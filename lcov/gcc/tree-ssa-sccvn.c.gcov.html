<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - gcc.info - gcc/tree-ssa-sccvn.c</title>
  <link rel="stylesheet" type="text/css" href="../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../index.html">top level</a> - <a href="index.html">gcc</a> - tree-ssa-sccvn.c<span style="font-size: 80%;"> (source / <a href="tree-ssa-sccvn.c.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">gcc.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">3132</td>
            <td class="headerCovTableEntry">3337</td>
            <td class="headerCovTableEntryHi">93.9 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2018-09-22 10:58:49</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">98</td>
            <td class="headerCovTableEntry">116</td>
            <td class="headerCovTableEntryMed">84.5 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /* SCC value numbering for trees</a>
<span class="lineNum">       2 </span>            :    Copyright (C) 2006-2018 Free Software Foundation, Inc.
<span class="lineNum">       3 </span>            :    Contributed by Daniel Berlin &lt;dan@dberlin.org&gt;
<span class="lineNum">       4 </span>            : 
<span class="lineNum">       5 </span>            : This file is part of GCC.
<span class="lineNum">       6 </span>            : 
<span class="lineNum">       7 </span>            : GCC is free software; you can redistribute it and/or modify
<span class="lineNum">       8 </span>            : it under the terms of the GNU General Public License as published by
<span class="lineNum">       9 </span>            : the Free Software Foundation; either version 3, or (at your option)
<span class="lineNum">      10 </span>            : any later version.
<span class="lineNum">      11 </span>            : 
<span class="lineNum">      12 </span>            : GCC is distributed in the hope that it will be useful,
<span class="lineNum">      13 </span>            : but WITHOUT ANY WARRANTY; without even the implied warranty of
<span class="lineNum">      14 </span>            : MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
<span class="lineNum">      15 </span>            : GNU General Public License for more details.
<span class="lineNum">      16 </span>            : 
<span class="lineNum">      17 </span>            : You should have received a copy of the GNU General Public License
<span class="lineNum">      18 </span>            : along with GCC; see the file COPYING3.  If not see
<span class="lineNum">      19 </span>            : &lt;http://www.gnu.org/licenses/&gt;.  */
<span class="lineNum">      20 </span>            : 
<span class="lineNum">      21 </span>            : #include &quot;config.h&quot;
<span class="lineNum">      22 </span>            : #include &quot;system.h&quot;
<span class="lineNum">      23 </span>            : #include &quot;coretypes.h&quot;
<span class="lineNum">      24 </span>            : #include &quot;backend.h&quot;
<span class="lineNum">      25 </span>            : #include &quot;rtl.h&quot;
<span class="lineNum">      26 </span>            : #include &quot;tree.h&quot;
<span class="lineNum">      27 </span>            : #include &quot;gimple.h&quot;
<span class="lineNum">      28 </span>            : #include &quot;ssa.h&quot;
<span class="lineNum">      29 </span>            : #include &quot;expmed.h&quot;
<span class="lineNum">      30 </span>            : #include &quot;insn-config.h&quot;
<span class="lineNum">      31 </span>            : #include &quot;memmodel.h&quot;
<span class="lineNum">      32 </span>            : #include &quot;emit-rtl.h&quot;
<span class="lineNum">      33 </span>            : #include &quot;cgraph.h&quot;
<span class="lineNum">      34 </span>            : #include &quot;gimple-pretty-print.h&quot;
<span class="lineNum">      35 </span>            : #include &quot;alias.h&quot;
<span class="lineNum">      36 </span>            : #include &quot;fold-const.h&quot;
<span class="lineNum">      37 </span>            : #include &quot;stor-layout.h&quot;
<span class="lineNum">      38 </span>            : #include &quot;cfganal.h&quot;
<span class="lineNum">      39 </span>            : #include &quot;tree-inline.h&quot;
<span class="lineNum">      40 </span>            : #include &quot;internal-fn.h&quot;
<span class="lineNum">      41 </span>            : #include &quot;gimple-fold.h&quot;
<span class="lineNum">      42 </span>            : #include &quot;tree-eh.h&quot;
<span class="lineNum">      43 </span>            : #include &quot;gimplify.h&quot;
<span class="lineNum">      44 </span>            : #include &quot;flags.h&quot;
<span class="lineNum">      45 </span>            : #include &quot;dojump.h&quot;
<span class="lineNum">      46 </span>            : #include &quot;explow.h&quot;
<span class="lineNum">      47 </span>            : #include &quot;calls.h&quot;
<span class="lineNum">      48 </span>            : #include &quot;varasm.h&quot;
<span class="lineNum">      49 </span>            : #include &quot;stmt.h&quot;
<span class="lineNum">      50 </span>            : #include &quot;expr.h&quot;
<span class="lineNum">      51 </span>            : #include &quot;tree-dfa.h&quot;
<span class="lineNum">      52 </span>            : #include &quot;tree-ssa.h&quot;
<span class="lineNum">      53 </span>            : #include &quot;dumpfile.h&quot;
<span class="lineNum">      54 </span>            : #include &quot;cfgloop.h&quot;
<span class="lineNum">      55 </span>            : #include &quot;params.h&quot;
<span class="lineNum">      56 </span>            : #include &quot;tree-ssa-propagate.h&quot;
<span class="lineNum">      57 </span>            : #include &quot;tree-cfg.h&quot;
<span class="lineNum">      58 </span>            : #include &quot;domwalk.h&quot;
<span class="lineNum">      59 </span>            : #include &quot;gimple-iterator.h&quot;
<span class="lineNum">      60 </span>            : #include &quot;gimple-match.h&quot;
<span class="lineNum">      61 </span>            : #include &quot;stringpool.h&quot;
<span class="lineNum">      62 </span>            : #include &quot;attribs.h&quot;
<span class="lineNum">      63 </span>            : #include &quot;tree-pass.h&quot;
<span class="lineNum">      64 </span>            : #include &quot;statistics.h&quot;
<span class="lineNum">      65 </span>            : #include &quot;langhooks.h&quot;
<span class="lineNum">      66 </span>            : #include &quot;ipa-utils.h&quot;
<span class="lineNum">      67 </span>            : #include &quot;dbgcnt.h&quot;
<span class="lineNum">      68 </span>            : #include &quot;tree-cfgcleanup.h&quot;
<span class="lineNum">      69 </span>            : #include &quot;tree-ssa-loop.h&quot;
<span class="lineNum">      70 </span>            : #include &quot;tree-scalar-evolution.h&quot;
<span class="lineNum">      71 </span>            : #include &quot;tree-ssa-sccvn.h&quot;
<span class="lineNum">      72 </span>            : 
<span class="lineNum">      73 </span>            : /* This algorithm is based on the SCC algorithm presented by Keith
<span class="lineNum">      74 </span>            :    Cooper and L. Taylor Simpson in &quot;SCC-Based Value numbering&quot;
<span class="lineNum">      75 </span>            :    (http://citeseer.ist.psu.edu/41805.html).  In
<span class="lineNum">      76 </span>            :    straight line code, it is equivalent to a regular hash based value
<span class="lineNum">      77 </span>            :    numbering that is performed in reverse postorder.
<span class="lineNum">      78 </span>            : 
<span class="lineNum">      79 </span>            :    For code with cycles, there are two alternatives, both of which
<span class="lineNum">      80 </span>            :    require keeping the hashtables separate from the actual list of
<span class="lineNum">      81 </span>            :    value numbers for SSA names.
<span class="lineNum">      82 </span>            : 
<span class="lineNum">      83 </span>            :    1. Iterate value numbering in an RPO walk of the blocks, removing
<span class="lineNum">      84 </span>            :    all the entries from the hashtable after each iteration (but
<span class="lineNum">      85 </span>            :    keeping the SSA name-&gt;value number mapping between iterations).
<span class="lineNum">      86 </span>            :    Iterate until it does not change.
<span class="lineNum">      87 </span>            : 
<span class="lineNum">      88 </span>            :    2. Perform value numbering as part of an SCC walk on the SSA graph,
<span class="lineNum">      89 </span>            :    iterating only the cycles in the SSA graph until they do not change
<span class="lineNum">      90 </span>            :    (using a separate, optimistic hashtable for value numbering the SCC
<span class="lineNum">      91 </span>            :    operands).
<span class="lineNum">      92 </span>            : 
<span class="lineNum">      93 </span>            :    The second is not just faster in practice (because most SSA graph
<span class="lineNum">      94 </span>            :    cycles do not involve all the variables in the graph), it also has
<span class="lineNum">      95 </span>            :    some nice properties.
<span class="lineNum">      96 </span>            : 
<span class="lineNum">      97 </span>            :    One of these nice properties is that when we pop an SCC off the
<span class="lineNum">      98 </span>            :    stack, we are guaranteed to have processed all the operands coming from
<span class="lineNum">      99 </span>            :    *outside of that SCC*, so we do not need to do anything special to
<span class="lineNum">     100 </span>            :    ensure they have value numbers.
<span class="lineNum">     101 </span>            : 
<span class="lineNum">     102 </span>            :    Another nice property is that the SCC walk is done as part of a DFS
<span class="lineNum">     103 </span>            :    of the SSA graph, which makes it easy to perform combining and
<span class="lineNum">     104 </span>            :    simplifying operations at the same time.
<span class="lineNum">     105 </span>            : 
<span class="lineNum">     106 </span>            :    The code below is deliberately written in a way that makes it easy
<span class="lineNum">     107 </span>            :    to separate the SCC walk from the other work it does.
<span class="lineNum">     108 </span>            : 
<span class="lineNum">     109 </span>            :    In order to propagate constants through the code, we track which
<span class="lineNum">     110 </span>            :    expressions contain constants, and use those while folding.  In
<span class="lineNum">     111 </span>            :    theory, we could also track expressions whose value numbers are
<span class="lineNum">     112 </span>            :    replaced, in case we end up folding based on expression
<span class="lineNum">     113 </span>            :    identities.
<span class="lineNum">     114 </span>            : 
<span class="lineNum">     115 </span>            :    In order to value number memory, we assign value numbers to vuses.
<span class="lineNum">     116 </span>            :    This enables us to note that, for example, stores to the same
<span class="lineNum">     117 </span>            :    address of the same value from the same starting memory states are
<span class="lineNum">     118 </span>            :    equivalent.
<span class="lineNum">     119 </span>            :    TODO:
<span class="lineNum">     120 </span>            : 
<span class="lineNum">     121 </span>            :    1. We can iterate only the changing portions of the SCC's, but
<span class="lineNum">     122 </span>            :    I have not seen an SCC big enough for this to be a win.
<span class="lineNum">     123 </span>            :    2. If you differentiate between phi nodes for loops and phi nodes
<span class="lineNum">     124 </span>            :    for if-then-else, you can properly consider phi nodes in different
<span class="lineNum">     125 </span>            :    blocks for equivalence.
<span class="lineNum">     126 </span>            :    3. We could value number vuses in more cases, particularly, whole
<span class="lineNum">     127 </span>            :    structure copies.
<span class="lineNum">     128 </span>            : */
<span class="lineNum">     129 </span>            : 
<span class="lineNum">     130 </span>            : /* There's no BB_EXECUTABLE but we can use BB_VISITED.  */
<span class="lineNum">     131 </span>            : #define BB_EXECUTABLE BB_VISITED
<span class="lineNum">     132 </span>            : 
<span class="lineNum">     133 </span>            : static tree *last_vuse_ptr;
<span class="lineNum">     134 </span>            : static vn_lookup_kind vn_walk_kind;
<span class="lineNum">     135 </span>            : static vn_lookup_kind default_vn_walk_kind;
<span class="lineNum">     136 </span>            : 
<span class="lineNum">     137 </span>            : /* vn_nary_op hashtable helpers.  */
<span class="lineNum">     138 </span>            : 
<span class="lineNum">     139 </span>            : struct vn_nary_op_hasher : nofree_ptr_hash &lt;vn_nary_op_s&gt;
<span class="lineNum">     140 </span>            : {
<span class="lineNum">     141 </span>            :   typedef vn_nary_op_s *compare_type;
<span class="lineNum">     142 </span>            :   static inline hashval_t hash (const vn_nary_op_s *);
<span class="lineNum">     143 </span>            :   static inline bool equal (const vn_nary_op_s *, const vn_nary_op_s *);
<span class="lineNum">     144 </span>            : };
<span class="lineNum">     145 </span>            : 
<span class="lineNum">     146 </span>            : /* Return the computed hashcode for nary operation P1.  */
<a name="147"><span class="lineNum">     147 </span>            : </a>
<span class="lineNum">     148 </span>            : inline hashval_t
<span class="lineNum">     149 </span><span class="lineNoCov">          0 : vn_nary_op_hasher::hash (const vn_nary_op_s *vno1)</span>
<span class="lineNum">     150 </span>            : {
<span class="lineNum">     151 </span><span class="lineCov">    6974556 :   return vno1-&gt;hashcode;</span>
<span class="lineNum">     152 </span>            : }
<span class="lineNum">     153 </span>            : 
<span class="lineNum">     154 </span>            : /* Compare nary operations P1 and P2 and return true if they are
<span class="lineNum">     155 </span>            :    equivalent.  */
<span class="lineNum">     156 </span>            : 
<span class="lineNum">     157 </span>            : inline bool
<span class="lineNum">     158 </span>            : vn_nary_op_hasher::equal (const vn_nary_op_s *vno1, const vn_nary_op_s *vno2)
<span class="lineNum">     159 </span>            : {
<span class="lineNum">     160 </span><span class="lineCov">  111595983 :   return vno1 == vno2 || vn_nary_op_eq (vno1, vno2);</span>
<span class="lineNum">     161 </span>            : }
<span class="lineNum">     162 </span>            : 
<span class="lineNum">     163 </span>            : typedef hash_table&lt;vn_nary_op_hasher&gt; vn_nary_op_table_type;
<span class="lineNum">     164 </span>            : typedef vn_nary_op_table_type::iterator vn_nary_op_iterator_type;
<span class="lineNum">     165 </span>            : 
<span class="lineNum">     166 </span>            : 
<span class="lineNum">     167 </span>            : /* vn_phi hashtable helpers.  */
<span class="lineNum">     168 </span>            : 
<span class="lineNum">     169 </span>            : static int
<span class="lineNum">     170 </span>            : vn_phi_eq (const_vn_phi_t const vp1, const_vn_phi_t const vp2);
<span class="lineNum">     171 </span>            : 
<span class="lineNum">     172 </span>            : struct vn_phi_hasher : nofree_ptr_hash &lt;vn_phi_s&gt;
<span class="lineNum">     173 </span>            : { 
<span class="lineNum">     174 </span>            :   static inline hashval_t hash (const vn_phi_s *);
<span class="lineNum">     175 </span>            :   static inline bool equal (const vn_phi_s *, const vn_phi_s *);
<span class="lineNum">     176 </span>            : };
<span class="lineNum">     177 </span>            : 
<span class="lineNum">     178 </span>            : /* Return the computed hashcode for phi operation P1.  */
<a name="179"><span class="lineNum">     179 </span>            : </a>
<span class="lineNum">     180 </span>            : inline hashval_t
<span class="lineNum">     181 </span><span class="lineNoCov">          0 : vn_phi_hasher::hash (const vn_phi_s *vp1)</span>
<span class="lineNum">     182 </span>            : {
<span class="lineNum">     183 </span><span class="lineCov">          6 :   return vp1-&gt;hashcode;</span>
<span class="lineNum">     184 </span>            : }
<span class="lineNum">     185 </span>            : 
<span class="lineNum">     186 </span>            : /* Compare two phi entries for equality, ignoring VN_TOP arguments.  */
<span class="lineNum">     187 </span>            : 
<span class="lineNum">     188 </span>            : inline bool
<span class="lineNum">     189 </span>            : vn_phi_hasher::equal (const vn_phi_s *vp1, const vn_phi_s *vp2)
<span class="lineNum">     190 </span>            : {
<span class="lineNum">     191 </span><span class="lineCov">   62313153 :   return vp1 == vp2 || vn_phi_eq (vp1, vp2);</span>
<span class="lineNum">     192 </span>            : }
<span class="lineNum">     193 </span>            : 
<span class="lineNum">     194 </span>            : typedef hash_table&lt;vn_phi_hasher&gt; vn_phi_table_type;
<span class="lineNum">     195 </span>            : typedef vn_phi_table_type::iterator vn_phi_iterator_type;
<span class="lineNum">     196 </span>            : 
<span class="lineNum">     197 </span>            : 
<span class="lineNum">     198 </span>            : /* Compare two reference operands P1 and P2 for equality.  Return true if
<span class="lineNum">     199 </span>            :    they are equal, and false otherwise.  */
<a name="200"><span class="lineNum">     200 </span>            : </a>
<span class="lineNum">     201 </span>            : static int
<span class="lineNum">     202 </span><span class="lineCov">    9911121 : vn_reference_op_eq (const void *p1, const void *p2)</span>
<span class="lineNum">     203 </span>            : {
<span class="lineNum">     204 </span><span class="lineCov">    9911121 :   const_vn_reference_op_t const vro1 = (const_vn_reference_op_t) p1;</span>
<span class="lineNum">     205 </span><span class="lineCov">    9911121 :   const_vn_reference_op_t const vro2 = (const_vn_reference_op_t) p2;</span>
<span class="lineNum">     206 </span>            : 
<span class="lineNum">     207 </span><span class="lineCov">    9911121 :   return (vro1-&gt;opcode == vro2-&gt;opcode</span>
<span class="lineNum">     208 </span>            :           /* We do not care for differences in type qualification.  */
<span class="lineNum">     209 </span><span class="lineCov">    9911121 :           &amp;&amp; (vro1-&gt;type == vro2-&gt;type</span>
<span class="lineNum">     210 </span><span class="lineCov">     703465 :               || (vro1-&gt;type &amp;&amp; vro2-&gt;type</span>
<span class="lineNum">     211 </span><span class="lineCov">     703465 :                   &amp;&amp; types_compatible_p (TYPE_MAIN_VARIANT (vro1-&gt;type),</span>
<span class="lineNum">     212 </span><span class="lineCov">     703465 :                                          TYPE_MAIN_VARIANT (vro2-&gt;type))))</span>
<span class="lineNum">     213 </span><span class="lineCov">    9257616 :           &amp;&amp; expressions_equal_p (vro1-&gt;op0, vro2-&gt;op0)</span>
<span class="lineNum">     214 </span><span class="lineCov">    9245786 :           &amp;&amp; expressions_equal_p (vro1-&gt;op1, vro2-&gt;op1)</span>
<span class="lineNum">     215 </span><span class="lineCov">   19156907 :           &amp;&amp; expressions_equal_p (vro1-&gt;op2, vro2-&gt;op2));</span>
<span class="lineNum">     216 </span>            : }
<span class="lineNum">     217 </span>            : 
<span class="lineNum">     218 </span>            : /* Free a reference operation structure VP.  */
<span class="lineNum">     219 </span>            : 
<span class="lineNum">     220 </span>            : static inline void
<span class="lineNum">     221 </span>            : free_reference (vn_reference_s *vr)
<span class="lineNum">     222 </span>            : {
<span class="lineNum">     223 </span><span class="lineNoCov">          0 :   vr-&gt;operands.release ();</span>
<span class="lineNum">     224 </span>            : }
<span class="lineNum">     225 </span>            : 
<span class="lineNum">     226 </span>            : 
<span class="lineNum">     227 </span>            : /* vn_reference hashtable helpers.  */
<span class="lineNum">     228 </span>            : 
<span class="lineNum">     229 </span>            : struct vn_reference_hasher : nofree_ptr_hash &lt;vn_reference_s&gt;
<span class="lineNum">     230 </span>            : {
<span class="lineNum">     231 </span>            :   static inline hashval_t hash (const vn_reference_s *);
<span class="lineNum">     232 </span>            :   static inline bool equal (const vn_reference_s *, const vn_reference_s *);
<span class="lineNum">     233 </span>            : };
<span class="lineNum">     234 </span>            : 
<span class="lineNum">     235 </span>            : /* Return the hashcode for a given reference operation P1.  */
<a name="236"><span class="lineNum">     236 </span>            : </a>
<span class="lineNum">     237 </span>            : inline hashval_t
<span class="lineNum">     238 </span><span class="lineNoCov">          0 : vn_reference_hasher::hash (const vn_reference_s *vr1)</span>
<span class="lineNum">     239 </span>            : {
<span class="lineNum">     240 </span><span class="lineCov">    3003001 :   return vr1-&gt;hashcode;</span>
<span class="lineNum">     241 </span>            : }
<span class="lineNum">     242 </span>            : 
<span class="lineNum">     243 </span>            : inline bool
<span class="lineNum">     244 </span>            : vn_reference_hasher::equal (const vn_reference_s *v, const vn_reference_s *c)
<span class="lineNum">     245 </span>            : {
<span class="lineNum">     246 </span><span class="lineCov">  429496891 :   return v == c || vn_reference_eq (v, c);</span>
<span class="lineNum">     247 </span>            : }
<span class="lineNum">     248 </span>            : 
<span class="lineNum">     249 </span>            : typedef hash_table&lt;vn_reference_hasher&gt; vn_reference_table_type;
<span class="lineNum">     250 </span>            : typedef vn_reference_table_type::iterator vn_reference_iterator_type;
<span class="lineNum">     251 </span>            : 
<span class="lineNum">     252 </span>            : 
<span class="lineNum">     253 </span>            : /* The set of VN hashtables.  */
<span class="lineNum">     254 </span>            : 
<span class="lineNum">     255 </span>            : typedef struct vn_tables_s
<span class="lineNum">     256 </span>            : {
<span class="lineNum">     257 </span>            :   vn_nary_op_table_type *nary;
<span class="lineNum">     258 </span>            :   vn_phi_table_type *phis;
<span class="lineNum">     259 </span>            :   vn_reference_table_type *references;
<span class="lineNum">     260 </span>            : } *vn_tables_t;
<span class="lineNum">     261 </span>            : 
<span class="lineNum">     262 </span>            : 
<span class="lineNum">     263 </span>            : /* vn_constant hashtable helpers.  */
<span class="lineNum">     264 </span>            : 
<span class="lineNum">     265 </span>            : struct vn_constant_hasher : free_ptr_hash &lt;vn_constant_s&gt;
<span class="lineNum">     266 </span>            : { 
<span class="lineNum">     267 </span>            :   static inline hashval_t hash (const vn_constant_s *);
<span class="lineNum">     268 </span>            :   static inline bool equal (const vn_constant_s *, const vn_constant_s *);
<span class="lineNum">     269 </span>            : };
<span class="lineNum">     270 </span>            : 
<span class="lineNum">     271 </span>            : /* Hash table hash function for vn_constant_t.  */
<a name="272"><span class="lineNum">     272 </span>            : </a>
<span class="lineNum">     273 </span>            : inline hashval_t
<span class="lineNum">     274 </span><span class="lineNoCov">          0 : vn_constant_hasher::hash (const vn_constant_s *vc1)</span>
<span class="lineNum">     275 </span>            : {
<span class="lineNum">     276 </span><span class="lineCov">    7142387 :   return vc1-&gt;hashcode;</span>
<span class="lineNum">     277 </span>            : }
<span class="lineNum">     278 </span>            : 
<span class="lineNum">     279 </span>            : /* Hash table equality function for vn_constant_t.  */
<a name="280"><span class="lineNum">     280 </span>            : </a>
<span class="lineNum">     281 </span>            : inline bool
<span class="lineNum">     282 </span><span class="lineNoCov">          0 : vn_constant_hasher::equal (const vn_constant_s *vc1, const vn_constant_s *vc2)</span>
<span class="lineNum">     283 </span>            : {
<span class="lineNum">     284 </span><span class="lineCov">    7037323 :   if (vc1-&gt;hashcode != vc2-&gt;hashcode)</span>
<span class="lineNum">     285 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">     286 </span>            : 
<span class="lineNum">     287 </span><span class="lineCov">    5250537 :   return vn_constant_eq_with_type (vc1-&gt;constant, vc2-&gt;constant);</span>
<span class="lineNum">     288 </span>            : }
<span class="lineNum">     289 </span>            : 
<span class="lineNum">     290 </span>            : static hash_table&lt;vn_constant_hasher&gt; *constant_to_value_id;
<span class="lineNum">     291 </span>            : static bitmap constant_value_ids;
<span class="lineNum">     292 </span>            : 
<span class="lineNum">     293 </span>            : 
<span class="lineNum">     294 </span>            : /* Obstack we allocate the vn-tables elements from.  */
<span class="lineNum">     295 </span>            : static obstack vn_tables_obstack;
<span class="lineNum">     296 </span>            : /* Special obstack we never unwind.  */
<span class="lineNum">     297 </span>            : static obstack vn_tables_insert_obstack;
<span class="lineNum">     298 </span>            : 
<span class="lineNum">     299 </span>            : static vn_reference_t last_inserted_ref;
<span class="lineNum">     300 </span>            : static vn_phi_t last_inserted_phi;
<span class="lineNum">     301 </span>            : static vn_nary_op_t last_inserted_nary;
<span class="lineNum">     302 </span>            : 
<span class="lineNum">     303 </span>            : /* Valid hashtables storing information we have proven to be
<span class="lineNum">     304 </span>            :    correct.  */
<span class="lineNum">     305 </span>            : static vn_tables_t valid_info;
<span class="lineNum">     306 </span>            : 
<span class="lineNum">     307 </span>            : 
<span class="lineNum">     308 </span>            : /* Valueization hook.  Valueize NAME if it is an SSA name, otherwise
<span class="lineNum">     309 </span>            :    just return it.  */
<span class="lineNum">     310 </span>            : tree (*vn_valueize) (tree);
<span class="lineNum">     311 </span>            : 
<span class="lineNum">     312 </span>            : 
<span class="lineNum">     313 </span>            : /* This represents the top of the VN lattice, which is the universal
<span class="lineNum">     314 </span>            :    value.  */
<span class="lineNum">     315 </span>            : 
<span class="lineNum">     316 </span>            : tree VN_TOP;
<span class="lineNum">     317 </span>            : 
<span class="lineNum">     318 </span>            : /* Unique counter for our value ids.  */
<span class="lineNum">     319 </span>            : 
<span class="lineNum">     320 </span>            : static unsigned int next_value_id;
<span class="lineNum">     321 </span>            : 
<span class="lineNum">     322 </span>            : 
<span class="lineNum">     323 </span>            : /* Table of vn_ssa_aux_t's, one per ssa_name.  The vn_ssa_aux_t objects
<span class="lineNum">     324 </span>            :    are allocated on an obstack for locality reasons, and to free them
<span class="lineNum">     325 </span>            :    without looping over the vec.  */
<span class="lineNum">     326 </span>            : 
<span class="lineNum">     327 </span>            : struct vn_ssa_aux_hasher : typed_noop_remove &lt;vn_ssa_aux_t&gt;
<span class="lineNum">     328 </span>            : {
<span class="lineNum">     329 </span>            :   typedef vn_ssa_aux_t value_type;
<span class="lineNum">     330 </span>            :   typedef tree compare_type;
<span class="lineNum">     331 </span>            :   static inline hashval_t hash (const value_type &amp;);
<span class="lineNum">     332 </span>            :   static inline bool equal (const value_type &amp;, const compare_type &amp;);
<a name="333"><span class="lineNum">     333 </span>            :   static inline void mark_deleted (value_type &amp;) {}</a>
<a name="334"><span class="lineNum">     334 </span><span class="lineCov">  273568354 :   static inline void mark_empty (value_type &amp;e) { e = NULL; }</span></a>
<span class="lineNum">     335 </span><span class="lineCov"> 2685628014 :   static inline bool is_deleted (value_type &amp;) { return false; }</span>
<span class="lineNum">     336 </span><span class="lineCov"> 3329392712 :   static inline bool is_empty (value_type &amp;e) { return e == NULL; }</span>
<span class="lineNum">     337 </span>            : };
<a name="338"><span class="lineNum">     338 </span>            : </a>
<span class="lineNum">     339 </span>            : hashval_t
<span class="lineNum">     340 </span><span class="lineNoCov">          0 : vn_ssa_aux_hasher::hash (const value_type &amp;entry)</span>
<span class="lineNum">     341 </span>            : {
<span class="lineNum">     342 </span><span class="lineNoCov">          0 :   return SSA_NAME_VERSION (entry-&gt;name);</span>
<span class="lineNum">     343 </span>            : }
<a name="344"><span class="lineNum">     344 </span>            : </a>
<span class="lineNum">     345 </span>            : bool
<span class="lineNum">     346 </span><span class="lineNoCov">          0 : vn_ssa_aux_hasher::equal (const value_type &amp;entry, const compare_type &amp;name)</span>
<span class="lineNum">     347 </span>            : {
<span class="lineNum">     348 </span><span class="lineCov"> 2685625658 :   return name == entry-&gt;name;</span>
<span class="lineNum">     349 </span>            : }
<span class="lineNum">     350 </span>            : 
<span class="lineNum">     351 </span>            : static hash_table&lt;vn_ssa_aux_hasher&gt; *vn_ssa_aux_hash;
<span class="lineNum">     352 </span>            : typedef hash_table&lt;vn_ssa_aux_hasher&gt;::iterator vn_ssa_aux_iterator_type;
<span class="lineNum">     353 </span>            : static struct obstack vn_ssa_aux_obstack;
<span class="lineNum">     354 </span>            : 
<span class="lineNum">     355 </span>            : static vn_nary_op_t vn_nary_op_insert_stmt (gimple *, tree);
<span class="lineNum">     356 </span>            : static unsigned int vn_nary_length_from_stmt (gimple *);
<span class="lineNum">     357 </span>            : static vn_nary_op_t alloc_vn_nary_op_noinit (unsigned int, obstack *);
<span class="lineNum">     358 </span>            : static vn_nary_op_t vn_nary_op_insert_into (vn_nary_op_t,
<span class="lineNum">     359 </span>            :                                             vn_nary_op_table_type *, bool);
<span class="lineNum">     360 </span>            : static void init_vn_nary_op_from_stmt (vn_nary_op_t, gimple *);
<span class="lineNum">     361 </span>            : static void init_vn_nary_op_from_pieces (vn_nary_op_t, unsigned int,
<span class="lineNum">     362 </span>            :                                          enum tree_code, tree, tree *);
<span class="lineNum">     363 </span>            : static tree vn_lookup_simplify_result (gimple_match_op *);
<span class="lineNum">     364 </span>            : 
<span class="lineNum">     365 </span>            : /* Return whether there is value numbering information for a given SSA name.  */
<a name="366"><span class="lineNum">     366 </span>            : </a>
<span class="lineNum">     367 </span>            : bool
<span class="lineNum">     368 </span><span class="lineCov">    2357164 : has_VN_INFO (tree name)</span>
<span class="lineNum">     369 </span>            : {
<span class="lineNum">     370 </span><span class="lineCov">    2357164 :   return vn_ssa_aux_hash-&gt;find_with_hash (name, SSA_NAME_VERSION (name));</span>
<span class="lineNum">     371 </span>            : }
<a name="372"><span class="lineNum">     372 </span>            : </a>
<span class="lineNum">     373 </span>            : vn_ssa_aux_t
<span class="lineNum">     374 </span><span class="lineCov"> 1254806834 : VN_INFO (tree name)</span>
<span class="lineNum">     375 </span>            : {
<span class="lineNum">     376 </span><span class="lineCov"> 1254806834 :   vn_ssa_aux_t *res</span>
<span class="lineNum">     377 </span><span class="lineCov"> 1254806834 :     = vn_ssa_aux_hash-&gt;find_slot_with_hash (name, SSA_NAME_VERSION (name),</span>
<span class="lineNum">     378 </span>            :                                             INSERT);
<span class="lineNum">     379 </span><span class="lineCov"> 1254806834 :   if (*res != NULL)</span>
<span class="lineNum">     380 </span>            :     return *res;
<span class="lineNum">     381 </span>            : 
<span class="lineNum">     382 </span><span class="lineCov">   74319719 :   vn_ssa_aux_t newinfo = *res = XOBNEW (&amp;vn_ssa_aux_obstack, struct vn_ssa_aux);</span>
<span class="lineNum">     383 </span><span class="lineCov">   74319719 :   memset (newinfo, 0, sizeof (struct vn_ssa_aux));</span>
<span class="lineNum">     384 </span><span class="lineCov">   74319719 :   newinfo-&gt;name = name;</span>
<span class="lineNum">     385 </span><span class="lineCov">   74319719 :   newinfo-&gt;valnum = VN_TOP;</span>
<span class="lineNum">     386 </span>            :   /* We are using the visited flag to handle uses with defs not within the
<span class="lineNum">     387 </span>            :      region being value-numbered.  */
<span class="lineNum">     388 </span><span class="lineCov">   74319719 :   newinfo-&gt;visited = false;</span>
<span class="lineNum">     389 </span>            : 
<span class="lineNum">     390 </span>            :   /* Given we create the VN_INFOs on-demand now we have to do initialization
<span class="lineNum">     391 </span>            :      different than VN_TOP here.  */
<span class="lineNum">     392 </span><span class="lineCov">   74319719 :   if (SSA_NAME_IS_DEFAULT_DEF (name))</span>
<span class="lineNum">     393 </span><span class="lineCov">    8951476 :     switch (TREE_CODE (SSA_NAME_VAR (name)))</span>
<span class="lineNum">     394 </span>            :       {
<span class="lineNum">     395 </span><span class="lineCov">     899742 :       case VAR_DECL:</span>
<span class="lineNum">     396 </span>            :         /* All undefined vars are VARYING.  */
<span class="lineNum">     397 </span><span class="lineCov">     899742 :         newinfo-&gt;valnum = name;</span>
<span class="lineNum">     398 </span><span class="lineCov">     899742 :         newinfo-&gt;visited = true;</span>
<span class="lineNum">     399 </span><span class="lineCov">     899742 :         break;</span>
<span class="lineNum">     400 </span>            : 
<span class="lineNum">     401 </span><span class="lineCov">    3546923 :       case PARM_DECL:</span>
<span class="lineNum">     402 </span>            :         /* Parameters are VARYING but we can record a condition
<span class="lineNum">     403 </span>            :            if we know it is a non-NULL pointer.  */
<span class="lineNum">     404 </span><span class="lineCov">    3546923 :         newinfo-&gt;visited = true;</span>
<span class="lineNum">     405 </span><span class="lineCov">    3546923 :         newinfo-&gt;valnum = name;</span>
<span class="lineNum">     406 </span><span class="lineCov">    7246969 :         if (POINTER_TYPE_P (TREE_TYPE (name))</span>
<span class="lineNum">     407 </span><span class="lineCov">    4106873 :             &amp;&amp; nonnull_arg_p (SSA_NAME_VAR (name)))</span>
<span class="lineNum">     408 </span>            :           {
<span class="lineNum">     409 </span><span class="lineCov">    1212369 :             tree ops[2];</span>
<span class="lineNum">     410 </span><span class="lineCov">    1212369 :             ops[0] = name;</span>
<span class="lineNum">     411 </span><span class="lineCov">    2424738 :             ops[1] = build_int_cst (TREE_TYPE (name), 0);</span>
<span class="lineNum">     412 </span><span class="lineCov">    1212369 :             vn_nary_op_t nary;</span>
<span class="lineNum">     413 </span>            :             /* Allocate from non-unwinding stack.  */
<span class="lineNum">     414 </span><span class="lineCov">    1212369 :             nary = alloc_vn_nary_op_noinit (2, &amp;vn_tables_insert_obstack);</span>
<span class="lineNum">     415 </span><span class="lineCov">    2424738 :             init_vn_nary_op_from_pieces (nary, 2, NE_EXPR,</span>
<span class="lineNum">     416 </span>            :                                          boolean_type_node, ops);
<span class="lineNum">     417 </span><span class="lineCov">    1212369 :             nary-&gt;predicated_values = 0;</span>
<span class="lineNum">     418 </span><span class="lineCov">    1212369 :             nary-&gt;u.result = boolean_true_node;</span>
<span class="lineNum">     419 </span><span class="lineCov">    1212369 :             vn_nary_op_insert_into (nary, valid_info-&gt;nary, true);</span>
<span class="lineNum">     420 </span><span class="lineCov">    1212369 :             gcc_assert (nary-&gt;unwind_to == NULL);</span>
<span class="lineNum">     421 </span>            :             /* Also do not link it into the undo chain.  */
<span class="lineNum">     422 </span><span class="lineCov">    1212369 :             last_inserted_nary = nary-&gt;next;</span>
<span class="lineNum">     423 </span><span class="lineCov">    1212369 :             nary-&gt;next = (vn_nary_op_t)(void *)-1;</span>
<span class="lineNum">     424 </span><span class="lineCov">    1212369 :             nary = alloc_vn_nary_op_noinit (2, &amp;vn_tables_insert_obstack);</span>
<span class="lineNum">     425 </span><span class="lineCov">    2424738 :             init_vn_nary_op_from_pieces (nary, 2, EQ_EXPR,</span>
<span class="lineNum">     426 </span>            :                                          boolean_type_node, ops);
<span class="lineNum">     427 </span><span class="lineCov">    1212369 :             nary-&gt;predicated_values = 0;</span>
<span class="lineNum">     428 </span><span class="lineCov">    1212369 :             nary-&gt;u.result = boolean_false_node;</span>
<span class="lineNum">     429 </span><span class="lineCov">    1212369 :             vn_nary_op_insert_into (nary, valid_info-&gt;nary, true);</span>
<span class="lineNum">     430 </span><span class="lineCov">    1212369 :             gcc_assert (nary-&gt;unwind_to == NULL);</span>
<span class="lineNum">     431 </span><span class="lineCov">    1212369 :             last_inserted_nary = nary-&gt;next;</span>
<span class="lineNum">     432 </span><span class="lineCov">    1212369 :             nary-&gt;next = (vn_nary_op_t)(void *)-1;</span>
<span class="lineNum">     433 </span><span class="lineCov">    1212369 :             if (dump_file &amp;&amp; (dump_flags &amp; TDF_DETAILS))</span>
<span class="lineNum">     434 </span>            :               {
<span class="lineNum">     435 </span><span class="lineCov">         13 :                 fprintf (dump_file, &quot;Recording &quot;);</span>
<span class="lineNum">     436 </span><span class="lineCov">         13 :                 print_generic_expr (dump_file, name, TDF_SLIM);</span>
<span class="lineNum">     437 </span><span class="lineCov">         13 :                 fprintf (dump_file, &quot; != 0\n&quot;);</span>
<span class="lineNum">     438 </span>            :               }
<span class="lineNum">     439 </span>            :           }
<span class="lineNum">     440 </span>            :         break;
<span class="lineNum">     441 </span>            : 
<span class="lineNum">     442 </span><span class="lineCov">      29073 :       case RESULT_DECL:</span>
<span class="lineNum">     443 </span>            :         /* If the result is passed by invisible reference the default
<span class="lineNum">     444 </span>            :            def is initialized, otherwise it's uninitialized.  Still
<span class="lineNum">     445 </span>            :            undefined is varying.  */
<span class="lineNum">     446 </span><span class="lineCov">      29073 :         newinfo-&gt;visited = true;</span>
<span class="lineNum">     447 </span><span class="lineCov">      29073 :         newinfo-&gt;valnum = name;</span>
<span class="lineNum">     448 </span><span class="lineCov">      29073 :         break;</span>
<span class="lineNum">     449 </span>            : 
<span class="lineNum">     450 </span><span class="lineNoCov">          0 :       default:</span>
<span class="lineNum">     451 </span><span class="lineNoCov">          0 :         gcc_unreachable ();</span>
<span class="lineNum">     452 </span>            :       }
<span class="lineNum">     453 </span>            :   return newinfo;
<span class="lineNum">     454 </span>            : }
<span class="lineNum">     455 </span>            : 
<span class="lineNum">     456 </span>            : /* Return the SSA value of X.  */
<a name="457"><span class="lineNum">     457 </span>            : </a>
<span class="lineNum">     458 </span>            : inline tree
<span class="lineNum">     459 </span><span class="lineCov"> 1523397567 : SSA_VAL (tree x, bool *visited = NULL)</span>
<span class="lineNum">     460 </span>            : {
<span class="lineNum">     461 </span><span class="lineCov"> 1523397567 :   vn_ssa_aux_t tem = vn_ssa_aux_hash-&gt;find_with_hash (x, SSA_NAME_VERSION (x));</span>
<span class="lineNum">     462 </span><span class="lineCov"> 1523397567 :   if (visited)</span>
<span class="lineNum">     463 </span><span class="lineCov">  602338317 :     *visited = tem &amp;&amp; tem-&gt;visited;</span>
<span class="lineNum">     464 </span><span class="lineCov"> 1523397567 :   return tem &amp;&amp; tem-&gt;visited ? tem-&gt;valnum : x;</span>
<span class="lineNum">     465 </span>            : }
<span class="lineNum">     466 </span>            : 
<span class="lineNum">     467 </span>            : /* Return whether X was visited.  */
<span class="lineNum">     468 </span>            : 
<span class="lineNum">     469 </span>            : inline bool
<span class="lineNum">     470 </span>            : SSA_VISITED (tree x)
<span class="lineNum">     471 </span>            : {
<span class="lineNum">     472 </span>            :   vn_ssa_aux_t tem = vn_ssa_aux_hash-&gt;find_with_hash (x, SSA_NAME_VERSION (x));
<span class="lineNum">     473 </span>            :   return tem &amp;&amp; tem-&gt;visited;
<span class="lineNum">     474 </span>            : }
<span class="lineNum">     475 </span>            : 
<span class="lineNum">     476 </span>            : /* Return the SSA value of the VUSE x, supporting released VDEFs
<span class="lineNum">     477 </span>            :    during elimination which will value-number the VDEF to the
<span class="lineNum">     478 </span>            :    associated VUSE (but not substitute in the whole lattice).  */
<a name="479"><span class="lineNum">     479 </span>            : </a>
<span class="lineNum">     480 </span>            : static inline tree
<span class="lineNum">     481 </span><span class="lineCov">  603162186 : vuse_ssa_val (tree x)</span>
<span class="lineNum">     482 </span>            : {
<span class="lineNum">     483 </span><span class="lineCov">  603162186 :   if (!x)</span>
<span class="lineNum">     484 </span>            :     return NULL_TREE;
<span class="lineNum">     485 </span>            : 
<span class="lineNum">     486 </span><span class="lineCov">  600718473 :   do</span>
<span class="lineNum">     487 </span>            :     {
<span class="lineNum">     488 </span><span class="lineCov">  600718473 :       x = SSA_VAL (x);</span>
<span class="lineNum">     489 </span><span class="lineCov">  600718473 :       gcc_assert (x != VN_TOP);</span>
<span class="lineNum">     490 </span>            :     }
<span class="lineNum">     491 </span><span class="lineCov">  600718473 :   while (SSA_NAME_IN_FREE_LIST (x));</span>
<span class="lineNum">     492 </span>            : 
<span class="lineNum">     493 </span>            :   return x;
<span class="lineNum">     494 </span>            : }
<span class="lineNum">     495 </span>            : 
<span class="lineNum">     496 </span>            : /* Similar to the above but used as callback for walk_non_aliases_vuses
<span class="lineNum">     497 </span>            :    and thus should stop at unvisited VUSE to not walk across region
<span class="lineNum">     498 </span>            :    boundaries.  */
<a name="499"><span class="lineNum">     499 </span>            : </a>
<span class="lineNum">     500 </span>            : static tree
<span class="lineNum">     501 </span><span class="lineCov">  514650625 : vuse_valueize (tree vuse)</span>
<span class="lineNum">     502 </span>            : {
<span class="lineNum">     503 </span><span class="lineCov">  514650656 :   do</span>
<span class="lineNum">     504 </span>            :     {
<span class="lineNum">     505 </span><span class="lineCov">  514650656 :       bool visited;</span>
<span class="lineNum">     506 </span><span class="lineCov">  514650656 :       vuse = SSA_VAL (vuse, &amp;visited);</span>
<span class="lineNum">     507 </span><span class="lineCov">  514650656 :       if (!visited)</span>
<span class="lineNum">     508 </span><span class="lineCov">    5488822 :         return NULL_TREE;</span>
<span class="lineNum">     509 </span><span class="lineCov">  509161834 :       gcc_assert (vuse != VN_TOP);</span>
<span class="lineNum">     510 </span>            :     }
<span class="lineNum">     511 </span><span class="lineCov">  509161834 :   while (SSA_NAME_IN_FREE_LIST (vuse));</span>
<span class="lineNum">     512 </span>            :   return vuse;
<span class="lineNum">     513 </span>            : }
<span class="lineNum">     514 </span>            : 
<span class="lineNum">     515 </span>            : 
<span class="lineNum">     516 </span>            : /* Return the vn_kind the expression computed by the stmt should be
<span class="lineNum">     517 </span>            :    associated with.  */
<a name="518"><span class="lineNum">     518 </span>            : </a>
<span class="lineNum">     519 </span>            : enum vn_kind
<span class="lineNum">     520 </span><span class="lineCov">   46175214 : vn_get_stmt_kind (gimple *stmt)</span>
<span class="lineNum">     521 </span>            : {
<span class="lineNum">     522 </span><span class="lineCov">   92350428 :   switch (gimple_code (stmt))</span>
<span class="lineNum">     523 </span>            :     {
<span class="lineNum">     524 </span>            :     case GIMPLE_CALL:
<span class="lineNum">     525 </span>            :       return VN_REFERENCE;
<span class="lineNum">     526 </span><span class="lineNoCov">          0 :     case GIMPLE_PHI:</span>
<span class="lineNum">     527 </span><span class="lineNoCov">          0 :       return VN_PHI;</span>
<span class="lineNum">     528 </span><span class="lineCov">   46175214 :     case GIMPLE_ASSIGN:</span>
<span class="lineNum">     529 </span><span class="lineCov">   46175214 :       {</span>
<span class="lineNum">     530 </span><span class="lineCov">   46175214 :         enum tree_code code = gimple_assign_rhs_code (stmt);</span>
<span class="lineNum">     531 </span><span class="lineCov">   46175214 :         tree rhs1 = gimple_assign_rhs1 (stmt);</span>
<span class="lineNum">     532 </span><span class="lineCov">   92350428 :         switch (get_gimple_rhs_class (code))</span>
<span class="lineNum">     533 </span>            :           {
<span class="lineNum">     534 </span>            :           case GIMPLE_UNARY_RHS:
<span class="lineNum">     535 </span>            :           case GIMPLE_BINARY_RHS:
<span class="lineNum">     536 </span>            :           case GIMPLE_TERNARY_RHS:
<span class="lineNum">     537 </span>            :             return VN_NARY;
<span class="lineNum">     538 </span><span class="lineCov">   21648394 :           case GIMPLE_SINGLE_RHS:</span>
<span class="lineNum">     539 </span><span class="lineCov">   21648394 :             switch (TREE_CODE_CLASS (code))</span>
<span class="lineNum">     540 </span>            :               {
<span class="lineNum">     541 </span><span class="lineCov">   15313526 :               case tcc_reference:</span>
<span class="lineNum">     542 </span>            :                 /* VOP-less references can go through unary case.  */
<span class="lineNum">     543 </span><span class="lineCov">   15313526 :                 if ((code == REALPART_EXPR</span>
<span class="lineNum">     544 </span>            :                      || code == IMAGPART_EXPR
<span class="lineNum">     545 </span>            :                      || code == VIEW_CONVERT_EXPR
<span class="lineNum">     546 </span><span class="lineCov">   15313526 :                      || code == BIT_FIELD_REF)</span>
<span class="lineNum">     547 </span><span class="lineCov">   15313526 :                     &amp;&amp; TREE_CODE (TREE_OPERAND (rhs1, 0)) == SSA_NAME)</span>
<span class="lineNum">     548 </span><span class="lineCov">     891225 :                   return VN_NARY;</span>
<span class="lineNum">     549 </span>            : 
<span class="lineNum">     550 </span>            :                 /* Fallthrough.  */
<span class="lineNum">     551 </span>            :               case tcc_declaration:
<span class="lineNum">     552 </span>            :                 return VN_REFERENCE;
<span class="lineNum">     553 </span>            : 
<span class="lineNum">     554 </span>            :               case tcc_constant:
<span class="lineNum">     555 </span>            :                 return VN_CONSTANT;
<span class="lineNum">     556 </span>            : 
<span class="lineNum">     557 </span><span class="lineCov">    3417468 :               default:</span>
<span class="lineNum">     558 </span><span class="lineCov">    3417468 :                 if (code == ADDR_EXPR)</span>
<span class="lineNum">     559 </span><span class="lineCov">    1922756 :                   return (is_gimple_min_invariant (rhs1)</span>
<span class="lineNum">     560 </span><span class="lineCov">    1922756 :                           ? VN_CONSTANT : VN_REFERENCE);</span>
<span class="lineNum">     561 </span><span class="lineCov">    1494712 :                 else if (code == CONSTRUCTOR)</span>
<span class="lineNum">     562 </span><span class="lineCov">      63538 :                   return VN_NARY;</span>
<span class="lineNum">     563 </span>            :                 return VN_NONE;
<span class="lineNum">     564 </span>            :               }
<span class="lineNum">     565 </span><span class="lineNoCov">          0 :           default:</span>
<span class="lineNum">     566 </span><span class="lineNoCov">          0 :             return VN_NONE;</span>
<span class="lineNum">     567 </span>            :           }
<span class="lineNum">     568 </span>            :       }
<span class="lineNum">     569 </span><span class="lineNoCov">          0 :     default:</span>
<span class="lineNum">     570 </span><span class="lineNoCov">          0 :       return VN_NONE;</span>
<span class="lineNum">     571 </span>            :     }
<span class="lineNum">     572 </span>            : }
<span class="lineNum">     573 </span>            : 
<span class="lineNum">     574 </span>            : /* Lookup a value id for CONSTANT and return it.  If it does not
<span class="lineNum">     575 </span>            :    exist returns 0.  */
<a name="576"><span class="lineNum">     576 </span>            : </a>
<span class="lineNum">     577 </span>            : unsigned int
<span class="lineNum">     578 </span><span class="lineCov">    3884263 : get_constant_value_id (tree constant)</span>
<span class="lineNum">     579 </span>            : {
<span class="lineNum">     580 </span><span class="lineCov">    3884263 :   vn_constant_s **slot;</span>
<span class="lineNum">     581 </span><span class="lineCov">    3884263 :   struct vn_constant_s vc;</span>
<span class="lineNum">     582 </span>            : 
<span class="lineNum">     583 </span><span class="lineCov">    3884263 :   vc.hashcode = vn_hash_constant_with_type (constant);</span>
<span class="lineNum">     584 </span><span class="lineCov">    3884263 :   vc.constant = constant;</span>
<span class="lineNum">     585 </span><span class="lineCov">    3884263 :   slot = constant_to_value_id-&gt;find_slot (&amp;vc, NO_INSERT);</span>
<span class="lineNum">     586 </span><span class="lineCov">    3884263 :   if (slot)</span>
<span class="lineNum">     587 </span><span class="lineCov">    3884263 :     return (*slot)-&gt;value_id;</span>
<span class="lineNum">     588 </span>            :   return 0;
<span class="lineNum">     589 </span>            : }
<span class="lineNum">     590 </span>            : 
<span class="lineNum">     591 </span>            : /* Lookup a value id for CONSTANT, and if it does not exist, create a
<span class="lineNum">     592 </span>            :    new one and return it.  If it does exist, return it.  */
<a name="593"><span class="lineNum">     593 </span>            : </a>
<span class="lineNum">     594 </span>            : unsigned int
<span class="lineNum">     595 </span><span class="lineCov">   15370160 : get_or_alloc_constant_value_id (tree constant)</span>
<span class="lineNum">     596 </span>            : {
<span class="lineNum">     597 </span><span class="lineCov">   15370160 :   vn_constant_s **slot;</span>
<span class="lineNum">     598 </span><span class="lineCov">   15370160 :   struct vn_constant_s vc;</span>
<span class="lineNum">     599 </span><span class="lineCov">   15370160 :   vn_constant_t vcp;</span>
<span class="lineNum">     600 </span>            : 
<span class="lineNum">     601 </span>            :   /* If the hashtable isn't initialized we're not running from PRE and thus
<span class="lineNum">     602 </span>            :      do not need value-ids.  */
<span class="lineNum">     603 </span><span class="lineCov">   15370160 :   if (!constant_to_value_id)</span>
<span class="lineNum">     604 </span>            :     return 0;
<span class="lineNum">     605 </span>            : 
<span class="lineNum">     606 </span><span class="lineCov">    2884888 :   vc.hashcode = vn_hash_constant_with_type (constant);</span>
<span class="lineNum">     607 </span><span class="lineCov">    2884888 :   vc.constant = constant;</span>
<span class="lineNum">     608 </span><span class="lineCov">    2884888 :   slot = constant_to_value_id-&gt;find_slot (&amp;vc, INSERT);</span>
<span class="lineNum">     609 </span><span class="lineCov">    2884888 :   if (*slot)</span>
<span class="lineNum">     610 </span><span class="lineCov">    1322109 :     return (*slot)-&gt;value_id;</span>
<span class="lineNum">     611 </span>            : 
<span class="lineNum">     612 </span><span class="lineCov">    1562779 :   vcp = XNEW (struct vn_constant_s);</span>
<span class="lineNum">     613 </span><span class="lineCov">    1562779 :   vcp-&gt;hashcode = vc.hashcode;</span>
<span class="lineNum">     614 </span><span class="lineCov">    1562779 :   vcp-&gt;constant = constant;</span>
<span class="lineNum">     615 </span><span class="lineCov">    1562779 :   vcp-&gt;value_id = get_next_value_id ();</span>
<span class="lineNum">     616 </span><span class="lineCov">    1562779 :   *slot = vcp;</span>
<span class="lineNum">     617 </span><span class="lineCov">    1562779 :   bitmap_set_bit (constant_value_ids, vcp-&gt;value_id);</span>
<span class="lineNum">     618 </span><span class="lineCov">    1562779 :   return vcp-&gt;value_id;</span>
<span class="lineNum">     619 </span>            : }
<span class="lineNum">     620 </span>            : 
<span class="lineNum">     621 </span>            : /* Return true if V is a value id for a constant.  */
<a name="622"><span class="lineNum">     622 </span>            : </a>
<span class="lineNum">     623 </span>            : bool
<span class="lineNum">     624 </span><span class="lineCov">  450649791 : value_id_constant_p (unsigned int v)</span>
<span class="lineNum">     625 </span>            : {
<span class="lineNum">     626 </span><span class="lineCov">  450649791 :   return bitmap_bit_p (constant_value_ids, v);</span>
<span class="lineNum">     627 </span>            : }
<span class="lineNum">     628 </span>            : 
<span class="lineNum">     629 </span>            : /* Compute the hash for a reference operand VRO1.  */
<a name="630"><span class="lineNum">     630 </span>            : </a>
<span class="lineNum">     631 </span>            : static void
<span class="lineNum">     632 </span><span class="lineCov">   60915371 : vn_reference_op_compute_hash (const vn_reference_op_t vro1, inchash::hash &amp;hstate)</span>
<span class="lineNum">     633 </span>            : {
<span class="lineNum">     634 </span><span class="lineCov">   60915371 :   hstate.add_int (vro1-&gt;opcode);</span>
<span class="lineNum">     635 </span><span class="lineCov">   60915371 :   if (vro1-&gt;op0)</span>
<span class="lineNum">     636 </span><span class="lineCov">   58494183 :     inchash::add_expr (vro1-&gt;op0, hstate);</span>
<span class="lineNum">     637 </span><span class="lineCov">   60915371 :   if (vro1-&gt;op1)</span>
<span class="lineNum">     638 </span><span class="lineCov">    4711755 :     inchash::add_expr (vro1-&gt;op1, hstate);</span>
<span class="lineNum">     639 </span><span class="lineCov">   60915371 :   if (vro1-&gt;op2)</span>
<span class="lineNum">     640 </span><span class="lineCov">    5302483 :     inchash::add_expr (vro1-&gt;op2, hstate);</span>
<span class="lineNum">     641 </span><span class="lineCov">   60915371 : }</span>
<span class="lineNum">     642 </span>            : 
<span class="lineNum">     643 </span>            : /* Compute a hash for the reference operation VR1 and return it.  */
<a name="644"><span class="lineNum">     644 </span>            : </a>
<span class="lineNum">     645 </span>            : static hashval_t
<span class="lineNum">     646 </span><span class="lineCov">   89719413 : vn_reference_compute_hash (const vn_reference_t vr1)</span>
<span class="lineNum">     647 </span>            : {
<span class="lineNum">     648 </span><span class="lineCov">   89719413 :   inchash::hash hstate;</span>
<span class="lineNum">     649 </span><span class="lineCov">   89719413 :   hashval_t result;</span>
<span class="lineNum">     650 </span><span class="lineCov">   89719413 :   int i;</span>
<span class="lineNum">     651 </span><span class="lineCov">   89719413 :   vn_reference_op_t vro;</span>
<span class="lineNum">     652 </span><span class="lineCov">   89719413 :   poly_int64 off = -1;</span>
<span class="lineNum">     653 </span><span class="lineCov">   89719413 :   bool deref = false;</span>
<span class="lineNum">     654 </span>            : 
<span class="lineNum">     655 </span><span class="lineCov">  354658138 :   FOR_EACH_VEC_ELT (vr1-&gt;operands, i, vro)</span>
<span class="lineNum">     656 </span>            :     {
<span class="lineNum">     657 </span><span class="lineCov">  264938725 :       if (vro-&gt;opcode == MEM_REF)</span>
<span class="lineNum">     658 </span>            :         deref = true;
<span class="lineNum">     659 </span><span class="lineCov">  179098984 :       else if (vro-&gt;opcode != ADDR_EXPR)</span>
<span class="lineNum">     660 </span><span class="lineCov">  119545678 :         deref = false;</span>
<span class="lineNum">     661 </span><span class="lineCov">  264938725 :       if (maybe_ne (vro-&gt;off, -1))</span>
<span class="lineNum">     662 </span>            :         {
<span class="lineNum">     663 </span><span class="lineCov">  149341345 :           if (known_eq (off, -1))</span>
<span class="lineNum">     664 </span><span class="lineCov">  173626276 :             off = 0;</span>
<span class="lineNum">     665 </span><span class="lineCov">  149341345 :           off += vro-&gt;off;</span>
<span class="lineNum">     666 </span>            :         }
<span class="lineNum">     667 </span>            :       else
<span class="lineNum">     668 </span>            :         {
<span class="lineNum">     669 </span><span class="lineCov">  115597380 :           if (maybe_ne (off, -1)</span>
<span class="lineNum">     670 </span><span class="lineCov">  115597380 :               &amp;&amp; maybe_ne (off, 0))</span>
<span class="lineNum">     671 </span>            :             hstate.add_poly_int (off);
<span class="lineNum">     672 </span><span class="lineCov">  115597380 :           off = -1;</span>
<span class="lineNum">     673 </span><span class="lineCov">  115597380 :           if (deref</span>
<span class="lineNum">     674 </span><span class="lineCov">   54742293 :               &amp;&amp; vro-&gt;opcode == ADDR_EXPR)</span>
<span class="lineNum">     675 </span>            :             {
<span class="lineNum">     676 </span><span class="lineCov">   54682009 :               if (vro-&gt;op0)</span>
<span class="lineNum">     677 </span>            :                 {
<span class="lineNum">     678 </span><span class="lineCov">   54682009 :                   tree op = TREE_OPERAND (vro-&gt;op0, 0);</span>
<span class="lineNum">     679 </span><span class="lineCov">   54682009 :                   hstate.add_int (TREE_CODE (op));</span>
<span class="lineNum">     680 </span><span class="lineCov">   54682009 :                   inchash::add_expr (op, hstate);</span>
<span class="lineNum">     681 </span>            :                 }
<span class="lineNum">     682 </span>            :             }
<span class="lineNum">     683 </span>            :           else
<span class="lineNum">     684 </span><span class="lineCov">   60915371 :             vn_reference_op_compute_hash (vro, hstate);</span>
<span class="lineNum">     685 </span>            :         }
<span class="lineNum">     686 </span>            :     }
<span class="lineNum">     687 </span><span class="lineCov">   89719413 :   result = hstate.end ();</span>
<span class="lineNum">     688 </span>            :   /* ??? We would ICE later if we hash instead of adding that in. */
<span class="lineNum">     689 </span><span class="lineCov">   89719413 :   if (vr1-&gt;vuse)</span>
<span class="lineNum">     690 </span><span class="lineCov">   86691647 :     result += SSA_NAME_VERSION (vr1-&gt;vuse);</span>
<span class="lineNum">     691 </span>            : 
<span class="lineNum">     692 </span><span class="lineCov">   89719413 :   return result;</span>
<span class="lineNum">     693 </span>            : }
<span class="lineNum">     694 </span>            : 
<span class="lineNum">     695 </span>            : /* Return true if reference operations VR1 and VR2 are equivalent.  This
<span class="lineNum">     696 </span>            :    means they have the same set of operands and vuses.  */
<a name="697"><span class="lineNum">     697 </span>            : </a>
<span class="lineNum">     698 </span>            : bool
<span class="lineNum">     699 </span><span class="lineCov">  466596831 : vn_reference_eq (const_vn_reference_t const vr1, const_vn_reference_t const vr2)</span>
<span class="lineNum">     700 </span>            : {
<span class="lineNum">     701 </span><span class="lineCov">  466596831 :   unsigned i, j;</span>
<span class="lineNum">     702 </span>            : 
<span class="lineNum">     703 </span>            :   /* Early out if this is not a hash collision.  */
<span class="lineNum">     704 </span><span class="lineCov">  466596831 :   if (vr1-&gt;hashcode != vr2-&gt;hashcode)</span>
<span class="lineNum">     705 </span>            :     return false;
<span class="lineNum">     706 </span>            : 
<span class="lineNum">     707 </span>            :   /* The VOP needs to be the same.  */
<span class="lineNum">     708 </span><span class="lineCov">   49622768 :   if (vr1-&gt;vuse != vr2-&gt;vuse)</span>
<span class="lineNum">     709 </span>            :     return false;
<span class="lineNum">     710 </span>            : 
<span class="lineNum">     711 </span>            :   /* If the operands are the same we are done.  */
<span class="lineNum">     712 </span><span class="lineCov">   99244970 :   if (vr1-&gt;operands == vr2-&gt;operands)</span>
<span class="lineNum">     713 </span>            :     return true;
<span class="lineNum">     714 </span>            : 
<span class="lineNum">     715 </span><span class="lineCov">    7193634 :   if (!expressions_equal_p (TYPE_SIZE (vr1-&gt;type), TYPE_SIZE (vr2-&gt;type)))</span>
<span class="lineNum">     716 </span>            :     return false;
<span class="lineNum">     717 </span>            : 
<span class="lineNum">     718 </span><span class="lineCov">    6877524 :   if (INTEGRAL_TYPE_P (vr1-&gt;type)</span>
<span class="lineNum">     719 </span><span class="lineCov">    3491081 :       &amp;&amp; INTEGRAL_TYPE_P (vr2-&gt;type))</span>
<span class="lineNum">     720 </span>            :     {
<span class="lineNum">     721 </span><span class="lineCov">    3487806 :       if (TYPE_PRECISION (vr1-&gt;type) != TYPE_PRECISION (vr2-&gt;type))</span>
<span class="lineNum">     722 </span>            :         return false;
<span class="lineNum">     723 </span>            :     }
<span class="lineNum">     724 </span><span class="lineCov">    3389718 :   else if (INTEGRAL_TYPE_P (vr1-&gt;type)</span>
<span class="lineNum">     725 </span><span class="lineCov">    3389718 :            &amp;&amp; (TYPE_PRECISION (vr1-&gt;type)</span>
<span class="lineNum">     726 </span><span class="lineCov">       6550 :                != TREE_INT_CST_LOW (TYPE_SIZE (vr1-&gt;type))))</span>
<span class="lineNum">     727 </span>            :     return false;
<span class="lineNum">     728 </span><span class="lineCov">    3389608 :   else if (INTEGRAL_TYPE_P (vr2-&gt;type)</span>
<span class="lineNum">     729 </span><span class="lineCov">    3389608 :            &amp;&amp; (TYPE_PRECISION (vr2-&gt;type)</span>
<span class="lineNum">     730 </span><span class="lineCov">       2822 :                != TREE_INT_CST_LOW (TYPE_SIZE (vr2-&gt;type))))</span>
<span class="lineNum">     731 </span>            :     return false;
<span class="lineNum">     732 </span>            : 
<span class="lineNum">     733 </span>            :   i = 0;
<span class="lineNum">     734 </span>            :   j = 0;
<span class="lineNum">     735 </span><span class="lineCov">    8436618 :   do</span>
<span class="lineNum">     736 </span>            :     {
<span class="lineNum">     737 </span><span class="lineCov">   16873236 :       poly_int64 off1 = 0, off2 = 0;</span>
<span class="lineNum">     738 </span><span class="lineCov">    8436618 :       vn_reference_op_t vro1, vro2;</span>
<span class="lineNum">     739 </span><span class="lineCov">    8436618 :       vn_reference_op_s tem1, tem2;</span>
<span class="lineNum">     740 </span><span class="lineCov">    8436618 :       bool deref1 = false, deref2 = false;</span>
<span class="lineNum">     741 </span><span class="lineCov">   19256262 :       for (; vr1-&gt;operands.iterate (i, &amp;vro1); i++)</span>
<span class="lineNum">     742 </span>            :         {
<span class="lineNum">     743 </span><span class="lineCov">   19256262 :           if (vro1-&gt;opcode == MEM_REF)</span>
<span class="lineNum">     744 </span>            :             deref1 = true;
<span class="lineNum">     745 </span>            :           /* Do not look through a storage order barrier.  */
<span class="lineNum">     746 </span><span class="lineCov">   12683889 :           else if (vro1-&gt;opcode == VIEW_CONVERT_EXPR &amp;&amp; vro1-&gt;reverse)</span>
<span class="lineNum">     747 </span><span class="lineCov">       1547 :             return false;</span>
<span class="lineNum">     748 </span><span class="lineCov">   19256262 :           if (known_eq (vro1-&gt;off, -1))</span>
<span class="lineNum">     749 </span>            :             break;
<span class="lineNum">     750 </span><span class="lineCov">   21639288 :           off1 += vro1-&gt;off;</span>
<span class="lineNum">     751 </span>            :         }
<span class="lineNum">     752 </span><span class="lineCov">   19248980 :       for (; vr2-&gt;operands.iterate (j, &amp;vro2); j++)</span>
<span class="lineNum">     753 </span>            :         {
<span class="lineNum">     754 </span><span class="lineCov">   19248980 :           if (vro2-&gt;opcode == MEM_REF)</span>
<span class="lineNum">     755 </span>            :             deref2 = true;
<span class="lineNum">     756 </span>            :           /* Do not look through a storage order barrier.  */
<span class="lineNum">     757 </span><span class="lineCov">   12676607 :           else if (vro2-&gt;opcode == VIEW_CONVERT_EXPR &amp;&amp; vro2-&gt;reverse)</span>
<span class="lineNum">     758 </span>            :             return false;
<span class="lineNum">     759 </span><span class="lineCov">   19248980 :           if (known_eq (vro2-&gt;off, -1))</span>
<span class="lineNum">     760 </span>            :             break;
<span class="lineNum">     761 </span><span class="lineCov">   21624724 :           off2 += vro2-&gt;off;</span>
<span class="lineNum">     762 </span>            :         }
<span class="lineNum">     763 </span><span class="lineCov">    8436618 :       if (maybe_ne (off1, off2))</span>
<span class="lineNum">     764 </span>            :         return false;
<span class="lineNum">     765 </span><span class="lineCov">    8436542 :       if (deref1 &amp;&amp; vro1-&gt;opcode == ADDR_EXPR)</span>
<span class="lineNum">     766 </span>            :         {
<span class="lineNum">     767 </span><span class="lineCov">    3139734 :           memset (&amp;tem1, 0, sizeof (tem1));</span>
<span class="lineNum">     768 </span><span class="lineCov">    3139734 :           tem1.op0 = TREE_OPERAND (vro1-&gt;op0, 0);</span>
<span class="lineNum">     769 </span><span class="lineCov">    3139734 :           tem1.type = TREE_TYPE (tem1.op0);</span>
<span class="lineNum">     770 </span><span class="lineCov">    3139734 :           tem1.opcode = TREE_CODE (tem1.op0);</span>
<span class="lineNum">     771 </span><span class="lineCov">    3139734 :           vro1 = &amp;tem1;</span>
<span class="lineNum">     772 </span><span class="lineCov">    3139734 :           deref1 = false;</span>
<span class="lineNum">     773 </span>            :         }
<span class="lineNum">     774 </span><span class="lineCov">    8436542 :       if (deref2 &amp;&amp; vro2-&gt;opcode == ADDR_EXPR)</span>
<span class="lineNum">     775 </span>            :         {
<span class="lineNum">     776 </span><span class="lineCov">    3139734 :           memset (&amp;tem2, 0, sizeof (tem2));</span>
<span class="lineNum">     777 </span><span class="lineCov">    3139734 :           tem2.op0 = TREE_OPERAND (vro2-&gt;op0, 0);</span>
<span class="lineNum">     778 </span><span class="lineCov">    3139734 :           tem2.type = TREE_TYPE (tem2.op0);</span>
<span class="lineNum">     779 </span><span class="lineCov">    3139734 :           tem2.opcode = TREE_CODE (tem2.op0);</span>
<span class="lineNum">     780 </span><span class="lineCov">    3139734 :           vro2 = &amp;tem2;</span>
<span class="lineNum">     781 </span><span class="lineCov">    3139734 :           deref2 = false;</span>
<span class="lineNum">     782 </span>            :         }
<span class="lineNum">     783 </span><span class="lineCov">    8436542 :       if (deref1 != deref2)</span>
<span class="lineNum">     784 </span>            :         return false;
<span class="lineNum">     785 </span><span class="lineCov">    8436542 :       if (!vn_reference_op_eq (vro1, vro2))</span>
<span class="lineNum">     786 </span>            :         return false;
<span class="lineNum">     787 </span><span class="lineCov">    8435071 :       ++j;</span>
<span class="lineNum">     788 </span><span class="lineCov">    8435071 :       ++i;</span>
<span class="lineNum">     789 </span>            :     }
<span class="lineNum">     790 </span><span class="lineCov">    8435071 :   while (vr1-&gt;operands.length () != i</span>
<span class="lineNum">     791 </span><span class="lineCov">   15301413 :          || vr2-&gt;operands.length () != j);</span>
<span class="lineNum">     792 </span>            : 
<span class="lineNum">     793 </span>            :   return true;
<span class="lineNum">     794 </span>            : }
<span class="lineNum">     795 </span>            : 
<span class="lineNum">     796 </span>            : /* Copy the operations present in load/store REF into RESULT, a vector of
<span class="lineNum">     797 </span>            :    vn_reference_op_s's.  */
<a name="798"><span class="lineNum">     798 </span>            : </a>
<span class="lineNum">     799 </span>            : static void
<span class="lineNum">     800 </span><span class="lineCov">   94199616 : copy_reference_ops_from_ref (tree ref, vec&lt;vn_reference_op_s&gt; *result)</span>
<span class="lineNum">     801 </span>            : {
<span class="lineNum">     802 </span><span class="lineCov">   94199616 :   if (TREE_CODE (ref) == TARGET_MEM_REF)</span>
<span class="lineNum">     803 </span>            :     {
<span class="lineNum">     804 </span><span class="lineNoCov">          0 :       vn_reference_op_s temp;</span>
<span class="lineNum">     805 </span>            : 
<span class="lineNum">     806 </span><span class="lineNoCov">          0 :       result-&gt;reserve (3);</span>
<span class="lineNum">     807 </span>            : 
<span class="lineNum">     808 </span><span class="lineNoCov">          0 :       memset (&amp;temp, 0, sizeof (temp));</span>
<span class="lineNum">     809 </span><span class="lineNoCov">          0 :       temp.type = TREE_TYPE (ref);</span>
<span class="lineNum">     810 </span><span class="lineNoCov">          0 :       temp.opcode = TREE_CODE (ref);</span>
<span class="lineNum">     811 </span><span class="lineNoCov">          0 :       temp.op0 = TMR_INDEX (ref);</span>
<span class="lineNum">     812 </span><span class="lineNoCov">          0 :       temp.op1 = TMR_STEP (ref);</span>
<span class="lineNum">     813 </span><span class="lineNoCov">          0 :       temp.op2 = TMR_OFFSET (ref);</span>
<span class="lineNum">     814 </span><span class="lineNoCov">          0 :       temp.off = -1;</span>
<span class="lineNum">     815 </span><span class="lineNoCov">          0 :       temp.clique = MR_DEPENDENCE_CLIQUE (ref);</span>
<span class="lineNum">     816 </span><span class="lineNoCov">          0 :       temp.base = MR_DEPENDENCE_BASE (ref);</span>
<span class="lineNum">     817 </span><span class="lineNoCov">          0 :       result-&gt;quick_push (temp);</span>
<span class="lineNum">     818 </span>            : 
<span class="lineNum">     819 </span><span class="lineNoCov">          0 :       memset (&amp;temp, 0, sizeof (temp));</span>
<span class="lineNum">     820 </span><span class="lineNoCov">          0 :       temp.type = NULL_TREE;</span>
<span class="lineNum">     821 </span><span class="lineNoCov">          0 :       temp.opcode = ERROR_MARK;</span>
<span class="lineNum">     822 </span><span class="lineNoCov">          0 :       temp.op0 = TMR_INDEX2 (ref);</span>
<span class="lineNum">     823 </span><span class="lineNoCov">          0 :       temp.off = -1;</span>
<span class="lineNum">     824 </span><span class="lineNoCov">          0 :       result-&gt;quick_push (temp);</span>
<span class="lineNum">     825 </span>            : 
<span class="lineNum">     826 </span><span class="lineNoCov">          0 :       memset (&amp;temp, 0, sizeof (temp));</span>
<span class="lineNum">     827 </span><span class="lineNoCov">          0 :       temp.type = NULL_TREE;</span>
<span class="lineNum">     828 </span><span class="lineNoCov">          0 :       temp.opcode = TREE_CODE (TMR_BASE (ref));</span>
<span class="lineNum">     829 </span><span class="lineNoCov">          0 :       temp.op0 = TMR_BASE (ref);</span>
<span class="lineNum">     830 </span><span class="lineNoCov">          0 :       temp.off = -1;</span>
<span class="lineNum">     831 </span><span class="lineNoCov">          0 :       result-&gt;quick_push (temp);</span>
<span class="lineNum">     832 </span><span class="lineNoCov">          0 :       return;</span>
<span class="lineNum">     833 </span>            :     }
<span class="lineNum">     834 </span>            : 
<span class="lineNum">     835 </span>            :   /* For non-calls, store the information that makes up the address.  */
<span class="lineNum">     836 </span>            :   tree orig = ref;
<span class="lineNum">     837 </span><span class="lineCov">  320971684 :   while (ref)</span>
<span class="lineNum">     838 </span>            :     {
<span class="lineNum">     839 </span><span class="lineCov">  226772068 :       vn_reference_op_s temp;</span>
<span class="lineNum">     840 </span>            : 
<span class="lineNum">     841 </span><span class="lineCov">  226772068 :       memset (&amp;temp, 0, sizeof (temp));</span>
<span class="lineNum">     842 </span><span class="lineCov">  226772068 :       temp.type = TREE_TYPE (ref);</span>
<span class="lineNum">     843 </span><span class="lineCov">  226772068 :       temp.opcode = TREE_CODE (ref);</span>
<span class="lineNum">     844 </span><span class="lineCov">  226772068 :       temp.off = -1;</span>
<span class="lineNum">     845 </span>            : 
<span class="lineNum">     846 </span><span class="lineCov">  226772068 :       switch (temp.opcode)</span>
<span class="lineNum">     847 </span>            :         {
<span class="lineNum">     848 </span><span class="lineCov">    9217031 :         case MODIFY_EXPR:</span>
<span class="lineNum">     849 </span><span class="lineCov">    9217031 :           temp.op0 = TREE_OPERAND (ref, 1);</span>
<span class="lineNum">     850 </span><span class="lineCov">    9217031 :           break;</span>
<span class="lineNum">     851 </span><span class="lineCov">         56 :         case WITH_SIZE_EXPR:</span>
<span class="lineNum">     852 </span><span class="lineCov">         56 :           temp.op0 = TREE_OPERAND (ref, 1);</span>
<span class="lineNum">     853 </span><span class="lineCov">         56 :           temp.off = 0;</span>
<span class="lineNum">     854 </span><span class="lineCov">         56 :           break;</span>
<span class="lineNum">     855 </span><span class="lineCov">   53370173 :         case MEM_REF:</span>
<span class="lineNum">     856 </span>            :           /* The base address gets its own vn_reference_op_s structure.  */
<span class="lineNum">     857 </span><span class="lineCov">   53370173 :           temp.op0 = TREE_OPERAND (ref, 1);</span>
<span class="lineNum">     858 </span><span class="lineCov">  106740346 :           if (!mem_ref_offset (ref).to_shwi (&amp;temp.off))</span>
<span class="lineNum">     859 </span><span class="lineNoCov">          0 :             temp.off = -1;</span>
<span class="lineNum">     860 </span><span class="lineCov">   53370173 :           temp.clique = MR_DEPENDENCE_CLIQUE (ref);</span>
<span class="lineNum">     861 </span><span class="lineCov">   53370173 :           temp.base = MR_DEPENDENCE_BASE (ref);</span>
<span class="lineNum">     862 </span><span class="lineCov">   53370173 :           temp.reverse = REF_REVERSE_STORAGE_ORDER (ref);</span>
<span class="lineNum">     863 </span><span class="lineCov">   53370173 :           break;</span>
<span class="lineNum">     864 </span><span class="lineCov">     106082 :         case BIT_FIELD_REF:</span>
<span class="lineNum">     865 </span>            :           /* Record bits, position and storage order.  */
<span class="lineNum">     866 </span><span class="lineCov">     106082 :           temp.op0 = TREE_OPERAND (ref, 1);</span>
<span class="lineNum">     867 </span><span class="lineCov">     106082 :           temp.op1 = TREE_OPERAND (ref, 2);</span>
<span class="lineNum">     868 </span><span class="lineCov">     106082 :           if (!multiple_p (bit_field_offset (ref), BITS_PER_UNIT, &amp;temp.off))</span>
<span class="lineNum">     869 </span><span class="lineCov">        864 :             temp.off = -1;</span>
<span class="lineNum">     870 </span><span class="lineCov">     106082 :           temp.reverse = REF_REVERSE_STORAGE_ORDER (ref);</span>
<span class="lineNum">     871 </span><span class="lineCov">     106082 :           break;</span>
<span class="lineNum">     872 </span><span class="lineCov">   50830478 :         case COMPONENT_REF:</span>
<span class="lineNum">     873 </span>            :           /* The field decl is enough to unambiguously specify the field,
<span class="lineNum">     874 </span>            :              a matching type is not necessary and a mismatching type
<span class="lineNum">     875 </span>            :              is always a spurious difference.  */
<span class="lineNum">     876 </span><span class="lineCov">   50830478 :           temp.type = NULL_TREE;</span>
<span class="lineNum">     877 </span><span class="lineCov">   50830478 :           temp.op0 = TREE_OPERAND (ref, 1);</span>
<span class="lineNum">     878 </span><span class="lineCov">   50830478 :           temp.op1 = TREE_OPERAND (ref, 2);</span>
<span class="lineNum">     879 </span><span class="lineCov">   50830478 :           {</span>
<span class="lineNum">     880 </span><span class="lineCov">   50830478 :             tree this_offset = component_ref_field_offset (ref);</span>
<span class="lineNum">     881 </span><span class="lineCov">   50830478 :             if (this_offset</span>
<span class="lineNum">     882 </span><span class="lineCov">   50830478 :                 &amp;&amp; poly_int_tree_p (this_offset))</span>
<span class="lineNum">     883 </span>            :               {
<span class="lineNum">     884 </span><span class="lineCov">   50829913 :                 tree bit_offset = DECL_FIELD_BIT_OFFSET (TREE_OPERAND (ref, 1));</span>
<span class="lineNum">     885 </span><span class="lineCov">   50829913 :                 if (TREE_INT_CST_LOW (bit_offset) % BITS_PER_UNIT == 0)</span>
<span class="lineNum">     886 </span>            :                   {
<span class="lineNum">     887 </span><span class="lineCov">   50681094 :                     poly_offset_int off</span>
<span class="lineNum">     888 </span><span class="lineCov">  152043282 :                       = (wi::to_poly_offset (this_offset)</span>
<span class="lineNum">     889 </span><span class="lineCov">   50681094 :                          + (wi::to_offset (bit_offset) &gt;&gt; LOG2_BITS_PER_UNIT));</span>
<span class="lineNum">     890 </span>            :                     /* Probibit value-numbering zero offset components
<span class="lineNum">     891 </span>            :                        of addresses the same before the pass folding
<span class="lineNum">     892 </span>            :                        __builtin_object_size had a chance to run
<span class="lineNum">     893 </span>            :                        (checking cfun-&gt;after_inlining does the
<span class="lineNum">     894 </span>            :                        trick here).  */
<span class="lineNum">     895 </span><span class="lineCov">   50681094 :                     if (TREE_CODE (orig) != ADDR_EXPR</span>
<span class="lineNum">     896 </span><span class="lineCov">    2605484 :                         || maybe_ne (off, 0)</span>
<span class="lineNum">     897 </span><span class="lineCov">   52191482 :                         || cfun-&gt;after_inlining)</span>
<span class="lineNum">     898 </span>            :                       off.to_shwi (&amp;temp.off);
<span class="lineNum">     899 </span>            :                   }
<span class="lineNum">     900 </span>            :               }
<span class="lineNum">     901 </span>            :           }
<span class="lineNum">     902 </span>            :           break;
<span class="lineNum">     903 </span><span class="lineCov">   15500553 :         case ARRAY_RANGE_REF:</span>
<span class="lineNum">     904 </span><span class="lineCov">   15500553 :         case ARRAY_REF:</span>
<span class="lineNum">     905 </span><span class="lineCov">   15500553 :           {</span>
<span class="lineNum">     906 </span><span class="lineCov">   15500553 :             tree eltype = TREE_TYPE (TREE_TYPE (TREE_OPERAND (ref, 0)));</span>
<span class="lineNum">     907 </span>            :             /* Record index as operand.  */
<span class="lineNum">     908 </span><span class="lineCov">   15500553 :             temp.op0 = TREE_OPERAND (ref, 1);</span>
<span class="lineNum">     909 </span>            :             /* Always record lower bounds and element size.  */
<span class="lineNum">     910 </span><span class="lineCov">   15500553 :             temp.op1 = array_ref_low_bound (ref);</span>
<span class="lineNum">     911 </span>            :             /* But record element size in units of the type alignment.  */
<span class="lineNum">     912 </span><span class="lineCov">   15500553 :             temp.op2 = TREE_OPERAND (ref, 3);</span>
<span class="lineNum">     913 </span><span class="lineCov">   15500553 :             temp.align = eltype-&gt;type_common.align;</span>
<span class="lineNum">     914 </span><span class="lineCov">   15500553 :             if (! temp.op2)</span>
<span class="lineNum">     915 </span><span class="lineCov">   15425010 :               temp.op2 = size_binop (EXACT_DIV_EXPR, TYPE_SIZE_UNIT (eltype),</span>
<span class="lineNum">     916 </span>            :                                      size_int (TYPE_ALIGN_UNIT (eltype)));
<span class="lineNum">     917 </span><span class="lineCov">   15500553 :             if (poly_int_tree_p (temp.op0)</span>
<span class="lineNum">     918 </span><span class="lineCov">   18038316 :                 &amp;&amp; poly_int_tree_p (temp.op1)</span>
<span class="lineNum">     919 </span><span class="lineCov">   24519711 :                 &amp;&amp; TREE_CODE (temp.op2) == INTEGER_CST)</span>
<span class="lineNum">     920 </span>            :               {
<span class="lineNum">     921 </span><span class="lineCov">   35999740 :                 poly_offset_int off = ((wi::to_poly_offset (temp.op0)</span>
<span class="lineNum">     922 </span><span class="lineCov">    8999935 :                                         - wi::to_poly_offset (temp.op1))</span>
<span class="lineNum">     923 </span><span class="lineCov">   17999870 :                                        * wi::to_offset (temp.op2)</span>
<span class="lineNum">     924 </span><span class="lineCov">   26999805 :                                        * vn_ref_op_align_unit (&amp;temp));</span>
<span class="lineNum">     925 </span><span class="lineCov">   17999145 :                 off.to_shwi (&amp;temp.off);</span>
<span class="lineNum">     926 </span>            :               }
<span class="lineNum">     927 </span>            :           }
<span class="lineNum">     928 </span>            :           break;
<span class="lineNum">     929 </span><span class="lineCov">   32912237 :         case VAR_DECL:</span>
<span class="lineNum">     930 </span><span class="lineCov">   32912237 :           if (DECL_HARD_REGISTER (ref))</span>
<span class="lineNum">     931 </span>            :             {
<span class="lineNum">     932 </span><span class="lineCov">       9740 :               temp.op0 = ref;</span>
<span class="lineNum">     933 </span><span class="lineCov">       9740 :               break;</span>
<span class="lineNum">     934 </span>            :             }
<span class="lineNum">     935 </span>            :           /* Fallthru.  */
<span class="lineNum">     936 </span><span class="lineCov">   33361753 :         case PARM_DECL:</span>
<span class="lineNum">     937 </span><span class="lineCov">   33361753 :         case CONST_DECL:</span>
<span class="lineNum">     938 </span><span class="lineCov">   33361753 :         case RESULT_DECL:</span>
<span class="lineNum">     939 </span>            :           /* Canonicalize decls to MEM[&amp;decl] which is what we end up with
<span class="lineNum">     940 </span>            :              when valueizing MEM[ptr] with ptr = &amp;decl.  */
<span class="lineNum">     941 </span><span class="lineCov">   33361753 :           temp.opcode = MEM_REF;</span>
<span class="lineNum">     942 </span><span class="lineCov">   66723506 :           temp.op0 = build_int_cst (build_pointer_type (TREE_TYPE (ref)), 0);</span>
<span class="lineNum">     943 </span><span class="lineCov">   33361753 :           temp.off = 0;</span>
<span class="lineNum">     944 </span><span class="lineCov">   33361753 :           result-&gt;safe_push (temp);</span>
<span class="lineNum">     945 </span><span class="lineCov">   33361753 :           temp.opcode = ADDR_EXPR;</span>
<span class="lineNum">     946 </span><span class="lineCov">   33361753 :           temp.op0 = build1 (ADDR_EXPR, TREE_TYPE (temp.op0), ref);</span>
<span class="lineNum">     947 </span><span class="lineCov">   33361753 :           temp.type = TREE_TYPE (temp.op0);</span>
<span class="lineNum">     948 </span><span class="lineCov">   33361753 :           temp.off = -1;</span>
<span class="lineNum">     949 </span><span class="lineCov">   33361753 :           break;</span>
<span class="lineNum">     950 </span><span class="lineCov">   36982421 :         case STRING_CST:</span>
<span class="lineNum">     951 </span><span class="lineCov">   36982421 :         case INTEGER_CST:</span>
<span class="lineNum">     952 </span><span class="lineCov">   36982421 :         case COMPLEX_CST:</span>
<span class="lineNum">     953 </span><span class="lineCov">   36982421 :         case VECTOR_CST:</span>
<span class="lineNum">     954 </span><span class="lineCov">   36982421 :         case REAL_CST:</span>
<span class="lineNum">     955 </span><span class="lineCov">   36982421 :         case FIXED_CST:</span>
<span class="lineNum">     956 </span><span class="lineCov">   36982421 :         case CONSTRUCTOR:</span>
<span class="lineNum">     957 </span><span class="lineCov">   36982421 :         case SSA_NAME:</span>
<span class="lineNum">     958 </span><span class="lineCov">   36982421 :           temp.op0 = ref;</span>
<span class="lineNum">     959 </span><span class="lineCov">   36982421 :           break;</span>
<span class="lineNum">     960 </span><span class="lineCov">   26186167 :         case ADDR_EXPR:</span>
<span class="lineNum">     961 </span><span class="lineCov">   26186167 :           if (is_gimple_min_invariant (ref))</span>
<span class="lineNum">     962 </span>            :             {
<span class="lineNum">     963 </span><span class="lineCov">   23845702 :               temp.op0 = ref;</span>
<span class="lineNum">     964 </span><span class="lineCov">   23845702 :               break;</span>
<span class="lineNum">     965 </span>            :             }
<span class="lineNum">     966 </span>            :           break;
<span class="lineNum">     967 </span>            :           /* These are only interesting for their operands, their
<span class="lineNum">     968 </span>            :              existence, and their type.  They will never be the last
<span class="lineNum">     969 </span>            :              ref in the chain of references (IE they require an
<span class="lineNum">     970 </span>            :              operand), so we don't have to put anything
<span class="lineNum">     971 </span>            :              for op* as it will be handled by the iteration  */
<span class="lineNum">     972 </span><span class="lineCov">     258948 :         case REALPART_EXPR:</span>
<span class="lineNum">     973 </span><span class="lineCov">     258948 :           temp.off = 0;</span>
<span class="lineNum">     974 </span><span class="lineCov">     258948 :           break;</span>
<span class="lineNum">     975 </span><span class="lineCov">     683384 :         case VIEW_CONVERT_EXPR:</span>
<span class="lineNum">     976 </span><span class="lineCov">     683384 :           temp.off = 0;</span>
<span class="lineNum">     977 </span><span class="lineCov">     683384 :           temp.reverse = storage_order_barrier_p (ref);</span>
<span class="lineNum">     978 </span><span class="lineCov">     683384 :           break;</span>
<span class="lineNum">     979 </span><span class="lineCov">     265282 :         case IMAGPART_EXPR:</span>
<span class="lineNum">     980 </span>            :           /* This is only interesting for its constant offset.  */
<span class="lineNum">     981 </span><span class="lineCov">     265282 :           temp.off = TREE_INT_CST_LOW (TYPE_SIZE_UNIT (TREE_TYPE (ref)));</span>
<span class="lineNum">     982 </span><span class="lineCov">     265282 :           break;</span>
<span class="lineNum">     983 </span><span class="lineNoCov">          0 :         default:</span>
<span class="lineNum">     984 </span><span class="lineNoCov">          0 :           gcc_unreachable ();</span>
<span class="lineNum">     985 </span>            :         }
<span class="lineNum">     986 </span><span class="lineCov">  226772068 :       result-&gt;safe_push (temp);</span>
<span class="lineNum">     987 </span>            : 
<span class="lineNum">     988 </span><span class="lineCov">  226772068 :       if (REFERENCE_CLASS_P (ref)</span>
<span class="lineNum">     989 </span><span class="lineCov">  105757168 :           || TREE_CODE (ref) == MODIFY_EXPR</span>
<span class="lineNum">     990 </span><span class="lineCov">   96540137 :           || TREE_CODE (ref) == WITH_SIZE_EXPR</span>
<span class="lineNum">     991 </span><span class="lineCov">  323312149 :           || (TREE_CODE (ref) == ADDR_EXPR</span>
<span class="lineNum">     992 </span><span class="lineCov">   26186167 :               &amp;&amp; !is_gimple_min_invariant (ref)))</span>
<span class="lineNum">     993 </span><span class="lineCov">  132572452 :         ref = TREE_OPERAND (ref, 0);</span>
<span class="lineNum">     994 </span>            :       else
<span class="lineNum">     995 </span>            :         ref = NULL_TREE;
<span class="lineNum">     996 </span>            :     }
<span class="lineNum">     997 </span>            : }
<span class="lineNum">     998 </span>            : 
<span class="lineNum">     999 </span>            : /* Build a alias-oracle reference abstraction in *REF from the vn_reference
<span class="lineNum">    1000 </span>            :    operands in *OPS, the reference alias set SET and the reference type TYPE.
<span class="lineNum">    1001 </span>            :    Return true if something useful was produced.  */
<a name="1002"><span class="lineNum">    1002 </span>            : </a>
<span class="lineNum">    1003 </span>            : bool
<span class="lineNum">    1004 </span><span class="lineCov">    7786791 : ao_ref_init_from_vn_reference (ao_ref *ref,</span>
<span class="lineNum">    1005 </span>            :                                alias_set_type set, tree type,
<span class="lineNum">    1006 </span>            :                                vec&lt;vn_reference_op_s&gt; ops)
<span class="lineNum">    1007 </span>            : {
<span class="lineNum">    1008 </span><span class="lineCov">    7786791 :   vn_reference_op_t op;</span>
<span class="lineNum">    1009 </span><span class="lineCov">    7786791 :   unsigned i;</span>
<span class="lineNum">    1010 </span><span class="lineCov">    7786791 :   tree base = NULL_TREE;</span>
<span class="lineNum">    1011 </span><span class="lineCov">    7786791 :   tree *op0_p = &amp;base;</span>
<span class="lineNum">    1012 </span><span class="lineCov">    7786791 :   poly_offset_int offset = 0;</span>
<span class="lineNum">    1013 </span><span class="lineCov">    7786791 :   poly_offset_int max_size;</span>
<span class="lineNum">    1014 </span><span class="lineCov">    7786791 :   poly_offset_int size = -1;</span>
<span class="lineNum">    1015 </span><span class="lineCov">    7786791 :   tree size_tree = NULL_TREE;</span>
<span class="lineNum">    1016 </span><span class="lineCov">    7786791 :   alias_set_type base_alias_set = -1;</span>
<span class="lineNum">    1017 </span>            : 
<span class="lineNum">    1018 </span>            :   /* First get the final access size from just the outermost expression.  */
<span class="lineNum">    1019 </span><span class="lineCov">    7786791 :   op = &amp;ops[0];</span>
<span class="lineNum">    1020 </span><span class="lineCov">    7786791 :   if (op-&gt;opcode == COMPONENT_REF)</span>
<span class="lineNum">    1021 </span><span class="lineCov">    1866890 :     size_tree = DECL_SIZE (op-&gt;op0);</span>
<span class="lineNum">    1022 </span><span class="lineCov">    5919901 :   else if (op-&gt;opcode == BIT_FIELD_REF)</span>
<span class="lineNum">    1023 </span><span class="lineCov">      17220 :     size_tree = op-&gt;op0;</span>
<span class="lineNum">    1024 </span>            :   else
<span class="lineNum">    1025 </span>            :     {
<span class="lineNum">    1026 </span><span class="lineCov">    5902681 :       machine_mode mode = TYPE_MODE (type);</span>
<span class="lineNum">    1027 </span><span class="lineCov">    5902681 :       if (mode == BLKmode)</span>
<span class="lineNum">    1028 </span><span class="lineCov">     102706 :         size_tree = TYPE_SIZE (type);</span>
<span class="lineNum">    1029 </span>            :       else
<span class="lineNum">    1030 </span><span class="lineCov">   11599950 :         size = GET_MODE_BITSIZE (mode);</span>
<span class="lineNum">    1031 </span>            :     }
<span class="lineNum">    1032 </span><span class="lineCov">    5799975 :   if (size_tree != NULL_TREE</span>
<span class="lineNum">    1033 </span><span class="lineCov">    1986816 :       &amp;&amp; poly_int_tree_p (size_tree))</span>
<span class="lineNum">    1034 </span><span class="lineCov">    1986816 :     size = wi::to_poly_offset (size_tree);</span>
<span class="lineNum">    1035 </span>            : 
<span class="lineNum">    1036 </span>            :   /* Initially, maxsize is the same as the accessed element size.
<span class="lineNum">    1037 </span>            :      In the following it will only grow (or become -1).  */
<span class="lineNum">    1038 </span><span class="lineCov">    7786791 :   max_size = size;</span>
<span class="lineNum">    1039 </span>            : 
<span class="lineNum">    1040 </span>            :   /* Compute cumulative bit-offset for nested component-refs and array-refs,
<span class="lineNum">    1041 </span>            :      and find the ultimate containing object.  */
<span class="lineNum">    1042 </span><span class="lineCov">   28927316 :   FOR_EACH_VEC_ELT (ops, i, op)</span>
<span class="lineNum">    1043 </span>            :     {
<span class="lineNum">    1044 </span><span class="lineCov">   21233667 :       switch (op-&gt;opcode)</span>
<span class="lineNum">    1045 </span>            :         {
<span class="lineNum">    1046 </span>            :         /* These may be in the reference ops, but we cannot do anything
<span class="lineNum">    1047 </span>            :            sensible with them here.  */
<span class="lineNum">    1048 </span><span class="lineCov">    3835214 :         case ADDR_EXPR:</span>
<span class="lineNum">    1049 </span>            :           /* Apart from ADDR_EXPR arguments to MEM_REF.  */
<span class="lineNum">    1050 </span><span class="lineCov">    3835214 :           if (base != NULL_TREE</span>
<span class="lineNum">    1051 </span><span class="lineCov">    3835214 :               &amp;&amp; TREE_CODE (base) == MEM_REF</span>
<span class="lineNum">    1052 </span><span class="lineCov">    3835214 :               &amp;&amp; op-&gt;op0</span>
<span class="lineNum">    1053 </span><span class="lineCov">    7670428 :               &amp;&amp; DECL_P (TREE_OPERAND (op-&gt;op0, 0)))</span>
<span class="lineNum">    1054 </span>            :             {
<span class="lineNum">    1055 </span><span class="lineCov">    3831715 :               vn_reference_op_t pop = &amp;ops[i-1];</span>
<span class="lineNum">    1056 </span><span class="lineCov">    3831715 :               base = TREE_OPERAND (op-&gt;op0, 0);</span>
<span class="lineNum">    1057 </span><span class="lineCov">    3831715 :               if (known_eq (pop-&gt;off, -1))</span>
<span class="lineNum">    1058 </span>            :                 {
<span class="lineNum">    1059 </span><span class="lineCov">         21 :                   max_size = -1;</span>
<span class="lineNum">    1060 </span><span class="lineCov">         42 :                   offset = 0;</span>
<span class="lineNum">    1061 </span>            :                 }
<span class="lineNum">    1062 </span>            :               else
<span class="lineNum">    1063 </span><span class="lineCov">    7663388 :                 offset += pop-&gt;off * BITS_PER_UNIT;</span>
<span class="lineNum">    1064 </span>            :               op0_p = NULL;
<span class="lineNum">    1065 </span>            :               break;
<span class="lineNum">    1066 </span>            :             }
<span class="lineNum">    1067 </span>            :           /* Fallthru.  */
<span class="lineNum">    1068 </span>            :         case CALL_EXPR:
<span class="lineNum">    1069 </span>            :           return false;
<span class="lineNum">    1070 </span>            : 
<span class="lineNum">    1071 </span>            :         /* Record the base objects.  */
<span class="lineNum">    1072 </span><span class="lineCov">    7698621 :         case MEM_REF:</span>
<span class="lineNum">    1073 </span><span class="lineCov">    7698621 :           base_alias_set = get_deref_alias_set (op-&gt;op0);</span>
<span class="lineNum">    1074 </span><span class="lineCov">    7698621 :           *op0_p = build2 (MEM_REF, op-&gt;type,</span>
<span class="lineNum">    1075 </span>            :                            NULL_TREE, op-&gt;op0);
<span class="lineNum">    1076 </span><span class="lineCov">    7698621 :           MR_DEPENDENCE_CLIQUE (*op0_p) = op-&gt;clique;</span>
<span class="lineNum">    1077 </span><span class="lineCov">    7698621 :           MR_DEPENDENCE_BASE (*op0_p) = op-&gt;base;</span>
<span class="lineNum">    1078 </span><span class="lineCov">    7698621 :           op0_p = &amp;TREE_OPERAND (*op0_p, 0);</span>
<span class="lineNum">    1079 </span><span class="lineCov">    7698621 :           break;</span>
<span class="lineNum">    1080 </span>            : 
<span class="lineNum">    1081 </span><span class="lineCov">    3861934 :         case VAR_DECL:</span>
<span class="lineNum">    1082 </span><span class="lineCov">    3861934 :         case PARM_DECL:</span>
<span class="lineNum">    1083 </span><span class="lineCov">    3861934 :         case RESULT_DECL:</span>
<span class="lineNum">    1084 </span><span class="lineCov">    3861934 :         case SSA_NAME:</span>
<span class="lineNum">    1085 </span><span class="lineCov">    3861934 :           *op0_p = op-&gt;op0;</span>
<span class="lineNum">    1086 </span><span class="lineCov">    3861934 :           op0_p = NULL;</span>
<span class="lineNum">    1087 </span><span class="lineCov">    3861934 :           break;</span>
<span class="lineNum">    1088 </span>            : 
<span class="lineNum">    1089 </span>            :         /* And now the usual component-reference style ops.  */
<span class="lineNum">    1090 </span><span class="lineCov">      17220 :         case BIT_FIELD_REF:</span>
<span class="lineNum">    1091 </span><span class="lineCov">      17220 :           offset += wi::to_poly_offset (op-&gt;op1);</span>
<span class="lineNum">    1092 </span><span class="lineCov">      17220 :           break;</span>
<span class="lineNum">    1093 </span>            : 
<span class="lineNum">    1094 </span><span class="lineCov">    3131080 :         case COMPONENT_REF:</span>
<span class="lineNum">    1095 </span><span class="lineCov">    3131080 :           {</span>
<span class="lineNum">    1096 </span><span class="lineCov">    3131080 :             tree field = op-&gt;op0;</span>
<span class="lineNum">    1097 </span>            :             /* We do not have a complete COMPONENT_REF tree here so we
<span class="lineNum">    1098 </span>            :                cannot use component_ref_field_offset.  Do the interesting
<span class="lineNum">    1099 </span>            :                parts manually.  */
<span class="lineNum">    1100 </span><span class="lineCov">    3131080 :             tree this_offset = DECL_FIELD_OFFSET (field);</span>
<span class="lineNum">    1101 </span>            : 
<span class="lineNum">    1102 </span><span class="lineCov">    3131080 :             if (op-&gt;op1 || !poly_int_tree_p (this_offset))</span>
<span class="lineNum">    1103 </span>            :               max_size = -1;
<span class="lineNum">    1104 </span>            :             else
<span class="lineNum">    1105 </span>            :               {
<span class="lineNum">    1106 </span><span class="lineCov">    3131006 :                 poly_offset_int woffset = (wi::to_poly_offset (this_offset)</span>
<span class="lineNum">    1107 </span><span class="lineCov">    3131006 :                                            &lt;&lt; LOG2_BITS_PER_UNIT);</span>
<span class="lineNum">    1108 </span><span class="lineCov">    3131006 :                 woffset += wi::to_offset (DECL_FIELD_BIT_OFFSET (field));</span>
<span class="lineNum">    1109 </span><span class="lineCov">    3131006 :                 offset += woffset;</span>
<span class="lineNum">    1110 </span>            :               }
<span class="lineNum">    1111 </span>            :             break;
<span class="lineNum">    1112 </span>            :           }
<span class="lineNum">    1113 </span>            : 
<span class="lineNum">    1114 </span><span class="lineCov">    1957984 :         case ARRAY_RANGE_REF:</span>
<span class="lineNum">    1115 </span><span class="lineCov">    1957984 :         case ARRAY_REF:</span>
<span class="lineNum">    1116 </span>            :           /* We recorded the lower bound and the element size.  */
<span class="lineNum">    1117 </span><span class="lineCov">    1957984 :           if (!poly_int_tree_p (op-&gt;op0)</span>
<span class="lineNum">    1118 </span><span class="lineCov">    2537772 :               || !poly_int_tree_p (op-&gt;op1)</span>
<span class="lineNum">    1119 </span><span class="lineCov">    3226870 :               || TREE_CODE (op-&gt;op2) != INTEGER_CST)</span>
<span class="lineNum">    1120 </span>            :             max_size = -1;
<span class="lineNum">    1121 </span>            :           else
<span class="lineNum">    1122 </span>            :             {
<span class="lineNum">    1123 </span><span class="lineCov">    1242855 :               poly_offset_int woffset</span>
<span class="lineNum">    1124 </span><span class="lineCov">    3728565 :                 = wi::sext (wi::to_poly_offset (op-&gt;op0)</span>
<span class="lineNum">    1125 </span><span class="lineCov">    1242855 :                             - wi::to_poly_offset (op-&gt;op1),</span>
<span class="lineNum">    1126 </span><span class="lineCov">    2485710 :                             TYPE_PRECISION (TREE_TYPE (op-&gt;op0)));</span>
<span class="lineNum">    1127 </span><span class="lineCov">    2485710 :               woffset *= wi::to_offset (op-&gt;op2) * vn_ref_op_align_unit (op);</span>
<span class="lineNum">    1128 </span><span class="lineCov">    1242855 :               woffset &lt;&lt;= LOG2_BITS_PER_UNIT;</span>
<span class="lineNum">    1129 </span><span class="lineCov">    1242855 :               offset += woffset;</span>
<span class="lineNum">    1130 </span>            :             }
<span class="lineNum">    1131 </span>            :           break;
<span class="lineNum">    1132 </span>            : 
<span class="lineNum">    1133 </span>            :         case REALPART_EXPR:
<span class="lineNum">    1134 </span>            :           break;
<span class="lineNum">    1135 </span>            : 
<span class="lineNum">    1136 </span><span class="lineCov">      35289 :         case IMAGPART_EXPR:</span>
<span class="lineNum">    1137 </span><span class="lineCov">      35289 :           offset += size;</span>
<span class="lineNum">    1138 </span><span class="lineCov">      35289 :           break;</span>
<span class="lineNum">    1139 </span>            : 
<span class="lineNum">    1140 </span>            :         case VIEW_CONVERT_EXPR:
<span class="lineNum">    1141 </span>            :           break;
<span class="lineNum">    1142 </span>            : 
<span class="lineNum">    1143 </span>            :         case STRING_CST:
<span class="lineNum">    1144 </span>            :         case INTEGER_CST:
<span class="lineNum">    1145 </span>            :         case COMPLEX_CST:
<span class="lineNum">    1146 </span>            :         case VECTOR_CST:
<span class="lineNum">    1147 </span>            :         case REAL_CST:
<span class="lineNum">    1148 </span>            :         case CONSTRUCTOR:
<span class="lineNum">    1149 </span>            :         case CONST_DECL:
<span class="lineNum">    1150 </span>            :           return false;
<span class="lineNum">    1151 </span>            : 
<span class="lineNum">    1152 </span>            :         default:
<span class="lineNum">    1153 </span>            :           return false;
<span class="lineNum">    1154 </span>            :         }
<span class="lineNum">    1155 </span>            :     }
<span class="lineNum">    1156 </span>            : 
<span class="lineNum">    1157 </span><span class="lineCov">    7693649 :   if (base == NULL_TREE)</span>
<span class="lineNum">    1158 </span>            :     return false;
<span class="lineNum">    1159 </span>            : 
<span class="lineNum">    1160 </span><span class="lineCov">    7693649 :   ref-&gt;ref = NULL_TREE;</span>
<span class="lineNum">    1161 </span><span class="lineCov">    7693649 :   ref-&gt;base = base;</span>
<span class="lineNum">    1162 </span><span class="lineCov">    7693649 :   ref-&gt;ref_alias_set = set;</span>
<span class="lineNum">    1163 </span><span class="lineCov">    7693649 :   if (base_alias_set != -1)</span>
<span class="lineNum">    1164 </span><span class="lineCov">    7693606 :     ref-&gt;base_alias_set = base_alias_set;</span>
<span class="lineNum">    1165 </span>            :   else
<span class="lineNum">    1166 </span><span class="lineCov">         43 :     ref-&gt;base_alias_set = get_alias_set (base);</span>
<span class="lineNum">    1167 </span>            :   /* We discount volatiles from value-numbering elsewhere.  */
<span class="lineNum">    1168 </span><span class="lineCov">    7693649 :   ref-&gt;volatile_p = false;</span>
<span class="lineNum">    1169 </span>            : 
<span class="lineNum">    1170 </span><span class="lineCov">   15387298 :   if (!size.to_shwi (&amp;ref-&gt;size) || maybe_lt (ref-&gt;size, 0))</span>
<span class="lineNum">    1171 </span>            :     {
<span class="lineNum">    1172 </span><span class="lineNoCov">          0 :       ref-&gt;offset = 0;</span>
<span class="lineNum">    1173 </span><span class="lineNoCov">          0 :       ref-&gt;size = -1;</span>
<span class="lineNum">    1174 </span><span class="lineNoCov">          0 :       ref-&gt;max_size = -1;</span>
<span class="lineNum">    1175 </span><span class="lineNoCov">          0 :       return true;</span>
<span class="lineNum">    1176 </span>            :     }
<span class="lineNum">    1177 </span>            : 
<span class="lineNum">    1178 </span><span class="lineCov">   15387234 :   if (!offset.to_shwi (&amp;ref-&gt;offset))</span>
<span class="lineNum">    1179 </span>            :     {
<span class="lineNum">    1180 </span><span class="lineCov">         64 :       ref-&gt;offset = 0;</span>
<span class="lineNum">    1181 </span><span class="lineCov">         64 :       ref-&gt;max_size = -1;</span>
<span class="lineNum">    1182 </span><span class="lineCov">         64 :       return true;</span>
<span class="lineNum">    1183 </span>            :     }
<span class="lineNum">    1184 </span>            : 
<span class="lineNum">    1185 </span><span class="lineCov">   15387170 :   if (!max_size.to_shwi (&amp;ref-&gt;max_size) || maybe_lt (ref-&gt;max_size, 0))</span>
<span class="lineNum">    1186 </span><span class="lineCov">    1284850 :     ref-&gt;max_size = -1;</span>
<span class="lineNum">    1187 </span>            : 
<span class="lineNum">    1188 </span>            :   return true;
<span class="lineNum">    1189 </span>            : }
<span class="lineNum">    1190 </span>            : 
<span class="lineNum">    1191 </span>            : /* Copy the operations present in load/store/call REF into RESULT, a vector of
<span class="lineNum">    1192 </span>            :    vn_reference_op_s's.  */
<a name="1193"><span class="lineNum">    1193 </span>            : </a>
<span class="lineNum">    1194 </span>            : static void
<span class="lineNum">    1195 </span><span class="lineCov">    4358408 : copy_reference_ops_from_call (gcall *call,</span>
<span class="lineNum">    1196 </span>            :                               vec&lt;vn_reference_op_s&gt; *result)
<span class="lineNum">    1197 </span>            : {
<span class="lineNum">    1198 </span><span class="lineCov">    4358408 :   vn_reference_op_s temp;</span>
<span class="lineNum">    1199 </span><span class="lineCov">    4358408 :   unsigned i;</span>
<span class="lineNum">    1200 </span><span class="lineCov">    4358408 :   tree lhs = gimple_call_lhs (call);</span>
<span class="lineNum">    1201 </span><span class="lineCov">    4358408 :   int lr;</span>
<span class="lineNum">    1202 </span>            : 
<span class="lineNum">    1203 </span>            :   /* If 2 calls have a different non-ssa lhs, vdef value numbers should be
<span class="lineNum">    1204 </span>            :      different.  By adding the lhs here in the vector, we ensure that the
<span class="lineNum">    1205 </span>            :      hashcode is different, guaranteeing a different value number.  */
<span class="lineNum">    1206 </span><span class="lineCov">    4358408 :   if (lhs &amp;&amp; TREE_CODE (lhs) != SSA_NAME)</span>
<span class="lineNum">    1207 </span>            :     {
<span class="lineNum">    1208 </span><span class="lineCov">     272369 :       memset (&amp;temp, 0, sizeof (temp));</span>
<span class="lineNum">    1209 </span><span class="lineCov">     272369 :       temp.opcode = MODIFY_EXPR;</span>
<span class="lineNum">    1210 </span><span class="lineCov">     272369 :       temp.type = TREE_TYPE (lhs);</span>
<span class="lineNum">    1211 </span><span class="lineCov">     272369 :       temp.op0 = lhs;</span>
<span class="lineNum">    1212 </span><span class="lineCov">     272369 :       temp.off = -1;</span>
<span class="lineNum">    1213 </span><span class="lineCov">     272369 :       result-&gt;safe_push (temp);</span>
<span class="lineNum">    1214 </span>            :     }
<span class="lineNum">    1215 </span>            : 
<span class="lineNum">    1216 </span>            :   /* Copy the type, opcode, function, static chain and EH region, if any.  */
<span class="lineNum">    1217 </span><span class="lineCov">    4358408 :   memset (&amp;temp, 0, sizeof (temp));</span>
<span class="lineNum">    1218 </span><span class="lineCov">    4358408 :   temp.type = gimple_call_return_type (call);</span>
<span class="lineNum">    1219 </span><span class="lineCov">    4358408 :   temp.opcode = CALL_EXPR;</span>
<span class="lineNum">    1220 </span><span class="lineCov">    4358408 :   temp.op0 = gimple_call_fn (call);</span>
<span class="lineNum">    1221 </span><span class="lineCov">    4358408 :   temp.op1 = gimple_call_chain (call);</span>
<span class="lineNum">    1222 </span><span class="lineCov">    4358408 :   if (stmt_could_throw_p (call) &amp;&amp; (lr = lookup_stmt_eh_lp (call)) &gt; 0)</span>
<span class="lineNum">    1223 </span><span class="lineCov">    1218988 :     temp.op2 = size_int (lr);</span>
<span class="lineNum">    1224 </span><span class="lineCov">    4358408 :   temp.off = -1;</span>
<span class="lineNum">    1225 </span><span class="lineCov">    4358408 :   result-&gt;safe_push (temp);</span>
<span class="lineNum">    1226 </span>            : 
<span class="lineNum">    1227 </span>            :   /* Copy the call arguments.  As they can be references as well,
<span class="lineNum">    1228 </span>            :      just chain them together.  */
<span class="lineNum">    1229 </span><span class="lineCov">   12394391 :   for (i = 0; i &lt; gimple_call_num_args (call); ++i)</span>
<span class="lineNum">    1230 </span>            :     {
<span class="lineNum">    1231 </span><span class="lineCov">    8035983 :       tree callarg = gimple_call_arg (call, i);</span>
<span class="lineNum">    1232 </span><span class="lineCov">    8035983 :       copy_reference_ops_from_ref (callarg, result);</span>
<span class="lineNum">    1233 </span>            :     }
<span class="lineNum">    1234 </span><span class="lineCov">    4358408 : }</span>
<span class="lineNum">    1235 </span>            : 
<span class="lineNum">    1236 </span>            : /* Fold *&amp; at position *I_P in a vn_reference_op_s vector *OPS.  Updates
<a name="1237"><span class="lineNum">    1237 </span>            :    *I_P to point to the last element of the replacement.  */</a>
<span class="lineNum">    1238 </span>            : static bool
<span class="lineNum">    1239 </span><span class="lineCov">   58561856 : vn_reference_fold_indirect (vec&lt;vn_reference_op_s&gt; *ops,</span>
<span class="lineNum">    1240 </span>            :                             unsigned int *i_p)
<span class="lineNum">    1241 </span>            : {
<span class="lineNum">    1242 </span><span class="lineCov">   58561856 :   unsigned int i = *i_p;</span>
<span class="lineNum">    1243 </span><span class="lineCov">   58561856 :   vn_reference_op_t op = &amp;(*ops)[i];</span>
<span class="lineNum">    1244 </span><span class="lineCov">   58561856 :   vn_reference_op_t mem_op = &amp;(*ops)[i - 1];</span>
<span class="lineNum">    1245 </span><span class="lineCov">   58561856 :   tree addr_base;</span>
<span class="lineNum">    1246 </span><span class="lineCov">   58561856 :   poly_int64 addr_offset = 0;</span>
<span class="lineNum">    1247 </span>            : 
<span class="lineNum">    1248 </span>            :   /* The only thing we have to do is from &amp;OBJ.foo.bar add the offset
<span class="lineNum">    1249 </span>            :      from .foo.bar to the preceding MEM_REF offset and replace the
<span class="lineNum">    1250 </span>            :      address with &amp;OBJ.  */
<span class="lineNum">    1251 </span><span class="lineCov">   58561856 :   addr_base = get_addr_base_and_unit_offset (TREE_OPERAND (op-&gt;op0, 0),</span>
<span class="lineNum">    1252 </span>            :                                              &amp;addr_offset);
<span class="lineNum">    1253 </span><span class="lineCov">   58561856 :   gcc_checking_assert (addr_base &amp;&amp; TREE_CODE (addr_base) != MEM_REF);</span>
<span class="lineNum">    1254 </span><span class="lineCov">   58561856 :   if (addr_base != TREE_OPERAND (op-&gt;op0, 0))</span>
<span class="lineNum">    1255 </span>            :     {
<span class="lineNum">    1256 </span><span class="lineCov">     146980 :       poly_offset_int off</span>
<span class="lineNum">    1257 </span><span class="lineCov">     146980 :         = (poly_offset_int::from (wi::to_poly_wide (mem_op-&gt;op0),</span>
<span class="lineNum">    1258 </span><span class="lineCov">     146980 :                                   SIGNED)</span>
<span class="lineNum">    1259 </span><span class="lineCov">     146980 :            + addr_offset);</span>
<span class="lineNum">    1260 </span><span class="lineCov">     293960 :       mem_op-&gt;op0 = wide_int_to_tree (TREE_TYPE (mem_op-&gt;op0), off);</span>
<span class="lineNum">    1261 </span><span class="lineCov">     146980 :       op-&gt;op0 = build_fold_addr_expr (addr_base);</span>
<span class="lineNum">    1262 </span><span class="lineCov">     146980 :       if (tree_fits_shwi_p (mem_op-&gt;op0))</span>
<span class="lineNum">    1263 </span><span class="lineCov">     146951 :         mem_op-&gt;off = tree_to_shwi (mem_op-&gt;op0);</span>
<span class="lineNum">    1264 </span>            :       else
<span class="lineNum">    1265 </span><span class="lineCov">         58 :         mem_op-&gt;off = -1;</span>
<span class="lineNum">    1266 </span><span class="lineCov">     146980 :       return true;</span>
<span class="lineNum">    1267 </span>            :     }
<span class="lineNum">    1268 </span>            :   return false;
<span class="lineNum">    1269 </span>            : }
<span class="lineNum">    1270 </span>            : 
<span class="lineNum">    1271 </span>            : /* Fold *&amp; at position *I_P in a vn_reference_op_s vector *OPS.  Updates
<a name="1272"><span class="lineNum">    1272 </span>            :    *I_P to point to the last element of the replacement.  */</a>
<span class="lineNum">    1273 </span>            : static bool
<span class="lineNum">    1274 </span><span class="lineCov">   36069742 : vn_reference_maybe_forwprop_address (vec&lt;vn_reference_op_s&gt; *ops,</span>
<span class="lineNum">    1275 </span>            :                                      unsigned int *i_p)
<span class="lineNum">    1276 </span>            : {
<span class="lineNum">    1277 </span><span class="lineCov">   36069742 :   unsigned int i = *i_p;</span>
<span class="lineNum">    1278 </span><span class="lineCov">   36069742 :   vn_reference_op_t op = &amp;(*ops)[i];</span>
<span class="lineNum">    1279 </span><span class="lineCov">   36069742 :   vn_reference_op_t mem_op = &amp;(*ops)[i - 1];</span>
<span class="lineNum">    1280 </span><span class="lineCov">   36069742 :   gimple *def_stmt;</span>
<span class="lineNum">    1281 </span><span class="lineCov">   36069742 :   enum tree_code code;</span>
<span class="lineNum">    1282 </span><span class="lineCov">   36069742 :   poly_offset_int off;</span>
<span class="lineNum">    1283 </span>            : 
<span class="lineNum">    1284 </span><span class="lineCov">   36069742 :   def_stmt = SSA_NAME_DEF_STMT (op-&gt;op0);</span>
<span class="lineNum">    1285 </span><span class="lineCov">   72139484 :   if (!is_gimple_assign (def_stmt))</span>
<span class="lineNum">    1286 </span>            :     return false;
<span class="lineNum">    1287 </span>            : 
<span class="lineNum">    1288 </span><span class="lineCov">   13606957 :   code = gimple_assign_rhs_code (def_stmt);</span>
<span class="lineNum">    1289 </span><span class="lineCov">   27213914 :   if (code != ADDR_EXPR</span>
<span class="lineNum">    1290 </span><span class="lineCov">   13606957 :       &amp;&amp; code != POINTER_PLUS_EXPR)</span>
<span class="lineNum">    1291 </span>            :     return false;
<span class="lineNum">    1292 </span>            : 
<span class="lineNum">    1293 </span><span class="lineCov">   14392984 :   off = poly_offset_int::from (wi::to_poly_wide (mem_op-&gt;op0), SIGNED);</span>
<span class="lineNum">    1294 </span>            : 
<span class="lineNum">    1295 </span>            :   /* The only thing we have to do is from &amp;OBJ.foo.bar add the offset
<span class="lineNum">    1296 </span>            :      from .foo.bar to the preceding MEM_REF offset and replace the
<span class="lineNum">    1297 </span>            :      address with &amp;OBJ.  */
<span class="lineNum">    1298 </span><span class="lineCov">    7196492 :   if (code == ADDR_EXPR)</span>
<span class="lineNum">    1299 </span>            :     {
<span class="lineNum">    1300 </span><span class="lineCov">     253473 :       tree addr, addr_base;</span>
<span class="lineNum">    1301 </span><span class="lineCov">     253473 :       poly_int64 addr_offset;</span>
<span class="lineNum">    1302 </span>            : 
<span class="lineNum">    1303 </span><span class="lineCov">     253473 :       addr = gimple_assign_rhs1 (def_stmt);</span>
<span class="lineNum">    1304 </span><span class="lineCov">     253473 :       addr_base = get_addr_base_and_unit_offset (TREE_OPERAND (addr, 0),</span>
<span class="lineNum">    1305 </span>            :                                                  &amp;addr_offset);
<span class="lineNum">    1306 </span>            :       /* If that didn't work because the address isn't invariant propagate
<span class="lineNum">    1307 </span>            :          the reference tree from the address operation in case the current
<span class="lineNum">    1308 </span>            :          dereference isn't offsetted.  */
<span class="lineNum">    1309 </span><span class="lineCov">     253473 :       if (!addr_base</span>
<span class="lineNum">    1310 </span><span class="lineCov">     104454 :           &amp;&amp; *i_p == ops-&gt;length () - 1</span>
<span class="lineNum">    1311 </span><span class="lineCov">      52227 :           &amp;&amp; known_eq (off, 0)</span>
<span class="lineNum">    1312 </span>            :           /* This makes us disable this transform for PRE where the
<span class="lineNum">    1313 </span>            :              reference ops might be also used for code insertion which
<span class="lineNum">    1314 </span>            :              is invalid.  */
<span class="lineNum">    1315 </span><span class="lineCov">     285281 :           &amp;&amp; default_vn_walk_kind == VN_WALKREWRITE)</span>
<span class="lineNum">    1316 </span>            :         {
<span class="lineNum">    1317 </span><span class="lineCov">      63616 :           auto_vec&lt;vn_reference_op_s, 32&gt; tem;</span>
<span class="lineNum">    1318 </span><span class="lineCov">      31808 :           copy_reference_ops_from_ref (TREE_OPERAND (addr, 0), &amp;tem);</span>
<span class="lineNum">    1319 </span>            :           /* Make sure to preserve TBAA info.  The only objects not
<span class="lineNum">    1320 </span>            :              wrapped in MEM_REFs that can have their address taken are
<span class="lineNum">    1321 </span>            :              STRING_CSTs.  */
<span class="lineNum">    1322 </span><span class="lineCov">      31808 :           if (tem.length () &gt;= 2</span>
<span class="lineNum">    1323 </span><span class="lineCov">      31808 :               &amp;&amp; tem[tem.length () - 2].opcode == MEM_REF)</span>
<span class="lineNum">    1324 </span>            :             {
<span class="lineNum">    1325 </span><span class="lineCov">      63596 :               vn_reference_op_t new_mem_op = &amp;tem[tem.length () - 2];</span>
<span class="lineNum">    1326 </span><span class="lineCov">      31798 :               new_mem_op-&gt;op0</span>
<span class="lineNum">    1327 </span><span class="lineCov">      31798 :                 = wide_int_to_tree (TREE_TYPE (mem_op-&gt;op0),</span>
<span class="lineNum">    1328 </span><span class="lineCov">      95394 :                                     wi::to_poly_wide (new_mem_op-&gt;op0));</span>
<span class="lineNum">    1329 </span>            :             }
<span class="lineNum">    1330 </span>            :           else
<span class="lineNum">    1331 </span><span class="lineCov">         10 :             gcc_assert (tem.last ().opcode == STRING_CST);</span>
<span class="lineNum">    1332 </span><span class="lineCov">      31808 :           ops-&gt;pop ();</span>
<span class="lineNum">    1333 </span><span class="lineCov">      31808 :           ops-&gt;pop ();</span>
<span class="lineNum">    1334 </span><span class="lineCov">      31808 :           ops-&gt;safe_splice (tem);</span>
<span class="lineNum">    1335 </span><span class="lineCov">      31808 :           --*i_p;</span>
<span class="lineNum">    1336 </span><span class="lineCov">      31808 :           return true;</span>
<span class="lineNum">    1337 </span>            :         }
<span class="lineNum">    1338 </span><span class="lineCov">     221665 :       if (!addr_base</span>
<span class="lineNum">    1339 </span><span class="lineCov">     201246 :           || TREE_CODE (addr_base) != MEM_REF</span>
<span class="lineNum">    1340 </span><span class="lineCov">     422895 :           || (TREE_CODE (TREE_OPERAND (addr_base, 0)) == SSA_NAME</span>
<span class="lineNum">    1341 </span><span class="lineCov">     201206 :               &amp;&amp; SSA_NAME_OCCURS_IN_ABNORMAL_PHI (TREE_OPERAND (addr_base, 0))))</span>
<span class="lineNum">    1342 </span>            :         return false;
<span class="lineNum">    1343 </span>            : 
<span class="lineNum">    1344 </span><span class="lineCov">     201230 :       off += addr_offset;</span>
<span class="lineNum">    1345 </span><span class="lineCov">     201230 :       off += mem_ref_offset (addr_base);</span>
<span class="lineNum">    1346 </span><span class="lineCov">     201230 :       op-&gt;op0 = TREE_OPERAND (addr_base, 0);</span>
<span class="lineNum">    1347 </span>            :     }
<span class="lineNum">    1348 </span>            :   else
<span class="lineNum">    1349 </span>            :     {
<span class="lineNum">    1350 </span><span class="lineCov">    6943019 :       tree ptr, ptroff;</span>
<span class="lineNum">    1351 </span><span class="lineCov">    6943019 :       ptr = gimple_assign_rhs1 (def_stmt);</span>
<span class="lineNum">    1352 </span><span class="lineCov">    6943019 :       ptroff = gimple_assign_rhs2 (def_stmt);</span>
<span class="lineNum">    1353 </span><span class="lineCov">    6943019 :       if (TREE_CODE (ptr) != SSA_NAME</span>
<span class="lineNum">    1354 </span><span class="lineCov">   13391350 :           || SSA_NAME_OCCURS_IN_ABNORMAL_PHI (ptr)</span>
<span class="lineNum">    1355 </span>            :           /* Make sure to not endlessly recurse.
<span class="lineNum">    1356 </span>            :              See gcc.dg/tree-ssa/20040408-1.c for an example.  Can easily
<span class="lineNum">    1357 </span>            :              happen when we value-number a PHI to its backedge value.  */
<span class="lineNum">    1358 </span><span class="lineCov">    6694363 :           || SSA_VAL (ptr) == op-&gt;op0</span>
<span class="lineNum">    1359 </span><span class="lineCov">   20331745 :           || !poly_int_tree_p (ptroff))</span>
<span class="lineNum">    1360 </span><span class="lineCov">    5738861 :         return false;</span>
<span class="lineNum">    1361 </span>            : 
<span class="lineNum">    1362 </span><span class="lineCov">    1204158 :       off += wi::to_poly_offset (ptroff);</span>
<span class="lineNum">    1363 </span><span class="lineCov">    1204158 :       op-&gt;op0 = ptr;</span>
<span class="lineNum">    1364 </span>            :     }
<span class="lineNum">    1365 </span>            : 
<span class="lineNum">    1366 </span><span class="lineCov">    2810776 :   mem_op-&gt;op0 = wide_int_to_tree (TREE_TYPE (mem_op-&gt;op0), off);</span>
<span class="lineNum">    1367 </span><span class="lineCov">    1405388 :   if (tree_fits_shwi_p (mem_op-&gt;op0))</span>
<span class="lineNum">    1368 </span><span class="lineCov">    1347292 :     mem_op-&gt;off = tree_to_shwi (mem_op-&gt;op0);</span>
<span class="lineNum">    1369 </span>            :   else
<span class="lineNum">    1370 </span><span class="lineCov">     116192 :     mem_op-&gt;off = -1;</span>
<span class="lineNum">    1371 </span>            :   /* ???  Can end up with endless recursion here!?
<span class="lineNum">    1372 </span>            :      gcc.c-torture/execute/strcmp-1.c  */
<span class="lineNum">    1373 </span><span class="lineCov">    1405388 :   if (TREE_CODE (op-&gt;op0) == SSA_NAME)</span>
<span class="lineNum">    1374 </span><span class="lineCov">    1405364 :     op-&gt;op0 = SSA_VAL (op-&gt;op0);</span>
<span class="lineNum">    1375 </span><span class="lineCov">    1405388 :   if (TREE_CODE (op-&gt;op0) != SSA_NAME)</span>
<span class="lineNum">    1376 </span><span class="lineCov">        119 :     op-&gt;opcode = TREE_CODE (op-&gt;op0);</span>
<span class="lineNum">    1377 </span>            : 
<span class="lineNum">    1378 </span>            :   /* And recurse.  */
<span class="lineNum">    1379 </span><span class="lineCov">    1405388 :   if (TREE_CODE (op-&gt;op0) == SSA_NAME)</span>
<span class="lineNum">    1380 </span><span class="lineCov">    1405269 :     vn_reference_maybe_forwprop_address (ops, i_p);</span>
<span class="lineNum">    1381 </span><span class="lineCov">        119 :   else if (TREE_CODE (op-&gt;op0) == ADDR_EXPR)</span>
<span class="lineNum">    1382 </span><span class="lineCov">         95 :     vn_reference_fold_indirect (ops, i_p);</span>
<span class="lineNum">    1383 </span>            :   return true;
<span class="lineNum">    1384 </span>            : }
<span class="lineNum">    1385 </span>            : 
<span class="lineNum">    1386 </span>            : /* Optimize the reference REF to a constant if possible or return
<span class="lineNum">    1387 </span>            :    NULL_TREE if not.  */
<a name="1388"><span class="lineNum">    1388 </span>            : </a>
<span class="lineNum">    1389 </span>            : tree
<span class="lineNum">    1390 </span><span class="lineCov">   51768462 : fully_constant_vn_reference_p (vn_reference_t ref)</span>
<span class="lineNum">    1391 </span>            : {
<span class="lineNum">    1392 </span><span class="lineCov">   51768462 :   vec&lt;vn_reference_op_s&gt; operands = ref-&gt;operands;</span>
<span class="lineNum">    1393 </span><span class="lineCov">   51768462 :   vn_reference_op_t op;</span>
<span class="lineNum">    1394 </span>            : 
<span class="lineNum">    1395 </span>            :   /* Try to simplify the translated expression if it is
<span class="lineNum">    1396 </span>            :      a call to a builtin function with at most two arguments.  */
<span class="lineNum">    1397 </span><span class="lineCov">   51768462 :   op = &amp;operands[0];</span>
<span class="lineNum">    1398 </span><span class="lineCov">   51768462 :   if (op-&gt;opcode == CALL_EXPR</span>
<span class="lineNum">    1399 </span><span class="lineCov">      46154 :       &amp;&amp; TREE_CODE (op-&gt;op0) == ADDR_EXPR</span>
<span class="lineNum">    1400 </span><span class="lineCov">      46154 :       &amp;&amp; TREE_CODE (TREE_OPERAND (op-&gt;op0, 0)) == FUNCTION_DECL</span>
<span class="lineNum">    1401 </span><span class="lineCov">      46154 :       &amp;&amp; fndecl_built_in_p (TREE_OPERAND (op-&gt;op0, 0))</span>
<span class="lineNum">    1402 </span><span class="lineCov">      64978 :       &amp;&amp; operands.length () &gt;= 2</span>
<span class="lineNum">    1403 </span><span class="lineCov">   51833440 :       &amp;&amp; operands.length () &lt;= 3)</span>
<span class="lineNum">    1404 </span>            :     {
<span class="lineNum">    1405 </span><span class="lineCov">      23423 :       vn_reference_op_t arg0, arg1 = NULL;</span>
<span class="lineNum">    1406 </span><span class="lineCov">      23423 :       bool anyconst = false;</span>
<span class="lineNum">    1407 </span><span class="lineCov">      23423 :       arg0 = &amp;operands[1];</span>
<span class="lineNum">    1408 </span><span class="lineCov">      46846 :       if (operands.length () &gt; 2)</span>
<span class="lineNum">    1409 </span><span class="lineCov">       5964 :         arg1 = &amp;operands[2];</span>
<span class="lineNum">    1410 </span><span class="lineCov">      23423 :       if (TREE_CODE_CLASS (arg0-&gt;opcode) == tcc_constant</span>
<span class="lineNum">    1411 </span><span class="lineCov">      23423 :           || (arg0-&gt;opcode == ADDR_EXPR</span>
<span class="lineNum">    1412 </span><span class="lineCov">        562 :               &amp;&amp; is_gimple_min_invariant (arg0-&gt;op0)))</span>
<span class="lineNum">    1413 </span>            :         anyconst = true;
<span class="lineNum">    1414 </span><span class="lineCov">      23423 :       if (arg1</span>
<span class="lineNum">    1415 </span><span class="lineCov">      23423 :           &amp;&amp; (TREE_CODE_CLASS (arg1-&gt;opcode) == tcc_constant</span>
<span class="lineNum">    1416 </span><span class="lineCov">       2160 :               || (arg1-&gt;opcode == ADDR_EXPR</span>
<span class="lineNum">    1417 </span><span class="lineCov">        289 :                   &amp;&amp; is_gimple_min_invariant (arg1-&gt;op0))))</span>
<span class="lineNum">    1418 </span>            :         anyconst = true;
<span class="lineNum">    1419 </span><span class="lineCov">      22312 :       if (anyconst)</span>
<span class="lineNum">    1420 </span>            :         {
<span class="lineNum">    1421 </span><span class="lineCov">      34680 :           tree folded = build_call_expr (TREE_OPERAND (op-&gt;op0, 0),</span>
<span class="lineNum">    1422 </span>            :                                          arg1 ? 2 : 1,
<span class="lineNum">    1423 </span>            :                                          arg0-&gt;op0,
<span class="lineNum">    1424 </span><span class="lineCov">      18209 :                                          arg1 ? arg1-&gt;op0 : NULL);</span>
<span class="lineNum">    1425 </span><span class="lineCov">      18209 :           if (folded</span>
<span class="lineNum">    1426 </span><span class="lineCov">      18209 :               &amp;&amp; TREE_CODE (folded) == NOP_EXPR)</span>
<span class="lineNum">    1427 </span><span class="lineCov">        317 :             folded = TREE_OPERAND (folded, 0);</span>
<span class="lineNum">    1428 </span><span class="lineCov">      18209 :           if (folded</span>
<span class="lineNum">    1429 </span><span class="lineCov">      18209 :               &amp;&amp; is_gimple_min_invariant (folded))</span>
<span class="lineNum">    1430 </span><span class="lineCov">        345 :             return folded;</span>
<span class="lineNum">    1431 </span>            :         }
<span class="lineNum">    1432 </span>            :     }
<span class="lineNum">    1433 </span>            : 
<span class="lineNum">    1434 </span>            :   /* Simplify reads from constants or constant initializers.  */
<span class="lineNum">    1435 </span><span class="lineCov">   51745039 :   else if (BITS_PER_UNIT == 8</span>
<span class="lineNum">    1436 </span><span class="lineCov">   51745039 :            &amp;&amp; COMPLETE_TYPE_P (ref-&gt;type)</span>
<span class="lineNum">    1437 </span><span class="lineCov">   51745039 :            &amp;&amp; is_gimple_reg_type (ref-&gt;type))</span>
<span class="lineNum">    1438 </span>            :     {
<span class="lineNum">    1439 </span><span class="lineCov">   49755753 :       poly_int64 off = 0;</span>
<span class="lineNum">    1440 </span><span class="lineCov">   49755753 :       HOST_WIDE_INT size;</span>
<span class="lineNum">    1441 </span><span class="lineCov">   49755753 :       if (INTEGRAL_TYPE_P (ref-&gt;type))</span>
<span class="lineNum">    1442 </span><span class="lineCov">   50468910 :         size = TYPE_PRECISION (ref-&gt;type);</span>
<span class="lineNum">    1443 </span><span class="lineCov">   49042596 :       else if (tree_fits_shwi_p (TYPE_SIZE (ref-&gt;type)))</span>
<span class="lineNum">    1444 </span><span class="lineCov">   49042596 :         size = tree_to_shwi (TYPE_SIZE (ref-&gt;type));</span>
<span class="lineNum">    1445 </span>            :       else
<span class="lineNum">    1446 </span>            :         return NULL_TREE;
<span class="lineNum">    1447 </span><span class="lineCov">   49755753 :       if (size % BITS_PER_UNIT != 0</span>
<span class="lineNum">    1448 </span><span class="lineCov">   48690665 :           || size &gt; MAX_BITSIZE_MODE_ANY_MODE)</span>
<span class="lineNum">    1449 </span>            :         return NULL_TREE;
<span class="lineNum">    1450 </span><span class="lineCov">   48690665 :       size /= BITS_PER_UNIT;</span>
<span class="lineNum">    1451 </span><span class="lineCov">   48690665 :       unsigned i;</span>
<span class="lineNum">    1452 </span><span class="lineCov">   80774350 :       for (i = 0; i &lt; operands.length (); ++i)</span>
<span class="lineNum">    1453 </span>            :         {
<span class="lineNum">    1454 </span><span class="lineCov">   80774350 :           if (TREE_CODE_CLASS (operands[i].opcode) == tcc_constant)</span>
<span class="lineNum">    1455 </span>            :             {
<span class="lineNum">    1456 </span><span class="lineCov">        243 :               ++i;</span>
<span class="lineNum">    1457 </span><span class="lineCov">        243 :               break;</span>
<span class="lineNum">    1458 </span>            :             }
<span class="lineNum">    1459 </span><span class="lineCov">  161548214 :           if (known_eq (operands[i].off, -1))</span>
<span class="lineNum">    1460 </span>            :             return NULL_TREE;
<span class="lineNum">    1461 </span><span class="lineCov">  145793014 :           off += operands[i].off;</span>
<span class="lineNum">    1462 </span><span class="lineCov">  145793014 :           if (operands[i].opcode == MEM_REF)</span>
<span class="lineNum">    1463 </span>            :             {
<span class="lineNum">    1464 </span><span class="lineCov">   40812822 :               ++i;</span>
<span class="lineNum">    1465 </span><span class="lineCov">   40812822 :               break;</span>
<span class="lineNum">    1466 </span>            :             }
<span class="lineNum">    1467 </span>            :         }
<span class="lineNum">    1468 </span><span class="lineCov">   40813065 :       vn_reference_op_t base = &amp;operands[--i];</span>
<span class="lineNum">    1469 </span><span class="lineCov">   40813065 :       tree ctor = error_mark_node;</span>
<span class="lineNum">    1470 </span><span class="lineCov">   40813065 :       tree decl = NULL_TREE;</span>
<span class="lineNum">    1471 </span><span class="lineCov">   40813065 :       if (TREE_CODE_CLASS (base-&gt;opcode) == tcc_constant)</span>
<span class="lineNum">    1472 </span><span class="lineCov">        243 :         ctor = base-&gt;op0;</span>
<span class="lineNum">    1473 </span><span class="lineCov">   40812822 :       else if (base-&gt;opcode == MEM_REF</span>
<span class="lineNum">    1474 </span><span class="lineCov">   40812822 :                &amp;&amp; base[1].opcode == ADDR_EXPR</span>
<span class="lineNum">    1475 </span><span class="lineCov">   67149046 :                &amp;&amp; (TREE_CODE (TREE_OPERAND (base[1].op0, 0)) == VAR_DECL</span>
<span class="lineNum">    1476 </span><span class="lineCov">    1961411 :                    || TREE_CODE (TREE_OPERAND (base[1].op0, 0)) == CONST_DECL</span>
<span class="lineNum">    1477 </span><span class="lineCov">    1961394 :                    || TREE_CODE (TREE_OPERAND (base[1].op0, 0)) == STRING_CST))</span>
<span class="lineNum">    1478 </span>            :         {
<span class="lineNum">    1479 </span><span class="lineCov">   24378297 :           decl = TREE_OPERAND (base[1].op0, 0);</span>
<span class="lineNum">    1480 </span><span class="lineCov">   24378297 :           if (TREE_CODE (decl) == STRING_CST)</span>
<span class="lineNum">    1481 </span>            :             ctor = decl;
<span class="lineNum">    1482 </span>            :           else
<span class="lineNum">    1483 </span><span class="lineCov">   24374830 :             ctor = ctor_for_folding (decl);</span>
<span class="lineNum">    1484 </span>            :         }
<span class="lineNum">    1485 </span><span class="lineCov">   40813065 :       if (ctor == NULL_TREE)</span>
<span class="lineNum">    1486 </span><span class="lineCov">        102 :         return build_zero_cst (ref-&gt;type);</span>
<span class="lineNum">    1487 </span><span class="lineCov">   40812963 :       else if (ctor != error_mark_node)</span>
<span class="lineNum">    1488 </span>            :         {
<span class="lineNum">    1489 </span><span class="lineCov">      57678 :           HOST_WIDE_INT const_off;</span>
<span class="lineNum">    1490 </span><span class="lineCov">      57678 :           if (decl)</span>
<span class="lineNum">    1491 </span>            :             {
<span class="lineNum">    1492 </span><span class="lineCov">      57435 :               tree res = fold_ctor_reference (ref-&gt;type, ctor,</span>
<span class="lineNum">    1493 </span><span class="lineCov">     114870 :                                               off * BITS_PER_UNIT,</span>
<span class="lineNum">    1494 </span><span class="lineCov">      57435 :                                               size * BITS_PER_UNIT, decl);</span>
<span class="lineNum">    1495 </span><span class="lineCov">      57435 :               if (res)</span>
<span class="lineNum">    1496 </span>            :                 {
<span class="lineNum">    1497 </span><span class="lineCov">      28857 :                   STRIP_USELESS_TYPE_CONVERSION (res);</span>
<span class="lineNum">    1498 </span><span class="lineCov">      28857 :                   if (is_gimple_min_invariant (res))</span>
<span class="lineNum">    1499 </span><span class="lineCov">      28773 :                     return res;</span>
<span class="lineNum">    1500 </span>            :                 }
<span class="lineNum">    1501 </span>            :             }
<span class="lineNum">    1502 </span><span class="lineCov">        243 :           else if (off.is_constant (&amp;const_off))</span>
<span class="lineNum">    1503 </span>            :             {
<span class="lineNum">    1504 </span><span class="lineCov">        243 :               unsigned char buf[MAX_BITSIZE_MODE_ANY_MODE / BITS_PER_UNIT];</span>
<span class="lineNum">    1505 </span><span class="lineCov">        243 :               int len = native_encode_expr (ctor, buf, size, const_off);</span>
<span class="lineNum">    1506 </span><span class="lineCov">        243 :               if (len &gt; 0)</span>
<span class="lineNum">    1507 </span><span class="lineCov">         91 :                 return native_interpret_expr (ref-&gt;type, buf, len);</span>
<span class="lineNum">    1508 </span>            :             }
<span class="lineNum">    1509 </span>            :         }
<span class="lineNum">    1510 </span>            :     }
<span class="lineNum">    1511 </span>            : 
<span class="lineNum">    1512 </span>            :   return NULL_TREE;
<span class="lineNum">    1513 </span>            : }
<span class="lineNum">    1514 </span>            : 
<span class="lineNum">    1515 </span>            : /* Return true if OPS contain a storage order barrier.  */
<a name="1516"><span class="lineNum">    1516 </span>            : </a>
<span class="lineNum">    1517 </span>            : static bool
<span class="lineNum">    1518 </span><span class="lineNoCov">          0 : contains_storage_order_barrier_p (vec&lt;vn_reference_op_s&gt; ops)</span>
<span class="lineNum">    1519 </span>            : {
<span class="lineNum">    1520 </span><span class="lineCov">   18967610 :   vn_reference_op_t op;</span>
<span class="lineNum">    1521 </span><span class="lineCov">   18967610 :   unsigned i;</span>
<span class="lineNum">    1522 </span>            : 
<span class="lineNum">    1523 </span><span class="lineCov">   70183023 :   FOR_EACH_VEC_ELT (ops, i, op)</span>
<span class="lineNum">    1524 </span><span class="lineCov">   51215413 :     if (op-&gt;opcode == VIEW_CONVERT_EXPR &amp;&amp; op-&gt;reverse)</span>
<span class="lineNum">    1525 </span>            :       return true;
<span class="lineNum">    1526 </span>            : 
<span class="lineNum">    1527 </span>            :   return false;
<span class="lineNum">    1528 </span>            : }
<span class="lineNum">    1529 </span>            : 
<span class="lineNum">    1530 </span>            : /* Transform any SSA_NAME's in a vector of vn_reference_op_s
<span class="lineNum">    1531 </span>            :    structures into their value numbers.  This is done in-place, and
<span class="lineNum">    1532 </span>            :    the vector passed in is returned.  *VALUEIZED_ANYTHING will specify
<span class="lineNum">    1533 </span>            :    whether any operands were valueized.  */
<a name="1534"><span class="lineNum">    1534 </span>            : </a>
<span class="lineNum">    1535 </span>            : static vec&lt;vn_reference_op_s&gt; 
<span class="lineNum">    1536 </span><span class="lineCov">   97094325 : valueize_refs_1 (vec&lt;vn_reference_op_s&gt; orig, bool *valueized_anything,</span>
<span class="lineNum">    1537 </span>            :                  bool with_avail = false)
<span class="lineNum">    1538 </span>            : {
<span class="lineNum">    1539 </span><span class="lineCov">   97094325 :   vn_reference_op_t vro;</span>
<span class="lineNum">    1540 </span><span class="lineCov">   97094325 :   unsigned int i;</span>
<span class="lineNum">    1541 </span>            : 
<span class="lineNum">    1542 </span><span class="lineCov">   97094325 :   *valueized_anything = false;</span>
<span class="lineNum">    1543 </span>            : 
<span class="lineNum">    1544 </span><span class="lineCov">  380070952 :   FOR_EACH_VEC_ELT (orig, i, vro)</span>
<span class="lineNum">    1545 </span>            :     {
<span class="lineNum">    1546 </span><span class="lineCov">  282976627 :       if (vro-&gt;opcode == SSA_NAME</span>
<span class="lineNum">    1547 </span><span class="lineCov">  244817803 :           || (vro-&gt;op0 &amp;&amp; TREE_CODE (vro-&gt;op0) == SSA_NAME))</span>
<span class="lineNum">    1548 </span>            :         {
<span class="lineNum">    1549 </span><span class="lineCov">   49136761 :           tree tem = with_avail ? vn_valueize (vro-&gt;op0) : SSA_VAL (vro-&gt;op0);</span>
<span class="lineNum">    1550 </span><span class="lineCov">   49136761 :           if (tem != vro-&gt;op0)</span>
<span class="lineNum">    1551 </span>            :             {
<span class="lineNum">    1552 </span><span class="lineCov">    6506729 :               *valueized_anything = true;</span>
<span class="lineNum">    1553 </span><span class="lineCov">    6506729 :               vro-&gt;op0 = tem;</span>
<span class="lineNum">    1554 </span>            :             }
<span class="lineNum">    1555 </span>            :           /* If it transforms from an SSA_NAME to a constant, update
<span class="lineNum">    1556 </span>            :              the opcode.  */
<span class="lineNum">    1557 </span><span class="lineCov">   49136761 :           if (TREE_CODE (vro-&gt;op0) != SSA_NAME &amp;&amp; vro-&gt;opcode == SSA_NAME)</span>
<span class="lineNum">    1558 </span><span class="lineCov">     344975 :             vro-&gt;opcode = TREE_CODE (vro-&gt;op0);</span>
<span class="lineNum">    1559 </span>            :         }
<span class="lineNum">    1560 </span><span class="lineCov">  282976627 :       if (vro-&gt;op1 &amp;&amp; TREE_CODE (vro-&gt;op1) == SSA_NAME)</span>
<span class="lineNum">    1561 </span>            :         {
<span class="lineNum">    1562 </span><span class="lineCov">      12814 :           tree tem = with_avail ? vn_valueize (vro-&gt;op1) : SSA_VAL (vro-&gt;op1);</span>
<span class="lineNum">    1563 </span><span class="lineCov">      12814 :           if (tem != vro-&gt;op1)</span>
<span class="lineNum">    1564 </span>            :             {
<span class="lineNum">    1565 </span><span class="lineCov">        272 :               *valueized_anything = true;</span>
<span class="lineNum">    1566 </span><span class="lineCov">        272 :               vro-&gt;op1 = tem;</span>
<span class="lineNum">    1567 </span>            :             }
<span class="lineNum">    1568 </span>            :         }
<span class="lineNum">    1569 </span><span class="lineCov">  282976627 :       if (vro-&gt;op2 &amp;&amp; TREE_CODE (vro-&gt;op2) == SSA_NAME)</span>
<span class="lineNum">    1570 </span>            :         {
<span class="lineNum">    1571 </span><span class="lineCov">      72560 :           tree tem = with_avail ? vn_valueize (vro-&gt;op2) : SSA_VAL (vro-&gt;op2);</span>
<span class="lineNum">    1572 </span><span class="lineCov">      72560 :           if (tem != vro-&gt;op2)</span>
<span class="lineNum">    1573 </span>            :             {
<span class="lineNum">    1574 </span><span class="lineCov">      35935 :               *valueized_anything = true;</span>
<span class="lineNum">    1575 </span><span class="lineCov">      35935 :               vro-&gt;op2 = tem;</span>
<span class="lineNum">    1576 </span>            :             }
<span class="lineNum">    1577 </span>            :         }
<span class="lineNum">    1578 </span>            :       /* If it transforms from an SSA_NAME to an address, fold with
<span class="lineNum">    1579 </span>            :          a preceding indirect reference.  */
<span class="lineNum">    1580 </span><span class="lineCov">  282976627 :       if (i &gt; 0</span>
<span class="lineNum">    1581 </span><span class="lineCov">  185882302 :           &amp;&amp; vro-&gt;op0</span>
<span class="lineNum">    1582 </span><span class="lineCov">  185625586 :           &amp;&amp; TREE_CODE (vro-&gt;op0) == ADDR_EXPR</span>
<span class="lineNum">    1583 </span><span class="lineCov">  344269020 :           &amp;&amp; orig[i - 1].opcode == MEM_REF)</span>
<span class="lineNum">    1584 </span>            :         {
<span class="lineNum">    1585 </span><span class="lineCov">   58561761 :           if (vn_reference_fold_indirect (&amp;orig, &amp;i))</span>
<span class="lineNum">    1586 </span><span class="lineCov">     146885 :             *valueized_anything = true;</span>
<span class="lineNum">    1587 </span>            :         }
<span class="lineNum">    1588 </span><span class="lineCov">  224414866 :       else if (i &gt; 0</span>
<span class="lineNum">    1589 </span><span class="lineCov">  127320541 :                &amp;&amp; vro-&gt;opcode == SSA_NAME</span>
<span class="lineNum">    1590 </span><span class="lineCov">  262228715 :                &amp;&amp; orig[i - 1].opcode == MEM_REF)</span>
<span class="lineNum">    1591 </span>            :         {
<span class="lineNum">    1592 </span><span class="lineCov">   34664473 :           if (vn_reference_maybe_forwprop_address (&amp;orig, &amp;i))</span>
<span class="lineNum">    1593 </span><span class="lineCov">     554661 :             *valueized_anything = true;</span>
<span class="lineNum">    1594 </span>            :         }
<span class="lineNum">    1595 </span>            :       /* If it transforms a non-constant ARRAY_REF into a constant
<span class="lineNum">    1596 </span>            :          one, adjust the constant offset.  */
<span class="lineNum">    1597 </span><span class="lineCov">  189750393 :       else if (vro-&gt;opcode == ARRAY_REF</span>
<span class="lineNum">    1598 </span><span class="lineCov">   16648209 :                &amp;&amp; known_eq (vro-&gt;off, -1)</span>
<span class="lineNum">    1599 </span><span class="lineCov">   14516002 :                &amp;&amp; poly_int_tree_p (vro-&gt;op0)</span>
<span class="lineNum">    1600 </span><span class="lineCov">    4162592 :                &amp;&amp; poly_int_tree_p (vro-&gt;op1)</span>
<span class="lineNum">    1601 </span><span class="lineCov">  191831689 :                &amp;&amp; TREE_CODE (vro-&gt;op2) == INTEGER_CST)</span>
<span class="lineNum">    1602 </span>            :         {
<span class="lineNum">    1603 </span><span class="lineCov">    8156748 :           poly_offset_int off = ((wi::to_poly_offset (vro-&gt;op0)</span>
<span class="lineNum">    1604 </span><span class="lineCov">    2039187 :                                   - wi::to_poly_offset (vro-&gt;op1))</span>
<span class="lineNum">    1605 </span><span class="lineCov">    4078374 :                                  * wi::to_offset (vro-&gt;op2)</span>
<span class="lineNum">    1606 </span><span class="lineCov">    6117561 :                                  * vn_ref_op_align_unit (vro));</span>
<span class="lineNum">    1607 </span><span class="lineCov">    4077517 :           off.to_shwi (&amp;vro-&gt;off);</span>
<span class="lineNum">    1608 </span>            :         }
<span class="lineNum">    1609 </span>            :     }
<span class="lineNum">    1610 </span>            : 
<span class="lineNum">    1611 </span><span class="lineCov">   97094325 :   return orig;</span>
<span class="lineNum">    1612 </span>            : }
<a name="1613"><span class="lineNum">    1613 </span>            : </a>
<span class="lineNum">    1614 </span>            : static vec&lt;vn_reference_op_s&gt; 
<span class="lineNum">    1615 </span><span class="lineNoCov">          0 : valueize_refs (vec&lt;vn_reference_op_s&gt; orig)</span>
<span class="lineNum">    1616 </span>            : {
<span class="lineNum">    1617 </span><span class="lineCov">   11681251 :   bool tem;</span>
<span class="lineNum">    1618 </span><span class="lineNoCov">          0 :   return valueize_refs_1 (orig, &amp;tem);</span>
<span class="lineNum">    1619 </span>            : }
<span class="lineNum">    1620 </span>            : 
<span class="lineNum">    1621 </span>            : static vec&lt;vn_reference_op_s&gt; shared_lookup_references;
<span class="lineNum">    1622 </span>            : 
<span class="lineNum">    1623 </span>            : /* Create a vector of vn_reference_op_s structures from REF, a
<span class="lineNum">    1624 </span>            :    REFERENCE_CLASS_P tree.  The vector is shared among all callers of
<span class="lineNum">    1625 </span>            :    this function.  *VALUEIZED_ANYTHING will specify whether any
<span class="lineNum">    1626 </span>            :    operands were valueized.  */
<a name="1627"><span class="lineNum">    1627 </span>            : </a>
<span class="lineNum">    1628 </span>            : static vec&lt;vn_reference_op_s&gt; 
<span class="lineNum">    1629 </span><span class="lineCov">   80242926 : valueize_shared_reference_ops_from_ref (tree ref, bool *valueized_anything)</span>
<span class="lineNum">    1630 </span>            : {
<span class="lineNum">    1631 </span><span class="lineCov">   80242926 :   if (!ref)</span>
<span class="lineNum">    1632 </span><span class="lineNoCov">          0 :     return vNULL;</span>
<span class="lineNum">    1633 </span><span class="lineCov">   80242926 :   shared_lookup_references.truncate (0);</span>
<span class="lineNum">    1634 </span><span class="lineCov">   80242926 :   copy_reference_ops_from_ref (ref, &amp;shared_lookup_references);</span>
<span class="lineNum">    1635 </span><span class="lineCov">   80242926 :   shared_lookup_references = valueize_refs_1 (shared_lookup_references,</span>
<span class="lineNum">    1636 </span><span class="lineCov">   80242926 :                                               valueized_anything);</span>
<span class="lineNum">    1637 </span><span class="lineCov">   80242926 :   return shared_lookup_references;</span>
<span class="lineNum">    1638 </span>            : }
<span class="lineNum">    1639 </span>            : 
<span class="lineNum">    1640 </span>            : /* Create a vector of vn_reference_op_s structures from CALL, a
<span class="lineNum">    1641 </span>            :    call statement.  The vector is shared among all callers of
<span class="lineNum">    1642 </span>            :    this function.  */
<a name="1643"><span class="lineNum">    1643 </span>            : </a>
<span class="lineNum">    1644 </span>            : static vec&lt;vn_reference_op_s&gt; 
<span class="lineNum">    1645 </span><span class="lineCov">    4358408 : valueize_shared_reference_ops_from_call (gcall *call)</span>
<span class="lineNum">    1646 </span>            : {
<span class="lineNum">    1647 </span><span class="lineCov">    4358408 :   if (!call)</span>
<span class="lineNum">    1648 </span><span class="lineNoCov">          0 :     return vNULL;</span>
<span class="lineNum">    1649 </span><span class="lineCov">    4358408 :   shared_lookup_references.truncate (0);</span>
<span class="lineNum">    1650 </span><span class="lineCov">    4358408 :   copy_reference_ops_from_call (call, &amp;shared_lookup_references);</span>
<span class="lineNum">    1651 </span><span class="lineCov">    4358408 :   shared_lookup_references = valueize_refs (shared_lookup_references);</span>
<span class="lineNum">    1652 </span><span class="lineCov">    4358408 :   return shared_lookup_references;</span>
<span class="lineNum">    1653 </span>            : }
<span class="lineNum">    1654 </span>            : 
<span class="lineNum">    1655 </span>            : /* Lookup a SCCVN reference operation VR in the current hash table.
<span class="lineNum">    1656 </span>            :    Returns the resulting value number if it exists in the hash table,
<span class="lineNum">    1657 </span>            :    NULL_TREE otherwise.  VNRESULT will be filled in with the actual
<span class="lineNum">    1658 </span>            :    vn_reference_t stored in the hashtable if something is found.  */
<a name="1659"><span class="lineNum">    1659 </span>            : </a>
<span class="lineNum">    1660 </span>            : static tree
<span class="lineNum">    1661 </span><span class="lineCov">   30717902 : vn_reference_lookup_1 (vn_reference_t vr, vn_reference_t *vnresult)</span>
<span class="lineNum">    1662 </span>            : {
<span class="lineNum">    1663 </span><span class="lineCov">   30717902 :   vn_reference_s **slot;</span>
<span class="lineNum">    1664 </span><span class="lineCov">   30717902 :   hashval_t hash;</span>
<span class="lineNum">    1665 </span>            : 
<span class="lineNum">    1666 </span><span class="lineCov">   30717902 :   hash = vr-&gt;hashcode;</span>
<span class="lineNum">    1667 </span><span class="lineCov">   30717902 :   slot = valid_info-&gt;references-&gt;find_slot_with_hash (vr, hash, NO_INSERT);</span>
<span class="lineNum">    1668 </span><span class="lineCov">   30717902 :   if (slot)</span>
<span class="lineNum">    1669 </span>            :     {
<span class="lineNum">    1670 </span><span class="lineCov">    3178067 :       if (vnresult)</span>
<span class="lineNum">    1671 </span><span class="lineCov">    2973993 :         *vnresult = (vn_reference_t)*slot;</span>
<span class="lineNum">    1672 </span><span class="lineCov">    3178067 :       return ((vn_reference_t)*slot)-&gt;result;</span>
<span class="lineNum">    1673 </span>            :     }
<span class="lineNum">    1674 </span>            : 
<span class="lineNum">    1675 </span>            :   return NULL_TREE;
<span class="lineNum">    1676 </span>            : }
<span class="lineNum">    1677 </span>            : 
<span class="lineNum">    1678 </span>            : /* Callback for walk_non_aliased_vuses.  Adjusts the vn_reference_t VR_
<span class="lineNum">    1679 </span>            :    with the current VUSE and performs the expression lookup.  */
<a name="1680"><span class="lineNum">    1680 </span>            : </a>
<span class="lineNum">    1681 </span>            : static void *
<span class="lineNum">    1682 </span><span class="lineCov">  519095265 : vn_reference_lookup_2 (ao_ref *op ATTRIBUTE_UNUSED, tree vuse,</span>
<span class="lineNum">    1683 </span>            :                        unsigned int cnt, void *vr_)
<span class="lineNum">    1684 </span>            : {
<span class="lineNum">    1685 </span><span class="lineCov">  519095265 :   vn_reference_t vr = (vn_reference_t)vr_;</span>
<span class="lineNum">    1686 </span><span class="lineCov">  519095265 :   vn_reference_s **slot;</span>
<span class="lineNum">    1687 </span><span class="lineCov">  519095265 :   hashval_t hash;</span>
<span class="lineNum">    1688 </span>            : 
<span class="lineNum">    1689 </span>            :   /* This bounds the stmt walks we perform on reference lookups
<span class="lineNum">    1690 </span>            :      to O(1) instead of O(N) where N is the number of dominating
<span class="lineNum">    1691 </span>            :      stores.  */
<span class="lineNum">    1692 </span><span class="lineCov">  519095265 :   if (cnt &gt; (unsigned) PARAM_VALUE (PARAM_SCCVN_MAX_ALIAS_QUERIES_PER_ACCESS))</span>
<span class="lineNum">    1693 </span>            :     return (void *)-1;
<span class="lineNum">    1694 </span>            : 
<span class="lineNum">    1695 </span><span class="lineCov">  518957059 :   if (last_vuse_ptr)</span>
<span class="lineNum">    1696 </span><span class="lineCov">   68483157 :     *last_vuse_ptr = vuse;</span>
<span class="lineNum">    1697 </span>            : 
<span class="lineNum">    1698 </span>            :   /* Fixup vuse and hash.  */
<span class="lineNum">    1699 </span><span class="lineCov">  518957059 :   if (vr-&gt;vuse)</span>
<span class="lineNum">    1700 </span><span class="lineCov">  518957059 :     vr-&gt;hashcode = vr-&gt;hashcode - SSA_NAME_VERSION (vr-&gt;vuse);</span>
<span class="lineNum">    1701 </span><span class="lineCov">  518957059 :   vr-&gt;vuse = vuse_ssa_val (vuse);</span>
<span class="lineNum">    1702 </span><span class="lineCov">  518957059 :   if (vr-&gt;vuse)</span>
<span class="lineNum">    1703 </span><span class="lineCov">  518957059 :     vr-&gt;hashcode = vr-&gt;hashcode + SSA_NAME_VERSION (vr-&gt;vuse);</span>
<span class="lineNum">    1704 </span>            : 
<span class="lineNum">    1705 </span><span class="lineCov">  518957059 :   hash = vr-&gt;hashcode;</span>
<span class="lineNum">    1706 </span><span class="lineCov">  518957059 :   slot = valid_info-&gt;references-&gt;find_slot_with_hash (vr, hash, NO_INSERT);</span>
<span class="lineNum">    1707 </span><span class="lineCov">  518957059 :   if (slot)</span>
<span class="lineNum">    1708 </span><span class="lineCov">    3688275 :     return *slot;</span>
<span class="lineNum">    1709 </span>            : 
<span class="lineNum">    1710 </span>            :   return NULL;
<span class="lineNum">    1711 </span>            : }
<span class="lineNum">    1712 </span>            : 
<span class="lineNum">    1713 </span>            : /* Lookup an existing or insert a new vn_reference entry into the
<span class="lineNum">    1714 </span>            :    value table for the VUSE, SET, TYPE, OPERANDS reference which
<span class="lineNum">    1715 </span>            :    has the value VALUE which is either a constant or an SSA name.  */
<a name="1716"><span class="lineNum">    1716 </span>            : </a>
<span class="lineNum">    1717 </span>            : static vn_reference_t
<span class="lineNum">    1718 </span><span class="lineCov">     435975 : vn_reference_lookup_or_insert_for_pieces (tree vuse,</span>
<span class="lineNum">    1719 </span>            :                                           alias_set_type set,
<span class="lineNum">    1720 </span>            :                                           tree type,
<span class="lineNum">    1721 </span>            :                                           vec&lt;vn_reference_op_s,
<span class="lineNum">    1722 </span>            :                                                 va_heap&gt; operands,
<span class="lineNum">    1723 </span>            :                                           tree value)
<span class="lineNum">    1724 </span>            : {
<span class="lineNum">    1725 </span><span class="lineCov">     435975 :   vn_reference_s vr1;</span>
<span class="lineNum">    1726 </span><span class="lineCov">     435975 :   vn_reference_t result;</span>
<span class="lineNum">    1727 </span><span class="lineCov">     435975 :   unsigned value_id;</span>
<span class="lineNum">    1728 </span><span class="lineCov">     435975 :   vr1.vuse = vuse ? SSA_VAL (vuse) : NULL_TREE;</span>
<span class="lineNum">    1729 </span><span class="lineCov">     435975 :   vr1.operands = operands;</span>
<span class="lineNum">    1730 </span><span class="lineCov">     435975 :   vr1.type = type;</span>
<span class="lineNum">    1731 </span><span class="lineCov">     435975 :   vr1.set = set;</span>
<span class="lineNum">    1732 </span><span class="lineCov">     435975 :   vr1.hashcode = vn_reference_compute_hash (&amp;vr1);</span>
<span class="lineNum">    1733 </span><span class="lineCov">     435975 :   if (vn_reference_lookup_1 (&amp;vr1, &amp;result))</span>
<span class="lineNum">    1734 </span><span class="lineCov">       1907 :     return result;</span>
<span class="lineNum">    1735 </span><span class="lineCov">     434068 :   if (TREE_CODE (value) == SSA_NAME)</span>
<span class="lineNum">    1736 </span><span class="lineCov">      25316 :     value_id = VN_INFO (value)-&gt;value_id;</span>
<span class="lineNum">    1737 </span>            :   else
<span class="lineNum">    1738 </span><span class="lineCov">     408752 :     value_id = get_or_alloc_constant_value_id (value);</span>
<span class="lineNum">    1739 </span><span class="lineCov">     868136 :   return vn_reference_insert_pieces (vuse, set, type,</span>
<span class="lineNum">    1740 </span><span class="lineCov">     434068 :                                      operands.copy (), value, value_id);</span>
<span class="lineNum">    1741 </span>            : }
<span class="lineNum">    1742 </span>            : 
<span class="lineNum">    1743 </span>            : /* Return a value-number for RCODE OPS... either by looking up an existing
<span class="lineNum">    1744 </span>            :    value-number for the simplified result or by inserting the operation if
<span class="lineNum">    1745 </span>            :    INSERT is true.  */
<a name="1746"><span class="lineNum">    1746 </span>            : </a>
<span class="lineNum">    1747 </span>            : static tree
<span class="lineNum">    1748 </span><span class="lineCov">    3716061 : vn_nary_build_or_lookup_1 (gimple_match_op *res_op, bool insert)</span>
<span class="lineNum">    1749 </span>            : {
<span class="lineNum">    1750 </span><span class="lineCov">    3716061 :   tree result = NULL_TREE;</span>
<span class="lineNum">    1751 </span>            :   /* We will be creating a value number for
<span class="lineNum">    1752 </span>            :        RCODE (OPS...).
<span class="lineNum">    1753 </span>            :      So first simplify and lookup this expression to see if it
<span class="lineNum">    1754 </span>            :      is already available.  */
<span class="lineNum">    1755 </span><span class="lineCov">    3716061 :   mprts_hook = vn_lookup_simplify_result;</span>
<span class="lineNum">    1756 </span><span class="lineCov">    3716061 :   bool res = false;</span>
<span class="lineNum">    1757 </span><span class="lineCov">    7432122 :   switch (TREE_CODE_LENGTH ((tree_code) res_op-&gt;code))</span>
<span class="lineNum">    1758 </span>            :     {
<span class="lineNum">    1759 </span><span class="lineCov">     835381 :     case 1:</span>
<span class="lineNum">    1760 </span><span class="lineCov">     835381 :       res = gimple_resimplify1 (NULL, res_op, vn_valueize);</span>
<span class="lineNum">    1761 </span><span class="lineCov">     835381 :       break;</span>
<span class="lineNum">    1762 </span><span class="lineCov">    2854381 :     case 2:</span>
<span class="lineNum">    1763 </span><span class="lineCov">    2854381 :       res = gimple_resimplify2 (NULL, res_op, vn_valueize);</span>
<span class="lineNum">    1764 </span><span class="lineCov">    2854381 :       break;</span>
<span class="lineNum">    1765 </span><span class="lineCov">      26137 :     case 3:</span>
<span class="lineNum">    1766 </span><span class="lineCov">      26137 :       res = gimple_resimplify3 (NULL, res_op, vn_valueize);</span>
<span class="lineNum">    1767 </span><span class="lineCov">      26137 :       break;</span>
<span class="lineNum">    1768 </span>            :     }
<span class="lineNum">    1769 </span><span class="lineCov">    3716061 :   mprts_hook = NULL;</span>
<span class="lineNum">    1770 </span><span class="lineCov">    3716061 :   gimple *new_stmt = NULL;</span>
<span class="lineNum">    1771 </span><span class="lineCov">        162 :   if (res</span>
<span class="lineNum">    1772 </span><span class="lineCov">    3715899 :       &amp;&amp; gimple_simplified_result_is_gimple_val (res_op))</span>
<span class="lineNum">    1773 </span>            :     {
<span class="lineNum">    1774 </span>            :       /* The expression is already available.  */
<span class="lineNum">    1775 </span><span class="lineCov">     650076 :       result = res_op-&gt;ops[0];</span>
<span class="lineNum">    1776 </span>            :       /* Valueize it, simplification returns sth in AVAIL only.  */
<span class="lineNum">    1777 </span><span class="lineCov">     650076 :       if (TREE_CODE (result) == SSA_NAME)</span>
<span class="lineNum">    1778 </span><span class="lineCov">     136338 :         result = SSA_VAL (result);</span>
<span class="lineNum">    1779 </span>            :     }
<span class="lineNum">    1780 </span>            :   else
<span class="lineNum">    1781 </span>            :     {
<span class="lineNum">    1782 </span><span class="lineCov">    3065985 :       tree val = vn_lookup_simplify_result (res_op);</span>
<span class="lineNum">    1783 </span><span class="lineCov">    3065985 :       if (!val &amp;&amp; insert)</span>
<span class="lineNum">    1784 </span>            :         {
<span class="lineNum">    1785 </span><span class="lineCov">      17617 :           gimple_seq stmts = NULL;</span>
<span class="lineNum">    1786 </span><span class="lineCov">      17617 :           result = maybe_push_res_to_seq (res_op, &amp;stmts);</span>
<span class="lineNum">    1787 </span><span class="lineCov">      17617 :           if (result)</span>
<span class="lineNum">    1788 </span>            :             {
<span class="lineNum">    1789 </span><span class="lineCov">      17617 :               gcc_assert (gimple_seq_singleton_p (stmts));</span>
<span class="lineNum">    1790 </span><span class="lineCov">      17617 :               new_stmt = gimple_seq_first_stmt (stmts);</span>
<span class="lineNum">    1791 </span>            :             }
<span class="lineNum">    1792 </span>            :         }
<span class="lineNum">    1793 </span>            :       else
<span class="lineNum">    1794 </span>            :         /* The expression is already available.  */
<span class="lineNum">    1795 </span>            :         result = val;
<span class="lineNum">    1796 </span>            :     }
<span class="lineNum">    1797 </span><span class="lineCov">     136338 :   if (new_stmt)</span>
<span class="lineNum">    1798 </span>            :     {
<span class="lineNum">    1799 </span>            :       /* The expression is not yet available, value-number lhs to
<span class="lineNum">    1800 </span>            :          the new SSA_NAME we created.  */
<span class="lineNum">    1801 </span>            :       /* Initialize value-number information properly.  */
<span class="lineNum">    1802 </span><span class="lineCov">      17617 :       vn_ssa_aux_t result_info = VN_INFO (result);</span>
<span class="lineNum">    1803 </span><span class="lineCov">      17617 :       result_info-&gt;valnum = result;</span>
<span class="lineNum">    1804 </span><span class="lineCov">      17617 :       result_info-&gt;value_id = get_next_value_id ();</span>
<span class="lineNum">    1805 </span><span class="lineCov">      17617 :       result_info-&gt;visited = 1;</span>
<span class="lineNum">    1806 </span><span class="lineCov">      17617 :       gimple_seq_add_stmt_without_update (&amp;VN_INFO (result)-&gt;expr,</span>
<span class="lineNum">    1807 </span>            :                                           new_stmt);
<span class="lineNum">    1808 </span><span class="lineCov">      17617 :       result_info-&gt;needs_insertion = true;</span>
<span class="lineNum">    1809 </span>            :       /* ???  PRE phi-translation inserts NARYs without corresponding
<span class="lineNum">    1810 </span>            :          SSA name result.  Re-use those but set their result according
<span class="lineNum">    1811 </span>            :          to the stmt we just built.  */
<span class="lineNum">    1812 </span><span class="lineCov">      17617 :       vn_nary_op_t nary = NULL;</span>
<span class="lineNum">    1813 </span><span class="lineCov">      17617 :       vn_nary_op_lookup_stmt (new_stmt, &amp;nary);</span>
<span class="lineNum">    1814 </span><span class="lineCov">      17617 :       if (nary)</span>
<span class="lineNum">    1815 </span>            :         {
<span class="lineNum">    1816 </span><span class="lineNoCov">          0 :           gcc_assert (! nary-&gt;predicated_values &amp;&amp; nary-&gt;u.result == NULL_TREE);</span>
<span class="lineNum">    1817 </span><span class="lineNoCov">          0 :           nary-&gt;u.result = gimple_assign_lhs (new_stmt);</span>
<span class="lineNum">    1818 </span>            :         }
<span class="lineNum">    1819 </span>            :       /* As all &quot;inserted&quot; statements are singleton SCCs, insert
<span class="lineNum">    1820 </span>            :          to the valid table.  This is strictly needed to
<span class="lineNum">    1821 </span>            :          avoid re-generating new value SSA_NAMEs for the same
<span class="lineNum">    1822 </span>            :          expression during SCC iteration over and over (the
<span class="lineNum">    1823 </span>            :          optimistic table gets cleared after each iteration).
<span class="lineNum">    1824 </span>            :          We do not need to insert into the optimistic table, as
<span class="lineNum">    1825 </span>            :          lookups there will fall back to the valid table.  */
<span class="lineNum">    1826 </span>            :       else
<span class="lineNum">    1827 </span>            :         {
<span class="lineNum">    1828 </span><span class="lineCov">      17617 :           unsigned int length = vn_nary_length_from_stmt (new_stmt);</span>
<span class="lineNum">    1829 </span><span class="lineCov">      17617 :           vn_nary_op_t vno1</span>
<span class="lineNum">    1830 </span><span class="lineCov">      17617 :             = alloc_vn_nary_op_noinit (length, &amp;vn_tables_insert_obstack);</span>
<span class="lineNum">    1831 </span><span class="lineCov">      17617 :           vno1-&gt;value_id = result_info-&gt;value_id;</span>
<span class="lineNum">    1832 </span><span class="lineCov">      17617 :           vno1-&gt;length = length;</span>
<span class="lineNum">    1833 </span><span class="lineCov">      17617 :           vno1-&gt;predicated_values = 0;</span>
<span class="lineNum">    1834 </span><span class="lineCov">      17617 :           vno1-&gt;u.result = result;</span>
<span class="lineNum">    1835 </span><span class="lineCov">      17617 :           init_vn_nary_op_from_stmt (vno1, new_stmt);</span>
<span class="lineNum">    1836 </span><span class="lineCov">      17617 :           vn_nary_op_insert_into (vno1, valid_info-&gt;nary, true);</span>
<span class="lineNum">    1837 </span>            :           /* Also do not link it into the undo chain.  */
<span class="lineNum">    1838 </span><span class="lineCov">      17617 :           last_inserted_nary = vno1-&gt;next;</span>
<span class="lineNum">    1839 </span><span class="lineCov">      17617 :           vno1-&gt;next = (vn_nary_op_t)(void *)-1;</span>
<span class="lineNum">    1840 </span>            :         }
<span class="lineNum">    1841 </span><span class="lineCov">      17617 :       if (dump_file &amp;&amp; (dump_flags &amp; TDF_DETAILS))</span>
<span class="lineNum">    1842 </span>            :         {
<span class="lineNum">    1843 </span><span class="lineCov">          6 :           fprintf (dump_file, &quot;Inserting name &quot;);</span>
<span class="lineNum">    1844 </span><span class="lineCov">          6 :           print_generic_expr (dump_file, result);</span>
<span class="lineNum">    1845 </span><span class="lineCov">          6 :           fprintf (dump_file, &quot; for expression &quot;);</span>
<span class="lineNum">    1846 </span><span class="lineCov">          6 :           print_gimple_expr (dump_file, new_stmt, 0, TDF_SLIM);</span>
<span class="lineNum">    1847 </span><span class="lineCov">          6 :           fprintf (dump_file, &quot;\n&quot;);</span>
<span class="lineNum">    1848 </span>            :         }
<span class="lineNum">    1849 </span>            :     }
<span class="lineNum">    1850 </span><span class="lineCov">    3716061 :   return result;</span>
<span class="lineNum">    1851 </span>            : }
<span class="lineNum">    1852 </span>            : 
<span class="lineNum">    1853 </span>            : /* Return a value-number for RCODE OPS... either by looking up an existing
<span class="lineNum">    1854 </span>            :    value-number for the simplified result or by inserting the operation.  */
<a name="1855"><span class="lineNum">    1855 </span>            : </a>
<span class="lineNum">    1856 </span>            : static tree
<span class="lineNum">    1857 </span><span class="lineNoCov">          0 : vn_nary_build_or_lookup (gimple_match_op *res_op)</span>
<span class="lineNum">    1858 </span>            : {
<span class="lineNum">    1859 </span><span class="lineNoCov">          0 :   return vn_nary_build_or_lookup_1 (res_op, true);</span>
<span class="lineNum">    1860 </span>            : }
<span class="lineNum">    1861 </span>            : 
<span class="lineNum">    1862 </span>            : /* Try to simplify the expression RCODE OPS... of type TYPE and return
<span class="lineNum">    1863 </span>            :    its value if present.  */
<a name="1864"><span class="lineNum">    1864 </span>            : </a>
<span class="lineNum">    1865 </span>            : tree
<span class="lineNum">    1866 </span><span class="lineCov">    3680450 : vn_nary_simplify (vn_nary_op_t nary)</span>
<span class="lineNum">    1867 </span>            : {
<span class="lineNum">    1868 </span><span class="lineCov">    3680450 :   if (nary-&gt;length &gt; gimple_match_op::MAX_NUM_OPS)</span>
<span class="lineNum">    1869 </span>            :     return NULL_TREE;
<span class="lineNum">    1870 </span><span class="lineCov">    7360856 :   gimple_match_op op (gimple_match_cond::UNCOND, nary-&gt;opcode,</span>
<span class="lineNum">    1871 </span><span class="lineCov">    7360856 :                       nary-&gt;type, nary-&gt;length);</span>
<span class="lineNum">    1872 </span><span class="lineCov">    3680428 :   memcpy (op.ops, nary-&gt;op, sizeof (tree) * nary-&gt;length);</span>
<span class="lineNum">    1873 </span><span class="lineCov">    3680428 :   return vn_nary_build_or_lookup_1 (&amp;op, false);</span>
<span class="lineNum">    1874 </span>            : }
<span class="lineNum">    1875 </span>            : 
<span class="lineNum">    1876 </span>            : basic_block vn_context_bb;
<span class="lineNum">    1877 </span>            : 
<span class="lineNum">    1878 </span>            : /* Callback for walk_non_aliased_vuses.  Tries to perform a lookup
<span class="lineNum">    1879 </span>            :    from the statement defining VUSE and if not successful tries to
<span class="lineNum">    1880 </span>            :    translate *REFP and VR_ through an aggregate copy at the definition
<span class="lineNum">    1881 </span>            :    of VUSE.  If *DISAMBIGUATE_ONLY is true then do not perform translation
<span class="lineNum">    1882 </span>            :    of *REF and *VR.  If only disambiguation was performed then
<span class="lineNum">    1883 </span>            :    *DISAMBIGUATE_ONLY is set to true.  */
<a name="1884"><span class="lineNum">    1884 </span>            : </a>
<span class="lineNum">    1885 </span>            : static void *
<span class="lineNum">    1886 </span><span class="lineCov">   14329177 : vn_reference_lookup_3 (ao_ref *ref, tree vuse, void *vr_,</span>
<span class="lineNum">    1887 </span>            :                        bool *disambiguate_only)
<span class="lineNum">    1888 </span>            : {
<span class="lineNum">    1889 </span><span class="lineCov">   14329177 :   vn_reference_t vr = (vn_reference_t)vr_;</span>
<span class="lineNum">    1890 </span><span class="lineCov">   14329177 :   gimple *def_stmt = SSA_NAME_DEF_STMT (vuse);</span>
<span class="lineNum">    1891 </span><span class="lineCov">   14329177 :   tree base = ao_ref_base (ref);</span>
<span class="lineNum">    1892 </span><span class="lineCov">   14329177 :   HOST_WIDE_INT offseti, maxsizei;</span>
<span class="lineNum">    1893 </span><span class="lineCov">   14329177 :   static vec&lt;vn_reference_op_s&gt; lhs_ops;</span>
<span class="lineNum">    1894 </span><span class="lineCov">   14329177 :   ao_ref lhs_ref;</span>
<span class="lineNum">    1895 </span><span class="lineCov">   14329177 :   bool lhs_ref_ok = false;</span>
<span class="lineNum">    1896 </span><span class="lineCov">   14329177 :   poly_int64 copy_size;</span>
<span class="lineNum">    1897 </span>            : 
<span class="lineNum">    1898 </span>            :   /* First try to disambiguate after value-replacing in the definitions LHS.  */
<span class="lineNum">    1899 </span><span class="lineCov">   28658354 :   if (is_gimple_assign (def_stmt))</span>
<span class="lineNum">    1900 </span>            :     {
<span class="lineNum">    1901 </span><span class="lineCov">    5170148 :       tree lhs = gimple_assign_lhs (def_stmt);</span>
<span class="lineNum">    1902 </span><span class="lineCov">    5170148 :       bool valueized_anything = false;</span>
<span class="lineNum">    1903 </span>            :       /* Avoid re-allocation overhead.  */
<span class="lineNum">    1904 </span><span class="lineCov">    5170148 :       lhs_ops.truncate (0);</span>
<span class="lineNum">    1905 </span><span class="lineCov">    5170148 :       basic_block saved_rpo_bb = vn_context_bb;</span>
<span class="lineNum">    1906 </span><span class="lineCov">    5170148 :       vn_context_bb = gimple_bb (def_stmt);</span>
<span class="lineNum">    1907 </span><span class="lineCov">    5170148 :       copy_reference_ops_from_ref (lhs, &amp;lhs_ops);</span>
<span class="lineNum">    1908 </span><span class="lineCov">    5170148 :       lhs_ops = valueize_refs_1 (lhs_ops, &amp;valueized_anything, true);</span>
<span class="lineNum">    1909 </span><span class="lineCov">    5170148 :       vn_context_bb = saved_rpo_bb;</span>
<span class="lineNum">    1910 </span><span class="lineCov">    5170148 :       if (valueized_anything)</span>
<span class="lineNum">    1911 </span>            :         {
<span class="lineNum">    1912 </span><span class="lineCov">     399496 :           lhs_ref_ok = ao_ref_init_from_vn_reference (&amp;lhs_ref,</span>
<span class="lineNum">    1913 </span>            :                                                       get_alias_set (lhs),
<span class="lineNum">    1914 </span><span class="lineCov">     399496 :                                                       TREE_TYPE (lhs), lhs_ops);</span>
<span class="lineNum">    1915 </span><span class="lineCov">     399496 :           if (lhs_ref_ok</span>
<span class="lineNum">    1916 </span><span class="lineCov">     399496 :               &amp;&amp; !refs_may_alias_p_1 (ref, &amp;lhs_ref, true))</span>
<span class="lineNum">    1917 </span>            :             {
<span class="lineNum">    1918 </span><span class="lineCov">     297614 :               *disambiguate_only = true;</span>
<span class="lineNum">    1919 </span><span class="lineCov">     326786 :               return NULL;</span>
<span class="lineNum">    1920 </span>            :             }
<span class="lineNum">    1921 </span>            :         }
<span class="lineNum">    1922 </span>            :       else
<span class="lineNum">    1923 </span>            :         {
<span class="lineNum">    1924 </span><span class="lineCov">    4770652 :           ao_ref_init (&amp;lhs_ref, lhs);</span>
<span class="lineNum">    1925 </span><span class="lineCov">    4770652 :           lhs_ref_ok = true;</span>
<span class="lineNum">    1926 </span>            :         }
<span class="lineNum">    1927 </span>            : 
<span class="lineNum">    1928 </span>            :       /* If we reach a clobbering statement try to skip it and see if
<span class="lineNum">    1929 </span>            :          we find a VN result with exactly the same value as the
<span class="lineNum">    1930 </span>            :          possible clobber.  In this case we can ignore the clobber
<span class="lineNum">    1931 </span>            :          and return the found value.
<span class="lineNum">    1932 </span>            :          Note that we don't need to worry about partial overlapping
<span class="lineNum">    1933 </span>            :          accesses as we then can use TBAA to disambiguate against the
<span class="lineNum">    1934 </span>            :          clobbering statement when looking up a load (thus the
<span class="lineNum">    1935 </span>            :          VN_WALKREWRITE guard).  */
<span class="lineNum">    1936 </span><span class="lineCov">    4872534 :       if (vn_walk_kind == VN_WALKREWRITE</span>
<span class="lineNum">    1937 </span><span class="lineCov">    3710606 :           &amp;&amp; is_gimple_reg_type (TREE_TYPE (lhs))</span>
<span class="lineNum">    1938 </span><span class="lineCov">    7372770 :           &amp;&amp; types_compatible_p (TREE_TYPE (lhs), vr-&gt;type))</span>
<span class="lineNum">    1939 </span>            :         {
<span class="lineNum">    1940 </span><span class="lineCov">     693095 :           tree *saved_last_vuse_ptr = last_vuse_ptr;</span>
<span class="lineNum">    1941 </span>            :           /* Do not update last_vuse_ptr in vn_reference_lookup_2.  */
<span class="lineNum">    1942 </span><span class="lineCov">     693095 :           last_vuse_ptr = NULL;</span>
<span class="lineNum">    1943 </span><span class="lineCov">     693095 :           tree saved_vuse = vr-&gt;vuse;</span>
<span class="lineNum">    1944 </span><span class="lineCov">     693095 :           hashval_t saved_hashcode = vr-&gt;hashcode;</span>
<span class="lineNum">    1945 </span><span class="lineCov">    1386190 :           void *res = vn_reference_lookup_2 (ref,</span>
<span class="lineNum">    1946 </span>            :                                              gimple_vuse (def_stmt), 0, vr);
<span class="lineNum">    1947 </span>            :           /* Need to restore vr-&gt;vuse and vr-&gt;hashcode.  */
<span class="lineNum">    1948 </span><span class="lineCov">     693095 :           vr-&gt;vuse = saved_vuse;</span>
<span class="lineNum">    1949 </span><span class="lineCov">     693095 :           vr-&gt;hashcode = saved_hashcode;</span>
<span class="lineNum">    1950 </span><span class="lineCov">     693095 :           last_vuse_ptr = saved_last_vuse_ptr;</span>
<span class="lineNum">    1951 </span><span class="lineCov">     693095 :           if (res &amp;&amp; res != (void *)-1)</span>
<span class="lineNum">    1952 </span>            :             {
<span class="lineNum">    1953 </span><span class="lineCov">      74936 :               vn_reference_t vnresult = (vn_reference_t) res;</span>
<span class="lineNum">    1954 </span><span class="lineCov">      74936 :               if (vnresult-&gt;result</span>
<span class="lineNum">    1955 </span><span class="lineCov">     149856 :                   &amp;&amp; operand_equal_p (vnresult-&gt;result,</span>
<span class="lineNum">    1956 </span><span class="lineCov">      74920 :                                       gimple_assign_rhs1 (def_stmt), 0))</span>
<span class="lineNum">    1957 </span>            :                 return res;
<span class="lineNum">    1958 </span>            :             }
<span class="lineNum">    1959 </span>            :         }
<span class="lineNum">    1960 </span>            :     }
<span class="lineNum">    1961 </span><span class="lineCov">    9159029 :   else if (gimple_call_builtin_p (def_stmt, BUILT_IN_NORMAL)</span>
<span class="lineNum">    1962 </span><span class="lineCov">    9159029 :            &amp;&amp; gimple_call_num_args (def_stmt) &lt;= 4)</span>
<span class="lineNum">    1963 </span>            :     {
<span class="lineNum">    1964 </span>            :       /* For builtin calls valueize its arguments and call the
<span class="lineNum">    1965 </span>            :          alias oracle again.  Valueization may improve points-to
<span class="lineNum">    1966 </span>            :          info of pointers and constify size and position arguments.
<span class="lineNum">    1967 </span>            :          Originally this was motivated by PR61034 which has
<span class="lineNum">    1968 </span>            :          conditional calls to free falsely clobbering ref because
<span class="lineNum">    1969 </span>            :          of imprecise points-to info of the argument.  */
<span class="lineNum">    1970 </span>            :       tree oldargs[4];
<span class="lineNum">    1971 </span>            :       bool valueized_anything = false;
<span class="lineNum">    1972 </span><span class="lineCov">    1574883 :       for (unsigned i = 0; i &lt; gimple_call_num_args (def_stmt); ++i)</span>
<span class="lineNum">    1973 </span>            :         {
<span class="lineNum">    1974 </span><span class="lineCov">    1074185 :           oldargs[i] = gimple_call_arg (def_stmt, i);</span>
<span class="lineNum">    1975 </span><span class="lineCov">    1074185 :           tree val = vn_valueize (oldargs[i]);</span>
<span class="lineNum">    1976 </span><span class="lineCov">    1074185 :           if (val != oldargs[i])</span>
<span class="lineNum">    1977 </span>            :             {
<span class="lineNum">    1978 </span><span class="lineCov">      49693 :               gimple_call_set_arg (def_stmt, i, val);</span>
<span class="lineNum">    1979 </span><span class="lineCov">      49693 :               valueized_anything = true;</span>
<span class="lineNum">    1980 </span>            :             }
<span class="lineNum">    1981 </span>            :         }
<span class="lineNum">    1982 </span><span class="lineCov">     500698 :       if (valueized_anything)</span>
<span class="lineNum">    1983 </span>            :         {
<span class="lineNum">    1984 </span><span class="lineCov">      40859 :           bool res = call_may_clobber_ref_p_1 (as_a &lt;gcall *&gt; (def_stmt),</span>
<span class="lineNum">    1985 </span>            :                                                ref);
<span class="lineNum">    1986 </span><span class="lineCov">     149769 :           for (unsigned i = 0; i &lt; gimple_call_num_args (def_stmt); ++i)</span>
<span class="lineNum">    1987 </span><span class="lineCov">     108910 :             gimple_call_set_arg (def_stmt, i, oldargs[i]);</span>
<span class="lineNum">    1988 </span><span class="lineCov">      40859 :           if (!res)</span>
<span class="lineNum">    1989 </span>            :             {
<span class="lineNum">    1990 </span><span class="lineCov">      14316 :               *disambiguate_only = true;</span>
<span class="lineNum">    1991 </span><span class="lineCov">      14316 :               return NULL;</span>
<span class="lineNum">    1992 </span>            :             }
<span class="lineNum">    1993 </span>            :         }
<span class="lineNum">    1994 </span>            :     }
<span class="lineNum">    1995 </span>            : 
<span class="lineNum">    1996 </span><span class="lineCov">   13988075 :   if (*disambiguate_only)</span>
<span class="lineNum">    1997 </span>            :     return (void *)-1;
<span class="lineNum">    1998 </span>            : 
<span class="lineNum">    1999 </span>            :   /* If we cannot constrain the size of the reference we cannot
<span class="lineNum">    2000 </span>            :      test if anything kills it.  */
<span class="lineNum">    2001 </span><span class="lineCov">   23548058 :   if (!ref-&gt;max_size_known_p ())</span>
<span class="lineNum">    2002 </span>            :     return (void *)-1;
<span class="lineNum">    2003 </span>            : 
<span class="lineNum">    2004 </span><span class="lineCov">   11542692 :   poly_int64 offset = ref-&gt;offset;</span>
<span class="lineNum">    2005 </span><span class="lineCov">   11542692 :   poly_int64 maxsize = ref-&gt;max_size;</span>
<span class="lineNum">    2006 </span>            : 
<span class="lineNum">    2007 </span>            :   /* We can't deduce anything useful from clobbers.  */
<span class="lineNum">    2008 </span><span class="lineCov">   11542692 :   if (gimple_clobber_p (def_stmt))</span>
<span class="lineNum">    2009 </span>            :     return (void *)-1;
<span class="lineNum">    2010 </span>            : 
<span class="lineNum">    2011 </span>            :   /* def_stmt may-defs *ref.  See if we can derive a value for *ref
<span class="lineNum">    2012 </span>            :      from that definition.
<span class="lineNum">    2013 </span>            :      1) Memset.  */
<span class="lineNum">    2014 </span><span class="lineCov">   10413871 :   if (is_gimple_reg_type (vr-&gt;type)</span>
<span class="lineNum">    2015 </span><span class="lineCov">   10277811 :       &amp;&amp; gimple_call_builtin_p (def_stmt, BUILT_IN_MEMSET)</span>
<span class="lineNum">    2016 </span><span class="lineCov">      34974 :       &amp;&amp; (integer_zerop (gimple_call_arg (def_stmt, 1))</span>
<span class="lineNum">    2017 </span><span class="lineCov">      18496 :           || ((TREE_CODE (gimple_call_arg (def_stmt, 1)) == INTEGER_CST</span>
<span class="lineNum">    2018 </span><span class="lineCov">       7562 :                || (INTEGRAL_TYPE_P (vr-&gt;type) &amp;&amp; known_eq (ref-&gt;size, 8)))</span>
<span class="lineNum">    2019 </span>            :               &amp;&amp; CHAR_BIT == 8 &amp;&amp; BITS_PER_UNIT == 8
<span class="lineNum">    2020 </span><span class="lineCov">      18348 :               &amp;&amp; offset.is_constant (&amp;offseti)</span>
<span class="lineNum">    2021 </span><span class="lineCov">      18348 :               &amp;&amp; offseti % BITS_PER_UNIT == 0))</span>
<span class="lineNum">    2022 </span><span class="lineCov">      34802 :       &amp;&amp; poly_int_tree_p (gimple_call_arg (def_stmt, 2))</span>
<span class="lineNum">    2023 </span><span class="lineCov">   10440149 :       &amp;&amp; (TREE_CODE (gimple_call_arg (def_stmt, 0)) == ADDR_EXPR</span>
<span class="lineNum">    2024 </span><span class="lineCov">      20151 :           || TREE_CODE (gimple_call_arg (def_stmt, 0)) == SSA_NAME))</span>
<span class="lineNum">    2025 </span>            :     {
<span class="lineNum">    2026 </span><span class="lineCov">      26278 :       tree base2;</span>
<span class="lineNum">    2027 </span><span class="lineCov">      78834 :       poly_int64 offset2, size2, maxsize2;</span>
<span class="lineNum">    2028 </span><span class="lineCov">      26278 :       bool reverse;</span>
<span class="lineNum">    2029 </span><span class="lineCov">      26278 :       tree ref2 = gimple_call_arg (def_stmt, 0);</span>
<span class="lineNum">    2030 </span><span class="lineCov">      26278 :       if (TREE_CODE (ref2) == SSA_NAME)</span>
<span class="lineNum">    2031 </span>            :         {
<span class="lineNum">    2032 </span><span class="lineCov">      20151 :           ref2 = SSA_VAL (ref2);</span>
<span class="lineNum">    2033 </span><span class="lineCov">      20151 :           if (TREE_CODE (ref2) == SSA_NAME</span>
<span class="lineNum">    2034 </span><span class="lineCov">      20151 :               &amp;&amp; (TREE_CODE (base) != MEM_REF</span>
<span class="lineNum">    2035 </span><span class="lineCov">      11926 :                   || TREE_OPERAND (base, 0) != ref2))</span>
<span class="lineNum">    2036 </span>            :             {
<span class="lineNum">    2037 </span><span class="lineCov">      16884 :               gimple *def_stmt = SSA_NAME_DEF_STMT (ref2);</span>
<span class="lineNum">    2038 </span><span class="lineCov">      16884 :               if (gimple_assign_single_p (def_stmt)</span>
<span class="lineNum">    2039 </span><span class="lineCov">        354 :                   &amp;&amp; gimple_assign_rhs_code (def_stmt) == ADDR_EXPR)</span>
<span class="lineNum">    2040 </span><span class="lineCov">        348 :                 ref2 = gimple_assign_rhs1 (def_stmt);</span>
<span class="lineNum">    2041 </span>            :             }
<span class="lineNum">    2042 </span>            :         }
<span class="lineNum">    2043 </span><span class="lineCov">      26278 :       if (TREE_CODE (ref2) == ADDR_EXPR)</span>
<span class="lineNum">    2044 </span>            :         {
<span class="lineNum">    2045 </span><span class="lineCov">       9213 :           ref2 = TREE_OPERAND (ref2, 0);</span>
<span class="lineNum">    2046 </span><span class="lineCov">       9213 :           base2 = get_ref_base_and_extent (ref2, &amp;offset2, &amp;size2, &amp;maxsize2,</span>
<span class="lineNum">    2047 </span>            :                                            &amp;reverse);
<span class="lineNum">    2048 </span><span class="lineCov">       9213 :           if (!known_size_p (maxsize2)</span>
<span class="lineNum">    2049 </span><span class="lineCov">       9168 :               || !known_eq (maxsize2, size2)</span>
<span class="lineNum">    2050 </span><span class="lineCov">      18367 :               || !operand_equal_p (base, base2, OEP_ADDRESS_OF))</span>
<span class="lineNum">    2051 </span><span class="lineCov">      26206 :             return (void *)-1;</span>
<span class="lineNum">    2052 </span>            :         }
<span class="lineNum">    2053 </span><span class="lineCov">      17065 :       else if (TREE_CODE (ref2) == SSA_NAME)</span>
<span class="lineNum">    2054 </span>            :         {
<span class="lineNum">    2055 </span><span class="lineCov">      17065 :           poly_int64 soff;</span>
<span class="lineNum">    2056 </span><span class="lineCov">      17065 :           if (TREE_CODE (base) != MEM_REF</span>
<span class="lineNum">    2057 </span><span class="lineCov">      28883 :               || !(mem_ref_offset (base) &lt;&lt; LOG2_BITS_PER_UNIT).to_shwi (&amp;soff))</span>
<span class="lineNum">    2058 </span><span class="lineCov">       5247 :             return (void *)-1;</span>
<span class="lineNum">    2059 </span><span class="lineCov">      11818 :           offset += soff;</span>
<span class="lineNum">    2060 </span><span class="lineCov">      11818 :           offset2 = 0;</span>
<span class="lineNum">    2061 </span><span class="lineCov">      11818 :           if (TREE_OPERAND (base, 0) != ref2)</span>
<span class="lineNum">    2062 </span>            :             {
<span class="lineNum">    2063 </span><span class="lineCov">      11463 :               gimple *def = SSA_NAME_DEF_STMT (ref2);</span>
<span class="lineNum">    2064 </span><span class="lineCov">      11463 :               if (is_gimple_assign (def)</span>
<span class="lineNum">    2065 </span><span class="lineCov">      11090 :                   &amp;&amp; gimple_assign_rhs_code (def) == POINTER_PLUS_EXPR</span>
<span class="lineNum">    2066 </span><span class="lineCov">      21994 :                   &amp;&amp; gimple_assign_rhs1 (def) == TREE_OPERAND (base, 0)</span>
<span class="lineNum">    2067 </span><span class="lineCov">         10 :                   &amp;&amp; poly_int_tree_p (gimple_assign_rhs2 (def))</span>
<span class="lineNum">    2068 </span><span class="lineCov">      11473 :                   &amp;&amp; (wi::to_poly_offset (gimple_assign_rhs2 (def))</span>
<span class="lineNum">    2069 </span><span class="lineCov">         20 :                       &lt;&lt; LOG2_BITS_PER_UNIT).to_shwi (&amp;offset2))</span>
<span class="lineNum">    2070 </span>            :                 {
<span class="lineNum">    2071 </span><span class="lineCov">         10 :                   ref2 = gimple_assign_rhs1 (def);</span>
<span class="lineNum">    2072 </span><span class="lineCov">         10 :                   if (TREE_CODE (ref2) == SSA_NAME)</span>
<span class="lineNum">    2073 </span><span class="lineCov">         10 :                     ref2 = SSA_VAL (ref2);</span>
<span class="lineNum">    2074 </span>            :                 }
<span class="lineNum">    2075 </span>            :               else
<span class="lineNum">    2076 </span><span class="lineCov">      11453 :                 return (void *)-1;</span>
<span class="lineNum">    2077 </span>            :             }
<span class="lineNum">    2078 </span>            :         }
<span class="lineNum">    2079 </span>            :       else
<span class="lineNum">    2080 </span>            :         return (void *)-1;
<span class="lineNum">    2081 </span><span class="lineCov">       8789 :       tree len = gimple_call_arg (def_stmt, 2);</span>
<span class="lineNum">    2082 </span><span class="lineCov">      26367 :       if (known_subrange_p (offset, maxsize, offset2,</span>
<span class="lineNum">    2083 </span><span class="lineCov">       8789 :                             wi::to_poly_offset (len) &lt;&lt; LOG2_BITS_PER_UNIT))</span>
<span class="lineNum">    2084 </span>            :         {
<span class="lineNum">    2085 </span><span class="lineCov">       8717 :           tree val;</span>
<span class="lineNum">    2086 </span><span class="lineCov">       8717 :           if (integer_zerop (gimple_call_arg (def_stmt, 1)))</span>
<span class="lineNum">    2087 </span><span class="lineCov">       6192 :             val = build_zero_cst (vr-&gt;type);</span>
<span class="lineNum">    2088 </span><span class="lineCov">       2525 :           else if (INTEGRAL_TYPE_P (vr-&gt;type)</span>
<span class="lineNum">    2089 </span><span class="lineCov">       2525 :                    &amp;&amp; known_eq (ref-&gt;size, 8))</span>
<span class="lineNum">    2090 </span>            :             {
<span class="lineNum">    2091 </span><span class="lineCov">       2122 :               gimple_match_op res_op (gimple_match_cond::UNCOND, NOP_EXPR,</span>
<span class="lineNum">    2092 </span><span class="lineCov">       2122 :                                       vr-&gt;type, gimple_call_arg (def_stmt, 1));</span>
<span class="lineNum">    2093 </span><span class="lineCov">       2122 :               val = vn_nary_build_or_lookup (&amp;res_op);</span>
<span class="lineNum">    2094 </span><span class="lineCov">       2122 :               if (!val</span>
<span class="lineNum">    2095 </span><span class="lineCov">       2122 :                   || (TREE_CODE (val) == SSA_NAME</span>
<span class="lineNum">    2096 </span><span class="lineCov">       1942 :                       &amp;&amp; SSA_NAME_OCCURS_IN_ABNORMAL_PHI (val)))</span>
<span class="lineNum">    2097 </span><span class="lineNoCov">          0 :                 return (void *)-1;</span>
<span class="lineNum">    2098 </span>            :             }
<span class="lineNum">    2099 </span>            :           else
<span class="lineNum">    2100 </span>            :             {
<span class="lineNum">    2101 </span><span class="lineCov">        403 :               unsigned len = TREE_INT_CST_LOW (TYPE_SIZE_UNIT (vr-&gt;type));</span>
<span class="lineNum">    2102 </span><span class="lineCov">        403 :               unsigned char *buf = XALLOCAVEC (unsigned char, len);</span>
<span class="lineNum">    2103 </span><span class="lineCov">        403 :               memset (buf, TREE_INT_CST_LOW (gimple_call_arg (def_stmt, 1)),</span>
<span class="lineNum">    2104 </span>            :                       len);
<span class="lineNum">    2105 </span><span class="lineCov">        403 :               val = native_interpret_expr (vr-&gt;type, buf, len);</span>
<span class="lineNum">    2106 </span><span class="lineCov">        403 :               if (!val)</span>
<span class="lineNum">    2107 </span>            :                 return (void *)-1;
<span class="lineNum">    2108 </span>            :             }
<span class="lineNum">    2109 </span><span class="lineCov">       8717 :           return vn_reference_lookup_or_insert_for_pieces</span>
<span class="lineNum">    2110 </span><span class="lineCov">       8717 :                    (vuse, vr-&gt;set, vr-&gt;type, vr-&gt;operands, val);</span>
<span class="lineNum">    2111 </span>            :         }
<span class="lineNum">    2112 </span>            :     }
<span class="lineNum">    2113 </span>            : 
<span class="lineNum">    2114 </span>            :   /* 2) Assignment from an empty CONSTRUCTOR.  */
<span class="lineNum">    2115 </span><span class="lineCov">   10387593 :   else if (is_gimple_reg_type (vr-&gt;type)</span>
<span class="lineNum">    2116 </span><span class="lineCov">   10251533 :            &amp;&amp; gimple_assign_single_p (def_stmt)</span>
<span class="lineNum">    2117 </span><span class="lineCov">    2895733 :            &amp;&amp; gimple_assign_rhs_code (def_stmt) == CONSTRUCTOR</span>
<span class="lineNum">    2118 </span><span class="lineCov">   11172881 :            &amp;&amp; CONSTRUCTOR_NELTS (gimple_assign_rhs1 (def_stmt)) == 0)</span>
<span class="lineNum">    2119 </span>            :     {
<span class="lineNum">    2120 </span><span class="lineCov">     392644 :       tree base2;</span>
<span class="lineNum">    2121 </span><span class="lineCov">    1177932 :       poly_int64 offset2, size2, maxsize2;</span>
<span class="lineNum">    2122 </span><span class="lineCov">     392644 :       bool reverse;</span>
<span class="lineNum">    2123 </span><span class="lineCov">     785288 :       base2 = get_ref_base_and_extent (gimple_assign_lhs (def_stmt),</span>
<span class="lineNum">    2124 </span>            :                                        &amp;offset2, &amp;size2, &amp;maxsize2, &amp;reverse);
<span class="lineNum">    2125 </span><span class="lineCov">     392644 :       if (known_size_p (maxsize2)</span>
<span class="lineNum">    2126 </span><span class="lineCov">     392546 :           &amp;&amp; operand_equal_p (base, base2, 0)</span>
<span class="lineNum">    2127 </span><span class="lineCov">     774592 :           &amp;&amp; known_subrange_p (offset, maxsize, offset2, size2))</span>
<span class="lineNum">    2128 </span>            :         {
<span class="lineNum">    2129 </span><span class="lineCov">     381300 :           tree val = build_zero_cst (vr-&gt;type);</span>
<span class="lineNum">    2130 </span><span class="lineCov">     381300 :           return vn_reference_lookup_or_insert_for_pieces</span>
<span class="lineNum">    2131 </span><span class="lineCov">     381300 :                    (vuse, vr-&gt;set, vr-&gt;type, vr-&gt;operands, val);</span>
<span class="lineNum">    2132 </span>            :         }
<span class="lineNum">    2133 </span>            :     }
<span class="lineNum">    2134 </span>            : 
<span class="lineNum">    2135 </span>            :   /* 3) Assignment from a constant.  We can use folds native encode/interpret
<span class="lineNum">    2136 </span>            :      routines to extract the assigned bits.  */
<span class="lineNum">    2137 </span><span class="lineCov">    9994949 :   else if (known_eq (ref-&gt;size, maxsize)</span>
<span class="lineNum">    2138 </span><span class="lineCov">   19526880 :            &amp;&amp; is_gimple_reg_type (vr-&gt;type)</span>
<span class="lineNum">    2139 </span><span class="lineCov">   19254760 :            &amp;&amp; !contains_storage_order_barrier_p (vr-&gt;operands)</span>
<span class="lineNum">    2140 </span><span class="lineCov">    9627380 :            &amp;&amp; gimple_assign_single_p (def_stmt)</span>
<span class="lineNum">    2141 </span>            :            &amp;&amp; CHAR_BIT == 8 &amp;&amp; BITS_PER_UNIT == 8
<span class="lineNum">    2142 </span>            :            /* native_encode and native_decode operate on arrays of bytes
<span class="lineNum">    2143 </span>            :               and so fundamentally need a compile-time size and offset.  */
<span class="lineNum">    2144 </span><span class="lineCov">    2357658 :            &amp;&amp; maxsize.is_constant (&amp;maxsizei)</span>
<span class="lineNum">    2145 </span><span class="lineCov">    2357658 :            &amp;&amp; maxsizei % BITS_PER_UNIT == 0</span>
<span class="lineNum">    2146 </span><span class="lineCov">    2353094 :            &amp;&amp; offset.is_constant (&amp;offseti)</span>
<span class="lineNum">    2147 </span><span class="lineCov">    2353094 :            &amp;&amp; offseti % BITS_PER_UNIT == 0</span>
<span class="lineNum">    2148 </span><span class="lineCov">   14700565 :            &amp;&amp; (is_gimple_min_invariant (gimple_assign_rhs1 (def_stmt))</span>
<span class="lineNum">    2149 </span><span class="lineCov">    2070291 :                || (TREE_CODE (gimple_assign_rhs1 (def_stmt)) == SSA_NAME</span>
<span class="lineNum">    2150 </span><span class="lineCov">    1749284 :                    &amp;&amp; is_gimple_min_invariant (SSA_VAL (gimple_assign_rhs1 (def_stmt))))))</span>
<span class="lineNum">    2151 </span>            :     {
<span class="lineNum">    2152 </span><span class="lineCov">     287150 :       tree base2;</span>
<span class="lineNum">    2153 </span><span class="lineCov">     287150 :       HOST_WIDE_INT offset2, size2;</span>
<span class="lineNum">    2154 </span><span class="lineCov">     287150 :       bool reverse;</span>
<span class="lineNum">    2155 </span><span class="lineCov">     287150 :       base2 = get_ref_base_and_extent_hwi (gimple_assign_lhs (def_stmt),</span>
<span class="lineNum">    2156 </span>            :                                            &amp;offset2, &amp;size2, &amp;reverse);
<span class="lineNum">    2157 </span><span class="lineCov">     287150 :       if (base2</span>
<span class="lineNum">    2158 </span><span class="lineCov">     271026 :           &amp;&amp; !reverse</span>
<span class="lineNum">    2159 </span><span class="lineCov">     271026 :           &amp;&amp; size2 % BITS_PER_UNIT == 0</span>
<span class="lineNum">    2160 </span><span class="lineCov">     270188 :           &amp;&amp; offset2 % BITS_PER_UNIT == 0</span>
<span class="lineNum">    2161 </span><span class="lineCov">     270173 :           &amp;&amp; operand_equal_p (base, base2, 0)</span>
<span class="lineNum">    2162 </span><span class="lineCov">     301211 :           &amp;&amp; known_subrange_p (offseti, maxsizei, offset2, size2))</span>
<span class="lineNum">    2163 </span>            :         {
<span class="lineNum">    2164 </span>            :           /* We support up to 512-bit values (for V8DFmode).  */
<span class="lineNum">    2165 </span><span class="lineCov">       9980 :           unsigned char buffer[64];</span>
<span class="lineNum">    2166 </span><span class="lineCov">       9980 :           int len;</span>
<span class="lineNum">    2167 </span>            : 
<span class="lineNum">    2168 </span><span class="lineCov">       9980 :           tree rhs = gimple_assign_rhs1 (def_stmt);</span>
<span class="lineNum">    2169 </span><span class="lineCov">       9980 :           if (TREE_CODE (rhs) == SSA_NAME)</span>
<span class="lineNum">    2170 </span><span class="lineCov">        263 :             rhs = SSA_VAL (rhs);</span>
<span class="lineNum">    2171 </span><span class="lineCov">       9980 :           len = native_encode_expr (gimple_assign_rhs1 (def_stmt),</span>
<span class="lineNum">    2172 </span>            :                                     buffer, sizeof (buffer),
<span class="lineNum">    2173 </span><span class="lineCov">       9980 :                                     (offseti - offset2) / BITS_PER_UNIT);</span>
<span class="lineNum">    2174 </span><span class="lineCov">       9980 :           if (len &gt; 0 &amp;&amp; len * BITS_PER_UNIT &gt;= maxsizei)</span>
<span class="lineNum">    2175 </span>            :             {
<span class="lineNum">    2176 </span><span class="lineCov">       9543 :               tree type = vr-&gt;type;</span>
<span class="lineNum">    2177 </span>            :               /* Make sure to interpret in a type that has a range
<span class="lineNum">    2178 </span>            :                  covering the whole access size.  */
<span class="lineNum">    2179 </span><span class="lineCov">       9543 :               if (INTEGRAL_TYPE_P (vr-&gt;type)</span>
<span class="lineNum">    2180 </span><span class="lineCov">       9543 :                   &amp;&amp; maxsizei != TYPE_PRECISION (vr-&gt;type))</span>
<span class="lineNum">    2181 </span><span class="lineCov">        138 :                 type = build_nonstandard_integer_type (maxsizei,</span>
<span class="lineNum">    2182 </span><span class="lineCov">        138 :                                                        TYPE_UNSIGNED (type));</span>
<span class="lineNum">    2183 </span><span class="lineCov">      28629 :               tree val = native_interpret_expr (type, buffer,</span>
<span class="lineNum">    2184 </span><span class="lineCov">       9543 :                                                 maxsizei / BITS_PER_UNIT);</span>
<span class="lineNum">    2185 </span>            :               /* If we chop off bits because the types precision doesn't
<span class="lineNum">    2186 </span>            :                  match the memory access size this is ok when optimizing
<span class="lineNum">    2187 </span>            :                  reads but not when called from the DSE code during
<span class="lineNum">    2188 </span>            :                  elimination.  */
<span class="lineNum">    2189 </span><span class="lineCov">       9543 :               if (val</span>
<span class="lineNum">    2190 </span><span class="lineCov">       9527 :                   &amp;&amp; type != vr-&gt;type)</span>
<span class="lineNum">    2191 </span>            :                 {
<span class="lineNum">    2192 </span><span class="lineCov">         69 :                   if (! int_fits_type_p (val, vr-&gt;type))</span>
<span class="lineNum">    2193 </span>            :                     val = NULL_TREE;
<span class="lineNum">    2194 </span>            :                   else
<span class="lineNum">    2195 </span><span class="lineCov">         43 :                     val = fold_convert (vr-&gt;type, val);</span>
<span class="lineNum">    2196 </span>            :                 }
<span class="lineNum">    2197 </span>            : 
<span class="lineNum">    2198 </span><span class="lineCov">       9517 :               if (val)</span>
<span class="lineNum">    2199 </span><span class="lineCov">       9501 :                 return vn_reference_lookup_or_insert_for_pieces</span>
<span class="lineNum">    2200 </span><span class="lineCov">       9501 :                          (vuse, vr-&gt;set, vr-&gt;type, vr-&gt;operands, val);</span>
<span class="lineNum">    2201 </span>            :             }
<span class="lineNum">    2202 </span>            :         }
<span class="lineNum">    2203 </span>            :     }
<span class="lineNum">    2204 </span>            : 
<span class="lineNum">    2205 </span>            :   /* 4) Assignment from an SSA name which definition we may be able
<span class="lineNum">    2206 </span>            :      to access pieces from.  */
<span class="lineNum">    2207 </span><span class="lineCov">    9707799 :   else if (known_eq (ref-&gt;size, maxsize)</span>
<span class="lineNum">    2208 </span><span class="lineCov">   18952580 :            &amp;&amp; is_gimple_reg_type (vr-&gt;type)</span>
<span class="lineNum">    2209 </span><span class="lineCov">   18680460 :            &amp;&amp; !contains_storage_order_barrier_p (vr-&gt;operands)</span>
<span class="lineNum">    2210 </span><span class="lineCov">    9340230 :            &amp;&amp; gimple_assign_single_p (def_stmt)</span>
<span class="lineNum">    2211 </span><span class="lineCov">   13848815 :            &amp;&amp; TREE_CODE (gimple_assign_rhs1 (def_stmt)) == SSA_NAME)</span>
<span class="lineNum">    2212 </span>            :     {
<span class="lineNum">    2213 </span><span class="lineCov">     871587 :       tree base2;</span>
<span class="lineNum">    2214 </span><span class="lineCov">    2614761 :       poly_int64 offset2, size2, maxsize2;</span>
<span class="lineNum">    2215 </span><span class="lineCov">     871587 :       bool reverse;</span>
<span class="lineNum">    2216 </span><span class="lineCov">    1743174 :       base2 = get_ref_base_and_extent (gimple_assign_lhs (def_stmt),</span>
<span class="lineNum">    2217 </span>            :                                        &amp;offset2, &amp;size2, &amp;maxsize2,
<span class="lineNum">    2218 </span>            :                                        &amp;reverse);
<span class="lineNum">    2219 </span><span class="lineCov">     871587 :       if (!reverse</span>
<span class="lineNum">    2220 </span><span class="lineCov">    1743150 :           &amp;&amp; known_size_p (maxsize2)</span>
<span class="lineNum">    2221 </span><span class="lineCov">     859660 :           &amp;&amp; known_eq (maxsize2, size2)</span>
<span class="lineNum">    2222 </span><span class="lineCov">     814112 :           &amp;&amp; operand_equal_p (base, base2, 0)</span>
<span class="lineNum">    2223 </span><span class="lineCov">      37658 :           &amp;&amp; known_subrange_p (offset, maxsize, offset2, size2)</span>
<span class="lineNum">    2224 </span>            :           /* ???  We can't handle bitfield precision extracts without
<span class="lineNum">    2225 </span>            :              either using an alternate type for the BIT_FIELD_REF and
<span class="lineNum">    2226 </span>            :              then doing a conversion or possibly adjusting the offset
<span class="lineNum">    2227 </span>            :              according to endianness.  */
<span class="lineNum">    2228 </span><span class="lineCov">      25645 :           &amp;&amp; (! INTEGRAL_TYPE_P (vr-&gt;type)</span>
<span class="lineNum">    2229 </span><span class="lineCov">      19770 :               || known_eq (ref-&gt;size, TYPE_PRECISION (vr-&gt;type)))</span>
<span class="lineNum">    2230 </span><span class="lineCov">     921314 :           &amp;&amp; multiple_p (ref-&gt;size, BITS_PER_UNIT))</span>
<span class="lineNum">    2231 </span>            :         {
<span class="lineNum">    2232 </span>            :           gimple_match_op op (gimple_match_cond::UNCOND,
<span class="lineNum">    2233 </span>            :                               BIT_FIELD_REF, vr-&gt;type,
<span class="lineNum">    2234 </span>            :                               vn_valueize (gimple_assign_rhs1 (def_stmt)),
<span class="lineNum">    2235 </span>            :                               bitsize_int (ref-&gt;size),
<span class="lineNum">    2236 </span><span class="lineCov">      24415 :                               bitsize_int (offset - offset2));</span>
<span class="lineNum">    2237 </span><span class="lineCov">      24415 :           tree val = vn_nary_build_or_lookup (&amp;op);</span>
<span class="lineNum">    2238 </span><span class="lineCov">      24415 :           if (val</span>
<span class="lineNum">    2239 </span><span class="lineCov">      24415 :               &amp;&amp; (TREE_CODE (val) != SSA_NAME</span>
<span class="lineNum">    2240 </span><span class="lineCov">      48720 :                   || ! SSA_NAME_OCCURS_IN_ABNORMAL_PHI (val)))</span>
<span class="lineNum">    2241 </span>            :             {
<span class="lineNum">    2242 </span><span class="lineCov">      24400 :               vn_reference_t res = vn_reference_lookup_or_insert_for_pieces</span>
<span class="lineNum">    2243 </span><span class="lineCov">      24400 :                   (vuse, vr-&gt;set, vr-&gt;type, vr-&gt;operands, val);</span>
<span class="lineNum">    2244 </span><span class="lineCov">      24400 :               return res;</span>
<span class="lineNum">    2245 </span>            :             }
<span class="lineNum">    2246 </span>            :         }
<span class="lineNum">    2247 </span>            :     }
<span class="lineNum">    2248 </span>            : 
<span class="lineNum">    2249 </span>            :   /* 5) For aggregate copies translate the reference through them if
<span class="lineNum">    2250 </span>            :      the copy kills ref.  */
<span class="lineNum">    2251 </span><span class="lineCov">    8836212 :   else if (vn_walk_kind == VN_WALKREWRITE</span>
<span class="lineNum">    2252 </span><span class="lineCov">    6631856 :            &amp;&amp; gimple_assign_single_p (def_stmt)</span>
<span class="lineNum">    2253 </span><span class="lineCov">   10837622 :            &amp;&amp; (DECL_P (gimple_assign_rhs1 (def_stmt))</span>
<span class="lineNum">    2254 </span><span class="lineCov">    1710988 :                || TREE_CODE (gimple_assign_rhs1 (def_stmt)) == MEM_REF</span>
<span class="lineNum">    2255 </span><span class="lineCov">    1538470 :                || handled_component_p (gimple_assign_rhs1 (def_stmt))))</span>
<span class="lineNum">    2256 </span>            :     {
<span class="lineNum">    2257 </span><span class="lineCov">     913729 :       tree base2;</span>
<span class="lineNum">    2258 </span><span class="lineCov">     913729 :       int i, j, k;</span>
<span class="lineNum">    2259 </span><span class="lineCov">    2546209 :       auto_vec&lt;vn_reference_op_s&gt; rhs;</span>
<span class="lineNum">    2260 </span><span class="lineCov">     913729 :       vn_reference_op_t vro;</span>
<span class="lineNum">    2261 </span><span class="lineCov">     913729 :       ao_ref r;</span>
<span class="lineNum">    2262 </span>            : 
<span class="lineNum">    2263 </span><span class="lineCov">     913729 :       if (!lhs_ref_ok)</span>
<span class="lineNum">    2264 </span>            :         return (void *)-1;
<span class="lineNum">    2265 </span>            : 
<span class="lineNum">    2266 </span>            :       /* See if the assignment kills REF.  */
<span class="lineNum">    2267 </span><span class="lineCov">     913729 :       base2 = ao_ref_base (&amp;lhs_ref);</span>
<span class="lineNum">    2268 </span><span class="lineCov">     913729 :       if (!lhs_ref.max_size_known_p ()</span>
<span class="lineNum">    2269 </span><span class="lineCov">     913322 :           || (base != base2</span>
<span class="lineNum">    2270 </span><span class="lineCov">      32289 :               &amp;&amp; (TREE_CODE (base) != MEM_REF</span>
<span class="lineNum">    2271 </span><span class="lineCov">      25491 :                   || TREE_CODE (base2) != MEM_REF</span>
<span class="lineNum">    2272 </span><span class="lineCov">      19917 :                   || TREE_OPERAND (base, 0) != TREE_OPERAND (base2, 0)</span>
<span class="lineNum">    2273 </span><span class="lineCov">       8704 :                   || !tree_int_cst_equal (TREE_OPERAND (base, 1),</span>
<span class="lineNum">    2274 </span><span class="lineCov">       8704 :                                           TREE_OPERAND (base2, 1))))</span>
<span class="lineNum">    2275 </span><span class="lineCov">    1803020 :           || !stmt_kills_ref_p (def_stmt, ref))</span>
<span class="lineNum">    2276 </span><span class="lineCov">     180700 :         return (void *)-1;</span>
<span class="lineNum">    2277 </span>            : 
<span class="lineNum">    2278 </span>            :       /* Find the common base of ref and the lhs.  lhs_ops already
<span class="lineNum">    2279 </span>            :          contains valueized operands for the lhs.  */
<span class="lineNum">    2280 </span><span class="lineCov">     733029 :       i = vr-&gt;operands.length () - 1;</span>
<span class="lineNum">    2281 </span><span class="lineCov">    1466058 :       j = lhs_ops.length () - 1;</span>
<span class="lineNum">    2282 </span><span class="lineCov">    1474579 :       while (j &gt;= 0 &amp;&amp; i &gt;= 0</span>
<span class="lineNum">    2283 </span><span class="lineCov">    3018323 :              &amp;&amp; vn_reference_op_eq (&amp;vr-&gt;operands[i], &amp;lhs_ops[j]))</span>
<span class="lineNum">    2284 </span>            :         {
<span class="lineNum">    2285 </span><span class="lineCov">     810715 :           i--;</span>
<span class="lineNum">    2286 </span><span class="lineCov">     810715 :           j--;</span>
<span class="lineNum">    2287 </span>            :         }
<span class="lineNum">    2288 </span>            : 
<span class="lineNum">    2289 </span>            :       /* ???  The innermost op should always be a MEM_REF and we already
<span class="lineNum">    2290 </span>            :          checked that the assignment to the lhs kills vr.  Thus for
<span class="lineNum">    2291 </span>            :          aggregate copies using char[] types the vn_reference_op_eq
<span class="lineNum">    2292 </span>            :          may fail when comparing types for compatibility.  But we really
<span class="lineNum">    2293 </span>            :          don't care here - further lookups with the rewritten operands
<span class="lineNum">    2294 </span>            :          will simply fail if we messed up types too badly.  */
<span class="lineNum">    2295 </span><span class="lineCov">     733029 :       poly_int64 extra_off = 0;</span>
<span class="lineNum">    2296 </span><span class="lineCov">     649595 :       if (j == 0 &amp;&amp; i &gt;= 0</span>
<span class="lineNum">    2297 </span><span class="lineCov">     649595 :           &amp;&amp; lhs_ops[0].opcode == MEM_REF</span>
<span class="lineNum">    2298 </span><span class="lineCov">    2032201 :           &amp;&amp; maybe_ne (lhs_ops[0].off, -1))</span>
<span class="lineNum">    2299 </span>            :         {
<span class="lineNum">    2300 </span><span class="lineCov">     649586 :           if (known_eq (lhs_ops[0].off, vr-&gt;operands[i].off))</span>
<span class="lineNum">    2301 </span><span class="lineCov">     232942 :             i--, j--;</span>
<span class="lineNum">    2302 </span><span class="lineCov">     416644 :           else if (vr-&gt;operands[i].opcode == MEM_REF</span>
<span class="lineNum">    2303 </span><span class="lineCov">     416644 :                    &amp;&amp; maybe_ne (vr-&gt;operands[i].off, -1))</span>
<span class="lineNum">    2304 </span>            :             {
<span class="lineNum">    2305 </span><span class="lineCov">    1249932 :               extra_off = vr-&gt;operands[i].off - lhs_ops[0].off;</span>
<span class="lineNum">    2306 </span><span class="lineCov">     416644 :               i--, j--;</span>
<span class="lineNum">    2307 </span>            :             }
<span class="lineNum">    2308 </span>            :         }
<span class="lineNum">    2309 </span>            : 
<span class="lineNum">    2310 </span>            :       /* i now points to the first additional op.
<span class="lineNum">    2311 </span>            :          ???  LHS may not be completely contained in VR, one or more
<span class="lineNum">    2312 </span>            :          VIEW_CONVERT_EXPRs could be in its way.  We could at least
<span class="lineNum">    2313 </span>            :          try handling outermost VIEW_CONVERT_EXPRs.  */
<span class="lineNum">    2314 </span><span class="lineCov">     733029 :       if (j != -1)</span>
<span class="lineNum">    2315 </span>            :         return (void *)-1;
<span class="lineNum">    2316 </span>            : 
<span class="lineNum">    2317 </span>            :       /* Punt if the additional ops contain a storage order barrier.  */
<span class="lineNum">    2318 </span><span class="lineCov">     814726 :       for (k = i; k &gt;= 0; k--)</span>
<span class="lineNum">    2319 </span>            :         {
<span class="lineNum">    2320 </span><span class="lineCov">      95975 :           vro = &amp;vr-&gt;operands[k];</span>
<span class="lineNum">    2321 </span><span class="lineCov">      95975 :           if (vro-&gt;opcode == VIEW_CONVERT_EXPR &amp;&amp; vro-&gt;reverse)</span>
<span class="lineNum">    2322 </span>            :             return (void *)-1;
<span class="lineNum">    2323 </span>            :         }
<span class="lineNum">    2324 </span>            : 
<span class="lineNum">    2325 </span>            :       /* Now re-write REF to be based on the rhs of the assignment.  */
<span class="lineNum">    2326 </span><span class="lineCov">     718751 :       copy_reference_ops_from_ref (gimple_assign_rhs1 (def_stmt), &amp;rhs);</span>
<span class="lineNum">    2327 </span>            : 
<span class="lineNum">    2328 </span>            :       /* Apply an extra offset to the inner MEM_REF of the RHS.  */
<span class="lineNum">    2329 </span><span class="lineCov">     718751 :       if (maybe_ne (extra_off, 0))</span>
<span class="lineNum">    2330 </span>            :         {
<span class="lineNum">    2331 </span><span class="lineCov">     416644 :           if (rhs.length () &lt; 2)</span>
<span class="lineNum">    2332 </span>            :             return (void *)-1;
<span class="lineNum">    2333 </span><span class="lineCov">     416644 :           int ix = rhs.length () - 2;</span>
<span class="lineNum">    2334 </span><span class="lineCov">     416644 :           if (rhs[ix].opcode != MEM_REF</span>
<span class="lineNum">    2335 </span><span class="lineCov">     416644 :               || known_eq (rhs[ix].off, -1))</span>
<span class="lineNum">    2336 </span>            :             return (void *)-1;
<span class="lineNum">    2337 </span><span class="lineCov">     833288 :           rhs[ix].off += extra_off;</span>
<span class="lineNum">    2338 </span><span class="lineCov">     416644 :           rhs[ix].op0 = int_const_binop (PLUS_EXPR, rhs[ix].op0,</span>
<span class="lineNum">    2339 </span><span class="lineCov">     833288 :                                          build_int_cst (TREE_TYPE (rhs[ix].op0),</span>
<span class="lineNum">    2340 </span>            :                                                         extra_off));
<span class="lineNum">    2341 </span>            :         }
<span class="lineNum">    2342 </span>            : 
<span class="lineNum">    2343 </span>            :       /* We need to pre-pend vr-&gt;operands[0..i] to rhs.  */
<span class="lineNum">    2344 </span><span class="lineCov">     718751 :       vec&lt;vn_reference_op_s&gt; old = vr-&gt;operands;</span>
<span class="lineNum">    2345 </span><span class="lineCov">    2156253 :       if (i + 1 + rhs.length () &gt; vr-&gt;operands.length ())</span>
<span class="lineNum">    2346 </span><span class="lineCov">     541044 :         vr-&gt;operands.safe_grow (i + 1 + rhs.length ());</span>
<span class="lineNum">    2347 </span>            :       else
<span class="lineNum">    2348 </span><span class="lineCov">     177707 :         vr-&gt;operands.truncate (i + 1 + rhs.length ());</span>
<span class="lineNum">    2349 </span><span class="lineCov">    2712764 :       FOR_EACH_VEC_ELT (rhs, j, vro)</span>
<span class="lineNum">    2350 </span><span class="lineCov">    1994013 :         vr-&gt;operands[i + 1 + j] = *vro;</span>
<span class="lineNum">    2351 </span><span class="lineCov">     718751 :       vr-&gt;operands = valueize_refs (vr-&gt;operands);</span>
<span class="lineNum">    2352 </span><span class="lineCov">    1437502 :       if (old == shared_lookup_references)</span>
<span class="lineNum">    2353 </span><span class="lineCov">     718751 :         shared_lookup_references = vr-&gt;operands;</span>
<span class="lineNum">    2354 </span><span class="lineCov">     718751 :       vr-&gt;hashcode = vn_reference_compute_hash (vr);</span>
<span class="lineNum">    2355 </span>            : 
<span class="lineNum">    2356 </span>            :       /* Try folding the new reference to a constant.  */
<span class="lineNum">    2357 </span><span class="lineCov">     718751 :       tree val = fully_constant_vn_reference_p (vr);</span>
<span class="lineNum">    2358 </span><span class="lineCov">     718751 :       if (val)</span>
<span class="lineNum">    2359 </span><span class="lineCov">      10873 :         return vn_reference_lookup_or_insert_for_pieces</span>
<span class="lineNum">    2360 </span><span class="lineCov">      10873 :                  (vuse, vr-&gt;set, vr-&gt;type, vr-&gt;operands, val);</span>
<span class="lineNum">    2361 </span>            : 
<span class="lineNum">    2362 </span>            :       /* Adjust *ref from the new operands.  */
<span class="lineNum">    2363 </span><span class="lineCov">     707878 :       if (!ao_ref_init_from_vn_reference (&amp;r, vr-&gt;set, vr-&gt;type, vr-&gt;operands))</span>
<span class="lineNum">    2364 </span>            :         return (void *)-1;
<span class="lineNum">    2365 </span>            :       /* This can happen with bitfields.  */
<span class="lineNum">    2366 </span><span class="lineCov">     707790 :       if (maybe_ne (ref-&gt;size, r.size))</span>
<span class="lineNum">    2367 </span>            :         return (void *)-1;
<span class="lineNum">    2368 </span><span class="lineCov">     649796 :       *ref = r;</span>
<span class="lineNum">    2369 </span>            : 
<span class="lineNum">    2370 </span>            :       /* Do not update last seen VUSE after translating.  */
<span class="lineNum">    2371 </span><span class="lineCov">     649796 :       last_vuse_ptr = NULL;</span>
<span class="lineNum">    2372 </span>            : 
<span class="lineNum">    2373 </span>            :       /* Keep looking for the adjusted *REF / VR pair.  */
<span class="lineNum">    2374 </span><span class="lineCov">     649796 :       return NULL;</span>
<span class="lineNum">    2375 </span>            :     }
<span class="lineNum">    2376 </span>            : 
<span class="lineNum">    2377 </span>            :   /* 6) For memcpy copies translate the reference through them if
<span class="lineNum">    2378 </span>            :      the copy kills ref.  */
<span class="lineNum">    2379 </span><span class="lineCov">    7922483 :   else if (vn_walk_kind == VN_WALKREWRITE</span>
<span class="lineNum">    2380 </span><span class="lineCov">   11436254 :            &amp;&amp; is_gimple_reg_type (vr-&gt;type)</span>
<span class="lineNum">    2381 </span>            :            /* ???  Handle BCOPY as well.  */
<span class="lineNum">    2382 </span><span class="lineCov">    5713189 :            &amp;&amp; (gimple_call_builtin_p (def_stmt, BUILT_IN_MEMCPY)</span>
<span class="lineNum">    2383 </span><span class="lineCov">    5698170 :                || gimple_call_builtin_p (def_stmt, BUILT_IN_MEMPCPY)</span>
<span class="lineNum">    2384 </span><span class="lineCov">    5697526 :                || gimple_call_builtin_p (def_stmt, BUILT_IN_MEMMOVE))</span>
<span class="lineNum">    2385 </span><span class="lineCov">      16650 :            &amp;&amp; (TREE_CODE (gimple_call_arg (def_stmt, 0)) == ADDR_EXPR</span>
<span class="lineNum">    2386 </span><span class="lineCov">      15481 :                || TREE_CODE (gimple_call_arg (def_stmt, 0)) == SSA_NAME)</span>
<span class="lineNum">    2387 </span><span class="lineCov">      16632 :            &amp;&amp; (TREE_CODE (gimple_call_arg (def_stmt, 1)) == ADDR_EXPR</span>
<span class="lineNum">    2388 </span><span class="lineCov">       7780 :                || TREE_CODE (gimple_call_arg (def_stmt, 1)) == SSA_NAME)</span>
<span class="lineNum">    2389 </span><span class="lineCov">    7939104 :            &amp;&amp; poly_int_tree_p (gimple_call_arg (def_stmt, 2), &amp;copy_size))</span>
<span class="lineNum">    2390 </span>            :     {
<span class="lineNum">    2391 </span><span class="lineCov">       9010 :       tree lhs, rhs;</span>
<span class="lineNum">    2392 </span><span class="lineCov">       9010 :       ao_ref r;</span>
<span class="lineNum">    2393 </span><span class="lineCov">      18020 :       poly_int64 rhs_offset, lhs_offset;</span>
<span class="lineNum">    2394 </span><span class="lineCov">       9010 :       vn_reference_op_s op;</span>
<span class="lineNum">    2395 </span><span class="lineCov">       9010 :       poly_uint64 mem_offset;</span>
<span class="lineNum">    2396 </span><span class="lineCov">      18020 :       poly_int64 at, byte_maxsize;</span>
<span class="lineNum">    2397 </span>            : 
<span class="lineNum">    2398 </span>            :       /* Only handle non-variable, addressable refs.  */
<span class="lineNum">    2399 </span><span class="lineCov">       9010 :       if (maybe_ne (ref-&gt;size, maxsize)</span>
<span class="lineNum">    2400 </span><span class="lineCov">       8960 :           || !multiple_p (offset, BITS_PER_UNIT, &amp;at)</span>
<span class="lineNum">    2401 </span><span class="lineCov">      17958 :           || !multiple_p (maxsize, BITS_PER_UNIT, &amp;byte_maxsize))</span>
<span class="lineNum">    2402 </span><span class="lineCov">         62 :         return (void *)-1;</span>
<span class="lineNum">    2403 </span>            : 
<span class="lineNum">    2404 </span>            :       /* Extract a pointer base and an offset for the destination.  */
<span class="lineNum">    2405 </span><span class="lineCov">       8948 :       lhs = gimple_call_arg (def_stmt, 0);</span>
<span class="lineNum">    2406 </span><span class="lineCov">       8948 :       lhs_offset = 0;</span>
<span class="lineNum">    2407 </span><span class="lineCov">       8948 :       if (TREE_CODE (lhs) == SSA_NAME)</span>
<span class="lineNum">    2408 </span>            :         {
<span class="lineNum">    2409 </span><span class="lineCov">       7955 :           lhs = vn_valueize (lhs);</span>
<span class="lineNum">    2410 </span><span class="lineCov">       7955 :           if (TREE_CODE (lhs) == SSA_NAME)</span>
<span class="lineNum">    2411 </span>            :             {
<span class="lineNum">    2412 </span><span class="lineCov">       7852 :               gimple *def_stmt = SSA_NAME_DEF_STMT (lhs);</span>
<span class="lineNum">    2413 </span><span class="lineCov">       7852 :               if (gimple_assign_single_p (def_stmt)</span>
<span class="lineNum">    2414 </span><span class="lineCov">       2967 :                   &amp;&amp; gimple_assign_rhs_code (def_stmt) == ADDR_EXPR)</span>
<span class="lineNum">    2415 </span><span class="lineCov">       4064 :                 lhs = gimple_assign_rhs1 (def_stmt);</span>
<span class="lineNum">    2416 </span>            :             }
<span class="lineNum">    2417 </span>            :         }
<span class="lineNum">    2418 </span><span class="lineCov">       8948 :       if (TREE_CODE (lhs) == ADDR_EXPR)</span>
<span class="lineNum">    2419 </span>            :         {
<span class="lineNum">    2420 </span><span class="lineCov">       3128 :           tree tem = get_addr_base_and_unit_offset (TREE_OPERAND (lhs, 0),</span>
<span class="lineNum">    2421 </span><span class="lineCov">       3128 :                                                     &amp;lhs_offset);</span>
<span class="lineNum">    2422 </span><span class="lineCov">       3128 :           if (!tem)</span>
<span class="lineNum">    2423 </span>            :             return (void *)-1;
<span class="lineNum">    2424 </span><span class="lineCov">       2103 :           if (TREE_CODE (tem) == MEM_REF</span>
<span class="lineNum">    2425 </span><span class="lineCov">       2103 :               &amp;&amp; poly_int_tree_p (TREE_OPERAND (tem, 1), &amp;mem_offset))</span>
<span class="lineNum">    2426 </span>            :             {
<span class="lineNum">    2427 </span><span class="lineCov">       1007 :               lhs = TREE_OPERAND (tem, 0);</span>
<span class="lineNum">    2428 </span><span class="lineCov">       1007 :               if (TREE_CODE (lhs) == SSA_NAME)</span>
<span class="lineNum">    2429 </span><span class="lineCov">       1007 :                 lhs = vn_valueize (lhs);</span>
<span class="lineNum">    2430 </span><span class="lineCov">       1007 :               lhs_offset += mem_offset;</span>
<span class="lineNum">    2431 </span>            :             }
<span class="lineNum">    2432 </span><span class="lineCov">       1096 :           else if (DECL_P (tem))</span>
<span class="lineNum">    2433 </span><span class="lineCov">       1096 :             lhs = build_fold_addr_expr (tem);</span>
<span class="lineNum">    2434 </span>            :           else
<span class="lineNum">    2435 </span>            :             return (void *)-1;
<span class="lineNum">    2436 </span>            :         }
<span class="lineNum">    2437 </span><span class="lineCov">       7923 :       if (TREE_CODE (lhs) != SSA_NAME</span>
<span class="lineNum">    2438 </span><span class="lineCov">       1096 :           &amp;&amp; TREE_CODE (lhs) != ADDR_EXPR)</span>
<span class="lineNum">    2439 </span>            :         return (void *)-1;
<span class="lineNum">    2440 </span>            : 
<span class="lineNum">    2441 </span>            :       /* Extract a pointer base and an offset for the source.  */
<span class="lineNum">    2442 </span><span class="lineCov">       7923 :       rhs = gimple_call_arg (def_stmt, 1);</span>
<span class="lineNum">    2443 </span><span class="lineCov">       7923 :       rhs_offset = 0;</span>
<span class="lineNum">    2444 </span><span class="lineCov">       7923 :       if (TREE_CODE (rhs) == SSA_NAME)</span>
<span class="lineNum">    2445 </span><span class="lineCov">       1180 :         rhs = vn_valueize (rhs);</span>
<span class="lineNum">    2446 </span><span class="lineCov">       7923 :       if (TREE_CODE (rhs) == ADDR_EXPR)</span>
<span class="lineNum">    2447 </span>            :         {
<span class="lineNum">    2448 </span><span class="lineCov">       6775 :           tree tem = get_addr_base_and_unit_offset (TREE_OPERAND (rhs, 0),</span>
<span class="lineNum">    2449 </span><span class="lineCov">       6775 :                                                     &amp;rhs_offset);</span>
<span class="lineNum">    2450 </span><span class="lineCov">       6775 :           if (!tem)</span>
<span class="lineNum">    2451 </span>            :             return (void *)-1;
<span class="lineNum">    2452 </span><span class="lineCov">       6775 :           if (TREE_CODE (tem) == MEM_REF</span>
<span class="lineNum">    2453 </span><span class="lineCov">       6775 :               &amp;&amp; poly_int_tree_p (TREE_OPERAND (tem, 1), &amp;mem_offset))</span>
<span class="lineNum">    2454 </span>            :             {
<span class="lineNum">    2455 </span><span class="lineNoCov">          0 :               rhs = TREE_OPERAND (tem, 0);</span>
<span class="lineNum">    2456 </span><span class="lineNoCov">          0 :               rhs_offset += mem_offset;</span>
<span class="lineNum">    2457 </span>            :             }
<span class="lineNum">    2458 </span><span class="lineCov">       6775 :           else if (DECL_P (tem)</span>
<span class="lineNum">    2459 </span><span class="lineCov">       6041 :                    || TREE_CODE (tem) == STRING_CST)</span>
<span class="lineNum">    2460 </span><span class="lineCov">       6775 :             rhs = build_fold_addr_expr (tem);</span>
<span class="lineNum">    2461 </span>            :           else
<span class="lineNum">    2462 </span>            :             return (void *)-1;
<span class="lineNum">    2463 </span>            :         }
<span class="lineNum">    2464 </span><span class="lineCov">       7923 :       if (TREE_CODE (rhs) != SSA_NAME</span>
<span class="lineNum">    2465 </span><span class="lineCov">       6775 :           &amp;&amp; TREE_CODE (rhs) != ADDR_EXPR)</span>
<span class="lineNum">    2466 </span>            :         return (void *)-1;
<span class="lineNum">    2467 </span>            : 
<span class="lineNum">    2468 </span>            :       /* The bases of the destination and the references have to agree.  */
<span class="lineNum">    2469 </span><span class="lineCov">       7923 :       if (TREE_CODE (base) == MEM_REF)</span>
<span class="lineNum">    2470 </span>            :         {
<span class="lineNum">    2471 </span><span class="lineCov">       2771 :           if (TREE_OPERAND (base, 0) != lhs</span>
<span class="lineNum">    2472 </span><span class="lineCov">       2771 :               || !poly_int_tree_p (TREE_OPERAND (base, 1), &amp;mem_offset))</span>
<span class="lineNum">    2473 </span><span class="lineCov">       1671 :             return (void *) -1;</span>
<span class="lineNum">    2474 </span>            :           at += mem_offset;
<span class="lineNum">    2475 </span>            :         }
<span class="lineNum">    2476 </span><span class="lineCov">       5152 :       else if (!DECL_P (base)</span>
<span class="lineNum">    2477 </span><span class="lineCov">       5152 :                || TREE_CODE (lhs) != ADDR_EXPR</span>
<span class="lineNum">    2478 </span><span class="lineCov">       6125 :                || TREE_OPERAND (lhs, 0) != base)</span>
<span class="lineNum">    2479 </span>            :         return (void *)-1;
<span class="lineNum">    2480 </span>            : 
<span class="lineNum">    2481 </span>            :       /* If the access is completely outside of the memcpy destination
<span class="lineNum">    2482 </span>            :          area there is no aliasing.  */
<span class="lineNum">    2483 </span><span class="lineCov">       2073 :       if (!ranges_maybe_overlap_p (lhs_offset, copy_size, at, byte_maxsize))</span>
<span class="lineNum">    2484 </span>            :         return NULL;
<span class="lineNum">    2485 </span>            :       /* And the access has to be contained within the memcpy destination.  */
<span class="lineNum">    2486 </span><span class="lineCov">       2057 :       if (!known_subrange_p (at, byte_maxsize, lhs_offset, copy_size))</span>
<span class="lineNum">    2487 </span>            :         return (void *)-1;
<span class="lineNum">    2488 </span>            : 
<span class="lineNum">    2489 </span>            :       /* Make room for 2 operands in the new reference.  */
<span class="lineNum">    2490 </span><span class="lineCov">       1825 :       if (vr-&gt;operands.length () &lt; 2)</span>
<span class="lineNum">    2491 </span>            :         {
<span class="lineNum">    2492 </span><span class="lineNoCov">          0 :           vec&lt;vn_reference_op_s&gt; old = vr-&gt;operands;</span>
<span class="lineNum">    2493 </span><span class="lineNoCov">          0 :           vr-&gt;operands.safe_grow_cleared (2);</span>
<span class="lineNum">    2494 </span><span class="lineNoCov">          0 :           if (old == shared_lookup_references)</span>
<span class="lineNum">    2495 </span><span class="lineNoCov">          0 :             shared_lookup_references = vr-&gt;operands;</span>
<span class="lineNum">    2496 </span>            :         }
<span class="lineNum">    2497 </span>            :       else
<span class="lineNum">    2498 </span><span class="lineCov">       1825 :         vr-&gt;operands.truncate (2);</span>
<span class="lineNum">    2499 </span>            : 
<span class="lineNum">    2500 </span>            :       /* The looked-through reference is a simple MEM_REF.  */
<span class="lineNum">    2501 </span><span class="lineCov">       1825 :       memset (&amp;op, 0, sizeof (op));</span>
<span class="lineNum">    2502 </span><span class="lineCov">       1825 :       op.type = vr-&gt;type;</span>
<span class="lineNum">    2503 </span><span class="lineCov">       1825 :       op.opcode = MEM_REF;</span>
<span class="lineNum">    2504 </span><span class="lineCov">       5475 :       op.op0 = build_int_cst (ptr_type_node, at - lhs_offset + rhs_offset);</span>
<span class="lineNum">    2505 </span><span class="lineCov">       3650 :       op.off = at - lhs_offset + rhs_offset;</span>
<span class="lineNum">    2506 </span><span class="lineCov">       1825 :       vr-&gt;operands[0] = op;</span>
<span class="lineNum">    2507 </span><span class="lineCov">       1825 :       op.type = TREE_TYPE (rhs);</span>
<span class="lineNum">    2508 </span><span class="lineCov">       1825 :       op.opcode = TREE_CODE (rhs);</span>
<span class="lineNum">    2509 </span><span class="lineCov">       1825 :       op.op0 = rhs;</span>
<span class="lineNum">    2510 </span><span class="lineCov">       1825 :       op.off = -1;</span>
<span class="lineNum">    2511 </span><span class="lineCov">       1825 :       vr-&gt;operands[1] = op;</span>
<span class="lineNum">    2512 </span><span class="lineCov">       1825 :       vr-&gt;hashcode = vn_reference_compute_hash (vr);</span>
<span class="lineNum">    2513 </span>            : 
<span class="lineNum">    2514 </span>            :       /* Try folding the new reference to a constant.  */
<span class="lineNum">    2515 </span><span class="lineCov">       1825 :       tree val = fully_constant_vn_reference_p (vr);</span>
<span class="lineNum">    2516 </span><span class="lineCov">       1825 :       if (val)</span>
<span class="lineNum">    2517 </span><span class="lineCov">       1184 :         return vn_reference_lookup_or_insert_for_pieces</span>
<span class="lineNum">    2518 </span><span class="lineCov">       1184 :                  (vuse, vr-&gt;set, vr-&gt;type, vr-&gt;operands, val);</span>
<span class="lineNum">    2519 </span>            : 
<span class="lineNum">    2520 </span>            :       /* Adjust *ref from the new operands.  */
<span class="lineNum">    2521 </span><span class="lineCov">        641 :       if (!ao_ref_init_from_vn_reference (&amp;r, vr-&gt;set, vr-&gt;type, vr-&gt;operands))</span>
<span class="lineNum">    2522 </span>            :         return (void *)-1;
<span class="lineNum">    2523 </span>            :       /* This can happen with bitfields.  */
<span class="lineNum">    2524 </span><span class="lineCov">        641 :       if (maybe_ne (ref-&gt;size, r.size))</span>
<span class="lineNum">    2525 </span>            :         return (void *)-1;
<span class="lineNum">    2526 </span><span class="lineCov">        641 :       *ref = r;</span>
<span class="lineNum">    2527 </span>            : 
<span class="lineNum">    2528 </span>            :       /* Do not update last seen VUSE after translating.  */
<span class="lineNum">    2529 </span><span class="lineCov">        641 :       last_vuse_ptr = NULL;</span>
<span class="lineNum">    2530 </span>            : 
<span class="lineNum">    2531 </span>            :       /* Keep looking for the adjusted *REF / VR pair.  */
<span class="lineNum">    2532 </span><span class="lineCov">        641 :       return NULL;</span>
<span class="lineNum">    2533 </span>            :     }
<span class="lineNum">    2534 </span>            : 
<span class="lineNum">    2535 </span>            :   /* Bail out and stop walking.  */
<span class="lineNum">    2536 </span>            :   return (void *)-1;
<span class="lineNum">    2537 </span>            : }
<span class="lineNum">    2538 </span>            : 
<span class="lineNum">    2539 </span>            : /* Return a reference op vector from OP that can be used for
<span class="lineNum">    2540 </span>            :    vn_reference_lookup_pieces.  The caller is responsible for releasing
<span class="lineNum">    2541 </span>            :    the vector.  */
<a name="2542"><span class="lineNum">    2542 </span>            : </a>
<span class="lineNum">    2543 </span>            : vec&lt;vn_reference_op_s&gt;
<span class="lineNum">    2544 </span><span class="lineCov">    2642564 : vn_reference_operands_for_lookup (tree op)</span>
<span class="lineNum">    2545 </span>            : {
<span class="lineNum">    2546 </span><span class="lineCov">    2642564 :   bool valueized;</span>
<span class="lineNum">    2547 </span><span class="lineCov">    2642564 :   return valueize_shared_reference_ops_from_ref (op, &amp;valueized).copy ();</span>
<span class="lineNum">    2548 </span>            : }
<span class="lineNum">    2549 </span>            : 
<span class="lineNum">    2550 </span>            : /* Lookup a reference operation by it's parts, in the current hash table.
<span class="lineNum">    2551 </span>            :    Returns the resulting value number if it exists in the hash table,
<span class="lineNum">    2552 </span>            :    NULL_TREE otherwise.  VNRESULT will be filled in with the actual
<span class="lineNum">    2553 </span>            :    vn_reference_t stored in the hashtable if something is found.  */
<a name="2554"><span class="lineNum">    2554 </span>            : </a>
<span class="lineNum">    2555 </span>            : tree
<span class="lineNum">    2556 </span><span class="lineCov">    4566482 : vn_reference_lookup_pieces (tree vuse, alias_set_type set, tree type,</span>
<span class="lineNum">    2557 </span>            :                             vec&lt;vn_reference_op_s&gt; operands,
<span class="lineNum">    2558 </span>            :                             vn_reference_t *vnresult, vn_lookup_kind kind)
<span class="lineNum">    2559 </span>            : {
<span class="lineNum">    2560 </span><span class="lineCov">    4566482 :   struct vn_reference_s vr1;</span>
<span class="lineNum">    2561 </span><span class="lineCov">    4566482 :   vn_reference_t tmp;</span>
<span class="lineNum">    2562 </span><span class="lineCov">    4566482 :   tree cst;</span>
<span class="lineNum">    2563 </span>            : 
<span class="lineNum">    2564 </span><span class="lineCov">    4566482 :   if (!vnresult)</span>
<span class="lineNum">    2565 </span><span class="lineNoCov">          0 :     vnresult = &amp;tmp;</span>
<span class="lineNum">    2566 </span><span class="lineCov">    4566482 :   *vnresult = NULL;</span>
<span class="lineNum">    2567 </span>            : 
<span class="lineNum">    2568 </span><span class="lineCov">    4566482 :   vr1.vuse = vuse_ssa_val (vuse);</span>
<span class="lineNum">    2569 </span><span class="lineCov">    4566482 :   shared_lookup_references.truncate (0);</span>
<span class="lineNum">    2570 </span><span class="lineCov">    9132964 :   shared_lookup_references.safe_grow (operands.length ());</span>
<span class="lineNum">    2571 </span><span class="lineCov">    4566482 :   memcpy (shared_lookup_references.address (),</span>
<span class="lineNum">    2572 </span><span class="lineCov">    4566482 :           operands.address (),</span>
<span class="lineNum">    2573 </span>            :           sizeof (vn_reference_op_s)
<span class="lineNum">    2574 </span><span class="lineCov">    9132964 :           * operands.length ());</span>
<span class="lineNum">    2575 </span><span class="lineCov">    9132964 :   vr1.operands = operands = shared_lookup_references</span>
<span class="lineNum">    2576 </span><span class="lineCov">    4566482 :     = valueize_refs (shared_lookup_references);</span>
<span class="lineNum">    2577 </span><span class="lineCov">    4566482 :   vr1.type = type;</span>
<span class="lineNum">    2578 </span><span class="lineCov">    4566482 :   vr1.set = set;</span>
<span class="lineNum">    2579 </span><span class="lineCov">    4566482 :   vr1.hashcode = vn_reference_compute_hash (&amp;vr1);</span>
<span class="lineNum">    2580 </span><span class="lineCov">    4566482 :   if ((cst = fully_constant_vn_reference_p (&amp;vr1)))</span>
<span class="lineNum">    2581 </span>            :     return cst;
<span class="lineNum">    2582 </span>            : 
<span class="lineNum">    2583 </span><span class="lineCov">    4555218 :   vn_reference_lookup_1 (&amp;vr1, vnresult);</span>
<span class="lineNum">    2584 </span><span class="lineCov">    4555218 :   if (!*vnresult</span>
<span class="lineNum">    2585 </span><span class="lineCov">    2555101 :       &amp;&amp; kind != VN_NOWALK</span>
<span class="lineNum">    2586 </span><span class="lineCov">    2555101 :       &amp;&amp; vr1.vuse)</span>
<span class="lineNum">    2587 </span>            :     {
<span class="lineNum">    2588 </span><span class="lineCov">    2509669 :       ao_ref r;</span>
<span class="lineNum">    2589 </span><span class="lineCov">    2509669 :       vn_walk_kind = kind;</span>
<span class="lineNum">    2590 </span><span class="lineCov">    2509669 :       if (ao_ref_init_from_vn_reference (&amp;r, set, type, vr1.operands))</span>
<span class="lineNum">    2591 </span><span class="lineCov">    2468753 :         *vnresult =</span>
<span class="lineNum">    2592 </span><span class="lineCov">    2468753 :           (vn_reference_t)walk_non_aliased_vuses (&amp;r, vr1.vuse,</span>
<span class="lineNum">    2593 </span>            :                                                   vn_reference_lookup_2,
<span class="lineNum">    2594 </span>            :                                                   vn_reference_lookup_3,
<span class="lineNum">    2595 </span>            :                                                   vuse_valueize, &amp;vr1);
<span class="lineNum">    2596 </span><span class="lineCov">    5019338 :       gcc_checking_assert (vr1.operands == shared_lookup_references);</span>
<span class="lineNum">    2597 </span>            :     }
<span class="lineNum">    2598 </span>            : 
<span class="lineNum">    2599 </span><span class="lineCov">    4555218 :   if (*vnresult)</span>
<span class="lineNum">    2600 </span><span class="lineCov">    2777899 :      return (*vnresult)-&gt;result;</span>
<span class="lineNum">    2601 </span>            : 
<span class="lineNum">    2602 </span>            :   return NULL_TREE;
<span class="lineNum">    2603 </span>            : }
<span class="lineNum">    2604 </span>            : 
<span class="lineNum">    2605 </span>            : /* Lookup OP in the current hash table, and return the resulting value
<span class="lineNum">    2606 </span>            :    number if it exists in the hash table.  Return NULL_TREE if it does
<span class="lineNum">    2607 </span>            :    not exist in the hash table or if the result field of the structure
<span class="lineNum">    2608 </span>            :    was NULL..  VNRESULT will be filled in with the vn_reference_t
<span class="lineNum">    2609 </span>            :    stored in the hashtable if one exists.  When TBAA_P is false assume
<span class="lineNum">    2610 </span>            :    we are looking up a store and treat it as having alias-set zero.  */
<a name="2611"><span class="lineNum">    2611 </span>            : </a>
<span class="lineNum">    2612 </span>            : tree
<span class="lineNum">    2613 </span><span class="lineCov">   46481404 : vn_reference_lookup (tree op, tree vuse, vn_lookup_kind kind,</span>
<span class="lineNum">    2614 </span>            :                      vn_reference_t *vnresult, bool tbaa_p)
<span class="lineNum">    2615 </span>            : {
<span class="lineNum">    2616 </span><span class="lineCov">   46481404 :   vec&lt;vn_reference_op_s&gt; operands;</span>
<span class="lineNum">    2617 </span><span class="lineCov">   46481404 :   struct vn_reference_s vr1;</span>
<span class="lineNum">    2618 </span><span class="lineCov">   46481404 :   tree cst;</span>
<span class="lineNum">    2619 </span><span class="lineCov">   46481404 :   bool valuezied_anything;</span>
<span class="lineNum">    2620 </span>            : 
<span class="lineNum">    2621 </span><span class="lineCov">   46481404 :   if (vnresult)</span>
<span class="lineNum">    2622 </span><span class="lineCov">   31848326 :     *vnresult = NULL;</span>
<span class="lineNum">    2623 </span>            : 
<span class="lineNum">    2624 </span><span class="lineCov">   46481404 :   vr1.vuse = vuse_ssa_val (vuse);</span>
<span class="lineNum">    2625 </span><span class="lineCov">   92962808 :   vr1.operands = operands</span>
<span class="lineNum">    2626 </span><span class="lineCov">   46481404 :     = valueize_shared_reference_ops_from_ref (op, &amp;valuezied_anything);</span>
<span class="lineNum">    2627 </span><span class="lineCov">   46481404 :   vr1.type = TREE_TYPE (op);</span>
<span class="lineNum">    2628 </span><span class="lineCov">   46481404 :   vr1.set = tbaa_p ? get_alias_set (op) : 0;</span>
<span class="lineNum">    2629 </span><span class="lineCov">   46481404 :   vr1.hashcode = vn_reference_compute_hash (&amp;vr1);</span>
<span class="lineNum">    2630 </span><span class="lineCov">   46481404 :   if ((cst = fully_constant_vn_reference_p (&amp;vr1)))</span>
<span class="lineNum">    2631 </span>            :     return cst;
<span class="lineNum">    2632 </span>            : 
<span class="lineNum">    2633 </span><span class="lineCov">   46475414 :   if (kind != VN_NOWALK</span>
<span class="lineNum">    2634 </span><span class="lineCov">   26287744 :       &amp;&amp; vr1.vuse)</span>
<span class="lineNum">    2635 </span>            :     {
<span class="lineNum">    2636 </span><span class="lineCov">   25107113 :       vn_reference_t wvnresult;</span>
<span class="lineNum">    2637 </span><span class="lineCov">   25107113 :       ao_ref r;</span>
<span class="lineNum">    2638 </span>            :       /* Make sure to use a valueized reference if we valueized anything.
<span class="lineNum">    2639 </span>            :          Otherwise preserve the full reference for advanced TBAA.  */
<span class="lineNum">    2640 </span><span class="lineCov">   25107113 :       if (!valuezied_anything</span>
<span class="lineNum">    2641 </span><span class="lineCov">   25107113 :           || !ao_ref_init_from_vn_reference (&amp;r, vr1.set, vr1.type,</span>
<span class="lineNum">    2642 </span>            :                                              vr1.operands))
<span class="lineNum">    2643 </span><span class="lineCov">   22990303 :         ao_ref_init (&amp;r, op);</span>
<span class="lineNum">    2644 </span><span class="lineCov">   25107113 :       if (! tbaa_p)</span>
<span class="lineNum">    2645 </span><span class="lineCov">   11660550 :         r.ref_alias_set = r.base_alias_set = 0;</span>
<span class="lineNum">    2646 </span><span class="lineCov">   25107113 :       vn_walk_kind = kind;</span>
<span class="lineNum">    2647 </span><span class="lineCov">   25107113 :       wvnresult =</span>
<span class="lineNum">    2648 </span><span class="lineCov">   25107113 :         (vn_reference_t)walk_non_aliased_vuses (&amp;r, vr1.vuse,</span>
<span class="lineNum">    2649 </span>            :                                                 vn_reference_lookup_2,
<span class="lineNum">    2650 </span>            :                                                 vn_reference_lookup_3,
<span class="lineNum">    2651 </span>            :                                                 vuse_valueize, &amp;vr1);
<span class="lineNum">    2652 </span><span class="lineCov">   50214226 :       gcc_checking_assert (vr1.operands == shared_lookup_references);</span>
<span class="lineNum">    2653 </span><span class="lineCov">   25107113 :       if (wvnresult)</span>
<span class="lineNum">    2654 </span>            :         {
<span class="lineNum">    2655 </span><span class="lineCov">    3299690 :           if (vnresult)</span>
<span class="lineNum">    2656 </span><span class="lineCov">    1337677 :             *vnresult = wvnresult;</span>
<span class="lineNum">    2657 </span><span class="lineCov">    3299690 :           return wvnresult-&gt;result;</span>
<span class="lineNum">    2658 </span>            :         }
<span class="lineNum">    2659 </span>            : 
<span class="lineNum">    2660 </span>            :       return NULL_TREE;
<span class="lineNum">    2661 </span>            :     }
<span class="lineNum">    2662 </span>            : 
<span class="lineNum">    2663 </span><span class="lineCov">   21368301 :   return vn_reference_lookup_1 (&amp;vr1, vnresult);</span>
<span class="lineNum">    2664 </span>            : }
<span class="lineNum">    2665 </span>            : 
<span class="lineNum">    2666 </span>            : /* Lookup CALL in the current hash table and return the entry in
<span class="lineNum">    2667 </span>            :    *VNRESULT if found.  Populates *VR for the hashtable lookup.  */
<a name="2668"><span class="lineNum">    2668 </span>            : </a>
<span class="lineNum">    2669 </span>            : void
<span class="lineNum">    2670 </span><span class="lineCov">    4358408 : vn_reference_lookup_call (gcall *call, vn_reference_t *vnresult,</span>
<span class="lineNum">    2671 </span>            :                           vn_reference_t vr)
<span class="lineNum">    2672 </span>            : {
<span class="lineNum">    2673 </span><span class="lineCov">    4358408 :   if (vnresult)</span>
<span class="lineNum">    2674 </span><span class="lineCov">    4358408 :     *vnresult = NULL;</span>
<span class="lineNum">    2675 </span>            : 
<span class="lineNum">    2676 </span><span class="lineCov">    4358408 :   tree vuse = gimple_vuse (call);</span>
<span class="lineNum">    2677 </span>            : 
<span class="lineNum">    2678 </span><span class="lineCov">    4358408 :   vr-&gt;vuse = vuse ? SSA_VAL (vuse) : NULL_TREE;</span>
<span class="lineNum">    2679 </span><span class="lineCov">    4358408 :   vr-&gt;operands = valueize_shared_reference_ops_from_call (call);</span>
<span class="lineNum">    2680 </span><span class="lineCov">    4358408 :   vr-&gt;type = gimple_expr_type (call);</span>
<span class="lineNum">    2681 </span><span class="lineCov">    4358408 :   vr-&gt;set = 0;</span>
<span class="lineNum">    2682 </span><span class="lineCov">    4358408 :   vr-&gt;hashcode = vn_reference_compute_hash (vr);</span>
<span class="lineNum">    2683 </span><span class="lineCov">    4358408 :   vn_reference_lookup_1 (vr, vnresult);</span>
<span class="lineNum">    2684 </span><span class="lineCov">    4358408 : }</span>
<span class="lineNum">    2685 </span>            : 
<span class="lineNum">    2686 </span>            : /* Insert OP into the current hash table with a value number of RESULT.  */
<a name="2687"><span class="lineNum">    2687 </span>            : </a>
<span class="lineNum">    2688 </span>            : static void 
<span class="lineNum">    2689 </span><span class="lineCov">   31118958 : vn_reference_insert (tree op, tree result, tree vuse, tree vdef)</span>
<span class="lineNum">    2690 </span>            : {
<span class="lineNum">    2691 </span><span class="lineCov">   31118958 :   vn_reference_s **slot;</span>
<span class="lineNum">    2692 </span><span class="lineCov">   31118958 :   vn_reference_t vr1;</span>
<span class="lineNum">    2693 </span><span class="lineCov">   31118958 :   bool tem;</span>
<span class="lineNum">    2694 </span>            : 
<span class="lineNum">    2695 </span><span class="lineCov">   31118958 :   vr1 = XOBNEW (&amp;vn_tables_obstack, vn_reference_s);</span>
<span class="lineNum">    2696 </span><span class="lineCov">   31118958 :   if (TREE_CODE (result) == SSA_NAME)</span>
<span class="lineNum">    2697 </span><span class="lineCov">   18968095 :     vr1-&gt;value_id = VN_INFO (result)-&gt;value_id;</span>
<span class="lineNum">    2698 </span>            :   else
<span class="lineNum">    2699 </span><span class="lineCov">   12150863 :     vr1-&gt;value_id = get_or_alloc_constant_value_id (result);</span>
<span class="lineNum">    2700 </span><span class="lineCov">   31118958 :   vr1-&gt;vuse = vuse_ssa_val (vuse);</span>
<span class="lineNum">    2701 </span><span class="lineCov">   31118958 :   vr1-&gt;operands = valueize_shared_reference_ops_from_ref (op, &amp;tem).copy ();</span>
<span class="lineNum">    2702 </span><span class="lineCov">   31118958 :   vr1-&gt;type = TREE_TYPE (op);</span>
<span class="lineNum">    2703 </span><span class="lineCov">   31118958 :   vr1-&gt;set = get_alias_set (op);</span>
<span class="lineNum">    2704 </span><span class="lineCov">   31118958 :   vr1-&gt;hashcode = vn_reference_compute_hash (vr1);</span>
<span class="lineNum">    2705 </span><span class="lineCov">   31118958 :   vr1-&gt;result = TREE_CODE (result) == SSA_NAME ? SSA_VAL (result) : result;</span>
<span class="lineNum">    2706 </span><span class="lineCov">   31118958 :   vr1-&gt;result_vdef = vdef;</span>
<span class="lineNum">    2707 </span>            : 
<span class="lineNum">    2708 </span><span class="lineCov">   31118958 :   slot = valid_info-&gt;references-&gt;find_slot_with_hash (vr1, vr1-&gt;hashcode,</span>
<span class="lineNum">    2709 </span>            :                                                       INSERT);
<span class="lineNum">    2710 </span>            : 
<span class="lineNum">    2711 </span>            :   /* Because IL walking on reference lookup can end up visiting
<span class="lineNum">    2712 </span>            :      a def that is only to be visited later in iteration order
<span class="lineNum">    2713 </span>            :      when we are about to make an irreducible region reducible
<span class="lineNum">    2714 </span>            :      the def can be effectively processed and its ref being inserted
<span class="lineNum">    2715 </span>            :      by vn_reference_lookup_3 already.  So we cannot assert (!*slot)
<span class="lineNum">    2716 </span>            :      but save a lookup if we deal with already inserted refs here.  */
<span class="lineNum">    2717 </span><span class="lineCov">   31118958 :   if (*slot)</span>
<span class="lineNum">    2718 </span>            :     {
<span class="lineNum">    2719 </span>            :       /* We cannot assert that we have the same value either because
<span class="lineNum">    2720 </span>            :          when disentangling an irreducible region we may end up visiting
<span class="lineNum">    2721 </span>            :          a use before the corresponding def.  That's a missed optimization
<span class="lineNum">    2722 </span>            :          only though.  See gcc.dg/tree-ssa/pr87126.c for example.  */
<span class="lineNum">    2723 </span><span class="lineNoCov">          0 :       if (dump_file &amp;&amp; (dump_flags &amp; TDF_DETAILS)</span>
<span class="lineNum">    2724 </span><span class="lineNoCov">          0 :           &amp;&amp; !operand_equal_p ((*slot)-&gt;result, vr1-&gt;result, 0))</span>
<span class="lineNum">    2725 </span>            :         {
<span class="lineNum">    2726 </span><span class="lineNoCov">          0 :           fprintf (dump_file, &quot;Keeping old value &quot;);</span>
<span class="lineNum">    2727 </span><span class="lineNoCov">          0 :           print_generic_expr (dump_file, (*slot)-&gt;result);</span>
<span class="lineNum">    2728 </span><span class="lineNoCov">          0 :           fprintf (dump_file, &quot; because of collision\n&quot;);</span>
<span class="lineNum">    2729 </span>            :         }
<span class="lineNum">    2730 </span><span class="lineNoCov">          0 :       free_reference (vr1);</span>
<span class="lineNum">    2731 </span><span class="lineNoCov">          0 :       obstack_free (&amp;vn_tables_obstack, vr1);</span>
<span class="lineNum">    2732 </span><span class="lineNoCov">          0 :       return;</span>
<span class="lineNum">    2733 </span>            :     }
<span class="lineNum">    2734 </span>            : 
<span class="lineNum">    2735 </span><span class="lineCov">   31118958 :   *slot = vr1;</span>
<span class="lineNum">    2736 </span><span class="lineCov">   31118958 :   vr1-&gt;next = last_inserted_ref;</span>
<span class="lineNum">    2737 </span><span class="lineCov">   31118958 :   last_inserted_ref = vr1;</span>
<span class="lineNum">    2738 </span>            : }
<span class="lineNum">    2739 </span>            : 
<span class="lineNum">    2740 </span>            : /* Insert a reference by it's pieces into the current hash table with
<span class="lineNum">    2741 </span>            :    a value number of RESULT.  Return the resulting reference
<span class="lineNum">    2742 </span>            :    structure we created.  */
<a name="2743"><span class="lineNum">    2743 </span>            : </a>
<span class="lineNum">    2744 </span>            : vn_reference_t
<span class="lineNum">    2745 </span><span class="lineCov">    2037610 : vn_reference_insert_pieces (tree vuse, alias_set_type set, tree type,</span>
<span class="lineNum">    2746 </span>            :                             vec&lt;vn_reference_op_s&gt; operands,
<span class="lineNum">    2747 </span>            :                             tree result, unsigned int value_id)
<span class="lineNum">    2748 </span>            : 
<span class="lineNum">    2749 </span>            : {
<span class="lineNum">    2750 </span><span class="lineCov">    2037610 :   vn_reference_s **slot;</span>
<span class="lineNum">    2751 </span><span class="lineCov">    2037610 :   vn_reference_t vr1;</span>
<span class="lineNum">    2752 </span>            : 
<span class="lineNum">    2753 </span><span class="lineCov">    2037610 :   vr1 = XOBNEW (&amp;vn_tables_obstack, vn_reference_s);</span>
<span class="lineNum">    2754 </span><span class="lineCov">    2037610 :   vr1-&gt;value_id = value_id;</span>
<span class="lineNum">    2755 </span><span class="lineCov">    2037610 :   vr1-&gt;vuse = vuse_ssa_val (vuse);</span>
<span class="lineNum">    2756 </span><span class="lineCov">    2037610 :   vr1-&gt;operands = valueize_refs (operands);</span>
<span class="lineNum">    2757 </span><span class="lineCov">    2037610 :   vr1-&gt;type = type;</span>
<span class="lineNum">    2758 </span><span class="lineCov">    2037610 :   vr1-&gt;set = set;</span>
<span class="lineNum">    2759 </span><span class="lineCov">    2037610 :   vr1-&gt;hashcode = vn_reference_compute_hash (vr1);</span>
<span class="lineNum">    2760 </span><span class="lineCov">    2037610 :   if (result &amp;&amp; TREE_CODE (result) == SSA_NAME)</span>
<span class="lineNum">    2761 </span><span class="lineCov">      25316 :     result = SSA_VAL (result);</span>
<span class="lineNum">    2762 </span><span class="lineCov">    2037610 :   vr1-&gt;result = result;</span>
<span class="lineNum">    2763 </span>            : 
<span class="lineNum">    2764 </span><span class="lineCov">    2037610 :   slot = valid_info-&gt;references-&gt;find_slot_with_hash (vr1, vr1-&gt;hashcode,</span>
<span class="lineNum">    2765 </span>            :                                                       INSERT);
<span class="lineNum">    2766 </span>            : 
<span class="lineNum">    2767 </span>            :   /* At this point we should have all the things inserted that we have
<span class="lineNum">    2768 </span>            :      seen before, and we should never try inserting something that
<span class="lineNum">    2769 </span>            :      already exists.  */
<span class="lineNum">    2770 </span><span class="lineCov">    2037610 :   gcc_assert (!*slot);</span>
<span class="lineNum">    2771 </span>            : 
<span class="lineNum">    2772 </span><span class="lineCov">    2037610 :   *slot = vr1;</span>
<span class="lineNum">    2773 </span><span class="lineCov">    2037610 :   vr1-&gt;next = last_inserted_ref;</span>
<span class="lineNum">    2774 </span><span class="lineCov">    2037610 :   last_inserted_ref = vr1;</span>
<span class="lineNum">    2775 </span><span class="lineCov">    2037610 :   return vr1;</span>
<span class="lineNum">    2776 </span>            : }
<span class="lineNum">    2777 </span>            : 
<span class="lineNum">    2778 </span>            : /* Compute and return the hash value for nary operation VBO1.  */
<a name="2779"><span class="lineNum">    2779 </span>            : </a>
<span class="lineNum">    2780 </span>            : static hashval_t
<span class="lineNum">    2781 </span><span class="lineCov">  118908150 : vn_nary_op_compute_hash (const vn_nary_op_t vno1)</span>
<span class="lineNum">    2782 </span>            : {
<span class="lineNum">    2783 </span><span class="lineCov">  118908150 :   inchash::hash hstate;</span>
<span class="lineNum">    2784 </span><span class="lineCov">  118908150 :   unsigned i;</span>
<span class="lineNum">    2785 </span>            : 
<span class="lineNum">    2786 </span><span class="lineCov">  339544318 :   for (i = 0; i &lt; vno1-&gt;length; ++i)</span>
<span class="lineNum">    2787 </span><span class="lineCov">  220636168 :     if (TREE_CODE (vno1-&gt;op[i]) == SSA_NAME)</span>
<span class="lineNum">    2788 </span><span class="lineCov">  154211897 :       vno1-&gt;op[i] = SSA_VAL (vno1-&gt;op[i]);</span>
<span class="lineNum">    2789 </span>            : 
<span class="lineNum">    2790 </span><span class="lineCov">  118908150 :   if (((vno1-&gt;length == 2</span>
<span class="lineNum">    2791 </span><span class="lineCov">  101122740 :         &amp;&amp; commutative_tree_code (vno1-&gt;opcode))</span>
<span class="lineNum">    2792 </span><span class="lineCov">   57227431 :        || (vno1-&gt;length == 3</span>
<span class="lineNum">    2793 </span><span class="lineCov">     257213 :            &amp;&amp; commutative_ternary_tree_code (vno1-&gt;opcode)))</span>
<span class="lineNum">    2794 </span><span class="lineCov">  180588887 :       &amp;&amp; tree_swap_operands_p (vno1-&gt;op[0], vno1-&gt;op[1]))</span>
<span class="lineNum">    2795 </span><span class="lineCov">    1973810 :     std::swap (vno1-&gt;op[0], vno1-&gt;op[1]);</span>
<span class="lineNum">    2796 </span><span class="lineCov">  116934340 :   else if (TREE_CODE_CLASS (vno1-&gt;opcode) == tcc_comparison</span>
<span class="lineNum">    2797 </span><span class="lineCov">  116934340 :            &amp;&amp; tree_swap_operands_p (vno1-&gt;op[0], vno1-&gt;op[1]))</span>
<span class="lineNum">    2798 </span>            :     {
<span class="lineNum">    2799 </span><span class="lineCov">    1608279 :       std::swap (vno1-&gt;op[0], vno1-&gt;op[1]);</span>
<span class="lineNum">    2800 </span><span class="lineCov">    1608279 :       vno1-&gt;opcode = swap_tree_comparison  (vno1-&gt;opcode);</span>
<span class="lineNum">    2801 </span>            :     }
<span class="lineNum">    2802 </span>            : 
<span class="lineNum">    2803 </span><span class="lineCov">  118908150 :   hstate.add_int (vno1-&gt;opcode);</span>
<span class="lineNum">    2804 </span><span class="lineCov">  339544318 :   for (i = 0; i &lt; vno1-&gt;length; ++i)</span>
<span class="lineNum">    2805 </span><span class="lineCov">  220636168 :     inchash::add_expr (vno1-&gt;op[i], hstate);</span>
<span class="lineNum">    2806 </span>            : 
<span class="lineNum">    2807 </span><span class="lineCov">  237816300 :   return hstate.end ();</span>
<span class="lineNum">    2808 </span>            : }
<span class="lineNum">    2809 </span>            : 
<span class="lineNum">    2810 </span>            : /* Compare nary operations VNO1 and VNO2 and return true if they are
<span class="lineNum">    2811 </span>            :    equivalent.  */
<a name="2812"><span class="lineNum">    2812 </span>            : </a>
<span class="lineNum">    2813 </span>            : bool
<span class="lineNum">    2814 </span><span class="lineCov">  149993749 : vn_nary_op_eq (const_vn_nary_op_t const vno1, const_vn_nary_op_t const vno2)</span>
<span class="lineNum">    2815 </span>            : {
<span class="lineNum">    2816 </span><span class="lineCov">  149993749 :   unsigned i;</span>
<span class="lineNum">    2817 </span>            : 
<span class="lineNum">    2818 </span><span class="lineCov">  149993749 :   if (vno1-&gt;hashcode != vno2-&gt;hashcode)</span>
<span class="lineNum">    2819 </span>            :     return false;
<span class="lineNum">    2820 </span>            : 
<span class="lineNum">    2821 </span><span class="lineCov">   77087814 :   if (vno1-&gt;length != vno2-&gt;length)</span>
<span class="lineNum">    2822 </span>            :     return false;
<span class="lineNum">    2823 </span>            : 
<span class="lineNum">    2824 </span><span class="lineCov">   77087814 :   if (vno1-&gt;opcode != vno2-&gt;opcode</span>
<span class="lineNum">    2825 </span><span class="lineCov">   77087814 :       || !types_compatible_p (vno1-&gt;type, vno2-&gt;type))</span>
<span class="lineNum">    2826 </span><span class="lineCov">     868330 :     return false;</span>
<span class="lineNum">    2827 </span>            : 
<span class="lineNum">    2828 </span><span class="lineCov">  214111879 :   for (i = 0; i &lt; vno1-&gt;length; ++i)</span>
<span class="lineNum">    2829 </span><span class="lineCov">  137982747 :     if (!expressions_equal_p (vno1-&gt;op[i], vno2-&gt;op[i]))</span>
<span class="lineNum">    2830 </span>            :       return false;
<span class="lineNum">    2831 </span>            : 
<span class="lineNum">    2832 </span>            :   /* BIT_INSERT_EXPR has an implict operand as the type precision
<span class="lineNum">    2833 </span>            :      of op1.  Need to check to make sure they are the same.  */
<span class="lineNum">    2834 </span><span class="lineCov">   76129132 :   if (vno1-&gt;opcode == BIT_INSERT_EXPR</span>
<span class="lineNum">    2835 </span><span class="lineCov">        583 :       &amp;&amp; TREE_CODE (vno1-&gt;op[1]) == INTEGER_CST</span>
<span class="lineNum">    2836 </span><span class="lineCov">   76129348 :       &amp;&amp; TYPE_PRECISION (TREE_TYPE (vno1-&gt;op[1]))</span>
<span class="lineNum">    2837 </span><span class="lineCov">        216 :          != TYPE_PRECISION (TREE_TYPE (vno2-&gt;op[1])))</span>
<span class="lineNum">    2838 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    2839 </span>            : 
<span class="lineNum">    2840 </span>            :   return true;
<span class="lineNum">    2841 </span>            : }
<span class="lineNum">    2842 </span>            : 
<span class="lineNum">    2843 </span>            : /* Initialize VNO from the pieces provided.  */
<a name="2844"><span class="lineNum">    2844 </span>            : </a>
<span class="lineNum">    2845 </span>            : static void
<span class="lineNum">    2846 </span><span class="lineNoCov">          0 : init_vn_nary_op_from_pieces (vn_nary_op_t vno, unsigned int length,</span>
<span class="lineNum">    2847 </span>            :                              enum tree_code code, tree type, tree *ops)
<span class="lineNum">    2848 </span>            : {
<span class="lineNum">    2849 </span><span class="lineCov">   73654348 :   vno-&gt;opcode = code;</span>
<span class="lineNum">    2850 </span><span class="lineCov">   73654348 :   vno-&gt;length = length;</span>
<span class="lineNum">    2851 </span><span class="lineCov">   73654348 :   vno-&gt;type = type;</span>
<span class="lineNum">    2852 </span><span class="lineCov">    2424738 :   memcpy (&amp;vno-&gt;op[0], ops, sizeof (tree) * length);</span>
<span class="lineNum">    2853 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    2854 </span>            : 
<span class="lineNum">    2855 </span>            : /* Initialize VNO from OP.  */
<a name="2856"><span class="lineNum">    2856 </span>            : </a>
<span class="lineNum">    2857 </span>            : static void
<span class="lineNum">    2858 </span><span class="lineNoCov">          0 : init_vn_nary_op_from_op (vn_nary_op_t vno, tree op)</span>
<span class="lineNum">    2859 </span>            : {
<span class="lineNum">    2860 </span><span class="lineNoCov">          0 :   unsigned i;</span>
<span class="lineNum">    2861 </span>            : 
<span class="lineNum">    2862 </span><span class="lineNoCov">          0 :   vno-&gt;opcode = TREE_CODE (op);</span>
<span class="lineNum">    2863 </span><span class="lineNoCov">          0 :   vno-&gt;length = TREE_CODE_LENGTH (TREE_CODE (op));</span>
<span class="lineNum">    2864 </span><span class="lineNoCov">          0 :   vno-&gt;type = TREE_TYPE (op);</span>
<span class="lineNum">    2865 </span><span class="lineNoCov">          0 :   for (i = 0; i &lt; vno-&gt;length; ++i)</span>
<span class="lineNum">    2866 </span><span class="lineNoCov">          0 :     vno-&gt;op[i] = TREE_OPERAND (op, i);</span>
<span class="lineNum">    2867 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    2868 </span>            : 
<span class="lineNum">    2869 </span>            : /* Return the number of operands for a vn_nary ops structure from STMT.  */
<a name="2870"><span class="lineNum">    2870 </span>            : </a>
<span class="lineNum">    2871 </span>            : static unsigned int
<span class="lineNum">    2872 </span><span class="lineCov">   45253802 : vn_nary_length_from_stmt (gimple *stmt)</span>
<span class="lineNum">    2873 </span>            : {
<span class="lineNum">    2874 </span><span class="lineCov">   45253802 :   switch (gimple_assign_rhs_code (stmt))</span>
<span class="lineNum">    2875 </span>            :     {
<span class="lineNum">    2876 </span>            :     case REALPART_EXPR:
<span class="lineNum">    2877 </span>            :     case IMAGPART_EXPR:
<span class="lineNum">    2878 </span>            :     case VIEW_CONVERT_EXPR:
<span class="lineNum">    2879 </span>            :       return 1;
<span class="lineNum">    2880 </span>            : 
<span class="lineNum">    2881 </span><span class="lineCov">      80059 :     case BIT_FIELD_REF:</span>
<span class="lineNum">    2882 </span><span class="lineCov">      80059 :       return 3;</span>
<span class="lineNum">    2883 </span>            : 
<span class="lineNum">    2884 </span><span class="lineCov">      73198 :     case CONSTRUCTOR:</span>
<span class="lineNum">    2885 </span><span class="lineCov">      73198 :       return CONSTRUCTOR_NELTS (gimple_assign_rhs1 (stmt));</span>
<span class="lineNum">    2886 </span>            : 
<span class="lineNum">    2887 </span><span class="lineCov">   43586828 :     default:</span>
<span class="lineNum">    2888 </span><span class="lineCov">   87173656 :       return gimple_num_ops (stmt) - 1;</span>
<span class="lineNum">    2889 </span>            :     }
<span class="lineNum">    2890 </span>            : }
<span class="lineNum">    2891 </span>            : 
<span class="lineNum">    2892 </span>            : /* Initialize VNO from STMT.  */
<a name="2893"><span class="lineNum">    2893 </span>            : </a>
<span class="lineNum">    2894 </span>            : static void
<span class="lineNum">    2895 </span><span class="lineCov">   45253802 : init_vn_nary_op_from_stmt (vn_nary_op_t vno, gimple *stmt)</span>
<span class="lineNum">    2896 </span>            : {
<span class="lineNum">    2897 </span><span class="lineCov">   45253802 :   unsigned i;</span>
<span class="lineNum">    2898 </span>            : 
<span class="lineNum">    2899 </span><span class="lineCov">   45253802 :   vno-&gt;opcode = gimple_assign_rhs_code (stmt);</span>
<span class="lineNum">    2900 </span><span class="lineCov">   45253802 :   vno-&gt;type = gimple_expr_type (stmt);</span>
<span class="lineNum">    2901 </span><span class="lineCov">   45253802 :   switch (vno-&gt;opcode)</span>
<span class="lineNum">    2902 </span>            :     {
<span class="lineNum">    2903 </span><span class="lineCov">    1513717 :     case REALPART_EXPR:</span>
<span class="lineNum">    2904 </span><span class="lineCov">    1513717 :     case IMAGPART_EXPR:</span>
<span class="lineNum">    2905 </span><span class="lineCov">    1513717 :     case VIEW_CONVERT_EXPR:</span>
<span class="lineNum">    2906 </span><span class="lineCov">    1513717 :       vno-&gt;length = 1;</span>
<span class="lineNum">    2907 </span><span class="lineCov">    1513717 :       vno-&gt;op[0] = TREE_OPERAND (gimple_assign_rhs1 (stmt), 0);</span>
<span class="lineNum">    2908 </span><span class="lineCov">    1513717 :       break;</span>
<span class="lineNum">    2909 </span>            : 
<span class="lineNum">    2910 </span><span class="lineCov">      80059 :     case BIT_FIELD_REF:</span>
<span class="lineNum">    2911 </span><span class="lineCov">      80059 :       vno-&gt;length = 3;</span>
<span class="lineNum">    2912 </span><span class="lineCov">      80059 :       vno-&gt;op[0] = TREE_OPERAND (gimple_assign_rhs1 (stmt), 0);</span>
<span class="lineNum">    2913 </span><span class="lineCov">     160118 :       vno-&gt;op[1] = TREE_OPERAND (gimple_assign_rhs1 (stmt), 1);</span>
<span class="lineNum">    2914 </span><span class="lineCov">     160118 :       vno-&gt;op[2] = TREE_OPERAND (gimple_assign_rhs1 (stmt), 2);</span>
<span class="lineNum">    2915 </span><span class="lineCov">      80059 :       break;</span>
<span class="lineNum">    2916 </span>            : 
<span class="lineNum">    2917 </span><span class="lineCov">      73198 :     case CONSTRUCTOR:</span>
<span class="lineNum">    2918 </span><span class="lineCov">      73198 :       vno-&gt;length = CONSTRUCTOR_NELTS (gimple_assign_rhs1 (stmt));</span>
<span class="lineNum">    2919 </span><span class="lineCov">     242026 :       for (i = 0; i &lt; vno-&gt;length; ++i)</span>
<span class="lineNum">    2920 </span><span class="lineCov">     337656 :         vno-&gt;op[i] = CONSTRUCTOR_ELT (gimple_assign_rhs1 (stmt), i)-&gt;value;</span>
<span class="lineNum">    2921 </span>            :       break;
<span class="lineNum">    2922 </span>            : 
<span class="lineNum">    2923 </span><span class="lineCov">   43586828 :     default:</span>
<span class="lineNum">    2924 </span><span class="lineCov">   43586828 :       gcc_checking_assert (!gimple_assign_single_p (stmt));</span>
<span class="lineNum">    2925 </span><span class="lineCov">   43586828 :       vno-&gt;length = gimple_num_ops (stmt) - 1;</span>
<span class="lineNum">    2926 </span><span class="lineCov">  118745782 :       for (i = 0; i &lt; vno-&gt;length; ++i)</span>
<span class="lineNum">    2927 </span><span class="lineCov">   75158954 :         vno-&gt;op[i] = gimple_op (stmt, i + 1);</span>
<span class="lineNum">    2928 </span>            :     }
<span class="lineNum">    2929 </span><span class="lineCov">   45253802 : }</span>
<span class="lineNum">    2930 </span>            : 
<span class="lineNum">    2931 </span>            : /* Compute the hashcode for VNO and look for it in the hash table;
<span class="lineNum">    2932 </span>            :    return the resulting value number if it exists in the hash table.
<span class="lineNum">    2933 </span>            :    Return NULL_TREE if it does not exist in the hash table or if the
<span class="lineNum">    2934 </span>            :    result field of the operation is NULL.  VNRESULT will contain the
<span class="lineNum">    2935 </span>            :    vn_nary_op_t from the hashtable if it exists.  */
<a name="2936"><span class="lineNum">    2936 </span>            : </a>
<span class="lineNum">    2937 </span>            : static tree
<span class="lineNum">    2938 </span><span class="lineCov">   47516809 : vn_nary_op_lookup_1 (vn_nary_op_t vno, vn_nary_op_t *vnresult)</span>
<span class="lineNum">    2939 </span>            : {
<span class="lineNum">    2940 </span><span class="lineCov">   47516809 :   vn_nary_op_s **slot;</span>
<span class="lineNum">    2941 </span>            : 
<span class="lineNum">    2942 </span><span class="lineCov">   47516809 :   if (vnresult)</span>
<span class="lineNum">    2943 </span><span class="lineCov">   46074894 :     *vnresult = NULL;</span>
<span class="lineNum">    2944 </span>            : 
<span class="lineNum">    2945 </span><span class="lineCov">   47516809 :   vno-&gt;hashcode = vn_nary_op_compute_hash (vno);</span>
<span class="lineNum">    2946 </span><span class="lineCov">   47516809 :   slot = valid_info-&gt;nary-&gt;find_slot_with_hash (vno, vno-&gt;hashcode, NO_INSERT);</span>
<span class="lineNum">    2947 </span><span class="lineCov">   47516809 :   if (!slot)</span>
<span class="lineNum">    2948 </span>            :     return NULL_TREE;
<span class="lineNum">    2949 </span><span class="lineCov">    8583680 :   if (vnresult)</span>
<span class="lineNum">    2950 </span><span class="lineCov">    8388688 :     *vnresult = *slot;</span>
<span class="lineNum">    2951 </span><span class="lineCov">    8583680 :   return (*slot)-&gt;predicated_values ? NULL_TREE : (*slot)-&gt;u.result;</span>
<span class="lineNum">    2952 </span>            : }
<span class="lineNum">    2953 </span>            : 
<span class="lineNum">    2954 </span>            : /* Lookup a n-ary operation by its pieces and return the resulting value
<span class="lineNum">    2955 </span>            :    number if it exists in the hash table.  Return NULL_TREE if it does
<span class="lineNum">    2956 </span>            :    not exist in the hash table or if the result field of the operation
<span class="lineNum">    2957 </span>            :    is NULL. VNRESULT will contain the vn_nary_op_t from the hashtable
<span class="lineNum">    2958 </span>            :    if it exists.  */
<a name="2959"><span class="lineNum">    2959 </span>            : </a>
<span class="lineNum">    2960 </span>            : tree
<span class="lineNum">    2961 </span><span class="lineCov">   22022017 : vn_nary_op_lookup_pieces (unsigned int length, enum tree_code code,</span>
<span class="lineNum">    2962 </span>            :                           tree type, tree *ops, vn_nary_op_t *vnresult)
<span class="lineNum">    2963 </span>            : {
<span class="lineNum">    2964 </span><span class="lineCov">   22022017 :   vn_nary_op_t vno1 = XALLOCAVAR (struct vn_nary_op_s,</span>
<span class="lineNum">    2965 </span>            :                                   sizeof_vn_nary_op (length));
<span class="lineNum">    2966 </span><span class="lineCov">   44044034 :   init_vn_nary_op_from_pieces (vno1, length, code, type, ops);</span>
<span class="lineNum">    2967 </span><span class="lineCov">   22022017 :   return vn_nary_op_lookup_1 (vno1, vnresult);</span>
<span class="lineNum">    2968 </span>            : }
<span class="lineNum">    2969 </span>            : 
<span class="lineNum">    2970 </span>            : /* Lookup OP in the current hash table, and return the resulting value
<span class="lineNum">    2971 </span>            :    number if it exists in the hash table.  Return NULL_TREE if it does
<span class="lineNum">    2972 </span>            :    not exist in the hash table or if the result field of the operation
<span class="lineNum">    2973 </span>            :    is NULL. VNRESULT will contain the vn_nary_op_t from the hashtable
<span class="lineNum">    2974 </span>            :    if it exists.  */
<a name="2975"><span class="lineNum">    2975 </span>            : </a>
<span class="lineNum">    2976 </span>            : tree
<span class="lineNum">    2977 </span><span class="lineNoCov">          0 : vn_nary_op_lookup (tree op, vn_nary_op_t *vnresult)</span>
<span class="lineNum">    2978 </span>            : {
<span class="lineNum">    2979 </span><span class="lineNoCov">          0 :   vn_nary_op_t vno1</span>
<span class="lineNum">    2980 </span><span class="lineNoCov">          0 :     = XALLOCAVAR (struct vn_nary_op_s,</span>
<span class="lineNum">    2981 </span>            :                   sizeof_vn_nary_op (TREE_CODE_LENGTH (TREE_CODE (op))));
<span class="lineNum">    2982 </span><span class="lineNoCov">          0 :   init_vn_nary_op_from_op (vno1, op);</span>
<span class="lineNum">    2983 </span><span class="lineNoCov">          0 :   return vn_nary_op_lookup_1 (vno1, vnresult);</span>
<span class="lineNum">    2984 </span>            : }
<span class="lineNum">    2985 </span>            : 
<span class="lineNum">    2986 </span>            : /* Lookup the rhs of STMT in the current hash table, and return the resulting
<span class="lineNum">    2987 </span>            :    value number if it exists in the hash table.  Return NULL_TREE if
<span class="lineNum">    2988 </span>            :    it does not exist in the hash table.  VNRESULT will contain the
<span class="lineNum">    2989 </span>            :    vn_nary_op_t from the hashtable if it exists.  */
<a name="2990"><span class="lineNum">    2990 </span>            : </a>
<span class="lineNum">    2991 </span>            : tree
<span class="lineNum">    2992 </span><span class="lineCov">   25494792 : vn_nary_op_lookup_stmt (gimple *stmt, vn_nary_op_t *vnresult)</span>
<span class="lineNum">    2993 </span>            : {
<span class="lineNum">    2994 </span><span class="lineCov">   25494792 :   vn_nary_op_t vno1</span>
<span class="lineNum">    2995 </span><span class="lineCov">   25494792 :     = XALLOCAVAR (struct vn_nary_op_s,</span>
<span class="lineNum">    2996 </span>            :                   sizeof_vn_nary_op (vn_nary_length_from_stmt (stmt)));
<span class="lineNum">    2997 </span><span class="lineCov">   25494792 :   init_vn_nary_op_from_stmt (vno1, stmt);</span>
<span class="lineNum">    2998 </span><span class="lineCov">   25494792 :   return vn_nary_op_lookup_1 (vno1, vnresult);</span>
<span class="lineNum">    2999 </span>            : }
<span class="lineNum">    3000 </span>            : 
<span class="lineNum">    3001 </span>            : /* Allocate a vn_nary_op_t with LENGTH operands on STACK.  */
<a name="3002"><span class="lineNum">    3002 </span>            : </a>
<span class="lineNum">    3003 </span>            : static vn_nary_op_t
<span class="lineNum">    3004 </span><span class="lineCov">   71391341 : alloc_vn_nary_op_noinit (unsigned int length, struct obstack *stack)</span>
<span class="lineNum">    3005 </span>            : {
<span class="lineNum">    3006 </span><span class="lineCov">  142782682 :   return (vn_nary_op_t) obstack_alloc (stack, sizeof_vn_nary_op (length));</span>
<span class="lineNum">    3007 </span>            : }
<span class="lineNum">    3008 </span>            : 
<span class="lineNum">    3009 </span>            : /* Allocate and initialize a vn_nary_op_t on CURRENT_INFO's
<span class="lineNum">    3010 </span>            :    obstack.  */
<a name="3011"><span class="lineNum">    3011 </span>            : </a>
<span class="lineNum">    3012 </span>            : static vn_nary_op_t
<span class="lineNum">    3013 </span><span class="lineNoCov">          0 : alloc_vn_nary_op (unsigned int length, tree result, unsigned int value_id)</span>
<span class="lineNum">    3014 </span>            : {
<span class="lineNum">    3015 </span><span class="lineNoCov">          0 :   vn_nary_op_t vno1 = alloc_vn_nary_op_noinit (length, &amp;vn_tables_obstack);</span>
<span class="lineNum">    3016 </span>            : 
<span class="lineNum">    3017 </span><span class="lineCov">   68948986 :   vno1-&gt;value_id = value_id;</span>
<span class="lineNum">    3018 </span><span class="lineCov">   68948986 :   vno1-&gt;length = length;</span>
<span class="lineNum">    3019 </span><span class="lineCov">   68948986 :   vno1-&gt;predicated_values = 0;</span>
<span class="lineNum">    3020 </span><span class="lineCov">   68948986 :   vno1-&gt;u.result = result;</span>
<span class="lineNum">    3021 </span>            : 
<span class="lineNum">    3022 </span><span class="lineCov">   68948986 :   return vno1;</span>
<span class="lineNum">    3023 </span>            : }
<span class="lineNum">    3024 </span>            : 
<span class="lineNum">    3025 </span>            : /* Insert VNO into TABLE.  If COMPUTE_HASH is true, then compute
<span class="lineNum">    3026 </span>            :    VNO-&gt;HASHCODE first.  */
<a name="3027"><span class="lineNum">    3027 </span>            : </a>
<span class="lineNum">    3028 </span>            : static vn_nary_op_t
<span class="lineNum">    3029 </span><span class="lineCov">   71391341 : vn_nary_op_insert_into (vn_nary_op_t vno, vn_nary_op_table_type *table,</span>
<span class="lineNum">    3030 </span>            :                         bool compute_hash)
<span class="lineNum">    3031 </span>            : {
<span class="lineNum">    3032 </span><span class="lineCov">   71391341 :   vn_nary_op_s **slot;</span>
<span class="lineNum">    3033 </span>            : 
<span class="lineNum">    3034 </span><span class="lineCov">   71391341 :   if (compute_hash)</span>
<span class="lineNum">    3035 </span>            :     {
<span class="lineNum">    3036 </span><span class="lineCov">   71391341 :       vno-&gt;hashcode = vn_nary_op_compute_hash (vno);</span>
<span class="lineNum">    3037 </span><span class="lineCov">   71391341 :       gcc_assert (! vno-&gt;predicated_values</span>
<span class="lineNum">    3038 </span>            :                   || (! vno-&gt;u.values-&gt;next
<span class="lineNum">    3039 </span>            :                       &amp;&amp; vno-&gt;u.values-&gt;n == 1));
<span class="lineNum">    3040 </span>            :     }
<span class="lineNum">    3041 </span>            : 
<span class="lineNum">    3042 </span><span class="lineCov">   71391341 :   slot = table-&gt;find_slot_with_hash (vno, vno-&gt;hashcode, INSERT);</span>
<span class="lineNum">    3043 </span><span class="lineCov">   71391341 :   vno-&gt;unwind_to = *slot;</span>
<span class="lineNum">    3044 </span><span class="lineCov">   71391341 :   if (*slot)</span>
<span class="lineNum">    3045 </span>            :     {
<span class="lineNum">    3046 </span>            :       /* Prefer non-predicated values.
<span class="lineNum">    3047 </span>            :          ???  Only if those are constant, otherwise, with constant predicated
<span class="lineNum">    3048 </span>            :          value, turn them into predicated values with entry-block validity
<span class="lineNum">    3049 </span>            :          (???  but we always find the first valid result currently).  */
<span class="lineNum">    3050 </span><span class="lineCov">   27374314 :       if ((*slot)-&gt;predicated_values</span>
<span class="lineNum">    3051 </span><span class="lineCov">   13687157 :           &amp;&amp; ! vno-&gt;predicated_values)</span>
<span class="lineNum">    3052 </span>            :         {
<span class="lineNum">    3053 </span>            :           /* ???  We cannot remove *slot from the unwind stack list.
<span class="lineNum">    3054 </span>            :              For the moment we deal with this by skipping not found
<span class="lineNum">    3055 </span>            :              entries but this isn't ideal ...  */
<span class="lineNum">    3056 </span><span class="lineCov">     108152 :           *slot = vno;</span>
<span class="lineNum">    3057 </span>            :           /* ???  Maintain a stack of states we can unwind in
<span class="lineNum">    3058 </span>            :              vn_nary_op_s?  But how far do we unwind?  In reality
<span class="lineNum">    3059 </span>            :              we need to push change records somewhere...  Or not
<span class="lineNum">    3060 </span>            :              unwind vn_nary_op_s and linking them but instead
<span class="lineNum">    3061 </span>            :              unwind the results &quot;list&quot;, linking that, which also
<span class="lineNum">    3062 </span>            :              doesn't move on hashtable resize.  */
<span class="lineNum">    3063 </span>            :           /* We can also have a -&gt;unwind_to recording *slot there.
<span class="lineNum">    3064 </span>            :              That way we can make u.values a fixed size array with
<span class="lineNum">    3065 </span>            :              recording the number of entries but of course we then
<span class="lineNum">    3066 </span>            :              have always N copies for each unwind_to-state.  Or we
<span class="lineNum">    3067 </span>            :              make sure to only ever append and each unwinding will
<span class="lineNum">    3068 </span>            :              pop off one entry (but how to deal with predicated
<span class="lineNum">    3069 </span>            :              replaced with non-predicated here?)  */
<span class="lineNum">    3070 </span><span class="lineCov">     108152 :           vno-&gt;next = last_inserted_nary;</span>
<span class="lineNum">    3071 </span><span class="lineCov">     108152 :           last_inserted_nary = vno;</span>
<span class="lineNum">    3072 </span><span class="lineCov">     108152 :           return vno;</span>
<span class="lineNum">    3073 </span>            :         }
<span class="lineNum">    3074 </span><span class="lineCov">   27158010 :       else if (vno-&gt;predicated_values</span>
<span class="lineNum">    3075 </span><span class="lineCov">   13579005 :                &amp;&amp; ! (*slot)-&gt;predicated_values)</span>
<span class="lineNum">    3076 </span>            :         return *slot;
<span class="lineNum">    3077 </span><span class="lineCov">   13252484 :       else if (vno-&gt;predicated_values</span>
<span class="lineNum">    3078 </span><span class="lineCov">   13252132 :                &amp;&amp; (*slot)-&gt;predicated_values)</span>
<span class="lineNum">    3079 </span>            :         {
<span class="lineNum">    3080 </span>            :           /* ???  Factor this all into a insert_single_predicated_value
<span class="lineNum">    3081 </span>            :              routine.  */
<span class="lineNum">    3082 </span><span class="lineCov">   13252132 :           gcc_assert (!vno-&gt;u.values-&gt;next &amp;&amp; vno-&gt;u.values-&gt;n == 1);</span>
<span class="lineNum">    3083 </span><span class="lineCov">   13252132 :           basic_block vno_bb</span>
<span class="lineNum">    3084 </span><span class="lineCov">   13252132 :             = BASIC_BLOCK_FOR_FN (cfun, vno-&gt;u.values-&gt;valid_dominated_by_p[0]);</span>
<span class="lineNum">    3085 </span><span class="lineCov">   13252132 :           vn_pval *nval = vno-&gt;u.values;</span>
<span class="lineNum">    3086 </span><span class="lineCov">   13252132 :           vn_pval **next = &amp;vno-&gt;u.values;</span>
<span class="lineNum">    3087 </span><span class="lineCov">   13252132 :           bool found = false;</span>
<span class="lineNum">    3088 </span><span class="lineCov">   28654043 :           for (vn_pval *val = (*slot)-&gt;u.values; val; val = val-&gt;next)</span>
<span class="lineNum">    3089 </span>            :             {
<span class="lineNum">    3090 </span><span class="lineCov">   15423530 :               if (expressions_equal_p (val-&gt;result, vno-&gt;u.values-&gt;result))</span>
<span class="lineNum">    3091 </span>            :                 {
<span class="lineNum">    3092 </span>            :                   found = true;
<span class="lineNum">    3093 </span><span class="lineCov">    6295856 :                   for (unsigned i = 0; i &lt; val-&gt;n; ++i)</span>
<span class="lineNum">    3094 </span>            :                     {
<span class="lineNum">    3095 </span><span class="lineCov">    4787600 :                       basic_block val_bb</span>
<span class="lineNum">    3096 </span><span class="lineCov">    4787600 :                         = BASIC_BLOCK_FOR_FN (cfun,</span>
<span class="lineNum">    3097 </span>            :                                               val-&gt;valid_dominated_by_p[i]);
<span class="lineNum">    3098 </span><span class="lineCov">    4787600 :                       if (dominated_by_p (CDI_DOMINATORS, vno_bb, val_bb))</span>
<span class="lineNum">    3099 </span>            :                         /* Value registered with more generic predicate.  */
<span class="lineNum">    3100 </span><span class="lineCov">      21619 :                         return *slot;</span>
<span class="lineNum">    3101 </span><span class="lineCov">    4765981 :                       else if (dominated_by_p (CDI_DOMINATORS, val_bb, vno_bb))</span>
<span class="lineNum">    3102 </span>            :                         /* Shouldn't happen, we insert in RPO order.  */
<span class="lineNum">    3103 </span><span class="lineNoCov">          0 :                         gcc_unreachable ();</span>
<span class="lineNum">    3104 </span>            :                     }
<span class="lineNum">    3105 </span>            :                   /* Append value.  */
<span class="lineNum">    3106 </span><span class="lineCov">    1508256 :                   *next = (vn_pval *) obstack_alloc (&amp;vn_tables_obstack,</span>
<span class="lineNum">    3107 </span>            :                                                      sizeof (vn_pval)
<span class="lineNum">    3108 </span>            :                                                      + val-&gt;n * sizeof (int));
<span class="lineNum">    3109 </span><span class="lineCov">    1508256 :                   (*next)-&gt;next = NULL;</span>
<span class="lineNum">    3110 </span><span class="lineCov">    1508256 :                   (*next)-&gt;result = val-&gt;result;</span>
<span class="lineNum">    3111 </span><span class="lineCov">    1508256 :                   (*next)-&gt;n = val-&gt;n + 1;</span>
<span class="lineNum">    3112 </span><span class="lineCov">    4524768 :                   memcpy ((*next)-&gt;valid_dominated_by_p,</span>
<span class="lineNum">    3113 </span><span class="lineCov">    1508256 :                           val-&gt;valid_dominated_by_p,</span>
<span class="lineNum">    3114 </span><span class="lineCov">    1508256 :                           val-&gt;n * sizeof (int));</span>
<span class="lineNum">    3115 </span><span class="lineCov">    1508256 :                   (*next)-&gt;valid_dominated_by_p[val-&gt;n] = vno_bb-&gt;index;</span>
<span class="lineNum">    3116 </span><span class="lineCov">    1508256 :                   next = &amp;(*next)-&gt;next;</span>
<span class="lineNum">    3117 </span><span class="lineCov">    1508256 :                   if (dump_file &amp;&amp; (dump_flags &amp; TDF_DETAILS))</span>
<span class="lineNum">    3118 </span><span class="lineCov">          8 :                     fprintf (dump_file, &quot;Appending predicate to value.\n&quot;);</span>
<span class="lineNum">    3119 </span><span class="lineCov">    1508256 :                   continue;</span>
<span class="lineNum">    3120 </span>            :                 }
<span class="lineNum">    3121 </span>            :               /* Copy other predicated values.  */
<span class="lineNum">    3122 </span><span class="lineCov">   13893655 :               *next = (vn_pval *) obstack_alloc (&amp;vn_tables_obstack,</span>
<span class="lineNum">    3123 </span>            :                                                  sizeof (vn_pval)
<span class="lineNum">    3124 </span>            :                                                  + (val-&gt;n-1) * sizeof (int));
<span class="lineNum">    3125 </span><span class="lineCov">   13893655 :               memcpy (*next, val, sizeof (vn_pval) + (val-&gt;n-1) * sizeof (int));</span>
<span class="lineNum">    3126 </span><span class="lineCov">   13893655 :               (*next)-&gt;next = NULL;</span>
<span class="lineNum">    3127 </span><span class="lineCov">   13893655 :               next = &amp;(*next)-&gt;next;</span>
<span class="lineNum">    3128 </span>            :             }
<span class="lineNum">    3129 </span><span class="lineCov">   13230513 :           if (!found)</span>
<span class="lineNum">    3130 </span><span class="lineCov">   11722257 :             *next = nval;</span>
<span class="lineNum">    3131 </span>            : 
<span class="lineNum">    3132 </span><span class="lineCov">   13230513 :           *slot = vno;</span>
<span class="lineNum">    3133 </span><span class="lineCov">   13230513 :           vno-&gt;next = last_inserted_nary;</span>
<span class="lineNum">    3134 </span><span class="lineCov">   13230513 :           last_inserted_nary = vno;</span>
<span class="lineNum">    3135 </span><span class="lineCov">   13230513 :           return vno;</span>
<span class="lineNum">    3136 </span>            :         }
<span class="lineNum">    3137 </span>            : 
<span class="lineNum">    3138 </span>            :       /* While we do not want to insert things twice it's awkward to
<span class="lineNum">    3139 </span>            :          avoid it in the case where visit_nary_op pattern-matches stuff
<span class="lineNum">    3140 </span>            :          and ends up simplifying the replacement to itself.  We then
<span class="lineNum">    3141 </span>            :          get two inserts, one from visit_nary_op and one from
<span class="lineNum">    3142 </span>            :          vn_nary_build_or_lookup.
<span class="lineNum">    3143 </span>            :          So allow inserts with the same value number.  */
<span class="lineNum">    3144 </span><span class="lineCov">        352 :       if ((*slot)-&gt;u.result == vno-&gt;u.result)</span>
<span class="lineNum">    3145 </span>            :         return *slot;
<span class="lineNum">    3146 </span>            :     }
<span class="lineNum">    3147 </span>            : 
<span class="lineNum">    3148 </span>            :   /* ???  There's also optimistic vs. previous commited state merging
<span class="lineNum">    3149 </span>            :      that is problematic for the case of unwinding.  */
<span class="lineNum">    3150 </span>            : 
<span class="lineNum">    3151 </span>            :   /* ???  We should return NULL if we do not use 'vno' and have the
<span class="lineNum">    3152 </span>            :      caller release it.  */
<span class="lineNum">    3153 </span><span class="lineCov">   57704184 :   gcc_assert (!*slot);</span>
<span class="lineNum">    3154 </span>            : 
<span class="lineNum">    3155 </span><span class="lineCov">   57704184 :   *slot = vno;</span>
<span class="lineNum">    3156 </span><span class="lineCov">   57704184 :   vno-&gt;next = last_inserted_nary;</span>
<span class="lineNum">    3157 </span><span class="lineCov">   57704184 :   last_inserted_nary = vno;</span>
<span class="lineNum">    3158 </span><span class="lineCov">   57704184 :   return vno;</span>
<span class="lineNum">    3159 </span>            : }
<span class="lineNum">    3160 </span>            : 
<span class="lineNum">    3161 </span>            : /* Insert a n-ary operation into the current hash table using it's
<span class="lineNum">    3162 </span>            :    pieces.  Return the vn_nary_op_t structure we created and put in
<span class="lineNum">    3163 </span>            :    the hashtable.  */
<a name="3164"><span class="lineNum">    3164 </span>            : </a>
<span class="lineNum">    3165 </span>            : vn_nary_op_t
<span class="lineNum">    3166 </span><span class="lineCov">    2816655 : vn_nary_op_insert_pieces (unsigned int length, enum tree_code code,</span>
<span class="lineNum">    3167 </span>            :                           tree type, tree *ops,
<span class="lineNum">    3168 </span>            :                           tree result, unsigned int value_id)
<span class="lineNum">    3169 </span>            : {
<span class="lineNum">    3170 </span><span class="lineCov">    2816655 :   vn_nary_op_t vno1 = alloc_vn_nary_op (length, result, value_id);</span>
<span class="lineNum">    3171 </span><span class="lineCov">    5633310 :   init_vn_nary_op_from_pieces (vno1, length, code, type, ops);</span>
<span class="lineNum">    3172 </span><span class="lineCov">    2816655 :   return vn_nary_op_insert_into (vno1, valid_info-&gt;nary, true);</span>
<span class="lineNum">    3173 </span>            : }
<a name="3174"><span class="lineNum">    3174 </span>            : </a>
<span class="lineNum">    3175 </span>            : static vn_nary_op_t
<span class="lineNum">    3176 </span><span class="lineCov">   58169943 : vn_nary_op_insert_pieces_predicated (unsigned int length, enum tree_code code,</span>
<span class="lineNum">    3177 </span>            :                                      tree type, tree *ops,
<span class="lineNum">    3178 </span>            :                                      tree result, unsigned int value_id,
<span class="lineNum">    3179 </span>            :                                      edge pred_e)
<span class="lineNum">    3180 </span>            : {
<span class="lineNum">    3181 </span>            :   /* ???  Currently tracking BBs.  */
<span class="lineNum">    3182 </span><span class="lineCov">   58169943 :   if (! single_pred_p (pred_e-&gt;dest))</span>
<span class="lineNum">    3183 </span>            :     {
<span class="lineNum">    3184 </span>            :       /* Never record for backedges.  */
<span class="lineNum">    3185 </span><span class="lineCov">   12242046 :       if (pred_e-&gt;flags &amp; EDGE_DFS_BACK)</span>
<span class="lineNum">    3186 </span><span class="lineCov">   11779005 :         return NULL;</span>
<span class="lineNum">    3187 </span><span class="lineCov">   11824916 :       edge_iterator ei;</span>
<span class="lineNum">    3188 </span><span class="lineCov">   11824916 :       edge e;</span>
<span class="lineNum">    3189 </span><span class="lineCov">   11824916 :       int cnt = 0;</span>
<span class="lineNum">    3190 </span>            :       /* Ignore backedges.  */
<span class="lineNum">    3191 </span><span class="lineCov"> 2071247611 :       FOR_EACH_EDGE (e, ei, pred_e-&gt;dest-&gt;preds)</span>
<span class="lineNum">    3192 </span><span class="lineCov"> 2047597779 :         if (! dominated_by_p (CDI_DOMINATORS, e-&gt;src, e-&gt;dest))</span>
<span class="lineNum">    3193 </span><span class="lineCov"> 2047124723 :           cnt++;</span>
<span class="lineNum">    3194 </span><span class="lineCov">   11824916 :       if (cnt != 1)</span>
<span class="lineNum">    3195 </span>            :         return NULL;
<span class="lineNum">    3196 </span>            :     }
<span class="lineNum">    3197 </span><span class="lineCov">       7284 :   if (dump_file &amp;&amp; (dump_flags &amp; TDF_DETAILS)</span>
<span class="lineNum">    3198 </span>            :       /* ???  Fix dumping, but currently we only get comparisons.  */
<span class="lineNum">    3199 </span><span class="lineCov">   46391560 :       &amp;&amp; TREE_CODE_CLASS (code) == tcc_comparison)</span>
<span class="lineNum">    3200 </span>            :     {
<span class="lineNum">    3201 </span><span class="lineCov">       1244 :       fprintf (dump_file, &quot;Recording on edge %d-&gt;%d &quot;, pred_e-&gt;src-&gt;index,</span>
<span class="lineNum">    3202 </span><span class="lineCov">        622 :                pred_e-&gt;dest-&gt;index);</span>
<span class="lineNum">    3203 </span><span class="lineCov">        622 :       print_generic_expr (dump_file, ops[0], TDF_SLIM);</span>
<span class="lineNum">    3204 </span><span class="lineCov">        622 :       fprintf (dump_file, &quot; %s &quot;, get_tree_code_name (code));</span>
<span class="lineNum">    3205 </span><span class="lineCov">        622 :       print_generic_expr (dump_file, ops[1], TDF_SLIM);</span>
<span class="lineNum">    3206 </span><span class="lineCov">        879 :       fprintf (dump_file, &quot; == %s\n&quot;,</span>
<span class="lineNum">    3207 </span><span class="lineCov">        622 :                integer_zerop (result) ? &quot;false&quot; : &quot;true&quot;);</span>
<span class="lineNum">    3208 </span>            :     }
<span class="lineNum">    3209 </span><span class="lineCov">   46390938 :   vn_nary_op_t vno1 = alloc_vn_nary_op (length, NULL_TREE, value_id);</span>
<span class="lineNum">    3210 </span><span class="lineCov">   92781876 :   init_vn_nary_op_from_pieces (vno1, length, code, type, ops);</span>
<span class="lineNum">    3211 </span><span class="lineCov">   46390938 :   vno1-&gt;predicated_values = 1;</span>
<span class="lineNum">    3212 </span><span class="lineCov">   46390938 :   vno1-&gt;u.values = (vn_pval *) obstack_alloc (&amp;vn_tables_obstack,</span>
<span class="lineNum">    3213 </span>            :                                               sizeof (vn_pval));
<span class="lineNum">    3214 </span><span class="lineCov">   46390938 :   vno1-&gt;u.values-&gt;next = NULL;</span>
<span class="lineNum">    3215 </span><span class="lineCov">   46390938 :   vno1-&gt;u.values-&gt;result = result;</span>
<span class="lineNum">    3216 </span><span class="lineCov">   46390938 :   vno1-&gt;u.values-&gt;n = 1;</span>
<span class="lineNum">    3217 </span><span class="lineCov">   46390938 :   vno1-&gt;u.values-&gt;valid_dominated_by_p[0] = pred_e-&gt;dest-&gt;index;</span>
<span class="lineNum">    3218 </span><span class="lineCov">   46390938 :   return vn_nary_op_insert_into (vno1, valid_info-&gt;nary, true);</span>
<span class="lineNum">    3219 </span>            : }
<span class="lineNum">    3220 </span>            : 
<span class="lineNum">    3221 </span>            : static bool
<span class="lineNum">    3222 </span>            : dominated_by_p_w_unex (basic_block bb1, basic_block bb2);
<a name="3223"><span class="lineNum">    3223 </span>            : </a>
<span class="lineNum">    3224 </span>            : static tree
<span class="lineNum">    3225 </span><span class="lineCov">     775366 : vn_nary_op_get_predicated_value (vn_nary_op_t vno, basic_block bb)</span>
<span class="lineNum">    3226 </span>            : {
<span class="lineNum">    3227 </span><span class="lineCov">     775366 :   if (! vno-&gt;predicated_values)</span>
<span class="lineNum">    3228 </span><span class="lineNoCov">          0 :     return vno-&gt;u.result;</span>
<span class="lineNum">    3229 </span><span class="lineCov">    1981195 :   for (vn_pval *val = vno-&gt;u.values; val; val = val-&gt;next)</span>
<span class="lineNum">    3230 </span><span class="lineCov">    3696979 :     for (unsigned i = 0; i &lt; val-&gt;n; ++i)</span>
<span class="lineNum">    3231 </span><span class="lineCov">    2491150 :       if (dominated_by_p_w_unex (bb,</span>
<span class="lineNum">    3232 </span><span class="lineCov">    2491150 :                           BASIC_BLOCK_FOR_FN</span>
<span class="lineNum">    3233 </span>            :                             (cfun, val-&gt;valid_dominated_by_p[i])))
<span class="lineNum">    3234 </span><span class="lineCov">     219302 :         return val-&gt;result;</span>
<span class="lineNum">    3235 </span>            :   return NULL_TREE;
<span class="lineNum">    3236 </span>            : }
<span class="lineNum">    3237 </span>            : 
<span class="lineNum">    3238 </span>            : /* Insert OP into the current hash table with a value number of
<span class="lineNum">    3239 </span>            :    RESULT.  Return the vn_nary_op_t structure we created and put in
<span class="lineNum">    3240 </span>            :    the hashtable.  */
<a name="3241"><span class="lineNum">    3241 </span>            : </a>
<span class="lineNum">    3242 </span>            : vn_nary_op_t
<span class="lineNum">    3243 </span><span class="lineNoCov">          0 : vn_nary_op_insert (tree op, tree result)</span>
<span class="lineNum">    3244 </span>            : {
<span class="lineNum">    3245 </span><span class="lineNoCov">          0 :   unsigned length = TREE_CODE_LENGTH (TREE_CODE (op));</span>
<span class="lineNum">    3246 </span><span class="lineNoCov">          0 :   vn_nary_op_t vno1;</span>
<span class="lineNum">    3247 </span>            : 
<span class="lineNum">    3248 </span><span class="lineNoCov">          0 :   vno1 = alloc_vn_nary_op (length, result, VN_INFO (result)-&gt;value_id);</span>
<span class="lineNum">    3249 </span><span class="lineNoCov">          0 :   init_vn_nary_op_from_op (vno1, op);</span>
<span class="lineNum">    3250 </span><span class="lineNoCov">          0 :   return vn_nary_op_insert_into (vno1, valid_info-&gt;nary, true);</span>
<span class="lineNum">    3251 </span>            : }
<span class="lineNum">    3252 </span>            : 
<span class="lineNum">    3253 </span>            : /* Insert the rhs of STMT into the current hash table with a value number of
<span class="lineNum">    3254 </span>            :    RESULT.  */
<a name="3255"><span class="lineNum">    3255 </span>            : </a>
<span class="lineNum">    3256 </span>            : static vn_nary_op_t
<span class="lineNum">    3257 </span><span class="lineCov">   19741393 : vn_nary_op_insert_stmt (gimple *stmt, tree result)</span>
<span class="lineNum">    3258 </span>            : {
<span class="lineNum">    3259 </span><span class="lineCov">   19741393 :   vn_nary_op_t vno1</span>
<span class="lineNum">    3260 </span><span class="lineCov">   19741393 :     = alloc_vn_nary_op (vn_nary_length_from_stmt (stmt),</span>
<span class="lineNum">    3261 </span><span class="lineCov">   19741393 :                         result, VN_INFO (result)-&gt;value_id);</span>
<span class="lineNum">    3262 </span><span class="lineCov">   19741393 :   init_vn_nary_op_from_stmt (vno1, stmt);</span>
<span class="lineNum">    3263 </span><span class="lineCov">   19741393 :   return vn_nary_op_insert_into (vno1, valid_info-&gt;nary, true);</span>
<span class="lineNum">    3264 </span>            : }
<span class="lineNum">    3265 </span>            : 
<span class="lineNum">    3266 </span>            : /* Compute a hashcode for PHI operation VP1 and return it.  */
<a name="3267"><span class="lineNum">    3267 </span>            : </a>
<span class="lineNum">    3268 </span>            : static inline hashval_t
<span class="lineNum">    3269 </span><span class="lineCov">   22032420 : vn_phi_compute_hash (vn_phi_t vp1)</span>
<span class="lineNum">    3270 </span>            : {
<span class="lineNum">    3271 </span><span class="lineCov">   22032420 :   inchash::hash hstate (EDGE_COUNT (vp1-&gt;block-&gt;preds) &gt; 2</span>
<span class="lineNum">    3272 </span><span class="lineCov">   41235633 :                         ? vp1-&gt;block-&gt;index : EDGE_COUNT (vp1-&gt;block-&gt;preds));</span>
<span class="lineNum">    3273 </span><span class="lineCov">   22032420 :   tree phi1op;</span>
<span class="lineNum">    3274 </span><span class="lineCov">   22032420 :   tree type;</span>
<span class="lineNum">    3275 </span><span class="lineCov">   22032420 :   edge e;</span>
<span class="lineNum">    3276 </span><span class="lineCov">   22032420 :   edge_iterator ei;</span>
<span class="lineNum">    3277 </span>            : 
<span class="lineNum">    3278 </span>            :   /* If all PHI arguments are constants we need to distinguish
<span class="lineNum">    3279 </span>            :      the PHI node via its type.  */
<span class="lineNum">    3280 </span><span class="lineCov">   22032420 :   type = vp1-&gt;type;</span>
<span class="lineNum">    3281 </span><span class="lineCov">   22032420 :   hstate.merge_hash (vn_hash_type (type));</span>
<span class="lineNum">    3282 </span>            : 
<span class="lineNum">    3283 </span><span class="lineCov">   97409508 :   FOR_EACH_EDGE (e, ei, vp1-&gt;block-&gt;preds)</span>
<span class="lineNum">    3284 </span>            :     {
<span class="lineNum">    3285 </span>            :       /* Don't hash backedge values they need to be handled as VN_TOP
<span class="lineNum">    3286 </span>            :          for optimistic value-numbering.  */
<span class="lineNum">    3287 </span><span class="lineCov">   53344668 :       if (e-&gt;flags &amp; EDGE_DFS_BACK)</span>
<span class="lineNum">    3288 </span>            :         continue;
<span class="lineNum">    3289 </span>            : 
<span class="lineNum">    3290 </span><span class="lineCov">   40438282 :       phi1op = vp1-&gt;phiargs[e-&gt;dest_idx];</span>
<span class="lineNum">    3291 </span><span class="lineCov">   40438282 :       if (phi1op == VN_TOP)</span>
<span class="lineNum">    3292 </span>            :         continue;
<span class="lineNum">    3293 </span><span class="lineCov">   40438282 :       inchash::add_expr (phi1op, hstate);</span>
<span class="lineNum">    3294 </span>            :     }
<span class="lineNum">    3295 </span>            : 
<span class="lineNum">    3296 </span><span class="lineCov">   44064840 :   return hstate.end ();</span>
<span class="lineNum">    3297 </span>            : }
<span class="lineNum">    3298 </span>            : 
<span class="lineNum">    3299 </span>            : 
<span class="lineNum">    3300 </span>            : /* Return true if COND1 and COND2 represent the same condition, set
<span class="lineNum">    3301 </span>            :    *INVERTED_P if one needs to be inverted to make it the same as
<span class="lineNum">    3302 </span>            :    the other.  */
<a name="3303"><span class="lineNum">    3303 </span>            : </a>
<span class="lineNum">    3304 </span>            : static bool
<span class="lineNum">    3305 </span><span class="lineCov">     762255 : cond_stmts_equal_p (gcond *cond1, tree lhs1, tree rhs1,</span>
<span class="lineNum">    3306 </span>            :                     gcond *cond2, tree lhs2, tree rhs2, bool *inverted_p)
<span class="lineNum">    3307 </span>            : {
<span class="lineNum">    3308 </span><span class="lineCov">     762255 :   enum tree_code code1 = gimple_cond_code (cond1);</span>
<span class="lineNum">    3309 </span><span class="lineCov">     762255 :   enum tree_code code2 = gimple_cond_code (cond2);</span>
<span class="lineNum">    3310 </span>            : 
<span class="lineNum">    3311 </span><span class="lineCov">     762255 :   *inverted_p = false;</span>
<span class="lineNum">    3312 </span><span class="lineCov">     762255 :   if (code1 == code2)</span>
<span class="lineNum">    3313 </span>            :     ;
<span class="lineNum">    3314 </span><span class="lineCov">     147776 :   else if (code1 == swap_tree_comparison (code2))</span>
<span class="lineNum">    3315 </span>            :     std::swap (lhs2, rhs2);
<span class="lineNum">    3316 </span><span class="lineCov">     131193 :   else if (code1 == invert_tree_comparison (code2, HONOR_NANS (lhs2)))</span>
<span class="lineNum">    3317 </span><span class="lineCov">      39331 :     *inverted_p = true;</span>
<span class="lineNum">    3318 </span><span class="lineCov">      91862 :   else if (code1 == invert_tree_comparison</span>
<span class="lineNum">    3319 </span><span class="lineCov">      91862 :                       (swap_tree_comparison (code2), HONOR_NANS (lhs2)))</span>
<span class="lineNum">    3320 </span>            :     {
<span class="lineNum">    3321 </span><span class="lineCov">       9644 :       std::swap (lhs2, rhs2);</span>
<span class="lineNum">    3322 </span><span class="lineCov">       9644 :       *inverted_p = true;</span>
<span class="lineNum">    3323 </span>            :     }
<span class="lineNum">    3324 </span>            :   else
<span class="lineNum">    3325 </span>            :     return false;
<span class="lineNum">    3326 </span>            : 
<span class="lineNum">    3327 </span><span class="lineCov">     680037 :   return ((expressions_equal_p (lhs1, lhs2)</span>
<span class="lineNum">    3328 </span><span class="lineCov">      46024 :            &amp;&amp; expressions_equal_p (rhs1, rhs2))</span>
<span class="lineNum">    3329 </span><span class="lineCov">     707474 :           || (commutative_tree_code (code1)</span>
<span class="lineNum">    3330 </span><span class="lineCov">     282461 :               &amp;&amp; expressions_equal_p (lhs1, rhs2)</span>
<span class="lineNum">    3331 </span><span class="lineCov">       1273 :               &amp;&amp; expressions_equal_p (rhs1, lhs2)));</span>
<span class="lineNum">    3332 </span>            : }
<span class="lineNum">    3333 </span>            : 
<span class="lineNum">    3334 </span>            : /* Compare two phi entries for equality, ignoring VN_TOP arguments.  */
<a name="3335"><span class="lineNum">    3335 </span>            : </a>
<span class="lineNum">    3336 </span>            : static int
<span class="lineNum">    3337 </span><span class="lineCov">   59224972 : vn_phi_eq (const_vn_phi_t const vp1, const_vn_phi_t const vp2)</span>
<span class="lineNum">    3338 </span>            : {
<span class="lineNum">    3339 </span><span class="lineCov">   59224972 :   if (vp1-&gt;hashcode != vp2-&gt;hashcode)</span>
<span class="lineNum">    3340 </span>            :     return false;
<span class="lineNum">    3341 </span>            : 
<span class="lineNum">    3342 </span><span class="lineCov">   56540549 :   if (vp1-&gt;block != vp2-&gt;block)</span>
<span class="lineNum">    3343 </span>            :     {
<span class="lineNum">    3344 </span><span class="lineCov">  155774727 :       if (EDGE_COUNT (vp1-&gt;block-&gt;preds) != EDGE_COUNT (vp2-&gt;block-&gt;preds))</span>
<span class="lineNum">    3345 </span>            :         return false;
<span class="lineNum">    3346 </span>            : 
<span class="lineNum">    3347 </span><span class="lineCov">   51924787 :       switch (EDGE_COUNT (vp1-&gt;block-&gt;preds))</span>
<span class="lineNum">    3348 </span>            :         {
<span class="lineNum">    3349 </span>            :         case 1:
<span class="lineNum">    3350 </span>            :           /* Single-arg PHIs are just copies.  */
<span class="lineNum">    3351 </span>            :           break;
<span class="lineNum">    3352 </span>            : 
<span class="lineNum">    3353 </span><span class="lineCov">   51924787 :         case 2:</span>
<span class="lineNum">    3354 </span><span class="lineCov">   51924787 :           {</span>
<span class="lineNum">    3355 </span>            :             /* Rule out backedges into the PHI.  */
<span class="lineNum">    3356 </span><span class="lineCov">   51924787 :             if (vp1-&gt;block-&gt;loop_father-&gt;header == vp1-&gt;block</span>
<span class="lineNum">    3357 </span><span class="lineCov">     771459 :                 || vp2-&gt;block-&gt;loop_father-&gt;header == vp2-&gt;block)</span>
<span class="lineNum">    3358 </span>            :               return false;
<span class="lineNum">    3359 </span>            : 
<span class="lineNum">    3360 </span>            :             /* If the PHI nodes do not have compatible types
<span class="lineNum">    3361 </span>            :                they are not the same.  */
<span class="lineNum">    3362 </span><span class="lineCov">     766863 :             if (!types_compatible_p (vp1-&gt;type, vp2-&gt;type))</span>
<span class="lineNum">    3363 </span>            :               return false;
<span class="lineNum">    3364 </span>            : 
<span class="lineNum">    3365 </span><span class="lineCov">     765074 :             basic_block idom1</span>
<span class="lineNum">    3366 </span><span class="lineCov">     765074 :               = get_immediate_dominator (CDI_DOMINATORS, vp1-&gt;block);</span>
<span class="lineNum">    3367 </span><span class="lineCov">     765074 :             basic_block idom2</span>
<span class="lineNum">    3368 </span><span class="lineCov">     765074 :               = get_immediate_dominator (CDI_DOMINATORS, vp2-&gt;block);</span>
<span class="lineNum">    3369 </span>            :             /* If the immediate dominator end in switch stmts multiple
<span class="lineNum">    3370 </span>            :                values may end up in the same PHI arg via intermediate
<span class="lineNum">    3371 </span>            :                CFG merges.  */
<span class="lineNum">    3372 </span><span class="lineCov">     765074 :             if (EDGE_COUNT (idom1-&gt;succs) != 2</span>
<span class="lineNum">    3373 </span><span class="lineCov">     765074 :                 || EDGE_COUNT (idom2-&gt;succs) != 2)</span>
<span class="lineNum">    3374 </span>            :               return false;
<span class="lineNum">    3375 </span>            : 
<span class="lineNum">    3376 </span>            :             /* Verify the controlling stmt is the same.  */
<span class="lineNum">    3377 </span><span class="lineCov">     763809 :             gcond *last1 = safe_dyn_cast &lt;gcond *&gt; (last_stmt (idom1));</span>
<span class="lineNum">    3378 </span><span class="lineCov">     763809 :             gcond *last2 = safe_dyn_cast &lt;gcond *&gt; (last_stmt (idom2));</span>
<span class="lineNum">    3379 </span><span class="lineCov">     763809 :             if (! last1 || ! last2)</span>
<span class="lineNum">    3380 </span>            :               return false;
<span class="lineNum">    3381 </span><span class="lineCov">     762255 :             bool inverted_p;</span>
<span class="lineNum">    3382 </span><span class="lineCov">     762255 :             if (! cond_stmts_equal_p (last1, vp1-&gt;cclhs, vp1-&gt;ccrhs,</span>
<span class="lineNum">    3383 </span><span class="lineCov">     762255 :                                       last2, vp2-&gt;cclhs, vp2-&gt;ccrhs,</span>
<span class="lineNum">    3384 </span>            :                                       &amp;inverted_p))
<span class="lineNum">    3385 </span>            :               return false;
<span class="lineNum">    3386 </span>            : 
<span class="lineNum">    3387 </span>            :             /* Get at true/false controlled edges into the PHI.  */
<span class="lineNum">    3388 </span><span class="lineCov">      18814 :             edge te1, te2, fe1, fe2;</span>
<span class="lineNum">    3389 </span><span class="lineCov">      18814 :             if (! extract_true_false_controlled_edges (idom1, vp1-&gt;block,</span>
<span class="lineNum">    3390 </span>            :                                                        &amp;te1, &amp;fe1)
<span class="lineNum">    3391 </span><span class="lineCov">      18814 :                 || ! extract_true_false_controlled_edges (idom2, vp2-&gt;block,</span>
<span class="lineNum">    3392 </span>            :                                                           &amp;te2, &amp;fe2))
<span class="lineNum">    3393 </span><span class="lineCov">       6154 :               return false;</span>
<span class="lineNum">    3394 </span>            : 
<span class="lineNum">    3395 </span>            :             /* Swap edges if the second condition is the inverted of the
<span class="lineNum">    3396 </span>            :                first.  */
<span class="lineNum">    3397 </span><span class="lineCov">      12660 :             if (inverted_p)</span>
<span class="lineNum">    3398 </span><span class="lineCov">       1066 :               std::swap (te2, fe2);</span>
<span class="lineNum">    3399 </span>            : 
<span class="lineNum">    3400 </span>            :             /* ???  Handle VN_TOP specially.  */
<span class="lineNum">    3401 </span><span class="lineCov">      25320 :             if (! expressions_equal_p (vp1-&gt;phiargs[te1-&gt;dest_idx],</span>
<span class="lineNum">    3402 </span><span class="lineCov">      12660 :                                        vp2-&gt;phiargs[te2-&gt;dest_idx])</span>
<span class="lineNum">    3403 </span><span class="lineCov">      24213 :                 || ! expressions_equal_p (vp1-&gt;phiargs[fe1-&gt;dest_idx],</span>
<span class="lineNum">    3404 </span><span class="lineCov">      11553 :                                           vp2-&gt;phiargs[fe2-&gt;dest_idx]))</span>
<span class="lineNum">    3405 </span><span class="lineCov">       1107 :               return false;</span>
<span class="lineNum">    3406 </span>            : 
<span class="lineNum">    3407 </span>            :             return true;
<span class="lineNum">    3408 </span>            :           }
<span class="lineNum">    3409 </span>            : 
<span class="lineNum">    3410 </span>            :         default:
<span class="lineNum">    3411 </span>            :           return false;
<span class="lineNum">    3412 </span>            :         }
<span class="lineNum">    3413 </span>            :     }
<span class="lineNum">    3414 </span>            : 
<span class="lineNum">    3415 </span>            :   /* If the PHI nodes do not have compatible types
<span class="lineNum">    3416 </span>            :      they are not the same.  */
<span class="lineNum">    3417 </span><span class="lineCov">    4615640 :   if (!types_compatible_p (vp1-&gt;type, vp2-&gt;type))</span>
<span class="lineNum">    3418 </span>            :     return false;
<span class="lineNum">    3419 </span>            : 
<span class="lineNum">    3420 </span>            :   /* Any phi in the same block will have it's arguments in the
<span class="lineNum">    3421 </span>            :      same edge order, because of how we store phi nodes.  */
<span class="lineNum">    3422 </span><span class="lineCov">   23193116 :   for (unsigned i = 0; i &lt; EDGE_COUNT (vp1-&gt;block-&gt;preds); ++i)</span>
<span class="lineNum">    3423 </span>            :     {
<span class="lineNum">    3424 </span><span class="lineCov">    9251661 :       tree phi1op = vp1-&gt;phiargs[i];</span>
<span class="lineNum">    3425 </span><span class="lineCov">    9251661 :       tree phi2op = vp2-&gt;phiargs[i];</span>
<span class="lineNum">    3426 </span><span class="lineCov">    9251661 :       if (phi1op == VN_TOP || phi2op == VN_TOP)</span>
<span class="lineNum">    3427 </span>            :         continue;
<span class="lineNum">    3428 </span><span class="lineCov">    9251661 :       if (!expressions_equal_p (phi1op, phi2op))</span>
<span class="lineNum">    3429 </span>            :         return false;
<span class="lineNum">    3430 </span>            :     }
<span class="lineNum">    3431 </span>            : 
<span class="lineNum">    3432 </span>            :   return true;
<span class="lineNum">    3433 </span>            : }
<span class="lineNum">    3434 </span>            : 
<span class="lineNum">    3435 </span>            : /* Lookup PHI in the current hash table, and return the resulting
<span class="lineNum">    3436 </span>            :    value number if it exists in the hash table.  Return NULL_TREE if
<span class="lineNum">    3437 </span>            :    it does not exist in the hash table. */
<a name="3438"><span class="lineNum">    3438 </span>            : </a>
<span class="lineNum">    3439 </span>            : static tree
<span class="lineNum">    3440 </span><span class="lineCov">   12382991 : vn_phi_lookup (gimple *phi, bool backedges_varying_p)</span>
<span class="lineNum">    3441 </span>            : {
<span class="lineNum">    3442 </span><span class="lineCov">   12382991 :   vn_phi_s **slot;</span>
<span class="lineNum">    3443 </span><span class="lineCov">   12382991 :   struct vn_phi_s *vp1;</span>
<span class="lineNum">    3444 </span><span class="lineCov">   12382991 :   edge e;</span>
<span class="lineNum">    3445 </span><span class="lineCov">   12382991 :   edge_iterator ei;</span>
<span class="lineNum">    3446 </span>            : 
<span class="lineNum">    3447 </span><span class="lineCov">   12382991 :   vp1 = XALLOCAVAR (struct vn_phi_s,</span>
<span class="lineNum">    3448 </span>            :                     sizeof (struct vn_phi_s)
<span class="lineNum">    3449 </span>            :                     + (gimple_phi_num_args (phi) - 1) * sizeof (tree));
<span class="lineNum">    3450 </span>            : 
<span class="lineNum">    3451 </span>            :   /* Canonicalize the SSA_NAME's to their value number.  */
<span class="lineNum">    3452 </span><span class="lineCov">   66787580 :   FOR_EACH_EDGE (e, ei, gimple_bb (phi)-&gt;preds)</span>
<span class="lineNum">    3453 </span>            :     {
<span class="lineNum">    3454 </span><span class="lineCov">   29638607 :       tree def = PHI_ARG_DEF_FROM_EDGE (phi, e);</span>
<span class="lineNum">    3455 </span><span class="lineCov">   29638607 :       if (TREE_CODE (def) == SSA_NAME</span>
<span class="lineNum">    3456 </span><span class="lineCov">   25302614 :           &amp;&amp; (!backedges_varying_p || !(e-&gt;flags &amp; EDGE_DFS_BACK)))</span>
<span class="lineNum">    3457 </span><span class="lineCov">   25103283 :         def = SSA_VAL (def);</span>
<span class="lineNum">    3458 </span><span class="lineCov">   29638607 :       vp1-&gt;phiargs[e-&gt;dest_idx] = def;</span>
<span class="lineNum">    3459 </span>            :     }
<span class="lineNum">    3460 </span><span class="lineCov">   12382991 :   vp1-&gt;type = TREE_TYPE (gimple_phi_result (phi));</span>
<span class="lineNum">    3461 </span><span class="lineCov">   12382991 :   vp1-&gt;block = gimple_bb (phi);</span>
<span class="lineNum">    3462 </span>            :   /* Extract values of the controlling condition.  */
<span class="lineNum">    3463 </span><span class="lineCov">   12382991 :   vp1-&gt;cclhs = NULL_TREE;</span>
<span class="lineNum">    3464 </span><span class="lineCov">   12382991 :   vp1-&gt;ccrhs = NULL_TREE;</span>
<span class="lineNum">    3465 </span><span class="lineCov">   12382991 :   basic_block idom1 = get_immediate_dominator (CDI_DOMINATORS, vp1-&gt;block);</span>
<span class="lineNum">    3466 </span><span class="lineCov">   12382991 :   if (EDGE_COUNT (idom1-&gt;succs) == 2)</span>
<span class="lineNum">    3467 </span><span class="lineCov">    5669398 :     if (gcond *last1 = safe_dyn_cast &lt;gcond *&gt; (last_stmt (idom1)))</span>
<span class="lineNum">    3468 </span>            :       {
<span class="lineNum">    3469 </span>            :         /* ???  We want to use SSA_VAL here.  But possibly not
<span class="lineNum">    3470 </span>            :            allow VN_TOP.  */
<span class="lineNum">    3471 </span><span class="lineCov">   10749534 :         vp1-&gt;cclhs = vn_valueize (gimple_cond_lhs (last1));</span>
<span class="lineNum">    3472 </span><span class="lineCov">   10749534 :         vp1-&gt;ccrhs = vn_valueize (gimple_cond_rhs (last1));</span>
<span class="lineNum">    3473 </span>            :       }
<span class="lineNum">    3474 </span><span class="lineCov">   12382991 :   vp1-&gt;hashcode = vn_phi_compute_hash (vp1);</span>
<span class="lineNum">    3475 </span><span class="lineCov">   12382991 :   slot = valid_info-&gt;phis-&gt;find_slot_with_hash (vp1, vp1-&gt;hashcode, NO_INSERT);</span>
<span class="lineNum">    3476 </span><span class="lineCov">   12382991 :   if (!slot)</span>
<span class="lineNum">    3477 </span>            :     return NULL_TREE;
<span class="lineNum">    3478 </span><span class="lineCov">    2356450 :   return (*slot)-&gt;result;</span>
<span class="lineNum">    3479 </span>            : }
<span class="lineNum">    3480 </span>            : 
<span class="lineNum">    3481 </span>            : /* Insert PHI into the current hash table with a value number of
<span class="lineNum">    3482 </span>            :    RESULT.  */
<a name="3483"><span class="lineNum">    3483 </span>            : </a>
<span class="lineNum">    3484 </span>            : static vn_phi_t
<span class="lineNum">    3485 </span><span class="lineCov">    9649429 : vn_phi_insert (gimple *phi, tree result, bool backedges_varying_p)</span>
<span class="lineNum">    3486 </span>            : {
<span class="lineNum">    3487 </span><span class="lineCov">    9649429 :   vn_phi_s **slot;</span>
<span class="lineNum">    3488 </span><span class="lineCov">    9649429 :   vn_phi_t vp1 = (vn_phi_t) obstack_alloc (&amp;vn_tables_obstack,</span>
<span class="lineNum">    3489 </span>            :                                            sizeof (vn_phi_s)
<span class="lineNum">    3490 </span>            :                                            + ((gimple_phi_num_args (phi) - 1)
<span class="lineNum">    3491 </span>            :                                               * sizeof (tree)));
<span class="lineNum">    3492 </span><span class="lineCov">    9649429 :   edge e;</span>
<span class="lineNum">    3493 </span><span class="lineCov">    9649429 :   edge_iterator ei;</span>
<span class="lineNum">    3494 </span>            : 
<span class="lineNum">    3495 </span>            :   /* Canonicalize the SSA_NAME's to their value number.  */
<span class="lineNum">    3496 </span><span class="lineCov">   52654348 :   FOR_EACH_EDGE (e, ei, gimple_bb (phi)-&gt;preds)</span>
<span class="lineNum">    3497 </span>            :     {
<span class="lineNum">    3498 </span><span class="lineCov">   23706061 :       tree def = PHI_ARG_DEF_FROM_EDGE (phi, e);</span>
<span class="lineNum">    3499 </span><span class="lineCov">   23706061 :       if (TREE_CODE (def) == SSA_NAME</span>
<span class="lineNum">    3500 </span><span class="lineCov">   19854686 :           &amp;&amp; (!backedges_varying_p || !(e-&gt;flags &amp; EDGE_DFS_BACK)))</span>
<span class="lineNum">    3501 </span><span class="lineCov">   19655392 :         def = SSA_VAL (def);</span>
<span class="lineNum">    3502 </span><span class="lineCov">   23706061 :       vp1-&gt;phiargs[e-&gt;dest_idx] = def;</span>
<span class="lineNum">    3503 </span>            :     }
<span class="lineNum">    3504 </span><span class="lineCov">    9649429 :   vp1-&gt;value_id = VN_INFO (result)-&gt;value_id;</span>
<span class="lineNum">    3505 </span><span class="lineCov">    9649429 :   vp1-&gt;type = TREE_TYPE (gimple_phi_result (phi));</span>
<span class="lineNum">    3506 </span><span class="lineCov">    9649429 :   vp1-&gt;block = gimple_bb (phi);</span>
<span class="lineNum">    3507 </span>            :   /* Extract values of the controlling condition.  */
<span class="lineNum">    3508 </span><span class="lineCov">    9649429 :   vp1-&gt;cclhs = NULL_TREE;</span>
<span class="lineNum">    3509 </span><span class="lineCov">    9649429 :   vp1-&gt;ccrhs = NULL_TREE;</span>
<span class="lineNum">    3510 </span><span class="lineCov">    9649429 :   basic_block idom1 = get_immediate_dominator (CDI_DOMINATORS, vp1-&gt;block);</span>
<span class="lineNum">    3511 </span><span class="lineCov">    9649429 :   if (EDGE_COUNT (idom1-&gt;succs) == 2)</span>
<span class="lineNum">    3512 </span><span class="lineCov">    5224347 :     if (gcond *last1 = safe_dyn_cast &lt;gcond *&gt; (last_stmt (idom1)))</span>
<span class="lineNum">    3513 </span>            :       {
<span class="lineNum">    3514 </span>            :         /* ???  We want to use SSA_VAL here.  But possibly not
<span class="lineNum">    3515 </span>            :            allow VN_TOP.  */
<span class="lineNum">    3516 </span><span class="lineCov">    9899304 :         vp1-&gt;cclhs = vn_valueize (gimple_cond_lhs (last1));</span>
<span class="lineNum">    3517 </span><span class="lineCov">    9899304 :         vp1-&gt;ccrhs = vn_valueize (gimple_cond_rhs (last1));</span>
<span class="lineNum">    3518 </span>            :       }
<span class="lineNum">    3519 </span><span class="lineCov">    9649429 :   vp1-&gt;result = result;</span>
<span class="lineNum">    3520 </span><span class="lineCov">    9649429 :   vp1-&gt;hashcode = vn_phi_compute_hash (vp1);</span>
<span class="lineNum">    3521 </span>            : 
<span class="lineNum">    3522 </span><span class="lineCov">    9649429 :   slot = valid_info-&gt;phis-&gt;find_slot_with_hash (vp1, vp1-&gt;hashcode, INSERT);</span>
<span class="lineNum">    3523 </span><span class="lineCov">    9649429 :   gcc_assert (!*slot);</span>
<span class="lineNum">    3524 </span>            : 
<span class="lineNum">    3525 </span><span class="lineCov">    9649429 :   *slot = vp1;</span>
<span class="lineNum">    3526 </span><span class="lineCov">    9649429 :   vp1-&gt;next = last_inserted_phi;</span>
<span class="lineNum">    3527 </span><span class="lineCov">    9649429 :   last_inserted_phi = vp1;</span>
<span class="lineNum">    3528 </span><span class="lineCov">    9649429 :   return vp1;</span>
<span class="lineNum">    3529 </span>            : }
<span class="lineNum">    3530 </span>            : 
<span class="lineNum">    3531 </span>            : 
<span class="lineNum">    3532 </span>            : /* Return true if BB1 is dominated by BB2 taking into account edges
<span class="lineNum">    3533 </span>            :    that are not executable.  */
<a name="3534"><span class="lineNum">    3534 </span>            : </a>
<span class="lineNum">    3535 </span>            : static bool
<span class="lineNum">    3536 </span><span class="lineCov">   23640587 : dominated_by_p_w_unex (basic_block bb1, basic_block bb2)</span>
<span class="lineNum">    3537 </span>            : {
<span class="lineNum">    3538 </span><span class="lineCov">   23640587 :   edge_iterator ei;</span>
<span class="lineNum">    3539 </span><span class="lineCov">   23640587 :   edge e;</span>
<span class="lineNum">    3540 </span>            : 
<span class="lineNum">    3541 </span><span class="lineCov">   23640587 :   if (dominated_by_p (CDI_DOMINATORS, bb1, bb2))</span>
<span class="lineNum">    3542 </span>            :     return true;
<span class="lineNum">    3543 </span>            : 
<span class="lineNum">    3544 </span>            :   /* Before iterating we'd like to know if there exists a
<span class="lineNum">    3545 </span>            :      (executable) path from bb2 to bb1 at all, if not we can
<span class="lineNum">    3546 </span>            :      directly return false.  For now simply iterate once.  */
<span class="lineNum">    3547 </span>            : 
<span class="lineNum">    3548 </span>            :   /* Iterate to the single executable bb1 predecessor.  */
<span class="lineNum">    3549 </span><span class="lineCov">    6387088 :   if (EDGE_COUNT (bb1-&gt;preds) &gt; 1)</span>
<span class="lineNum">    3550 </span>            :     {
<span class="lineNum">    3551 </span><span class="lineCov">    1675120 :       edge prede = NULL;</span>
<span class="lineNum">    3552 </span><span class="lineCov">    5273622 :       FOR_EACH_EDGE (e, ei, bb1-&gt;preds)</span>
<span class="lineNum">    3553 </span><span class="lineCov">    3399977 :         if (e-&gt;flags &amp; EDGE_EXECUTABLE)</span>
<span class="lineNum">    3554 </span>            :           {
<span class="lineNum">    3555 </span><span class="lineCov">    3151715 :             if (prede)</span>
<span class="lineNum">    3556 </span>            :               {
<span class="lineNum">    3557 </span>            :                 prede = NULL;
<span class="lineNum">    3558 </span>            :                 break;
<span class="lineNum">    3559 </span>            :               }
<span class="lineNum">    3560 </span>            :             prede = e;
<span class="lineNum">    3561 </span>            :           }
<span class="lineNum">    3562 </span><span class="lineCov">    1675120 :       if (prede)</span>
<span class="lineNum">    3563 </span>            :         {
<span class="lineNum">    3564 </span><span class="lineCov">     198525 :           bb1 = prede-&gt;src;</span>
<span class="lineNum">    3565 </span>            : 
<span class="lineNum">    3566 </span>            :           /* Re-do the dominance check with changed bb1.  */
<span class="lineNum">    3567 </span><span class="lineCov">     198525 :           if (dominated_by_p (CDI_DOMINATORS, bb1, bb2))</span>
<span class="lineNum">    3568 </span>            :             return true;
<span class="lineNum">    3569 </span>            :         }
<span class="lineNum">    3570 </span>            :     }
<span class="lineNum">    3571 </span>            : 
<span class="lineNum">    3572 </span>            :   /* Iterate to the single executable bb2 successor.  */
<span class="lineNum">    3573 </span><span class="lineCov">    6291998 :   edge succe = NULL;</span>
<span class="lineNum">    3574 </span><span class="lineCov">   19115763 :   FOR_EACH_EDGE (e, ei, bb2-&gt;succs)</span>
<span class="lineNum">    3575 </span><span class="lineCov">    8893717 :     if (e-&gt;flags &amp; EDGE_EXECUTABLE)</span>
<span class="lineNum">    3576 </span>            :       {
<span class="lineNum">    3577 </span><span class="lineCov">    8472736 :         if (succe)</span>
<span class="lineNum">    3578 </span>            :           {
<span class="lineNum">    3579 </span>            :             succe = NULL;
<span class="lineNum">    3580 </span>            :             break;
<span class="lineNum">    3581 </span>            :           }
<span class="lineNum">    3582 </span>            :         succe = e;
<span class="lineNum">    3583 </span>            :       }
<span class="lineNum">    3584 </span><span class="lineCov">    6291998 :   if (succe)</span>
<span class="lineNum">    3585 </span>            :     {
<span class="lineNum">    3586 </span>            :       /* Verify the reached block is only reached through succe.
<span class="lineNum">    3587 </span>            :          If there is only one edge we can spare us the dominator
<span class="lineNum">    3588 </span>            :          check and iterate directly.  */
<span class="lineNum">    3589 </span><span class="lineCov">    3748836 :       if (EDGE_COUNT (succe-&gt;dest-&gt;preds) &gt; 1)</span>
<span class="lineNum">    3590 </span>            :         {
<span class="lineNum">    3591 </span><span class="lineCov">   11336489 :           FOR_EACH_EDGE (e, ei, succe-&gt;dest-&gt;preds)</span>
<span class="lineNum">    3592 </span><span class="lineCov">    7207820 :             if (e != succe</span>
<span class="lineNum">    3593 </span><span class="lineCov">    5215995 :                 &amp;&amp; (e-&gt;flags &amp; EDGE_EXECUTABLE))</span>
<span class="lineNum">    3594 </span>            :               {
<span class="lineNum">    3595 </span>            :                 succe = NULL;
<span class="lineNum">    3596 </span>            :                 break;
<span class="lineNum">    3597 </span>            :               }
<span class="lineNum">    3598 </span>            :         }
<span class="lineNum">    3599 </span><span class="lineCov">    3748836 :       if (succe)</span>
<span class="lineNum">    3600 </span>            :         {
<span class="lineNum">    3601 </span><span class="lineCov">     536131 :           bb2 = succe-&gt;dest;</span>
<span class="lineNum">    3602 </span>            : 
<span class="lineNum">    3603 </span>            :           /* Re-do the dominance check with changed bb2.  */
<span class="lineNum">    3604 </span><span class="lineCov">     536131 :           if (dominated_by_p (CDI_DOMINATORS, bb1, bb2))</span>
<span class="lineNum">    3605 </span><span class="lineCov">      87851 :             return true;</span>
<span class="lineNum">    3606 </span>            :         }
<span class="lineNum">    3607 </span>            :     }
<span class="lineNum">    3608 </span>            : 
<span class="lineNum">    3609 </span>            :   /* We could now iterate updating bb1 / bb2.  */
<span class="lineNum">    3610 </span>            :   return false;
<span class="lineNum">    3611 </span>            : }
<span class="lineNum">    3612 </span>            : 
<span class="lineNum">    3613 </span>            : /* Set the value number of FROM to TO, return true if it has changed
<span class="lineNum">    3614 </span>            :    as a result.  */
<a name="3615"><span class="lineNum">    3615 </span>            : </a>
<span class="lineNum">    3616 </span>            : static inline bool
<span class="lineNum">    3617 </span><span class="lineCov">   95708206 : set_ssa_val_to (tree from, tree to)</span>
<span class="lineNum">    3618 </span>            : {
<span class="lineNum">    3619 </span><span class="lineCov">   95708206 :   vn_ssa_aux_t from_info = VN_INFO (from);</span>
<span class="lineNum">    3620 </span><span class="lineCov">   95708206 :   tree currval = from_info-&gt;valnum; // SSA_VAL (from)</span>
<span class="lineNum">    3621 </span><span class="lineCov">  191416412 :   poly_int64 toff, coff;</span>
<span class="lineNum">    3622 </span>            : 
<span class="lineNum">    3623 </span>            :   /* The only thing we allow as value numbers are ssa_names
<span class="lineNum">    3624 </span>            :      and invariants.  So assert that here.  We don't allow VN_TOP
<span class="lineNum">    3625 </span>            :      as visiting a stmt should produce a value-number other than
<span class="lineNum">    3626 </span>            :      that.
<span class="lineNum">    3627 </span>            :      ???  Still VN_TOP can happen for unreachable code, so force
<span class="lineNum">    3628 </span>            :      it to varying in that case.  Not all code is prepared to
<span class="lineNum">    3629 </span>            :      get VN_TOP on valueization.  */
<span class="lineNum">    3630 </span><span class="lineCov">   95708206 :   if (to == VN_TOP)</span>
<span class="lineNum">    3631 </span>            :     {
<span class="lineNum">    3632 </span>            :       /* ???  When iterating and visiting PHI &lt;undef, backedge-value&gt;
<span class="lineNum">    3633 </span>            :          for the first time we rightfully get VN_TOP and we need to
<span class="lineNum">    3634 </span>            :          preserve that to optimize for example gcc.dg/tree-ssa/ssa-sccvn-2.c.
<span class="lineNum">    3635 </span>            :          With SCCVN we were simply lucky we iterated the other PHI
<span class="lineNum">    3636 </span>            :          cycles first and thus visited the backedge-value DEF.  */
<span class="lineNum">    3637 </span><span class="lineNoCov">          0 :       if (currval == VN_TOP)</span>
<span class="lineNum">    3638 </span>            :         goto set_and_exit;
<span class="lineNum">    3639 </span><span class="lineNoCov">          0 :       if (dump_file &amp;&amp; (dump_flags &amp; TDF_DETAILS))</span>
<span class="lineNum">    3640 </span><span class="lineNoCov">          0 :         fprintf (dump_file, &quot;Forcing value number to varying on &quot;</span>
<span class="lineNum">    3641 </span>            :                  &quot;receiving VN_TOP\n&quot;);
<span class="lineNum">    3642 </span>            :       to = from;
<span class="lineNum">    3643 </span>            :     }
<span class="lineNum">    3644 </span>            : 
<span class="lineNum">    3645 </span><span class="lineCov">   95708206 :   gcc_checking_assert (to != NULL_TREE</span>
<span class="lineNum">    3646 </span>            :                        &amp;&amp; ((TREE_CODE (to) == SSA_NAME
<span class="lineNum">    3647 </span>            :                             &amp;&amp; (to == from || SSA_VAL (to) == to))
<span class="lineNum">    3648 </span>            :                            || is_gimple_min_invariant (to)));
<span class="lineNum">    3649 </span>            : 
<span class="lineNum">    3650 </span><span class="lineCov">   95708206 :   if (from != to)</span>
<span class="lineNum">    3651 </span>            :     {
<span class="lineNum">    3652 </span><span class="lineCov">   16946104 :       if (currval == from)</span>
<span class="lineNum">    3653 </span>            :         {
<span class="lineNum">    3654 </span><span class="lineCov">       6240 :           if (dump_file &amp;&amp; (dump_flags &amp; TDF_DETAILS))</span>
<span class="lineNum">    3655 </span>            :             {
<span class="lineNum">    3656 </span><span class="lineNoCov">          0 :               fprintf (dump_file, &quot;Not changing value number of &quot;);</span>
<span class="lineNum">    3657 </span><span class="lineNoCov">          0 :               print_generic_expr (dump_file, from);</span>
<span class="lineNum">    3658 </span><span class="lineNoCov">          0 :               fprintf (dump_file, &quot; from VARYING to &quot;);</span>
<span class="lineNum">    3659 </span><span class="lineNoCov">          0 :               print_generic_expr (dump_file, to);</span>
<span class="lineNum">    3660 </span><span class="lineNoCov">          0 :               fprintf (dump_file, &quot;\n&quot;);</span>
<span class="lineNum">    3661 </span>            :             }
<span class="lineNum">    3662 </span><span class="lineCov">       6240 :           return false;</span>
<span class="lineNum">    3663 </span>            :         }
<span class="lineNum">    3664 </span><span class="lineCov">   16939864 :       else if (currval != VN_TOP</span>
<span class="lineNum">    3665 </span><span class="lineCov">    3861232 :                &amp;&amp; ! is_gimple_min_invariant (currval)</span>
<span class="lineNum">    3666 </span><span class="lineCov">    2995323 :                &amp;&amp; ! ssa_undefined_value_p (currval, false)</span>
<span class="lineNum">    3667 </span><span class="lineCov">   19874223 :                &amp;&amp; is_gimple_min_invariant (to))</span>
<span class="lineNum">    3668 </span>            :         {
<span class="lineNum">    3669 </span><span class="lineCov">          6 :           if (dump_file &amp;&amp; (dump_flags &amp; TDF_DETAILS))</span>
<span class="lineNum">    3670 </span>            :             {
<span class="lineNum">    3671 </span><span class="lineNoCov">          0 :               fprintf (dump_file, &quot;Forcing VARYING instead of changing &quot;</span>
<span class="lineNum">    3672 </span>            :                        &quot;value number of &quot;);
<span class="lineNum">    3673 </span><span class="lineNoCov">          0 :               print_generic_expr (dump_file, from);</span>
<span class="lineNum">    3674 </span><span class="lineNoCov">          0 :               fprintf (dump_file, &quot; from &quot;);</span>
<span class="lineNum">    3675 </span><span class="lineNoCov">          0 :               print_generic_expr (dump_file, currval);</span>
<span class="lineNum">    3676 </span><span class="lineNoCov">          0 :               fprintf (dump_file, &quot; (non-constant) to &quot;);</span>
<span class="lineNum">    3677 </span><span class="lineNoCov">          0 :               print_generic_expr (dump_file, to);</span>
<span class="lineNum">    3678 </span><span class="lineNoCov">          0 :               fprintf (dump_file, &quot; (constant)\n&quot;);</span>
<span class="lineNum">    3679 </span>            :             }
<span class="lineNum">    3680 </span>            :           to = from;
<span class="lineNum">    3681 </span>            :         }
<span class="lineNum">    3682 </span><span class="lineCov">   16939858 :       else if (TREE_CODE (to) == SSA_NAME</span>
<span class="lineNum">    3683 </span><span class="lineCov">   16939858 :                &amp;&amp; SSA_NAME_OCCURS_IN_ABNORMAL_PHI (to))</span>
<span class="lineNum">    3684 </span>            :         to = from;
<span class="lineNum">    3685 </span>            :     }
<span class="lineNum">    3686 </span>            : 
<span class="lineNum">    3687 </span><span class="lineCov">   78762102 : set_and_exit:</span>
<span class="lineNum">    3688 </span><span class="lineCov">   95701966 :   if (dump_file &amp;&amp; (dump_flags &amp; TDF_DETAILS))</span>
<span class="lineNum">    3689 </span>            :     {
<span class="lineNum">    3690 </span><span class="lineCov">       1741 :       fprintf (dump_file, &quot;Setting value number of &quot;);</span>
<span class="lineNum">    3691 </span><span class="lineCov">       1741 :       print_generic_expr (dump_file, from);</span>
<span class="lineNum">    3692 </span><span class="lineCov">       1741 :       fprintf (dump_file, &quot; to &quot;);</span>
<span class="lineNum">    3693 </span><span class="lineCov">       1741 :       print_generic_expr (dump_file, to);</span>
<span class="lineNum">    3694 </span>            :     }
<span class="lineNum">    3695 </span>            : 
<span class="lineNum">    3696 </span><span class="lineCov">   95701966 :   if (currval != to</span>
<span class="lineNum">    3697 </span><span class="lineCov">   71666202 :       &amp;&amp; !operand_equal_p (currval, to, 0)</span>
<span class="lineNum">    3698 </span>            :       /* Different undefined SSA names are not actually different.  See
<span class="lineNum">    3699 </span>            :          PR82320 for a testcase were we'd otherwise not terminate iteration.  */
<span class="lineNum">    3700 </span><span class="lineCov">   71813277 :       &amp;&amp; !(TREE_CODE (currval) == SSA_NAME</span>
<span class="lineNum">    3701 </span><span class="lineCov">    2185956 :            &amp;&amp; TREE_CODE (to) == SSA_NAME</span>
<span class="lineNum">    3702 </span><span class="lineCov">    2185356 :            &amp;&amp; ssa_undefined_value_p (currval, false)</span>
<span class="lineNum">    3703 </span><span class="lineCov">     178943 :            &amp;&amp; ssa_undefined_value_p (to, false))</span>
<span class="lineNum">    3704 </span>            :       /* ???  For addresses involving volatile objects or types operand_equal_p
<span class="lineNum">    3705 </span>            :          does not reliably detect ADDR_EXPRs as equal.  We know we are only
<span class="lineNum">    3706 </span>            :          getting invariant gimple addresses here, so can use
<span class="lineNum">    3707 </span>            :          get_addr_base_and_unit_offset to do this comparison.  */
<span class="lineNum">    3708 </span><span class="lineCov">  167336168 :       &amp;&amp; !(TREE_CODE (currval) == ADDR_EXPR</span>
<span class="lineNum">    3709 </span><span class="lineCov">     148650 :            &amp;&amp; TREE_CODE (to) == ADDR_EXPR</span>
<span class="lineNum">    3710 </span><span class="lineCov">         12 :            &amp;&amp; (get_addr_base_and_unit_offset (TREE_OPERAND (currval, 0), &amp;coff)</span>
<span class="lineNum">    3711 </span><span class="lineCov">          6 :                == get_addr_base_and_unit_offset (TREE_OPERAND (to, 0), &amp;toff))</span>
<span class="lineNum">    3712 </span><span class="lineCov">          6 :            &amp;&amp; known_eq (coff, toff)))</span>
<span class="lineNum">    3713 </span>            :     {
<span class="lineNum">    3714 </span><span class="lineCov">   71634196 :       if (dump_file &amp;&amp; (dump_flags &amp; TDF_DETAILS))</span>
<span class="lineNum">    3715 </span><span class="lineCov">       1365 :         fprintf (dump_file, &quot; (changed)\n&quot;);</span>
<span class="lineNum">    3716 </span><span class="lineCov">   71634196 :       from_info-&gt;valnum = to;</span>
<span class="lineNum">    3717 </span><span class="lineCov">   71634196 :       return true;</span>
<span class="lineNum">    3718 </span>            :     }
<span class="lineNum">    3719 </span><span class="lineCov">   24067770 :   if (dump_file &amp;&amp; (dump_flags &amp; TDF_DETAILS))</span>
<span class="lineNum">    3720 </span><span class="lineCov">        376 :     fprintf (dump_file, &quot;\n&quot;);</span>
<span class="lineNum">    3721 </span>            :   return false;
<span class="lineNum">    3722 </span>            : }
<span class="lineNum">    3723 </span>            : 
<span class="lineNum">    3724 </span>            : /* Set all definitions in STMT to value number to themselves.
<span class="lineNum">    3725 </span>            :    Return true if a value number changed. */
<a name="3726"><span class="lineNum">    3726 </span>            : </a>
<span class="lineNum">    3727 </span>            : static bool
<span class="lineNum">    3728 </span><span class="lineCov">  133940515 : defs_to_varying (gimple *stmt)</span>
<span class="lineNum">    3729 </span>            : {
<span class="lineNum">    3730 </span><span class="lineCov">  133940515 :   bool changed = false;</span>
<span class="lineNum">    3731 </span><span class="lineCov">  133940515 :   ssa_op_iter iter;</span>
<span class="lineNum">    3732 </span><span class="lineCov">  133940515 :   def_operand_p defp;</span>
<span class="lineNum">    3733 </span>            : 
<span class="lineNum">    3734 </span><span class="lineCov">  162409229 :   FOR_EACH_SSA_DEF_OPERAND (defp, stmt, iter, SSA_OP_ALL_DEFS)</span>
<span class="lineNum">    3735 </span>            :     {
<span class="lineNum">    3736 </span><span class="lineCov">   14234357 :       tree def = DEF_FROM_PTR (defp);</span>
<span class="lineNum">    3737 </span><span class="lineCov">   14234357 :       changed |= set_ssa_val_to (def, def);</span>
<span class="lineNum">    3738 </span>            :     }
<span class="lineNum">    3739 </span><span class="lineCov">  133940515 :   return changed;</span>
<span class="lineNum">    3740 </span>            : }
<span class="lineNum">    3741 </span>            : 
<span class="lineNum">    3742 </span>            : /* Visit a copy between LHS and RHS, return true if the value number
<span class="lineNum">    3743 </span>            :    changed.  */
<a name="3744"><span class="lineNum">    3744 </span>            : </a>
<span class="lineNum">    3745 </span>            : static bool
<span class="lineNum">    3746 </span><span class="lineNoCov">          0 : visit_copy (tree lhs, tree rhs)</span>
<span class="lineNum">    3747 </span>            : {
<span class="lineNum">    3748 </span>            :   /* Valueize.  */
<span class="lineNum">    3749 </span><span class="lineNoCov">          0 :   rhs = SSA_VAL (rhs);</span>
<span class="lineNum">    3750 </span>            : 
<span class="lineNum">    3751 </span><span class="lineCov">       4929 :   return set_ssa_val_to (lhs, rhs);</span>
<span class="lineNum">    3752 </span>            : }
<span class="lineNum">    3753 </span>            : 
<span class="lineNum">    3754 </span>            : /* Lookup a value for OP in type WIDE_TYPE where the value in type of OP
<span class="lineNum">    3755 </span>            :    is the same.  */
<a name="3756"><span class="lineNum">    3756 </span>            : </a>
<span class="lineNum">    3757 </span>            : static tree
<span class="lineNum">    3758 </span><span class="lineCov">    1230631 : valueized_wider_op (tree wide_type, tree op)</span>
<span class="lineNum">    3759 </span>            : {
<span class="lineNum">    3760 </span><span class="lineCov">    1230631 :   if (TREE_CODE (op) == SSA_NAME)</span>
<span class="lineNum">    3761 </span><span class="lineCov">    1041290 :     op = vn_valueize (op);</span>
<span class="lineNum">    3762 </span>            : 
<span class="lineNum">    3763 </span>            :   /* Either we have the op widened available.  */
<span class="lineNum">    3764 </span><span class="lineCov">    1230631 :   tree ops[3] = {};</span>
<span class="lineNum">    3765 </span><span class="lineCov">    1230631 :   ops[0] = op;</span>
<span class="lineNum">    3766 </span><span class="lineCov">    1230631 :   tree tem = vn_nary_op_lookup_pieces (1, NOP_EXPR,</span>
<span class="lineNum">    3767 </span><span class="lineCov">    1230631 :                                        wide_type, ops, NULL);</span>
<span class="lineNum">    3768 </span><span class="lineCov">    1230631 :   if (tem)</span>
<span class="lineNum">    3769 </span>            :     return tem;
<span class="lineNum">    3770 </span>            : 
<span class="lineNum">    3771 </span>            :   /* Or the op is truncated from some existing value.  */
<span class="lineNum">    3772 </span><span class="lineCov">    1039545 :   if (TREE_CODE (op) == SSA_NAME)</span>
<span class="lineNum">    3773 </span>            :     {
<span class="lineNum">    3774 </span><span class="lineCov">     826305 :       gimple *def = SSA_NAME_DEF_STMT (op);</span>
<span class="lineNum">    3775 </span><span class="lineCov">     826305 :       if (is_gimple_assign (def)</span>
<span class="lineNum">    3776 </span><span class="lineCov">     826305 :           &amp;&amp; CONVERT_EXPR_CODE_P (gimple_assign_rhs_code (def)))</span>
<span class="lineNum">    3777 </span>            :         {
<span class="lineNum">    3778 </span><span class="lineCov">     142576 :           tem = gimple_assign_rhs1 (def);</span>
<span class="lineNum">    3779 </span><span class="lineCov">     142576 :           if (useless_type_conversion_p (wide_type, TREE_TYPE (tem)))</span>
<span class="lineNum">    3780 </span>            :             {
<span class="lineNum">    3781 </span><span class="lineCov">      97678 :               if (TREE_CODE (tem) == SSA_NAME)</span>
<span class="lineNum">    3782 </span><span class="lineCov">      97678 :                 tem = vn_valueize (tem);</span>
<span class="lineNum">    3783 </span><span class="lineCov">      97678 :               return tem;</span>
<span class="lineNum">    3784 </span>            :             }
<span class="lineNum">    3785 </span>            :         }
<span class="lineNum">    3786 </span>            :     }
<span class="lineNum">    3787 </span>            : 
<span class="lineNum">    3788 </span>            :   /* For constants simply extend it.  */
<span class="lineNum">    3789 </span><span class="lineCov">     941867 :   if (TREE_CODE (op) == INTEGER_CST)</span>
<span class="lineNum">    3790 </span><span class="lineCov">     213240 :     return wide_int_to_tree (wide_type, wi::to_wide (op));</span>
<span class="lineNum">    3791 </span>            : 
<span class="lineNum">    3792 </span>            :   return NULL_TREE;
<span class="lineNum">    3793 </span>            : }
<span class="lineNum">    3794 </span>            : 
<span class="lineNum">    3795 </span>            : /* Visit a nary operator RHS, value number it, and return true if the
<span class="lineNum">    3796 </span>            :    value number of LHS has changed as a result.  */
<a name="3797"><span class="lineNum">    3797 </span>            : </a>
<span class="lineNum">    3798 </span>            : static bool
<span class="lineNum">    3799 </span><span class="lineCov">   21366195 : visit_nary_op (tree lhs, gassign *stmt)</span>
<span class="lineNum">    3800 </span>            : {
<span class="lineNum">    3801 </span><span class="lineCov">   21366195 :   vn_nary_op_t vnresult;</span>
<span class="lineNum">    3802 </span><span class="lineCov">   21366195 :   tree result = vn_nary_op_lookup_stmt (stmt, &amp;vnresult);</span>
<span class="lineNum">    3803 </span><span class="lineCov">   21366195 :   if (! result &amp;&amp; vnresult)</span>
<span class="lineNum">    3804 </span><span class="lineCov">     219672 :     result = vn_nary_op_get_predicated_value (vnresult, gimple_bb (stmt));</span>
<span class="lineNum">    3805 </span><span class="lineCov">   21366195 :   if (result)</span>
<span class="lineNum">    3806 </span><span class="lineCov">    1624802 :     return set_ssa_val_to (lhs, result);</span>
<span class="lineNum">    3807 </span>            : 
<span class="lineNum">    3808 </span>            :   /* Do some special pattern matching for redundancies of operations
<span class="lineNum">    3809 </span>            :      in different types.  */
<span class="lineNum">    3810 </span><span class="lineCov">   19741393 :   enum tree_code code = gimple_assign_rhs_code (stmt);</span>
<span class="lineNum">    3811 </span><span class="lineCov">   19741393 :   tree type = TREE_TYPE (lhs);</span>
<span class="lineNum">    3812 </span><span class="lineCov">   19741393 :   tree rhs1 = gimple_assign_rhs1 (stmt);</span>
<span class="lineNum">    3813 </span><span class="lineCov">   19741393 :   switch (code)</span>
<span class="lineNum">    3814 </span>            :     {
<span class="lineNum">    3815 </span><span class="lineCov">    4595989 :     CASE_CONVERT:</span>
<span class="lineNum">    3816 </span>            :       /* Match arithmetic done in a different type where we can easily
<span class="lineNum">    3817 </span>            :          substitute the result from some earlier sign-changed or widened
<span class="lineNum">    3818 </span>            :          operation.  */
<span class="lineNum">    3819 </span><span class="lineCov">    4595989 :       if (INTEGRAL_TYPE_P (type)</span>
<span class="lineNum">    3820 </span><span class="lineCov">    4324499 :           &amp;&amp; TREE_CODE (rhs1) == SSA_NAME</span>
<span class="lineNum">    3821 </span>            :           /* We only handle sign-changes or zero-extension -&gt; &amp; mask.  */
<span class="lineNum">    3822 </span><span class="lineCov">    8867299 :           &amp;&amp; ((TYPE_UNSIGNED (TREE_TYPE (rhs1))</span>
<span class="lineNum">    3823 </span><span class="lineCov">    4271310 :                &amp;&amp; TYPE_PRECISION (type) &gt; TYPE_PRECISION (TREE_TYPE (rhs1)))</span>
<span class="lineNum">    3824 </span><span class="lineCov">    3342774 :               || TYPE_PRECISION (type) == TYPE_PRECISION (TREE_TYPE (rhs1))))</span>
<span class="lineNum">    3825 </span>            :         {
<span class="lineNum">    3826 </span><span class="lineCov">    6090556 :           gassign *def = dyn_cast &lt;gassign *&gt; (SSA_NAME_DEF_STMT (rhs1));</span>
<span class="lineNum">    3827 </span><span class="lineCov">    2396393 :           if (def</span>
<span class="lineNum">    3828 </span><span class="lineCov">    3160379 :               &amp;&amp; (gimple_assign_rhs_code (def) == PLUS_EXPR</span>
<span class="lineNum">    3829 </span><span class="lineCov">    3371990 :                   || gimple_assign_rhs_code (def) == MINUS_EXPR</span>
<span class="lineNum">    3830 </span><span class="lineCov">    3300522 :                   || gimple_assign_rhs_code (def) == MULT_EXPR))</span>
<span class="lineNum">    3831 </span>            :             {
<span class="lineNum">    3832 </span><span class="lineCov">     939911 :               tree ops[3] = {};</span>
<span class="lineNum">    3833 </span>            :               /* Either we have the op widened available.  */
<span class="lineNum">    3834 </span><span class="lineCov">    1879822 :               ops[0] = valueized_wider_op (type,</span>
<span class="lineNum">    3835 </span>            :                                            gimple_assign_rhs1 (def));
<span class="lineNum">    3836 </span><span class="lineCov">     939911 :               if (ops[0])</span>
<span class="lineNum">    3837 </span><span class="lineCov">     581440 :                 ops[1] = valueized_wider_op (type,</span>
<span class="lineNum">    3838 </span>            :                                              gimple_assign_rhs2 (def));
<span class="lineNum">    3839 </span><span class="lineCov">     939911 :               if (ops[0] &amp;&amp; ops[1])</span>
<span class="lineNum">    3840 </span>            :                 {
<span class="lineNum">    3841 </span><span class="lineCov">     422568 :                   ops[0] = vn_nary_op_lookup_pieces</span>
<span class="lineNum">    3842 </span><span class="lineCov">     211284 :                       (2, gimple_assign_rhs_code (def), type, ops, NULL);</span>
<span class="lineNum">    3843 </span>            :                   /* We have wider operation available.  */
<span class="lineNum">    3844 </span><span class="lineCov">     211284 :                   if (ops[0])</span>
<span class="lineNum">    3845 </span>            :                     {
<span class="lineNum">    3846 </span><span class="lineCov">       3906 :                       unsigned lhs_prec = TYPE_PRECISION (type);</span>
<span class="lineNum">    3847 </span><span class="lineCov">       3906 :                       unsigned rhs_prec = TYPE_PRECISION (TREE_TYPE (rhs1));</span>
<span class="lineNum">    3848 </span><span class="lineCov">       3906 :                       if (lhs_prec == rhs_prec)</span>
<span class="lineNum">    3849 </span>            :                         {
<span class="lineNum">    3850 </span><span class="lineCov">       3367 :                           gimple_match_op match_op (gimple_match_cond::UNCOND,</span>
<span class="lineNum">    3851 </span><span class="lineCov">       3367 :                                                     NOP_EXPR, type, ops[0]);</span>
<span class="lineNum">    3852 </span><span class="lineCov">       3367 :                           result = vn_nary_build_or_lookup (&amp;match_op);</span>
<span class="lineNum">    3853 </span><span class="lineCov">       3367 :                           if (result)</span>
<span class="lineNum">    3854 </span>            :                             {
<span class="lineNum">    3855 </span><span class="lineCov">       3367 :                               bool changed = set_ssa_val_to (lhs, result);</span>
<span class="lineNum">    3856 </span><span class="lineCov">       3367 :                               vn_nary_op_insert_stmt (stmt, result);</span>
<span class="lineNum">    3857 </span><span class="lineCov">       3367 :                               return changed;</span>
<span class="lineNum">    3858 </span>            :                             }
<span class="lineNum">    3859 </span>            :                         }
<span class="lineNum">    3860 </span>            :                       else
<span class="lineNum">    3861 </span>            :                         {
<span class="lineNum">    3862 </span><span class="lineCov">        539 :                           tree mask = wide_int_to_tree</span>
<span class="lineNum">    3863 </span><span class="lineCov">        539 :                             (type, wi::mask (rhs_prec, false, lhs_prec));</span>
<span class="lineNum">    3864 </span><span class="lineCov">        539 :                           gimple_match_op match_op (gimple_match_cond::UNCOND,</span>
<span class="lineNum">    3865 </span>            :                                                     BIT_AND_EXPR,
<span class="lineNum">    3866 </span><span class="lineCov">       1078 :                                                     TREE_TYPE (lhs),</span>
<span class="lineNum">    3867 </span><span class="lineCov">        539 :                                                     ops[0], mask);</span>
<span class="lineNum">    3868 </span><span class="lineCov">        539 :                           result = vn_nary_build_or_lookup (&amp;match_op);</span>
<span class="lineNum">    3869 </span><span class="lineCov">        539 :                           if (result)</span>
<span class="lineNum">    3870 </span>            :                             {
<span class="lineNum">    3871 </span><span class="lineCov">        539 :                               bool changed = set_ssa_val_to (lhs, result);</span>
<span class="lineNum">    3872 </span><span class="lineCov">        539 :                               vn_nary_op_insert_stmt (stmt, result);</span>
<span class="lineNum">    3873 </span><span class="lineCov">        539 :                               return changed;</span>
<span class="lineNum">    3874 </span>            :                             }
<span class="lineNum">    3875 </span>            :                         }
<span class="lineNum">    3876 </span>            :                     }
<span class="lineNum">    3877 </span>            :                 }
<span class="lineNum">    3878 </span>            :             }
<span class="lineNum">    3879 </span>            :         }
<span class="lineNum">    3880 </span><span class="lineCov">   19737487 :     default:;</span>
<span class="lineNum">    3881 </span>            :     }
<span class="lineNum">    3882 </span>            : 
<span class="lineNum">    3883 </span><span class="lineCov">   19737487 :   bool changed = set_ssa_val_to (lhs, lhs);</span>
<span class="lineNum">    3884 </span><span class="lineCov">   19737487 :   vn_nary_op_insert_stmt (stmt, lhs);</span>
<span class="lineNum">    3885 </span><span class="lineCov">   19737487 :   return changed;</span>
<span class="lineNum">    3886 </span>            : }
<span class="lineNum">    3887 </span>            : 
<span class="lineNum">    3888 </span>            : /* Visit a call STMT storing into LHS.  Return true if the value number
<span class="lineNum">    3889 </span>            :    of the LHS has changed as a result.  */
<a name="3890"><span class="lineNum">    3890 </span>            : </a>
<span class="lineNum">    3891 </span>            : static bool
<span class="lineNum">    3892 </span><span class="lineCov">    4167617 : visit_reference_op_call (tree lhs, gcall *stmt)</span>
<span class="lineNum">    3893 </span>            : {
<span class="lineNum">    3894 </span><span class="lineCov">    4167617 :   bool changed = false;</span>
<span class="lineNum">    3895 </span><span class="lineCov">    4167617 :   struct vn_reference_s vr1;</span>
<span class="lineNum">    3896 </span><span class="lineCov">    4167617 :   vn_reference_t vnresult = NULL;</span>
<span class="lineNum">    3897 </span><span class="lineCov">    4167617 :   tree vdef = gimple_vdef (stmt);</span>
<span class="lineNum">    3898 </span>            : 
<span class="lineNum">    3899 </span>            :   /* Non-ssa lhs is handled in copy_reference_ops_from_call.  */
<span class="lineNum">    3900 </span><span class="lineCov">    4167617 :   if (lhs &amp;&amp; TREE_CODE (lhs) != SSA_NAME)</span>
<span class="lineNum">    3901 </span><span class="lineCov">     271641 :     lhs = NULL_TREE;</span>
<span class="lineNum">    3902 </span>            : 
<span class="lineNum">    3903 </span><span class="lineCov">    4167617 :   vn_reference_lookup_call (stmt, &amp;vnresult, &amp;vr1);</span>
<span class="lineNum">    3904 </span><span class="lineCov">    4167617 :   if (vnresult)</span>
<span class="lineNum">    3905 </span>            :     {
<span class="lineNum">    3906 </span><span class="lineCov">     102760 :       if (vnresult-&gt;result_vdef &amp;&amp; vdef)</span>
<span class="lineNum">    3907 </span><span class="lineCov">      67316 :         changed |= set_ssa_val_to (vdef, vnresult-&gt;result_vdef);</span>
<span class="lineNum">    3908 </span><span class="lineCov">      35444 :       else if (vdef)</span>
<span class="lineNum">    3909 </span>            :         /* If the call was discovered to be pure or const reflect
<span class="lineNum">    3910 </span>            :            that as far as possible.  */
<span class="lineNum">    3911 </span><span class="lineCov">         20 :         changed |= set_ssa_val_to (vdef, vuse_ssa_val (gimple_vuse (stmt)));</span>
<span class="lineNum">    3912 </span>            : 
<span class="lineNum">    3913 </span><span class="lineCov">     102760 :       if (!vnresult-&gt;result &amp;&amp; lhs)</span>
<span class="lineNum">    3914 </span><span class="lineCov">        208 :         vnresult-&gt;result = lhs;</span>
<span class="lineNum">    3915 </span>            : 
<span class="lineNum">    3916 </span><span class="lineCov">     102760 :       if (vnresult-&gt;result &amp;&amp; lhs)</span>
<span class="lineNum">    3917 </span><span class="lineCov">      35907 :         changed |= set_ssa_val_to (lhs, vnresult-&gt;result);</span>
<span class="lineNum">    3918 </span>            :     }
<span class="lineNum">    3919 </span>            :   else
<span class="lineNum">    3920 </span>            :     {
<span class="lineNum">    3921 </span><span class="lineCov">    4064857 :       vn_reference_t vr2;</span>
<span class="lineNum">    3922 </span><span class="lineCov">    4064857 :       vn_reference_s **slot;</span>
<span class="lineNum">    3923 </span><span class="lineCov">    4064857 :       tree vdef_val = vdef;</span>
<span class="lineNum">    3924 </span><span class="lineCov">    4064857 :       if (vdef)</span>
<span class="lineNum">    3925 </span>            :         {
<span class="lineNum">    3926 </span>            :           /* If we value numbered an indirect functions function to
<span class="lineNum">    3927 </span>            :              one not clobbering memory value number its VDEF to its
<span class="lineNum">    3928 </span>            :              VUSE.  */
<span class="lineNum">    3929 </span><span class="lineCov">    3169984 :           tree fn = gimple_call_fn (stmt);</span>
<span class="lineNum">    3930 </span><span class="lineCov">    3169984 :           if (fn &amp;&amp; TREE_CODE (fn) == SSA_NAME)</span>
<span class="lineNum">    3931 </span>            :             {
<span class="lineNum">    3932 </span><span class="lineCov">      87022 :               fn = SSA_VAL (fn);</span>
<span class="lineNum">    3933 </span><span class="lineCov">      87022 :               if (TREE_CODE (fn) == ADDR_EXPR</span>
<span class="lineNum">    3934 </span><span class="lineCov">        857 :                   &amp;&amp; TREE_CODE (TREE_OPERAND (fn, 0)) == FUNCTION_DECL</span>
<span class="lineNum">    3935 </span><span class="lineCov">      87879 :                   &amp;&amp; (flags_from_decl_or_type (TREE_OPERAND (fn, 0))</span>
<span class="lineNum">    3936 </span><span class="lineCov">        857 :                       &amp; (ECF_CONST | ECF_PURE)))</span>
<span class="lineNum">    3937 </span><span class="lineCov">       1326 :                 vdef_val = vuse_ssa_val (gimple_vuse (stmt));</span>
<span class="lineNum">    3938 </span>            :             }
<span class="lineNum">    3939 </span><span class="lineCov">    3169984 :           changed |= set_ssa_val_to (vdef, vdef_val);</span>
<span class="lineNum">    3940 </span>            :         }
<span class="lineNum">    3941 </span><span class="lineCov">    4064857 :       if (lhs)</span>
<span class="lineNum">    3942 </span><span class="lineCov">    1666948 :         changed |= set_ssa_val_to (lhs, lhs);</span>
<span class="lineNum">    3943 </span><span class="lineCov">    4064857 :       vr2 = XOBNEW (&amp;vn_tables_obstack, vn_reference_s);</span>
<span class="lineNum">    3944 </span><span class="lineCov">    4064857 :       vr2-&gt;vuse = vr1.vuse;</span>
<span class="lineNum">    3945 </span>            :       /* As we are not walking the virtual operand chain we know the
<span class="lineNum">    3946 </span>            :          shared_lookup_references are still original so we can re-use
<span class="lineNum">    3947 </span>            :          them here.  */
<span class="lineNum">    3948 </span><span class="lineCov">    4064857 :       vr2-&gt;operands = vr1.operands.copy ();</span>
<span class="lineNum">    3949 </span><span class="lineCov">    4064857 :       vr2-&gt;type = vr1.type;</span>
<span class="lineNum">    3950 </span><span class="lineCov">    4064857 :       vr2-&gt;set = vr1.set;</span>
<span class="lineNum">    3951 </span><span class="lineCov">    4064857 :       vr2-&gt;hashcode = vr1.hashcode;</span>
<span class="lineNum">    3952 </span><span class="lineCov">    4064857 :       vr2-&gt;result = lhs;</span>
<span class="lineNum">    3953 </span><span class="lineCov">    4064857 :       vr2-&gt;result_vdef = vdef_val;</span>
<span class="lineNum">    3954 </span><span class="lineCov">    4064857 :       slot = valid_info-&gt;references-&gt;find_slot_with_hash (vr2, vr2-&gt;hashcode,</span>
<span class="lineNum">    3955 </span>            :                                                           INSERT);
<span class="lineNum">    3956 </span><span class="lineCov">    4064857 :       gcc_assert (!*slot);</span>
<span class="lineNum">    3957 </span><span class="lineCov">    4064857 :       *slot = vr2;</span>
<span class="lineNum">    3958 </span><span class="lineCov">    4064857 :       vr2-&gt;next = last_inserted_ref;</span>
<span class="lineNum">    3959 </span><span class="lineCov">    4064857 :       last_inserted_ref = vr2;</span>
<span class="lineNum">    3960 </span>            :     }
<span class="lineNum">    3961 </span>            : 
<span class="lineNum">    3962 </span><span class="lineCov">    4167617 :   return changed;</span>
<span class="lineNum">    3963 </span>            : }
<span class="lineNum">    3964 </span>            : 
<span class="lineNum">    3965 </span>            : /* Visit a load from a reference operator RHS, part of STMT, value number it,
<span class="lineNum">    3966 </span>            :    and return true if the value number of the LHS has changed as a result.  */
<a name="3967"><span class="lineNum">    3967 </span>            : </a>
<span class="lineNum">    3968 </span>            : static bool
<span class="lineNum">    3969 </span><span class="lineCov">   14633078 : visit_reference_op_load (tree lhs, tree op, gimple *stmt)</span>
<span class="lineNum">    3970 </span>            : {
<span class="lineNum">    3971 </span><span class="lineCov">   14633078 :   bool changed = false;</span>
<span class="lineNum">    3972 </span><span class="lineCov">   14633078 :   tree last_vuse;</span>
<span class="lineNum">    3973 </span><span class="lineCov">   14633078 :   tree result;</span>
<span class="lineNum">    3974 </span>            : 
<span class="lineNum">    3975 </span><span class="lineCov">   14633078 :   last_vuse = gimple_vuse (stmt);</span>
<span class="lineNum">    3976 </span><span class="lineCov">   14633078 :   last_vuse_ptr = &amp;last_vuse;</span>
<span class="lineNum">    3977 </span><span class="lineCov">   29266156 :   result = vn_reference_lookup (op, gimple_vuse (stmt),</span>
<span class="lineNum">    3978 </span>            :                                 default_vn_walk_kind, NULL, true);
<span class="lineNum">    3979 </span><span class="lineCov">   14633078 :   last_vuse_ptr = NULL;</span>
<span class="lineNum">    3980 </span>            : 
<span class="lineNum">    3981 </span>            :   /* We handle type-punning through unions by value-numbering based
<span class="lineNum">    3982 </span>            :      on offset and size of the access.  Be prepared to handle a
<span class="lineNum">    3983 </span>            :      type-mismatch here via creating a VIEW_CONVERT_EXPR.  */
<span class="lineNum">    3984 </span><span class="lineCov">   14633078 :   if (result</span>
<span class="lineNum">    3985 </span><span class="lineCov">   14633078 :       &amp;&amp; !useless_type_conversion_p (TREE_TYPE (result), TREE_TYPE (op)))</span>
<span class="lineNum">    3986 </span>            :     {
<span class="lineNum">    3987 </span>            :       /* We will be setting the value number of lhs to the value number
<span class="lineNum">    3988 </span>            :          of VIEW_CONVERT_EXPR &lt;TREE_TYPE (result)&gt; (result).
<span class="lineNum">    3989 </span>            :          So first simplify and lookup this expression to see if it
<span class="lineNum">    3990 </span>            :          is already available.  */
<span class="lineNum">    3991 </span><span class="lineCov">       5190 :       gimple_match_op res_op (gimple_match_cond::UNCOND,</span>
<span class="lineNum">    3992 </span><span class="lineCov">       5190 :                               VIEW_CONVERT_EXPR, TREE_TYPE (op), result);</span>
<span class="lineNum">    3993 </span><span class="lineCov">       5190 :       result = vn_nary_build_or_lookup (&amp;res_op);</span>
<span class="lineNum">    3994 </span>            :       /* When building the conversion fails avoid inserting the reference
<span class="lineNum">    3995 </span>            :          again.  */
<span class="lineNum">    3996 </span><span class="lineCov">       5190 :       if (!result)</span>
<span class="lineNum">    3997 </span><span class="lineNoCov">          0 :         return set_ssa_val_to (lhs, lhs);</span>
<span class="lineNum">    3998 </span>            :     }
<span class="lineNum">    3999 </span>            : 
<span class="lineNum">    4000 </span><span class="lineCov">   14633078 :   if (result)</span>
<span class="lineNum">    4001 </span><span class="lineCov">    2171971 :     changed = set_ssa_val_to (lhs, result);</span>
<span class="lineNum">    4002 </span>            :   else
<span class="lineNum">    4003 </span>            :     {
<span class="lineNum">    4004 </span><span class="lineCov">   12461107 :       changed = set_ssa_val_to (lhs, lhs);</span>
<span class="lineNum">    4005 </span><span class="lineCov">   12461107 :       vn_reference_insert (op, lhs, last_vuse, NULL_TREE);</span>
<span class="lineNum">    4006 </span>            :     }
<span class="lineNum">    4007 </span>            : 
<span class="lineNum">    4008 </span>            :   return changed;
<span class="lineNum">    4009 </span>            : }
<span class="lineNum">    4010 </span>            : 
<span class="lineNum">    4011 </span>            : 
<span class="lineNum">    4012 </span>            : /* Visit a store to a reference operator LHS, part of STMT, value number it,
<span class="lineNum">    4013 </span>            :    and return true if the value number of the LHS has changed as a result.  */
<a name="4014"><span class="lineNum">    4014 </span>            : </a>
<span class="lineNum">    4015 </span>            : static bool
<span class="lineNum">    4016 </span><span class="lineCov">   15563138 : visit_reference_op_store (tree lhs, tree op, gimple *stmt)</span>
<span class="lineNum">    4017 </span>            : {
<span class="lineNum">    4018 </span><span class="lineCov">   15563138 :   bool changed = false;</span>
<span class="lineNum">    4019 </span><span class="lineCov">   15563138 :   vn_reference_t vnresult = NULL;</span>
<span class="lineNum">    4020 </span><span class="lineCov">   15563138 :   tree assign;</span>
<span class="lineNum">    4021 </span><span class="lineCov">   15563138 :   bool resultsame = false;</span>
<span class="lineNum">    4022 </span><span class="lineCov">   15563138 :   tree vuse = gimple_vuse (stmt);</span>
<span class="lineNum">    4023 </span><span class="lineCov">   15563138 :   tree vdef = gimple_vdef (stmt);</span>
<span class="lineNum">    4024 </span>            : 
<span class="lineNum">    4025 </span><span class="lineCov">   15563138 :   if (TREE_CODE (op) == SSA_NAME)</span>
<span class="lineNum">    4026 </span><span class="lineCov">    7161492 :     op = SSA_VAL (op);</span>
<span class="lineNum">    4027 </span>            : 
<span class="lineNum">    4028 </span>            :   /* First we want to lookup using the *vuses* from the store and see
<span class="lineNum">    4029 </span>            :      if there the last store to this location with the same address
<span class="lineNum">    4030 </span>            :      had the same value.
<span class="lineNum">    4031 </span>            : 
<span class="lineNum">    4032 </span>            :      The vuses represent the memory state before the store.  If the
<span class="lineNum">    4033 </span>            :      memory state, address, and value of the store is the same as the
<span class="lineNum">    4034 </span>            :      last store to this location, then this store will produce the
<span class="lineNum">    4035 </span>            :      same memory state as that store.
<span class="lineNum">    4036 </span>            : 
<span class="lineNum">    4037 </span>            :      In this case the vdef versions for this store are value numbered to those
<span class="lineNum">    4038 </span>            :      vuse versions, since they represent the same memory state after
<span class="lineNum">    4039 </span>            :      this store.
<span class="lineNum">    4040 </span>            : 
<span class="lineNum">    4041 </span>            :      Otherwise, the vdefs for the store are used when inserting into
<span class="lineNum">    4042 </span>            :      the table, since the store generates a new memory state.  */
<span class="lineNum">    4043 </span>            : 
<span class="lineNum">    4044 </span><span class="lineCov">   15563138 :   vn_reference_lookup (lhs, vuse, VN_NOWALK, &amp;vnresult, false);</span>
<span class="lineNum">    4045 </span><span class="lineCov">   31126276 :   if (vnresult</span>
<span class="lineNum">    4046 </span><span class="lineCov">   15563138 :       &amp;&amp; vnresult-&gt;result)</span>
<span class="lineNum">    4047 </span>            :     {
<span class="lineNum">    4048 </span><span class="lineCov">     646330 :       tree result = vnresult-&gt;result;</span>
<span class="lineNum">    4049 </span><span class="lineCov">     646330 :       gcc_checking_assert (TREE_CODE (result) != SSA_NAME</span>
<span class="lineNum">    4050 </span>            :                            || result == SSA_VAL (result));
<span class="lineNum">    4051 </span><span class="lineCov">     646330 :       resultsame = expressions_equal_p (result, op);</span>
<span class="lineNum">    4052 </span><span class="lineCov">     646330 :       if (resultsame)</span>
<span class="lineNum">    4053 </span>            :         {
<span class="lineNum">    4054 </span>            :           /* If the TBAA state isn't compatible for downstream reads
<span class="lineNum">    4055 </span>            :              we cannot value-number the VDEFs the same.  */
<span class="lineNum">    4056 </span><span class="lineCov">      37686 :           alias_set_type set = get_alias_set (lhs);</span>
<span class="lineNum">    4057 </span><span class="lineCov">      37686 :           if (vnresult-&gt;set != set</span>
<span class="lineNum">    4058 </span><span class="lineCov">      37686 :               &amp;&amp; ! alias_set_subset_of (set, vnresult-&gt;set))</span>
<span class="lineNum">    4059 </span>            :             resultsame = false;
<span class="lineNum">    4060 </span>            :         }
<span class="lineNum">    4061 </span>            :     }
<span class="lineNum">    4062 </span>            : 
<span class="lineNum">    4063 </span><span class="lineCov">     646200 :   if (!resultsame)</span>
<span class="lineNum">    4064 </span>            :     {
<span class="lineNum">    4065 </span>            :       /* Only perform the following when being called from PRE
<span class="lineNum">    4066 </span>            :          which embeds tail merging.  */
<span class="lineNum">    4067 </span><span class="lineCov">   15525582 :       if (default_vn_walk_kind == VN_WALK)</span>
<span class="lineNum">    4068 </span>            :         {
<span class="lineNum">    4069 </span><span class="lineCov">    4624588 :           assign = build2 (MODIFY_EXPR, TREE_TYPE (lhs), lhs, op);</span>
<span class="lineNum">    4070 </span><span class="lineCov">    4624588 :           vn_reference_lookup (assign, vuse, VN_NOWALK, &amp;vnresult, false);</span>
<span class="lineNum">    4071 </span><span class="lineCov">    4624588 :           if (vnresult)</span>
<span class="lineNum">    4072 </span>            :             {
<span class="lineNum">    4073 </span><span class="lineCov">      32145 :               VN_INFO (vdef)-&gt;visited = true;</span>
<span class="lineNum">    4074 </span><span class="lineCov">      32145 :               return set_ssa_val_to (vdef, vnresult-&gt;result_vdef);</span>
<span class="lineNum">    4075 </span>            :             }
<span class="lineNum">    4076 </span>            :         }
<span class="lineNum">    4077 </span>            : 
<span class="lineNum">    4078 </span><span class="lineCov">   15493437 :       if (dump_file &amp;&amp; (dump_flags &amp; TDF_DETAILS))</span>
<span class="lineNum">    4079 </span>            :         {
<span class="lineNum">    4080 </span><span class="lineCov">        208 :           fprintf (dump_file, &quot;No store match\n&quot;);</span>
<span class="lineNum">    4081 </span><span class="lineCov">        208 :           fprintf (dump_file, &quot;Value numbering store &quot;);</span>
<span class="lineNum">    4082 </span><span class="lineCov">        208 :           print_generic_expr (dump_file, lhs);</span>
<span class="lineNum">    4083 </span><span class="lineCov">        208 :           fprintf (dump_file, &quot; to &quot;);</span>
<span class="lineNum">    4084 </span><span class="lineCov">        208 :           print_generic_expr (dump_file, op);</span>
<span class="lineNum">    4085 </span><span class="lineCov">        208 :           fprintf (dump_file, &quot;\n&quot;);</span>
<span class="lineNum">    4086 </span>            :         }
<span class="lineNum">    4087 </span>            :       /* Have to set value numbers before insert, since insert is
<span class="lineNum">    4088 </span>            :          going to valueize the references in-place.  */
<span class="lineNum">    4089 </span><span class="lineCov">   15493437 :       if (vdef)</span>
<span class="lineNum">    4090 </span><span class="lineCov">   15493437 :         changed |= set_ssa_val_to (vdef, vdef);</span>
<span class="lineNum">    4091 </span>            : 
<span class="lineNum">    4092 </span>            :       /* Do not insert structure copies into the tables.  */
<span class="lineNum">    4093 </span><span class="lineCov">   15493437 :       if (is_gimple_min_invariant (op)</span>
<span class="lineNum">    4094 </span><span class="lineCov">   15493437 :           || is_gimple_reg (op))</span>
<span class="lineNum">    4095 </span><span class="lineCov">   14065408 :         vn_reference_insert (lhs, op, vdef, NULL);</span>
<span class="lineNum">    4096 </span>            : 
<span class="lineNum">    4097 </span>            :       /* Only perform the following when being called from PRE
<span class="lineNum">    4098 </span>            :          which embeds tail merging.  */
<span class="lineNum">    4099 </span><span class="lineCov">   15493437 :       if (default_vn_walk_kind == VN_WALK)</span>
<span class="lineNum">    4100 </span>            :         {
<span class="lineNum">    4101 </span><span class="lineCov">    4592443 :           assign = build2 (MODIFY_EXPR, TREE_TYPE (lhs), lhs, op);</span>
<span class="lineNum">    4102 </span><span class="lineCov">    4592443 :           vn_reference_insert (assign, lhs, vuse, vdef);</span>
<span class="lineNum">    4103 </span>            :         }
<span class="lineNum">    4104 </span>            :     }
<span class="lineNum">    4105 </span>            :   else
<span class="lineNum">    4106 </span>            :     {
<span class="lineNum">    4107 </span>            :       /* We had a match, so value number the vdef to have the value
<span class="lineNum">    4108 </span>            :          number of the vuse it came from.  */
<span class="lineNum">    4109 </span>            : 
<span class="lineNum">    4110 </span><span class="lineCov">      37556 :       if (dump_file &amp;&amp; (dump_flags &amp; TDF_DETAILS))</span>
<span class="lineNum">    4111 </span><span class="lineCov">          8 :         fprintf (dump_file, &quot;Store matched earlier value, &quot;</span>
<span class="lineNum">    4112 </span>            :                  &quot;value numbering store vdefs to matching vuses.\n&quot;);
<span class="lineNum">    4113 </span>            : 
<span class="lineNum">    4114 </span><span class="lineCov">      37556 :       changed |= set_ssa_val_to (vdef, SSA_VAL (vuse));</span>
<span class="lineNum">    4115 </span>            :     }
<span class="lineNum">    4116 </span>            : 
<span class="lineNum">    4117 </span>            :   return changed;
<span class="lineNum">    4118 </span>            : }
<span class="lineNum">    4119 </span>            : 
<span class="lineNum">    4120 </span>            : /* Visit and value number PHI, return true if the value number
<span class="lineNum">    4121 </span>            :    changed.  When BACKEDGES_VARYING_P is true then assume all
<span class="lineNum">    4122 </span>            :    backedge values are varying.  When INSERTED is not NULL then
<span class="lineNum">    4123 </span>            :    this is just a ahead query for a possible iteration, set INSERTED
<span class="lineNum">    4124 </span>            :    to true if we'd insert into the hashtable.  */
<a name="4125"><span class="lineNum">    4125 </span>            : </a>
<span class="lineNum">    4126 </span>            : static bool
<span class="lineNum">    4127 </span><span class="lineCov">   15417228 : visit_phi (gimple *phi, bool *inserted, bool backedges_varying_p)</span>
<span class="lineNum">    4128 </span>            : {
<span class="lineNum">    4129 </span><span class="lineCov">   15417228 :   tree result, sameval = VN_TOP, seen_undef = NULL_TREE;</span>
<span class="lineNum">    4130 </span><span class="lineCov">   15417228 :   tree backedge_val = NULL_TREE;</span>
<span class="lineNum">    4131 </span><span class="lineCov">   15417228 :   bool seen_non_backedge = false;</span>
<span class="lineNum">    4132 </span><span class="lineCov">   15417228 :   tree sameval_base = NULL_TREE;</span>
<span class="lineNum">    4133 </span><span class="lineCov">   30834456 :   poly_int64 soff, doff;</span>
<span class="lineNum">    4134 </span><span class="lineCov">   15417228 :   unsigned n_executable = 0;</span>
<span class="lineNum">    4135 </span><span class="lineCov">   15417228 :   edge_iterator ei;</span>
<span class="lineNum">    4136 </span><span class="lineCov">   15417228 :   edge e;</span>
<span class="lineNum">    4137 </span>            : 
<span class="lineNum">    4138 </span>            :   /* TODO: We could check for this in initialization, and replace this
<span class="lineNum">    4139 </span>            :      with a gcc_assert.  */
<span class="lineNum">    4140 </span><span class="lineCov">   15417228 :   if (SSA_NAME_OCCURS_IN_ABNORMAL_PHI (PHI_RESULT (phi)))</span>
<span class="lineNum">    4141 </span><span class="lineCov">      85995 :     return set_ssa_val_to (PHI_RESULT (phi), PHI_RESULT (phi));</span>
<span class="lineNum">    4142 </span>            : 
<span class="lineNum">    4143 </span>            :   /* We track whether a PHI was CSEd to to avoid excessive iterations
<span class="lineNum">    4144 </span>            :      that would be necessary only because the PHI changed arguments
<span class="lineNum">    4145 </span>            :      but not value.  */
<span class="lineNum">    4146 </span><span class="lineCov">   15400029 :   if (!inserted)</span>
<span class="lineNum">    4147 </span><span class="lineCov">   11287768 :     gimple_set_plf (phi, GF_PLF_1, false);</span>
<span class="lineNum">    4148 </span>            : 
<span class="lineNum">    4149 </span>            :   /* See if all non-TOP arguments have the same value.  TOP is
<span class="lineNum">    4150 </span>            :      equivalent to everything, so we can ignore it.  */
<span class="lineNum">    4151 </span><span class="lineCov">   65119334 :   FOR_EACH_EDGE (e, ei, gimple_bb (phi)-&gt;preds)</span>
<span class="lineNum">    4152 </span><span class="lineCov">   30867664 :     if (e-&gt;flags &amp; EDGE_EXECUTABLE)</span>
<span class="lineNum">    4153 </span>            :       {
<span class="lineNum">    4154 </span><span class="lineCov">   28241512 :         tree def = PHI_ARG_DEF_FROM_EDGE (phi, e);</span>
<span class="lineNum">    4155 </span>            : 
<span class="lineNum">    4156 </span><span class="lineCov">   28241512 :         ++n_executable;</span>
<span class="lineNum">    4157 </span><span class="lineCov">   28241512 :         if (TREE_CODE (def) == SSA_NAME)</span>
<span class="lineNum">    4158 </span>            :           {
<span class="lineNum">    4159 </span><span class="lineCov">   23374082 :             if (!backedges_varying_p || !(e-&gt;flags &amp; EDGE_DFS_BACK))</span>
<span class="lineNum">    4160 </span><span class="lineCov">   23175936 :               def = SSA_VAL (def);</span>
<span class="lineNum">    4161 </span><span class="lineCov">   23374082 :             if (e-&gt;flags &amp; EDGE_DFS_BACK)</span>
<span class="lineNum">    4162 </span><span class="lineCov">    7333300 :               backedge_val = def;</span>
<span class="lineNum">    4163 </span>            :           }
<span class="lineNum">    4164 </span><span class="lineCov">   28241512 :         if (!(e-&gt;flags &amp; EDGE_DFS_BACK))</span>
<span class="lineNum">    4165 </span><span class="lineCov">   20861061 :           seen_non_backedge = true;</span>
<span class="lineNum">    4166 </span><span class="lineCov">   28241512 :         if (def == VN_TOP)</span>
<span class="lineNum">    4167 </span>            :           ;
<span class="lineNum">    4168 </span>            :         /* Ignore undefined defs for sameval but record one.  */
<span class="lineNum">    4169 </span><span class="lineCov">   28241506 :         else if (TREE_CODE (def) == SSA_NAME</span>
<span class="lineNum">    4170 </span><span class="lineCov">   43232398 :                  &amp;&amp; ! virtual_operand_p (def)</span>
<span class="lineNum">    4171 </span><span class="lineCov">   38998876 :                  &amp;&amp; ssa_undefined_value_p (def, false))</span>
<span class="lineNum">    4172 </span>            :           seen_undef = def;
<span class="lineNum">    4173 </span><span class="lineCov">   28147197 :         else if (sameval == VN_TOP)</span>
<span class="lineNum">    4174 </span>            :           sameval = def;
<span class="lineNum">    4175 </span><span class="lineCov">   12767432 :         else if (!expressions_equal_p (def, sameval))</span>
<span class="lineNum">    4176 </span>            :           {
<span class="lineNum">    4177 </span>            :             /* We know we're arriving only with invariant addresses here,
<span class="lineNum">    4178 </span>            :                try harder comparing them.  We can do some caching here
<span class="lineNum">    4179 </span>            :                which we cannot do in expressions_equal_p.  */
<span class="lineNum">    4180 </span><span class="lineCov">   11948433 :             if (TREE_CODE (def) == ADDR_EXPR</span>
<span class="lineNum">    4181 </span><span class="lineCov">      95708 :                 &amp;&amp; TREE_CODE (sameval) == ADDR_EXPR</span>
<span class="lineNum">    4182 </span><span class="lineCov">      60018 :                 &amp;&amp; sameval_base != (void *)-1)</span>
<span class="lineNum">    4183 </span>            :               {
<span class="lineNum">    4184 </span><span class="lineCov">      60018 :                 if (!sameval_base)</span>
<span class="lineNum">    4185 </span><span class="lineCov">      60016 :                   sameval_base = get_addr_base_and_unit_offset</span>
<span class="lineNum">    4186 </span><span class="lineCov">      60016 :                                    (TREE_OPERAND (sameval, 0), &amp;soff);</span>
<span class="lineNum">    4187 </span><span class="lineCov">      60018 :                 if (!sameval_base)</span>
<span class="lineNum">    4188 </span>            :                   sameval_base = (tree)(void *)-1;
<span class="lineNum">    4189 </span><span class="lineCov">      60018 :                 else if ((get_addr_base_and_unit_offset</span>
<span class="lineNum">    4190 </span><span class="lineCov">      60018 :                             (TREE_OPERAND (def, 0), &amp;doff) == sameval_base)</span>
<span class="lineNum">    4191 </span><span class="lineCov">      60018 :                          &amp;&amp; known_eq (soff, doff))</span>
<span class="lineNum">    4192 </span>            :                   continue;
<span class="lineNum">    4193 </span>            :               }
<span class="lineNum">    4194 </span>            :             sameval = NULL_TREE;
<span class="lineNum">    4195 </span>            :             break;
<span class="lineNum">    4196 </span>            :           }
<span class="lineNum">    4197 </span>            :       }
<span class="lineNum">    4198 </span>            : 
<span class="lineNum">    4199 </span>            :   /* If we value-number a virtual operand never value-number to the
<span class="lineNum">    4200 </span>            :      value from the backedge as that confuses the alias-walking code.
<span class="lineNum">    4201 </span>            :      See gcc.dg/torture/pr87176.c.  If the value is the same on a
<span class="lineNum">    4202 </span>            :      non-backedge everything is OK though.  */
<span class="lineNum">    4203 </span><span class="lineCov">   15400029 :   if (backedge_val</span>
<span class="lineNum">    4204 </span><span class="lineCov">   15400029 :       &amp;&amp; !seen_non_backedge</span>
<span class="lineNum">    4205 </span><span class="lineCov">      12691 :       &amp;&amp; TREE_CODE (backedge_val) == SSA_NAME</span>
<span class="lineNum">    4206 </span><span class="lineCov">      12377 :       &amp;&amp; sameval == backedge_val</span>
<span class="lineNum">    4207 </span><span class="lineCov">   15403503 :       &amp;&amp; SSA_NAME_IS_VIRTUAL_OPERAND (backedge_val))</span>
<span class="lineNum">    4208 </span>            :     /* Note this just drops to VARYING without inserting the PHI into
<span class="lineNum">    4209 </span>            :        the hashes.  */
<span class="lineNum">    4210 </span><span class="lineCov">        897 :     result = PHI_RESULT (phi);</span>
<span class="lineNum">    4211 </span>            :   /* If none of the edges was executable keep the value-number at VN_TOP,
<span class="lineNum">    4212 </span>            :      if only a single edge is exectuable use its value.  */
<span class="lineNum">    4213 </span><span class="lineCov">   15399132 :   else if (n_executable &lt;= 1)</span>
<span class="lineNum">    4214 </span><span class="lineCov">    3012387 :     result = seen_undef ? seen_undef : sameval;</span>
<span class="lineNum">    4215 </span>            :   /* If we saw only undefined values and VN_TOP use one of the
<span class="lineNum">    4216 </span>            :      undefined values.  */
<span class="lineNum">    4217 </span><span class="lineCov">   12386745 :   else if (sameval == VN_TOP)</span>
<span class="lineNum">    4218 </span><span class="lineCov">       3754 :     result = seen_undef ? seen_undef : sameval;</span>
<span class="lineNum">    4219 </span>            :   /* First see if it is equivalent to a phi node in this block.  We prefer
<span class="lineNum">    4220 </span>            :      this as it allows IV elimination - see PRs 66502 and 67167.  */
<span class="lineNum">    4221 </span><span class="lineCov">   12382991 :   else if ((result = vn_phi_lookup (phi, backedges_varying_p)))</span>
<span class="lineNum">    4222 </span>            :     {
<span class="lineNum">    4223 </span><span class="lineCov">    2356450 :       if (!inserted</span>
<span class="lineNum">    4224 </span><span class="lineCov">      20747 :           &amp;&amp; TREE_CODE (result) == SSA_NAME</span>
<span class="lineNum">    4225 </span><span class="lineCov">    2418691 :           &amp;&amp; gimple_code (SSA_NAME_DEF_STMT (result)) == GIMPLE_PHI)</span>
<span class="lineNum">    4226 </span>            :         {
<span class="lineNum">    4227 </span><span class="lineCov">      41494 :           gimple_set_plf (SSA_NAME_DEF_STMT (result), GF_PLF_1, true);</span>
<span class="lineNum">    4228 </span><span class="lineCov">      20747 :           if (dump_file &amp;&amp; (dump_flags &amp; TDF_DETAILS))</span>
<span class="lineNum">    4229 </span>            :             {
<span class="lineNum">    4230 </span><span class="lineCov">          1 :               fprintf (dump_file, &quot;Marking CSEd to PHI node &quot;);</span>
<span class="lineNum">    4231 </span><span class="lineCov">          1 :               print_gimple_expr (dump_file, SSA_NAME_DEF_STMT (result),</span>
<span class="lineNum">    4232 </span>            :                                  0, TDF_SLIM);
<span class="lineNum">    4233 </span><span class="lineCov">          1 :               fprintf (dump_file, &quot;\n&quot;);</span>
<span class="lineNum">    4234 </span>            :             }
<span class="lineNum">    4235 </span>            :         }
<span class="lineNum">    4236 </span>            :     }
<span class="lineNum">    4237 </span>            :   /* If all values are the same use that, unless we've seen undefined
<span class="lineNum">    4238 </span>            :      values as well and the value isn't constant.
<span class="lineNum">    4239 </span>            :      CCP/copyprop have the same restriction to not remove uninit warnings.  */
<span class="lineNum">    4240 </span><span class="lineCov">   10026541 :   else if (sameval</span>
<span class="lineNum">    4241 </span><span class="lineCov">   10026541 :            &amp;&amp; (! seen_undef || is_gimple_min_invariant (sameval)))</span>
<span class="lineNum">    4242 </span>            :     result = sameval;
<span class="lineNum">    4243 </span>            :   else
<span class="lineNum">    4244 </span>            :     {
<span class="lineNum">    4245 </span><span class="lineCov">    9649429 :       result = PHI_RESULT (phi);</span>
<span class="lineNum">    4246 </span>            :       /* Only insert PHIs that are varying, for constant value numbers
<span class="lineNum">    4247 </span>            :          we mess up equivalences otherwise as we are only comparing
<span class="lineNum">    4248 </span>            :          the immediate controlling predicates.  */
<span class="lineNum">    4249 </span><span class="lineCov">    9649429 :       vn_phi_insert (phi, result, backedges_varying_p);</span>
<span class="lineNum">    4250 </span><span class="lineCov">    9649429 :       if (inserted)</span>
<span class="lineNum">    4251 </span><span class="lineCov">    1684593 :         *inserted = true;</span>
<span class="lineNum">    4252 </span>            :     }
<span class="lineNum">    4253 </span>            : 
<span class="lineNum">    4254 </span><span class="lineCov">   15400029 :   return set_ssa_val_to (PHI_RESULT (phi), result);</span>
<span class="lineNum">    4255 </span>            : }
<span class="lineNum">    4256 </span>            : 
<span class="lineNum">    4257 </span>            : /* Try to simplify RHS using equivalences and constant folding.  */
<a name="4258"><span class="lineNum">    4258 </span>            : </a>
<span class="lineNum">    4259 </span>            : static tree
<span class="lineNum">    4260 </span><span class="lineCov">   57133083 : try_to_simplify (gassign *stmt)</span>
<span class="lineNum">    4261 </span>            : {
<span class="lineNum">    4262 </span><span class="lineCov">   57133083 :   enum tree_code code = gimple_assign_rhs_code (stmt);</span>
<span class="lineNum">    4263 </span><span class="lineCov">   57133083 :   tree tem;</span>
<span class="lineNum">    4264 </span>            : 
<span class="lineNum">    4265 </span>            :   /* For stores we can end up simplifying a SSA_NAME rhs.  Just return
<span class="lineNum">    4266 </span>            :      in this case, there is no point in doing extra work.  */
<span class="lineNum">    4267 </span><span class="lineCov">   57133083 :   if (code == SSA_NAME)</span>
<span class="lineNum">    4268 </span>            :     return NULL_TREE;
<span class="lineNum">    4269 </span>            : 
<span class="lineNum">    4270 </span>            :   /* First try constant folding based on our current lattice.  */
<span class="lineNum">    4271 </span><span class="lineCov">   49971429 :   mprts_hook = vn_lookup_simplify_result;</span>
<span class="lineNum">    4272 </span><span class="lineCov">   49971429 :   tem = gimple_fold_stmt_to_constant_1 (stmt, vn_valueize, vn_valueize);</span>
<span class="lineNum">    4273 </span><span class="lineCov">   49971429 :   mprts_hook = NULL;</span>
<span class="lineNum">    4274 </span><span class="lineCov">   49971429 :   if (tem</span>
<span class="lineNum">    4275 </span><span class="lineCov">   49971429 :       &amp;&amp; (TREE_CODE (tem) == SSA_NAME</span>
<span class="lineNum">    4276 </span><span class="lineCov">   12168862 :           || is_gimple_min_invariant (tem)))</span>
<span class="lineNum">    4277 </span><span class="lineCov">   12524746 :     return tem;</span>
<span class="lineNum">    4278 </span>            : 
<span class="lineNum">    4279 </span>            :   return NULL_TREE;
<span class="lineNum">    4280 </span>            : }
<span class="lineNum">    4281 </span>            : 
<span class="lineNum">    4282 </span>            : /* Visit and value number STMT, return true if the value number
<span class="lineNum">    4283 </span>            :    changed.  */
<a name="4284"><span class="lineNum">    4284 </span>            : </a>
<span class="lineNum">    4285 </span>            : static bool
<span class="lineNum">    4286 </span><span class="lineCov">  210523387 : visit_stmt (gimple *stmt, bool backedges_varying_p = false)</span>
<span class="lineNum">    4287 </span>            : {
<span class="lineNum">    4288 </span><span class="lineCov">  210523387 :   bool changed = false;</span>
<span class="lineNum">    4289 </span>            : 
<span class="lineNum">    4290 </span><span class="lineCov">  210523387 :   if (dump_file &amp;&amp; (dump_flags &amp; TDF_DETAILS))</span>
<span class="lineNum">    4291 </span>            :     {
<span class="lineNum">    4292 </span><span class="lineCov">       1908 :       fprintf (dump_file, &quot;Value numbering stmt = &quot;);</span>
<span class="lineNum">    4293 </span><span class="lineCov">       1908 :       print_gimple_stmt (dump_file, stmt, 0);</span>
<span class="lineNum">    4294 </span>            :     }
<span class="lineNum">    4295 </span>            : 
<span class="lineNum">    4296 </span><span class="lineCov">  421046774 :   if (gimple_code (stmt) == GIMPLE_PHI)</span>
<span class="lineNum">    4297 </span><span class="lineCov">   11299143 :     changed = visit_phi (stmt, NULL, backedges_varying_p);</span>
<span class="lineNum">    4298 </span><span class="lineCov">  279150345 :   else if (gimple_has_volatile_ops (stmt))</span>
<span class="lineNum">    4299 </span><span class="lineCov">    4355695 :     changed = defs_to_varying (stmt);</span>
<span class="lineNum">    4300 </span><span class="lineCov">  194868549 :   else if (gassign *ass = dyn_cast &lt;gassign *&gt; (stmt))</span>
<span class="lineNum">    4301 </span>            :     {
<span class="lineNum">    4302 </span><span class="lineCov">   61110784 :       enum tree_code code = gimple_assign_rhs_code (ass);</span>
<span class="lineNum">    4303 </span><span class="lineCov">   61110784 :       tree lhs = gimple_assign_lhs (ass);</span>
<span class="lineNum">    4304 </span><span class="lineCov">   61110784 :       tree rhs1 = gimple_assign_rhs1 (ass);</span>
<span class="lineNum">    4305 </span><span class="lineCov">   61110784 :       tree simplified;</span>
<span class="lineNum">    4306 </span>            : 
<span class="lineNum">    4307 </span>            :       /* Shortcut for copies. Simplifying copies is pointless,
<span class="lineNum">    4308 </span>            :          since we copy the expression and value they represent.  */
<span class="lineNum">    4309 </span><span class="lineCov">   61110784 :       if (code == SSA_NAME</span>
<span class="lineNum">    4310 </span><span class="lineCov">   11139355 :           &amp;&amp; TREE_CODE (lhs) == SSA_NAME)</span>
<span class="lineNum">    4311 </span>            :         {
<span class="lineNum">    4312 </span><span class="lineCov">    3977701 :           changed = visit_copy (lhs, rhs1);</span>
<span class="lineNum">    4313 </span><span class="lineCov">    3977701 :           goto done;</span>
<span class="lineNum">    4314 </span>            :         }
<span class="lineNum">    4315 </span><span class="lineCov">   57133083 :       simplified = try_to_simplify (ass);</span>
<span class="lineNum">    4316 </span><span class="lineCov">   57133083 :       if (simplified)</span>
<span class="lineNum">    4317 </span>            :         {
<span class="lineNum">    4318 </span><span class="lineCov">   12524746 :           if (dump_file &amp;&amp; (dump_flags &amp; TDF_DETAILS))</span>
<span class="lineNum">    4319 </span>            :             {
<span class="lineNum">    4320 </span><span class="lineCov">        318 :               fprintf (dump_file, &quot;RHS &quot;);</span>
<span class="lineNum">    4321 </span><span class="lineCov">        318 :               print_gimple_expr (dump_file, ass, 0);</span>
<span class="lineNum">    4322 </span><span class="lineCov">        318 :               fprintf (dump_file, &quot; simplified to &quot;);</span>
<span class="lineNum">    4323 </span><span class="lineCov">        318 :               print_generic_expr (dump_file, simplified);</span>
<span class="lineNum">    4324 </span><span class="lineCov">        318 :               fprintf (dump_file, &quot;\n&quot;);</span>
<span class="lineNum">    4325 </span>            :             }
<span class="lineNum">    4326 </span>            :         }
<span class="lineNum">    4327 </span>            :       /* Setting value numbers to constants will occasionally
<span class="lineNum">    4328 </span>            :          screw up phi congruence because constants are not
<span class="lineNum">    4329 </span>            :          uniquely associated with a single ssa name that can be
<span class="lineNum">    4330 </span>            :          looked up.  */
<span class="lineNum">    4331 </span><span class="lineCov">   57133083 :       if (simplified</span>
<span class="lineNum">    4332 </span><span class="lineCov">   12524746 :           &amp;&amp; is_gimple_min_invariant (simplified)</span>
<span class="lineNum">    4333 </span><span class="lineCov">   67874758 :           &amp;&amp; TREE_CODE (lhs) == SSA_NAME)</span>
<span class="lineNum">    4334 </span>            :         {
<span class="lineNum">    4335 </span><span class="lineCov">    3768522 :           changed = set_ssa_val_to (lhs, simplified);</span>
<span class="lineNum">    4336 </span><span class="lineCov">    3768522 :           goto done;</span>
<span class="lineNum">    4337 </span>            :         }
<span class="lineNum">    4338 </span><span class="lineCov">   53364561 :       else if (simplified</span>
<span class="lineNum">    4339 </span><span class="lineCov">    8756224 :                &amp;&amp; TREE_CODE (simplified) == SSA_NAME</span>
<span class="lineNum">    4340 </span><span class="lineCov">    1783071 :                &amp;&amp; TREE_CODE (lhs) == SSA_NAME)</span>
<span class="lineNum">    4341 </span>            :         {
<span class="lineNum">    4342 </span><span class="lineCov">    1783071 :           changed = visit_copy (lhs, simplified);</span>
<span class="lineNum">    4343 </span><span class="lineCov">    1783071 :           goto done;</span>
<span class="lineNum">    4344 </span>            :         }
<span class="lineNum">    4345 </span>            : 
<span class="lineNum">    4346 </span><span class="lineCov">   51581490 :       if ((TREE_CODE (lhs) == SSA_NAME</span>
<span class="lineNum">    4347 </span>            :            /* We can substitute SSA_NAMEs that are live over
<span class="lineNum">    4348 </span>            :               abnormal edges with their constant value.  */
<span class="lineNum">    4349 </span><span class="lineCov">   36018190 :            &amp;&amp; !(gimple_assign_copy_p (ass)</span>
<span class="lineNum">    4350 </span><span class="lineNoCov">          0 :                 &amp;&amp; is_gimple_min_invariant (rhs1))</span>
<span class="lineNum">    4351 </span><span class="lineCov">   36018190 :            &amp;&amp; !(simplified</span>
<span class="lineNum">    4352 </span><span class="lineNoCov">          0 :                 &amp;&amp; is_gimple_min_invariant (simplified))</span>
<span class="lineNum">    4353 </span><span class="lineCov">   36018190 :            &amp;&amp; SSA_NAME_OCCURS_IN_ABNORMAL_PHI (lhs))</span>
<span class="lineNum">    4354 </span>            :           /* Stores or copies from SSA_NAMEs that are live over
<span class="lineNum">    4355 </span>            :              abnormal edges are a problem.  */
<span class="lineNum">    4356 </span><span class="lineCov">   87598797 :           || (code == SSA_NAME</span>
<span class="lineNum">    4357 </span><span class="lineCov">    7161654 :               &amp;&amp; SSA_NAME_OCCURS_IN_ABNORMAL_PHI (rhs1)))</span>
<span class="lineNum">    4358 </span><span class="lineCov">       1045 :         changed = defs_to_varying (ass);</span>
<span class="lineNum">    4359 </span><span class="lineCov">  103160890 :       else if (REFERENCE_CLASS_P (lhs)</span>
<span class="lineNum">    4360 </span><span class="lineCov">   51580445 :                || DECL_P (lhs))</span>
<span class="lineNum">    4361 </span><span class="lineCov">   15563138 :         changed = visit_reference_op_store (lhs, rhs1, ass);</span>
<span class="lineNum">    4362 </span><span class="lineCov">   36017307 :       else if (TREE_CODE (lhs) == SSA_NAME)</span>
<span class="lineNum">    4363 </span>            :         {
<span class="lineNum">    4364 </span><span class="lineCov">   36017307 :           if ((gimple_assign_copy_p (ass)</span>
<span class="lineNum">    4365 </span><span class="lineNoCov">          0 :                &amp;&amp; is_gimple_min_invariant (rhs1))</span>
<span class="lineNum">    4366 </span><span class="lineCov">   36017307 :               || (simplified</span>
<span class="lineNum">    4367 </span><span class="lineNoCov">          0 :                   &amp;&amp; is_gimple_min_invariant (simplified)))</span>
<span class="lineNum">    4368 </span>            :             {
<span class="lineNum">    4369 </span><span class="lineNoCov">          0 :               if (simplified)</span>
<span class="lineNum">    4370 </span><span class="lineNoCov">          0 :                 changed = set_ssa_val_to (lhs, simplified);</span>
<span class="lineNum">    4371 </span>            :               else
<span class="lineNum">    4372 </span><span class="lineNoCov">          0 :                 changed = set_ssa_val_to (lhs, rhs1);</span>
<span class="lineNum">    4373 </span>            :             }
<span class="lineNum">    4374 </span>            :           else
<span class="lineNum">    4375 </span>            :             {
<span class="lineNum">    4376 </span>            :               /* Visit the original statement.  */
<span class="lineNum">    4377 </span><span class="lineCov">   36017307 :               switch (vn_get_stmt_kind (ass))</span>
<span class="lineNum">    4378 </span>            :                 {
<span class="lineNum">    4379 </span><span class="lineCov">   21366195 :                 case VN_NARY:</span>
<span class="lineNum">    4380 </span><span class="lineCov">   21366195 :                 changed = visit_nary_op (lhs, ass);</span>
<span class="lineNum">    4381 </span><span class="lineCov">   21366195 :                 break;</span>
<span class="lineNum">    4382 </span><span class="lineCov">   14633078 :                 case VN_REFERENCE:</span>
<span class="lineNum">    4383 </span><span class="lineCov">   14633078 :                 changed = visit_reference_op_load (lhs, rhs1, ass);</span>
<span class="lineNum">    4384 </span><span class="lineCov">   14633078 :                 break;</span>
<span class="lineNum">    4385 </span><span class="lineCov">      18034 :                 default:</span>
<span class="lineNum">    4386 </span><span class="lineCov">      18034 :                 changed = defs_to_varying (ass);</span>
<span class="lineNum">    4387 </span><span class="lineCov">      18034 :                 break;</span>
<span class="lineNum">    4388 </span>            :                 }
<span class="lineNum">    4389 </span>            :             }
<span class="lineNum">    4390 </span>            :         }
<span class="lineNum">    4391 </span>            :       else
<span class="lineNum">    4392 </span><span class="lineNoCov">          0 :         changed = defs_to_varying (ass);</span>
<span class="lineNum">    4393 </span>            :     }
<span class="lineNum">    4394 </span><span class="lineCov">  133757765 :   else if (gcall *call_stmt = dyn_cast &lt;gcall *&gt; (stmt))</span>
<span class="lineNum">    4395 </span>            :     {
<span class="lineNum">    4396 </span><span class="lineCov">   11672851 :       tree lhs = gimple_call_lhs (call_stmt);</span>
<span class="lineNum">    4397 </span><span class="lineCov">   11672851 :       if (lhs &amp;&amp; TREE_CODE (lhs) == SSA_NAME)</span>
<span class="lineNum">    4398 </span>            :         {
<span class="lineNum">    4399 </span>            :           /* Try constant folding based on our current lattice.  */
<span class="lineNum">    4400 </span><span class="lineCov">    4038572 :           tree simplified = gimple_fold_stmt_to_constant_1 (call_stmt,</span>
<span class="lineNum">    4401 </span><span class="lineCov">    4038572 :                                                             vn_valueize);</span>
<span class="lineNum">    4402 </span><span class="lineCov">    4038572 :           if (simplified)</span>
<span class="lineNum">    4403 </span>            :             {
<span class="lineNum">    4404 </span><span class="lineCov">      25275 :               if (dump_file &amp;&amp; (dump_flags &amp; TDF_DETAILS))</span>
<span class="lineNum">    4405 </span>            :                 {
<span class="lineNum">    4406 </span><span class="lineNoCov">          0 :                   fprintf (dump_file, &quot;call &quot;);</span>
<span class="lineNum">    4407 </span><span class="lineNoCov">          0 :                   print_gimple_expr (dump_file, call_stmt, 0);</span>
<span class="lineNum">    4408 </span><span class="lineNoCov">          0 :                   fprintf (dump_file, &quot; simplified to &quot;);</span>
<span class="lineNum">    4409 </span><span class="lineNoCov">          0 :                   print_generic_expr (dump_file, simplified);</span>
<span class="lineNum">    4410 </span><span class="lineNoCov">          0 :                   fprintf (dump_file, &quot;\n&quot;);</span>
<span class="lineNum">    4411 </span>            :                 }
<span class="lineNum">    4412 </span>            :             }
<span class="lineNum">    4413 </span>            :           /* Setting value numbers to constants will occasionally
<span class="lineNum">    4414 </span>            :              screw up phi congruence because constants are not
<span class="lineNum">    4415 </span>            :              uniquely associated with a single ssa name that can be
<span class="lineNum">    4416 </span>            :              looked up.  */
<span class="lineNum">    4417 </span><span class="lineCov">    4038572 :           if (simplified</span>
<span class="lineNum">    4418 </span><span class="lineCov">    4038572 :               &amp;&amp; is_gimple_min_invariant (simplified))</span>
<span class="lineNum">    4419 </span>            :             {
<span class="lineNum">    4420 </span><span class="lineCov">      19478 :               changed = set_ssa_val_to (lhs, simplified);</span>
<span class="lineNum">    4421 </span><span class="lineCov">      38956 :               if (gimple_vdef (call_stmt))</span>
<span class="lineNum">    4422 </span><span class="lineCov">       1026 :                 changed |= set_ssa_val_to (gimple_vdef (call_stmt),</span>
<span class="lineNum">    4423 </span>            :                                            SSA_VAL (gimple_vuse (call_stmt)));
<span class="lineNum">    4424 </span><span class="lineCov">      19478 :               goto done;</span>
<span class="lineNum">    4425 </span>            :             }
<span class="lineNum">    4426 </span><span class="lineCov">    4019094 :           else if (simplified</span>
<span class="lineNum">    4427 </span><span class="lineCov">       5797 :                    &amp;&amp; TREE_CODE (simplified) == SSA_NAME)</span>
<span class="lineNum">    4428 </span>            :             {
<span class="lineNum">    4429 </span><span class="lineCov">       4929 :               changed = visit_copy (lhs, simplified);</span>
<span class="lineNum">    4430 </span><span class="lineCov">       9858 :               if (gimple_vdef (call_stmt))</span>
<span class="lineNum">    4431 </span><span class="lineCov">          6 :                 changed |= set_ssa_val_to (gimple_vdef (call_stmt),</span>
<span class="lineNum">    4432 </span>            :                                            SSA_VAL (gimple_vuse (call_stmt)));
<span class="lineNum">    4433 </span><span class="lineCov">       4929 :               goto done;</span>
<span class="lineNum">    4434 </span>            :             }
<span class="lineNum">    4435 </span><span class="lineCov">    4014165 :           else if (SSA_NAME_OCCURS_IN_ABNORMAL_PHI (lhs))</span>
<span class="lineNum">    4436 </span>            :             {
<span class="lineNum">    4437 </span><span class="lineCov">        300 :               changed = defs_to_varying (call_stmt);</span>
<span class="lineNum">    4438 </span><span class="lineCov">        300 :               goto done;</span>
<span class="lineNum">    4439 </span>            :             }
<span class="lineNum">    4440 </span>            :         }
<span class="lineNum">    4441 </span>            : 
<span class="lineNum">    4442 </span>            :       /* Pick up flags from a devirtualization target.  */
<span class="lineNum">    4443 </span><span class="lineCov">   11648144 :       tree fn = gimple_call_fn (stmt);</span>
<span class="lineNum">    4444 </span><span class="lineCov">   11648144 :       int extra_fnflags = 0;</span>
<span class="lineNum">    4445 </span><span class="lineCov">   11648144 :       if (fn &amp;&amp; TREE_CODE (fn) == SSA_NAME)</span>
<span class="lineNum">    4446 </span>            :         {
<span class="lineNum">    4447 </span><span class="lineCov">     289377 :           fn = SSA_VAL (fn);</span>
<span class="lineNum">    4448 </span><span class="lineCov">     289377 :           if (TREE_CODE (fn) == ADDR_EXPR</span>
<span class="lineNum">    4449 </span><span class="lineCov">     289377 :               &amp;&amp; TREE_CODE (TREE_OPERAND (fn, 0)) == FUNCTION_DECL)</span>
<span class="lineNum">    4450 </span><span class="lineCov">       3895 :             extra_fnflags = flags_from_decl_or_type (TREE_OPERAND (fn, 0));</span>
<span class="lineNum">    4451 </span>            :         }
<span class="lineNum">    4452 </span><span class="lineCov">   11648144 :       if (!gimple_call_internal_p (call_stmt)</span>
<span class="lineNum">    4453 </span><span class="lineCov">   11648144 :           &amp;&amp; (/* Calls to the same function with the same vuse</span>
<span class="lineNum">    4454 </span>            :                  and the same operands do not necessarily return the same
<span class="lineNum">    4455 </span>            :                  value, unless they're pure or const.  */
<span class="lineNum">    4456 </span><span class="lineCov">   11293579 :               ((gimple_call_flags (call_stmt) | extra_fnflags)</span>
<span class="lineNum">    4457 </span><span class="lineCov">   11293579 :                &amp; (ECF_PURE | ECF_CONST))</span>
<span class="lineNum">    4458 </span>            :               /* If calls have a vdef, subsequent calls won't have
<span class="lineNum">    4459 </span>            :                  the same incoming vuse.  So, if 2 calls with vdef have the
<span class="lineNum">    4460 </span>            :                  same vuse, we know they're not subsequent.
<span class="lineNum">    4461 </span>            :                  We can value number 2 calls to the same function with the
<span class="lineNum">    4462 </span>            :                  same vuse and the same operands which are not subsequent
<span class="lineNum">    4463 </span>            :                  the same, because there is no code in the program that can
<span class="lineNum">    4464 </span>            :                  compare the 2 values...  */
<span class="lineNum">    4465 </span><span class="lineCov">   20718692 :               || (gimple_vdef (call_stmt)</span>
<span class="lineNum">    4466 </span>            :                   /* ... unless the call returns a pointer which does
<span class="lineNum">    4467 </span>            :                      not alias with anything else.  In which case the
<span class="lineNum">    4468 </span>            :                      information that the values are distinct are encoded
<span class="lineNum">    4469 </span>            :                      in the IL.  */
<span class="lineNum">    4470 </span><span class="lineCov">   10354230 :                   &amp;&amp; !(gimple_call_return_flags (call_stmt) &amp; ERF_NOALIAS)</span>
<span class="lineNum">    4471 </span>            :                   /* Only perform the following when being called from PRE
<span class="lineNum">    4472 </span>            :                      which embeds tail merging.  */
<span class="lineNum">    4473 </span><span class="lineCov">   10148107 :                   &amp;&amp; default_vn_walk_kind == VN_WALK)))</span>
<span class="lineNum">    4474 </span><span class="lineCov">    4167617 :         changed = visit_reference_op_call (lhs, call_stmt);</span>
<span class="lineNum">    4475 </span>            :       else
<span class="lineNum">    4476 </span><span class="lineCov">    7480527 :         changed = defs_to_varying (call_stmt);</span>
<span class="lineNum">    4477 </span>            :     }
<span class="lineNum">    4478 </span>            :   else
<span class="lineNum">    4479 </span><span class="lineCov">  122084914 :     changed = defs_to_varying (stmt);</span>
<span class="lineNum">    4480 </span><span class="lineCov">  210523387 :  done:</span>
<span class="lineNum">    4481 </span><span class="lineCov">  210523387 :   return changed;</span>
<span class="lineNum">    4482 </span>            : }
<span class="lineNum">    4483 </span>            : 
<span class="lineNum">    4484 </span>            : 
<span class="lineNum">    4485 </span>            : /* Allocate a value number table.  */
<a name="4486"><span class="lineNum">    4486 </span>            : </a>
<span class="lineNum">    4487 </span>            : static void
<span class="lineNum">    4488 </span><span class="lineCov">    2628835 : allocate_vn_table (vn_tables_t table, unsigned size)</span>
<span class="lineNum">    4489 </span>            : {
<span class="lineNum">    4490 </span><span class="lineCov">    2628835 :   table-&gt;phis = new vn_phi_table_type (size);</span>
<span class="lineNum">    4491 </span><span class="lineCov">    2628835 :   table-&gt;nary = new vn_nary_op_table_type (size);</span>
<span class="lineNum">    4492 </span><span class="lineCov">    2628835 :   table-&gt;references = new vn_reference_table_type (size);</span>
<span class="lineNum">    4493 </span><span class="lineCov">    2628835 : }</span>
<span class="lineNum">    4494 </span>            : 
<span class="lineNum">    4495 </span>            : /* Free a value number table.  */
<a name="4496"><span class="lineNum">    4496 </span>            : </a>
<span class="lineNum">    4497 </span>            : static void
<span class="lineNum">    4498 </span><span class="lineCov">    2628835 : free_vn_table (vn_tables_t table)</span>
<span class="lineNum">    4499 </span>            : {
<span class="lineNum">    4500 </span>            :   /* Walk over elements and release vectors.  */
<span class="lineNum">    4501 </span><span class="lineCov">    2628835 :   vn_reference_iterator_type hir;</span>
<span class="lineNum">    4502 </span><span class="lineCov">    2628835 :   vn_reference_t vr;</span>
<span class="lineNum">    4503 </span><span class="lineCov">   68225495 :   FOR_EACH_HASH_TABLE_ELEMENT (*table-&gt;references, vr, vn_reference_t, hir)</span>
<span class="lineNum">    4504 </span><span class="lineCov">   60338990 :     vr-&gt;operands.release ();</span>
<span class="lineNum">    4505 </span><span class="lineCov">    2628835 :   delete table-&gt;phis;</span>
<span class="lineNum">    4506 </span><span class="lineCov">    2628835 :   table-&gt;phis = NULL;</span>
<span class="lineNum">    4507 </span><span class="lineCov">    2628835 :   delete table-&gt;nary;</span>
<span class="lineNum">    4508 </span><span class="lineCov">    2628835 :   table-&gt;nary = NULL;</span>
<span class="lineNum">    4509 </span><span class="lineCov">    2628835 :   delete table-&gt;references;</span>
<span class="lineNum">    4510 </span><span class="lineCov">    2628835 :   table-&gt;references = NULL;</span>
<span class="lineNum">    4511 </span><span class="lineCov">    2628835 : }</span>
<span class="lineNum">    4512 </span>            : 
<span class="lineNum">    4513 </span>            : /* Set *ID according to RESULT.  */
<a name="4514"><span class="lineNum">    4514 </span>            : </a>
<span class="lineNum">    4515 </span>            : static void
<span class="lineNum">    4516 </span><span class="lineCov">   18963051 : set_value_id_for_result (tree result, unsigned int *id)</span>
<span class="lineNum">    4517 </span>            : {
<span class="lineNum">    4518 </span><span class="lineCov">   18963051 :   if (result &amp;&amp; TREE_CODE (result) == SSA_NAME)</span>
<span class="lineNum">    4519 </span><span class="lineCov">   10929438 :     *id = VN_INFO (result)-&gt;value_id;</span>
<span class="lineNum">    4520 </span><span class="lineCov">    8033613 :   else if (result &amp;&amp; is_gimple_min_invariant (result))</span>
<span class="lineNum">    4521 </span><span class="lineCov">    2302129 :     *id = get_or_alloc_constant_value_id (result);</span>
<span class="lineNum">    4522 </span>            :   else
<span class="lineNum">    4523 </span><span class="lineCov">    5731484 :     *id = get_next_value_id ();</span>
<span class="lineNum">    4524 </span><span class="lineCov">   18963051 : }</span>
<span class="lineNum">    4525 </span>            : 
<span class="lineNum">    4526 </span>            : /* Set the value ids in the valid hash tables.  */
<a name="4527"><span class="lineNum">    4527 </span>            : </a>
<span class="lineNum">    4528 </span>            : static void
<span class="lineNum">    4529 </span><span class="lineCov">     584052 : set_hashtable_value_ids (void)</span>
<span class="lineNum">    4530 </span>            : {
<span class="lineNum">    4531 </span><span class="lineCov">     584052 :   vn_nary_op_iterator_type hin;</span>
<span class="lineNum">    4532 </span><span class="lineCov">     584052 :   vn_phi_iterator_type hip;</span>
<span class="lineNum">    4533 </span><span class="lineCov">     584052 :   vn_reference_iterator_type hir;</span>
<span class="lineNum">    4534 </span><span class="lineCov">     584052 :   vn_nary_op_t vno;</span>
<span class="lineNum">    4535 </span><span class="lineCov">     584052 :   vn_reference_t vr;</span>
<span class="lineNum">    4536 </span><span class="lineCov">     584052 :   vn_phi_t vp;</span>
<span class="lineNum">    4537 </span>            : 
<span class="lineNum">    4538 </span>            :   /* Now set the value ids of the things we had put in the hash
<span class="lineNum">    4539 </span>            :      table.  */
<span class="lineNum">    4540 </span>            : 
<span class="lineNum">    4541 </span><span class="lineCov">   38005485 :   FOR_EACH_HASH_TABLE_ELEMENT (*valid_info-&gt;nary, vno, vn_nary_op_t, hin)</span>
<span class="lineNum">    4542 </span><span class="lineCov">   12084443 :     if (! vno-&gt;predicated_values)</span>
<span class="lineNum">    4543 </span><span class="lineCov">    4183683 :       set_value_id_for_result (vno-&gt;u.result, &amp;vno-&gt;value_id);</span>
<span class="lineNum">    4544 </span>            : 
<span class="lineNum">    4545 </span><span class="lineCov">    5804378 :   FOR_EACH_HASH_TABLE_ELEMENT (*valid_info-&gt;phis, vp, vn_phi_t, hip)</span>
<span class="lineNum">    4546 </span><span class="lineCov">    2026111 :     set_value_id_for_result (vp-&gt;result, &amp;vp-&gt;value_id);</span>
<span class="lineNum">    4547 </span>            : 
<span class="lineNum">    4548 </span><span class="lineCov">   27258670 :   FOR_EACH_HASH_TABLE_ELEMENT (*valid_info-&gt;references, vr, vn_reference_t,</span>
<span class="lineNum">    4549 </span>            :                                hir)
<span class="lineNum">    4550 </span><span class="lineCov">   12753257 :     set_value_id_for_result (vr-&gt;result, &amp;vr-&gt;value_id);</span>
<span class="lineNum">    4551 </span><span class="lineCov">     584052 : }</span>
<span class="lineNum">    4552 </span>            : 
<span class="lineNum">    4553 </span>            : /* Return the maximum value id we have ever seen.  */
<a name="4554"><span class="lineNum">    4554 </span>            : </a>
<span class="lineNum">    4555 </span>            : unsigned int
<span class="lineNum">    4556 </span><span class="lineCov">    5565953 : get_max_value_id (void)</span>
<span class="lineNum">    4557 </span>            : {
<span class="lineNum">    4558 </span><span class="lineCov">    5565953 :   return next_value_id;</span>
<span class="lineNum">    4559 </span>            : }
<span class="lineNum">    4560 </span>            : 
<span class="lineNum">    4561 </span>            : /* Return the next unique value id.  */
<a name="4562"><span class="lineNum">    4562 </span>            : </a>
<span class="lineNum">    4563 </span>            : unsigned int
<span class="lineNum">    4564 </span><span class="lineCov">   30494189 : get_next_value_id (void)</span>
<span class="lineNum">    4565 </span>            : {
<span class="lineNum">    4566 </span><span class="lineCov">   30494189 :   return next_value_id++;</span>
<span class="lineNum">    4567 </span>            : }
<span class="lineNum">    4568 </span>            : 
<span class="lineNum">    4569 </span>            : 
<span class="lineNum">    4570 </span>            : /* Compare two expressions E1 and E2 and return true if they are equal.  */
<a name="4571"><span class="lineNum">    4571 </span>            : </a>
<span class="lineNum">    4572 </span>            : bool
<span class="lineNum">    4573 </span><span class="lineCov">  220089557 : expressions_equal_p (tree e1, tree e2)</span>
<span class="lineNum">    4574 </span>            : {
<span class="lineNum">    4575 </span>            :   /* The obvious case.  */
<span class="lineNum">    4576 </span><span class="lineCov">  220089557 :   if (e1 == e2)</span>
<span class="lineNum">    4577 </span>            :     return true;
<span class="lineNum">    4578 </span>            : 
<span class="lineNum">    4579 </span>            :   /* If either one is VN_TOP consider them equal.  */
<span class="lineNum">    4580 </span><span class="lineCov">   32126993 :   if (e1 == VN_TOP || e2 == VN_TOP)</span>
<span class="lineNum">    4581 </span>            :     return true;
<span class="lineNum">    4582 </span>            : 
<span class="lineNum">    4583 </span>            :   /* If only one of them is null, they cannot be equal.  */
<span class="lineNum">    4584 </span><span class="lineCov">   32126993 :   if (!e1 || !e2)</span>
<span class="lineNum">    4585 </span>            :     return false;
<span class="lineNum">    4586 </span>            : 
<span class="lineNum">    4587 </span>            :   /* Now perform the actual comparison.  */
<span class="lineNum">    4588 </span><span class="lineCov">   32126993 :   if (TREE_CODE (e1) == TREE_CODE (e2)</span>
<span class="lineNum">    4589 </span><span class="lineCov">   32126993 :       &amp;&amp; operand_equal_p (e1, e2, OEP_PURE_SAME))</span>
<span class="lineNum">    4590 </span><span class="lineCov">    1958070 :     return true;</span>
<span class="lineNum">    4591 </span>            : 
<span class="lineNum">    4592 </span>            :   return false;
<span class="lineNum">    4593 </span>            : }
<span class="lineNum">    4594 </span>            : 
<span class="lineNum">    4595 </span>            : 
<span class="lineNum">    4596 </span>            : /* Return true if the nary operation NARY may trap.  This is a copy
<span class="lineNum">    4597 </span>            :    of stmt_could_throw_1_p adjusted to the SCCVN IL.  */
<a name="4598"><span class="lineNum">    4598 </span>            : </a>
<span class="lineNum">    4599 </span>            : bool
<span class="lineNum">    4600 </span><span class="lineCov">    1436466 : vn_nary_may_trap (vn_nary_op_t nary)</span>
<span class="lineNum">    4601 </span>            : {
<span class="lineNum">    4602 </span><span class="lineCov">    1436466 :   tree type;</span>
<span class="lineNum">    4603 </span><span class="lineCov">    1436466 :   tree rhs2 = NULL_TREE;</span>
<span class="lineNum">    4604 </span><span class="lineCov">    1436466 :   bool honor_nans = false;</span>
<span class="lineNum">    4605 </span><span class="lineCov">    1436466 :   bool honor_snans = false;</span>
<span class="lineNum">    4606 </span><span class="lineCov">    1436466 :   bool fp_operation = false;</span>
<span class="lineNum">    4607 </span><span class="lineCov">    1436466 :   bool honor_trapv = false;</span>
<span class="lineNum">    4608 </span><span class="lineCov">    1436466 :   bool handled, ret;</span>
<span class="lineNum">    4609 </span><span class="lineCov">    1436466 :   unsigned i;</span>
<span class="lineNum">    4610 </span>            : 
<span class="lineNum">    4611 </span><span class="lineCov">    2872932 :   if (TREE_CODE_CLASS (nary-&gt;opcode) == tcc_comparison</span>
<span class="lineNum">    4612 </span>            :       || TREE_CODE_CLASS (nary-&gt;opcode) == tcc_unary
<span class="lineNum">    4613 </span><span class="lineCov">    1436466 :       || TREE_CODE_CLASS (nary-&gt;opcode) == tcc_binary)</span>
<span class="lineNum">    4614 </span>            :     {
<span class="lineNum">    4615 </span><span class="lineCov">    1394557 :       type = nary-&gt;type;</span>
<span class="lineNum">    4616 </span><span class="lineCov">    1394557 :       fp_operation = FLOAT_TYPE_P (type);</span>
<span class="lineNum">    4617 </span><span class="lineCov">    1394557 :       if (fp_operation)</span>
<span class="lineNum">    4618 </span>            :         {
<span class="lineNum">    4619 </span><span class="lineCov">      72149 :           honor_nans = flag_trapping_math &amp;&amp; !flag_finite_math_only;</span>
<span class="lineNum">    4620 </span><span class="lineCov">      72149 :           honor_snans = flag_signaling_nans != 0;</span>
<span class="lineNum">    4621 </span>            :         }
<span class="lineNum">    4622 </span><span class="lineCov">    1322408 :       else if (INTEGRAL_TYPE_P (type)</span>
<span class="lineNum">    4623 </span><span class="lineCov">    1322408 :                &amp;&amp; TYPE_OVERFLOW_TRAPS (type))</span>
<span class="lineNum">    4624 </span>            :         honor_trapv = true;
<span class="lineNum">    4625 </span>            :     }
<span class="lineNum">    4626 </span><span class="lineCov">    1436466 :   if (nary-&gt;length &gt;= 2)</span>
<span class="lineNum">    4627 </span><span class="lineCov">    1015228 :     rhs2 = nary-&gt;op[1];</span>
<span class="lineNum">    4628 </span><span class="lineCov">    1436466 :   ret = operation_could_trap_helper_p (nary-&gt;opcode, fp_operation,</span>
<span class="lineNum">    4629 </span>            :                                        honor_trapv,
<span class="lineNum">    4630 </span>            :                                        honor_nans, honor_snans, rhs2,
<span class="lineNum">    4631 </span>            :                                        &amp;handled);
<span class="lineNum">    4632 </span><span class="lineCov">    1436466 :   if (handled</span>
<span class="lineNum">    4633 </span><span class="lineCov">     765675 :       &amp;&amp; ret)</span>
<span class="lineNum">    4634 </span>            :     return true;
<span class="lineNum">    4635 </span>            : 
<span class="lineNum">    4636 </span><span class="lineCov">    3706023 :   for (i = 0; i &lt; nary-&gt;length; ++i)</span>
<span class="lineNum">    4637 </span><span class="lineCov">    2334414 :     if (tree_could_trap_p (nary-&gt;op[i]))</span>
<span class="lineNum">    4638 </span>            :       return true;
<span class="lineNum">    4639 </span>            : 
<span class="lineNum">    4640 </span>            :   return false;
<span class="lineNum">    4641 </span>            : }
<span class="lineNum">    4642 </span>            : 
<span class="lineNum">    4643 </span>            : 
<span class="lineNum">    4644 </span>            : class eliminate_dom_walker : public dom_walker
<span class="lineNum">    4645 </span>            : {
<span class="lineNum">    4646 </span>            : public:
<span class="lineNum">    4647 </span>            :   eliminate_dom_walker (cdi_direction, bitmap);
<span class="lineNum">    4648 </span>            :   ~eliminate_dom_walker ();
<span class="lineNum">    4649 </span>            : 
<span class="lineNum">    4650 </span>            :   virtual edge before_dom_children (basic_block);
<span class="lineNum">    4651 </span>            :   virtual void after_dom_children (basic_block);
<span class="lineNum">    4652 </span>            : 
<span class="lineNum">    4653 </span>            :   virtual tree eliminate_avail (basic_block, tree op);
<span class="lineNum">    4654 </span>            :   virtual void eliminate_push_avail (basic_block, tree op);
<span class="lineNum">    4655 </span>            :   tree eliminate_insert (basic_block, gimple_stmt_iterator *gsi, tree val);
<span class="lineNum">    4656 </span>            : 
<span class="lineNum">    4657 </span>            :   void eliminate_stmt (basic_block, gimple_stmt_iterator *);
<span class="lineNum">    4658 </span>            : 
<span class="lineNum">    4659 </span>            :   unsigned eliminate_cleanup (bool region_p = false);
<span class="lineNum">    4660 </span>            : 
<span class="lineNum">    4661 </span>            :   bool do_pre;
<span class="lineNum">    4662 </span>            :   unsigned int el_todo;
<span class="lineNum">    4663 </span>            :   unsigned int eliminations;
<span class="lineNum">    4664 </span>            :   unsigned int insertions;
<span class="lineNum">    4665 </span>            : 
<span class="lineNum">    4666 </span>            :   /* SSA names that had their defs inserted by PRE if do_pre.  */
<span class="lineNum">    4667 </span>            :   bitmap inserted_exprs;
<span class="lineNum">    4668 </span>            : 
<span class="lineNum">    4669 </span>            :   /* Blocks with statements that have had their EH properties changed.  */
<span class="lineNum">    4670 </span>            :   bitmap need_eh_cleanup;
<span class="lineNum">    4671 </span>            : 
<span class="lineNum">    4672 </span>            :   /* Blocks with statements that have had their AB properties changed.  */
<span class="lineNum">    4673 </span>            :   bitmap need_ab_cleanup;
<span class="lineNum">    4674 </span>            : 
<span class="lineNum">    4675 </span>            :   /* Local state for the eliminate domwalk.  */
<span class="lineNum">    4676 </span>            :   auto_vec&lt;gimple *&gt; to_remove;
<span class="lineNum">    4677 </span>            :   auto_vec&lt;gimple *&gt; to_fixup;
<span class="lineNum">    4678 </span>            :   auto_vec&lt;tree&gt; avail;
<span class="lineNum">    4679 </span>            :   auto_vec&lt;tree&gt; avail_stack;
<a name="4680"><span class="lineNum">    4680 </span>            : };</a>
<span class="lineNum">    4681 </span>            : 
<span class="lineNum">    4682 </span><span class="lineCov">    5157761 : eliminate_dom_walker::eliminate_dom_walker (cdi_direction direction,</span>
<span class="lineNum">    4683 </span><span class="lineCov">    5157761 :                                             bitmap inserted_exprs_)</span>
<span class="lineNum">    4684 </span><span class="lineCov">    5157761 :   : dom_walker (direction), do_pre (inserted_exprs_ != NULL),</span>
<span class="lineNum">    4685 </span>            :     el_todo (0), eliminations (0), insertions (0),
<span class="lineNum">    4686 </span><span class="lineCov">    5157761 :     inserted_exprs (inserted_exprs_)</span>
<span class="lineNum">    4687 </span>            : {
<span class="lineNum">    4688 </span><span class="lineCov">    5157761 :   need_eh_cleanup = BITMAP_ALLOC (NULL);</span>
<span class="lineNum">    4689 </span><span class="lineCov">    5157761 :   need_ab_cleanup = BITMAP_ALLOC (NULL);</span>
<a name="4690"><span class="lineNum">    4690 </span><span class="lineCov">    5157761 : }</span></a>
<span class="lineNum">    4691 </span>            : 
<span class="lineNum">    4692 </span><span class="lineCov">    7700251 : eliminate_dom_walker::~eliminate_dom_walker ()</span>
<span class="lineNum">    4693 </span>            : {
<span class="lineNum">    4694 </span><span class="lineCov">    5157761 :   BITMAP_FREE (need_eh_cleanup);</span>
<span class="lineNum">    4695 </span><span class="lineCov">    5157761 :   BITMAP_FREE (need_ab_cleanup);</span>
<span class="lineNum">    4696 </span><span class="lineCov">    5157761 : }</span>
<span class="lineNum">    4697 </span>            : 
<span class="lineNum">    4698 </span>            : /* Return a leader for OP that is available at the current point of the
<span class="lineNum">    4699 </span>            :    eliminate domwalk.  */
<a name="4700"><span class="lineNum">    4700 </span>            : </a>
<span class="lineNum">    4701 </span>            : tree
<span class="lineNum">    4702 </span><span class="lineCov">  103408147 : eliminate_dom_walker::eliminate_avail (basic_block, tree op)</span>
<span class="lineNum">    4703 </span>            : {
<span class="lineNum">    4704 </span><span class="lineCov">  103408147 :   tree valnum = VN_INFO (op)-&gt;valnum;</span>
<span class="lineNum">    4705 </span><span class="lineCov">  103408147 :   if (TREE_CODE (valnum) == SSA_NAME)</span>
<span class="lineNum">    4706 </span>            :     {
<span class="lineNum">    4707 </span><span class="lineCov">  200606254 :       if (SSA_NAME_IS_DEFAULT_DEF (valnum))</span>
<span class="lineNum">    4708 </span>            :         return valnum;
<span class="lineNum">    4709 </span><span class="lineCov">  260978210 :       if (avail.length () &gt; SSA_NAME_VERSION (valnum))</span>
<span class="lineNum">    4710 </span><span class="lineCov">  157380532 :         return avail[SSA_NAME_VERSION (valnum)];</span>
<span class="lineNum">    4711 </span>            :     }
<span class="lineNum">    4712 </span><span class="lineCov">    3105020 :   else if (is_gimple_min_invariant (valnum))</span>
<span class="lineNum">    4713 </span><span class="lineCov">    3105020 :     return valnum;</span>
<span class="lineNum">    4714 </span>            :   return NULL_TREE;
<span class="lineNum">    4715 </span>            : }
<span class="lineNum">    4716 </span>            : 
<span class="lineNum">    4717 </span>            : /* At the current point of the eliminate domwalk make OP available.  */
<a name="4718"><span class="lineNum">    4718 </span>            : </a>
<span class="lineNum">    4719 </span>            : void
<span class="lineNum">    4720 </span><span class="lineCov">   29224094 : eliminate_dom_walker::eliminate_push_avail (basic_block, tree op)</span>
<span class="lineNum">    4721 </span>            : {
<span class="lineNum">    4722 </span><span class="lineCov">   29224094 :   tree valnum = VN_INFO (op)-&gt;valnum;</span>
<span class="lineNum">    4723 </span><span class="lineCov">   29224094 :   if (TREE_CODE (valnum) == SSA_NAME)</span>
<span class="lineNum">    4724 </span>            :     {
<span class="lineNum">    4725 </span><span class="lineCov">   83730274 :       if (avail.length () &lt;= SSA_NAME_VERSION (valnum))</span>
<span class="lineNum">    4726 </span><span class="lineCov">   20406528 :         avail.safe_grow_cleared (SSA_NAME_VERSION (valnum) + 1);</span>
<span class="lineNum">    4727 </span><span class="lineCov">   29224094 :       tree pushop = op;</span>
<span class="lineNum">    4728 </span><span class="lineCov">   29224094 :       if (avail[SSA_NAME_VERSION (valnum)])</span>
<span class="lineNum">    4729 </span><span class="lineCov">      20235 :         pushop = avail[SSA_NAME_VERSION (valnum)];</span>
<span class="lineNum">    4730 </span><span class="lineCov">   29224094 :       avail_stack.safe_push (pushop);</span>
<span class="lineNum">    4731 </span><span class="lineCov">   29224094 :       avail[SSA_NAME_VERSION (valnum)] = op;</span>
<span class="lineNum">    4732 </span>            :     }
<span class="lineNum">    4733 </span><span class="lineCov">   29224094 : }</span>
<span class="lineNum">    4734 </span>            : 
<span class="lineNum">    4735 </span>            : /* Insert the expression recorded by SCCVN for VAL at *GSI.  Returns
<span class="lineNum">    4736 </span>            :    the leader for the expression if insertion was successful.  */
<a name="4737"><span class="lineNum">    4737 </span>            : </a>
<span class="lineNum">    4738 </span>            : tree
<span class="lineNum">    4739 </span><span class="lineCov">       7203 : eliminate_dom_walker::eliminate_insert (basic_block bb,</span>
<span class="lineNum">    4740 </span>            :                                         gimple_stmt_iterator *gsi, tree val)
<span class="lineNum">    4741 </span>            : {
<span class="lineNum">    4742 </span>            :   /* We can insert a sequence with a single assignment only.  */
<span class="lineNum">    4743 </span><span class="lineCov">       7203 :   gimple_seq stmts = VN_INFO (val)-&gt;expr;</span>
<span class="lineNum">    4744 </span><span class="lineCov">       7203 :   if (!gimple_seq_singleton_p (stmts))</span>
<span class="lineNum">    4745 </span>            :     return NULL_TREE;
<span class="lineNum">    4746 </span><span class="lineCov">      14406 :   gassign *stmt = dyn_cast &lt;gassign *&gt; (gimple_seq_first_stmt (stmts));</span>
<span class="lineNum">    4747 </span><span class="lineCov">       7203 :   if (!stmt</span>
<span class="lineNum">    4748 </span><span class="lineCov">      11500 :       || (!CONVERT_EXPR_CODE_P (gimple_assign_rhs_code (stmt))</span>
<span class="lineNum">    4749 </span><span class="lineCov">       8606 :           &amp;&amp; gimple_assign_rhs_code (stmt) != VIEW_CONVERT_EXPR</span>
<span class="lineNum">    4750 </span><span class="lineCov">       7940 :           &amp;&amp; gimple_assign_rhs_code (stmt) != BIT_FIELD_REF</span>
<span class="lineNum">    4751 </span><span class="lineCov">         12 :           &amp;&amp; (gimple_assign_rhs_code (stmt) != BIT_AND_EXPR</span>
<span class="lineNum">    4752 </span><span class="lineCov">         12 :               || TREE_CODE (gimple_assign_rhs2 (stmt)) != INTEGER_CST)))</span>
<span class="lineNum">    4753 </span>            :     return NULL_TREE;
<span class="lineNum">    4754 </span>            : 
<span class="lineNum">    4755 </span><span class="lineCov">       7203 :   tree op = gimple_assign_rhs1 (stmt);</span>
<span class="lineNum">    4756 </span><span class="lineCov">       7203 :   if (gimple_assign_rhs_code (stmt) == VIEW_CONVERT_EXPR</span>
<span class="lineNum">    4757 </span><span class="lineCov">       7203 :       || gimple_assign_rhs_code (stmt) == BIT_FIELD_REF)</span>
<span class="lineNum">    4758 </span><span class="lineCov">       4297 :     op = TREE_OPERAND (op, 0);</span>
<span class="lineNum">    4759 </span><span class="lineCov">       7203 :   tree leader = TREE_CODE (op) == SSA_NAME ? eliminate_avail (bb, op) : op;</span>
<span class="lineNum">    4760 </span><span class="lineCov">       7203 :   if (!leader)</span>
<span class="lineNum">    4761 </span>            :     return NULL_TREE;
<span class="lineNum">    4762 </span>            : 
<span class="lineNum">    4763 </span><span class="lineCov">       5146 :   tree res;</span>
<span class="lineNum">    4764 </span><span class="lineCov">       5146 :   stmts = NULL;</span>
<span class="lineNum">    4765 </span><span class="lineCov">       9334 :   if (gimple_assign_rhs_code (stmt) == BIT_FIELD_REF)</span>
<span class="lineNum">    4766 </span><span class="lineCov">       3953 :     res = gimple_build (&amp;stmts, BIT_FIELD_REF,</span>
<span class="lineNum">    4767 </span><span class="lineCov">       3953 :                         TREE_TYPE (val), leader,</span>
<span class="lineNum">    4768 </span><span class="lineCov">       7906 :                         TREE_OPERAND (gimple_assign_rhs1 (stmt), 1),</span>
<span class="lineNum">    4769 </span><span class="lineCov">       7906 :                         TREE_OPERAND (gimple_assign_rhs1 (stmt), 2));</span>
<span class="lineNum">    4770 </span><span class="lineCov">       2386 :   else if (gimple_assign_rhs_code (stmt) == BIT_AND_EXPR)</span>
<span class="lineNum">    4771 </span><span class="lineCov">         12 :     res = gimple_build (&amp;stmts, BIT_AND_EXPR,</span>
<span class="lineNum">    4772 </span><span class="lineCov">          6 :                         TREE_TYPE (val), leader, gimple_assign_rhs2 (stmt));</span>
<span class="lineNum">    4773 </span>            :   else
<span class="lineNum">    4774 </span><span class="lineCov">       2374 :     res = gimple_build (&amp;stmts, gimple_assign_rhs_code (stmt),</span>
<span class="lineNum">    4775 </span><span class="lineCov">       1187 :                         TREE_TYPE (val), leader);</span>
<span class="lineNum">    4776 </span><span class="lineCov">       5146 :   if (TREE_CODE (res) != SSA_NAME</span>
<span class="lineNum">    4777 </span><span class="lineCov">      10292 :       || SSA_NAME_IS_DEFAULT_DEF (res)</span>
<span class="lineNum">    4778 </span><span class="lineCov">      20584 :       || gimple_bb (SSA_NAME_DEF_STMT (res)))</span>
<span class="lineNum">    4779 </span>            :     {
<span class="lineNum">    4780 </span><span class="lineNoCov">          0 :       gimple_seq_discard (stmts);</span>
<span class="lineNum">    4781 </span>            : 
<span class="lineNum">    4782 </span>            :       /* During propagation we have to treat SSA info conservatively
<span class="lineNum">    4783 </span>            :          and thus we can end up simplifying the inserted expression
<span class="lineNum">    4784 </span>            :          at elimination time to sth not defined in stmts.  */
<span class="lineNum">    4785 </span>            :       /* But then this is a redundancy we failed to detect.  Which means
<span class="lineNum">    4786 </span>            :          res now has two values.  That doesn't play well with how
<span class="lineNum">    4787 </span>            :          we track availability here, so give up.  */
<span class="lineNum">    4788 </span><span class="lineNoCov">          0 :       if (dump_file &amp;&amp; (dump_flags &amp; TDF_DETAILS))</span>
<span class="lineNum">    4789 </span>            :         {
<span class="lineNum">    4790 </span><span class="lineNoCov">          0 :           if (TREE_CODE (res) == SSA_NAME)</span>
<span class="lineNum">    4791 </span><span class="lineNoCov">          0 :             res = eliminate_avail (bb, res);</span>
<span class="lineNum">    4792 </span><span class="lineNoCov">          0 :           if (res)</span>
<span class="lineNum">    4793 </span>            :             {
<span class="lineNum">    4794 </span><span class="lineNoCov">          0 :               fprintf (dump_file, &quot;Failed to insert expression for value &quot;);</span>
<span class="lineNum">    4795 </span><span class="lineNoCov">          0 :               print_generic_expr (dump_file, val);</span>
<span class="lineNum">    4796 </span><span class="lineNoCov">          0 :               fprintf (dump_file, &quot; which is really fully redundant to &quot;);</span>
<span class="lineNum">    4797 </span><span class="lineNoCov">          0 :               print_generic_expr (dump_file, res);</span>
<span class="lineNum">    4798 </span><span class="lineNoCov">          0 :               fprintf (dump_file, &quot;\n&quot;);</span>
<span class="lineNum">    4799 </span>            :             }
<span class="lineNum">    4800 </span>            :         }
<span class="lineNum">    4801 </span>            : 
<span class="lineNum">    4802 </span><span class="lineNoCov">          0 :       return NULL_TREE;</span>
<span class="lineNum">    4803 </span>            :     }
<span class="lineNum">    4804 </span>            :   else
<span class="lineNum">    4805 </span>            :     {
<span class="lineNum">    4806 </span><span class="lineCov">       5146 :       gsi_insert_seq_before (gsi, stmts, GSI_SAME_STMT);</span>
<span class="lineNum">    4807 </span><span class="lineCov">       5146 :       VN_INFO (res)-&gt;valnum = val;</span>
<span class="lineNum">    4808 </span><span class="lineCov">       5146 :       VN_INFO (res)-&gt;visited = true;</span>
<span class="lineNum">    4809 </span>            :     }
<span class="lineNum">    4810 </span>            : 
<span class="lineNum">    4811 </span><span class="lineCov">       5146 :   insertions++;</span>
<span class="lineNum">    4812 </span><span class="lineCov">       5146 :   if (dump_file &amp;&amp; (dump_flags &amp; TDF_DETAILS))</span>
<span class="lineNum">    4813 </span>            :     {
<span class="lineNum">    4814 </span><span class="lineCov">          7 :       fprintf (dump_file, &quot;Inserted &quot;);</span>
<span class="lineNum">    4815 </span><span class="lineCov">          7 :       print_gimple_stmt (dump_file, SSA_NAME_DEF_STMT (res), 0);</span>
<span class="lineNum">    4816 </span>            :     }
<span class="lineNum">    4817 </span>            : 
<span class="lineNum">    4818 </span>            :   return res;
<span class="lineNum">    4819 </span>            : }
<a name="4820"><span class="lineNum">    4820 </span>            : </a>
<span class="lineNum">    4821 </span>            : void
<span class="lineNum">    4822 </span><span class="lineCov">  157573148 : eliminate_dom_walker::eliminate_stmt (basic_block b, gimple_stmt_iterator *gsi)</span>
<span class="lineNum">    4823 </span>            : {
<span class="lineNum">    4824 </span><span class="lineCov">  157573148 :   tree sprime = NULL_TREE;</span>
<span class="lineNum">    4825 </span><span class="lineCov">  157573148 :   gimple *stmt = gsi_stmt (*gsi);</span>
<span class="lineNum">    4826 </span><span class="lineCov">  157573148 :   tree lhs = gimple_get_lhs (stmt);</span>
<span class="lineNum">    4827 </span><span class="lineCov">   51511220 :   if (lhs &amp;&amp; TREE_CODE (lhs) == SSA_NAME</span>
<span class="lineNum">    4828 </span><span class="lineCov">   69445488 :       &amp;&amp; !gimple_has_volatile_ops (stmt)</span>
<span class="lineNum">    4829 </span>            :       /* See PR43491.  Do not replace a global register variable when
<span class="lineNum">    4830 </span>            :          it is a the RHS of an assignment.  Do replace local register
<span class="lineNum">    4831 </span>            :          variables since gcc does not guarantee a local variable will
<span class="lineNum">    4832 </span>            :          be allocated in register.
<span class="lineNum">    4833 </span>            :          ???  The fix isn't effective here.  This should instead
<span class="lineNum">    4834 </span>            :          be ensured by not value-numbering them the same but treating
<span class="lineNum">    4835 </span>            :          them like volatiles?  */
<span class="lineNum">    4836 </span><span class="lineCov">  191562000 :       &amp;&amp; !(gimple_assign_single_p (stmt)</span>
<span class="lineNum">    4837 </span><span class="lineCov">   31813922 :            &amp;&amp; (TREE_CODE (gimple_assign_rhs1 (stmt)) == VAR_DECL</span>
<span class="lineNum">    4838 </span><span class="lineCov">    2948382 :                &amp;&amp; DECL_HARD_REGISTER (gimple_assign_rhs1 (stmt))</span>
<span class="lineNum">    4839 </span><span class="lineCov">       2598 :                &amp;&amp; is_global_var (gimple_assign_rhs1 (stmt)))))</span>
<span class="lineNum">    4840 </span>            :     {
<span class="lineNum">    4841 </span><span class="lineCov">   33988757 :       sprime = eliminate_avail (b, lhs);</span>
<span class="lineNum">    4842 </span><span class="lineCov">   33988757 :       if (!sprime)</span>
<span class="lineNum">    4843 </span>            :         {
<span class="lineNum">    4844 </span>            :           /* If there is no existing usable leader but SCCVN thinks
<span class="lineNum">    4845 </span>            :              it has an expression it wants to use as replacement,
<span class="lineNum">    4846 </span>            :              insert that.  */
<span class="lineNum">    4847 </span><span class="lineCov">   27015581 :           tree val = VN_INFO (lhs)-&gt;valnum;</span>
<span class="lineNum">    4848 </span><span class="lineCov">   27015581 :           if (val != VN_TOP</span>
<span class="lineNum">    4849 </span><span class="lineCov">   27015581 :               &amp;&amp; TREE_CODE (val) == SSA_NAME</span>
<span class="lineNum">    4850 </span><span class="lineCov">   27015581 :               &amp;&amp; VN_INFO (val)-&gt;needs_insertion</span>
<span class="lineNum">    4851 </span><span class="lineCov">     321610 :               &amp;&amp; VN_INFO (val)-&gt;expr != NULL</span>
<span class="lineNum">    4852 </span><span class="lineCov">   27022784 :               &amp;&amp; (sprime = eliminate_insert (b, gsi, val)) != NULL_TREE)</span>
<span class="lineNum">    4853 </span><span class="lineCov">       5146 :             eliminate_push_avail (b, sprime);</span>
<span class="lineNum">    4854 </span>            :         }
<span class="lineNum">    4855 </span>            : 
<span class="lineNum">    4856 </span>            :       /* If this now constitutes a copy duplicate points-to
<span class="lineNum">    4857 </span>            :          and range info appropriately.  This is especially
<span class="lineNum">    4858 </span>            :          important for inserted code.  See tree-ssa-copy.c
<span class="lineNum">    4859 </span>            :          for similar code.  */
<span class="lineNum">    4860 </span><span class="lineCov">   33988757 :       if (sprime</span>
<span class="lineNum">    4861 </span><span class="lineCov">    6978322 :           &amp;&amp; TREE_CODE (sprime) == SSA_NAME)</span>
<span class="lineNum">    4862 </span>            :         {
<span class="lineNum">    4863 </span><span class="lineCov">    9836444 :           basic_block sprime_b = gimple_bb (SSA_NAME_DEF_STMT (sprime));</span>
<span class="lineNum">    4864 </span><span class="lineCov">   10473484 :           if (POINTER_TYPE_P (TREE_TYPE (lhs))</span>
<span class="lineNum">    4865 </span><span class="lineCov">    2190185 :               &amp;&amp; SSA_NAME_PTR_INFO (lhs)</span>
<span class="lineNum">    4866 </span><span class="lineCov">    9264938 :               &amp;&amp; ! SSA_NAME_PTR_INFO (sprime))</span>
<span class="lineNum">    4867 </span>            :             {
<span class="lineNum">    4868 </span><span class="lineCov">     178360 :               duplicate_ssa_name_ptr_info (sprime,</span>
<span class="lineNum">    4869 </span><span class="lineCov">     178360 :                                            SSA_NAME_PTR_INFO (lhs));</span>
<span class="lineNum">    4870 </span><span class="lineCov">      89180 :               if (b != sprime_b)</span>
<span class="lineNum">    4871 </span><span class="lineCov">      29565 :                 mark_ptr_info_alignment_unknown</span>
<span class="lineNum">    4872 </span><span class="lineCov">      29565 :                     (SSA_NAME_PTR_INFO (sprime));</span>
<span class="lineNum">    4873 </span>            :             }
<span class="lineNum">    4874 </span><span class="lineCov">    4829042 :           else if (INTEGRAL_TYPE_P (TREE_TYPE (lhs))</span>
<span class="lineNum">    4875 </span><span class="lineCov">    2573955 :                    &amp;&amp; SSA_NAME_RANGE_INFO (lhs)</span>
<span class="lineNum">    4876 </span><span class="lineCov">     951590 :                    &amp;&amp; ! SSA_NAME_RANGE_INFO (sprime)</span>
<span class="lineNum">    4877 </span><span class="lineCov">    4931261 :                    &amp;&amp; b == sprime_b)</span>
<span class="lineNum">    4878 </span><span class="lineCov">      37127 :             duplicate_ssa_name_range_info (sprime,</span>
<span class="lineNum">    4879 </span><span class="lineCov">      37127 :                                            SSA_NAME_RANGE_TYPE (lhs),</span>
<span class="lineNum">    4880 </span><span class="lineCov">      74254 :                                            SSA_NAME_RANGE_INFO (lhs));</span>
<span class="lineNum">    4881 </span>            :         }
<span class="lineNum">    4882 </span>            : 
<span class="lineNum">    4883 </span>            :       /* Inhibit the use of an inserted PHI on a loop header when
<span class="lineNum">    4884 </span>            :          the address of the memory reference is a simple induction
<span class="lineNum">    4885 </span>            :          variable.  In other cases the vectorizer won't do anything
<span class="lineNum">    4886 </span>            :          anyway (either it's loop invariant or a complicated
<span class="lineNum">    4887 </span>            :          expression).  */
<span class="lineNum">    4888 </span><span class="lineCov">   33988757 :       if (sprime</span>
<span class="lineNum">    4889 </span><span class="lineCov">    6978322 :           &amp;&amp; TREE_CODE (sprime) == SSA_NAME</span>
<span class="lineNum">    4890 </span><span class="lineCov">    4918222 :           &amp;&amp; do_pre</span>
<span class="lineNum">    4891 </span><span class="lineCov">     505855 :           &amp;&amp; (flag_tree_loop_vectorize || flag_tree_parallelize_loops &gt; 1)</span>
<span class="lineNum">    4892 </span><span class="lineCov">     199953 :           &amp;&amp; loop_outer (b-&gt;loop_father)</span>
<span class="lineNum">    4893 </span><span class="lineCov">      84283 :           &amp;&amp; has_zero_uses (sprime)</span>
<span class="lineNum">    4894 </span><span class="lineCov">      78510 :           &amp;&amp; bitmap_bit_p (inserted_exprs, SSA_NAME_VERSION (sprime))</span>
<span class="lineNum">    4895 </span><span class="lineCov">   34027591 :           &amp;&amp; gimple_assign_load_p (stmt))</span>
<span class="lineNum">    4896 </span>            :         {
<span class="lineNum">    4897 </span><span class="lineCov">      13667 :           gimple *def_stmt = SSA_NAME_DEF_STMT (sprime);</span>
<span class="lineNum">    4898 </span><span class="lineCov">      13667 :           basic_block def_bb = gimple_bb (def_stmt);</span>
<span class="lineNum">    4899 </span><span class="lineCov">      13667 :           if (gimple_code (def_stmt) == GIMPLE_PHI</span>
<span class="lineNum">    4900 </span><span class="lineCov">      13667 :               &amp;&amp; def_bb-&gt;loop_father-&gt;header == def_bb)</span>
<span class="lineNum">    4901 </span>            :             {
<span class="lineNum">    4902 </span><span class="lineCov">      10033 :               loop_p loop = def_bb-&gt;loop_father;</span>
<span class="lineNum">    4903 </span><span class="lineCov">      10033 :               ssa_op_iter iter;</span>
<span class="lineNum">    4904 </span><span class="lineCov">      10033 :               tree op;</span>
<span class="lineNum">    4905 </span><span class="lineCov">      10033 :               bool found = false;</span>
<span class="lineNum">    4906 </span><span class="lineCov">      13704 :               FOR_EACH_SSA_TREE_OPERAND (op, stmt, iter, SSA_OP_USE)</span>
<span class="lineNum">    4907 </span>            :                 {
<span class="lineNum">    4908 </span><span class="lineCov">      10405 :                   affine_iv iv;</span>
<span class="lineNum">    4909 </span><span class="lineCov">      10405 :                   def_bb = gimple_bb (SSA_NAME_DEF_STMT (op));</span>
<span class="lineNum">    4910 </span><span class="lineCov">      10405 :                   if (def_bb</span>
<span class="lineNum">    4911 </span><span class="lineCov">       9843 :                       &amp;&amp; flow_bb_inside_loop_p (loop, def_bb)</span>
<span class="lineNum">    4912 </span><span class="lineCov">      19235 :                       &amp;&amp; simple_iv (loop, loop, op, &amp;iv, true))</span>
<span class="lineNum">    4913 </span>            :                     {
<span class="lineNum">    4914 </span><span class="lineCov">       6734 :                       found = true;</span>
<span class="lineNum">    4915 </span><span class="lineCov">       6734 :                       break;</span>
<span class="lineNum">    4916 </span>            :                     }
<span class="lineNum">    4917 </span>            :                 }
<span class="lineNum">    4918 </span><span class="lineCov">       3299 :               if (found)</span>
<span class="lineNum">    4919 </span>            :                 {
<span class="lineNum">    4920 </span><span class="lineCov">       6734 :                   if (dump_file &amp;&amp; (dump_flags &amp; TDF_DETAILS))</span>
<span class="lineNum">    4921 </span>            :                     {
<span class="lineNum">    4922 </span><span class="lineNoCov">          0 :                       fprintf (dump_file, &quot;Not replacing &quot;);</span>
<span class="lineNum">    4923 </span><span class="lineNoCov">          0 :                       print_gimple_expr (dump_file, stmt, 0);</span>
<span class="lineNum">    4924 </span><span class="lineNoCov">          0 :                       fprintf (dump_file, &quot; with &quot;);</span>
<span class="lineNum">    4925 </span><span class="lineNoCov">          0 :                       print_generic_expr (dump_file, sprime);</span>
<span class="lineNum">    4926 </span><span class="lineNoCov">          0 :                       fprintf (dump_file, &quot; which would add a loop&quot;</span>
<span class="lineNum">    4927 </span>            :                                &quot; carried dependence to loop %d\n&quot;,
<span class="lineNum">    4928 </span>            :                                loop-&gt;num);
<span class="lineNum">    4929 </span>            :                     }
<span class="lineNum">    4930 </span>            :                   /* Don't keep sprime available.  */
<span class="lineNum">    4931 </span><span class="lineCov">       6734 :                   sprime = NULL_TREE;</span>
<span class="lineNum">    4932 </span>            :                 }
<span class="lineNum">    4933 </span>            :             }
<span class="lineNum">    4934 </span>            :         }
<span class="lineNum">    4935 </span>            : 
<span class="lineNum">    4936 </span><span class="lineCov">   33988757 :       if (sprime)</span>
<span class="lineNum">    4937 </span>            :         {
<span class="lineNum">    4938 </span>            :           /* If we can propagate the value computed for LHS into
<span class="lineNum">    4939 </span>            :              all uses don't bother doing anything with this stmt.  */
<span class="lineNum">    4940 </span><span class="lineCov">    6971588 :           if (may_propagate_copy (lhs, sprime))</span>
<span class="lineNum">    4941 </span>            :             {
<span class="lineNum">    4942 </span>            :               /* Mark it for removal.  */
<span class="lineNum">    4943 </span><span class="lineCov">    6970616 :               to_remove.safe_push (stmt);</span>
<span class="lineNum">    4944 </span>            : 
<span class="lineNum">    4945 </span>            :               /* ???  Don't count copy/constant propagations.  */
<span class="lineNum">    4946 </span><span class="lineCov">    6970616 :               if (gimple_assign_single_p (stmt)</span>
<span class="lineNum">    4947 </span><span class="lineCov">   11040936 :                   &amp;&amp; (TREE_CODE (gimple_assign_rhs1 (stmt)) == SSA_NAME</span>
<span class="lineNum">    4948 </span><span class="lineCov">    4868234 :                       || gimple_assign_rhs1 (stmt) == sprime))</span>
<span class="lineNum">    4949 </span>            :                 return;
<span class="lineNum">    4950 </span>            : 
<span class="lineNum">    4951 </span><span class="lineCov">    2850902 :               if (dump_file &amp;&amp; (dump_flags &amp; TDF_DETAILS))</span>
<span class="lineNum">    4952 </span>            :                 {
<span class="lineNum">    4953 </span><span class="lineCov">        393 :                   fprintf (dump_file, &quot;Replaced &quot;);</span>
<span class="lineNum">    4954 </span><span class="lineCov">        393 :                   print_gimple_expr (dump_file, stmt, 0);</span>
<span class="lineNum">    4955 </span><span class="lineCov">        393 :                   fprintf (dump_file, &quot; with &quot;);</span>
<span class="lineNum">    4956 </span><span class="lineCov">        393 :                   print_generic_expr (dump_file, sprime);</span>
<span class="lineNum">    4957 </span><span class="lineCov">        393 :                   fprintf (dump_file, &quot; in all uses of &quot;);</span>
<span class="lineNum">    4958 </span><span class="lineCov">        393 :                   print_gimple_stmt (dump_file, stmt, 0);</span>
<span class="lineNum">    4959 </span>            :                 }
<span class="lineNum">    4960 </span>            : 
<span class="lineNum">    4961 </span><span class="lineCov">    2850902 :               eliminations++;</span>
<span class="lineNum">    4962 </span><span class="lineCov">    2850902 :               return;</span>
<span class="lineNum">    4963 </span>            :             }
<span class="lineNum">    4964 </span>            : 
<span class="lineNum">    4965 </span>            :           /* If this is an assignment from our leader (which
<span class="lineNum">    4966 </span>            :              happens in the case the value-number is a constant)
<span class="lineNum">    4967 </span>            :              then there is nothing to do.  */
<span class="lineNum">    4968 </span><span class="lineCov">        972 :           if (gimple_assign_single_p (stmt)</span>
<span class="lineNum">    4969 </span><span class="lineCov">       1944 :               &amp;&amp; sprime == gimple_assign_rhs1 (stmt))</span>
<span class="lineNum">    4970 </span>            :             return;
<span class="lineNum">    4971 </span>            : 
<span class="lineNum">    4972 </span>            :           /* Else replace its RHS.  */
<span class="lineNum">    4973 </span><span class="lineCov">          6 :           bool can_make_abnormal_goto</span>
<span class="lineNum">    4974 </span><span class="lineCov">          6 :               = is_gimple_call (stmt)</span>
<span class="lineNum">    4975 </span><span class="lineCov">          6 :               &amp;&amp; stmt_can_make_abnormal_goto (stmt);</span>
<span class="lineNum">    4976 </span>            : 
<span class="lineNum">    4977 </span><span class="lineCov">          6 :           if (dump_file &amp;&amp; (dump_flags &amp; TDF_DETAILS))</span>
<span class="lineNum">    4978 </span>            :             {
<span class="lineNum">    4979 </span><span class="lineNoCov">          0 :               fprintf (dump_file, &quot;Replaced &quot;);</span>
<span class="lineNum">    4980 </span><span class="lineNoCov">          0 :               print_gimple_expr (dump_file, stmt, 0);</span>
<span class="lineNum">    4981 </span><span class="lineNoCov">          0 :               fprintf (dump_file, &quot; with &quot;);</span>
<span class="lineNum">    4982 </span><span class="lineNoCov">          0 :               print_generic_expr (dump_file, sprime);</span>
<span class="lineNum">    4983 </span><span class="lineNoCov">          0 :               fprintf (dump_file, &quot; in &quot;);</span>
<span class="lineNum">    4984 </span><span class="lineNoCov">          0 :               print_gimple_stmt (dump_file, stmt, 0);</span>
<span class="lineNum">    4985 </span>            :             }
<span class="lineNum">    4986 </span>            : 
<span class="lineNum">    4987 </span><span class="lineCov">          6 :           eliminations++;</span>
<span class="lineNum">    4988 </span><span class="lineCov">          6 :           gimple *orig_stmt = stmt;</span>
<span class="lineNum">    4989 </span><span class="lineCov">          6 :           if (!useless_type_conversion_p (TREE_TYPE (lhs),</span>
<span class="lineNum">    4990 </span><span class="lineCov">          6 :                                           TREE_TYPE (sprime)))</span>
<span class="lineNum">    4991 </span><span class="lineCov">          6 :             sprime = fold_convert (TREE_TYPE (lhs), sprime);</span>
<span class="lineNum">    4992 </span><span class="lineCov">          6 :           tree vdef = gimple_vdef (stmt);</span>
<span class="lineNum">    4993 </span><span class="lineCov">          6 :           tree vuse = gimple_vuse (stmt);</span>
<span class="lineNum">    4994 </span><span class="lineCov">          6 :           propagate_tree_value_into_stmt (gsi, sprime);</span>
<span class="lineNum">    4995 </span><span class="lineCov">          6 :           stmt = gsi_stmt (*gsi);</span>
<span class="lineNum">    4996 </span><span class="lineCov">          6 :           update_stmt (stmt);</span>
<span class="lineNum">    4997 </span>            :           /* In case the VDEF on the original stmt was released, value-number
<span class="lineNum">    4998 </span>            :              it to the VUSE.  This is to make vuse_ssa_val able to skip
<span class="lineNum">    4999 </span>            :              released virtual operands.  */
<span class="lineNum">    5000 </span><span class="lineCov">         12 :           if (vdef != gimple_vdef (stmt))</span>
<span class="lineNum">    5001 </span>            :             {
<span class="lineNum">    5002 </span><span class="lineNoCov">          0 :               gcc_assert (SSA_NAME_IN_FREE_LIST (vdef));</span>
<span class="lineNum">    5003 </span><span class="lineNoCov">          0 :               VN_INFO (vdef)-&gt;valnum = vuse;</span>
<span class="lineNum">    5004 </span>            :             }
<span class="lineNum">    5005 </span>            : 
<span class="lineNum">    5006 </span>            :           /* If we removed EH side-effects from the statement, clean
<span class="lineNum">    5007 </span>            :              its EH information.  */
<span class="lineNum">    5008 </span><span class="lineCov">          6 :           if (maybe_clean_or_replace_eh_stmt (orig_stmt, stmt))</span>
<span class="lineNum">    5009 </span>            :             {
<span class="lineNum">    5010 </span><span class="lineNoCov">          0 :               bitmap_set_bit (need_eh_cleanup,</span>
<span class="lineNum">    5011 </span><span class="lineNoCov">          0 :                               gimple_bb (stmt)-&gt;index);</span>
<span class="lineNum">    5012 </span><span class="lineNoCov">          0 :               if (dump_file &amp;&amp; (dump_flags &amp; TDF_DETAILS))</span>
<span class="lineNum">    5013 </span><span class="lineNoCov">          0 :                 fprintf (dump_file, &quot;  Removed EH side-effects.\n&quot;);</span>
<span class="lineNum">    5014 </span>            :             }
<span class="lineNum">    5015 </span>            : 
<span class="lineNum">    5016 </span>            :           /* Likewise for AB side-effects.  */
<span class="lineNum">    5017 </span><span class="lineCov">          6 :           if (can_make_abnormal_goto</span>
<span class="lineNum">    5018 </span><span class="lineCov">          6 :               &amp;&amp; !stmt_can_make_abnormal_goto (stmt))</span>
<span class="lineNum">    5019 </span>            :             {
<span class="lineNum">    5020 </span><span class="lineNoCov">          0 :               bitmap_set_bit (need_ab_cleanup,</span>
<span class="lineNum">    5021 </span><span class="lineNoCov">          0 :                               gimple_bb (stmt)-&gt;index);</span>
<span class="lineNum">    5022 </span><span class="lineNoCov">          0 :               if (dump_file &amp;&amp; (dump_flags &amp; TDF_DETAILS))</span>
<span class="lineNum">    5023 </span><span class="lineNoCov">          0 :                 fprintf (dump_file, &quot;  Removed AB side-effects.\n&quot;);</span>
<span class="lineNum">    5024 </span>            :             }
<span class="lineNum">    5025 </span>            : 
<span class="lineNum">    5026 </span><span class="lineCov">          6 :           return;</span>
<span class="lineNum">    5027 </span>            :         }
<span class="lineNum">    5028 </span>            :     }
<span class="lineNum">    5029 </span>            : 
<span class="lineNum">    5030 </span>            :   /* If the statement is a scalar store, see if the expression
<span class="lineNum">    5031 </span>            :      has the same value number as its rhs.  If so, the store is
<span class="lineNum">    5032 </span>            :      dead.  */
<span class="lineNum">    5033 </span><span class="lineCov">  150601560 :   if (gimple_assign_single_p (stmt)</span>
<span class="lineNum">    5034 </span><span class="lineCov">   54497556 :       &amp;&amp; !gimple_has_volatile_ops (stmt)</span>
<span class="lineNum">    5035 </span><span class="lineCov">   46429324 :       &amp;&amp; !is_gimple_reg (gimple_assign_lhs (stmt))</span>
<span class="lineNum">    5036 </span><span class="lineCov">   12829141 :       &amp;&amp; (TREE_CODE (gimple_assign_rhs1 (stmt)) == SSA_NAME</span>
<span class="lineNum">    5037 </span><span class="lineCov">   14712418 :           || is_gimple_min_invariant (gimple_assign_rhs1 (stmt))))</span>
<span class="lineNum">    5038 </span>            :     {
<span class="lineNum">    5039 </span><span class="lineCov">   11660600 :       tree val;</span>
<span class="lineNum">    5040 </span><span class="lineCov">   11660600 :       tree rhs = gimple_assign_rhs1 (stmt);</span>
<span class="lineNum">    5041 </span><span class="lineCov">   11660600 :       vn_reference_t vnresult;</span>
<span class="lineNum">    5042 </span><span class="lineCov">   23321200 :       val = vn_reference_lookup (lhs, gimple_vuse (stmt), VN_WALKREWRITE,</span>
<span class="lineNum">    5043 </span>            :                                  &amp;vnresult, false);
<span class="lineNum">    5044 </span><span class="lineCov">   11660600 :       if (TREE_CODE (rhs) == SSA_NAME)</span>
<span class="lineNum">    5045 </span><span class="lineCov">    5472932 :         rhs = VN_INFO (rhs)-&gt;valnum;</span>
<span class="lineNum">    5046 </span><span class="lineCov">   11660600 :       if (val</span>
<span class="lineNum">    5047 </span><span class="lineCov">   11660600 :           &amp;&amp; operand_equal_p (val, rhs, 0))</span>
<span class="lineNum">    5048 </span>            :         {
<span class="lineNum">    5049 </span>            :           /* We can only remove the later store if the former aliases
<span class="lineNum">    5050 </span>            :              at least all accesses the later one does or if the store
<span class="lineNum">    5051 </span>            :              was to readonly memory storing the same value.  */
<span class="lineNum">    5052 </span><span class="lineCov">      95665 :           alias_set_type set = get_alias_set (lhs);</span>
<span class="lineNum">    5053 </span><span class="lineCov">      95665 :           if (! vnresult</span>
<span class="lineNum">    5054 </span><span class="lineCov">      95659 :               || vnresult-&gt;set == set</span>
<span class="lineNum">    5055 </span><span class="lineCov">      97459 :               || alias_set_subset_of (set, vnresult-&gt;set))</span>
<span class="lineNum">    5056 </span>            :             {
<span class="lineNum">    5057 </span><span class="lineCov">      95117 :               if (dump_file &amp;&amp; (dump_flags &amp; TDF_DETAILS))</span>
<span class="lineNum">    5058 </span>            :                 {
<span class="lineNum">    5059 </span><span class="lineCov">          8 :                   fprintf (dump_file, &quot;Deleted redundant store &quot;);</span>
<span class="lineNum">    5060 </span><span class="lineCov">          8 :                   print_gimple_stmt (dump_file, stmt, 0);</span>
<span class="lineNum">    5061 </span>            :                 }
<span class="lineNum">    5062 </span>            : 
<span class="lineNum">    5063 </span>            :               /* Queue stmt for removal.  */
<span class="lineNum">    5064 </span><span class="lineCov">      95117 :               to_remove.safe_push (stmt);</span>
<span class="lineNum">    5065 </span><span class="lineCov">      95117 :               return;</span>
<span class="lineNum">    5066 </span>            :             }
<span class="lineNum">    5067 </span>            :         }
<span class="lineNum">    5068 </span>            :     }
<span class="lineNum">    5069 </span>            : 
<span class="lineNum">    5070 </span>            :   /* If this is a control statement value numbering left edges
<span class="lineNum">    5071 </span>            :      unexecuted on force the condition in a way consistent with
<span class="lineNum">    5072 </span>            :      that.  */
<span class="lineNum">    5073 </span><span class="lineCov">  150506443 :   if (gcond *cond = dyn_cast &lt;gcond *&gt; (stmt))</span>
<span class="lineNum">    5074 </span>            :     {
<span class="lineNum">    5075 </span><span class="lineCov">    7251452 :       if ((EDGE_SUCC (b, 0)-&gt;flags &amp; EDGE_EXECUTABLE)</span>
<span class="lineNum">    5076 </span><span class="lineCov">    7251452 :           ^ (EDGE_SUCC (b, 1)-&gt;flags &amp; EDGE_EXECUTABLE))</span>
<span class="lineNum">    5077 </span>            :         {
<span class="lineNum">    5078 </span><span class="lineCov">     229956 :           if (dump_file &amp;&amp; (dump_flags &amp; TDF_DETAILS))</span>
<span class="lineNum">    5079 </span>            :             {
<span class="lineNum">    5080 </span><span class="lineCov">         14 :               fprintf (dump_file, &quot;Removing unexecutable edge from &quot;);</span>
<span class="lineNum">    5081 </span><span class="lineCov">         14 :               print_gimple_stmt (dump_file, stmt, 0);</span>
<span class="lineNum">    5082 </span>            :             }
<span class="lineNum">    5083 </span><span class="lineCov">     229956 :           if (((EDGE_SUCC (b, 0)-&gt;flags &amp; EDGE_TRUE_VALUE) != 0)</span>
<span class="lineNum">    5084 </span><span class="lineCov">     229956 :               == ((EDGE_SUCC (b, 0)-&gt;flags &amp; EDGE_EXECUTABLE) != 0))</span>
<span class="lineNum">    5085 </span><span class="lineCov">      32235 :             gimple_cond_make_true (cond);</span>
<span class="lineNum">    5086 </span>            :           else
<span class="lineNum">    5087 </span><span class="lineCov">     197721 :             gimple_cond_make_false (cond);</span>
<span class="lineNum">    5088 </span><span class="lineCov">     229956 :           update_stmt (cond);</span>
<span class="lineNum">    5089 </span><span class="lineCov">     229956 :           el_todo |= TODO_cleanup_cfg;</span>
<span class="lineNum">    5090 </span><span class="lineCov">     229956 :           return;</span>
<span class="lineNum">    5091 </span>            :         }
<span class="lineNum">    5092 </span>            :     }
<span class="lineNum">    5093 </span>            : 
<span class="lineNum">    5094 </span><span class="lineCov">  150276487 :   bool can_make_abnormal_goto = stmt_can_make_abnormal_goto (stmt);</span>
<span class="lineNum">    5095 </span><span class="lineCov">  150276487 :   bool was_noreturn = (is_gimple_call (stmt)</span>
<span class="lineNum">    5096 </span><span class="lineCov">  150276487 :                        &amp;&amp; gimple_call_noreturn_p (stmt));</span>
<span class="lineNum">    5097 </span><span class="lineCov">  150276487 :   tree vdef = gimple_vdef (stmt);</span>
<span class="lineNum">    5098 </span><span class="lineCov">  150276487 :   tree vuse = gimple_vuse (stmt);</span>
<span class="lineNum">    5099 </span>            : 
<span class="lineNum">    5100 </span>            :   /* If we didn't replace the whole stmt (or propagate the result
<span class="lineNum">    5101 </span>            :      into all uses), replace all uses on this stmt with their
<span class="lineNum">    5102 </span>            :      leaders.  */
<span class="lineNum">    5103 </span><span class="lineCov">  150276487 :   bool modified = false;</span>
<span class="lineNum">    5104 </span><span class="lineCov">  150276487 :   use_operand_p use_p;</span>
<span class="lineNum">    5105 </span><span class="lineCov">  150276487 :   ssa_op_iter iter;</span>
<span class="lineNum">    5106 </span><span class="lineCov">  216254251 :   FOR_EACH_SSA_USE_OPERAND (use_p, stmt, iter, SSA_OP_USE)</span>
<span class="lineNum">    5107 </span>            :     {
<span class="lineNum">    5108 </span><span class="lineCov">   65977764 :       tree use = USE_FROM_PTR (use_p);</span>
<span class="lineNum">    5109 </span>            :       /* ???  The call code above leaves stmt operands un-updated.  */
<span class="lineNum">    5110 </span><span class="lineCov">   65977764 :       if (TREE_CODE (use) != SSA_NAME)</span>
<span class="lineNum">    5111 </span>            :         continue;
<span class="lineNum">    5112 </span><span class="lineCov">   65977764 :       tree sprime;</span>
<span class="lineNum">    5113 </span><span class="lineCov">  131955528 :       if (SSA_NAME_IS_DEFAULT_DEF (use))</span>
<span class="lineNum">    5114 </span>            :         /* ???  For default defs BB shouldn't matter, but we have to
<span class="lineNum">    5115 </span>            :            solve the inconsistency between rpo eliminate and
<span class="lineNum">    5116 </span>            :            dom eliminate avail valueization first.  */
<span class="lineNum">    5117 </span><span class="lineCov">   11947281 :         sprime = eliminate_avail (b, use);</span>
<span class="lineNum">    5118 </span>            :       else
<span class="lineNum">    5119 </span>            :         /* Look for sth available at the definition block of the argument.
<span class="lineNum">    5120 </span>            :            This avoids inconsistencies between availability there which
<span class="lineNum">    5121 </span>            :            decides if the stmt can be removed and availability at the
<span class="lineNum">    5122 </span>            :            use site.  The SSA property ensures that things available
<span class="lineNum">    5123 </span>            :            at the definition are also available at uses.  */
<span class="lineNum">    5124 </span><span class="lineCov">  162091449 :         sprime = eliminate_avail (gimple_bb (SSA_NAME_DEF_STMT (use)), use);</span>
<span class="lineNum">    5125 </span><span class="lineCov">   65977740 :       if (sprime &amp;&amp; sprime != use</span>
<span class="lineNum">    5126 </span><span class="lineCov">    5587839 :           &amp;&amp; may_propagate_copy (use, sprime)</span>
<span class="lineNum">    5127 </span>            :           /* We substitute into debug stmts to avoid excessive
<span class="lineNum">    5128 </span>            :              debug temporaries created by removed stmts, but we need
<span class="lineNum">    5129 </span>            :              to avoid doing so for inserted sprimes as we never want
<span class="lineNum">    5130 </span>            :              to create debug temporaries for them.  */
<span class="lineNum">    5131 </span><span class="lineCov">   71565443 :           &amp;&amp; (!inserted_exprs</span>
<span class="lineNum">    5132 </span><span class="lineCov">     659120 :               || TREE_CODE (sprime) != SSA_NAME</span>
<span class="lineNum">    5133 </span><span class="lineCov">    1309712 :               || !is_gimple_debug (stmt)</span>
<span class="lineNum">    5134 </span><span class="lineCov">     406716 :               || !bitmap_bit_p (inserted_exprs, SSA_NAME_VERSION (sprime))))</span>
<span class="lineNum">    5135 </span>            :         {
<span class="lineNum">    5136 </span><span class="lineCov">    5405888 :           propagate_value (use_p, sprime);</span>
<span class="lineNum">    5137 </span><span class="lineCov">    5405888 :           modified = true;</span>
<span class="lineNum">    5138 </span>            :         }
<span class="lineNum">    5139 </span>            :     }
<span class="lineNum">    5140 </span>            : 
<span class="lineNum">    5141 </span>            :   /* Fold the stmt if modified, this canonicalizes MEM_REFs we propagated
<span class="lineNum">    5142 </span>            :      into which is a requirement for the IPA devirt machinery.  */
<span class="lineNum">    5143 </span><span class="lineCov">  150276487 :   gimple *old_stmt = stmt;</span>
<span class="lineNum">    5144 </span><span class="lineCov">  150276487 :   if (modified)</span>
<span class="lineNum">    5145 </span>            :     {
<span class="lineNum">    5146 </span>            :       /* If a formerly non-invariant ADDR_EXPR is turned into an
<span class="lineNum">    5147 </span>            :          invariant one it was on a separate stmt.  */
<span class="lineNum">    5148 </span><span class="lineCov">    5062407 :       if (gimple_assign_single_p (stmt)</span>
<span class="lineNum">    5149 </span><span class="lineCov">    3459252 :           &amp;&amp; TREE_CODE (gimple_assign_rhs1 (stmt)) == ADDR_EXPR)</span>
<span class="lineNum">    5150 </span><span class="lineCov">     343624 :         recompute_tree_invariant_for_addr_expr (gimple_assign_rhs1 (stmt));</span>
<span class="lineNum">    5151 </span><span class="lineCov">    5062407 :       gimple_stmt_iterator prev = *gsi;</span>
<span class="lineNum">    5152 </span><span class="lineCov">    5062407 :       gsi_prev (&amp;prev);</span>
<span class="lineNum">    5153 </span><span class="lineCov">    5062407 :       if (fold_stmt (gsi))</span>
<span class="lineNum">    5154 </span>            :         {
<span class="lineNum">    5155 </span>            :           /* fold_stmt may have created new stmts inbetween
<span class="lineNum">    5156 </span>            :              the previous stmt and the folded stmt.  Mark
<span class="lineNum">    5157 </span>            :              all defs created there as varying to not confuse
<span class="lineNum">    5158 </span>            :              the SCCVN machinery as we're using that even during
<span class="lineNum">    5159 </span>            :              elimination.  */
<span class="lineNum">    5160 </span><span class="lineCov">     577588 :           if (gsi_end_p (prev))</span>
<span class="lineNum">    5161 </span><span class="lineCov">      58750 :             prev = gsi_start_bb (b);</span>
<span class="lineNum">    5162 </span>            :           else
<span class="lineNum">    5163 </span><span class="lineCov">     259419 :             gsi_next (&amp;prev);</span>
<span class="lineNum">    5164 </span><span class="lineCov">     866382 :           if (gsi_stmt (prev) != gsi_stmt (*gsi))</span>
<span class="lineNum">    5165 </span><span class="lineCov">       1812 :             do</span>
<span class="lineNum">    5166 </span>            :               {
<span class="lineNum">    5167 </span><span class="lineCov">       1812 :                 tree def;</span>
<span class="lineNum">    5168 </span><span class="lineCov">       1812 :                 ssa_op_iter dit;</span>
<span class="lineNum">    5169 </span><span class="lineCov">       5426 :                 FOR_EACH_SSA_TREE_OPERAND (def, gsi_stmt (prev),</span>
<span class="lineNum">    5170 </span>            :                                            dit, SSA_OP_ALL_DEFS)
<span class="lineNum">    5171 </span>            :                     /* As existing DEFs may move between stmts
<span class="lineNum">    5172 </span>            :                        only process new ones.  */
<span class="lineNum">    5173 </span><span class="lineCov">       1802 :                     if (! has_VN_INFO (def))</span>
<span class="lineNum">    5174 </span>            :                       {
<span class="lineNum">    5175 </span><span class="lineCov">        832 :                         VN_INFO (def)-&gt;valnum = def;</span>
<span class="lineNum">    5176 </span><span class="lineCov">        832 :                         VN_INFO (def)-&gt;visited = true;</span>
<span class="lineNum">    5177 </span>            :                       }
<span class="lineNum">    5178 </span><span class="lineCov">       5436 :                 if (gsi_stmt (prev) == gsi_stmt (*gsi))</span>
<span class="lineNum">    5179 </span>            :                   break;
<span class="lineNum">    5180 </span><span class="lineCov">       1860 :                 gsi_next (&amp;prev);</span>
<span class="lineNum">    5181 </span>            :               }
<span class="lineNum">    5182 </span>            :             while (1);
<span class="lineNum">    5183 </span>            :         }
<span class="lineNum">    5184 </span><span class="lineCov">    5062407 :       stmt = gsi_stmt (*gsi);</span>
<span class="lineNum">    5185 </span>            :       /* In case we folded the stmt away schedule the NOP for removal.  */
<span class="lineNum">    5186 </span><span class="lineCov">   10124814 :       if (gimple_nop_p (stmt))</span>
<span class="lineNum">    5187 </span><span class="lineCov">        265 :         to_remove.safe_push (stmt);</span>
<span class="lineNum">    5188 </span>            :     }
<span class="lineNum">    5189 </span>            : 
<span class="lineNum">    5190 </span>            :   /* Visit indirect calls and turn them into direct calls if
<span class="lineNum">    5191 </span>            :      possible using the devirtualization machinery.  Do this before
<span class="lineNum">    5192 </span>            :      checking for required EH/abnormal/noreturn cleanup as devird
<span class="lineNum">    5193 </span>            :      may expose more of those.  */
<span class="lineNum">    5194 </span><span class="lineCov">  150276487 :   if (gcall *call_stmt = dyn_cast &lt;gcall *&gt; (stmt))</span>
<span class="lineNum">    5195 </span>            :     {
<span class="lineNum">    5196 </span><span class="lineCov">   10146057 :       tree fn = gimple_call_fn (call_stmt);</span>
<span class="lineNum">    5197 </span><span class="lineCov">   10146057 :       if (fn</span>
<span class="lineNum">    5198 </span><span class="lineCov">    9844185 :           &amp;&amp; flag_devirtualize</span>
<span class="lineNum">    5199 </span><span class="lineCov">   19586581 :           &amp;&amp; virtual_method_call_p (fn))</span>
<span class="lineNum">    5200 </span>            :         {
<span class="lineNum">    5201 </span><span class="lineCov">      85095 :           tree otr_type = obj_type_ref_class (fn);</span>
<span class="lineNum">    5202 </span><span class="lineCov">      85095 :           unsigned HOST_WIDE_INT otr_tok</span>
<span class="lineNum">    5203 </span><span class="lineCov">      85095 :               = tree_to_uhwi (OBJ_TYPE_REF_TOKEN (fn));</span>
<span class="lineNum">    5204 </span><span class="lineCov">      85095 :           tree instance;</span>
<span class="lineNum">    5205 </span><span class="lineCov">      85095 :           ipa_polymorphic_call_context context (current_function_decl,</span>
<span class="lineNum">    5206 </span><span class="lineCov">      85095 :                                                 fn, stmt, &amp;instance);</span>
<span class="lineNum">    5207 </span><span class="lineCov">      85095 :           context.get_dynamic_type (instance, OBJ_TYPE_REF_OBJECT (fn),</span>
<span class="lineNum">    5208 </span>            :                                     otr_type, stmt);
<span class="lineNum">    5209 </span><span class="lineCov">      85095 :           bool final;</span>
<span class="lineNum">    5210 </span><span class="lineCov">      85095 :           vec &lt;cgraph_node *&gt; targets</span>
<span class="lineNum">    5211 </span>            :               = possible_polymorphic_call_targets (obj_type_ref_class (fn),
<span class="lineNum">    5212 </span><span class="lineCov">      85095 :                                                    otr_tok, context, &amp;final);</span>
<span class="lineNum">    5213 </span><span class="lineCov">      85095 :           if (dump_file)</span>
<span class="lineNum">    5214 </span><span class="lineCov">         15 :             dump_possible_polymorphic_call_targets (dump_file,</span>
<span class="lineNum">    5215 </span>            :                                                     obj_type_ref_class (fn),
<span class="lineNum">    5216 </span>            :                                                     otr_tok, context);
<span class="lineNum">    5217 </span><span class="lineCov">      85095 :           if (final &amp;&amp; targets.length () &lt;= 1 &amp;&amp; dbg_cnt (devirt))</span>
<span class="lineNum">    5218 </span>            :             {
<span class="lineNum">    5219 </span><span class="lineCov">         83 :               tree fn;</span>
<span class="lineNum">    5220 </span><span class="lineCov">         83 :               if (targets.length () == 1)</span>
<span class="lineNum">    5221 </span><span class="lineCov">        166 :                 fn = targets[0]-&gt;decl;</span>
<span class="lineNum">    5222 </span>            :               else
<span class="lineNum">    5223 </span><span class="lineNoCov">          0 :                 fn = builtin_decl_implicit (BUILT_IN_UNREACHABLE);</span>
<span class="lineNum">    5224 </span><span class="lineCov">        166 :               if (dump_enabled_p ())</span>
<span class="lineNum">    5225 </span>            :                 {
<span class="lineNum">    5226 </span><span class="lineCov">          9 :                   dump_printf_loc (MSG_OPTIMIZED_LOCATIONS, stmt,</span>
<span class="lineNum">    5227 </span>            :                                    &quot;converting indirect call to &quot;
<span class="lineNum">    5228 </span>            :                                    &quot;function %s\n&quot;,
<span class="lineNum">    5229 </span><span class="lineCov">          9 :                                    lang_hooks.decl_printable_name (fn, 2));</span>
<span class="lineNum">    5230 </span>            :                 }
<span class="lineNum">    5231 </span><span class="lineCov">         83 :               gimple_call_set_fndecl (call_stmt, fn);</span>
<span class="lineNum">    5232 </span>            :               /* If changing the call to __builtin_unreachable
<span class="lineNum">    5233 </span>            :                  or similar noreturn function, adjust gimple_call_fntype
<span class="lineNum">    5234 </span>            :                  too.  */
<span class="lineNum">    5235 </span><span class="lineCov">         83 :               if (gimple_call_noreturn_p (call_stmt)</span>
<span class="lineNum">    5236 </span><span class="lineNoCov">          0 :                   &amp;&amp; VOID_TYPE_P (TREE_TYPE (TREE_TYPE (fn)))</span>
<span class="lineNum">    5237 </span><span class="lineNoCov">          0 :                   &amp;&amp; TYPE_ARG_TYPES (TREE_TYPE (fn))</span>
<span class="lineNum">    5238 </span><span class="lineCov">         83 :                   &amp;&amp; (TREE_VALUE (TYPE_ARG_TYPES (TREE_TYPE (fn)))</span>
<span class="lineNum">    5239 </span><span class="lineNoCov">          0 :                       == void_type_node))</span>
<span class="lineNum">    5240 </span><span class="lineNoCov">          0 :                 gimple_call_set_fntype (call_stmt, TREE_TYPE (fn));</span>
<span class="lineNum">    5241 </span><span class="lineCov">         83 :               maybe_remove_unused_call_args (cfun, call_stmt);</span>
<span class="lineNum">    5242 </span><span class="lineCov">         83 :               modified = true;</span>
<span class="lineNum">    5243 </span>            :             }
<span class="lineNum">    5244 </span>            :         }
<span class="lineNum">    5245 </span>            :     }
<span class="lineNum">    5246 </span>            : 
<span class="lineNum">    5247 </span><span class="lineCov">  150276487 :   if (modified)</span>
<span class="lineNum">    5248 </span>            :     {
<span class="lineNum">    5249 </span>            :       /* When changing a call into a noreturn call, cfg cleanup
<span class="lineNum">    5250 </span>            :          is needed to fix up the noreturn call.  */
<span class="lineNum">    5251 </span><span class="lineCov">    5062427 :       if (!was_noreturn</span>
<span class="lineNum">    5252 </span><span class="lineCov">    5062427 :           &amp;&amp; is_gimple_call (stmt) &amp;&amp; gimple_call_noreturn_p (stmt))</span>
<span class="lineNum">    5253 </span><span class="lineCov">         47 :         to_fixup.safe_push  (stmt);</span>
<span class="lineNum">    5254 </span>            :       /* When changing a condition or switch into one we know what
<span class="lineNum">    5255 </span>            :          edge will be executed, schedule a cfg cleanup.  */
<span class="lineNum">    5256 </span><span class="lineCov">    5062427 :       if ((gimple_code (stmt) == GIMPLE_COND</span>
<span class="lineNum">    5257 </span><span class="lineCov">     573087 :            &amp;&amp; (gimple_cond_true_p (as_a &lt;gcond *&gt; (stmt))</span>
<span class="lineNum">    5258 </span><span class="lineCov">    1146130 :                || gimple_cond_false_p (as_a &lt;gcond *&gt; (stmt))))</span>
<span class="lineNum">    5259 </span><span class="lineCov">    6208257 :           || (gimple_code (stmt) == GIMPLE_SWITCH</span>
<span class="lineNum">    5260 </span><span class="lineCov">       2862 :               &amp;&amp; TREE_CODE (gimple_switch_index</span>
<span class="lineNum">    5261 </span>            :                             (as_a &lt;gswitch *&gt; (stmt))) == INTEGER_CST))
<span class="lineNum">    5262 </span><span class="lineCov">        301 :         el_todo |= TODO_cleanup_cfg;</span>
<span class="lineNum">    5263 </span>            :       /* If we removed EH side-effects from the statement, clean
<span class="lineNum">    5264 </span>            :          its EH information.  */
<span class="lineNum">    5265 </span><span class="lineCov">    5062427 :       if (maybe_clean_or_replace_eh_stmt (old_stmt, stmt))</span>
<span class="lineNum">    5266 </span>            :         {
<span class="lineNum">    5267 </span><span class="lineCov">        708 :           bitmap_set_bit (need_eh_cleanup,</span>
<span class="lineNum">    5268 </span><span class="lineCov">        708 :                           gimple_bb (stmt)-&gt;index);</span>
<span class="lineNum">    5269 </span><span class="lineCov">        708 :           if (dump_file &amp;&amp; (dump_flags &amp; TDF_DETAILS))</span>
<span class="lineNum">    5270 </span><span class="lineNoCov">          0 :             fprintf (dump_file, &quot;  Removed EH side-effects.\n&quot;);</span>
<span class="lineNum">    5271 </span>            :         }
<span class="lineNum">    5272 </span>            :       /* Likewise for AB side-effects.  */
<span class="lineNum">    5273 </span><span class="lineCov">    5062427 :       if (can_make_abnormal_goto</span>
<span class="lineNum">    5274 </span><span class="lineCov">    5062427 :           &amp;&amp; !stmt_can_make_abnormal_goto (stmt))</span>
<span class="lineNum">    5275 </span>            :         {
<span class="lineNum">    5276 </span><span class="lineNoCov">          0 :           bitmap_set_bit (need_ab_cleanup,</span>
<span class="lineNum">    5277 </span><span class="lineNoCov">          0 :                           gimple_bb (stmt)-&gt;index);</span>
<span class="lineNum">    5278 </span><span class="lineNoCov">          0 :           if (dump_file &amp;&amp; (dump_flags &amp; TDF_DETAILS))</span>
<span class="lineNum">    5279 </span><span class="lineNoCov">          0 :             fprintf (dump_file, &quot;  Removed AB side-effects.\n&quot;);</span>
<span class="lineNum">    5280 </span>            :         }
<span class="lineNum">    5281 </span><span class="lineCov">    5062427 :       update_stmt (stmt);</span>
<span class="lineNum">    5282 </span>            :       /* In case the VDEF on the original stmt was released, value-number
<span class="lineNum">    5283 </span>            :          it to the VUSE.  This is to make vuse_ssa_val able to skip
<span class="lineNum">    5284 </span>            :          released virtual operands.  */
<span class="lineNum">    5285 </span><span class="lineCov">    5062427 :       if (vdef &amp;&amp; SSA_NAME_IN_FREE_LIST (vdef))</span>
<span class="lineNum">    5286 </span><span class="lineCov">        957 :         VN_INFO (vdef)-&gt;valnum = vuse;</span>
<span class="lineNum">    5287 </span>            :     }
<span class="lineNum">    5288 </span>            : 
<span class="lineNum">    5289 </span>            :   /* Make new values available - for fully redundant LHS we
<span class="lineNum">    5290 </span>            :      continue with the next stmt above and skip this.  */
<span class="lineNum">    5291 </span><span class="lineCov">  150276487 :   def_operand_p defp;</span>
<span class="lineNum">    5292 </span><span class="lineCov">  178240966 :   FOR_EACH_SSA_DEF_OPERAND (defp, stmt, iter, SSA_OP_DEF)</span>
<span class="lineNum">    5293 </span><span class="lineCov">   55928958 :     eliminate_push_avail (b, DEF_FROM_PTR (defp));</span>
<span class="lineNum">    5294 </span>            : }
<span class="lineNum">    5295 </span>            : 
<span class="lineNum">    5296 </span>            : /* Perform elimination for the basic-block B during the domwalk.  */
<a name="5297"><span class="lineNum">    5297 </span>            : </a>
<span class="lineNum">    5298 </span>            : edge
<span class="lineNum">    5299 </span><span class="lineCov">   23516263 : eliminate_dom_walker::before_dom_children (basic_block b)</span>
<span class="lineNum">    5300 </span>            : {
<span class="lineNum">    5301 </span>            :   /* Mark new bb.  */
<span class="lineNum">    5302 </span><span class="lineCov">   23516263 :   avail_stack.safe_push (NULL_TREE);</span>
<span class="lineNum">    5303 </span>            : 
<span class="lineNum">    5304 </span>            :   /* Skip unreachable blocks marked unreachable during the SCCVN domwalk.  */
<span class="lineNum">    5305 </span><span class="lineCov">   23516263 :   if (!(b-&gt;flags &amp; BB_EXECUTABLE))</span>
<span class="lineNum">    5306 </span>            :     return NULL;
<span class="lineNum">    5307 </span>            : 
<span class="lineNum">    5308 </span><span class="lineCov">   21966784 :   vn_context_bb = b;</span>
<span class="lineNum">    5309 </span>            : 
<span class="lineNum">    5310 </span><span class="lineCov">   35228018 :   for (gphi_iterator gsi = gsi_start_phis (b); !gsi_end_p (gsi);)</span>
<span class="lineNum">    5311 </span>            :     {
<span class="lineNum">    5312 </span><span class="lineCov">    6630617 :       gphi *phi = gsi.phi ();</span>
<span class="lineNum">    5313 </span><span class="lineCov">   13261234 :       tree res = PHI_RESULT (phi);</span>
<span class="lineNum">    5314 </span>            : 
<span class="lineNum">    5315 </span><span class="lineCov">   13261234 :       if (virtual_operand_p (res))</span>
<span class="lineNum">    5316 </span>            :         {
<span class="lineNum">    5317 </span><span class="lineCov">    3129543 :           gsi_next (&amp;gsi);</span>
<span class="lineNum">    5318 </span><span class="lineCov">    3129543 :           continue;</span>
<span class="lineNum">    5319 </span>            :         }
<span class="lineNum">    5320 </span>            : 
<span class="lineNum">    5321 </span><span class="lineCov">    3501074 :       tree sprime = eliminate_avail (b, res);</span>
<span class="lineNum">    5322 </span><span class="lineCov">    3501074 :       if (sprime</span>
<span class="lineNum">    5323 </span><span class="lineCov">     371014 :           &amp;&amp; sprime != res)</span>
<span class="lineNum">    5324 </span>            :         {
<span class="lineNum">    5325 </span><span class="lineCov">     371014 :           if (dump_file &amp;&amp; (dump_flags &amp; TDF_DETAILS))</span>
<span class="lineNum">    5326 </span>            :             {
<span class="lineNum">    5327 </span><span class="lineCov">         24 :               fprintf (dump_file, &quot;Replaced redundant PHI node defining &quot;);</span>
<span class="lineNum">    5328 </span><span class="lineCov">         24 :               print_generic_expr (dump_file, res);</span>
<span class="lineNum">    5329 </span><span class="lineCov">         24 :               fprintf (dump_file, &quot; with &quot;);</span>
<span class="lineNum">    5330 </span><span class="lineCov">         24 :               print_generic_expr (dump_file, sprime);</span>
<span class="lineNum">    5331 </span><span class="lineCov">         24 :               fprintf (dump_file, &quot;\n&quot;);</span>
<span class="lineNum">    5332 </span>            :             }
<span class="lineNum">    5333 </span>            : 
<span class="lineNum">    5334 </span>            :           /* If we inserted this PHI node ourself, it's not an elimination.  */
<span class="lineNum">    5335 </span><span class="lineCov">     371014 :           if (! inserted_exprs</span>
<span class="lineNum">    5336 </span><span class="lineCov">     371014 :               || ! bitmap_bit_p (inserted_exprs, SSA_NAME_VERSION (res)))</span>
<span class="lineNum">    5337 </span><span class="lineCov">     362047 :             eliminations++;</span>
<span class="lineNum">    5338 </span>            : 
<span class="lineNum">    5339 </span>            :           /* If we will propagate into all uses don't bother to do
<span class="lineNum">    5340 </span>            :              anything.  */
<span class="lineNum">    5341 </span><span class="lineCov">     371014 :           if (may_propagate_copy (res, sprime))</span>
<span class="lineNum">    5342 </span>            :             {
<span class="lineNum">    5343 </span>            :               /* Mark the PHI for removal.  */
<span class="lineNum">    5344 </span><span class="lineCov">     371014 :               to_remove.safe_push (phi);</span>
<span class="lineNum">    5345 </span><span class="lineCov">     371014 :               gsi_next (&amp;gsi);</span>
<span class="lineNum">    5346 </span><span class="lineCov">     371014 :               continue;</span>
<span class="lineNum">    5347 </span>            :             }
<span class="lineNum">    5348 </span>            : 
<span class="lineNum">    5349 </span><span class="lineNoCov">          0 :           remove_phi_node (&amp;gsi, false);</span>
<span class="lineNum">    5350 </span>            : 
<span class="lineNum">    5351 </span><span class="lineNoCov">          0 :           if (!useless_type_conversion_p (TREE_TYPE (res), TREE_TYPE (sprime)))</span>
<span class="lineNum">    5352 </span><span class="lineNoCov">          0 :             sprime = fold_convert (TREE_TYPE (res), sprime);</span>
<span class="lineNum">    5353 </span><span class="lineNoCov">          0 :           gimple *stmt = gimple_build_assign (res, sprime);</span>
<span class="lineNum">    5354 </span><span class="lineNoCov">          0 :           gimple_stmt_iterator gsi2 = gsi_after_labels (b);</span>
<span class="lineNum">    5355 </span><span class="lineNoCov">          0 :           gsi_insert_before (&amp;gsi2, stmt, GSI_NEW_STMT);</span>
<span class="lineNum">    5356 </span><span class="lineNoCov">          0 :           continue;</span>
<span class="lineNum">    5357 </span>            :         }
<span class="lineNum">    5358 </span>            : 
<span class="lineNum">    5359 </span><span class="lineCov">    3130060 :       eliminate_push_avail (b, res);</span>
<span class="lineNum">    5360 </span><span class="lineCov">    3130060 :       gsi_next (&amp;gsi);</span>
<span class="lineNum">    5361 </span>            :     }
<span class="lineNum">    5362 </span>            : 
<span class="lineNum">    5363 </span><span class="lineCov">   21966784 :   for (gimple_stmt_iterator gsi = gsi_start_bb (b);</span>
<span class="lineNum">    5364 </span><span class="lineCov">  349757160 :        !gsi_end_p (gsi);</span>
<span class="lineNum">    5365 </span><span class="lineCov">  152911796 :        gsi_next (&amp;gsi))</span>
<span class="lineNum">    5366 </span><span class="lineCov">  152911796 :     eliminate_stmt (b, &amp;gsi);</span>
<span class="lineNum">    5367 </span>            : 
<span class="lineNum">    5368 </span>            :   /* Replace destination PHI arguments.  */
<span class="lineNum">    5369 </span><span class="lineCov">   21966784 :   edge_iterator ei;</span>
<span class="lineNum">    5370 </span><span class="lineCov">   21966784 :   edge e;</span>
<span class="lineNum">    5371 </span><span class="lineCov">   73744036 :   FOR_EACH_EDGE (e, ei, b-&gt;succs)</span>
<span class="lineNum">    5372 </span><span class="lineCov">   29810468 :     if (e-&gt;flags &amp; EDGE_EXECUTABLE)</span>
<span class="lineNum">    5373 </span><span class="lineCov">   29594236 :       for (gphi_iterator gsi = gsi_start_phis (e-&gt;dest);</span>
<span class="lineNum">    5374 </span><span class="lineCov">   92264330 :            !gsi_end_p (gsi);</span>
<span class="lineNum">    5375 </span><span class="lineCov">   16537929 :            gsi_next (&amp;gsi))</span>
<span class="lineNum">    5376 </span>            :         {
<span class="lineNum">    5377 </span><span class="lineCov">   16537929 :           gphi *phi = gsi.phi ();</span>
<span class="lineNum">    5378 </span><span class="lineCov">   16537929 :           use_operand_p use_p = PHI_ARG_DEF_PTR_FROM_EDGE (phi, e);</span>
<span class="lineNum">    5379 </span><span class="lineCov">   16537929 :           tree arg = USE_FROM_PTR (use_p);</span>
<span class="lineNum">    5380 </span><span class="lineCov">   16537929 :           if (TREE_CODE (arg) != SSA_NAME</span>
<span class="lineNum">    5381 </span><span class="lineCov">   16537929 :               || virtual_operand_p (arg))</span>
<span class="lineNum">    5382 </span>            :             continue;
<span class="lineNum">    5383 </span><span class="lineCov">    5494941 :           tree sprime = eliminate_avail (b, arg);</span>
<span class="lineNum">    5384 </span><span class="lineCov">    5494941 :           if (sprime &amp;&amp; may_propagate_copy (arg, sprime))</span>
<span class="lineNum">    5385 </span><span class="lineCov">    5488287 :             propagate_value (use_p, sprime);</span>
<span class="lineNum">    5386 </span>            :         }
<span class="lineNum">    5387 </span>            : 
<span class="lineNum">    5388 </span><span class="lineCov">   21966784 :   vn_context_bb = NULL;</span>
<span class="lineNum">    5389 </span>            : 
<span class="lineNum">    5390 </span><span class="lineCov">   21966784 :   return NULL;</span>
<span class="lineNum">    5391 </span>            : }
<span class="lineNum">    5392 </span>            : 
<span class="lineNum">    5393 </span>            : /* Make no longer available leaders no longer available.  */
<a name="5394"><span class="lineNum">    5394 </span>            : </a>
<span class="lineNum">    5395 </span>            : void
<span class="lineNum">    5396 </span><span class="lineCov">   23516263 : eliminate_dom_walker::after_dom_children (basic_block)</span>
<span class="lineNum">    5397 </span>            : {
<span class="lineNum">    5398 </span><span class="lineCov">   52740357 :   tree entry;</span>
<span class="lineNum">    5399 </span><span class="lineCov">   52740357 :   while ((entry = avail_stack.pop ()) != NULL_TREE)</span>
<span class="lineNum">    5400 </span>            :     {
<span class="lineNum">    5401 </span><span class="lineCov">   29224094 :       tree valnum = VN_INFO (entry)-&gt;valnum;</span>
<span class="lineNum">    5402 </span><span class="lineCov">   29224094 :       tree old = avail[SSA_NAME_VERSION (valnum)];</span>
<span class="lineNum">    5403 </span><span class="lineCov">   29224094 :       if (old == entry)</span>
<span class="lineNum">    5404 </span><span class="lineCov">   87652047 :         avail[SSA_NAME_VERSION (valnum)] = NULL_TREE;</span>
<span class="lineNum">    5405 </span>            :       else
<span class="lineNum">    5406 </span><span class="lineCov">      20235 :         avail[SSA_NAME_VERSION (valnum)] = entry;</span>
<span class="lineNum">    5407 </span>            :     }
<span class="lineNum">    5408 </span><span class="lineCov">   23516263 : }</span>
<span class="lineNum">    5409 </span>            : 
<span class="lineNum">    5410 </span>            : /* Remove queued stmts and perform delayed cleanups.  */
<a name="5411"><span class="lineNum">    5411 </span>            : </a>
<span class="lineNum">    5412 </span>            : unsigned
<span class="lineNum">    5413 </span><span class="lineCov">    2628835 : eliminate_dom_walker::eliminate_cleanup (bool region_p)</span>
<span class="lineNum">    5414 </span>            : {
<span class="lineNum">    5415 </span><span class="lineCov">    2628835 :   statistics_counter_event (cfun, &quot;Eliminated&quot;, eliminations);</span>
<span class="lineNum">    5416 </span><span class="lineCov">    2628835 :   statistics_counter_event (cfun, &quot;Insertions&quot;, insertions);</span>
<span class="lineNum">    5417 </span>            : 
<span class="lineNum">    5418 </span>            :   /* We cannot remove stmts during BB walk, especially not release SSA
<span class="lineNum">    5419 </span>            :      names there as this confuses the VN machinery.  The stmts ending
<span class="lineNum">    5420 </span>            :      up in to_remove are either stores or simple copies.
<span class="lineNum">    5421 </span>            :      Remove stmts in reverse order to make debug stmt creation possible.  */
<span class="lineNum">    5422 </span><span class="lineCov">   10208825 :   while (!to_remove.is_empty ())</span>
<span class="lineNum">    5423 </span>            :     {
<span class="lineNum">    5424 </span><span class="lineCov">    7579990 :       bool do_release_defs = true;</span>
<span class="lineNum">    5425 </span><span class="lineCov">    7579990 :       gimple *stmt = to_remove.pop ();</span>
<span class="lineNum">    5426 </span>            : 
<span class="lineNum">    5427 </span>            :       /* When we are value-numbering a region we do not require exit PHIs to
<span class="lineNum">    5428 </span>            :          be present so we have to make sure to deal with uses outside of the
<span class="lineNum">    5429 </span>            :          region of stmts that we thought are eliminated.
<span class="lineNum">    5430 </span>            :          ??? Note we may be confused by uses in dead regions we didn't run
<span class="lineNum">    5431 </span>            :          elimination on.  Rather than checking individual uses we accept
<span class="lineNum">    5432 </span>            :          dead copies to be generated here (gcc.c-torture/execute/20060905-1.c
<span class="lineNum">    5433 </span>            :          contains such example).  */
<span class="lineNum">    5434 </span><span class="lineCov">    7579990 :       if (region_p)</span>
<span class="lineNum">    5435 </span>            :         {
<span class="lineNum">    5436 </span><span class="lineCov">     333558 :           if (gphi *phi = dyn_cast &lt;gphi *&gt; (stmt))</span>
<span class="lineNum">    5437 </span>            :             {
<span class="lineNum">    5438 </span><span class="lineCov">     131835 :               tree lhs = gimple_phi_result (phi);</span>
<span class="lineNum">    5439 </span><span class="lineCov">     131835 :               if (!has_zero_uses (lhs))</span>
<span class="lineNum">    5440 </span>            :                 {
<span class="lineNum">    5441 </span><span class="lineCov">      12633 :                   if (dump_file &amp;&amp; (dump_flags &amp; TDF_DETAILS))</span>
<span class="lineNum">    5442 </span><span class="lineNoCov">          0 :                     fprintf (dump_file, &quot;Keeping eliminated stmt live &quot;</span>
<span class="lineNum">    5443 </span>            :                              &quot;as copy because of out-of-region uses\n&quot;);
<span class="lineNum">    5444 </span><span class="lineCov">      25266 :                   tree sprime = eliminate_avail (gimple_bb (stmt), lhs);</span>
<span class="lineNum">    5445 </span><span class="lineCov">      12633 :                   gimple *copy = gimple_build_assign (lhs, sprime);</span>
<span class="lineNum">    5446 </span><span class="lineCov">      12633 :                   gimple_stmt_iterator gsi</span>
<span class="lineNum">    5447 </span><span class="lineCov">      25266 :                     = gsi_after_labels (gimple_bb (stmt));</span>
<span class="lineNum">    5448 </span><span class="lineCov">      12633 :                   gsi_insert_before (&amp;gsi, copy, GSI_SAME_STMT);</span>
<span class="lineNum">    5449 </span><span class="lineCov">      12633 :                   do_release_defs = false;</span>
<span class="lineNum">    5450 </span>            :                 }
<span class="lineNum">    5451 </span>            :             }
<span class="lineNum">    5452 </span><span class="lineCov">     201723 :           else if (tree lhs = gimple_get_lhs (stmt))</span>
<span class="lineNum">    5453 </span><span class="lineCov">     201723 :             if (TREE_CODE (lhs) == SSA_NAME</span>
<span class="lineNum">    5454 </span><span class="lineCov">     201723 :                 &amp;&amp; !has_zero_uses (lhs))</span>
<span class="lineNum">    5455 </span>            :               {
<span class="lineNum">    5456 </span><span class="lineCov">        158 :                 if (dump_file &amp;&amp; (dump_flags &amp; TDF_DETAILS))</span>
<span class="lineNum">    5457 </span><span class="lineNoCov">          0 :                   fprintf (dump_file, &quot;Keeping eliminated stmt live &quot;</span>
<span class="lineNum">    5458 </span>            :                            &quot;as copy because of out-of-region uses\n&quot;);
<span class="lineNum">    5459 </span><span class="lineCov">        316 :                 tree sprime = eliminate_avail (gimple_bb (stmt), lhs);</span>
<span class="lineNum">    5460 </span><span class="lineCov">        158 :                 gimple_stmt_iterator gsi = gsi_for_stmt (stmt);</span>
<span class="lineNum">    5461 </span><span class="lineCov">        316 :                 if (is_gimple_assign (stmt))</span>
<span class="lineNum">    5462 </span>            :                   {
<span class="lineNum">    5463 </span><span class="lineCov">        158 :                     gimple_assign_set_rhs_from_tree (&amp;gsi, sprime);</span>
<span class="lineNum">    5464 </span><span class="lineCov">        158 :                     stmt = gsi_stmt (gsi);</span>
<span class="lineNum">    5465 </span><span class="lineCov">        158 :                     update_stmt (stmt);</span>
<span class="lineNum">    5466 </span><span class="lineCov">        158 :                     if (maybe_clean_or_replace_eh_stmt (stmt, stmt))</span>
<span class="lineNum">    5467 </span><span class="lineNoCov">          0 :                       bitmap_set_bit (need_eh_cleanup, gimple_bb (stmt)-&gt;index);</span>
<span class="lineNum">    5468 </span><span class="lineCov">        158 :                     continue;</span>
<span class="lineNum">    5469 </span>            :                   }
<span class="lineNum">    5470 </span>            :                 else
<span class="lineNum">    5471 </span>            :                   {
<span class="lineNum">    5472 </span><span class="lineNoCov">          0 :                     gimple *copy = gimple_build_assign (lhs, sprime);</span>
<span class="lineNum">    5473 </span><span class="lineNoCov">          0 :                     gsi_insert_before (&amp;gsi, copy, GSI_SAME_STMT);</span>
<span class="lineNum">    5474 </span><span class="lineNoCov">          0 :                     do_release_defs = false;</span>
<span class="lineNum">    5475 </span>            :                   }
<span class="lineNum">    5476 </span>            :               }
<span class="lineNum">    5477 </span>            :         }
<span class="lineNum">    5478 </span>            : 
<span class="lineNum">    5479 </span><span class="lineCov">    7579832 :       if (dump_file &amp;&amp; (dump_flags &amp; TDF_DETAILS))</span>
<span class="lineNum">    5480 </span>            :         {
<span class="lineNum">    5481 </span><span class="lineCov">        480 :           fprintf (dump_file, &quot;Removing dead stmt &quot;);</span>
<span class="lineNum">    5482 </span><span class="lineCov">        480 :           print_gimple_stmt (dump_file, stmt, 0, TDF_NONE);</span>
<span class="lineNum">    5483 </span>            :         }
<span class="lineNum">    5484 </span>            : 
<span class="lineNum">    5485 </span><span class="lineCov">    7579832 :       gimple_stmt_iterator gsi = gsi_for_stmt (stmt);</span>
<span class="lineNum">    5486 </span><span class="lineCov">   15159664 :       if (gimple_code (stmt) == GIMPLE_PHI)</span>
<span class="lineNum">    5487 </span><span class="lineCov">     513992 :         remove_phi_node (&amp;gsi, do_release_defs);</span>
<span class="lineNum">    5488 </span>            :       else
<span class="lineNum">    5489 </span>            :         {
<span class="lineNum">    5490 </span><span class="lineCov">    7065840 :           basic_block bb = gimple_bb (stmt);</span>
<span class="lineNum">    5491 </span><span class="lineCov">    7065840 :           unlink_stmt_vdef (stmt);</span>
<span class="lineNum">    5492 </span><span class="lineCov">    7065840 :           if (gsi_remove (&amp;gsi, true))</span>
<span class="lineNum">    5493 </span><span class="lineCov">      17028 :             bitmap_set_bit (need_eh_cleanup, bb-&gt;index);</span>
<span class="lineNum">    5494 </span><span class="lineCov">   14131680 :           if (is_gimple_call (stmt) &amp;&amp; stmt_can_make_abnormal_goto (stmt))</span>
<span class="lineNum">    5495 </span><span class="lineCov">          2 :             bitmap_set_bit (need_ab_cleanup, bb-&gt;index);</span>
<span class="lineNum">    5496 </span><span class="lineCov">    7065840 :           if (do_release_defs)</span>
<span class="lineNum">    5497 </span><span class="lineCov">    7065840 :             release_defs (stmt);</span>
<span class="lineNum">    5498 </span>            :         }
<span class="lineNum">    5499 </span>            : 
<span class="lineNum">    5500 </span>            :       /* Removing a stmt may expose a forwarder block.  */
<span class="lineNum">    5501 </span><span class="lineCov">    7579832 :       el_todo |= TODO_cleanup_cfg;</span>
<span class="lineNum">    5502 </span>            :     }
<span class="lineNum">    5503 </span>            : 
<span class="lineNum">    5504 </span>            :   /* Fixup stmts that became noreturn calls.  This may require splitting
<span class="lineNum">    5505 </span>            :      blocks and thus isn't possible during the dominator walk.  Do this
<span class="lineNum">    5506 </span>            :      in reverse order so we don't inadvertedly remove a stmt we want to
<span class="lineNum">    5507 </span>            :      fixup by visiting a dominating now noreturn call first.  */
<span class="lineNum">    5508 </span><span class="lineCov">    2628882 :   while (!to_fixup.is_empty ())</span>
<span class="lineNum">    5509 </span>            :     {
<span class="lineNum">    5510 </span><span class="lineCov">         47 :       gimple *stmt = to_fixup.pop ();</span>
<span class="lineNum">    5511 </span>            : 
<span class="lineNum">    5512 </span><span class="lineCov">         47 :       if (dump_file &amp;&amp; (dump_flags &amp; TDF_DETAILS))</span>
<span class="lineNum">    5513 </span>            :         {
<span class="lineNum">    5514 </span><span class="lineNoCov">          0 :           fprintf (dump_file, &quot;Fixing up noreturn call &quot;);</span>
<span class="lineNum">    5515 </span><span class="lineNoCov">          0 :           print_gimple_stmt (dump_file, stmt, 0);</span>
<span class="lineNum">    5516 </span>            :         }
<span class="lineNum">    5517 </span>            : 
<span class="lineNum">    5518 </span><span class="lineCov">         47 :       if (fixup_noreturn_call (stmt))</span>
<span class="lineNum">    5519 </span><span class="lineCov">         47 :         el_todo |= TODO_cleanup_cfg;</span>
<span class="lineNum">    5520 </span>            :     }
<span class="lineNum">    5521 </span>            : 
<span class="lineNum">    5522 </span><span class="lineCov">    2628835 :   bool do_eh_cleanup = !bitmap_empty_p (need_eh_cleanup);</span>
<span class="lineNum">    5523 </span><span class="lineCov">    2628835 :   bool do_ab_cleanup = !bitmap_empty_p (need_ab_cleanup);</span>
<span class="lineNum">    5524 </span>            : 
<span class="lineNum">    5525 </span><span class="lineCov">    2628835 :   if (do_eh_cleanup)</span>
<span class="lineNum">    5526 </span><span class="lineCov">       6354 :     gimple_purge_all_dead_eh_edges (need_eh_cleanup);</span>
<span class="lineNum">    5527 </span>            : 
<span class="lineNum">    5528 </span><span class="lineCov">    2628835 :   if (do_ab_cleanup)</span>
<span class="lineNum">    5529 </span><span class="lineCov">          2 :     gimple_purge_all_dead_abnormal_call_edges (need_ab_cleanup);</span>
<span class="lineNum">    5530 </span>            : 
<span class="lineNum">    5531 </span><span class="lineCov">    2628835 :   if (do_eh_cleanup || do_ab_cleanup)</span>
<span class="lineNum">    5532 </span><span class="lineCov">       6356 :     el_todo |= TODO_cleanup_cfg;</span>
<span class="lineNum">    5533 </span>            : 
<span class="lineNum">    5534 </span><span class="lineCov">    2628835 :   return el_todo;</span>
<span class="lineNum">    5535 </span>            : }
<span class="lineNum">    5536 </span>            : 
<span class="lineNum">    5537 </span>            : /* Eliminate fully redundant computations.  */
<a name="5538"><span class="lineNum">    5538 </span>            : </a>
<span class="lineNum">    5539 </span>            : unsigned
<span class="lineNum">    5540 </span><span class="lineCov">    2528926 : eliminate_with_rpo_vn (bitmap inserted_exprs)</span>
<span class="lineNum">    5541 </span>            : {
<span class="lineNum">    5542 </span><span class="lineCov">    5057852 :   eliminate_dom_walker walker (CDI_DOMINATORS, inserted_exprs);</span>
<span class="lineNum">    5543 </span>            : 
<span class="lineNum">    5544 </span><span class="lineCov">    2528926 :   walker.walk (cfun-&gt;cfg-&gt;x_entry_block_ptr);</span>
<span class="lineNum">    5545 </span><span class="lineCov">    2528926 :   return walker.eliminate_cleanup ();</span>
<span class="lineNum">    5546 </span>            : }
<span class="lineNum">    5547 </span>            : 
<span class="lineNum">    5548 </span>            : static unsigned
<span class="lineNum">    5549 </span>            : do_rpo_vn (function *fn, edge entry, bitmap exit_bbs,
<span class="lineNum">    5550 </span>            :            bool iterate, bool eliminate);
<a name="5551"><span class="lineNum">    5551 </span>            : </a>
<span class="lineNum">    5552 </span>            : void
<span class="lineNum">    5553 </span><span class="lineCov">     584052 : run_rpo_vn (vn_lookup_kind kind)</span>
<span class="lineNum">    5554 </span>            : {
<span class="lineNum">    5555 </span><span class="lineCov">     584052 :   default_vn_walk_kind = kind;</span>
<span class="lineNum">    5556 </span><span class="lineCov">     584052 :   do_rpo_vn (cfun, NULL, NULL, true, false);</span>
<span class="lineNum">    5557 </span>            : 
<span class="lineNum">    5558 </span>            :   /* ???  Prune requirement of these.  */
<span class="lineNum">    5559 </span><span class="lineCov">     584052 :   constant_to_value_id = new hash_table&lt;vn_constant_hasher&gt; (23);</span>
<span class="lineNum">    5560 </span><span class="lineCov">     584052 :   constant_value_ids = BITMAP_ALLOC (NULL);</span>
<span class="lineNum">    5561 </span>            : 
<span class="lineNum">    5562 </span>            :   /* Initialize the value ids and prune out remaining VN_TOPs
<span class="lineNum">    5563 </span>            :      from dead code.  */
<span class="lineNum">    5564 </span><span class="lineCov">     584052 :   tree name;</span>
<span class="lineNum">    5565 </span><span class="lineCov">     584052 :   unsigned i;</span>
<span class="lineNum">    5566 </span><span class="lineCov">   25621515 :   FOR_EACH_SSA_NAME (i, name, cfun)</span>
<span class="lineNum">    5567 </span>            :     {
<span class="lineNum">    5568 </span><span class="lineCov">   19337805 :       vn_ssa_aux_t info = VN_INFO (name);</span>
<span class="lineNum">    5569 </span><span class="lineCov">   19337805 :       if (!info-&gt;visited</span>
<span class="lineNum">    5570 </span><span class="lineCov">   19299557 :           || info-&gt;valnum == VN_TOP)</span>
<span class="lineNum">    5571 </span><span class="lineCov">      38248 :         info-&gt;valnum = name;</span>
<span class="lineNum">    5572 </span><span class="lineCov">   19337805 :       if (info-&gt;valnum == name)</span>
<span class="lineNum">    5573 </span><span class="lineCov">   18784339 :         info-&gt;value_id = get_next_value_id ();</span>
<span class="lineNum">    5574 </span><span class="lineCov">     553466 :       else if (is_gimple_min_invariant (info-&gt;valnum))</span>
<span class="lineNum">    5575 </span><span class="lineCov">      21701 :         info-&gt;value_id = get_or_alloc_constant_value_id (info-&gt;valnum);</span>
<span class="lineNum">    5576 </span>            :     }
<span class="lineNum">    5577 </span>            : 
<span class="lineNum">    5578 </span>            :   /* Propagate.  */
<span class="lineNum">    5579 </span><span class="lineCov">   25621515 :   FOR_EACH_SSA_NAME (i, name, cfun)</span>
<span class="lineNum">    5580 </span>            :     {
<span class="lineNum">    5581 </span><span class="lineCov">   19337805 :       vn_ssa_aux_t info = VN_INFO (name);</span>
<span class="lineNum">    5582 </span><span class="lineCov">   19337805 :       if (TREE_CODE (info-&gt;valnum) == SSA_NAME</span>
<span class="lineNum">    5583 </span><span class="lineCov">   19316104 :           &amp;&amp; info-&gt;valnum != name</span>
<span class="lineNum">    5584 </span><span class="lineCov">   19869570 :           &amp;&amp; info-&gt;value_id != VN_INFO (info-&gt;valnum)-&gt;value_id)</span>
<span class="lineNum">    5585 </span><span class="lineCov">     529754 :         info-&gt;value_id = VN_INFO (info-&gt;valnum)-&gt;value_id;</span>
<span class="lineNum">    5586 </span>            :     }
<span class="lineNum">    5587 </span>            : 
<span class="lineNum">    5588 </span><span class="lineCov">     584052 :   set_hashtable_value_ids ();</span>
<span class="lineNum">    5589 </span>            : 
<span class="lineNum">    5590 </span><span class="lineCov">     584052 :   if (dump_file &amp;&amp; (dump_flags &amp; TDF_DETAILS))</span>
<span class="lineNum">    5591 </span>            :     {
<span class="lineNum">    5592 </span><span class="lineCov">         14 :       fprintf (dump_file, &quot;Value numbers:\n&quot;);</span>
<span class="lineNum">    5593 </span><span class="lineCov">        420 :       FOR_EACH_SSA_NAME (i, name, cfun)</span>
<span class="lineNum">    5594 </span>            :         {
<span class="lineNum">    5595 </span><span class="lineCov">        280 :           if (VN_INFO (name)-&gt;visited</span>
<span class="lineNum">    5596 </span><span class="lineCov">        280 :               &amp;&amp; SSA_VAL (name) != name)</span>
<span class="lineNum">    5597 </span>            :             {
<span class="lineNum">    5598 </span><span class="lineCov">          9 :               print_generic_expr (dump_file, name);</span>
<span class="lineNum">    5599 </span><span class="lineCov">          9 :               fprintf (dump_file, &quot; = &quot;);</span>
<span class="lineNum">    5600 </span><span class="lineCov">          9 :               print_generic_expr (dump_file, SSA_VAL (name));</span>
<span class="lineNum">    5601 </span><span class="lineCov">          9 :               fprintf (dump_file, &quot; (%04d)\n&quot;, VN_INFO (name)-&gt;value_id);</span>
<span class="lineNum">    5602 </span>            :             }
<span class="lineNum">    5603 </span>            :         }
<span class="lineNum">    5604 </span>            :     }
<span class="lineNum">    5605 </span><span class="lineCov">     584052 : }</span>
<span class="lineNum">    5606 </span>            : 
<span class="lineNum">    5607 </span>            : /* Free VN associated data structures.  */
<a name="5608"><span class="lineNum">    5608 </span>            : </a>
<span class="lineNum">    5609 </span>            : void
<span class="lineNum">    5610 </span><span class="lineCov">    2628835 : free_rpo_vn (void)</span>
<span class="lineNum">    5611 </span>            : {
<span class="lineNum">    5612 </span><span class="lineCov">    2628835 :   free_vn_table (valid_info);</span>
<span class="lineNum">    5613 </span><span class="lineCov">    2628835 :   XDELETE (valid_info);</span>
<span class="lineNum">    5614 </span><span class="lineCov">    2628835 :   obstack_free (&amp;vn_tables_obstack, NULL);</span>
<span class="lineNum">    5615 </span><span class="lineCov">    2628835 :   obstack_free (&amp;vn_tables_insert_obstack, NULL);</span>
<span class="lineNum">    5616 </span>            : 
<span class="lineNum">    5617 </span><span class="lineCov">    2628835 :   vn_ssa_aux_iterator_type it;</span>
<span class="lineNum">    5618 </span><span class="lineCov">    2628835 :   vn_ssa_aux_t info;</span>
<span class="lineNum">    5619 </span><span class="lineCov">  230845662 :   FOR_EACH_HASH_TABLE_ELEMENT (*vn_ssa_aux_hash, info, vn_ssa_aux_t, it)</span>
<span class="lineNum">    5620 </span><span class="lineCov">   74319719 :     if (info-&gt;needs_insertion)</span>
<span class="lineNum">    5621 </span><span class="lineCov">    2341505 :       release_ssa_name (info-&gt;name);</span>
<span class="lineNum">    5622 </span><span class="lineCov">    2628835 :   obstack_free (&amp;vn_ssa_aux_obstack, NULL);</span>
<span class="lineNum">    5623 </span><span class="lineCov">    2628835 :   delete vn_ssa_aux_hash;</span>
<span class="lineNum">    5624 </span>            : 
<span class="lineNum">    5625 </span><span class="lineCov">    2628835 :   delete constant_to_value_id;</span>
<span class="lineNum">    5626 </span><span class="lineCov">    2628835 :   constant_to_value_id = NULL;</span>
<span class="lineNum">    5627 </span><span class="lineCov">    2628835 :   BITMAP_FREE (constant_value_ids);</span>
<span class="lineNum">    5628 </span><span class="lineCov">    2628835 : }</span>
<span class="lineNum">    5629 </span>            : 
<span class="lineNum">    5630 </span>            : /* Adaptor to the elimination engine using RPO availability.  */
<span class="lineNum">    5631 </span>            : 
<span class="lineNum">    5632 </span>            : class rpo_elim : public eliminate_dom_walker
<a name="5633"><span class="lineNum">    5633 </span>            : {</a>
<span class="lineNum">    5634 </span>            : public:
<span class="lineNum">    5635 </span><span class="lineCov">    2628835 :   rpo_elim(basic_block entry_)</span>
<span class="lineNum">    5636 </span><span class="lineCov">    2628835 :     : eliminate_dom_walker (CDI_DOMINATORS, NULL), entry (entry_) {}</span>
<span class="lineNum">    5637 </span>            :   ~rpo_elim();
<span class="lineNum">    5638 </span>            : 
<span class="lineNum">    5639 </span>            :   virtual tree eliminate_avail (basic_block, tree op);
<span class="lineNum">    5640 </span>            : 
<span class="lineNum">    5641 </span>            :   virtual void eliminate_push_avail (basic_block, tree);
<span class="lineNum">    5642 </span>            : 
<span class="lineNum">    5643 </span>            :   basic_block entry;
<span class="lineNum">    5644 </span>            :   /* Instead of having a local availability lattice for each
<span class="lineNum">    5645 </span>            :      basic-block and availability at X defined as union of
<span class="lineNum">    5646 </span>            :      the local availabilities at X and its dominators we're
<span class="lineNum">    5647 </span>            :      turning this upside down and track availability per
<span class="lineNum">    5648 </span>            :      value given values are usually made available at very
<span class="lineNum">    5649 </span>            :      few points (at least one).
<span class="lineNum">    5650 </span>            :      So we have a value -&gt; vec&lt;location, leader&gt; map where
<span class="lineNum">    5651 </span>            :      LOCATION is specifying the basic-block LEADER is made
<span class="lineNum">    5652 </span>            :      available for VALUE.  We push to this vector in RPO
<span class="lineNum">    5653 </span>            :      order thus for iteration we can simply pop the last
<span class="lineNum">    5654 </span>            :      entries.
<span class="lineNum">    5655 </span>            :      LOCATION is the basic-block index and LEADER is its
<span class="lineNum">    5656 </span>            :      SSA name version.  */
<span class="lineNum">    5657 </span>            :   /* ???  We'd like to use auto_vec here with embedded storage
<span class="lineNum">    5658 </span>            :      but that doesn't play well until we can provide move
<span class="lineNum">    5659 </span>            :      constructors and use std::move on hash-table expansion.
<span class="lineNum">    5660 </span>            :      So for now this is a bit more expensive than necessary.
<span class="lineNum">    5661 </span>            :      We eventually want to switch to a chaining scheme like
<span class="lineNum">    5662 </span>            :      for hashtable entries for unwinding which would make
<span class="lineNum">    5663 </span>            :      making the vector part of the vn_ssa_aux structure possible.  */
<span class="lineNum">    5664 </span>            :   typedef hash_map&lt;tree, vec&lt;std::pair&lt;int, int&gt; &gt; &gt; rpo_avail_t;
<span class="lineNum">    5665 </span>            :   rpo_avail_t m_rpo_avail;
<span class="lineNum">    5666 </span>            : };
<span class="lineNum">    5667 </span>            : 
<span class="lineNum">    5668 </span>            : /* Global RPO state for access from hooks.  */
<span class="lineNum">    5669 </span>            : static rpo_elim *rpo_avail;
<span class="lineNum">    5670 </span>            : 
<span class="lineNum">    5671 </span>            : /* Hook for maybe_push_res_to_seq, lookup the expression in the VN tables.  */
<a name="5672"><span class="lineNum">    5672 </span>            : </a>
<span class="lineNum">    5673 </span>            : static tree
<span class="lineNum">    5674 </span><span class="lineCov">    7814117 : vn_lookup_simplify_result (gimple_match_op *res_op)</span>
<span class="lineNum">    5675 </span>            : {
<span class="lineNum">    5676 </span><span class="lineCov">   15628234 :   if (!res_op-&gt;code.is_tree_code ())</span>
<span class="lineNum">    5677 </span>            :     return NULL_TREE;
<span class="lineNum">    5678 </span><span class="lineCov">    7814116 :   tree *ops = res_op-&gt;ops;</span>
<span class="lineNum">    5679 </span><span class="lineCov">    7814116 :   unsigned int length = res_op-&gt;num_ops;</span>
<span class="lineNum">    5680 </span><span class="lineCov">    7814116 :   if (res_op-&gt;code == CONSTRUCTOR</span>
<span class="lineNum">    5681 </span>            :       /* ???  We're arriving here with SCCVNs view, decomposed CONSTRUCTOR
<span class="lineNum">    5682 </span>            :          and GIMPLEs / match-and-simplifies, CONSTRUCTOR as GENERIC tree.  */
<span class="lineNum">    5683 </span><span class="lineCov">    7814116 :       &amp;&amp; TREE_CODE (res_op-&gt;ops[0]) == CONSTRUCTOR)</span>
<span class="lineNum">    5684 </span>            :     {
<span class="lineNum">    5685 </span><span class="lineNoCov">          0 :       length = CONSTRUCTOR_NELTS (res_op-&gt;ops[0]);</span>
<span class="lineNum">    5686 </span><span class="lineNoCov">          0 :       ops = XALLOCAVEC (tree, length);</span>
<span class="lineNum">    5687 </span><span class="lineNoCov">          0 :       for (unsigned i = 0; i &lt; length; ++i)</span>
<span class="lineNum">    5688 </span><span class="lineNoCov">          0 :         ops[i] = CONSTRUCTOR_ELT (res_op-&gt;ops[0], i)-&gt;value;</span>
<span class="lineNum">    5689 </span>            :     }
<span class="lineNum">    5690 </span><span class="lineCov">    7814116 :   vn_nary_op_t vnresult = NULL;</span>
<span class="lineNum">    5691 </span><span class="lineCov">   15628232 :   tree res = vn_nary_op_lookup_pieces (length, (tree_code) res_op-&gt;code,</span>
<span class="lineNum">    5692 </span><span class="lineCov">    7814116 :                                        res_op-&gt;type, ops, &amp;vnresult);</span>
<span class="lineNum">    5693 </span>            :   /* If this is used from expression simplification make sure to
<span class="lineNum">    5694 </span>            :      return an available expression.  */
<span class="lineNum">    5695 </span><span class="lineCov">    7814116 :   if (res &amp;&amp; TREE_CODE (res) == SSA_NAME &amp;&amp; mprts_hook &amp;&amp; rpo_avail)</span>
<span class="lineNum">    5696 </span><span class="lineCov">    1361466 :     res = rpo_avail-&gt;eliminate_avail (vn_context_bb, res);</span>
<span class="lineNum">    5697 </span>            :   return res;
<a name="5698"><span class="lineNum">    5698 </span>            : }</a>
<span class="lineNum">    5699 </span>            : 
<span class="lineNum">    5700 </span><span class="lineCov">    2628835 : rpo_elim::~rpo_elim ()</span>
<span class="lineNum">    5701 </span>            : {
<span class="lineNum">    5702 </span>            :   /* Release the avail vectors.  */
<span class="lineNum">    5703 </span><span class="lineCov">    2628835 :   for (rpo_avail_t::iterator i = m_rpo_avail.begin ();</span>
<span class="lineNum">    5704 </span><span class="lineCov">   67170745 :        i != m_rpo_avail.end (); ++i)</span>
<span class="lineNum">    5705 </span><span class="lineCov">   88926360 :     (*i).second.release ();</span>
<span class="lineNum">    5706 </span><span class="lineCov">    2628835 : }</span>
<span class="lineNum">    5707 </span>            : 
<span class="lineNum">    5708 </span>            : /* Return a leader for OPs value that is valid at BB.  */
<a name="5709"><span class="lineNum">    5709 </span>            : </a>
<span class="lineNum">    5710 </span>            : tree
<span class="lineNum">    5711 </span><span class="lineCov">   81949022 : rpo_elim::eliminate_avail (basic_block bb, tree op)</span>
<span class="lineNum">    5712 </span>            : {
<span class="lineNum">    5713 </span><span class="lineCov">   81949022 :   bool visited;</span>
<span class="lineNum">    5714 </span><span class="lineCov">   81949022 :   tree valnum = SSA_VAL (op, &amp;visited);</span>
<span class="lineNum">    5715 </span>            :   /* If we didn't visit OP then it must be defined outside of the
<span class="lineNum">    5716 </span>            :      region we process and also dominate it.  So it is available.  */
<span class="lineNum">    5717 </span><span class="lineCov">   81949022 :   if (!visited)</span>
<span class="lineNum">    5718 </span>            :     return op;
<span class="lineNum">    5719 </span><span class="lineCov">   81699205 :   if (TREE_CODE (valnum) == SSA_NAME)</span>
<span class="lineNum">    5720 </span>            :     {
<span class="lineNum">    5721 </span><span class="lineCov">  151239506 :       if (SSA_NAME_IS_DEFAULT_DEF (valnum))</span>
<span class="lineNum">    5722 </span>            :         return valnum;
<span class="lineNum">    5723 </span><span class="lineCov">   74631423 :       vec&lt;std::pair&lt;int, int&gt; &gt; *av = m_rpo_avail.get (valnum);</span>
<span class="lineNum">    5724 </span><span class="lineCov">   48093926 :       if (!av || av-&gt;is_empty ())</span>
<span class="lineNum">    5725 </span>            :         return NULL_TREE;
<span class="lineNum">    5726 </span><span class="lineCov">   37498357 :       int i = av-&gt;length () - 1;</span>
<span class="lineNum">    5727 </span><span class="lineCov">   74996714 :       if ((*av)[i].first == bb-&gt;index)</span>
<span class="lineNum">    5728 </span>            :         /* On tramp3d 90% of the cases are here.  */
<span class="lineNum">    5729 </span><span class="lineCov">   37051430 :         return ssa_name ((*av)[i].second);</span>
<span class="lineNum">    5730 </span><span class="lineCov">   21149437 :       do</span>
<span class="lineNum">    5731 </span>            :         {
<span class="lineNum">    5732 </span><span class="lineCov">   21149437 :           basic_block abb = BASIC_BLOCK_FOR_FN (cfun, (*av)[i].first);</span>
<span class="lineNum">    5733 </span>            :           /* ???  During elimination we have to use availability at the
<span class="lineNum">    5734 </span>            :              definition site of a use we try to replace.  This
<span class="lineNum">    5735 </span>            :              is required to not run into inconsistencies because
<span class="lineNum">    5736 </span>            :              of dominated_by_p_w_unex behavior and removing a definition
<span class="lineNum">    5737 </span>            :              while not replacing all uses.
<span class="lineNum">    5738 </span>            :              ???  We could try to consistently walk dominators
<span class="lineNum">    5739 </span>            :              ignoring non-executable regions.  The nearest common
<span class="lineNum">    5740 </span>            :              dominator of bb and abb is where we can stop walking.  We
<span class="lineNum">    5741 </span>            :              may also be able to &quot;pre-compute&quot; (bits of) the next immediate
<span class="lineNum">    5742 </span>            :              (non-)dominator during the RPO walk when marking edges as
<span class="lineNum">    5743 </span>            :              executable.  */
<span class="lineNum">    5744 </span><span class="lineCov">   21149437 :           if (dominated_by_p_w_unex (bb, abb))</span>
<span class="lineNum">    5745 </span>            :             {
<span class="lineNum">    5746 </span><span class="lineCov">   17217138 :               tree leader = ssa_name ((*av)[i].second);</span>
<span class="lineNum">    5747 </span>            :               /* Prevent eliminations that break loop-closed SSA.  */
<span class="lineNum">    5748 </span><span class="lineCov">   17217138 :               if (loops_state_satisfies_p (LOOP_CLOSED_SSA)</span>
<span class="lineNum">    5749 </span><span class="lineCov">     422967 :                   &amp;&amp; ! SSA_NAME_IS_DEFAULT_DEF (leader)</span>
<span class="lineNum">    5750 </span><span class="lineCov">   18063072 :                   &amp;&amp; ! flow_bb_inside_loop_p (gimple_bb (SSA_NAME_DEF_STMT</span>
<span class="lineNum">    5751 </span><span class="lineCov">     422967 :                                                          (leader))-&gt;loop_father,</span>
<span class="lineNum">    5752 </span>            :                                               bb))
<span class="lineNum">    5753 </span>            :                 return NULL_TREE;
<span class="lineNum">    5754 </span><span class="lineCov">   17202719 :               if (dump_file &amp;&amp; (dump_flags &amp; TDF_DETAILS))</span>
<span class="lineNum">    5755 </span>            :                 {
<span class="lineNum">    5756 </span><span class="lineCov">         61 :                   print_generic_expr (dump_file, leader);</span>
<span class="lineNum">    5757 </span><span class="lineCov">         61 :                   fprintf (dump_file, &quot; is available for &quot;);</span>
<span class="lineNum">    5758 </span><span class="lineCov">         61 :                   print_generic_expr (dump_file, valnum);</span>
<span class="lineNum">    5759 </span><span class="lineCov">         61 :                   fprintf (dump_file, &quot;\n&quot;);</span>
<span class="lineNum">    5760 </span>            :                 }
<span class="lineNum">    5761 </span>            :               /* On tramp3d 99% of the _remaining_ cases succeed at
<span class="lineNum">    5762 </span>            :                  the first enty.  */
<span class="lineNum">    5763 </span><span class="lineCov">   17202719 :               return leader;</span>
<span class="lineNum">    5764 </span>            :             }
<span class="lineNum">    5765 </span>            :           /* ???  Can we somehow skip to the immediate dominator
<span class="lineNum">    5766 </span>            :              RPO index (bb_to_rpo)?  Again, maybe not worth, on
<span class="lineNum">    5767 </span>            :              tramp3d the worst number of elements in the vector is 9.  */
<span class="lineNum">    5768 </span>            :         }
<span class="lineNum">    5769 </span><span class="lineCov">    3932299 :       while (--i &gt;= 0);</span>
<span class="lineNum">    5770 </span>            :     }
<span class="lineNum">    5771 </span><span class="lineCov">    6079452 :   else if (valnum != VN_TOP)</span>
<span class="lineNum">    5772 </span>            :     /* valnum is is_gimple_min_invariant.  */
<span class="lineNum">    5773 </span><span class="lineCov">    6079452 :     return valnum;</span>
<span class="lineNum">    5774 </span>            :   return NULL_TREE;
<span class="lineNum">    5775 </span>            : }
<span class="lineNum">    5776 </span>            : 
<span class="lineNum">    5777 </span>            : /* Make LEADER a leader for its value at BB.  */
<a name="5778"><span class="lineNum">    5778 </span>            : </a>
<span class="lineNum">    5779 </span>            : void
<span class="lineNum">    5780 </span><span class="lineCov">   42997487 : rpo_elim::eliminate_push_avail (basic_block bb, tree leader)</span>
<span class="lineNum">    5781 </span>            : {
<span class="lineNum">    5782 </span><span class="lineCov">   42997487 :   tree valnum = VN_INFO (leader)-&gt;valnum;</span>
<span class="lineNum">    5783 </span><span class="lineCov">   42997487 :   if (valnum == VN_TOP)</span>
<span class="lineNum">    5784 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">    5785 </span><span class="lineCov">   42997487 :   if (dump_file &amp;&amp; (dump_flags &amp; TDF_DETAILS))</span>
<span class="lineNum">    5786 </span>            :     {
<span class="lineNum">    5787 </span><span class="lineCov">        713 :       fprintf (dump_file, &quot;Making available beyond BB%d &quot;, bb-&gt;index);</span>
<span class="lineNum">    5788 </span><span class="lineCov">        713 :       print_generic_expr (dump_file, leader);</span>
<span class="lineNum">    5789 </span><span class="lineCov">        713 :       fprintf (dump_file, &quot; for value &quot;);</span>
<span class="lineNum">    5790 </span><span class="lineCov">        713 :       print_generic_expr (dump_file, valnum);</span>
<span class="lineNum">    5791 </span><span class="lineCov">        713 :       fprintf (dump_file, &quot;\n&quot;);</span>
<span class="lineNum">    5792 </span>            :     }
<span class="lineNum">    5793 </span><span class="lineCov">   42997487 :   bool existed;</span>
<span class="lineNum">    5794 </span><span class="lineCov">   42997487 :   vec&lt;std::pair&lt;int, int&gt; &gt; &amp;av = m_rpo_avail.get_or_insert (valnum, &amp;existed);</span>
<span class="lineNum">    5795 </span><span class="lineCov">   42997487 :   if (!existed)</span>
<span class="lineNum">    5796 </span>            :     {
<span class="lineNum">    5797 </span><span class="lineCov">   29642120 :       new (&amp;av) vec&lt;std::pair&lt;int, int&gt; &gt;;</span>
<span class="lineNum">    5798 </span><span class="lineCov">   29642120 :       av = vNULL;</span>
<span class="lineNum">    5799 </span><span class="lineCov">   29642120 :       av.reserve_exact (2);</span>
<span class="lineNum">    5800 </span>            :     }
<span class="lineNum">    5801 </span><span class="lineCov">   42997487 :   av.safe_push (std::make_pair (bb-&gt;index, SSA_NAME_VERSION (leader)));</span>
<span class="lineNum">    5802 </span>            : }
<span class="lineNum">    5803 </span>            : 
<span class="lineNum">    5804 </span>            : /* Valueization hook for RPO VN plus required state.  */
<a name="5805"><span class="lineNum">    5805 </span>            : </a>
<span class="lineNum">    5806 </span>            : tree
<span class="lineNum">    5807 </span><span class="lineCov">  500373792 : rpo_vn_valueize (tree name)</span>
<span class="lineNum">    5808 </span>            : {
<span class="lineNum">    5809 </span><span class="lineCov">  500373792 :   if (TREE_CODE (name) == SSA_NAME)</span>
<span class="lineNum">    5810 </span>            :     {
<span class="lineNum">    5811 </span><span class="lineCov">  478919720 :       vn_ssa_aux_t val = VN_INFO (name);</span>
<span class="lineNum">    5812 </span><span class="lineCov">  478919720 :       if (val)</span>
<span class="lineNum">    5813 </span>            :         {
<span class="lineNum">    5814 </span><span class="lineCov">  478919720 :           tree tem = val-&gt;valnum;</span>
<span class="lineNum">    5815 </span><span class="lineCov">  478919720 :           if (tem != VN_TOP &amp;&amp; tem != name)</span>
<span class="lineNum">    5816 </span>            :             {
<span class="lineNum">    5817 </span><span class="lineCov">   30933906 :               if (TREE_CODE (tem) != SSA_NAME)</span>
<span class="lineNum">    5818 </span>            :                 return tem;
<span class="lineNum">    5819 </span>            :               /* For all values we only valueize to an available leader
<span class="lineNum">    5820 </span>            :                  which means we can use SSA name info without restriction.  */
<span class="lineNum">    5821 </span><span class="lineCov">   24132984 :               tem = rpo_avail-&gt;eliminate_avail (vn_context_bb, tem);</span>
<span class="lineNum">    5822 </span><span class="lineCov">   24132984 :               if (tem)</span>
<span class="lineNum">    5823 </span><span class="lineCov">   23981827 :                 return tem;</span>
<span class="lineNum">    5824 </span>            :             }
<span class="lineNum">    5825 </span>            :         }
<span class="lineNum">    5826 </span>            :     }
<span class="lineNum">    5827 </span>            :   return name;
<span class="lineNum">    5828 </span>            : }
<span class="lineNum">    5829 </span>            : 
<span class="lineNum">    5830 </span>            : /* Insert on PRED_E predicates derived from CODE OPS being true besides the
<span class="lineNum">    5831 </span>            :    inverted condition.  */
<a name="5832"><span class="lineNum">    5832 </span>            : </a>
<span class="lineNum">    5833 </span>            : static void
<span class="lineNum">    5834 </span><span class="lineCov">   14786693 : insert_related_predicates_on_edge (enum tree_code code, tree *ops, edge pred_e)</span>
<span class="lineNum">    5835 </span>            : {
<span class="lineNum">    5836 </span><span class="lineCov">   14786693 :   switch (code)</span>
<span class="lineNum">    5837 </span>            :     {
<span class="lineNum">    5838 </span><span class="lineCov">    1154486 :     case LT_EXPR:</span>
<span class="lineNum">    5839 </span>            :       /* a &lt; b -&gt; a {!,&lt;}= b */
<span class="lineNum">    5840 </span><span class="lineCov">    1154486 :       vn_nary_op_insert_pieces_predicated (2, NE_EXPR, boolean_type_node,</span>
<span class="lineNum">    5841 </span>            :                                            ops, boolean_true_node, 0, pred_e);
<span class="lineNum">    5842 </span><span class="lineCov">    1154486 :       vn_nary_op_insert_pieces_predicated (2, LE_EXPR, boolean_type_node,</span>
<span class="lineNum">    5843 </span>            :                                            ops, boolean_true_node, 0, pred_e);
<span class="lineNum">    5844 </span>            :       /* a &lt; b -&gt; ! a {&gt;,=} b */
<span class="lineNum">    5845 </span><span class="lineCov">    1154486 :       vn_nary_op_insert_pieces_predicated (2, GT_EXPR, boolean_type_node,</span>
<span class="lineNum">    5846 </span>            :                                            ops, boolean_false_node, 0, pred_e);
<span class="lineNum">    5847 </span><span class="lineCov">    1154486 :       vn_nary_op_insert_pieces_predicated (2, EQ_EXPR, boolean_type_node,</span>
<span class="lineNum">    5848 </span>            :                                            ops, boolean_false_node, 0, pred_e);
<span class="lineNum">    5849 </span><span class="lineCov">    1154486 :       break;</span>
<span class="lineNum">    5850 </span><span class="lineCov">    1608991 :     case GT_EXPR:</span>
<span class="lineNum">    5851 </span>            :       /* a &gt; b -&gt; a {!,&gt;}= b */
<span class="lineNum">    5852 </span><span class="lineCov">    1608991 :       vn_nary_op_insert_pieces_predicated (2, NE_EXPR, boolean_type_node,</span>
<span class="lineNum">    5853 </span>            :                                            ops, boolean_true_node, 0, pred_e);
<span class="lineNum">    5854 </span><span class="lineCov">    1608991 :       vn_nary_op_insert_pieces_predicated (2, GE_EXPR, boolean_type_node,</span>
<span class="lineNum">    5855 </span>            :                                            ops, boolean_true_node, 0, pred_e);
<span class="lineNum">    5856 </span>            :       /* a &gt; b -&gt; ! a {&lt;,=} b */
<span class="lineNum">    5857 </span><span class="lineCov">    1608991 :       vn_nary_op_insert_pieces_predicated (2, LT_EXPR, boolean_type_node,</span>
<span class="lineNum">    5858 </span>            :                                            ops, boolean_false_node, 0, pred_e);
<span class="lineNum">    5859 </span><span class="lineCov">    1608991 :       vn_nary_op_insert_pieces_predicated (2, EQ_EXPR, boolean_type_node,</span>
<span class="lineNum">    5860 </span>            :                                            ops, boolean_false_node, 0, pred_e);
<span class="lineNum">    5861 </span><span class="lineCov">    1608991 :       break;</span>
<span class="lineNum">    5862 </span><span class="lineCov">    4632980 :     case EQ_EXPR:</span>
<span class="lineNum">    5863 </span>            :       /* a == b -&gt; ! a {&lt;,&gt;} b */
<span class="lineNum">    5864 </span><span class="lineCov">    4632980 :       vn_nary_op_insert_pieces_predicated (2, LT_EXPR, boolean_type_node,</span>
<span class="lineNum">    5865 </span>            :                                            ops, boolean_false_node, 0, pred_e);
<span class="lineNum">    5866 </span><span class="lineCov">    4632980 :       vn_nary_op_insert_pieces_predicated (2, GT_EXPR, boolean_type_node,</span>
<span class="lineNum">    5867 </span>            :                                            ops, boolean_false_node, 0, pred_e);
<span class="lineNum">    5868 </span><span class="lineCov">    4632980 :       break;</span>
<span class="lineNum">    5869 </span>            :     case LE_EXPR:
<span class="lineNum">    5870 </span>            :     case GE_EXPR:
<span class="lineNum">    5871 </span>            :     case NE_EXPR:
<span class="lineNum">    5872 </span>            :       /* Nothing besides inverted condition.  */
<span class="lineNum">    5873 </span>            :       break;
<span class="lineNum">    5874 </span><span class="lineCov">   14786693 :     default:;</span>
<span class="lineNum">    5875 </span>            :     }
<span class="lineNum">    5876 </span><span class="lineCov">   14786693 : }</span>
<span class="lineNum">    5877 </span>            : 
<span class="lineNum">    5878 </span>            : /* Main stmt worker for RPO VN, process BB.  */
<a name="5879"><span class="lineNum">    5879 </span>            : </a>
<span class="lineNum">    5880 </span>            : static unsigned
<span class="lineNum">    5881 </span><span class="lineCov">   28571342 : process_bb (rpo_elim &amp;avail, basic_block bb,</span>
<span class="lineNum">    5882 </span>            :             bool bb_visited, bool iterate_phis, bool iterate, bool eliminate,
<span class="lineNum">    5883 </span>            :             bool do_region, bitmap exit_bbs)
<span class="lineNum">    5884 </span>            : {
<span class="lineNum">    5885 </span><span class="lineCov">   28571342 :   unsigned todo = 0;</span>
<span class="lineNum">    5886 </span><span class="lineCov">   28571342 :   edge_iterator ei;</span>
<span class="lineNum">    5887 </span><span class="lineCov">   28571342 :   edge e;</span>
<span class="lineNum">    5888 </span>            : 
<span class="lineNum">    5889 </span><span class="lineCov">   28571342 :   vn_context_bb = bb;</span>
<span class="lineNum">    5890 </span>            : 
<span class="lineNum">    5891 </span>            :   /* If we are in loop-closed SSA preserve this state.  This is
<span class="lineNum">    5892 </span>            :      relevant when called on regions from outside of FRE/PRE.  */
<span class="lineNum">    5893 </span><span class="lineCov">   28571342 :   bool lc_phi_nodes = false;</span>
<span class="lineNum">    5894 </span><span class="lineCov">   57142684 :   if (loops_state_satisfies_p (LOOP_CLOSED_SSA))</span>
<span class="lineNum">    5895 </span><span class="lineCov">     479056 :     FOR_EACH_EDGE (e, ei, bb-&gt;preds)</span>
<span class="lineNum">    5896 </span><span class="lineCov">     193928 :       if (e-&gt;src-&gt;loop_father != e-&gt;dest-&gt;loop_father</span>
<span class="lineNum">    5897 </span><span class="lineCov">     193928 :           &amp;&amp; flow_loop_nested_p (e-&gt;dest-&gt;loop_father,</span>
<span class="lineNum">    5898 </span>            :                                  e-&gt;src-&gt;loop_father))
<span class="lineNum">    5899 </span>            :         {
<span class="lineNum">    5900 </span>            :           lc_phi_nodes = true;
<span class="lineNum">    5901 </span>            :           break;
<span class="lineNum">    5902 </span>            :         }
<span class="lineNum">    5903 </span>            : 
<span class="lineNum">    5904 </span>            :   /* Value-number all defs in the basic-block.  */
<span class="lineNum">    5905 </span><span class="lineCov">   51169628 :   for (gphi_iterator gsi = gsi_start_phis (bb); !gsi_end_p (gsi);</span>
<span class="lineNum">    5906 </span><span class="lineCov">   11299143 :        gsi_next (&amp;gsi))</span>
<span class="lineNum">    5907 </span>            :     {
<span class="lineNum">    5908 </span><span class="lineCov">   11299143 :       gphi *phi = gsi.phi ();</span>
<span class="lineNum">    5909 </span><span class="lineCov">   22598286 :       tree res = PHI_RESULT (phi);</span>
<span class="lineNum">    5910 </span><span class="lineCov">   11299143 :       vn_ssa_aux_t res_info = VN_INFO (res);</span>
<span class="lineNum">    5911 </span><span class="lineCov">   11299143 :       if (!bb_visited)</span>
<span class="lineNum">    5912 </span>            :         {
<span class="lineNum">    5913 </span><span class="lineCov">    6874473 :           gcc_assert (!res_info-&gt;visited);</span>
<span class="lineNum">    5914 </span><span class="lineCov">    6874473 :           res_info-&gt;valnum = VN_TOP;</span>
<span class="lineNum">    5915 </span><span class="lineCov">    6874473 :           res_info-&gt;visited = true;</span>
<span class="lineNum">    5916 </span>            :         }
<span class="lineNum">    5917 </span>            : 
<span class="lineNum">    5918 </span>            :       /* When not iterating force backedge values to varying.  */
<span class="lineNum">    5919 </span><span class="lineCov">   11299143 :       visit_stmt (phi, !iterate_phis);</span>
<span class="lineNum">    5920 </span><span class="lineCov">   22598286 :       if (virtual_operand_p (res))</span>
<span class="lineNum">    5921 </span>            :         continue;
<span class="lineNum">    5922 </span>            : 
<span class="lineNum">    5923 </span>            :       /* Eliminate */
<span class="lineNum">    5924 </span>            :       /* The interesting case is gcc.dg/tree-ssa/pr22230.c for correctness
<span class="lineNum">    5925 </span>            :          how we handle backedges and availability.
<span class="lineNum">    5926 </span>            :          And gcc.dg/tree-ssa/ssa-sccvn-2.c for optimization.  */
<span class="lineNum">    5927 </span><span class="lineCov">    6565922 :       tree val = res_info-&gt;valnum;</span>
<span class="lineNum">    5928 </span><span class="lineCov">    6565922 :       if (res != val &amp;&amp; !iterate &amp;&amp; eliminate)</span>
<span class="lineNum">    5929 </span>            :         {
<span class="lineNum">    5930 </span><span class="lineCov">     158386 :           if (tree leader = avail.eliminate_avail (bb, res))</span>
<span class="lineNum">    5931 </span>            :             {
<span class="lineNum">    5932 </span><span class="lineCov">     142997 :               if (leader != res</span>
<span class="lineNum">    5933 </span>            :                   /* Preserve loop-closed SSA form.  */
<span class="lineNum">    5934 </span><span class="lineCov">     142997 :                   &amp;&amp; (! lc_phi_nodes</span>
<span class="lineNum">    5935 </span><span class="lineCov">        156 :                       || is_gimple_min_invariant (leader)))</span>
<span class="lineNum">    5936 </span>            :                 {
<span class="lineNum">    5937 </span><span class="lineCov">     142978 :                   if (dump_file &amp;&amp; (dump_flags &amp; TDF_DETAILS))</span>
<span class="lineNum">    5938 </span>            :                     {
<span class="lineNum">    5939 </span><span class="lineCov">         32 :                       fprintf (dump_file, &quot;Replaced redundant PHI node &quot;</span>
<span class="lineNum">    5940 </span>            :                                &quot;defining &quot;);
<span class="lineNum">    5941 </span><span class="lineCov">         32 :                       print_generic_expr (dump_file, res);</span>
<span class="lineNum">    5942 </span><span class="lineCov">         32 :                       fprintf (dump_file, &quot; with &quot;);</span>
<span class="lineNum">    5943 </span><span class="lineCov">         32 :                       print_generic_expr (dump_file, leader);</span>
<span class="lineNum">    5944 </span><span class="lineCov">         32 :                       fprintf (dump_file, &quot;\n&quot;);</span>
<span class="lineNum">    5945 </span>            :                     }
<span class="lineNum">    5946 </span><span class="lineCov">     142978 :                   avail.eliminations++;</span>
<span class="lineNum">    5947 </span>            : 
<span class="lineNum">    5948 </span><span class="lineCov">     142978 :                   if (may_propagate_copy (res, leader))</span>
<span class="lineNum">    5949 </span>            :                     {
<span class="lineNum">    5950 </span>            :                       /* Schedule for removal.  */
<span class="lineNum">    5951 </span><span class="lineCov">     142978 :                       avail.to_remove.safe_push (phi);</span>
<span class="lineNum">    5952 </span><span class="lineCov">     142978 :                       continue;</span>
<span class="lineNum">    5953 </span>            :                     }
<span class="lineNum">    5954 </span>            :                   /* ???  Else generate a copy stmt.  */
<span class="lineNum">    5955 </span>            :                 }
<span class="lineNum">    5956 </span>            :             }
<span class="lineNum">    5957 </span>            :         }
<span class="lineNum">    5958 </span>            :       /* Only make defs available that not already are.  But make
<span class="lineNum">    5959 </span>            :          sure loop-closed SSA PHI node defs are picked up for
<span class="lineNum">    5960 </span>            :          downstream uses.  */
<span class="lineNum">    5961 </span><span class="lineCov">    6422944 :       if (lc_phi_nodes</span>
<span class="lineNum">    5962 </span><span class="lineCov">    6422944 :           || res == val</span>
<span class="lineNum">    5963 </span><span class="lineCov">    6422944 :           || ! avail.eliminate_avail (bb, res))</span>
<span class="lineNum">    5964 </span><span class="lineCov">    4369404 :         avail.eliminate_push_avail (bb, res);</span>
<span class="lineNum">    5965 </span>            :     }
<span class="lineNum">    5966 </span>            : 
<span class="lineNum">    5967 </span>            :   /* For empty BBs mark outgoing edges executable.  For non-empty BBs
<span class="lineNum">    5968 </span>            :      we do this when processing the last stmt as we have to do this
<span class="lineNum">    5969 </span>            :      before elimination which otherwise forces GIMPLE_CONDs to
<span class="lineNum">    5970 </span>            :      if (1 != 0) style when seeing non-executable edges.  */
<span class="lineNum">    5971 </span><span class="lineCov">   85714026 :   if (gsi_end_p (gsi_start_bb (bb)))</span>
<span class="lineNum">    5972 </span>            :     {
<span class="lineNum">    5973 </span><span class="lineCov">   10829049 :       FOR_EACH_EDGE (e, ei, bb-&gt;succs)</span>
<span class="lineNum">    5974 </span>            :         {
<span class="lineNum">    5975 </span><span class="lineCov">    3609691 :           if (!(e-&gt;flags &amp; EDGE_EXECUTABLE))</span>
<span class="lineNum">    5976 </span>            :             {
<span class="lineNum">    5977 </span><span class="lineCov">    2525064 :               if (dump_file &amp;&amp; (dump_flags &amp; TDF_DETAILS))</span>
<span class="lineNum">    5978 </span><span class="lineCov">        240 :                 fprintf (dump_file,</span>
<span class="lineNum">    5979 </span>            :                          &quot;marking outgoing edge %d -&gt; %d executable\n&quot;,
<span class="lineNum">    5980 </span><span class="lineCov">         80 :                          e-&gt;src-&gt;index, e-&gt;dest-&gt;index);</span>
<span class="lineNum">    5981 </span><span class="lineCov">    2525064 :               e-&gt;flags |= EDGE_EXECUTABLE;</span>
<span class="lineNum">    5982 </span><span class="lineCov">    2525064 :               e-&gt;dest-&gt;flags |= BB_EXECUTABLE;</span>
<span class="lineNum">    5983 </span>            :             }
<span class="lineNum">    5984 </span><span class="lineCov">    1084627 :           else if (!(e-&gt;dest-&gt;flags &amp; BB_EXECUTABLE))</span>
<span class="lineNum">    5985 </span>            :             {
<span class="lineNum">    5986 </span><span class="lineNoCov">          0 :               if (dump_file &amp;&amp; (dump_flags &amp; TDF_DETAILS))</span>
<span class="lineNum">    5987 </span><span class="lineNoCov">          0 :                 fprintf (dump_file,</span>
<span class="lineNum">    5988 </span>            :                          &quot;marking destination block %d reachable\n&quot;,
<span class="lineNum">    5989 </span>            :                          e-&gt;dest-&gt;index);
<span class="lineNum">    5990 </span><span class="lineNoCov">          0 :               e-&gt;dest-&gt;flags |= BB_EXECUTABLE;</span>
<span class="lineNum">    5991 </span>            :             }
<span class="lineNum">    5992 </span>            :         }
<span class="lineNum">    5993 </span>            :     }
<span class="lineNum">    5994 </span><span class="lineCov">   28571342 :   for (gimple_stmt_iterator gsi = gsi_start_bb (bb);</span>
<span class="lineNum">    5995 </span><span class="lineCov">  256366928 :        !gsi_end_p (gsi); gsi_next (&amp;gsi))</span>
<span class="lineNum">    5996 </span>            :     {
<span class="lineNum">    5997 </span><span class="lineCov">  199224244 :       ssa_op_iter i;</span>
<span class="lineNum">    5998 </span><span class="lineCov">  199224244 :       tree op;</span>
<span class="lineNum">    5999 </span><span class="lineCov">  199224244 :       if (!bb_visited)</span>
<span class="lineNum">    6000 </span>            :         {
<span class="lineNum">    6001 </span><span class="lineCov">  432380230 :           FOR_EACH_SSA_TREE_OPERAND (op, gsi_stmt (gsi), i, SSA_OP_ALL_DEFS)</span>
<span class="lineNum">    6002 </span>            :             {
<span class="lineNum">    6003 </span><span class="lineCov">   59440866 :               vn_ssa_aux_t op_info = VN_INFO (op);</span>
<span class="lineNum">    6004 </span><span class="lineCov">   59440866 :               gcc_assert (!op_info-&gt;visited);</span>
<span class="lineNum">    6005 </span><span class="lineCov">   59440866 :               op_info-&gt;valnum = VN_TOP;</span>
<span class="lineNum">    6006 </span><span class="lineCov">   59440866 :               op_info-&gt;visited = true;</span>
<span class="lineNum">    6007 </span>            :             }
<span class="lineNum">    6008 </span>            : 
<span class="lineNum">    6009 </span>            :           /* We somehow have to deal with uses that are not defined
<span class="lineNum">    6010 </span>            :              in the processed region.  Forcing unvisited uses to
<span class="lineNum">    6011 </span>            :              varying here doesn't play well with def-use following during
<span class="lineNum">    6012 </span>            :              expression simplification, so we deal with this by checking
<span class="lineNum">    6013 </span>            :              the visited flag in SSA_VAL.  */
<span class="lineNum">    6014 </span>            :         }
<span class="lineNum">    6015 </span>            : 
<span class="lineNum">    6016 </span><span class="lineCov">  398448488 :       visit_stmt (gsi_stmt (gsi));</span>
<span class="lineNum">    6017 </span>            : 
<span class="lineNum">    6018 </span><span class="lineCov">  199224244 :       gimple *last = gsi_stmt (gsi);</span>
<span class="lineNum">    6019 </span><span class="lineCov">  199224244 :       e = NULL;</span>
<span class="lineNum">    6020 </span><span class="lineCov">  398448488 :       switch (gimple_code (last))</span>
<span class="lineNum">    6021 </span>            :         {
<span class="lineNum">    6022 </span><span class="lineCov">      50963 :         case GIMPLE_SWITCH:</span>
<span class="lineNum">    6023 </span><span class="lineCov">      50963 :           e = find_taken_edge (bb, vn_valueize (gimple_switch_index</span>
<span class="lineNum">    6024 </span><span class="lineCov">      50963 :                                                 (as_a &lt;gswitch *&gt; (last))));</span>
<span class="lineNum">    6025 </span><span class="lineCov">      50963 :           break;</span>
<span class="lineNum">    6026 </span><span class="lineCov">   10402701 :         case GIMPLE_COND:</span>
<span class="lineNum">    6027 </span><span class="lineCov">   10402701 :           {</span>
<span class="lineNum">    6028 </span><span class="lineCov">   10402701 :             tree lhs = vn_valueize (gimple_cond_lhs (last));</span>
<span class="lineNum">    6029 </span><span class="lineCov">   10402701 :             tree rhs = vn_valueize (gimple_cond_rhs (last));</span>
<span class="lineNum">    6030 </span><span class="lineCov">   10402701 :             tree val = gimple_simplify (gimple_cond_code (last),</span>
<span class="lineNum">    6031 </span>            :                                         boolean_type_node, lhs, rhs,
<span class="lineNum">    6032 </span><span class="lineCov">   10402701 :                                         NULL, vn_valueize);</span>
<span class="lineNum">    6033 </span>            :             /* If the condition didn't simplfy see if we have recorded
<span class="lineNum">    6034 </span>            :                an expression from sofar taken edges.  */
<span class="lineNum">    6035 </span><span class="lineCov">   10402701 :             if (! val || TREE_CODE (val) != INTEGER_CST)</span>
<span class="lineNum">    6036 </span>            :               {
<span class="lineNum">    6037 </span><span class="lineCov">    9755732 :                 vn_nary_op_t vnresult;</span>
<span class="lineNum">    6038 </span><span class="lineCov">    9755732 :                 tree ops[2];</span>
<span class="lineNum">    6039 </span><span class="lineCov">    9755732 :                 ops[0] = lhs;</span>
<span class="lineNum">    6040 </span><span class="lineCov">    9755732 :                 ops[1] = rhs;</span>
<span class="lineNum">    6041 </span><span class="lineCov">    9755732 :                 val = vn_nary_op_lookup_pieces (2, gimple_cond_code (last),</span>
<span class="lineNum">    6042 </span>            :                                                 boolean_type_node, ops,
<span class="lineNum">    6043 </span>            :                                                 &amp;vnresult);
<span class="lineNum">    6044 </span>            :                 /* Did we get a predicated value?  */
<span class="lineNum">    6045 </span><span class="lineCov">    9755732 :                 if (! val &amp;&amp; vnresult &amp;&amp; vnresult-&gt;predicated_values)</span>
<span class="lineNum">    6046 </span>            :                   {
<span class="lineNum">    6047 </span><span class="lineCov">     665530 :                     val = vn_nary_op_get_predicated_value (vnresult, bb);</span>
<span class="lineNum">    6048 </span><span class="lineCov">     665530 :                     if (val &amp;&amp; dump_file &amp;&amp; (dump_flags &amp; TDF_DETAILS))</span>
<span class="lineNum">    6049 </span>            :                       {
<span class="lineNum">    6050 </span><span class="lineCov">          2 :                         fprintf (dump_file, &quot;Got predicated value &quot;);</span>
<span class="lineNum">    6051 </span><span class="lineCov">          2 :                         print_generic_expr (dump_file, val, TDF_NONE);</span>
<span class="lineNum">    6052 </span><span class="lineCov">          2 :                         fprintf (dump_file, &quot; for &quot;);</span>
<span class="lineNum">    6053 </span><span class="lineCov">          2 :                         print_gimple_stmt (dump_file, last, TDF_SLIM);</span>
<span class="lineNum">    6054 </span>            :                       }
<span class="lineNum">    6055 </span>            :                   }
<span class="lineNum">    6056 </span>            :               }
<span class="lineNum">    6057 </span><span class="lineCov">   10402701 :             if (val)</span>
<span class="lineNum">    6058 </span><span class="lineCov">    1011458 :               e = find_taken_edge (bb, val);</span>
<span class="lineNum">    6059 </span><span class="lineCov">   10402701 :             if (! e)</span>
<span class="lineNum">    6060 </span>            :               {
<span class="lineNum">    6061 </span>            :                 /* If we didn't manage to compute the taken edge then
<span class="lineNum">    6062 </span>            :                    push predicated expressions for the condition itself
<span class="lineNum">    6063 </span>            :                    and related conditions to the hashtables.  This allows
<span class="lineNum">    6064 </span>            :                    simplification of redundant conditions which is
<span class="lineNum">    6065 </span>            :                    important as early cleanup.  */
<span class="lineNum">    6066 </span><span class="lineCov">    9537759 :                 edge true_e, false_e;</span>
<span class="lineNum">    6067 </span><span class="lineCov">    9537759 :                 extract_true_false_edges_from_block (bb, &amp;true_e, &amp;false_e);</span>
<span class="lineNum">    6068 </span><span class="lineCov">    9537759 :                 enum tree_code code = gimple_cond_code (last);</span>
<span class="lineNum">    6069 </span><span class="lineCov">    9537759 :                 enum tree_code icode</span>
<span class="lineNum">    6070 </span><span class="lineCov">    9537759 :                   = invert_tree_comparison (code, HONOR_NANS (lhs));</span>
<span class="lineNum">    6071 </span><span class="lineCov">    9537759 :                 tree ops[2];</span>
<span class="lineNum">    6072 </span><span class="lineCov">    9537759 :                 ops[0] = lhs;</span>
<span class="lineNum">    6073 </span><span class="lineCov">    9537759 :                 ops[1] = rhs;</span>
<span class="lineNum">    6074 </span><span class="lineCov">    9537759 :                 if (do_region</span>
<span class="lineNum">    6075 </span><span class="lineCov">    9537759 :                     &amp;&amp; bitmap_bit_p (exit_bbs, true_e-&gt;dest-&gt;index))</span>
<span class="lineNum">    6076 </span><span class="lineCov">      33951 :                   true_e = NULL;</span>
<span class="lineNum">    6077 </span><span class="lineCov">    9537759 :                 if (do_region</span>
<span class="lineNum">    6078 </span><span class="lineCov">    9537759 :                     &amp;&amp; bitmap_bit_p (exit_bbs, false_e-&gt;dest-&gt;index))</span>
<span class="lineNum">    6079 </span><span class="lineCov">       3980 :                   false_e = NULL;</span>
<span class="lineNum">    6080 </span><span class="lineCov">    9537759 :                 if (true_e)</span>
<span class="lineNum">    6081 </span><span class="lineCov">    9503808 :                   vn_nary_op_insert_pieces_predicated</span>
<span class="lineNum">    6082 </span><span class="lineCov">    9503808 :                     (2, code, boolean_type_node, ops,</span>
<span class="lineNum">    6083 </span>            :                      boolean_true_node, 0, true_e);
<span class="lineNum">    6084 </span><span class="lineCov">    9537759 :                 if (false_e)</span>
<span class="lineNum">    6085 </span><span class="lineCov">    9533779 :                   vn_nary_op_insert_pieces_predicated</span>
<span class="lineNum">    6086 </span><span class="lineCov">    9533779 :                     (2, code, boolean_type_node, ops,</span>
<span class="lineNum">    6087 </span>            :                      boolean_false_node, 0, false_e);
<span class="lineNum">    6088 </span><span class="lineCov">    9537759 :                 if (icode != ERROR_MARK)</span>
<span class="lineNum">    6089 </span>            :                   {
<span class="lineNum">    6090 </span><span class="lineCov">    9424965 :                     if (true_e)</span>
<span class="lineNum">    6091 </span><span class="lineCov">    9391467 :                       vn_nary_op_insert_pieces_predicated</span>
<span class="lineNum">    6092 </span><span class="lineCov">    9391467 :                         (2, icode, boolean_type_node, ops,</span>
<span class="lineNum">    6093 </span>            :                          boolean_false_node, 0, true_e);
<span class="lineNum">    6094 </span><span class="lineCov">    9424965 :                     if (false_e)</span>
<span class="lineNum">    6095 </span><span class="lineCov">    9421021 :                       vn_nary_op_insert_pieces_predicated</span>
<span class="lineNum">    6096 </span><span class="lineCov">    9421021 :                         (2, icode, boolean_type_node, ops,</span>
<span class="lineNum">    6097 </span>            :                          boolean_true_node, 0, false_e);
<span class="lineNum">    6098 </span>            :                   }
<span class="lineNum">    6099 </span>            :                 /* Relax for non-integers, inverted condition handled
<span class="lineNum">    6100 </span>            :                    above.  */
<span class="lineNum">    6101 </span><span class="lineCov">    9537759 :                 if (INTEGRAL_TYPE_P (TREE_TYPE (lhs)))</span>
<span class="lineNum">    6102 </span>            :                   {
<span class="lineNum">    6103 </span><span class="lineCov">    7410352 :                     if (true_e)</span>
<span class="lineNum">    6104 </span><span class="lineCov">    7380259 :                       insert_related_predicates_on_edge (code, ops, true_e);</span>
<span class="lineNum">    6105 </span><span class="lineCov">    7410352 :                     if (false_e)</span>
<span class="lineNum">    6106 </span><span class="lineCov">    7406434 :                       insert_related_predicates_on_edge (icode, ops, false_e);</span>
<span class="lineNum">    6107 </span>            :                   }
<span class="lineNum">    6108 </span>            :               }
<span class="lineNum">    6109 </span>            :             break;
<span class="lineNum">    6110 </span>            :           }
<span class="lineNum">    6111 </span><span class="lineCov">        981 :         case GIMPLE_GOTO:</span>
<span class="lineNum">    6112 </span><span class="lineCov">        981 :           e = find_taken_edge (bb, vn_valueize (gimple_goto_dest (last)));</span>
<span class="lineNum">    6113 </span><span class="lineCov">        981 :           break;</span>
<span class="lineNum">    6114 </span>            :         default:
<span class="lineNum">    6115 </span>            :           e = NULL;
<span class="lineNum">    6116 </span>            :         }
<span class="lineNum">    6117 </span><span class="lineCov">  199224244 :       if (e)</span>
<span class="lineNum">    6118 </span>            :         {
<span class="lineNum">    6119 </span><span class="lineCov">     866205 :           todo = TODO_cleanup_cfg;</span>
<span class="lineNum">    6120 </span><span class="lineCov">     866205 :           if (!(e-&gt;flags &amp; EDGE_EXECUTABLE))</span>
<span class="lineNum">    6121 </span>            :             {
<span class="lineNum">    6122 </span><span class="lineCov">     764882 :               if (dump_file &amp;&amp; (dump_flags &amp; TDF_DETAILS))</span>
<span class="lineNum">    6123 </span><span class="lineCov">         29 :                 fprintf (dump_file,</span>
<span class="lineNum">    6124 </span>            :                          &quot;marking known outgoing %sedge %d -&gt; %d executable\n&quot;,
<span class="lineNum">    6125 </span><span class="lineCov">         29 :                          e-&gt;flags &amp; EDGE_DFS_BACK ? &quot;back-&quot; : &quot;&quot;,</span>
<span class="lineNum">    6126 </span><span class="lineCov">         29 :                          e-&gt;src-&gt;index, e-&gt;dest-&gt;index);</span>
<span class="lineNum">    6127 </span><span class="lineCov">     764882 :               e-&gt;flags |= EDGE_EXECUTABLE;</span>
<span class="lineNum">    6128 </span><span class="lineCov">     764882 :               e-&gt;dest-&gt;flags |= BB_EXECUTABLE;</span>
<span class="lineNum">    6129 </span>            :             }
<span class="lineNum">    6130 </span><span class="lineCov">     101323 :           else if (!(e-&gt;dest-&gt;flags &amp; BB_EXECUTABLE))</span>
<span class="lineNum">    6131 </span>            :             {
<span class="lineNum">    6132 </span><span class="lineNoCov">          0 :               if (dump_file &amp;&amp; (dump_flags &amp; TDF_DETAILS))</span>
<span class="lineNum">    6133 </span><span class="lineNoCov">          0 :                 fprintf (dump_file,</span>
<span class="lineNum">    6134 </span>            :                          &quot;marking destination block %d reachable\n&quot;,
<span class="lineNum">    6135 </span>            :                          e-&gt;dest-&gt;index);
<span class="lineNum">    6136 </span><span class="lineNoCov">          0 :               e-&gt;dest-&gt;flags |= BB_EXECUTABLE;</span>
<span class="lineNum">    6137 </span>            :             }
<span class="lineNum">    6138 </span>            :         }
<span class="lineNum">    6139 </span><span class="lineCov">  198358039 :       else if (gsi_one_before_end_p (gsi))</span>
<span class="lineNum">    6140 </span>            :         {
<span class="lineNum">    6141 </span><span class="lineCov">   83323657 :           FOR_EACH_EDGE (e, ei, bb-&gt;succs)</span>
<span class="lineNum">    6142 </span>            :             {
<span class="lineNum">    6143 </span><span class="lineCov">   35132741 :               if (!(e-&gt;flags &amp; EDGE_EXECUTABLE))</span>
<span class="lineNum">    6144 </span>            :                 {
<span class="lineNum">    6145 </span><span class="lineCov">   26282961 :                   if (dump_file &amp;&amp; (dump_flags &amp; TDF_DETAILS))</span>
<span class="lineNum">    6146 </span><span class="lineCov">        981 :                     fprintf (dump_file,</span>
<span class="lineNum">    6147 </span>            :                              &quot;marking outgoing edge %d -&gt; %d executable\n&quot;,
<span class="lineNum">    6148 </span><span class="lineCov">        327 :                              e-&gt;src-&gt;index, e-&gt;dest-&gt;index);</span>
<span class="lineNum">    6149 </span><span class="lineCov">   26282961 :                   e-&gt;flags |= EDGE_EXECUTABLE;</span>
<span class="lineNum">    6150 </span><span class="lineCov">   26282961 :                   e-&gt;dest-&gt;flags |= BB_EXECUTABLE;</span>
<span class="lineNum">    6151 </span>            :                 }
<span class="lineNum">    6152 </span><span class="lineCov">    8849780 :               else if (!(e-&gt;dest-&gt;flags &amp; BB_EXECUTABLE))</span>
<span class="lineNum">    6153 </span>            :                 {
<span class="lineNum">    6154 </span><span class="lineCov">       1513 :                   if (dump_file &amp;&amp; (dump_flags &amp; TDF_DETAILS))</span>
<span class="lineNum">    6155 </span><span class="lineNoCov">          0 :                     fprintf (dump_file,</span>
<span class="lineNum">    6156 </span>            :                              &quot;marking destination block %d reachable\n&quot;,
<span class="lineNum">    6157 </span>            :                              e-&gt;dest-&gt;index);
<span class="lineNum">    6158 </span><span class="lineCov">       1513 :                   e-&gt;dest-&gt;flags |= BB_EXECUTABLE;</span>
<span class="lineNum">    6159 </span>            :                 }
<span class="lineNum">    6160 </span>            :             }
<span class="lineNum">    6161 </span>            :         }
<span class="lineNum">    6162 </span>            : 
<span class="lineNum">    6163 </span>            :       /* Eliminate.  That also pushes to avail.  */
<span class="lineNum">    6164 </span><span class="lineCov">  199224244 :       if (eliminate &amp;&amp; ! iterate)</span>
<span class="lineNum">    6165 </span><span class="lineCov">    4661352 :         avail.eliminate_stmt (bb, &amp;gsi);</span>
<span class="lineNum">    6166 </span>            :       else
<span class="lineNum">    6167 </span>            :         /* If not eliminating, make all not already available defs
<span class="lineNum">    6168 </span>            :            available.  */
<span class="lineNum">    6169 </span><span class="lineCov">  437314044 :         FOR_EACH_SSA_TREE_OPERAND (op, gsi_stmt (gsi), i, SSA_OP_DEF)</span>
<span class="lineNum">    6170 </span><span class="lineCov">   48188260 :           if (! avail.eliminate_avail (bb, op))</span>
<span class="lineNum">    6171 </span><span class="lineCov">   36752492 :             avail.eliminate_push_avail (bb, op);</span>
<span class="lineNum">    6172 </span>            :     }
<span class="lineNum">    6173 </span>            : 
<span class="lineNum">    6174 </span>            :   /* Eliminate in destination PHI arguments.  Always substitute in dest
<span class="lineNum">    6175 </span>            :      PHIs, even for non-executable edges.  This handles region
<span class="lineNum">    6176 </span>            :      exits PHIs.  */
<span class="lineNum">    6177 </span><span class="lineCov">   28571342 :   if (!iterate &amp;&amp; eliminate)</span>
<span class="lineNum">    6178 </span><span class="lineCov">    3205318 :     FOR_EACH_EDGE (e, ei, bb-&gt;succs)</span>
<span class="lineNum">    6179 </span><span class="lineCov">    1275250 :       for (gphi_iterator gsi = gsi_start_phis (e-&gt;dest);</span>
<span class="lineNum">    6180 </span><span class="lineCov">    3464674 :            !gsi_end_p (gsi); gsi_next (&amp;gsi))</span>
<span class="lineNum">    6181 </span>            :         {
<span class="lineNum">    6182 </span><span class="lineCov">     914174 :           gphi *phi = gsi.phi ();</span>
<span class="lineNum">    6183 </span><span class="lineCov">     914174 :           use_operand_p use_p = PHI_ARG_DEF_PTR_FROM_EDGE (phi, e);</span>
<span class="lineNum">    6184 </span><span class="lineCov">     914174 :           tree arg = USE_FROM_PTR (use_p);</span>
<span class="lineNum">    6185 </span><span class="lineCov">     914174 :           if (TREE_CODE (arg) != SSA_NAME</span>
<span class="lineNum">    6186 </span><span class="lineCov">     914174 :               || virtual_operand_p (arg))</span>
<span class="lineNum">    6187 </span>            :             continue;
<span class="lineNum">    6188 </span><span class="lineCov">     447830 :           tree sprime;</span>
<span class="lineNum">    6189 </span><span class="lineCov">     895660 :           if (SSA_NAME_IS_DEFAULT_DEF (arg))</span>
<span class="lineNum">    6190 </span>            :             {
<span class="lineNum">    6191 </span><span class="lineCov">       7258 :               sprime = SSA_VAL (arg);</span>
<span class="lineNum">    6192 </span><span class="lineCov">       7258 :               gcc_assert (TREE_CODE (sprime) != SSA_NAME</span>
<span class="lineNum">    6193 </span>            :                           || SSA_NAME_IS_DEFAULT_DEF (sprime));
<span class="lineNum">    6194 </span>            :             }
<span class="lineNum">    6195 </span>            :           else
<span class="lineNum">    6196 </span>            :             /* Look for sth available at the definition block of the argument.
<span class="lineNum">    6197 </span>            :                This avoids inconsistencies between availability there which
<span class="lineNum">    6198 </span>            :                decides if the stmt can be removed and availability at the
<span class="lineNum">    6199 </span>            :                use site.  The SSA property ensures that things available
<span class="lineNum">    6200 </span>            :                at the definition are also available at uses.  */
<span class="lineNum">    6201 </span><span class="lineCov">     881144 :             sprime = avail.eliminate_avail (gimple_bb (SSA_NAME_DEF_STMT (arg)),</span>
<span class="lineNum">    6202 </span><span class="lineCov">     440572 :                                             arg);</span>
<span class="lineNum">    6203 </span><span class="lineCov">     447830 :           if (sprime</span>
<span class="lineNum">    6204 </span><span class="lineCov">     447830 :               &amp;&amp; sprime != arg</span>
<span class="lineNum">    6205 </span><span class="lineCov">     542478 :               &amp;&amp; may_propagate_copy (arg, sprime))</span>
<span class="lineNum">    6206 </span><span class="lineCov">      94426 :             propagate_value (use_p, sprime);</span>
<span class="lineNum">    6207 </span>            :         }
<span class="lineNum">    6208 </span>            : 
<span class="lineNum">    6209 </span><span class="lineCov">   28571342 :   vn_context_bb = NULL;</span>
<span class="lineNum">    6210 </span><span class="lineCov">   28571342 :   return todo;</span>
<span class="lineNum">    6211 </span>            : }
<span class="lineNum">    6212 </span>            : 
<span class="lineNum">    6213 </span>            : /* Unwind state per basic-block.  */
<span class="lineNum">    6214 </span>            : 
<span class="lineNum">    6215 </span>            : struct unwind_state
<span class="lineNum">    6216 </span>            : {
<span class="lineNum">    6217 </span>            :   /* Times this block has been visited.  */
<span class="lineNum">    6218 </span>            :   unsigned visited;
<span class="lineNum">    6219 </span>            :   /* Whether to handle this as iteration point or whether to treat
<span class="lineNum">    6220 </span>            :      incoming backedge PHI values as varying.  */
<span class="lineNum">    6221 </span>            :   bool iterate;
<span class="lineNum">    6222 </span>            :   /* Maximum RPO index this block is reachable from.  */
<span class="lineNum">    6223 </span>            :   int max_rpo;
<span class="lineNum">    6224 </span>            :   /* Unwind state.  */
<span class="lineNum">    6225 </span>            :   void *ob_top;
<span class="lineNum">    6226 </span>            :   vn_reference_t ref_top;
<span class="lineNum">    6227 </span>            :   vn_phi_t phi_top;
<span class="lineNum">    6228 </span>            :   vn_nary_op_t nary_top;
<span class="lineNum">    6229 </span>            : };
<span class="lineNum">    6230 </span>            : 
<span class="lineNum">    6231 </span>            : /* Unwind the RPO VN state for iteration.  */
<a name="6232"><span class="lineNum">    6232 </span>            : </a>
<span class="lineNum">    6233 </span>            : static void
<span class="lineNum">    6234 </span><span class="lineCov">     990660 : do_unwind (unwind_state *to, int rpo_idx, rpo_elim &amp;avail, int *bb_to_rpo)</span>
<span class="lineNum">    6235 </span>            : {
<span class="lineNum">    6236 </span><span class="lineCov">     990660 :   gcc_assert (to-&gt;iterate);</span>
<span class="lineNum">    6237 </span><span class="lineCov">   21047007 :   for (; last_inserted_nary != to-&gt;nary_top;</span>
<span class="lineNum">    6238 </span><span class="lineCov">   20056347 :        last_inserted_nary = last_inserted_nary-&gt;next)</span>
<span class="lineNum">    6239 </span>            :     {
<span class="lineNum">    6240 </span><span class="lineCov">   20056347 :       vn_nary_op_t *slot;</span>
<span class="lineNum">    6241 </span><span class="lineCov">   40112694 :       slot = valid_info-&gt;nary-&gt;find_slot_with_hash</span>
<span class="lineNum">    6242 </span><span class="lineCov">   20056347 :         (last_inserted_nary, last_inserted_nary-&gt;hashcode, NO_INSERT);</span>
<span class="lineNum">    6243 </span>            :       /* Predication causes the need to restore previous state.  */
<span class="lineNum">    6244 </span><span class="lineCov">   20056347 :       if ((*slot)-&gt;unwind_to)</span>
<span class="lineNum">    6245 </span><span class="lineCov">    3755486 :         *slot = (*slot)-&gt;unwind_to;</span>
<span class="lineNum">    6246 </span>            :       else
<span class="lineNum">    6247 </span><span class="lineCov">   16300861 :         valid_info-&gt;nary-&gt;clear_slot (slot);</span>
<span class="lineNum">    6248 </span>            :     }
<span class="lineNum">    6249 </span><span class="lineCov">    4078841 :   for (; last_inserted_phi != to-&gt;phi_top;</span>
<span class="lineNum">    6250 </span><span class="lineCov">    3088181 :        last_inserted_phi = last_inserted_phi-&gt;next)</span>
<span class="lineNum">    6251 </span>            :     {
<span class="lineNum">    6252 </span><span class="lineCov">    3088181 :       vn_phi_t *slot;</span>
<span class="lineNum">    6253 </span><span class="lineCov">    6176362 :       slot = valid_info-&gt;phis-&gt;find_slot_with_hash</span>
<span class="lineNum">    6254 </span><span class="lineCov">    3088181 :         (last_inserted_phi, last_inserted_phi-&gt;hashcode, NO_INSERT);</span>
<span class="lineNum">    6255 </span><span class="lineCov">    3088181 :       valid_info-&gt;phis-&gt;clear_slot (slot);</span>
<span class="lineNum">    6256 </span>            :     }
<span class="lineNum">    6257 </span><span class="lineCov">    8042590 :   for (; last_inserted_ref != to-&gt;ref_top;</span>
<span class="lineNum">    6258 </span><span class="lineCov">    7051930 :        last_inserted_ref = last_inserted_ref-&gt;next)</span>
<span class="lineNum">    6259 </span>            :     {
<span class="lineNum">    6260 </span><span class="lineCov">    7051930 :       vn_reference_t *slot;</span>
<span class="lineNum">    6261 </span><span class="lineCov">   14103860 :       slot = valid_info-&gt;references-&gt;find_slot_with_hash</span>
<span class="lineNum">    6262 </span><span class="lineCov">    7051930 :         (last_inserted_ref, last_inserted_ref-&gt;hashcode, NO_INSERT);</span>
<span class="lineNum">    6263 </span><span class="lineCov">    7051930 :       (*slot)-&gt;operands.release ();</span>
<span class="lineNum">    6264 </span><span class="lineCov">    7051930 :       valid_info-&gt;references-&gt;clear_slot (slot);</span>
<span class="lineNum">    6265 </span>            :     }
<span class="lineNum">    6266 </span><span class="lineCov">     990660 :   obstack_free (&amp;vn_tables_obstack, to-&gt;ob_top);</span>
<span class="lineNum">    6267 </span>            : 
<span class="lineNum">    6268 </span>            :   /* Prune [rpo_idx, ] from avail.  */
<span class="lineNum">    6269 </span>            :   /* ???  This is O(number-of-values-in-region) which is
<span class="lineNum">    6270 </span>            :      O(region-size) rather than O(iteration-piece).  */
<span class="lineNum">    6271 </span><span class="lineCov">     990660 :   for (rpo_elim::rpo_avail_t::iterator i</span>
<span class="lineNum">    6272 </span><span class="lineCov">     990660 :        = avail.m_rpo_avail.begin ();</span>
<span class="lineNum">    6273 </span><span class="lineCov">  310284855 :        i != avail.m_rpo_avail.end (); ++i)</span>
<span class="lineNum">    6274 </span>            :     {
<span class="lineNum">    6275 </span><span class="lineCov">  230246986 :       while (! (*i).second.is_empty ())</span>
<span class="lineNum">    6276 </span>            :         {
<span class="lineNum">    6277 </span><span class="lineCov">  308525346 :           if (bb_to_rpo[(*i).second.last ().first] &lt; rpo_idx)</span>
<span class="lineNum">    6278 </span>            :             break;
<span class="lineNum">    6279 </span><span class="lineCov">   24711296 :           (*i).second.pop ();</span>
<span class="lineNum">    6280 </span>            :         }
<span class="lineNum">    6281 </span>            :     }
<span class="lineNum">    6282 </span><span class="lineCov">     990660 : }</span>
<span class="lineNum">    6283 </span>            : 
<span class="lineNum">    6284 </span>            : /* Do VN on a SEME region specified by ENTRY and EXIT_BBS in FN.
<span class="lineNum">    6285 </span>            :    If ITERATE is true then treat backedges optimistically as not
<span class="lineNum">    6286 </span>            :    executed and iterate.  If ELIMINATE is true then perform
<span class="lineNum">    6287 </span>            :    elimination, otherwise leave that to the caller.  */
<a name="6288"><span class="lineNum">    6288 </span>            : </a>
<span class="lineNum">    6289 </span>            : static unsigned
<span class="lineNum">    6290 </span><span class="lineCov">    2628835 : do_rpo_vn (function *fn, edge entry, bitmap exit_bbs,</span>
<span class="lineNum">    6291 </span>            :            bool iterate, bool eliminate)
<span class="lineNum">    6292 </span>            : {
<span class="lineNum">    6293 </span><span class="lineCov">    2628835 :   unsigned todo = 0;</span>
<span class="lineNum">    6294 </span>            : 
<span class="lineNum">    6295 </span>            :   /* We currently do not support region-based iteration when
<span class="lineNum">    6296 </span>            :      elimination is requested.  */
<span class="lineNum">    6297 </span><span class="lineCov">    2628835 :   gcc_assert (!entry || !iterate || !eliminate);</span>
<span class="lineNum">    6298 </span>            :   /* When iterating we need loop info up-to-date.  */
<span class="lineNum">    6299 </span><span class="lineCov">    2628835 :   gcc_assert (!iterate || !loops_state_satisfies_p (LOOPS_NEED_FIXUP));</span>
<span class="lineNum">    6300 </span>            : 
<span class="lineNum">    6301 </span><span class="lineCov">    2628835 :   bool do_region = entry != NULL;</span>
<span class="lineNum">    6302 </span><span class="lineCov">    2628835 :   if (!do_region)</span>
<span class="lineNum">    6303 </span>            :     {
<span class="lineNum">    6304 </span><span class="lineCov">    2614816 :       entry = single_succ_edge (ENTRY_BLOCK_PTR_FOR_FN (fn));</span>
<span class="lineNum">    6305 </span><span class="lineCov">    2614816 :       exit_bbs = BITMAP_ALLOC (NULL);</span>
<span class="lineNum">    6306 </span><span class="lineCov">    2614816 :       bitmap_set_bit (exit_bbs, EXIT_BLOCK);</span>
<span class="lineNum">    6307 </span>            :     }
<span class="lineNum">    6308 </span>            : 
<span class="lineNum">    6309 </span><span class="lineCov">    2628835 :   int *rpo = XNEWVEC (int, n_basic_blocks_for_fn (fn) - NUM_FIXED_BLOCKS);</span>
<span class="lineNum">    6310 </span><span class="lineCov">    2628835 :   int n = rev_post_order_and_mark_dfs_back_seme</span>
<span class="lineNum">    6311 </span><span class="lineCov">    2628835 :     (fn, entry, exit_bbs, !loops_state_satisfies_p (LOOPS_NEED_FIXUP), rpo);</span>
<span class="lineNum">    6312 </span>            :   /* rev_post_order_and_mark_dfs_back_seme fills RPO in reverse order.  */
<span class="lineNum">    6313 </span><span class="lineCov">   12570971 :   for (int i = 0; i &lt; n / 2; ++i)</span>
<span class="lineNum">    6314 </span><span class="lineCov">   19884272 :     std::swap (rpo[i], rpo[n-i-1]);</span>
<span class="lineNum">    6315 </span>            : 
<span class="lineNum">    6316 </span><span class="lineCov">    2628835 :   if (!do_region)</span>
<span class="lineNum">    6317 </span><span class="lineCov">    2614816 :     BITMAP_FREE (exit_bbs);</span>
<span class="lineNum">    6318 </span>            : 
<span class="lineNum">    6319 </span><span class="lineCov">    2628835 :   int *bb_to_rpo = XNEWVEC (int, last_basic_block_for_fn (fn));</span>
<span class="lineNum">    6320 </span><span class="lineCov">   24595656 :   for (int i = 0; i &lt; n; ++i)</span>
<span class="lineNum">    6321 </span><span class="lineCov">   21966821 :     bb_to_rpo[rpo[i]] = i;</span>
<span class="lineNum">    6322 </span>            : 
<span class="lineNum">    6323 </span><span class="lineCov">    2628835 :   unwind_state *rpo_state = XNEWVEC (unwind_state, n);</span>
<span class="lineNum">    6324 </span>            : 
<span class="lineNum">    6325 </span><span class="lineCov">    2628835 :   rpo_elim avail (entry-&gt;dest);</span>
<span class="lineNum">    6326 </span><span class="lineCov">    2628835 :   rpo_avail = &amp;avail;</span>
<span class="lineNum">    6327 </span>            : 
<span class="lineNum">    6328 </span>            :   /* Verify we have no extra entries into the region.  */
<span class="lineNum">    6329 </span><span class="lineCov">    2628835 :   if (flag_checking &amp;&amp; do_region)</span>
<span class="lineNum">    6330 </span>            :     {
<span class="lineNum">    6331 </span><span class="lineCov">      28030 :       auto_bb_flag bb_in_region (fn);</span>
<span class="lineNum">    6332 </span><span class="lineCov">     300248 :       for (int i = 0; i &lt; n; ++i)</span>
<span class="lineNum">    6333 </span>            :         {
<span class="lineNum">    6334 </span><span class="lineCov">     286233 :           basic_block bb = BASIC_BLOCK_FOR_FN (fn, rpo[i]);</span>
<span class="lineNum">    6335 </span><span class="lineCov">     286233 :           bb-&gt;flags |= bb_in_region;</span>
<span class="lineNum">    6336 </span>            :         }
<span class="lineNum">    6337 </span>            :       /* We can't merge the first two loops because we cannot rely
<span class="lineNum">    6338 </span>            :          on EDGE_DFS_BACK for edges not within the region.  But if
<span class="lineNum">    6339 </span>            :          we decide to always have the bb_in_region flag we can
<span class="lineNum">    6340 </span>            :          do the checking during the RPO walk itself (but then it's
<span class="lineNum">    6341 </span>            :          also easy to handle MEME conservatively).  */
<span class="lineNum">    6342 </span><span class="lineCov">     300248 :       for (int i = 0; i &lt; n; ++i)</span>
<span class="lineNum">    6343 </span>            :         {
<span class="lineNum">    6344 </span><span class="lineCov">     286233 :           basic_block bb = BASIC_BLOCK_FOR_FN (fn, rpo[i]);</span>
<span class="lineNum">    6345 </span><span class="lineCov">     286233 :           edge e;</span>
<span class="lineNum">    6346 </span><span class="lineCov">     286233 :           edge_iterator ei;</span>
<span class="lineNum">    6347 </span><span class="lineCov">     931439 :           FOR_EACH_EDGE (e, ei, bb-&gt;preds)</span>
<span class="lineNum">    6348 </span><span class="lineCov">     358973 :             gcc_assert (e == entry || (e-&gt;src-&gt;flags &amp; bb_in_region));</span>
<span class="lineNum">    6349 </span>            :         }
<span class="lineNum">    6350 </span><span class="lineCov">     300248 :       for (int i = 0; i &lt; n; ++i)</span>
<span class="lineNum">    6351 </span>            :         {
<span class="lineNum">    6352 </span><span class="lineCov">     286233 :           basic_block bb = BASIC_BLOCK_FOR_FN (fn, rpo[i]);</span>
<span class="lineNum">    6353 </span><span class="lineCov">     286233 :           bb-&gt;flags &amp;= ~bb_in_region;</span>
<span class="lineNum">    6354 </span>            :         }
<span class="lineNum">    6355 </span>            :     }
<span class="lineNum">    6356 </span>            : 
<span class="lineNum">    6357 </span>            :   /* Create the VN state.  For the initial size of the various hashtables
<span class="lineNum">    6358 </span>            :      use a heuristic based on region size and number of SSA names.  */
<span class="lineNum">    6359 </span><span class="lineCov">    2628835 :   unsigned region_size = (((unsigned HOST_WIDE_INT)n * num_ssa_names)</span>
<span class="lineNum">    6360 </span><span class="lineCov">    2628835 :                           / (n_basic_blocks_for_fn (fn) - NUM_FIXED_BLOCKS));</span>
<span class="lineNum">    6361 </span><span class="lineCov">    2628835 :   VN_TOP = create_tmp_var_raw (void_type_node, &quot;vn_top&quot;);</span>
<span class="lineNum">    6362 </span>            : 
<span class="lineNum">    6363 </span><span class="lineCov">    2628835 :   vn_ssa_aux_hash = new hash_table &lt;vn_ssa_aux_hasher&gt; (region_size * 2);</span>
<span class="lineNum">    6364 </span><span class="lineCov">    2628835 :   gcc_obstack_init (&amp;vn_ssa_aux_obstack);</span>
<span class="lineNum">    6365 </span>            : 
<span class="lineNum">    6366 </span><span class="lineCov">    2628835 :   gcc_obstack_init (&amp;vn_tables_obstack);</span>
<span class="lineNum">    6367 </span><span class="lineCov">    2628835 :   gcc_obstack_init (&amp;vn_tables_insert_obstack);</span>
<span class="lineNum">    6368 </span><span class="lineCov">    2628835 :   valid_info = XCNEW (struct vn_tables_s);</span>
<span class="lineNum">    6369 </span><span class="lineCov">    2628835 :   allocate_vn_table (valid_info, region_size);</span>
<span class="lineNum">    6370 </span><span class="lineCov">    2628835 :   last_inserted_ref = NULL;</span>
<span class="lineNum">    6371 </span><span class="lineCov">    2628835 :   last_inserted_phi = NULL;</span>
<span class="lineNum">    6372 </span><span class="lineCov">    2628835 :   last_inserted_nary = NULL;</span>
<span class="lineNum">    6373 </span>            : 
<span class="lineNum">    6374 </span><span class="lineCov">    2628835 :   vn_valueize = rpo_vn_valueize;</span>
<span class="lineNum">    6375 </span>            : 
<span class="lineNum">    6376 </span>            :   /* Initialize the unwind state and edge/BB executable state.  */
<span class="lineNum">    6377 </span><span class="lineCov">    2628835 :   bool need_max_rpo_iterate = false;</span>
<span class="lineNum">    6378 </span><span class="lineCov">   24595656 :   for (int i = 0; i &lt; n; ++i)</span>
<span class="lineNum">    6379 </span>            :     {
<span class="lineNum">    6380 </span><span class="lineCov">   21966821 :       basic_block bb = BASIC_BLOCK_FOR_FN (fn, rpo[i]);</span>
<span class="lineNum">    6381 </span><span class="lineCov">   21966821 :       rpo_state[i].visited = 0;</span>
<span class="lineNum">    6382 </span><span class="lineCov">   21966821 :       rpo_state[i].max_rpo = i;</span>
<span class="lineNum">    6383 </span><span class="lineCov">   21966821 :       bb-&gt;flags &amp;= ~BB_EXECUTABLE;</span>
<span class="lineNum">    6384 </span><span class="lineCov">   21966821 :       bool has_backedges = false;</span>
<span class="lineNum">    6385 </span><span class="lineCov">   21966821 :       edge e;</span>
<span class="lineNum">    6386 </span><span class="lineCov">   21966821 :       edge_iterator ei;</span>
<span class="lineNum">    6387 </span><span class="lineCov">   74031321 :       FOR_EACH_EDGE (e, ei, bb-&gt;preds)</span>
<span class="lineNum">    6388 </span>            :         {
<span class="lineNum">    6389 </span><span class="lineCov">   30097679 :           if (e-&gt;flags &amp; EDGE_DFS_BACK)</span>
<span class="lineNum">    6390 </span><span class="lineCov">    1074422 :             has_backedges = true;</span>
<span class="lineNum">    6391 </span><span class="lineCov">   30097679 :           e-&gt;flags &amp;= ~EDGE_EXECUTABLE;</span>
<span class="lineNum">    6392 </span><span class="lineCov">   30097679 :           if (iterate || e == entry)</span>
<span class="lineNum">    6393 </span>            :             continue;
<span class="lineNum">    6394 </span><span class="lineCov">    1148123 :           if (bb_to_rpo[e-&gt;src-&gt;index] &gt; i)</span>
<span class="lineNum">    6395 </span>            :             {
<span class="lineNum">    6396 </span><span class="lineCov">      81769 :               rpo_state[i].max_rpo = MAX (rpo_state[i].max_rpo,</span>
<span class="lineNum">    6397 </span>            :                                           bb_to_rpo[e-&gt;src-&gt;index]);
<span class="lineNum">    6398 </span><span class="lineCov">      81769 :               need_max_rpo_iterate = true;</span>
<span class="lineNum">    6399 </span>            :             }
<span class="lineNum">    6400 </span>            :           else
<span class="lineNum">    6401 </span><span class="lineCov">    1066354 :             rpo_state[i].max_rpo</span>
<span class="lineNum">    6402 </span><span class="lineCov">    1559502 :               = MAX (rpo_state[i].max_rpo,</span>
<span class="lineNum">    6403 </span>            :                      rpo_state[bb_to_rpo[e-&gt;src-&gt;index]].max_rpo);
<span class="lineNum">    6404 </span>            :         }
<span class="lineNum">    6405 </span><span class="lineCov">   21966821 :       rpo_state[i].iterate = iterate &amp;&amp; has_backedges;</span>
<span class="lineNum">    6406 </span>            :     }
<span class="lineNum">    6407 </span><span class="lineCov">    2628835 :   entry-&gt;flags |= EDGE_EXECUTABLE;</span>
<span class="lineNum">    6408 </span><span class="lineCov">    2628835 :   entry-&gt;dest-&gt;flags |= BB_EXECUTABLE;</span>
<span class="lineNum">    6409 </span>            : 
<span class="lineNum">    6410 </span>            :   /* When there are irreducible regions the simplistic max_rpo computation
<span class="lineNum">    6411 </span>            :      above for the case of backedges doesn't work and we need to iterate
<span class="lineNum">    6412 </span>            :      until there are no more changes.  */
<span class="lineNum">    6413 </span><span class="lineCov">    2628835 :   unsigned nit = 0;</span>
<span class="lineNum">    6414 </span><span class="lineCov">    2659075 :   while (need_max_rpo_iterate)</span>
<span class="lineNum">    6415 </span>            :     {
<span class="lineNum">    6416 </span><span class="lineCov">      30240 :       nit++;</span>
<span class="lineNum">    6417 </span><span class="lineCov">      30240 :       need_max_rpo_iterate = false;</span>
<span class="lineNum">    6418 </span><span class="lineCov">     675938 :       for (int i = 0; i &lt; n; ++i)</span>
<span class="lineNum">    6419 </span>            :         {
<span class="lineNum">    6420 </span><span class="lineCov">     645698 :           basic_block bb = BASIC_BLOCK_FOR_FN (fn, rpo[i]);</span>
<span class="lineNum">    6421 </span><span class="lineCov">     645698 :           edge e;</span>
<span class="lineNum">    6422 </span><span class="lineCov">     645698 :           edge_iterator ei;</span>
<span class="lineNum">    6423 </span><span class="lineCov">    2130253 :           FOR_EACH_EDGE (e, ei, bb-&gt;preds)</span>
<span class="lineNum">    6424 </span>            :             {
<span class="lineNum">    6425 </span><span class="lineCov">     838857 :               if (e == entry)</span>
<span class="lineNum">    6426 </span>            :                 continue;
<span class="lineNum">    6427 </span><span class="lineCov">     808617 :               int max_rpo = MAX (rpo_state[i].max_rpo,</span>
<span class="lineNum">    6428 </span>            :                                  rpo_state[bb_to_rpo[e-&gt;src-&gt;index]].max_rpo);
<span class="lineNum">    6429 </span><span class="lineCov">     808617 :               if (rpo_state[i].max_rpo != max_rpo)</span>
<span class="lineNum">    6430 </span>            :                 {
<span class="lineNum">    6431 </span><span class="lineCov">       2715 :                   rpo_state[i].max_rpo = max_rpo;</span>
<span class="lineNum">    6432 </span><span class="lineCov">       2715 :                   need_max_rpo_iterate = true;</span>
<span class="lineNum">    6433 </span>            :                 }
<span class="lineNum">    6434 </span>            :             }
<span class="lineNum">    6435 </span>            :         }
<span class="lineNum">    6436 </span>            :     }
<span class="lineNum">    6437 </span><span class="lineCov">    2628835 :   statistics_histogram_event (cfun, &quot;RPO max_rpo iterations&quot;, nit);</span>
<span class="lineNum">    6438 </span>            : 
<span class="lineNum">    6439 </span>            :   /* As heuristic to improve compile-time we handle only the N innermost
<span class="lineNum">    6440 </span>            :      loops and the outermost one optimistically.  */
<span class="lineNum">    6441 </span><span class="lineCov">    2628835 :   if (iterate)</span>
<span class="lineNum">    6442 </span>            :     {
<span class="lineNum">    6443 </span><span class="lineCov">    2528926 :       loop_p loop;</span>
<span class="lineNum">    6444 </span><span class="lineCov">    2528926 :       unsigned max_depth = PARAM_VALUE (PARAM_RPO_VN_MAX_LOOP_DEPTH);</span>
<span class="lineNum">    6445 </span><span class="lineCov">    5854438 :       FOR_EACH_LOOP (loop, LI_ONLY_INNERMOST)</span>
<span class="lineNum">    6446 </span><span class="lineCov">    1593172 :         if (loop_depth (loop) &gt; max_depth)</span>
<span class="lineNum">    6447 </span><span class="lineCov">        901 :           for (unsigned i = 2;</span>
<span class="lineNum">    6448 </span><span class="lineCov">       2574 :                i &lt; loop_depth (loop) - max_depth; ++i)</span>
<span class="lineNum">    6449 </span>            :             {
<span class="lineNum">    6450 </span><span class="lineCov">        901 :               basic_block header = superloop_at_depth (loop, i)-&gt;header;</span>
<span class="lineNum">    6451 </span><span class="lineCov">        901 :               bool non_latch_backedge = false;</span>
<span class="lineNum">    6452 </span><span class="lineCov">        901 :               edge e;</span>
<span class="lineNum">    6453 </span><span class="lineCov">        901 :               edge_iterator ei;</span>
<span class="lineNum">    6454 </span><span class="lineCov">       3631 :               FOR_EACH_EDGE (e, ei, header-&gt;preds)</span>
<span class="lineNum">    6455 </span><span class="lineCov">       1829 :                 if (e-&gt;flags &amp; EDGE_DFS_BACK)</span>
<span class="lineNum">    6456 </span>            :                   {
<span class="lineNum">    6457 </span><span class="lineCov">        928 :                     e-&gt;flags |= EDGE_EXECUTABLE;</span>
<span class="lineNum">    6458 </span>            :                     /* There can be a non-latch backedge into the header
<span class="lineNum">    6459 </span>            :                        which is part of an outer irreducible region.  We
<span class="lineNum">    6460 </span>            :                        cannot avoid iterating this block then.  */
<span class="lineNum">    6461 </span><span class="lineCov">        928 :                     if (!dominated_by_p (CDI_DOMINATORS,</span>
<span class="lineNum">    6462 </span><span class="lineCov">        928 :                                          e-&gt;src, e-&gt;dest))</span>
<span class="lineNum">    6463 </span>            :                       {
<span class="lineNum">    6464 </span><span class="lineCov">          6 :                         if (dump_file &amp;&amp; (dump_flags &amp; TDF_DETAILS))</span>
<span class="lineNum">    6465 </span><span class="lineNoCov">          0 :                           fprintf (dump_file, &quot;non-latch backedge %d -&gt; %d &quot;</span>
<span class="lineNum">    6466 </span>            :                                    &quot;forces iteration of loop %d\n&quot;,
<span class="lineNum">    6467 </span><span class="lineNoCov">          0 :                                    e-&gt;src-&gt;index, e-&gt;dest-&gt;index, loop-&gt;num);</span>
<span class="lineNum">    6468 </span>            :                         non_latch_backedge = true;
<span class="lineNum">    6469 </span>            :                       }
<span class="lineNum">    6470 </span>            :                   }
<span class="lineNum">    6471 </span><span class="lineCov">        901 :               rpo_state[bb_to_rpo[header-&gt;index]].iterate = non_latch_backedge;</span>
<span class="lineNum">    6472 </span>            :             }
<span class="lineNum">    6473 </span>            :     }
<span class="lineNum">    6474 </span>            : 
<span class="lineNum">    6475 </span><span class="lineCov">    2628835 :   uint64_t nblk = 0;</span>
<span class="lineNum">    6476 </span><span class="lineCov">    2628835 :   int idx = 0;</span>
<span class="lineNum">    6477 </span><span class="lineCov">    2628835 :   if (iterate)</span>
<span class="lineNum">    6478 </span>            :     /* Go and process all blocks, iterating as necessary.  */
<span class="lineNum">    6479 </span><span class="lineCov">   28058741 :     do</span>
<span class="lineNum">    6480 </span>            :       {
<span class="lineNum">    6481 </span><span class="lineCov">   28058741 :         basic_block bb = BASIC_BLOCK_FOR_FN (fn, rpo[idx]);</span>
<span class="lineNum">    6482 </span>            : 
<span class="lineNum">    6483 </span>            :         /* If the block has incoming backedges remember unwind state.  This
<span class="lineNum">    6484 </span>            :            is required even for non-executable blocks since in irreducible
<span class="lineNum">    6485 </span>            :            regions we might reach them via the backedge and re-start iterating
<span class="lineNum">    6486 </span>            :            from there.
<span class="lineNum">    6487 </span>            :            Note we can individually mark blocks with incoming backedges to
<span class="lineNum">    6488 </span>            :            not iterate where we then handle PHIs conservatively.  We do that
<span class="lineNum">    6489 </span>            :            heuristically to reduce compile-time for degenerate cases.  */
<span class="lineNum">    6490 </span><span class="lineCov">   28058741 :         if (rpo_state[idx].iterate)</span>
<span class="lineNum">    6491 </span>            :           {
<span class="lineNum">    6492 </span><span class="lineCov">    2316848 :             rpo_state[idx].ob_top = obstack_alloc (&amp;vn_tables_obstack, 0);</span>
<span class="lineNum">    6493 </span><span class="lineCov">    2316848 :             rpo_state[idx].ref_top = last_inserted_ref;</span>
<span class="lineNum">    6494 </span><span class="lineCov">    2316848 :             rpo_state[idx].phi_top = last_inserted_phi;</span>
<span class="lineNum">    6495 </span><span class="lineCov">    2316848 :             rpo_state[idx].nary_top = last_inserted_nary;</span>
<span class="lineNum">    6496 </span>            :           }
<span class="lineNum">    6497 </span>            : 
<span class="lineNum">    6498 </span><span class="lineCov">   28058741 :         if (!(bb-&gt;flags &amp; BB_EXECUTABLE))</span>
<span class="lineNum">    6499 </span>            :           {
<span class="lineNum">    6500 </span><span class="lineCov">     452433 :             if (dump_file &amp;&amp; (dump_flags &amp; TDF_DETAILS))</span>
<span class="lineNum">    6501 </span><span class="lineCov">          1 :               fprintf (dump_file, &quot;Block %d: BB%d found not executable\n&quot;,</span>
<span class="lineNum">    6502 </span>            :                        idx, bb-&gt;index);
<span class="lineNum">    6503 </span><span class="lineCov">     452433 :             idx++;</span>
<span class="lineNum">    6504 </span><span class="lineCov">    1443093 :             continue;</span>
<span class="lineNum">    6505 </span>            :           }
<span class="lineNum">    6506 </span>            : 
<span class="lineNum">    6507 </span><span class="lineCov">   27606308 :         if (dump_file &amp;&amp; (dump_flags &amp; TDF_DETAILS))</span>
<span class="lineNum">    6508 </span><span class="lineCov">        280 :           fprintf (dump_file, &quot;Processing block %d: BB%d\n&quot;, idx, bb-&gt;index);</span>
<span class="lineNum">    6509 </span><span class="lineCov">   27606308 :         nblk++;</span>
<span class="lineNum">    6510 </span><span class="lineCov">  110425232 :         todo |= process_bb (avail, bb,</span>
<span class="lineNum">    6511 </span><span class="lineCov">   27606308 :                             rpo_state[idx].visited != 0,</span>
<span class="lineNum">    6512 </span><span class="lineCov">   27606308 :                             rpo_state[idx].iterate,</span>
<span class="lineNum">    6513 </span>            :                             iterate, eliminate, do_region, exit_bbs);
<span class="lineNum">    6514 </span><span class="lineCov">   27606308 :         rpo_state[idx].visited++;</span>
<span class="lineNum">    6515 </span>            : 
<span class="lineNum">    6516 </span>            :         /* Verify if changed values flow over executable outgoing backedges
<span class="lineNum">    6517 </span>            :            and those change destination PHI values (that's the thing we
<span class="lineNum">    6518 </span>            :            can easily verify).  Reduce over all such edges to the farthest
<span class="lineNum">    6519 </span>            :            away PHI.  */
<span class="lineNum">    6520 </span><span class="lineCov">   27606308 :         int iterate_to = -1;</span>
<span class="lineNum">    6521 </span><span class="lineCov">   27606308 :         edge_iterator ei;</span>
<span class="lineNum">    6522 </span><span class="lineCov">   27606308 :         edge e;</span>
<span class="lineNum">    6523 </span><span class="lineCov">   94415950 :         FOR_EACH_EDGE (e, ei, bb-&gt;succs)</span>
<span class="lineNum">    6524 </span><span class="lineCov">   39203334 :           if ((e-&gt;flags &amp; (EDGE_DFS_BACK|EDGE_EXECUTABLE))</span>
<span class="lineNum">    6525 </span>            :               == (EDGE_DFS_BACK|EDGE_EXECUTABLE)
<span class="lineNum">    6526 </span><span class="lineCov">    2329674 :               &amp;&amp; rpo_state[bb_to_rpo[e-&gt;dest-&gt;index]].iterate)</span>
<span class="lineNum">    6527 </span>            :             {
<span class="lineNum">    6528 </span><span class="lineCov">    2328306 :               int destidx = bb_to_rpo[e-&gt;dest-&gt;index];</span>
<span class="lineNum">    6529 </span><span class="lineCov">    2328306 :               if (!rpo_state[destidx].visited)</span>
<span class="lineNum">    6530 </span>            :                 {
<span class="lineNum">    6531 </span><span class="lineCov">        371 :                   if (dump_file &amp;&amp; (dump_flags &amp; TDF_DETAILS))</span>
<span class="lineNum">    6532 </span><span class="lineNoCov">          0 :                     fprintf (dump_file, &quot;Unvisited destination %d\n&quot;,</span>
<span class="lineNum">    6533 </span>            :                              e-&gt;dest-&gt;index);
<span class="lineNum">    6534 </span><span class="lineCov">        371 :                   if (iterate_to == -1 || destidx &lt; iterate_to)</span>
<span class="lineNum">    6535 </span><span class="lineCov">        371 :                     iterate_to = destidx;</span>
<span class="lineNum">    6536 </span><span class="lineCov">        371 :                   continue;</span>
<span class="lineNum">    6537 </span>            :                 }
<span class="lineNum">    6538 </span><span class="lineCov">    2327935 :               if (dump_file &amp;&amp; (dump_flags &amp; TDF_DETAILS))</span>
<span class="lineNum">    6539 </span><span class="lineCov">         98 :                 fprintf (dump_file, &quot;Looking for changed values of backedge&quot;</span>
<span class="lineNum">    6540 </span>            :                          &quot; %d-&gt;%d destination PHIs\n&quot;,
<span class="lineNum">    6541 </span><span class="lineCov">         49 :                          e-&gt;src-&gt;index, e-&gt;dest-&gt;index);</span>
<span class="lineNum">    6542 </span><span class="lineCov">    2327935 :               vn_context_bb = e-&gt;dest;</span>
<span class="lineNum">    6543 </span><span class="lineCov">    2327935 :               gphi_iterator gsi;</span>
<span class="lineNum">    6544 </span><span class="lineCov">    2327935 :               for (gsi = gsi_start_phis (e-&gt;dest);</span>
<span class="lineNum">    6545 </span><span class="lineCov">    7783623 :                    !gsi_end_p (gsi); gsi_next (&amp;gsi))</span>
<span class="lineNum">    6546 </span>            :                 {
<span class="lineNum">    6547 </span><span class="lineCov">    4118085 :                   bool inserted = false;</span>
<span class="lineNum">    6548 </span>            :                   /* While we'd ideally just iterate on value changes
<span class="lineNum">    6549 </span>            :                      we CSE PHIs and do that even across basic-block
<span class="lineNum">    6550 </span>            :                      boundaries.  So even hashtable state changes can
<span class="lineNum">    6551 </span>            :                      be important (which is roughly equivalent to
<span class="lineNum">    6552 </span>            :                      PHI argument value changes).  To not excessively
<span class="lineNum">    6553 </span>            :                      iterate because of that we track whether a PHI
<span class="lineNum">    6554 </span>            :                      was CSEd to with GF_PLF_1.  */
<span class="lineNum">    6555 </span><span class="lineCov">    4118085 :                   bool phival_changed;</span>
<span class="lineNum">    6556 </span><span class="lineCov">    4118085 :                   if ((phival_changed = visit_phi (gsi.phi (),</span>
<span class="lineNum">    6557 </span>            :                                                    &amp;inserted, false))
<span class="lineNum">    6558 </span><span class="lineCov">    4118085 :                       || (inserted &amp;&amp; gimple_plf (gsi.phi (), GF_PLF_1)))</span>
<span class="lineNum">    6559 </span>            :                     {
<span class="lineNum">    6560 </span><span class="lineCov">     990332 :                       if (!phival_changed</span>
<span class="lineNum">    6561 </span><span class="lineCov">     990332 :                           &amp;&amp; dump_file &amp;&amp; (dump_flags &amp; TDF_DETAILS))</span>
<span class="lineNum">    6562 </span><span class="lineNoCov">          0 :                         fprintf (dump_file, &quot;PHI was CSEd and hashtable &quot;</span>
<span class="lineNum">    6563 </span>            :                                  &quot;state (changed)\n&quot;);
<span class="lineNum">    6564 </span><span class="lineCov">     990332 :                       if (iterate_to == -1 || destidx &lt; iterate_to)</span>
<span class="lineNum">    6565 </span><span class="lineCov">     990313 :                         iterate_to = destidx;</span>
<span class="lineNum">    6566 </span><span class="lineCov">     990332 :                       break;</span>
<span class="lineNum">    6567 </span>            :                     }
<span class="lineNum">    6568 </span>            :                 }
<span class="lineNum">    6569 </span><span class="lineCov">    2327935 :               vn_context_bb = NULL;</span>
<span class="lineNum">    6570 </span>            :             }
<span class="lineNum">    6571 </span><span class="lineCov">   27606308 :         if (iterate_to != -1)</span>
<span class="lineNum">    6572 </span>            :           {
<span class="lineNum">    6573 </span><span class="lineCov">     990660 :             do_unwind (&amp;rpo_state[iterate_to], iterate_to, avail, bb_to_rpo);</span>
<span class="lineNum">    6574 </span><span class="lineCov">     990660 :             idx = iterate_to;</span>
<span class="lineNum">    6575 </span><span class="lineCov">     990660 :             if (dump_file &amp;&amp; (dump_flags &amp; TDF_DETAILS))</span>
<span class="lineNum">    6576 </span><span class="lineCov">         36 :               fprintf (dump_file, &quot;Iterating to %d BB%d\n&quot;,</span>
<span class="lineNum">    6577 </span><span class="lineCov">         18 :                        iterate_to, rpo[iterate_to]);</span>
<span class="lineNum">    6578 </span><span class="lineCov">     990660 :             continue;</span>
<span class="lineNum">    6579 </span>            :           }
<span class="lineNum">    6580 </span>            : 
<span class="lineNum">    6581 </span><span class="lineCov">   26615648 :         idx++;</span>
<span class="lineNum">    6582 </span>            :       }
<span class="lineNum">    6583 </span><span class="lineCov">   28058741 :     while (idx &lt; n);</span>
<span class="lineNum">    6584 </span>            : 
<span class="lineNum">    6585 </span>            :   else /* !iterate */
<span class="lineNum">    6586 </span>            :     {
<span class="lineNum">    6587 </span>            :       /* Process all blocks greedily with a worklist that enforces RPO
<span class="lineNum">    6588 </span>            :          processing of reachable blocks.  */
<span class="lineNum">    6589 </span><span class="lineCov">     199818 :       auto_bitmap worklist;</span>
<span class="lineNum">    6590 </span><span class="lineCov">     199818 :       bitmap_set_bit (worklist, 0);</span>
<span class="lineNum">    6591 </span><span class="lineCov">    1264761 :       while (!bitmap_empty_p (worklist))</span>
<span class="lineNum">    6592 </span>            :         {
<span class="lineNum">    6593 </span><span class="lineCov">    1930068 :           int idx = bitmap_first_set_bit (worklist);</span>
<span class="lineNum">    6594 </span><span class="lineCov">    1930068 :           bitmap_clear_bit (worklist, idx);</span>
<span class="lineNum">    6595 </span><span class="lineCov">     965034 :           basic_block bb = BASIC_BLOCK_FOR_FN (fn, rpo[idx]);</span>
<span class="lineNum">    6596 </span><span class="lineCov">     965034 :           gcc_assert ((bb-&gt;flags &amp; BB_EXECUTABLE)</span>
<span class="lineNum">    6597 </span>            :                       &amp;&amp; !rpo_state[idx].visited);
<span class="lineNum">    6598 </span>            : 
<span class="lineNum">    6599 </span><span class="lineCov">     965034 :           if (dump_file &amp;&amp; (dump_flags &amp; TDF_DETAILS))</span>
<span class="lineNum">    6600 </span><span class="lineCov">        170 :             fprintf (dump_file, &quot;Processing block %d: BB%d\n&quot;, idx, bb-&gt;index);</span>
<span class="lineNum">    6601 </span>            : 
<span class="lineNum">    6602 </span>            :           /* When we run into predecessor edges where we cannot trust its
<span class="lineNum">    6603 </span>            :              executable state mark them executable so PHI processing will
<span class="lineNum">    6604 </span>            :              be conservative.
<span class="lineNum">    6605 </span>            :              ???  Do we need to force arguments flowing over that edge
<span class="lineNum">    6606 </span>            :              to be varying or will they even always be?  */
<span class="lineNum">    6607 </span><span class="lineCov">     965034 :           edge_iterator ei;</span>
<span class="lineNum">    6608 </span><span class="lineCov">     965034 :           edge e;</span>
<span class="lineNum">    6609 </span><span class="lineCov">    3161818 :           FOR_EACH_EDGE (e, ei, bb-&gt;preds)</span>
<span class="lineNum">    6610 </span><span class="lineCov">    1231750 :             if (!(e-&gt;flags &amp; EDGE_EXECUTABLE)</span>
<span class="lineNum">    6611 </span><span class="lineCov">      93023 :                 &amp;&amp; !rpo_state[bb_to_rpo[e-&gt;src-&gt;index]].visited</span>
<span class="lineNum">    6612 </span><span class="lineCov">      89469 :                 &amp;&amp; rpo_state[bb_to_rpo[e-&gt;src-&gt;index]].max_rpo &gt;= (int)idx)</span>
<span class="lineNum">    6613 </span>            :               {
<span class="lineNum">    6614 </span><span class="lineCov">      85826 :                 if (dump_file &amp;&amp; (dump_flags &amp; TDF_DETAILS))</span>
<span class="lineNum">    6615 </span><span class="lineCov">         14 :                   fprintf (dump_file, &quot;Cannot trust state of predecessor &quot;</span>
<span class="lineNum">    6616 </span>            :                            &quot;edge %d -&gt; %d, marking executable\n&quot;,
<span class="lineNum">    6617 </span><span class="lineCov">          7 :                            e-&gt;src-&gt;index, e-&gt;dest-&gt;index);</span>
<span class="lineNum">    6618 </span><span class="lineCov">      85826 :                 e-&gt;flags |= EDGE_EXECUTABLE;</span>
<span class="lineNum">    6619 </span>            :               }
<span class="lineNum">    6620 </span>            : 
<span class="lineNum">    6621 </span><span class="lineCov">     965034 :           nblk++;</span>
<span class="lineNum">    6622 </span><span class="lineCov">     965034 :           todo |= process_bb (avail, bb, false, false, false, eliminate,</span>
<span class="lineNum">    6623 </span>            :                               do_region, exit_bbs);
<span class="lineNum">    6624 </span><span class="lineCov">     965034 :           rpo_state[idx].visited++;</span>
<span class="lineNum">    6625 </span>            : 
<span class="lineNum">    6626 </span><span class="lineCov">    3205318 :           FOR_EACH_EDGE (e, ei, bb-&gt;succs)</span>
<span class="lineNum">    6627 </span><span class="lineCov">    1275250 :             if ((e-&gt;flags &amp; EDGE_EXECUTABLE)</span>
<span class="lineNum">    6628 </span><span class="lineCov">    1261210 :                 &amp;&amp; e-&gt;dest-&gt;index != EXIT_BLOCK</span>
<span class="lineNum">    6629 </span><span class="lineCov">    1179366 :                 &amp;&amp; (!do_region || !bitmap_bit_p (exit_bbs, e-&gt;dest-&gt;index))</span>
<span class="lineNum">    6630 </span><span class="lineCov">    2398708 :                 &amp;&amp; !rpo_state[bb_to_rpo[e-&gt;dest-&gt;index]].visited)</span>
<span class="lineNum">    6631 </span><span class="lineCov">    2077636 :               bitmap_set_bit (worklist, bb_to_rpo[e-&gt;dest-&gt;index]);</span>
<span class="lineNum">    6632 </span>            :         }
<span class="lineNum">    6633 </span>            :     }
<span class="lineNum">    6634 </span>            : 
<span class="lineNum">    6635 </span>            :   /* If statistics or dump file active.  */
<span class="lineNum">    6636 </span><span class="lineCov">    2628835 :   int nex = 0;</span>
<span class="lineNum">    6637 </span><span class="lineCov">    2628835 :   unsigned max_visited = 1;</span>
<span class="lineNum">    6638 </span><span class="lineCov">   24595656 :   for (int i = 0; i &lt; n; ++i)</span>
<span class="lineNum">    6639 </span>            :     {
<span class="lineNum">    6640 </span><span class="lineCov">   21966821 :       basic_block bb = BASIC_BLOCK_FOR_FN (fn, rpo[i]);</span>
<span class="lineNum">    6641 </span><span class="lineCov">   21966821 :       if (bb-&gt;flags &amp; BB_EXECUTABLE)</span>
<span class="lineNum">    6642 </span><span class="lineCov">   21791477 :         nex++;</span>
<span class="lineNum">    6643 </span><span class="lineCov">   43933642 :       statistics_histogram_event (cfun, &quot;RPO block visited times&quot;,</span>
<span class="lineNum">    6644 </span><span class="lineCov">   21966821 :                                   rpo_state[i].visited);</span>
<span class="lineNum">    6645 </span><span class="lineCov">   21966821 :       if (rpo_state[i].visited &gt; max_visited)</span>
<span class="lineNum">    6646 </span><span class="lineCov">     480296 :         max_visited = rpo_state[i].visited;</span>
<span class="lineNum">    6647 </span>            :     }
<span class="lineNum">    6648 </span><span class="lineCov">    2628835 :   unsigned nvalues = 0, navail = 0;</span>
<span class="lineNum">    6649 </span><span class="lineCov">    2628835 :   for (rpo_elim::rpo_avail_t::iterator i = avail.m_rpo_avail.begin ();</span>
<span class="lineNum">    6650 </span><span class="lineCov">   64541910 :        i != avail.m_rpo_avail.end (); ++i)</span>
<span class="lineNum">    6651 </span>            :     {
<span class="lineNum">    6652 </span><span class="lineCov">   29642120 :       nvalues++;</span>
<span class="lineNum">    6653 </span><span class="lineCov">   88926360 :       navail += (*i).second.length ();</span>
<span class="lineNum">    6654 </span>            :     }
<span class="lineNum">    6655 </span><span class="lineCov">    2628835 :   statistics_counter_event (cfun, &quot;RPO blocks&quot;, n);</span>
<span class="lineNum">    6656 </span><span class="lineCov">    2628835 :   statistics_counter_event (cfun, &quot;RPO blocks visited&quot;, nblk);</span>
<span class="lineNum">    6657 </span><span class="lineCov">    2628835 :   statistics_counter_event (cfun, &quot;RPO blocks executable&quot;, nex);</span>
<span class="lineNum">    6658 </span><span class="lineCov">    2628835 :   statistics_histogram_event (cfun, &quot;RPO iterations&quot;, 10*nblk / nex);</span>
<span class="lineNum">    6659 </span><span class="lineCov">    2628835 :   statistics_histogram_event (cfun, &quot;RPO num values&quot;, nvalues);</span>
<span class="lineNum">    6660 </span><span class="lineCov">    2628835 :   statistics_histogram_event (cfun, &quot;RPO num avail&quot;, navail);</span>
<span class="lineNum">    6661 </span><span class="lineCov">    2628835 :   statistics_histogram_event (cfun, &quot;RPO num lattice&quot;,</span>
<span class="lineNum">    6662 </span><span class="lineCov">    2628835 :                               vn_ssa_aux_hash-&gt;elements ());</span>
<span class="lineNum">    6663 </span><span class="lineCov">    2628835 :   if (dump_file &amp;&amp; (dump_flags &amp; (TDF_DETAILS|TDF_STATS)))</span>
<span class="lineNum">    6664 </span>            :     {
<span class="lineNum">    6665 </span><span class="lineCov">        582 :       fprintf (dump_file, &quot;RPO iteration over %d blocks visited %&quot; PRIu64</span>
<span class="lineNum">    6666 </span>            :                &quot; blocks in total discovering %d executable blocks iterating &quot;
<span class="lineNum">    6667 </span>            :                &quot;%d.%d times, a block was visited max. %u times\n&quot;,
<span class="lineNum">    6668 </span>            :                n, nblk, nex,
<span class="lineNum">    6669 </span><span class="lineCov">        194 :                (int)((10*nblk / nex)/10), (int)((10*nblk / nex)%10),</span>
<span class="lineNum">    6670 </span>            :                max_visited);
<span class="lineNum">    6671 </span><span class="lineCov">        194 :       fprintf (dump_file, &quot;RPO tracked %d values available at %d locations &quot;</span>
<span class="lineNum">    6672 </span>            :                &quot;and %&quot; PRIu64 &quot; lattice elements\n&quot;,
<span class="lineNum">    6673 </span><span class="lineCov">        194 :                nvalues, navail, (uint64_t) vn_ssa_aux_hash-&gt;elements ());</span>
<span class="lineNum">    6674 </span>            :     }
<span class="lineNum">    6675 </span>            : 
<span class="lineNum">    6676 </span><span class="lineCov">    2628835 :   if (eliminate)</span>
<span class="lineNum">    6677 </span>            :     {
<span class="lineNum">    6678 </span>            :       /* When !iterate we already performed elimination during the RPO
<span class="lineNum">    6679 </span>            :          walk.  */
<span class="lineNum">    6680 </span><span class="lineCov">    2044783 :       if (iterate)</span>
<span class="lineNum">    6681 </span>            :         {
<span class="lineNum">    6682 </span>            :           /* Elimination for region-based VN needs to be done within the
<span class="lineNum">    6683 </span>            :              RPO walk.  */
<span class="lineNum">    6684 </span><span class="lineCov">    1944874 :           gcc_assert (! do_region);</span>
<span class="lineNum">    6685 </span>            :           /* Note we can't use avail.walk here because that gets confused
<span class="lineNum">    6686 </span>            :              by the existing availability and it will be less efficient
<span class="lineNum">    6687 </span>            :              as well.  */
<span class="lineNum">    6688 </span><span class="lineCov">    1944874 :           todo |= eliminate_with_rpo_vn (NULL);</span>
<span class="lineNum">    6689 </span>            :         }
<span class="lineNum">    6690 </span>            :       else
<span class="lineNum">    6691 </span><span class="lineCov">      99909 :         todo |= avail.eliminate_cleanup (do_region);</span>
<span class="lineNum">    6692 </span>            :     }
<span class="lineNum">    6693 </span>            : 
<span class="lineNum">    6694 </span><span class="lineCov">    2628835 :   vn_valueize = NULL;</span>
<span class="lineNum">    6695 </span><span class="lineCov">    2628835 :   rpo_avail = NULL;</span>
<span class="lineNum">    6696 </span>            : 
<span class="lineNum">    6697 </span><span class="lineCov">    2628835 :   XDELETEVEC (bb_to_rpo);</span>
<span class="lineNum">    6698 </span><span class="lineCov">    2628835 :   XDELETEVEC (rpo);</span>
<span class="lineNum">    6699 </span>            : 
<span class="lineNum">    6700 </span><span class="lineCov">    2628835 :   return todo;</span>
<span class="lineNum">    6701 </span>            : }
<span class="lineNum">    6702 </span>            : 
<span class="lineNum">    6703 </span>            : /* Region-based entry for RPO VN.  Performs value-numbering and elimination
<span class="lineNum">    6704 </span>            :    on the SEME region specified by ENTRY and EXIT_BBS.  */
<a name="6705"><span class="lineNum">    6705 </span>            : </a>
<span class="lineNum">    6706 </span>            : unsigned
<span class="lineNum">    6707 </span><span class="lineCov">      14019 : do_rpo_vn (function *fn, edge entry, bitmap exit_bbs)</span>
<span class="lineNum">    6708 </span>            : {
<span class="lineNum">    6709 </span><span class="lineCov">      14019 :   default_vn_walk_kind = VN_WALKREWRITE;</span>
<span class="lineNum">    6710 </span><span class="lineCov">      14019 :   unsigned todo = do_rpo_vn (fn, entry, exit_bbs, false, true);</span>
<span class="lineNum">    6711 </span><span class="lineCov">      14019 :   free_rpo_vn ();</span>
<span class="lineNum">    6712 </span><span class="lineCov">      14019 :   return todo;</span>
<span class="lineNum">    6713 </span>            : }
<span class="lineNum">    6714 </span>            : 
<span class="lineNum">    6715 </span>            : 
<span class="lineNum">    6716 </span>            : namespace {
<span class="lineNum">    6717 </span>            : 
<span class="lineNum">    6718 </span>            : const pass_data pass_data_fre =
<span class="lineNum">    6719 </span>            : {
<span class="lineNum">    6720 </span>            :   GIMPLE_PASS, /* type */
<span class="lineNum">    6721 </span>            :   &quot;fre&quot;, /* name */
<span class="lineNum">    6722 </span>            :   OPTGROUP_NONE, /* optinfo_flags */
<span class="lineNum">    6723 </span>            :   TV_TREE_FRE, /* tv_id */
<span class="lineNum">    6724 </span>            :   ( PROP_cfg | PROP_ssa ), /* properties_required */
<span class="lineNum">    6725 </span>            :   0, /* properties_provided */
<span class="lineNum">    6726 </span>            :   0, /* properties_destroyed */
<span class="lineNum">    6727 </span>            :   0, /* todo_flags_start */
<span class="lineNum">    6728 </span>            :   0, /* todo_flags_finish */
<span class="lineNum">    6729 </span>            : };
<span class="lineNum">    6730 </span>            : 
<span class="lineNum">    6731 </span>            : class pass_fre : public gimple_opt_pass
<span class="lineNum">    6732 </span>            : {
<span class="lineNum">    6733 </span>            : public:
<span class="lineNum">    6734 </span>            :   pass_fre (gcc::context *ctxt)
<span class="lineNum">    6735 </span><span class="lineCov">    1021872 :     : gimple_opt_pass (pass_data_fre, ctxt)</span>
<span class="lineNum">    6736 </span>            :   {}
<a name="6737"><span class="lineNum">    6737 </span>            : </a>
<a name="6738"><span class="lineNum">    6738 </span>            :   /* opt_pass methods: */</a>
<span class="lineNum">    6739 </span><span class="lineCov">     340624 :   opt_pass * clone () { return new pass_fre (m_ctxt); }</span>
<span class="lineNum">    6740 </span><span class="lineCov">    2031067 :   virtual bool gate (function *) { return flag_tree_fre != 0; }</span>
<span class="lineNum">    6741 </span>            :   virtual unsigned int execute (function *);
<span class="lineNum">    6742 </span>            : 
<span class="lineNum">    6743 </span>            : }; // class pass_fre
<a name="6744"><span class="lineNum">    6744 </span>            : </a>
<span class="lineNum">    6745 </span>            : unsigned int
<span class="lineNum">    6746 </span><span class="lineCov">    2030764 : pass_fre::execute (function *fun)</span>
<span class="lineNum">    6747 </span>            : {
<span class="lineNum">    6748 </span><span class="lineCov">    2030764 :   unsigned todo = 0;</span>
<span class="lineNum">    6749 </span>            : 
<span class="lineNum">    6750 </span>            :   /* At -O[1g] use the cheap non-iterating mode.  */
<span class="lineNum">    6751 </span><span class="lineCov">    2030764 :   calculate_dominance_info (CDI_DOMINATORS);</span>
<span class="lineNum">    6752 </span><span class="lineCov">    2030764 :   if (optimize &gt; 1)</span>
<span class="lineNum">    6753 </span><span class="lineCov">    1944874 :     loop_optimizer_init (AVOID_CFG_MODIFICATIONS);</span>
<span class="lineNum">    6754 </span>            : 
<span class="lineNum">    6755 </span><span class="lineCov">    2030764 :   default_vn_walk_kind = VN_WALKREWRITE;</span>
<span class="lineNum">    6756 </span><span class="lineCov">    2030764 :   todo = do_rpo_vn (fun, NULL, NULL, optimize &gt; 1, true);</span>
<span class="lineNum">    6757 </span><span class="lineCov">    2030764 :   free_rpo_vn ();</span>
<span class="lineNum">    6758 </span>            : 
<span class="lineNum">    6759 </span><span class="lineCov">    2030764 :   if (optimize &gt; 1)</span>
<span class="lineNum">    6760 </span><span class="lineCov">    1944874 :     loop_optimizer_finalize ();</span>
<span class="lineNum">    6761 </span>            : 
<span class="lineNum">    6762 </span><span class="lineCov">    2030764 :   return todo;</span>
<span class="lineNum">    6763 </span>            : }
<span class="lineNum">    6764 </span>            : 
<span class="lineNum">    6765 </span>            : } // anon namespace
<a name="6766"><span class="lineNum">    6766 </span>            : </a>
<span class="lineNum">    6767 </span>            : gimple_opt_pass *
<span class="lineNum">    6768 </span><span class="lineCov">     170312 : make_pass_fre (gcc::context *ctxt)</span>
<span class="lineNum">    6769 </span>            : {
<span class="lineNum">    6770 </span><span class="lineCov">     170312 :   return new pass_fre (ctxt);</span>
<span class="lineNum">    6771 </span>            : }
<span class="lineNum">    6772 </span>            : 
<span class="lineNum">    6773 </span>            : #undef BB_EXECUTABLE
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.0</a></td></tr>
  </table>
  <br>
<h3>LCOV profile is generated on x86_64 machine using following configure options: configure --disable-bootstrap --enable-coverage=opt --enable-languages=c,c++,fortran,go,jit,lto --enable-host-shared. GCC test suite is run with the built compiler.</h3></body></html>
