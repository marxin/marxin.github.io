<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - gcc.info - gcc/tree-vrp.c</title>
  <link rel="stylesheet" type="text/css" href="../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../index.html">top level</a> - <a href="index.html">gcc</a> - tree-vrp.c<span style="font-size: 80%;"> (source / <a href="tree-vrp.c.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">gcc.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">2848</td>
            <td class="headerCovTableEntry">2949</td>
            <td class="headerCovTableEntryHi">96.6 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2018-09-22 10:58:49</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">101</td>
            <td class="headerCovTableEntry">108</td>
            <td class="headerCovTableEntryHi">93.5 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /* Support routines for Value Range Propagation (VRP).</a>
<span class="lineNum">       2 </span>            :    Copyright (C) 2005-2018 Free Software Foundation, Inc.
<span class="lineNum">       3 </span>            :    Contributed by Diego Novillo &lt;dnovillo@redhat.com&gt;.
<span class="lineNum">       4 </span>            : 
<span class="lineNum">       5 </span>            : This file is part of GCC.
<span class="lineNum">       6 </span>            : 
<span class="lineNum">       7 </span>            : GCC is free software; you can redistribute it and/or modify
<span class="lineNum">       8 </span>            : it under the terms of the GNU General Public License as published by
<span class="lineNum">       9 </span>            : the Free Software Foundation; either version 3, or (at your option)
<span class="lineNum">      10 </span>            : any later version.
<span class="lineNum">      11 </span>            : 
<span class="lineNum">      12 </span>            : GCC is distributed in the hope that it will be useful,
<span class="lineNum">      13 </span>            : but WITHOUT ANY WARRANTY; without even the implied warranty of
<span class="lineNum">      14 </span>            : MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
<span class="lineNum">      15 </span>            : GNU General Public License for more details.
<span class="lineNum">      16 </span>            : 
<span class="lineNum">      17 </span>            : You should have received a copy of the GNU General Public License
<span class="lineNum">      18 </span>            : along with GCC; see the file COPYING3.  If not see
<span class="lineNum">      19 </span>            : &lt;http://www.gnu.org/licenses/&gt;.  */
<span class="lineNum">      20 </span>            : 
<span class="lineNum">      21 </span>            : #include &quot;config.h&quot;
<span class="lineNum">      22 </span>            : #include &quot;system.h&quot;
<span class="lineNum">      23 </span>            : #include &quot;coretypes.h&quot;
<span class="lineNum">      24 </span>            : #include &quot;backend.h&quot;
<span class="lineNum">      25 </span>            : #include &quot;insn-codes.h&quot;
<span class="lineNum">      26 </span>            : #include &quot;rtl.h&quot;
<span class="lineNum">      27 </span>            : #include &quot;tree.h&quot;
<span class="lineNum">      28 </span>            : #include &quot;gimple.h&quot;
<span class="lineNum">      29 </span>            : #include &quot;cfghooks.h&quot;
<span class="lineNum">      30 </span>            : #include &quot;tree-pass.h&quot;
<span class="lineNum">      31 </span>            : #include &quot;ssa.h&quot;
<span class="lineNum">      32 </span>            : #include &quot;optabs-tree.h&quot;
<span class="lineNum">      33 </span>            : #include &quot;gimple-pretty-print.h&quot;
<span class="lineNum">      34 </span>            : #include &quot;diagnostic-core.h&quot;
<span class="lineNum">      35 </span>            : #include &quot;flags.h&quot;
<span class="lineNum">      36 </span>            : #include &quot;fold-const.h&quot;
<span class="lineNum">      37 </span>            : #include &quot;stor-layout.h&quot;
<span class="lineNum">      38 </span>            : #include &quot;calls.h&quot;
<span class="lineNum">      39 </span>            : #include &quot;cfganal.h&quot;
<span class="lineNum">      40 </span>            : #include &quot;gimple-fold.h&quot;
<span class="lineNum">      41 </span>            : #include &quot;tree-eh.h&quot;
<span class="lineNum">      42 </span>            : #include &quot;gimple-iterator.h&quot;
<span class="lineNum">      43 </span>            : #include &quot;gimple-walk.h&quot;
<span class="lineNum">      44 </span>            : #include &quot;tree-cfg.h&quot;
<span class="lineNum">      45 </span>            : #include &quot;tree-dfa.h&quot;
<span class="lineNum">      46 </span>            : #include &quot;tree-ssa-loop-manip.h&quot;
<span class="lineNum">      47 </span>            : #include &quot;tree-ssa-loop-niter.h&quot;
<span class="lineNum">      48 </span>            : #include &quot;tree-ssa-loop.h&quot;
<span class="lineNum">      49 </span>            : #include &quot;tree-into-ssa.h&quot;
<span class="lineNum">      50 </span>            : #include &quot;tree-ssa.h&quot;
<span class="lineNum">      51 </span>            : #include &quot;intl.h&quot;
<span class="lineNum">      52 </span>            : #include &quot;cfgloop.h&quot;
<span class="lineNum">      53 </span>            : #include &quot;tree-scalar-evolution.h&quot;
<span class="lineNum">      54 </span>            : #include &quot;tree-ssa-propagate.h&quot;
<span class="lineNum">      55 </span>            : #include &quot;tree-chrec.h&quot;
<span class="lineNum">      56 </span>            : #include &quot;tree-ssa-threadupdate.h&quot;
<span class="lineNum">      57 </span>            : #include &quot;tree-ssa-scopedtables.h&quot;
<span class="lineNum">      58 </span>            : #include &quot;tree-ssa-threadedge.h&quot;
<span class="lineNum">      59 </span>            : #include &quot;omp-general.h&quot;
<span class="lineNum">      60 </span>            : #include &quot;target.h&quot;
<span class="lineNum">      61 </span>            : #include &quot;case-cfn-macros.h&quot;
<span class="lineNum">      62 </span>            : #include &quot;params.h&quot;
<span class="lineNum">      63 </span>            : #include &quot;alloc-pool.h&quot;
<span class="lineNum">      64 </span>            : #include &quot;domwalk.h&quot;
<span class="lineNum">      65 </span>            : #include &quot;tree-cfgcleanup.h&quot;
<span class="lineNum">      66 </span>            : #include &quot;stringpool.h&quot;
<span class="lineNum">      67 </span>            : #include &quot;attribs.h&quot;
<span class="lineNum">      68 </span>            : #include &quot;vr-values.h&quot;
<span class="lineNum">      69 </span>            : #include &quot;builtins.h&quot;
<span class="lineNum">      70 </span>            : #include &quot;wide-int-range.h&quot;
<span class="lineNum">      71 </span>            : 
<span class="lineNum">      72 </span>            : /* Set of SSA names found live during the RPO traversal of the function
<span class="lineNum">      73 </span>            :    for still active basic-blocks.  */
<span class="lineNum">      74 </span>            : static sbitmap *live;
<span class="lineNum">      75 </span>            : 
<span class="lineNum">      76 </span>            : /* Return true if the SSA name NAME is live on the edge E.  */
<a name="77"><span class="lineNum">      77 </span>            : </a>
<span class="lineNum">      78 </span>            : static bool
<span class="lineNum">      79 </span><span class="lineCov">   12183642 : live_on_edge (edge e, tree name)</span>
<span class="lineNum">      80 </span>            : {
<span class="lineNum">      81 </span><span class="lineCov">   12183642 :   return (live[e-&gt;dest-&gt;index]</span>
<span class="lineNum">      82 </span><span class="lineCov">   12183642 :           &amp;&amp; bitmap_bit_p (live[e-&gt;dest-&gt;index], SSA_NAME_VERSION (name)));</span>
<span class="lineNum">      83 </span>            : }
<span class="lineNum">      84 </span>            : 
<span class="lineNum">      85 </span>            : /* Location information for ASSERT_EXPRs.  Each instance of this
<span class="lineNum">      86 </span>            :    structure describes an ASSERT_EXPR for an SSA name.  Since a single
<span class="lineNum">      87 </span>            :    SSA name may have more than one assertion associated with it, these
<span class="lineNum">      88 </span>            :    locations are kept in a linked list attached to the corresponding
<span class="lineNum">      89 </span>            :    SSA name.  */
<span class="lineNum">      90 </span>            : struct assert_locus
<span class="lineNum">      91 </span>            : {
<span class="lineNum">      92 </span>            :   /* Basic block where the assertion would be inserted.  */
<span class="lineNum">      93 </span>            :   basic_block bb;
<span class="lineNum">      94 </span>            : 
<span class="lineNum">      95 </span>            :   /* Some assertions need to be inserted on an edge (e.g., assertions
<span class="lineNum">      96 </span>            :      generated by COND_EXPRs).  In those cases, BB will be NULL.  */
<span class="lineNum">      97 </span>            :   edge e;
<span class="lineNum">      98 </span>            : 
<span class="lineNum">      99 </span>            :   /* Pointer to the statement that generated this assertion.  */
<span class="lineNum">     100 </span>            :   gimple_stmt_iterator si;
<span class="lineNum">     101 </span>            : 
<span class="lineNum">     102 </span>            :   /* Predicate code for the ASSERT_EXPR.  Must be COMPARISON_CLASS_P.  */
<span class="lineNum">     103 </span>            :   enum tree_code comp_code;
<span class="lineNum">     104 </span>            : 
<span class="lineNum">     105 </span>            :   /* Value being compared against.  */
<span class="lineNum">     106 </span>            :   tree val;
<span class="lineNum">     107 </span>            : 
<span class="lineNum">     108 </span>            :   /* Expression to compare.  */
<span class="lineNum">     109 </span>            :   tree expr;
<span class="lineNum">     110 </span>            : 
<span class="lineNum">     111 </span>            :   /* Next node in the linked list.  */
<span class="lineNum">     112 </span>            :   assert_locus *next;
<span class="lineNum">     113 </span>            : };
<span class="lineNum">     114 </span>            : 
<span class="lineNum">     115 </span>            : /* If bit I is present, it means that SSA name N_i has a list of
<span class="lineNum">     116 </span>            :    assertions that should be inserted in the IL.  */
<span class="lineNum">     117 </span>            : static bitmap need_assert_for;
<span class="lineNum">     118 </span>            : 
<span class="lineNum">     119 </span>            : /* Array of locations lists where to insert assertions.  ASSERTS_FOR[I]
<span class="lineNum">     120 </span>            :    holds a list of ASSERT_LOCUS_T nodes that describe where
<span class="lineNum">     121 </span>            :    ASSERT_EXPRs for SSA name N_I should be inserted.  */
<span class="lineNum">     122 </span>            : static assert_locus **asserts_for;
<span class="lineNum">     123 </span>            : 
<span class="lineNum">     124 </span>            : /* Return the maximum value for TYPE.  */
<a name="125"><span class="lineNum">     125 </span>            : </a>
<span class="lineNum">     126 </span>            : tree
<span class="lineNum">     127 </span><span class="lineCov">   38098426 : vrp_val_max (const_tree type)</span>
<span class="lineNum">     128 </span>            : {
<span class="lineNum">     129 </span><span class="lineCov">   38098426 :   if (!INTEGRAL_TYPE_P (type))</span>
<span class="lineNum">     130 </span>            :     return NULL_TREE;
<span class="lineNum">     131 </span>            : 
<span class="lineNum">     132 </span><span class="lineCov">   38031281 :   return TYPE_MAX_VALUE (type);</span>
<span class="lineNum">     133 </span>            : }
<span class="lineNum">     134 </span>            : 
<span class="lineNum">     135 </span>            : /* Return the minimum value for TYPE.  */
<a name="136"><span class="lineNum">     136 </span>            : </a>
<span class="lineNum">     137 </span>            : tree
<span class="lineNum">     138 </span><span class="lineCov">   46541602 : vrp_val_min (const_tree type)</span>
<span class="lineNum">     139 </span>            : {
<span class="lineNum">     140 </span><span class="lineCov">   46541602 :   if (!INTEGRAL_TYPE_P (type))</span>
<span class="lineNum">     141 </span>            :     return NULL_TREE;
<span class="lineNum">     142 </span>            : 
<span class="lineNum">     143 </span><span class="lineCov">   44770984 :   return TYPE_MIN_VALUE (type);</span>
<span class="lineNum">     144 </span>            : }
<span class="lineNum">     145 </span>            : 
<span class="lineNum">     146 </span>            : /* Return whether VAL is equal to the maximum value of its type.
<span class="lineNum">     147 </span>            :    We can't do a simple equality comparison with TYPE_MAX_VALUE because
<span class="lineNum">     148 </span>            :    C typedefs and Ada subtypes can produce types whose TYPE_MAX_VALUE
<span class="lineNum">     149 </span>            :    is not == to the integer constant with the same value in the type.  */
<a name="150"><span class="lineNum">     150 </span>            : </a>
<span class="lineNum">     151 </span>            : bool
<span class="lineNum">     152 </span><span class="lineCov">   10401958 : vrp_val_is_max (const_tree val)</span>
<span class="lineNum">     153 </span>            : {
<span class="lineNum">     154 </span><span class="lineCov">   10401958 :   tree type_max = vrp_val_max (TREE_TYPE (val));</span>
<span class="lineNum">     155 </span><span class="lineCov">   10401958 :   return (val == type_max</span>
<span class="lineNum">     156 </span><span class="lineCov">   10401958 :           || (type_max != NULL_TREE</span>
<span class="lineNum">     157 </span><span class="lineCov">    8735179 :               &amp;&amp; operand_equal_p (val, type_max, 0)));</span>
<span class="lineNum">     158 </span>            : }
<span class="lineNum">     159 </span>            : 
<span class="lineNum">     160 </span>            : /* Return whether VAL is equal to the minimum value of its type.  */
<a name="161"><span class="lineNum">     161 </span>            : </a>
<span class="lineNum">     162 </span>            : bool
<span class="lineNum">     163 </span><span class="lineCov">   32957772 : vrp_val_is_min (const_tree val)</span>
<span class="lineNum">     164 </span>            : {
<span class="lineNum">     165 </span><span class="lineCov">   32957772 :   tree type_min = vrp_val_min (TREE_TYPE (val));</span>
<span class="lineNum">     166 </span><span class="lineCov">   32957772 :   return (val == type_min</span>
<span class="lineNum">     167 </span><span class="lineCov">   32957772 :           || (type_min != NULL_TREE</span>
<span class="lineNum">     168 </span><span class="lineCov">   26790143 :               &amp;&amp; operand_equal_p (val, type_min, 0)));</span>
<span class="lineNum">     169 </span>            : }
<span class="lineNum">     170 </span>            : 
<span class="lineNum">     171 </span>            : /* VR_TYPE describes a range with mininum value *MIN and maximum
<span class="lineNum">     172 </span>            :    value *MAX.  Restrict the range to the set of values that have
<span class="lineNum">     173 </span>            :    no bits set outside NONZERO_BITS.  Update *MIN and *MAX and
<span class="lineNum">     174 </span>            :    return the new range type.
<span class="lineNum">     175 </span>            : 
<span class="lineNum">     176 </span>            :    SGN gives the sign of the values described by the range.  */
<span class="lineNum">     177 </span>            : 
<span class="lineNum">     178 </span>            : enum value_range_type
<span class="lineNum">     179 </span><span class="lineCov">     447043 : intersect_range_with_nonzero_bits (enum value_range_type vr_type,</span>
<span class="lineNum">     180 </span>            :                                    wide_int *min, wide_int *max,
<span class="lineNum">     181 </span>            :                                    const wide_int &amp;nonzero_bits,
<span class="lineNum">     182 </span>            :                                    signop sgn)
<span class="lineNum">     183 </span>            : {
<span class="lineNum">     184 </span><span class="lineCov">     447043 :   if (vr_type == VR_ANTI_RANGE)</span>
<span class="lineNum">     185 </span>            :     {
<span class="lineNum">     186 </span>            :       /* The VR_ANTI_RANGE is equivalent to the union of the ranges
<span class="lineNum">     187 </span>            :          A: [-INF, *MIN) and B: (*MAX, +INF].  First use NONZERO_BITS
<span class="lineNum">     188 </span>            :          to create an inclusive upper bound for A and an inclusive lower
<span class="lineNum">     189 </span>            :          bound for B.  */
<span class="lineNum">     190 </span><span class="lineCov">      13964 :       wide_int a_max = wi::round_down_for_mask (*min - 1, nonzero_bits);</span>
<span class="lineNum">     191 </span><span class="lineCov">      13964 :       wide_int b_min = wi::round_up_for_mask (*max + 1, nonzero_bits);</span>
<span class="lineNum">     192 </span>            : 
<span class="lineNum">     193 </span>            :       /* If the calculation of A_MAX wrapped, A is effectively empty
<span class="lineNum">     194 </span>            :          and A_MAX is the highest value that satisfies NONZERO_BITS.
<span class="lineNum">     195 </span>            :          Likewise if the calculation of B_MIN wrapped, B is effectively
<span class="lineNum">     196 </span>            :          empty and B_MIN is the lowest value that satisfies NONZERO_BITS.  */
<span class="lineNum">     197 </span><span class="lineCov">      13964 :       bool a_empty = wi::ge_p (a_max, *min, sgn);</span>
<span class="lineNum">     198 </span><span class="lineCov">      13964 :       bool b_empty = wi::le_p (b_min, *max, sgn);</span>
<span class="lineNum">     199 </span>            : 
<span class="lineNum">     200 </span>            :       /* If both A and B are empty, there are no valid values.  */
<span class="lineNum">     201 </span><span class="lineCov">      13964 :       if (a_empty &amp;&amp; b_empty)</span>
<span class="lineNum">     202 </span><span class="lineCov">        126 :         return VR_UNDEFINED;</span>
<span class="lineNum">     203 </span>            : 
<span class="lineNum">     204 </span>            :       /* If exactly one of A or B is empty, return a VR_RANGE for the
<span class="lineNum">     205 </span>            :          other one.  */
<span class="lineNum">     206 </span><span class="lineCov">      13964 :       if (a_empty || b_empty)</span>
<span class="lineNum">     207 </span>            :         {
<span class="lineNum">     208 </span><span class="lineCov">        126 :           *min = b_min;</span>
<span class="lineNum">     209 </span><span class="lineCov">        126 :           *max = a_max;</span>
<span class="lineNum">     210 </span><span class="lineCov">        126 :           gcc_checking_assert (wi::le_p (*min, *max, sgn));</span>
<span class="lineNum">     211 </span>            :           return VR_RANGE;
<span class="lineNum">     212 </span>            :         }
<span class="lineNum">     213 </span>            : 
<span class="lineNum">     214 </span>            :       /* Update the VR_ANTI_RANGE bounds.  */
<span class="lineNum">     215 </span><span class="lineCov">      13838 :       *min = a_max + 1;</span>
<span class="lineNum">     216 </span><span class="lineCov">      13838 :       *max = b_min - 1;</span>
<span class="lineNum">     217 </span><span class="lineCov">      13838 :       gcc_checking_assert (wi::le_p (*min, *max, sgn));</span>
<span class="lineNum">     218 </span>            : 
<span class="lineNum">     219 </span>            :       /* Now check whether the excluded range includes any values that
<span class="lineNum">     220 </span>            :          satisfy NONZERO_BITS.  If not, switch to a full VR_RANGE.  */
<span class="lineNum">     221 </span><span class="lineCov">      13838 :       if (wi::round_up_for_mask (*min, nonzero_bits) == b_min)</span>
<span class="lineNum">     222 </span>            :         {
<span class="lineNum">     223 </span><span class="lineCov">        123 :           unsigned int precision = min-&gt;get_precision ();</span>
<span class="lineNum">     224 </span><span class="lineCov">        123 :           *min = wi::min_value (precision, sgn);</span>
<span class="lineNum">     225 </span><span class="lineCov">        123 :           *max = wi::max_value (precision, sgn);</span>
<span class="lineNum">     226 </span><span class="lineCov">        123 :           vr_type = VR_RANGE;</span>
<span class="lineNum">     227 </span>            :         }
<span class="lineNum">     228 </span>            :     }
<span class="lineNum">     229 </span><span class="lineCov">     446917 :   if (vr_type == VR_RANGE)</span>
<span class="lineNum">     230 </span>            :     {
<span class="lineNum">     231 </span><span class="lineCov">     190548 :       *max = wi::round_down_for_mask (*max, nonzero_bits);</span>
<span class="lineNum">     232 </span>            : 
<span class="lineNum">     233 </span>            :       /* Check that the range contains at least one valid value.  */
<span class="lineNum">     234 </span><span class="lineCov">     190548 :       if (wi::gt_p (*min, *max, sgn))</span>
<span class="lineNum">     235 </span>            :         return VR_UNDEFINED;
<span class="lineNum">     236 </span>            : 
<span class="lineNum">     237 </span><span class="lineCov">     190548 :       *min = wi::round_up_for_mask (*min, nonzero_bits);</span>
<span class="lineNum">     238 </span><span class="lineCov">     190548 :       gcc_checking_assert (wi::le_p (*min, *max, sgn));</span>
<span class="lineNum">     239 </span>            :     }
<span class="lineNum">     240 </span>            :   return vr_type;
<span class="lineNum">     241 </span>            : }
<span class="lineNum">     242 </span>            : 
<span class="lineNum">     243 </span>            : /* Set value range VR to VR_UNDEFINED.  */
<span class="lineNum">     244 </span>            : 
<span class="lineNum">     245 </span>            : static inline void
<span class="lineNum">     246 </span>            : set_value_range_to_undefined (value_range *vr)
<span class="lineNum">     247 </span>            : {
<span class="lineNum">     248 </span><span class="lineCov">      57223 :   vr-&gt;type = VR_UNDEFINED;</span>
<span class="lineNum">     249 </span><span class="lineCov">      57223 :   vr-&gt;min = vr-&gt;max = NULL_TREE;</span>
<span class="lineNum">     250 </span><span class="lineCov">      57223 :   if (vr-&gt;equiv)</span>
<span class="lineNum">     251 </span><span class="lineCov">      24248 :     bitmap_clear (vr-&gt;equiv);</span>
<span class="lineNum">     252 </span>            : }
<span class="lineNum">     253 </span>            : 
<span class="lineNum">     254 </span>            : /* Set value range VR to VR_VARYING.  */
<a name="255"><span class="lineNum">     255 </span>            : </a>
<span class="lineNum">     256 </span>            : void
<span class="lineNum">     257 </span><span class="lineCov">   79456635 : set_value_range_to_varying (value_range *vr)</span>
<span class="lineNum">     258 </span>            : {
<span class="lineNum">     259 </span><span class="lineCov">   79456635 :   vr-&gt;type = VR_VARYING;</span>
<span class="lineNum">     260 </span><span class="lineCov">   79456635 :   vr-&gt;min = vr-&gt;max = NULL_TREE;</span>
<span class="lineNum">     261 </span><span class="lineCov">   79456635 :   if (vr-&gt;equiv)</span>
<span class="lineNum">     262 </span><span class="lineCov">     388047 :     bitmap_clear (vr-&gt;equiv);</span>
<span class="lineNum">     263 </span><span class="lineCov">   79456635 : }</span>
<span class="lineNum">     264 </span>            : 
<span class="lineNum">     265 </span>            : /* Set value range VR to {T, MIN, MAX, EQUIV}.  */
<a name="266"><span class="lineNum">     266 </span>            : </a>
<span class="lineNum">     267 </span>            : void
<span class="lineNum">     268 </span><span class="lineCov">  233631921 : set_value_range (value_range *vr, enum value_range_type t, tree min,</span>
<span class="lineNum">     269 </span>            :                  tree max, bitmap equiv)
<span class="lineNum">     270 </span>            : {
<span class="lineNum">     271 </span>            :   /* Check the validity of the range.  */
<span class="lineNum">     272 </span><span class="lineCov">  233631921 :   if (flag_checking</span>
<span class="lineNum">     273 </span><span class="lineCov">  233629498 :       &amp;&amp; (t == VR_RANGE || t == VR_ANTI_RANGE))</span>
<span class="lineNum">     274 </span>            :     {
<span class="lineNum">     275 </span><span class="lineCov">  212877883 :       int cmp;</span>
<span class="lineNum">     276 </span>            : 
<span class="lineNum">     277 </span><span class="lineCov">  212877883 :       gcc_assert (min &amp;&amp; max);</span>
<span class="lineNum">     278 </span>            : 
<span class="lineNum">     279 </span><span class="lineCov">  212877883 :       gcc_assert (!TREE_OVERFLOW_P (min) &amp;&amp; !TREE_OVERFLOW_P (max));</span>
<span class="lineNum">     280 </span>            : 
<span class="lineNum">     281 </span><span class="lineCov">  212877883 :       if (INTEGRAL_TYPE_P (TREE_TYPE (min)) &amp;&amp; t == VR_ANTI_RANGE)</span>
<span class="lineNum">     282 </span><span class="lineCov">   13409201 :         gcc_assert (!vrp_val_is_min (min) || !vrp_val_is_max (max));</span>
<span class="lineNum">     283 </span>            : 
<span class="lineNum">     284 </span><span class="lineCov">  212877883 :       cmp = compare_values (min, max);</span>
<span class="lineNum">     285 </span><span class="lineCov">  212877883 :       gcc_assert (cmp == 0 || cmp == -1 || cmp == -2);</span>
<span class="lineNum">     286 </span>            :     }
<span class="lineNum">     287 </span>            : 
<span class="lineNum">     288 </span><span class="lineCov">  233631921 :   if (flag_checking</span>
<span class="lineNum">     289 </span><span class="lineCov">  233629498 :       &amp;&amp; (t == VR_UNDEFINED || t == VR_VARYING))</span>
<span class="lineNum">     290 </span>            :     {
<span class="lineNum">     291 </span><span class="lineCov">   20751615 :       gcc_assert (min == NULL_TREE &amp;&amp; max == NULL_TREE);</span>
<span class="lineNum">     292 </span><span class="lineCov">   20751615 :       gcc_assert (equiv == NULL || bitmap_empty_p (equiv));</span>
<span class="lineNum">     293 </span>            :     }
<span class="lineNum">     294 </span>            : 
<span class="lineNum">     295 </span><span class="lineCov">  233631921 :   vr-&gt;type = t;</span>
<span class="lineNum">     296 </span><span class="lineCov">  233631921 :   vr-&gt;min = min;</span>
<span class="lineNum">     297 </span><span class="lineCov">  233631921 :   vr-&gt;max = max;</span>
<span class="lineNum">     298 </span>            : 
<span class="lineNum">     299 </span>            :   /* Since updating the equivalence set involves deep copying the
<span class="lineNum">     300 </span>            :      bitmaps, only do it if absolutely necessary.
<span class="lineNum">     301 </span>            : 
<span class="lineNum">     302 </span>            :      All equivalence bitmaps are allocated from the same obstack.  So
<span class="lineNum">     303 </span>            :      we can use the obstack associated with EQUIV to allocate vr-&gt;equiv.  */
<span class="lineNum">     304 </span><span class="lineCov">  233631921 :   if (vr-&gt;equiv == NULL</span>
<span class="lineNum">     305 </span><span class="lineCov">  170436897 :       &amp;&amp; equiv != NULL)</span>
<span class="lineNum">     306 </span><span class="lineCov">    8715355 :     vr-&gt;equiv = BITMAP_ALLOC (equiv-&gt;obstack);</span>
<span class="lineNum">     307 </span>            : 
<span class="lineNum">     308 </span><span class="lineCov">  233631921 :   if (equiv != vr-&gt;equiv)</span>
<span class="lineNum">     309 </span>            :     {
<span class="lineNum">     310 </span><span class="lineCov">   10171117 :       if (equiv &amp;&amp; !bitmap_empty_p (equiv))</span>
<span class="lineNum">     311 </span><span class="lineCov">    9566032 :         bitmap_copy (vr-&gt;equiv, equiv);</span>
<span class="lineNum">     312 </span>            :       else
<span class="lineNum">     313 </span><span class="lineCov">     605085 :         bitmap_clear (vr-&gt;equiv);</span>
<span class="lineNum">     314 </span>            :     }
<span class="lineNum">     315 </span><span class="lineCov">  233631921 : }</span>
<span class="lineNum">     316 </span>            : 
<span class="lineNum">     317 </span>            : 
<span class="lineNum">     318 </span>            : /* Set value range VR to the canonical form of {T, MIN, MAX, EQUIV}.
<span class="lineNum">     319 </span>            :    This means adjusting T, MIN and MAX representing the case of a
<span class="lineNum">     320 </span>            :    wrapping range with MAX &lt; MIN covering [MIN, type_max] U [type_min, MAX]
<span class="lineNum">     321 </span>            :    as anti-rage ~[MAX+1, MIN-1].  Likewise for wrapping anti-ranges.
<span class="lineNum">     322 </span>            :    In corner cases where MAX+1 or MIN-1 wraps this will fall back
<span class="lineNum">     323 </span>            :    to varying.
<span class="lineNum">     324 </span>            :    This routine exists to ease canonicalization in the case where we
<span class="lineNum">     325 </span>            :    extract ranges from var + CST op limit.  */
<a name="326"><span class="lineNum">     326 </span>            : </a>
<span class="lineNum">     327 </span>            : void
<span class="lineNum">     328 </span><span class="lineCov">   94925502 : set_and_canonicalize_value_range (value_range *vr, enum value_range_type t,</span>
<span class="lineNum">     329 </span>            :                                   tree min, tree max, bitmap equiv)
<span class="lineNum">     330 </span>            : {
<span class="lineNum">     331 </span>            :   /* Use the canonical setters for VR_UNDEFINED and VR_VARYING.  */
<span class="lineNum">     332 </span><span class="lineCov">   94925502 :   if (t == VR_UNDEFINED)</span>
<span class="lineNum">     333 </span>            :     {
<span class="lineNum">     334 </span><span class="lineCov">       3127 :       set_value_range_to_undefined (vr);</span>
<span class="lineNum">     335 </span><span class="lineCov">       3127 :       return;</span>
<span class="lineNum">     336 </span>            :     }
<span class="lineNum">     337 </span><span class="lineCov">   94922375 :   else if (t == VR_VARYING)</span>
<span class="lineNum">     338 </span>            :     {
<span class="lineNum">     339 </span><span class="lineNoCov">          0 :       set_value_range_to_varying (vr);</span>
<span class="lineNum">     340 </span><span class="lineNoCov">          0 :       return;</span>
<span class="lineNum">     341 </span>            :     }
<span class="lineNum">     342 </span>            : 
<span class="lineNum">     343 </span>            :   /* Nothing to canonicalize for symbolic ranges.  */
<span class="lineNum">     344 </span><span class="lineCov">   94922375 :   if (TREE_CODE (min) != INTEGER_CST</span>
<span class="lineNum">     345 </span><span class="lineCov">   90234848 :       || TREE_CODE (max) != INTEGER_CST)</span>
<span class="lineNum">     346 </span>            :     {
<span class="lineNum">     347 </span><span class="lineCov">    5529729 :       set_value_range (vr, t, min, max, equiv);</span>
<span class="lineNum">     348 </span><span class="lineCov">    5529729 :       return;</span>
<span class="lineNum">     349 </span>            :     }
<span class="lineNum">     350 </span>            : 
<span class="lineNum">     351 </span>            :   /* Wrong order for min and max, to swap them and the VR type we need
<span class="lineNum">     352 </span>            :      to adjust them.  */
<span class="lineNum">     353 </span><span class="lineCov">   89392646 :   if (tree_int_cst_lt (max, min))</span>
<span class="lineNum">     354 </span>            :     {
<span class="lineNum">     355 </span><span class="lineCov">    4682995 :       tree one, tmp;</span>
<span class="lineNum">     356 </span>            : 
<span class="lineNum">     357 </span>            :       /* For one bit precision if max &lt; min, then the swapped
<span class="lineNum">     358 </span>            :          range covers all values, so for VR_RANGE it is varying and
<span class="lineNum">     359 </span>            :          for VR_ANTI_RANGE empty range, so drop to varying as well.  */
<span class="lineNum">     360 </span><span class="lineCov">    4682995 :       if (TYPE_PRECISION (TREE_TYPE (min)) == 1)</span>
<span class="lineNum">     361 </span>            :         {
<span class="lineNum">     362 </span><span class="lineCov">        368 :           set_value_range_to_varying (vr);</span>
<span class="lineNum">     363 </span><span class="lineCov">        368 :           return;</span>
<span class="lineNum">     364 </span>            :         }
<span class="lineNum">     365 </span>            : 
<span class="lineNum">     366 </span><span class="lineCov">   14047881 :       one = build_int_cst (TREE_TYPE (min), 1);</span>
<span class="lineNum">     367 </span><span class="lineCov">    4682627 :       tmp = int_const_binop (PLUS_EXPR, max, one);</span>
<span class="lineNum">     368 </span><span class="lineCov">    4682627 :       max = int_const_binop (MINUS_EXPR, min, one);</span>
<span class="lineNum">     369 </span><span class="lineCov">    4682627 :       min = tmp;</span>
<span class="lineNum">     370 </span>            : 
<span class="lineNum">     371 </span>            :       /* There's one corner case, if we had [C+1, C] before we now have
<span class="lineNum">     372 </span>            :          that again.  But this represents an empty value range, so drop
<span class="lineNum">     373 </span>            :          to varying in this case.  */
<span class="lineNum">     374 </span><span class="lineCov">    4682627 :       if (tree_int_cst_lt (max, min))</span>
<span class="lineNum">     375 </span>            :         {
<span class="lineNum">     376 </span><span class="lineCov">    3339594 :           set_value_range_to_varying (vr);</span>
<span class="lineNum">     377 </span><span class="lineCov">    3339594 :           return;</span>
<span class="lineNum">     378 </span>            :         }
<span class="lineNum">     379 </span>            : 
<span class="lineNum">     380 </span><span class="lineCov">    1343033 :       t = t == VR_RANGE ? VR_ANTI_RANGE : VR_RANGE;</span>
<span class="lineNum">     381 </span>            :     }
<span class="lineNum">     382 </span>            : 
<span class="lineNum">     383 </span>            :   /* Anti-ranges that can be represented as ranges should be so.  */
<span class="lineNum">     384 </span><span class="lineCov">   86052684 :   if (t == VR_ANTI_RANGE)</span>
<span class="lineNum">     385 </span>            :     {
<span class="lineNum">     386 </span>            :       /* For -fstrict-enums we may receive out-of-range ranges so consider
<span class="lineNum">     387 </span>            :          values &lt; -INF and values &gt; INF as -INF/INF as well.  */
<span class="lineNum">     388 </span><span class="lineCov">   39432099 :       tree type = TREE_TYPE (min);</span>
<span class="lineNum">     389 </span><span class="lineCov">   39432099 :       bool is_min = (INTEGRAL_TYPE_P (type)</span>
<span class="lineNum">     390 </span><span class="lineCov">   39432099 :                      &amp;&amp; tree_int_cst_compare (min, TYPE_MIN_VALUE (type)) &lt;= 0);</span>
<span class="lineNum">     391 </span><span class="lineCov">   39432099 :       bool is_max = (INTEGRAL_TYPE_P (type)</span>
<span class="lineNum">     392 </span><span class="lineCov">   39432099 :                      &amp;&amp; tree_int_cst_compare (max, TYPE_MAX_VALUE (type)) &gt;= 0);</span>
<span class="lineNum">     393 </span>            : 
<span class="lineNum">     394 </span><span class="lineCov">   39432099 :       if (is_min &amp;&amp; is_max)</span>
<span class="lineNum">     395 </span>            :         {
<span class="lineNum">     396 </span>            :           /* We cannot deal with empty ranges, drop to varying.
<span class="lineNum">     397 </span>            :              ???  This could be VR_UNDEFINED instead.  */
<span class="lineNum">     398 </span><span class="lineNoCov">          0 :           set_value_range_to_varying (vr);</span>
<span class="lineNum">     399 </span><span class="lineNoCov">          0 :           return;</span>
<span class="lineNum">     400 </span>            :         }
<span class="lineNum">     401 </span><span class="lineCov">   39432099 :       else if (TYPE_PRECISION (TREE_TYPE (min)) == 1</span>
<span class="lineNum">     402 </span><span class="lineCov">   39432099 :                &amp;&amp; (is_min || is_max))</span>
<span class="lineNum">     403 </span>            :         {
<span class="lineNum">     404 </span>            :           /* Non-empty boolean ranges can always be represented
<span class="lineNum">     405 </span>            :              as a singleton range.  */
<span class="lineNum">     406 </span><span class="lineCov">    1073712 :           if (is_min)</span>
<span class="lineNum">     407 </span><span class="lineCov">    2111704 :             min = max = vrp_val_max (TREE_TYPE (min));</span>
<span class="lineNum">     408 </span>            :           else
<span class="lineNum">     409 </span><span class="lineCov">      35720 :             min = max = vrp_val_min (TREE_TYPE (min));</span>
<span class="lineNum">     410 </span>            :           t = VR_RANGE;
<span class="lineNum">     411 </span>            :         }
<span class="lineNum">     412 </span><span class="lineCov">   38358387 :       else if (is_min</span>
<span class="lineNum">     413 </span>            :                /* As a special exception preserve non-null ranges.  */
<span class="lineNum">     414 </span><span class="lineCov">   39894289 :                &amp;&amp; !(TYPE_UNSIGNED (TREE_TYPE (min))</span>
<span class="lineNum">     415 </span><span class="lineCov">    1538439 :                     &amp;&amp; integer_zerop (max)))</span>
<span class="lineNum">     416 </span>            :         {
<span class="lineNum">     417 </span><span class="lineCov">      45008 :           tree one = build_int_cst (TREE_TYPE (max), 1);</span>
<span class="lineNum">     418 </span><span class="lineCov">      22504 :           min = int_const_binop (PLUS_EXPR, max, one);</span>
<span class="lineNum">     419 </span><span class="lineCov">      22504 :           max = vrp_val_max (TREE_TYPE (max));</span>
<span class="lineNum">     420 </span><span class="lineCov">      22504 :           t = VR_RANGE;</span>
<span class="lineNum">     421 </span>            :         }
<span class="lineNum">     422 </span><span class="lineCov">   38335883 :       else if (is_max)</span>
<span class="lineNum">     423 </span>            :         {
<span class="lineNum">     424 </span><span class="lineCov">     244320 :           tree one = build_int_cst (TREE_TYPE (min), 1);</span>
<span class="lineNum">     425 </span><span class="lineCov">     122160 :           max = int_const_binop (MINUS_EXPR, min, one);</span>
<span class="lineNum">     426 </span><span class="lineCov">     122160 :           min = vrp_val_min (TREE_TYPE (min));</span>
<span class="lineNum">     427 </span><span class="lineCov">     122160 :           t = VR_RANGE;</span>
<span class="lineNum">     428 </span>            :         }
<span class="lineNum">     429 </span>            :     }
<span class="lineNum">     430 </span>            : 
<span class="lineNum">     431 </span>            :   /* Do not drop [-INF(OVF), +INF(OVF)] to varying.  (OVF) has to be sticky
<span class="lineNum">     432 </span>            :      to make sure VRP iteration terminates, otherwise we can get into
<span class="lineNum">     433 </span>            :      oscillations.  */
<span class="lineNum">     434 </span>            : 
<span class="lineNum">     435 </span><span class="lineCov">   86052684 :   set_value_range (vr, t, min, max, equiv);</span>
<span class="lineNum">     436 </span>            : }
<span class="lineNum">     437 </span>            : 
<span class="lineNum">     438 </span>            : /* Copy value range FROM into value range TO.  */
<a name="439"><span class="lineNum">     439 </span>            : </a>
<span class="lineNum">     440 </span>            : void
<span class="lineNum">     441 </span><span class="lineCov">   17952949 : copy_value_range (value_range *to, const value_range *from)</span>
<span class="lineNum">     442 </span>            : {
<span class="lineNum">     443 </span><span class="lineCov">   17952949 :   set_value_range (to, from-&gt;type, from-&gt;min, from-&gt;max, from-&gt;equiv);</span>
<span class="lineNum">     444 </span><span class="lineCov">   17952949 : }</span>
<span class="lineNum">     445 </span>            : 
<span class="lineNum">     446 </span>            : /* Set value range VR to a single value.  This function is only called
<span class="lineNum">     447 </span>            :    with values we get from statements, and exists to clear the
<span class="lineNum">     448 </span>            :    TREE_OVERFLOW flag.  */
<a name="449"><span class="lineNum">     449 </span>            : </a>
<span class="lineNum">     450 </span>            : void
<span class="lineNum">     451 </span><span class="lineCov">   23959592 : set_value_range_to_value (value_range *vr, tree val, bitmap equiv)</span>
<span class="lineNum">     452 </span>            : {
<span class="lineNum">     453 </span><span class="lineCov">   23959592 :   gcc_assert (is_gimple_min_invariant (val));</span>
<span class="lineNum">     454 </span><span class="lineCov">   23959592 :   if (TREE_OVERFLOW_P (val))</span>
<span class="lineNum">     455 </span><span class="lineCov">        696 :     val = drop_tree_overflow (val);</span>
<span class="lineNum">     456 </span><span class="lineCov">   23959592 :   set_value_range (vr, VR_RANGE, val, val, equiv);</span>
<span class="lineNum">     457 </span><span class="lineCov">   23959592 : }</span>
<span class="lineNum">     458 </span>            : 
<span class="lineNum">     459 </span>            : /* Set value range VR to a non-NULL range of type TYPE.  */
<a name="460"><span class="lineNum">     460 </span>            : </a>
<span class="lineNum">     461 </span>            : void
<span class="lineNum">     462 </span><span class="lineCov">    6284207 : set_value_range_to_nonnull (value_range *vr, tree type)</span>
<span class="lineNum">     463 </span>            : {
<span class="lineNum">     464 </span><span class="lineCov">   12568414 :   tree zero = build_int_cst (type, 0);</span>
<span class="lineNum">     465 </span><span class="lineCov">    6284207 :   set_value_range (vr, VR_ANTI_RANGE, zero, zero, vr-&gt;equiv);</span>
<span class="lineNum">     466 </span><span class="lineCov">    6284207 : }</span>
<span class="lineNum">     467 </span>            : 
<span class="lineNum">     468 </span>            : 
<span class="lineNum">     469 </span>            : /* Set value range VR to a NULL range of type TYPE.  */
<a name="470"><span class="lineNum">     470 </span>            : </a>
<span class="lineNum">     471 </span>            : void
<span class="lineNum">     472 </span><span class="lineCov">       2965 : set_value_range_to_null (value_range *vr, tree type)</span>
<span class="lineNum">     473 </span>            : {
<span class="lineNum">     474 </span><span class="lineCov">       5930 :   set_value_range_to_value (vr, build_int_cst (type, 0), vr-&gt;equiv);</span>
<span class="lineNum">     475 </span><span class="lineCov">       2965 : }</span>
<span class="lineNum">     476 </span>            : 
<span class="lineNum">     477 </span>            : /* Return true, if VAL1 and VAL2 are equal values for VRP purposes.  */
<a name="478"><span class="lineNum">     478 </span>            : </a>
<span class="lineNum">     479 </span>            : bool
<span class="lineNum">     480 </span><span class="lineCov">  233028636 : vrp_operand_equal_p (const_tree val1, const_tree val2)</span>
<span class="lineNum">     481 </span>            : {
<span class="lineNum">     482 </span><span class="lineCov">  233028636 :   if (val1 == val2)</span>
<span class="lineNum">     483 </span>            :     return true;
<span class="lineNum">     484 </span><span class="lineCov">  146039613 :   if (!val1 || !val2 || !operand_equal_p (val1, val2, 0))</span>
<span class="lineNum">     485 </span><span class="lineCov">  140065281 :     return false;</span>
<span class="lineNum">     486 </span>            :   return true;
<span class="lineNum">     487 </span>            : }
<span class="lineNum">     488 </span>            : 
<span class="lineNum">     489 </span>            : /* Return true, if the bitmaps B1 and B2 are equal.  */
<a name="490"><span class="lineNum">     490 </span>            : </a>
<span class="lineNum">     491 </span>            : bool
<span class="lineNum">     492 </span><span class="lineCov">    1584068 : vrp_bitmap_equal_p (const_bitmap b1, const_bitmap b2)</span>
<span class="lineNum">     493 </span>            : {
<span class="lineNum">     494 </span><span class="lineCov">    1584068 :   return (b1 == b2</span>
<span class="lineNum">     495 </span><span class="lineCov">     639397 :           || ((!b1 || bitmap_empty_p (b1))</span>
<span class="lineNum">     496 </span><span class="lineCov">      71652 :               &amp;&amp; (!b2 || bitmap_empty_p (b2)))</span>
<span class="lineNum">     497 </span><span class="lineCov">    2156415 :           || (b1 &amp;&amp; b2</span>
<span class="lineNum">     498 </span><span class="lineCov">     538336 :               &amp;&amp; bitmap_equal_p (b1, b2)));</span>
<span class="lineNum">     499 </span>            : }
<span class="lineNum">     500 </span>            : 
<span class="lineNum">     501 </span>            : /* Return true if VR is [0, 0].  */
<a name="502"><span class="lineNum">     502 </span>            : </a>
<span class="lineNum">     503 </span>            : static inline bool
<span class="lineNum">     504 </span><span class="lineCov">    4241167 : range_is_null (const value_range *vr)</span>
<span class="lineNum">     505 </span>            : {
<span class="lineNum">     506 </span><span class="lineCov">    4241167 :   return vr-&gt;type == VR_RANGE</span>
<span class="lineNum">     507 </span><span class="lineCov">    1297219 :          &amp;&amp; integer_zerop (vr-&gt;min)</span>
<span class="lineNum">     508 </span><span class="lineCov">    4844546 :          &amp;&amp; integer_zerop (vr-&gt;max);</span>
<span class="lineNum">     509 </span>            : }
<span class="lineNum">     510 </span>            : 
<span class="lineNum">     511 </span>            : /* Return true if max and min of VR are INTEGER_CST.  It's not necessary
<span class="lineNum">     512 </span>            :    a singleton.  */
<a name="513"><span class="lineNum">     513 </span>            : </a>
<span class="lineNum">     514 </span>            : bool
<span class="lineNum">     515 </span><span class="lineCov">  356196167 : range_int_cst_p (const value_range *vr)</span>
<span class="lineNum">     516 </span>            : {
<span class="lineNum">     517 </span><span class="lineCov">  356196167 :   return (vr-&gt;type == VR_RANGE</span>
<span class="lineNum">     518 </span><span class="lineCov">  185979242 :           &amp;&amp; TREE_CODE (vr-&gt;max) == INTEGER_CST</span>
<span class="lineNum">     519 </span><span class="lineCov">  536315170 :           &amp;&amp; TREE_CODE (vr-&gt;min) == INTEGER_CST);</span>
<span class="lineNum">     520 </span>            : }
<span class="lineNum">     521 </span>            : 
<span class="lineNum">     522 </span>            : /* Return true if VR is a INTEGER_CST singleton.  */
<a name="523"><span class="lineNum">     523 </span>            : </a>
<span class="lineNum">     524 </span>            : bool
<span class="lineNum">     525 </span><span class="lineCov">  338282882 : range_int_cst_singleton_p (const value_range *vr)</span>
<span class="lineNum">     526 </span>            : {
<span class="lineNum">     527 </span><span class="lineCov">  338282882 :   return (range_int_cst_p (vr)</span>
<span class="lineNum">     528 </span><span class="lineCov">  338282882 :           &amp;&amp; tree_int_cst_equal (vr-&gt;min, vr-&gt;max));</span>
<span class="lineNum">     529 </span>            : }
<span class="lineNum">     530 </span>            : 
<span class="lineNum">     531 </span>            : /* Return true if value range VR involves at least one symbol.  */
<a name="532"><span class="lineNum">     532 </span>            : </a>
<span class="lineNum">     533 </span>            : bool
<span class="lineNum">     534 </span><span class="lineCov">   14592456 : symbolic_range_p (const value_range *vr)</span>
<span class="lineNum">     535 </span>            : {
<span class="lineNum">     536 </span><span class="lineCov">   14592456 :   return (!is_gimple_min_invariant (vr-&gt;min)</span>
<span class="lineNum">     537 </span><span class="lineCov">   14592456 :           || !is_gimple_min_invariant (vr-&gt;max));</span>
<span class="lineNum">     538 </span>            : }
<span class="lineNum">     539 </span>            : 
<span class="lineNum">     540 </span>            : /* Return the single symbol (an SSA_NAME) contained in T if any, or NULL_TREE
<span class="lineNum">     541 </span>            :    otherwise.  We only handle additive operations and set NEG to true if the
<span class="lineNum">     542 </span>            :    symbol is negated and INV to the invariant part, if any.  */
<a name="543"><span class="lineNum">     543 </span>            : </a>
<span class="lineNum">     544 </span>            : tree
<span class="lineNum">     545 </span><span class="lineCov"> 1564021091 : get_single_symbol (tree t, bool *neg, tree *inv)</span>
<span class="lineNum">     546 </span>            : {
<span class="lineNum">     547 </span><span class="lineCov"> 1564021091 :   bool neg_;</span>
<span class="lineNum">     548 </span><span class="lineCov"> 1564021091 :   tree inv_;</span>
<span class="lineNum">     549 </span>            : 
<span class="lineNum">     550 </span><span class="lineCov"> 1564021091 :   *inv = NULL_TREE;</span>
<span class="lineNum">     551 </span><span class="lineCov"> 1564021091 :   *neg = false;</span>
<span class="lineNum">     552 </span>            : 
<span class="lineNum">     553 </span><span class="lineCov"> 1564021091 :   if (TREE_CODE (t) == PLUS_EXPR</span>
<span class="lineNum">     554 </span><span class="lineCov"> 1559316080 :       || TREE_CODE (t) == POINTER_PLUS_EXPR</span>
<span class="lineNum">     555 </span><span class="lineCov"> 1559316080 :       || TREE_CODE (t) == MINUS_EXPR)</span>
<span class="lineNum">     556 </span>            :     {
<span class="lineNum">     557 </span><span class="lineCov">    4705109 :       if (is_gimple_min_invariant (TREE_OPERAND (t, 0)))</span>
<span class="lineNum">     558 </span>            :         {
<span class="lineNum">     559 </span><span class="lineCov">         16 :           neg_ = (TREE_CODE (t) == MINUS_EXPR);</span>
<span class="lineNum">     560 </span><span class="lineCov">         16 :           inv_ = TREE_OPERAND (t, 0);</span>
<span class="lineNum">     561 </span><span class="lineCov">         16 :           t = TREE_OPERAND (t, 1);</span>
<span class="lineNum">     562 </span>            :         }
<span class="lineNum">     563 </span><span class="lineCov">    4705093 :       else if (is_gimple_min_invariant (TREE_OPERAND (t, 1)))</span>
<span class="lineNum">     564 </span>            :         {
<span class="lineNum">     565 </span><span class="lineCov">    4705093 :           neg_ = false;</span>
<span class="lineNum">     566 </span><span class="lineCov">    4705093 :           inv_ = TREE_OPERAND (t, 1);</span>
<span class="lineNum">     567 </span><span class="lineCov">    4705093 :           t = TREE_OPERAND (t, 0);</span>
<span class="lineNum">     568 </span>            :         }
<span class="lineNum">     569 </span>            :       else
<span class="lineNum">     570 </span>            :         return NULL_TREE;
<span class="lineNum">     571 </span>            :     }
<span class="lineNum">     572 </span>            :   else
<span class="lineNum">     573 </span>            :     {
<span class="lineNum">     574 </span>            :       neg_ = false;
<span class="lineNum">     575 </span>            :       inv_ = NULL_TREE;
<span class="lineNum">     576 </span>            :     }
<span class="lineNum">     577 </span>            : 
<span class="lineNum">     578 </span><span class="lineCov"> 1564021091 :   if (TREE_CODE (t) == NEGATE_EXPR)</span>
<span class="lineNum">     579 </span>            :     {
<span class="lineNum">     580 </span><span class="lineCov">      37730 :       t = TREE_OPERAND (t, 0);</span>
<span class="lineNum">     581 </span><span class="lineCov">      37730 :       neg_ = !neg_;</span>
<span class="lineNum">     582 </span>            :     }
<span class="lineNum">     583 </span>            : 
<span class="lineNum">     584 </span><span class="lineCov"> 1564021091 :   if (TREE_CODE (t) != SSA_NAME)</span>
<span class="lineNum">     585 </span>            :     return NULL_TREE;
<span class="lineNum">     586 </span>            : 
<span class="lineNum">     587 </span><span class="lineCov">  648091401 :   if (inv_ &amp;&amp; TREE_OVERFLOW_P (inv_))</span>
<span class="lineNum">     588 </span><span class="lineNoCov">          0 :     inv_ = drop_tree_overflow (inv_);</span>
<span class="lineNum">     589 </span>            : 
<span class="lineNum">     590 </span><span class="lineCov">  648091401 :   *neg = neg_;</span>
<span class="lineNum">     591 </span><span class="lineCov">  648091401 :   *inv = inv_;</span>
<span class="lineNum">     592 </span><span class="lineCov">  648091401 :   return t;</span>
<span class="lineNum">     593 </span>            : }
<span class="lineNum">     594 </span>            : 
<span class="lineNum">     595 </span>            : /* The reverse operation: build a symbolic expression with TYPE
<span class="lineNum">     596 </span>            :    from symbol SYM, negated according to NEG, and invariant INV.  */
<a name="597"><span class="lineNum">     597 </span>            : </a>
<span class="lineNum">     598 </span>            : static tree
<span class="lineNum">     599 </span><span class="lineCov">     653442 : build_symbolic_expr (tree type, tree sym, bool neg, tree inv)</span>
<span class="lineNum">     600 </span>            : {
<span class="lineNum">     601 </span><span class="lineCov">     653442 :   const bool pointer_p = POINTER_TYPE_P (type);</span>
<span class="lineNum">     602 </span><span class="lineCov">     653442 :   tree t = sym;</span>
<span class="lineNum">     603 </span>            : 
<span class="lineNum">     604 </span><span class="lineCov">     653442 :   if (neg)</span>
<span class="lineNum">     605 </span><span class="lineCov">      25260 :     t = build1 (NEGATE_EXPR, type, t);</span>
<span class="lineNum">     606 </span>            : 
<span class="lineNum">     607 </span><span class="lineCov">     653442 :   if (integer_zerop (inv))</span>
<span class="lineNum">     608 </span>            :     return t;
<span class="lineNum">     609 </span>            : 
<span class="lineNum">     610 </span><span class="lineCov">    1093468 :   return build2 (pointer_p ? POINTER_PLUS_EXPR : PLUS_EXPR, type, t, inv);</span>
<span class="lineNum">     611 </span>            : }
<span class="lineNum">     612 </span>            : 
<span class="lineNum">     613 </span>            : /* Return
<span class="lineNum">     614 </span>            :    1 if VAL &lt; VAL2
<span class="lineNum">     615 </span>            :    0 if !(VAL &lt; VAL2)
<a name="616"><span class="lineNum">     616 </span>            :    -2 if those are incomparable.  */</a>
<span class="lineNum">     617 </span>            : int
<span class="lineNum">     618 </span><span class="lineCov">  132653925 : operand_less_p (tree val, tree val2)</span>
<span class="lineNum">     619 </span>            : {
<span class="lineNum">     620 </span>            :   /* LT is folded faster than GE and others.  Inline the common case.  */
<span class="lineNum">     621 </span><span class="lineCov">  132653925 :   if (TREE_CODE (val) == INTEGER_CST &amp;&amp; TREE_CODE (val2) == INTEGER_CST)</span>
<span class="lineNum">     622 </span><span class="lineCov">   93005656 :     return tree_int_cst_lt (val, val2);</span>
<span class="lineNum">     623 </span>            :   else
<span class="lineNum">     624 </span>            :     {
<span class="lineNum">     625 </span><span class="lineCov">   39648269 :       tree tcmp;</span>
<span class="lineNum">     626 </span>            : 
<span class="lineNum">     627 </span><span class="lineCov">   39648269 :       fold_defer_overflow_warnings ();</span>
<span class="lineNum">     628 </span>            : 
<span class="lineNum">     629 </span><span class="lineCov">   39648269 :       tcmp = fold_binary_to_constant (LT_EXPR, boolean_type_node, val, val2);</span>
<span class="lineNum">     630 </span>            : 
<span class="lineNum">     631 </span><span class="lineCov">   39648269 :       fold_undefer_and_ignore_overflow_warnings ();</span>
<span class="lineNum">     632 </span>            : 
<span class="lineNum">     633 </span><span class="lineCov">   39648269 :       if (!tcmp</span>
<span class="lineNum">     634 </span><span class="lineCov">   11756845 :           || TREE_CODE (tcmp) != INTEGER_CST)</span>
<span class="lineNum">     635 </span>            :         return -2;
<span class="lineNum">     636 </span>            : 
<span class="lineNum">     637 </span><span class="lineCov">   11689206 :       if (!integer_zerop (tcmp))</span>
<span class="lineNum">     638 </span><span class="lineCov">    1520665 :         return 1;</span>
<span class="lineNum">     639 </span>            :     }
<span class="lineNum">     640 </span>            : 
<span class="lineNum">     641 </span>            :   return 0;
<span class="lineNum">     642 </span>            : }
<span class="lineNum">     643 </span>            : 
<span class="lineNum">     644 </span>            : /* Compare two values VAL1 and VAL2.  Return
<span class="lineNum">     645 </span>            : 
<span class="lineNum">     646 </span>            :         -2 if VAL1 and VAL2 cannot be compared at compile-time,
<span class="lineNum">     647 </span>            :         -1 if VAL1 &lt; VAL2,
<span class="lineNum">     648 </span>            :          0 if VAL1 == VAL2,
<span class="lineNum">     649 </span>            :         +1 if VAL1 &gt; VAL2, and
<span class="lineNum">     650 </span>            :         +2 if VAL1 != VAL2
<span class="lineNum">     651 </span>            : 
<span class="lineNum">     652 </span>            :    This is similar to tree_int_cst_compare but supports pointer values
<span class="lineNum">     653 </span>            :    and values that cannot be compared at compile time.
<span class="lineNum">     654 </span>            : 
<span class="lineNum">     655 </span>            :    If STRICT_OVERFLOW_P is not NULL, then set *STRICT_OVERFLOW_P to
<span class="lineNum">     656 </span>            :    true if the return value is only valid if we assume that signed
<span class="lineNum">     657 </span>            :    overflow is undefined.  */
<span class="lineNum">     658 </span>            : 
<span class="lineNum">     659 </span>            : int
<span class="lineNum">     660 </span><span class="lineCov">  911665764 : compare_values_warnv (tree val1, tree val2, bool *strict_overflow_p)</span>
<span class="lineNum">     661 </span>            : {
<span class="lineNum">     662 </span><span class="lineCov">  911665764 :   if (val1 == val2)</span>
<span class="lineNum">     663 </span>            :     return 0;
<span class="lineNum">     664 </span>            : 
<span class="lineNum">     665 </span>            :   /* Below we rely on the fact that VAL1 and VAL2 are both pointers or
<span class="lineNum">     666 </span>            :      both integers.  */
<span class="lineNum">     667 </span><span class="lineCov">  781314621 :   gcc_assert (POINTER_TYPE_P (TREE_TYPE (val1))</span>
<span class="lineNum">     668 </span>            :               == POINTER_TYPE_P (TREE_TYPE (val2)));
<span class="lineNum">     669 </span>            : 
<span class="lineNum">     670 </span>            :   /* Convert the two values into the same type.  This is needed because
<span class="lineNum">     671 </span>            :      sizetype causes sign extension even for unsigned types.  */
<span class="lineNum">     672 </span><span class="lineCov"> 1562614840 :   val2 = fold_convert (TREE_TYPE (val1), val2);</span>
<span class="lineNum">     673 </span><span class="lineCov">  781307420 :   STRIP_USELESS_TYPE_CONVERSION (val2);</span>
<span class="lineNum">     674 </span>            : 
<span class="lineNum">     675 </span><span class="lineCov">  781307420 :   const bool overflow_undefined</span>
<span class="lineNum">     676 </span><span class="lineCov"> 2340418270 :     = INTEGRAL_TYPE_P (TREE_TYPE (val1))</span>
<span class="lineNum">     677 </span><span class="lineCov"> 2317313228 :       &amp;&amp; TYPE_OVERFLOW_UNDEFINED (TREE_TYPE (val1));</span>
<span class="lineNum">     678 </span><span class="lineCov">  781307420 :   tree inv1, inv2;</span>
<span class="lineNum">     679 </span><span class="lineCov">  781307420 :   bool neg1, neg2;</span>
<span class="lineNum">     680 </span><span class="lineCov">  781307420 :   tree sym1 = get_single_symbol (val1, &amp;neg1, &amp;inv1);</span>
<span class="lineNum">     681 </span><span class="lineCov">  781307420 :   tree sym2 = get_single_symbol (val2, &amp;neg2, &amp;inv2);</span>
<span class="lineNum">     682 </span>            : 
<span class="lineNum">     683 </span>            :   /* If VAL1 and VAL2 are of the form '[-]NAME [+ CST]', return -1 or +1
<span class="lineNum">     684 </span>            :      accordingly.  If VAL1 and VAL2 don't use the same name, return -2.  */
<span class="lineNum">     685 </span><span class="lineCov">  781307420 :   if (sym1 &amp;&amp; sym2)</span>
<span class="lineNum">     686 </span>            :     {
<span class="lineNum">     687 </span>            :       /* Both values must use the same name with the same sign.  */
<span class="lineNum">     688 </span><span class="lineCov">  155822523 :       if (sym1 != sym2 || neg1 != neg2)</span>
<span class="lineNum">     689 </span>            :         return -2;
<span class="lineNum">     690 </span>            : 
<span class="lineNum">     691 </span>            :       /* [-]NAME + CST == [-]NAME + CST.  */
<span class="lineNum">     692 </span><span class="lineCov">     356799 :       if (inv1 == inv2)</span>
<span class="lineNum">     693 </span>            :         return 0;
<span class="lineNum">     694 </span>            : 
<span class="lineNum">     695 </span>            :       /* If overflow is defined we cannot simplify more.  */
<span class="lineNum">     696 </span><span class="lineCov">     178623 :       if (!overflow_undefined)</span>
<span class="lineNum">     697 </span>            :         return -2;
<span class="lineNum">     698 </span>            : 
<span class="lineNum">     699 </span><span class="lineCov">     122926 :       if (strict_overflow_p != NULL</span>
<span class="lineNum">     700 </span>            :           /* Symbolic range building sets TREE_NO_WARNING to declare
<span class="lineNum">     701 </span>            :              that overflow doesn't happen.  */
<span class="lineNum">     702 </span><span class="lineCov">     122926 :           &amp;&amp; (!inv1 || !TREE_NO_WARNING (val1))</span>
<span class="lineNum">     703 </span><span class="lineCov">     122697 :           &amp;&amp; (!inv2 || !TREE_NO_WARNING (val2)))</span>
<span class="lineNum">     704 </span><span class="lineCov">     122640 :         *strict_overflow_p = true;</span>
<span class="lineNum">     705 </span>            : 
<span class="lineNum">     706 </span><span class="lineCov">     122926 :       if (!inv1)</span>
<span class="lineNum">     707 </span><span class="lineCov">      17180 :         inv1 = build_int_cst (TREE_TYPE (val1), 0);</span>
<span class="lineNum">     708 </span><span class="lineCov">     122926 :       if (!inv2)</span>
<span class="lineNum">     709 </span><span class="lineCov">       7464 :         inv2 = build_int_cst (TREE_TYPE (val2), 0);</span>
<span class="lineNum">     710 </span>            : 
<span class="lineNum">     711 </span><span class="lineCov">     122926 :       return wi::cmp (wi::to_wide (inv1), wi::to_wide (inv2),</span>
<span class="lineNum">     712 </span><span class="lineCov">     122926 :                       TYPE_SIGN (TREE_TYPE (val1)));</span>
<span class="lineNum">     713 </span>            :     }
<span class="lineNum">     714 </span>            : 
<span class="lineNum">     715 </span><span class="lineCov">  625484897 :   const bool cst1 = is_gimple_min_invariant (val1);</span>
<span class="lineNum">     716 </span><span class="lineCov">  625484897 :   const bool cst2 = is_gimple_min_invariant (val2);</span>
<span class="lineNum">     717 </span>            : 
<span class="lineNum">     718 </span>            :   /* If one is of the form '[-]NAME + CST' and the other is constant, then
<span class="lineNum">     719 </span>            :      it might be possible to say something depending on the constants.  */
<span class="lineNum">     720 </span><span class="lineCov">  625484897 :   if ((sym1 &amp;&amp; inv1 &amp;&amp; cst2) || (sym2 &amp;&amp; inv2 &amp;&amp; cst1))</span>
<span class="lineNum">     721 </span>            :     {
<span class="lineNum">     722 </span><span class="lineCov">    3236025 :       if (!overflow_undefined)</span>
<span class="lineNum">     723 </span>            :         return -2;
<span class="lineNum">     724 </span>            : 
<span class="lineNum">     725 </span><span class="lineCov">    1373806 :       if (strict_overflow_p != NULL</span>
<span class="lineNum">     726 </span>            :           /* Symbolic range building sets TREE_NO_WARNING to declare
<span class="lineNum">     727 </span>            :              that overflow doesn't happen.  */
<span class="lineNum">     728 </span><span class="lineCov">    1373806 :           &amp;&amp; (!sym1 || !TREE_NO_WARNING (val1))</span>
<span class="lineNum">     729 </span><span class="lineCov">     980471 :           &amp;&amp; (!sym2 || !TREE_NO_WARNING (val2)))</span>
<span class="lineNum">     730 </span><span class="lineCov">     511166 :         *strict_overflow_p = true;</span>
<span class="lineNum">     731 </span>            : 
<span class="lineNum">     732 </span><span class="lineCov">    1373806 :       const signop sgn = TYPE_SIGN (TREE_TYPE (val1));</span>
<span class="lineNum">     733 </span><span class="lineCov">    1373806 :       tree cst = cst1 ? val1 : val2;</span>
<span class="lineNum">     734 </span><span class="lineCov">    1373806 :       tree inv = cst1 ? inv2 : inv1;</span>
<span class="lineNum">     735 </span>            : 
<span class="lineNum">     736 </span>            :       /* Compute the difference between the constants.  If it overflows or
<span class="lineNum">     737 </span>            :          underflows, this means that we can trivially compare the NAME with
<span class="lineNum">     738 </span>            :          it and, consequently, the two values with each other.  */
<span class="lineNum">     739 </span><span class="lineCov">    1373806 :       wide_int diff = wi::to_wide (cst) - wi::to_wide (inv);</span>
<span class="lineNum">     740 </span><span class="lineCov">    1373806 :       if (wi::cmp (0, wi::to_wide (inv), sgn)</span>
<span class="lineNum">     741 </span><span class="lineCov">    1373806 :           != wi::cmp (diff, wi::to_wide (cst), sgn))</span>
<span class="lineNum">     742 </span>            :         {
<span class="lineNum">     743 </span><span class="lineCov">     346533 :           const int res = wi::cmp (wi::to_wide (cst), wi::to_wide (inv), sgn);</span>
<span class="lineNum">     744 </span><span class="lineCov">     346533 :           return cst1 ? res : -res;</span>
<span class="lineNum">     745 </span>            :         }
<span class="lineNum">     746 </span>            : 
<span class="lineNum">     747 </span>            :       return -2;
<span class="lineNum">     748 </span>            :     }
<span class="lineNum">     749 </span>            : 
<span class="lineNum">     750 </span>            :   /* We cannot say anything more for non-constants.  */
<span class="lineNum">     751 </span><span class="lineCov">  622248872 :   if (!cst1 || !cst2)</span>
<span class="lineNum">     752 </span>            :     return -2;
<span class="lineNum">     753 </span>            : 
<span class="lineNum">     754 </span><span class="lineCov">  290444728 :   if (!POINTER_TYPE_P (TREE_TYPE (val1)))</span>
<span class="lineNum">     755 </span>            :     {
<span class="lineNum">     756 </span>            :       /* We cannot compare overflowed values.  */
<span class="lineNum">     757 </span><span class="lineCov">  290124661 :       if (TREE_OVERFLOW (val1) || TREE_OVERFLOW (val2))</span>
<span class="lineNum">     758 </span>            :         return -2;
<span class="lineNum">     759 </span>            : 
<span class="lineNum">     760 </span><span class="lineCov">  290116170 :       if (TREE_CODE (val1) == INTEGER_CST</span>
<span class="lineNum">     761 </span><span class="lineCov">  290116170 :           &amp;&amp; TREE_CODE (val2) == INTEGER_CST)</span>
<span class="lineNum">     762 </span><span class="lineCov">  290116170 :         return tree_int_cst_compare (val1, val2);</span>
<span class="lineNum">     763 </span>            : 
<span class="lineNum">     764 </span><span class="lineNoCov">          0 :       if (poly_int_tree_p (val1) &amp;&amp; poly_int_tree_p (val2))</span>
<span class="lineNum">     765 </span>            :         {
<span class="lineNum">     766 </span><span class="lineNoCov">          0 :           if (known_eq (wi::to_poly_widest (val1),</span>
<span class="lineNum">     767 </span>            :                         wi::to_poly_widest (val2)))
<span class="lineNum">     768 </span>            :             return 0;
<span class="lineNum">     769 </span><span class="lineNoCov">          0 :           if (known_lt (wi::to_poly_widest (val1),</span>
<span class="lineNum">     770 </span>            :                         wi::to_poly_widest (val2)))
<span class="lineNum">     771 </span>            :             return -1;
<span class="lineNum">     772 </span><span class="lineNoCov">          0 :           if (known_gt (wi::to_poly_widest (val1),</span>
<span class="lineNum">     773 </span>            :                         wi::to_poly_widest (val2)))
<span class="lineNum">     774 </span>            :             return 1;
<span class="lineNum">     775 </span>            :         }
<span class="lineNum">     776 </span>            : 
<span class="lineNum">     777 </span><span class="lineNoCov">          0 :       return -2;</span>
<span class="lineNum">     778 </span>            :     }
<span class="lineNum">     779 </span>            :   else
<span class="lineNum">     780 </span>            :     {
<span class="lineNum">     781 </span><span class="lineCov">     320067 :       tree t;</span>
<span class="lineNum">     782 </span>            : 
<span class="lineNum">     783 </span>            :       /* First see if VAL1 and VAL2 are not the same.  */
<span class="lineNum">     784 </span><span class="lineCov">     320067 :       if (val1 == val2 || operand_equal_p (val1, val2, 0))</span>
<span class="lineNum">     785 </span><span class="lineCov">       7601 :         return 0;</span>
<span class="lineNum">     786 </span>            : 
<span class="lineNum">     787 </span>            :       /* If VAL1 is a lower address than VAL2, return -1.  */
<span class="lineNum">     788 </span><span class="lineCov">     312466 :       if (operand_less_p (val1, val2) == 1)</span>
<span class="lineNum">     789 </span>            :         return -1;
<span class="lineNum">     790 </span>            : 
<span class="lineNum">     791 </span>            :       /* If VAL1 is a higher address than VAL2, return +1.  */
<span class="lineNum">     792 </span><span class="lineCov">     132374 :       if (operand_less_p (val2, val1) == 1)</span>
<span class="lineNum">     793 </span>            :         return 1;
<span class="lineNum">     794 </span>            : 
<span class="lineNum">     795 </span>            :       /* If VAL1 is different than VAL2, return +2.
<span class="lineNum">     796 </span>            :          For integer constants we either have already returned -1 or 1
<span class="lineNum">     797 </span>            :          or they are equivalent.  We still might succeed in proving
<span class="lineNum">     798 </span>            :          something about non-trivial operands.  */
<span class="lineNum">     799 </span><span class="lineCov">      89702 :       if (TREE_CODE (val1) != INTEGER_CST</span>
<span class="lineNum">     800 </span><span class="lineCov">      14127 :           || TREE_CODE (val2) != INTEGER_CST)</span>
<span class="lineNum">     801 </span>            :         {
<span class="lineNum">     802 </span><span class="lineCov">      89702 :           t = fold_binary_to_constant (NE_EXPR, boolean_type_node, val1, val2);</span>
<span class="lineNum">     803 </span><span class="lineCov">      89702 :           if (t &amp;&amp; integer_onep (t))</span>
<span class="lineNum">     804 </span>            :             return 2;
<span class="lineNum">     805 </span>            :         }
<span class="lineNum">     806 </span>            : 
<span class="lineNum">     807 </span><span class="lineCov">      89677 :       return -2;</span>
<span class="lineNum">     808 </span>            :     }
<span class="lineNum">     809 </span>            : }
<span class="lineNum">     810 </span>            : 
<span class="lineNum">     811 </span>            : /* Compare values like compare_values_warnv.  */
<a name="812"><span class="lineNum">     812 </span>            : </a>
<span class="lineNum">     813 </span>            : int
<span class="lineNum">     814 </span><span class="lineCov">  236450172 : compare_values (tree val1, tree val2)</span>
<span class="lineNum">     815 </span>            : {
<span class="lineNum">     816 </span><span class="lineCov">  236450172 :   bool sop;</span>
<span class="lineNum">     817 </span><span class="lineCov">  236450172 :   return compare_values_warnv (val1, val2, &amp;sop);</span>
<span class="lineNum">     818 </span>            : }
<span class="lineNum">     819 </span>            : 
<span class="lineNum">     820 </span>            : 
<span class="lineNum">     821 </span>            : /* Return 1 if VAL is inside value range MIN &lt;= VAL &lt;= MAX,
<span class="lineNum">     822 </span>            :           0 if VAL is not inside [MIN, MAX],
<span class="lineNum">     823 </span>            :          -2 if we cannot tell either way.
<span class="lineNum">     824 </span>            : 
<span class="lineNum">     825 </span>            :    Benchmark compile/20001226-1.c compilation time after changing this
<span class="lineNum">     826 </span>            :    function.  */
<a name="827"><span class="lineNum">     827 </span>            : </a>
<span class="lineNum">     828 </span>            : int
<span class="lineNum">     829 </span><span class="lineCov">   17883556 : value_inside_range (tree val, tree min, tree max)</span>
<span class="lineNum">     830 </span>            : {
<span class="lineNum">     831 </span><span class="lineCov">   17883556 :   int cmp1, cmp2;</span>
<span class="lineNum">     832 </span>            : 
<span class="lineNum">     833 </span><span class="lineCov">   17883556 :   cmp1 = operand_less_p (val, min);</span>
<span class="lineNum">     834 </span><span class="lineCov">   17883556 :   if (cmp1 == -2)</span>
<span class="lineNum">     835 </span>            :     return -2;
<span class="lineNum">     836 </span><span class="lineCov">   14869202 :   if (cmp1 == 1)</span>
<span class="lineNum">     837 </span>            :     return 0;
<span class="lineNum">     838 </span>            : 
<span class="lineNum">     839 </span><span class="lineCov">   12862472 :   cmp2 = operand_less_p (max, val);</span>
<span class="lineNum">     840 </span><span class="lineCov">   12862472 :   if (cmp2 == -2)</span>
<span class="lineNum">     841 </span>            :     return -2;
<span class="lineNum">     842 </span>            : 
<span class="lineNum">     843 </span><span class="lineCov">   12116408 :   return !cmp2;</span>
<span class="lineNum">     844 </span>            : }
<span class="lineNum">     845 </span>            : 
<span class="lineNum">     846 </span>            : 
<span class="lineNum">     847 </span>            : /* Return true if value ranges VR0 and VR1 have a non-empty
<span class="lineNum">     848 </span>            :    intersection.
<span class="lineNum">     849 </span>            : 
<span class="lineNum">     850 </span>            :    Benchmark compile/20001226-1.c compilation time after changing this
<span class="lineNum">     851 </span>            :    function.
<span class="lineNum">     852 </span>            :    */
<span class="lineNum">     853 </span>            : 
<span class="lineNum">     854 </span>            : static inline bool
<span class="lineNum">     855 </span>            : value_ranges_intersect_p (const value_range *vr0, const value_range *vr1)
<span class="lineNum">     856 </span>            : {
<span class="lineNum">     857 </span>            :   /* The value ranges do not intersect if the maximum of the first range is
<span class="lineNum">     858 </span>            :      less than the minimum of the second range or vice versa.
<span class="lineNum">     859 </span>            :      When those relations are unknown, we can't do any better.  */
<span class="lineNum">     860 </span>            :   if (operand_less_p (vr0-&gt;max, vr1-&gt;min) != 0)
<span class="lineNum">     861 </span>            :     return false;
<span class="lineNum">     862 </span>            :   if (operand_less_p (vr1-&gt;max, vr0-&gt;min) != 0)
<span class="lineNum">     863 </span>            :     return false;
<span class="lineNum">     864 </span>            :   return true;
<span class="lineNum">     865 </span>            : }
<span class="lineNum">     866 </span>            : 
<span class="lineNum">     867 </span>            : 
<span class="lineNum">     868 </span>            : /* Return TRUE if *VR includes the value zero.  */
<a name="869"><span class="lineNum">     869 </span>            : </a>
<span class="lineNum">     870 </span>            : bool
<span class="lineNum">     871 </span><span class="lineCov">   23971177 : range_includes_zero_p (const value_range *vr)</span>
<span class="lineNum">     872 </span>            : {
<span class="lineNum">     873 </span><span class="lineCov">   23971177 :   if (vr-&gt;type == VR_VARYING)</span>
<span class="lineNum">     874 </span>            :     return true;
<span class="lineNum">     875 </span>            : 
<span class="lineNum">     876 </span>            :   /* Ughh, we don't know.  We choose not to optimize.  */
<span class="lineNum">     877 </span><span class="lineCov">   15623326 :   if (vr-&gt;type == VR_UNDEFINED)</span>
<span class="lineNum">     878 </span>            :     return true;
<span class="lineNum">     879 </span>            : 
<span class="lineNum">     880 </span><span class="lineCov">   31236510 :   tree zero = build_int_cst (TREE_TYPE (vr-&gt;min), 0);</span>
<span class="lineNum">     881 </span><span class="lineCov">   15618255 :   if (vr-&gt;type == VR_ANTI_RANGE)</span>
<span class="lineNum">     882 </span>            :     {
<span class="lineNum">     883 </span><span class="lineCov">    8623561 :       int res = value_inside_range (zero, vr-&gt;min, vr-&gt;max);</span>
<span class="lineNum">     884 </span><span class="lineCov">    8623561 :       return res == 0 || res == -2;</span>
<span class="lineNum">     885 </span>            :     }
<span class="lineNum">     886 </span><span class="lineCov">    6994694 :   return value_inside_range (zero, vr-&gt;min, vr-&gt;max) != 0;</span>
<span class="lineNum">     887 </span>            : }
<span class="lineNum">     888 </span>            : 
<span class="lineNum">     889 </span>            : /* Return true if *VR is know to only contain nonnegative values.  */
<span class="lineNum">     890 </span>            : 
<span class="lineNum">     891 </span>            : static inline bool
<span class="lineNum">     892 </span>            : value_range_nonnegative_p (const value_range *vr)
<span class="lineNum">     893 </span>            : {
<span class="lineNum">     894 </span>            :   /* Testing for VR_ANTI_RANGE is not useful here as any anti-range
<span class="lineNum">     895 </span>            :      which would return a useful value should be encoded as a 
<span class="lineNum">     896 </span>            :      VR_RANGE.  */
<span class="lineNum">     897 </span>            :   if (vr-&gt;type == VR_RANGE)
<span class="lineNum">     898 </span>            :     {
<span class="lineNum">     899 </span>            :       int result = compare_values (vr-&gt;min, integer_zero_node);
<span class="lineNum">     900 </span>            :       return (result == 0 || result == 1);
<span class="lineNum">     901 </span>            :     }
<span class="lineNum">     902 </span>            : 
<span class="lineNum">     903 </span>            :   return false;
<span class="lineNum">     904 </span>            : }
<span class="lineNum">     905 </span>            : 
<span class="lineNum">     906 </span>            : /* If *VR has a value rante that is a single constant value return that,
<span class="lineNum">     907 </span>            :    otherwise return NULL_TREE.  */
<a name="908"><span class="lineNum">     908 </span>            : </a>
<span class="lineNum">     909 </span>            : tree
<span class="lineNum">     910 </span><span class="lineCov">  152483076 : value_range_constant_singleton (const value_range *vr)</span>
<span class="lineNum">     911 </span>            : {
<span class="lineNum">     912 </span><span class="lineCov">  152483076 :   if (vr-&gt;type == VR_RANGE</span>
<span class="lineNum">     913 </span><span class="lineCov">   46003482 :       &amp;&amp; vrp_operand_equal_p (vr-&gt;min, vr-&gt;max)</span>
<span class="lineNum">     914 </span><span class="lineCov">  154883160 :       &amp;&amp; is_gimple_min_invariant (vr-&gt;min))</span>
<span class="lineNum">     915 </span><span class="lineCov">    1113073 :     return vr-&gt;min;</span>
<span class="lineNum">     916 </span>            : 
<span class="lineNum">     917 </span>            :   return NULL_TREE;
<span class="lineNum">     918 </span>            : }
<span class="lineNum">     919 </span>            : 
<span class="lineNum">     920 </span>            : /* Value range wrapper for wide_int_range_set_zero_nonzero_bits.
<span class="lineNum">     921 </span>            : 
<span class="lineNum">     922 </span>            :    Compute MAY_BE_NONZERO and MUST_BE_NONZERO bit masks for range in VR.
<span class="lineNum">     923 </span>            : 
<span class="lineNum">     924 </span>            :    Return TRUE if VR was a constant range and we were able to compute
<span class="lineNum">     925 </span>            :    the bit masks.  */
<span class="lineNum">     926 </span>            : 
<span class="lineNum">     927 </span>            : bool
<span class="lineNum">     928 </span><span class="lineCov">    8239485 : vrp_set_zero_nonzero_bits (const tree expr_type,</span>
<span class="lineNum">     929 </span>            :                            const value_range *vr,
<span class="lineNum">     930 </span>            :                            wide_int *may_be_nonzero,
<span class="lineNum">     931 </span>            :                            wide_int *must_be_nonzero)
<span class="lineNum">     932 </span>            : {
<span class="lineNum">     933 </span><span class="lineCov">    8239485 :   if (!range_int_cst_p (vr))</span>
<span class="lineNum">     934 </span>            :     {
<span class="lineNum">     935 </span><span class="lineCov">    2009101 :       *may_be_nonzero = wi::minus_one (TYPE_PRECISION (expr_type));</span>
<span class="lineNum">     936 </span><span class="lineCov">    1134587 :       *must_be_nonzero = wi::zero (TYPE_PRECISION (expr_type));</span>
<span class="lineNum">     937 </span><span class="lineCov">    1134587 :       return false;</span>
<span class="lineNum">     938 </span>            :     }
<span class="lineNum">     939 </span><span class="lineCov">    7104898 :   wide_int_range_set_zero_nonzero_bits (TYPE_SIGN (expr_type),</span>
<span class="lineNum">     940 </span><span class="lineCov">    7104898 :                                         wi::to_wide (vr-&gt;min),</span>
<span class="lineNum">     941 </span><span class="lineCov">    7104898 :                                         wi::to_wide (vr-&gt;max),</span>
<span class="lineNum">     942 </span>            :                                         *may_be_nonzero, *must_be_nonzero);
<span class="lineNum">     943 </span><span class="lineCov">    7104898 :   return true;</span>
<span class="lineNum">     944 </span>            : }
<span class="lineNum">     945 </span>            : 
<span class="lineNum">     946 </span>            : /* Create two value-ranges in *VR0 and *VR1 from the anti-range *AR
<span class="lineNum">     947 </span>            :    so that *VR0 U *VR1 == *AR.  Returns true if that is possible,
<span class="lineNum">     948 </span>            :    false otherwise.  If *AR can be represented with a single range
<span class="lineNum">     949 </span>            :    *VR1 will be VR_UNDEFINED.  */
<span class="lineNum">     950 </span>            : 
<span class="lineNum">     951 </span>            : static bool
<span class="lineNum">     952 </span><span class="lineCov">    4288152 : ranges_from_anti_range (const value_range *ar,</span>
<span class="lineNum">     953 </span>            :                         value_range *vr0, value_range *vr1)
<span class="lineNum">     954 </span>            : {
<span class="lineNum">     955 </span><span class="lineCov">    4288152 :   tree type = TREE_TYPE (ar-&gt;min);</span>
<span class="lineNum">     956 </span>            : 
<span class="lineNum">     957 </span><span class="lineCov">    4288152 :   vr0-&gt;type = VR_UNDEFINED;</span>
<span class="lineNum">     958 </span><span class="lineCov">    4288152 :   vr1-&gt;type = VR_UNDEFINED;</span>
<span class="lineNum">     959 </span>            : 
<span class="lineNum">     960 </span>            :   /* As a future improvement, we could handle ~[0, A] as: [-INF, -1] U
<span class="lineNum">     961 </span>            :      [A+1, +INF].  Not sure if this helps in practice, though.  */
<span class="lineNum">     962 </span>            : 
<span class="lineNum">     963 </span><span class="lineCov">    4288152 :   if (ar-&gt;type != VR_ANTI_RANGE</span>
<span class="lineNum">     964 </span><span class="lineCov">    4288152 :       || TREE_CODE (ar-&gt;min) != INTEGER_CST</span>
<span class="lineNum">     965 </span><span class="lineCov">    3995570 :       || TREE_CODE (ar-&gt;max) != INTEGER_CST</span>
<span class="lineNum">     966 </span><span class="lineCov">    3995570 :       || !vrp_val_min (type)</span>
<span class="lineNum">     967 </span><span class="lineCov">    6513774 :       || !vrp_val_max (type))</span>
<span class="lineNum">     968 </span><span class="lineCov">    2062530 :     return false;</span>
<span class="lineNum">     969 </span>            : 
<span class="lineNum">     970 </span><span class="lineCov">    2225622 :   if (!vrp_val_is_min (ar-&gt;min))</span>
<span class="lineNum">     971 </span>            :     {
<span class="lineNum">     972 </span><span class="lineCov">    1738373 :       vr0-&gt;type = VR_RANGE;</span>
<span class="lineNum">     973 </span><span class="lineCov">    1738373 :       vr0-&gt;min = vrp_val_min (type);</span>
<span class="lineNum">     974 </span><span class="lineCov">    1738373 :       vr0-&gt;max = wide_int_to_tree (type, wi::to_wide (ar-&gt;min) - 1);</span>
<span class="lineNum">     975 </span>            :     }
<span class="lineNum">     976 </span><span class="lineCov">    2225622 :   if (!vrp_val_is_max (ar-&gt;max))</span>
<span class="lineNum">     977 </span>            :     {
<span class="lineNum">     978 </span><span class="lineCov">    2225622 :       vr1-&gt;type = VR_RANGE;</span>
<span class="lineNum">     979 </span><span class="lineCov">    2225622 :       vr1-&gt;min = wide_int_to_tree (type, wi::to_wide (ar-&gt;max) + 1);</span>
<span class="lineNum">     980 </span><span class="lineCov">    2225622 :       vr1-&gt;max = vrp_val_max (type);</span>
<span class="lineNum">     981 </span>            :     }
<span class="lineNum">     982 </span><span class="lineCov">    2225622 :   if (vr0-&gt;type == VR_UNDEFINED)</span>
<span class="lineNum">     983 </span>            :     {
<span class="lineNum">     984 </span><span class="lineCov">     487249 :       *vr0 = *vr1;</span>
<span class="lineNum">     985 </span><span class="lineCov">     487249 :       vr1-&gt;type = VR_UNDEFINED;</span>
<span class="lineNum">     986 </span>            :     }
<span class="lineNum">     987 </span>            : 
<span class="lineNum">     988 </span><span class="lineCov">    2225622 :   return vr0-&gt;type != VR_UNDEFINED;</span>
<span class="lineNum">     989 </span>            : }
<span class="lineNum">     990 </span>            : 
<span class="lineNum">     991 </span>            : /* Extract the components of a value range into a pair of wide ints in
<span class="lineNum">     992 </span>            :    [WMIN, WMAX].
<span class="lineNum">     993 </span>            : 
<span class="lineNum">     994 </span>            :    If the value range is anything but a VR_*RANGE of constants, the
<span class="lineNum">     995 </span>            :    resulting wide ints are set to [-MIN, +MAX] for the type.  */
<span class="lineNum">     996 </span>            : 
<span class="lineNum">     997 </span>            : static void inline
<span class="lineNum">     998 </span><span class="lineCov">   20494572 : extract_range_into_wide_ints (const value_range *vr,</span>
<span class="lineNum">     999 </span>            :                               signop sign, unsigned prec,
<span class="lineNum">    1000 </span>            :                               wide_int &amp;wmin, wide_int &amp;wmax)
<span class="lineNum">    1001 </span>            : {
<span class="lineNum">    1002 </span><span class="lineCov">   40989144 :   if ((vr-&gt;type == VR_RANGE</span>
<span class="lineNum">    1003 </span><span class="lineCov">   20494572 :        || vr-&gt;type == VR_ANTI_RANGE)</span>
<span class="lineNum">    1004 </span><span class="lineCov">   14307797 :       &amp;&amp; TREE_CODE (vr-&gt;min) == INTEGER_CST</span>
<span class="lineNum">    1005 </span><span class="lineCov">   13649562 :       &amp;&amp; TREE_CODE (vr-&gt;max) == INTEGER_CST)</span>
<span class="lineNum">    1006 </span>            :     {
<span class="lineNum">    1007 </span><span class="lineCov">   13469314 :       wmin = wi::to_wide (vr-&gt;min);</span>
<span class="lineNum">    1008 </span><span class="lineCov">   13469314 :       wmax = wi::to_wide (vr-&gt;max);</span>
<span class="lineNum">    1009 </span>            :     }
<span class="lineNum">    1010 </span>            :   else
<span class="lineNum">    1011 </span>            :     {
<span class="lineNum">    1012 </span><span class="lineCov">    7025258 :       wmin = wi::min_value (prec, sign);</span>
<span class="lineNum">    1013 </span><span class="lineCov">    7025258 :       wmax = wi::max_value (prec, sign);</span>
<span class="lineNum">    1014 </span>            :     }
<span class="lineNum">    1015 </span><span class="lineCov">   20494572 : }</span>
<span class="lineNum">    1016 </span>            : 
<span class="lineNum">    1017 </span>            : /* Value range wrapper for wide_int_range_multiplicative_op:
<span class="lineNum">    1018 </span>            : 
<span class="lineNum">    1019 </span>            :      *VR = *VR0 .CODE. *VR1.  */
<span class="lineNum">    1020 </span>            : 
<span class="lineNum">    1021 </span>            : static void
<span class="lineNum">    1022 </span><span class="lineCov">    4359704 : extract_range_from_multiplicative_op (value_range *vr,</span>
<span class="lineNum">    1023 </span>            :                                       enum tree_code code,
<span class="lineNum">    1024 </span>            :                                       const value_range *vr0,
<span class="lineNum">    1025 </span>            :                                       const value_range *vr1)
<span class="lineNum">    1026 </span>            : {
<span class="lineNum">    1027 </span><span class="lineCov">    4359704 :   gcc_assert (code == MULT_EXPR</span>
<span class="lineNum">    1028 </span>            :               || code == TRUNC_DIV_EXPR
<span class="lineNum">    1029 </span>            :               || code == FLOOR_DIV_EXPR
<span class="lineNum">    1030 </span>            :               || code == CEIL_DIV_EXPR
<span class="lineNum">    1031 </span>            :               || code == EXACT_DIV_EXPR
<span class="lineNum">    1032 </span>            :               || code == ROUND_DIV_EXPR
<span class="lineNum">    1033 </span>            :               || code == RSHIFT_EXPR
<span class="lineNum">    1034 </span>            :               || code == LSHIFT_EXPR);
<span class="lineNum">    1035 </span><span class="lineCov">    4359704 :   gcc_assert (vr0-&gt;type == VR_RANGE &amp;&amp; vr0-&gt;type == vr1-&gt;type);</span>
<span class="lineNum">    1036 </span>            : 
<span class="lineNum">    1037 </span><span class="lineCov">    4359704 :   tree type = TREE_TYPE (vr0-&gt;min);</span>
<span class="lineNum">    1038 </span><span class="lineCov">    8719408 :   wide_int res_lb, res_ub;</span>
<span class="lineNum">    1039 </span><span class="lineCov">    4359704 :   wide_int vr0_lb = wi::to_wide (vr0-&gt;min);</span>
<span class="lineNum">    1040 </span><span class="lineCov">    4359704 :   wide_int vr0_ub = wi::to_wide (vr0-&gt;max);</span>
<span class="lineNum">    1041 </span><span class="lineCov">    4359704 :   wide_int vr1_lb = wi::to_wide (vr1-&gt;min);</span>
<span class="lineNum">    1042 </span><span class="lineCov">    4359704 :   wide_int vr1_ub = wi::to_wide (vr1-&gt;max);</span>
<span class="lineNum">    1043 </span><span class="lineCov">    4359704 :   bool overflow_undefined = TYPE_OVERFLOW_UNDEFINED (type);</span>
<span class="lineNum">    1044 </span><span class="lineCov">    4359704 :   bool overflow_wraps = TYPE_OVERFLOW_WRAPS (type);</span>
<span class="lineNum">    1045 </span><span class="lineCov">    4359704 :   unsigned prec = TYPE_PRECISION (type);</span>
<span class="lineNum">    1046 </span>            : 
<span class="lineNum">    1047 </span><span class="lineCov">    4359704 :   if (wide_int_range_multiplicative_op (res_lb, res_ub,</span>
<span class="lineNum">    1048 </span><span class="lineCov">    8719408 :                                          code, TYPE_SIGN (type), prec,</span>
<span class="lineNum">    1049 </span>            :                                          vr0_lb, vr0_ub, vr1_lb, vr1_ub,
<span class="lineNum">    1050 </span>            :                                          overflow_undefined, overflow_wraps))
<span class="lineNum">    1051 </span><span class="lineCov">    6392086 :     set_and_canonicalize_value_range (vr, VR_RANGE,</span>
<span class="lineNum">    1052 </span>            :                                       wide_int_to_tree (type, res_lb),
<span class="lineNum">    1053 </span>            :                                       wide_int_to_tree (type, res_ub), NULL);
<span class="lineNum">    1054 </span>            :   else
<span class="lineNum">    1055 </span><span class="lineCov">    1163661 :     set_value_range_to_varying (vr);</span>
<span class="lineNum">    1056 </span><span class="lineCov">    4359704 : }</span>
<span class="lineNum">    1057 </span>            : 
<span class="lineNum">    1058 </span>            : /* If BOUND will include a symbolic bound, adjust it accordingly,
<span class="lineNum">    1059 </span>            :    otherwise leave it as is.
<span class="lineNum">    1060 </span>            : 
<span class="lineNum">    1061 </span>            :    CODE is the original operation that combined the bounds (PLUS_EXPR
<span class="lineNum">    1062 </span>            :    or MINUS_EXPR).
<span class="lineNum">    1063 </span>            : 
<span class="lineNum">    1064 </span>            :    TYPE is the type of the original operation.
<span class="lineNum">    1065 </span>            : 
<span class="lineNum">    1066 </span>            :    SYM_OPn is the symbolic for OPn if it has a symbolic.
<span class="lineNum">    1067 </span>            : 
<span class="lineNum">    1068 </span>            :    NEG_OPn is TRUE if the OPn was negated.  */
<a name="1069"><span class="lineNum">    1069 </span>            : </a>
<span class="lineNum">    1070 </span>            : static void
<span class="lineNum">    1071 </span><span class="lineCov">   17842644 : adjust_symbolic_bound (tree &amp;bound, enum tree_code code, tree type,</span>
<span class="lineNum">    1072 </span>            :                        tree sym_op0, tree sym_op1,
<span class="lineNum">    1073 </span>            :                        bool neg_op0, bool neg_op1)
<span class="lineNum">    1074 </span>            : {
<span class="lineNum">    1075 </span><span class="lineCov">   17842644 :   bool minus_p = (code == MINUS_EXPR);</span>
<span class="lineNum">    1076 </span>            :   /* If the result bound is constant, we're done; otherwise, build the
<span class="lineNum">    1077 </span>            :      symbolic lower bound.  */
<span class="lineNum">    1078 </span><span class="lineCov">   17842644 :   if (sym_op0 == sym_op1)</span>
<span class="lineNum">    1079 </span>            :     ;
<span class="lineNum">    1080 </span><span class="lineCov">     689117 :   else if (sym_op0)</span>
<span class="lineNum">    1081 </span><span class="lineCov">     532011 :     bound = build_symbolic_expr (type, sym_op0,</span>
<span class="lineNum">    1082 </span>            :                                  neg_op0, bound);
<span class="lineNum">    1083 </span><span class="lineCov">     157106 :   else if (sym_op1)</span>
<span class="lineNum">    1084 </span>            :     {
<span class="lineNum">    1085 </span>            :       /* We may not negate if that might introduce
<span class="lineNum">    1086 </span>            :          undefined overflow.  */
<span class="lineNum">    1087 </span><span class="lineCov">     157106 :       if (!minus_p</span>
<span class="lineNum">    1088 </span><span class="lineCov">     157106 :           || neg_op1</span>
<span class="lineNum">    1089 </span><span class="lineCov">     157106 :           || TYPE_OVERFLOW_WRAPS (type))</span>
<span class="lineNum">    1090 </span><span class="lineCov">     121431 :         bound = build_symbolic_expr (type, sym_op1,</span>
<span class="lineNum">    1091 </span>            :                                      neg_op1 ^ minus_p, bound);
<span class="lineNum">    1092 </span>            :       else
<span class="lineNum">    1093 </span><span class="lineCov">      35675 :         bound = NULL_TREE;</span>
<span class="lineNum">    1094 </span>            :     }
<span class="lineNum">    1095 </span><span class="lineCov">   17842644 : }</span>
<span class="lineNum">    1096 </span>            : 
<span class="lineNum">    1097 </span>            : /* Combine OP1 and OP1, which are two parts of a bound, into one wide
<span class="lineNum">    1098 </span>            :    int bound according to CODE.  CODE is the operation combining the
<span class="lineNum">    1099 </span>            :    bound (either a PLUS_EXPR or a MINUS_EXPR).
<span class="lineNum">    1100 </span>            : 
<span class="lineNum">    1101 </span>            :    TYPE is the type of the combine operation.
<span class="lineNum">    1102 </span>            : 
<span class="lineNum">    1103 </span>            :    WI is the wide int to store the result.
<span class="lineNum">    1104 </span>            : 
<span class="lineNum">    1105 </span>            :    OVF is -1 if an underflow occurred, +1 if an overflow occurred or 0
<span class="lineNum">    1106 </span>            :    if over/underflow occurred.  */
<span class="lineNum">    1107 </span>            : 
<span class="lineNum">    1108 </span>            : static void
<span class="lineNum">    1109 </span><span class="lineCov">   27220330 : combine_bound (enum tree_code code, wide_int &amp;wi, wi::overflow_type &amp;ovf,</span>
<span class="lineNum">    1110 </span>            :                tree type, tree op0, tree op1)
<span class="lineNum">    1111 </span>            : {
<span class="lineNum">    1112 </span><span class="lineCov">   27220330 :   bool minus_p = (code == MINUS_EXPR);</span>
<span class="lineNum">    1113 </span><span class="lineCov">   27220330 :   const signop sgn = TYPE_SIGN (type);</span>
<span class="lineNum">    1114 </span><span class="lineCov">   27220330 :   const unsigned int prec = TYPE_PRECISION (type);</span>
<span class="lineNum">    1115 </span>            : 
<span class="lineNum">    1116 </span>            :   /* Combine the bounds, if any.  */
<span class="lineNum">    1117 </span><span class="lineCov">   27220330 :   if (op0 &amp;&amp; op1)</span>
<span class="lineNum">    1118 </span>            :     {
<span class="lineNum">    1119 </span><span class="lineCov">   26556157 :       if (minus_p)</span>
<span class="lineNum">    1120 </span><span class="lineCov">    4288157 :         wi = wi::sub (wi::to_wide (op0), wi::to_wide (op1), sgn, &amp;ovf);</span>
<span class="lineNum">    1121 </span>            :       else
<span class="lineNum">    1122 </span><span class="lineCov">   22268000 :         wi = wi::add (wi::to_wide (op0), wi::to_wide (op1), sgn, &amp;ovf);</span>
<span class="lineNum">    1123 </span>            :     }
<span class="lineNum">    1124 </span><span class="lineCov">     664173 :   else if (op0)</span>
<span class="lineNum">    1125 </span><span class="lineCov">     193910 :     wi = wi::to_wide (op0);</span>
<span class="lineNum">    1126 </span><span class="lineCov">     470263 :   else if (op1)</span>
<span class="lineNum">    1127 </span>            :     {
<span class="lineNum">    1128 </span><span class="lineCov">     413953 :       if (minus_p)</span>
<span class="lineNum">    1129 </span><span class="lineCov">     103050 :         wi = wi::neg (wi::to_wide (op1), &amp;ovf);</span>
<span class="lineNum">    1130 </span>            :       else
<span class="lineNum">    1131 </span><span class="lineCov">     310903 :         wi = wi::to_wide (op1);</span>
<span class="lineNum">    1132 </span>            :     }
<span class="lineNum">    1133 </span>            :   else
<span class="lineNum">    1134 </span><span class="lineCov">     112620 :     wi = wi::shwi (0, prec);</span>
<span class="lineNum">    1135 </span><span class="lineCov">   27220330 : }</span>
<span class="lineNum">    1136 </span>            : 
<span class="lineNum">    1137 </span>            : /* Given a range in [WMIN, WMAX], adjust it for possible overflow and
<span class="lineNum">    1138 </span>            :    put the result in VR.
<span class="lineNum">    1139 </span>            : 
<span class="lineNum">    1140 </span>            :    TYPE is the type of the range.
<span class="lineNum">    1141 </span>            : 
<span class="lineNum">    1142 </span>            :    MIN_OVF and MAX_OVF indicate what type of overflow, if any,
<span class="lineNum">    1143 </span>            :    occurred while originally calculating WMIN or WMAX.  -1 indicates
<span class="lineNum">    1144 </span>            :    underflow.  +1 indicates overflow.  0 indicates neither.  */
<span class="lineNum">    1145 </span>            : 
<span class="lineNum">    1146 </span>            : static void
<span class="lineNum">    1147 </span><span class="lineCov">   13529717 : set_value_range_with_overflow (value_range &amp;vr,</span>
<span class="lineNum">    1148 </span>            :                                tree type,
<span class="lineNum">    1149 </span>            :                                const wide_int &amp;wmin, const wide_int &amp;wmax,
<span class="lineNum">    1150 </span>            :                                wi::overflow_type min_ovf,
<span class="lineNum">    1151 </span>            :                                wi::overflow_type max_ovf)
<span class="lineNum">    1152 </span>            : {
<span class="lineNum">    1153 </span><span class="lineCov">   13529717 :   const signop sgn = TYPE_SIGN (type);</span>
<span class="lineNum">    1154 </span><span class="lineCov">   13529717 :   const unsigned int prec = TYPE_PRECISION (type);</span>
<span class="lineNum">    1155 </span><span class="lineCov">   13529717 :   vr.type = VR_RANGE;</span>
<span class="lineNum">    1156 </span><span class="lineCov">   13529717 :   vr.equiv = NULL;</span>
<span class="lineNum">    1157 </span><span class="lineCov">   13529717 :   if (TYPE_OVERFLOW_WRAPS (type))</span>
<span class="lineNum">    1158 </span>            :     {
<span class="lineNum">    1159 </span>            :       /* If overflow wraps, truncate the values and adjust the
<span class="lineNum">    1160 </span>            :          range kind and bounds appropriately.  */
<span class="lineNum">    1161 </span><span class="lineCov">   15550728 :       wide_int tmin = wide_int::from (wmin, prec, sgn);</span>
<span class="lineNum">    1162 </span><span class="lineCov">   15550728 :       wide_int tmax = wide_int::from (wmax, prec, sgn);</span>
<span class="lineNum">    1163 </span><span class="lineCov">    7775364 :       if ((min_ovf != wi::OVF_NONE) == (max_ovf != wi::OVF_NONE))</span>
<span class="lineNum">    1164 </span>            :         {
<span class="lineNum">    1165 </span>            :           /* No overflow or both overflow or underflow.  The
<span class="lineNum">    1166 </span>            :              range kind stays VR_RANGE.  */
<span class="lineNum">    1167 </span><span class="lineCov">    4861278 :           vr.min = wide_int_to_tree (type, tmin);</span>
<span class="lineNum">    1168 </span><span class="lineCov">    4861278 :           vr.max = wide_int_to_tree (type, tmax);</span>
<span class="lineNum">    1169 </span>            :         }
<span class="lineNum">    1170 </span><span class="lineCov">    5344725 :       else if ((min_ovf == wi::OVF_UNDERFLOW &amp;&amp; max_ovf == wi::OVF_NONE)</span>
<span class="lineNum">    1171 </span><span class="lineCov">    4469736 :                || (max_ovf == wi::OVF_OVERFLOW &amp;&amp; min_ovf == wi::OVF_NONE))</span>
<span class="lineNum">    1172 </span>            :         {
<span class="lineNum">    1173 </span>            :           /* Min underflow or max overflow.  The range kind
<span class="lineNum">    1174 </span>            :              changes to VR_ANTI_RANGE.  */
<span class="lineNum">    1175 </span><span class="lineCov">    5344678 :           bool covers = false;</span>
<span class="lineNum">    1176 </span><span class="lineCov">    5344678 :           wide_int tem = tmin;</span>
<span class="lineNum">    1177 </span><span class="lineCov">    5344678 :           vr.type = VR_ANTI_RANGE;</span>
<span class="lineNum">    1178 </span><span class="lineCov">    5344678 :           tmin = tmax + 1;</span>
<span class="lineNum">    1179 </span><span class="lineCov">    5344678 :           if (wi::cmp (tmin, tmax, sgn) &lt; 0)</span>
<span class="lineNum">    1180 </span><span class="lineCov">     303057 :             covers = true;</span>
<span class="lineNum">    1181 </span><span class="lineCov">    5344678 :           tmax = tem - 1;</span>
<span class="lineNum">    1182 </span><span class="lineCov">    5344678 :           if (wi::cmp (tmax, tem, sgn) &gt; 0)</span>
<span class="lineNum">    1183 </span>            :             covers = true;
<span class="lineNum">    1184 </span>            :           /* If the anti-range would cover nothing, drop to varying.
<span class="lineNum">    1185 </span>            :              Likewise if the anti-range bounds are outside of the
<span class="lineNum">    1186 </span>            :              types values.  */
<span class="lineNum">    1187 </span><span class="lineCov">    4284163 :           if (covers || wi::cmp (tmin, tmax, sgn) &gt; 0)</span>
<span class="lineNum">    1188 </span>            :             {
<span class="lineNum">    1189 </span><span class="lineCov">    4608348 :               set_value_range_to_varying (&amp;vr);</span>
<span class="lineNum">    1190 </span><span class="lineCov">    4608348 :               return;</span>
<span class="lineNum">    1191 </span>            :             }
<span class="lineNum">    1192 </span><span class="lineCov">    1472660 :           vr.min = wide_int_to_tree (type, tmin);</span>
<span class="lineNum">    1193 </span><span class="lineCov">    1472660 :           vr.max = wide_int_to_tree (type, tmax);</span>
<span class="lineNum">    1194 </span>            :         }
<span class="lineNum">    1195 </span>            :       else
<span class="lineNum">    1196 </span>            :         {
<span class="lineNum">    1197 </span>            :           /* Other underflow and/or overflow, drop to VR_VARYING.  */
<span class="lineNum">    1198 </span><span class="lineCov">         47 :           set_value_range_to_varying (&amp;vr);</span>
<span class="lineNum">    1199 </span><span class="lineCov">         47 :           return;</span>
<span class="lineNum">    1200 </span>            :         }
<span class="lineNum">    1201 </span>            :     }
<span class="lineNum">    1202 </span>            :   else
<span class="lineNum">    1203 </span>            :     {
<span class="lineNum">    1204 </span>            :       /* If overflow does not wrap, saturate to the types min/max
<span class="lineNum">    1205 </span>            :          value.  */
<span class="lineNum">    1206 </span><span class="lineCov">    5754353 :       wide_int type_min = wi::min_value (prec, sgn);</span>
<span class="lineNum">    1207 </span><span class="lineCov">    5754353 :       wide_int type_max = wi::max_value (prec, sgn);</span>
<span class="lineNum">    1208 </span><span class="lineCov">    5754353 :       if (min_ovf == wi::OVF_UNDERFLOW)</span>
<span class="lineNum">    1209 </span><span class="lineCov">    2652902 :         vr.min = wide_int_to_tree (type, type_min);</span>
<span class="lineNum">    1210 </span><span class="lineCov">    4427902 :       else if (min_ovf == wi::OVF_OVERFLOW)</span>
<span class="lineNum">    1211 </span><span class="lineCov">        146 :         vr.min = wide_int_to_tree (type, type_max);</span>
<span class="lineNum">    1212 </span>            :       else
<span class="lineNum">    1213 </span><span class="lineCov">    8855658 :         vr.min = wide_int_to_tree (type, wmin);</span>
<span class="lineNum">    1214 </span>            : 
<span class="lineNum">    1215 </span><span class="lineCov">    5754353 :       if (max_ovf == wi::OVF_UNDERFLOW)</span>
<span class="lineNum">    1216 </span><span class="lineCov">        678 :         vr.max = wide_int_to_tree (type, type_min);</span>
<span class="lineNum">    1217 </span><span class="lineCov">    5754014 :       else if (max_ovf == wi::OVF_OVERFLOW)</span>
<span class="lineNum">    1218 </span><span class="lineCov">    5308908 :         vr.max = wide_int_to_tree (type, type_max);</span>
<span class="lineNum">    1219 </span>            :       else
<span class="lineNum">    1220 </span><span class="lineCov">    6199120 :         vr.max = wide_int_to_tree (type, wmax);</span>
<span class="lineNum">    1221 </span>            :     }
<span class="lineNum">    1222 </span>            : }
<span class="lineNum">    1223 </span>            : 
<span class="lineNum">    1224 </span>            : /* Extract range information from a binary operation CODE based on
<span class="lineNum">    1225 </span>            :    the ranges of each of its operands *VR0 and *VR1 with resulting
<span class="lineNum">    1226 </span>            :    type EXPR_TYPE.  The resulting range is stored in *VR.  */
<span class="lineNum">    1227 </span>            : 
<span class="lineNum">    1228 </span>            : void
<span class="lineNum">    1229 </span><span class="lineCov">   30824487 : extract_range_from_binary_expr_1 (value_range *vr,</span>
<span class="lineNum">    1230 </span>            :                                   enum tree_code code, tree expr_type,
<span class="lineNum">    1231 </span>            :                                   const value_range *vr0_,
<span class="lineNum">    1232 </span>            :                                   const value_range *vr1_)
<span class="lineNum">    1233 </span>            : {
<span class="lineNum">    1234 </span><span class="lineCov">   30824487 :   signop sign = TYPE_SIGN (expr_type);</span>
<span class="lineNum">    1235 </span><span class="lineCov">   30824487 :   unsigned int prec = TYPE_PRECISION (expr_type);</span>
<span class="lineNum">    1236 </span><span class="lineCov">   30824487 :   value_range vr0 = *vr0_, vr1 = *vr1_;</span>
<span class="lineNum">    1237 </span><span class="lineCov">   30824487 :   value_range vrtem0 = VR_INITIALIZER, vrtem1 = VR_INITIALIZER;</span>
<span class="lineNum">    1238 </span><span class="lineCov">   30824487 :   enum value_range_type type;</span>
<span class="lineNum">    1239 </span><span class="lineCov">   30824487 :   tree min = NULL_TREE, max = NULL_TREE;</span>
<span class="lineNum">    1240 </span><span class="lineCov">   30824487 :   int cmp;</span>
<span class="lineNum">    1241 </span>            : 
<span class="lineNum">    1242 </span><span class="lineCov">   30824487 :   if (!INTEGRAL_TYPE_P (expr_type)</span>
<span class="lineNum">    1243 </span><span class="lineCov">    4697055 :       &amp;&amp; !POINTER_TYPE_P (expr_type))</span>
<span class="lineNum">    1244 </span>            :     {
<span class="lineNum">    1245 </span><span class="lineNoCov">          0 :       set_value_range_to_varying (vr);</span>
<span class="lineNum">    1246 </span><span class="lineCov">   23154432 :       return;</span>
<span class="lineNum">    1247 </span>            :     }
<span class="lineNum">    1248 </span>            : 
<span class="lineNum">    1249 </span>            :   /* Not all binary expressions can be applied to ranges in a
<span class="lineNum">    1250 </span>            :      meaningful way.  Handle only arithmetic operations.  */
<span class="lineNum">    1251 </span><span class="lineCov">   61648974 :   if (code != PLUS_EXPR</span>
<span class="lineNum">    1252 </span><span class="lineCov">   30824487 :       &amp;&amp; code != MINUS_EXPR</span>
<span class="lineNum">    1253 </span><span class="lineCov">   30824487 :       &amp;&amp; code != POINTER_PLUS_EXPR</span>
<span class="lineNum">    1254 </span><span class="lineCov">   11602608 :       &amp;&amp; code != MULT_EXPR</span>
<span class="lineNum">    1255 </span><span class="lineCov">   11602608 :       &amp;&amp; code != TRUNC_DIV_EXPR</span>
<span class="lineNum">    1256 </span>            :       &amp;&amp; code != FLOOR_DIV_EXPR
<span class="lineNum">    1257 </span><span class="lineCov">    6725530 :       &amp;&amp; code != CEIL_DIV_EXPR</span>
<span class="lineNum">    1258 </span><span class="lineCov">    6723062 :       &amp;&amp; code != EXACT_DIV_EXPR</span>
<span class="lineNum">    1259 </span><span class="lineCov">    6723062 :       &amp;&amp; code != ROUND_DIV_EXPR</span>
<span class="lineNum">    1260 </span><span class="lineCov">    6457058 :       &amp;&amp; code != TRUNC_MOD_EXPR</span>
<span class="lineNum">    1261 </span><span class="lineCov">    6457058 :       &amp;&amp; code != RSHIFT_EXPR</span>
<span class="lineNum">    1262 </span><span class="lineCov">    4948979 :       &amp;&amp; code != LSHIFT_EXPR</span>
<span class="lineNum">    1263 </span><span class="lineCov">    4948979 :       &amp;&amp; code != MIN_EXPR</span>
<span class="lineNum">    1264 </span><span class="lineCov">    4367644 :       &amp;&amp; code != MAX_EXPR</span>
<span class="lineNum">    1265 </span><span class="lineCov">    4367644 :       &amp;&amp; code != BIT_AND_EXPR</span>
<span class="lineNum">    1266 </span>            :       &amp;&amp; code != BIT_IOR_EXPR
<span class="lineNum">    1267 </span><span class="lineCov">    2151804 :       &amp;&amp; code != BIT_XOR_EXPR)</span>
<span class="lineNum">    1268 </span>            :     {
<span class="lineNum">    1269 </span><span class="lineCov">     465271 :       set_value_range_to_varying (vr);</span>
<span class="lineNum">    1270 </span><span class="lineCov">     465271 :       return;</span>
<span class="lineNum">    1271 </span>            :     }
<span class="lineNum">    1272 </span>            : 
<span class="lineNum">    1273 </span>            :   /* If both ranges are UNDEFINED, so is the result.  */
<span class="lineNum">    1274 </span><span class="lineCov">   30359216 :   if (vr0.type == VR_UNDEFINED &amp;&amp; vr1.type == VR_UNDEFINED)</span>
<span class="lineNum">    1275 </span>            :     {
<span class="lineNum">    1276 </span><span class="lineCov">       3720 :       set_value_range_to_undefined (vr);</span>
<span class="lineNum">    1277 </span><span class="lineCov">       3720 :       return;</span>
<span class="lineNum">    1278 </span>            :     }
<span class="lineNum">    1279 </span>            :   /* If one of the ranges is UNDEFINED drop it to VARYING for the following
<span class="lineNum">    1280 </span>            :      code.  At some point we may want to special-case operations that
<span class="lineNum">    1281 </span>            :      have UNDEFINED result for all or some value-ranges of the not UNDEFINED
<span class="lineNum">    1282 </span>            :      operand.  */
<span class="lineNum">    1283 </span><span class="lineCov">   30355496 :   else if (vr0.type == VR_UNDEFINED)</span>
<span class="lineNum">    1284 </span><span class="lineCov">      20584 :     set_value_range_to_varying (&amp;vr0);</span>
<span class="lineNum">    1285 </span><span class="lineCov">   30334912 :   else if (vr1.type == VR_UNDEFINED)</span>
<span class="lineNum">    1286 </span><span class="lineCov">       8888 :     set_value_range_to_varying (&amp;vr1);</span>
<span class="lineNum">    1287 </span>            : 
<span class="lineNum">    1288 </span>            :   /* We get imprecise results from ranges_from_anti_range when
<span class="lineNum">    1289 </span>            :      code is EXACT_DIV_EXPR.  We could mask out bits in the resulting
<span class="lineNum">    1290 </span>            :      range, but then we also need to hack up vrp_meet.  It's just
<span class="lineNum">    1291 </span>            :      easier to special case when vr0 is ~[0,0] for EXACT_DIV_EXPR.  */
<span class="lineNum">    1292 </span><span class="lineCov">   30355496 :   if (code == EXACT_DIV_EXPR</span>
<span class="lineNum">    1293 </span><span class="lineCov">     266004 :       &amp;&amp; vr0.type == VR_ANTI_RANGE</span>
<span class="lineNum">    1294 </span><span class="lineCov">       7752 :       &amp;&amp; vr0.min == vr0.max</span>
<span class="lineNum">    1295 </span><span class="lineCov">   30362450 :       &amp;&amp; integer_zerop (vr0.min))</span>
<span class="lineNum">    1296 </span>            :     {
<span class="lineNum">    1297 </span><span class="lineCov">       6904 :       set_value_range_to_nonnull (vr, expr_type);</span>
<span class="lineNum">    1298 </span><span class="lineCov">       6904 :       return;</span>
<span class="lineNum">    1299 </span>            :     }
<span class="lineNum">    1300 </span>            : 
<span class="lineNum">    1301 </span>            :   /* Now canonicalize anti-ranges to ranges when they are not symbolic
<span class="lineNum">    1302 </span>            :      and express ~[] op X as ([]' op X) U ([]'' op X).  */
<span class="lineNum">    1303 </span><span class="lineCov">   30348592 :   if (vr0.type == VR_ANTI_RANGE</span>
<span class="lineNum">    1304 </span><span class="lineCov">   30348592 :       &amp;&amp; ranges_from_anti_range (&amp;vr0, &amp;vrtem0, &amp;vrtem1))</span>
<span class="lineNum">    1305 </span>            :     {
<span class="lineNum">    1306 </span><span class="lineCov">    1308894 :       extract_range_from_binary_expr_1 (vr, code, expr_type, &amp;vrtem0, vr1_);</span>
<span class="lineNum">    1307 </span><span class="lineCov">    1308894 :       if (vrtem1.type != VR_UNDEFINED)</span>
<span class="lineNum">    1308 </span>            :         {
<span class="lineNum">    1309 </span><span class="lineCov">     981252 :           value_range vrres = VR_INITIALIZER;</span>
<span class="lineNum">    1310 </span><span class="lineCov">     981252 :           extract_range_from_binary_expr_1 (&amp;vrres, code, expr_type,</span>
<span class="lineNum">    1311 </span>            :                                             &amp;vrtem1, vr1_);
<span class="lineNum">    1312 </span><span class="lineCov">     981252 :           vrp_meet (vr, &amp;vrres);</span>
<span class="lineNum">    1313 </span>            :         }
<span class="lineNum">    1314 </span><span class="lineCov">    1308894 :       return;</span>
<span class="lineNum">    1315 </span>            :     }
<span class="lineNum">    1316 </span>            :   /* Likewise for X op ~[].  */
<span class="lineNum">    1317 </span><span class="lineCov">   29039698 :   if (vr1.type == VR_ANTI_RANGE</span>
<span class="lineNum">    1318 </span><span class="lineCov">   29039698 :       &amp;&amp; ranges_from_anti_range (&amp;vr1, &amp;vrtem0, &amp;vrtem1))</span>
<span class="lineNum">    1319 </span>            :     {
<span class="lineNum">    1320 </span><span class="lineCov">     453277 :       extract_range_from_binary_expr_1 (vr, code, expr_type, vr0_, &amp;vrtem0);</span>
<span class="lineNum">    1321 </span><span class="lineCov">     453277 :       if (vrtem1.type != VR_UNDEFINED)</span>
<span class="lineNum">    1322 </span>            :         {
<span class="lineNum">    1323 </span><span class="lineCov">     361371 :           value_range vrres = VR_INITIALIZER;</span>
<span class="lineNum">    1324 </span><span class="lineCov">     361371 :           extract_range_from_binary_expr_1 (&amp;vrres, code, expr_type,</span>
<span class="lineNum">    1325 </span>            :                                             vr0_, &amp;vrtem1);
<span class="lineNum">    1326 </span><span class="lineCov">     361371 :           vrp_meet (vr, &amp;vrres);</span>
<span class="lineNum">    1327 </span>            :         }
<span class="lineNum">    1328 </span><span class="lineCov">     453277 :       return;</span>
<span class="lineNum">    1329 </span>            :     }
<span class="lineNum">    1330 </span>            : 
<span class="lineNum">    1331 </span>            :   /* The type of the resulting value range defaults to VR0.TYPE.  */
<span class="lineNum">    1332 </span><span class="lineCov">   28586421 :   type = vr0.type;</span>
<span class="lineNum">    1333 </span>            : 
<span class="lineNum">    1334 </span>            :   /* Refuse to operate on VARYING ranges, ranges of different kinds
<span class="lineNum">    1335 </span>            :      and symbolic ranges.  As an exception, we allow BIT_{AND,IOR}
<span class="lineNum">    1336 </span>            :      because we may be able to derive a useful range even if one of
<span class="lineNum">    1337 </span>            :      the operands is VR_VARYING or symbolic range.  Similarly for
<span class="lineNum">    1338 </span>            :      divisions, MIN/MAX and PLUS/MINUS.
<span class="lineNum">    1339 </span>            : 
<span class="lineNum">    1340 </span>            :      TODO, we may be able to derive anti-ranges in some cases.  */
<span class="lineNum">    1341 </span><span class="lineCov">   28586421 :   if (code != BIT_AND_EXPR</span>
<span class="lineNum">    1342 </span><span class="lineCov">   28586421 :       &amp;&amp; code != BIT_IOR_EXPR</span>
<span class="lineNum">    1343 </span><span class="lineCov">   25161243 :       &amp;&amp; code != TRUNC_DIV_EXPR</span>
<span class="lineNum">    1344 </span><span class="lineCov">   25161243 :       &amp;&amp; code != FLOOR_DIV_EXPR</span>
<span class="lineNum">    1345 </span><span class="lineCov">   24874844 :       &amp;&amp; code != CEIL_DIV_EXPR</span>
<span class="lineNum">    1346 </span><span class="lineCov">   24874844 :       &amp;&amp; code != EXACT_DIV_EXPR</span>
<span class="lineNum">    1347 </span>            :       &amp;&amp; code != ROUND_DIV_EXPR
<span class="lineNum">    1348 </span><span class="lineCov">   24616575 :       &amp;&amp; code != TRUNC_MOD_EXPR</span>
<span class="lineNum">    1349 </span>            :       &amp;&amp; code != MIN_EXPR
<span class="lineNum">    1350 </span><span class="lineCov">   24342011 :       &amp;&amp; code != MAX_EXPR</span>
<span class="lineNum">    1351 </span>            :       &amp;&amp; code != PLUS_EXPR
<span class="lineNum">    1352 </span><span class="lineCov">   23994518 :       &amp;&amp; code != MINUS_EXPR</span>
<span class="lineNum">    1353 </span><span class="lineCov">   10248805 :       &amp;&amp; code != RSHIFT_EXPR</span>
<span class="lineNum">    1354 </span><span class="lineCov">   10248805 :       &amp;&amp; code != POINTER_PLUS_EXPR</span>
<span class="lineNum">    1355 </span><span class="lineCov">   33176336 :       &amp;&amp; (vr0.type == VR_VARYING</span>
<span class="lineNum">    1356 </span><span class="lineCov">    3954180 :           || vr1.type == VR_VARYING</span>
<span class="lineNum">    1357 </span><span class="lineCov">    3855991 :           || vr0.type != vr1.type</span>
<span class="lineNum">    1358 </span><span class="lineCov">    3848230 :           || symbolic_range_p (&amp;vr0)</span>
<span class="lineNum">    1359 </span><span class="lineCov">    3777277 :           || symbolic_range_p (&amp;vr1)))</span>
<span class="lineNum">    1360 </span>            :     {
<span class="lineNum">    1361 </span><span class="lineCov">     852702 :       set_value_range_to_varying (vr);</span>
<span class="lineNum">    1362 </span><span class="lineCov">     852702 :       return;</span>
<span class="lineNum">    1363 </span>            :     }
<span class="lineNum">    1364 </span>            : 
<span class="lineNum">    1365 </span>            :   /* Now evaluate the expression to determine the new range.  */
<span class="lineNum">    1366 </span><span class="lineCov">   27733719 :   if (POINTER_TYPE_P (expr_type))</span>
<span class="lineNum">    1367 </span>            :     {
<span class="lineNum">    1368 </span><span class="lineCov">    4582988 :       if (code == MIN_EXPR || code == MAX_EXPR)</span>
<span class="lineNum">    1369 </span>            :         {
<span class="lineNum">    1370 </span>            :           /* For MIN/MAX expressions with pointers, we only care about
<span class="lineNum">    1371 </span>            :              nullness, if both are non null, then the result is nonnull.
<span class="lineNum">    1372 </span>            :              If both are null, then the result is null. Otherwise they
<span class="lineNum">    1373 </span>            :              are varying.  */
<span class="lineNum">    1374 </span><span class="lineCov">       1076 :           if (!range_includes_zero_p (&amp;vr0) &amp;&amp; !range_includes_zero_p (&amp;vr1))</span>
<span class="lineNum">    1375 </span><span class="lineCov">         36 :             set_value_range_to_nonnull (vr, expr_type);</span>
<span class="lineNum">    1376 </span><span class="lineCov">       1040 :           else if (range_is_null (&amp;vr0) &amp;&amp; range_is_null (&amp;vr1))</span>
<span class="lineNum">    1377 </span><span class="lineNoCov">          0 :             set_value_range_to_null (vr, expr_type);</span>
<span class="lineNum">    1378 </span>            :           else
<span class="lineNum">    1379 </span><span class="lineCov">       1040 :             set_value_range_to_varying (vr);</span>
<span class="lineNum">    1380 </span>            :         }
<span class="lineNum">    1381 </span><span class="lineCov">    4581912 :       else if (code == POINTER_PLUS_EXPR)</span>
<span class="lineNum">    1382 </span>            :         {
<span class="lineNum">    1383 </span>            :           /* For pointer types, we are really only interested in asserting
<span class="lineNum">    1384 </span>            :              whether the expression evaluates to non-NULL.  */
<span class="lineNum">    1385 </span><span class="lineCov">    4565454 :           if (!range_includes_zero_p (&amp;vr0)</span>
<span class="lineNum">    1386 </span><span class="lineCov">    4565454 :               || !range_includes_zero_p (&amp;vr1))</span>
<span class="lineNum">    1387 </span><span class="lineCov">    2364144 :             set_value_range_to_nonnull (vr, expr_type);</span>
<span class="lineNum">    1388 </span><span class="lineCov">    2201310 :           else if (range_is_null (&amp;vr0) &amp;&amp; range_is_null (&amp;vr1))</span>
<span class="lineNum">    1389 </span><span class="lineCov">        269 :             set_value_range_to_null (vr, expr_type);</span>
<span class="lineNum">    1390 </span>            :           else
<span class="lineNum">    1391 </span><span class="lineCov">    2201041 :             set_value_range_to_varying (vr);</span>
<span class="lineNum">    1392 </span>            :         }
<span class="lineNum">    1393 </span><span class="lineCov">      16458 :       else if (code == BIT_AND_EXPR)</span>
<span class="lineNum">    1394 </span>            :         {
<span class="lineNum">    1395 </span>            :           /* For pointer types, we are really only interested in asserting
<span class="lineNum">    1396 </span>            :              whether the expression evaluates to non-NULL.  */
<span class="lineNum">    1397 </span><span class="lineCov">       1244 :           if (!range_includes_zero_p (&amp;vr0) &amp;&amp; !range_includes_zero_p (&amp;vr1))</span>
<span class="lineNum">    1398 </span><span class="lineCov">       1241 :             set_value_range_to_nonnull (vr, expr_type);</span>
<span class="lineNum">    1399 </span><span class="lineCov">          3 :           else if (range_is_null (&amp;vr0) || range_is_null (&amp;vr1))</span>
<span class="lineNum">    1400 </span><span class="lineNoCov">          0 :             set_value_range_to_null (vr, expr_type);</span>
<span class="lineNum">    1401 </span>            :           else
<span class="lineNum">    1402 </span><span class="lineCov">          3 :             set_value_range_to_varying (vr);</span>
<span class="lineNum">    1403 </span>            :         }
<span class="lineNum">    1404 </span>            :       else
<span class="lineNum">    1405 </span><span class="lineCov">      15214 :         set_value_range_to_varying (vr);</span>
<span class="lineNum">    1406 </span>            : 
<span class="lineNum">    1407 </span><span class="lineCov">    4582988 :       return;</span>
<span class="lineNum">    1408 </span>            :     }
<span class="lineNum">    1409 </span>            : 
<span class="lineNum">    1410 </span>            :   /* For integer ranges, apply the operation to each end of the
<span class="lineNum">    1411 </span>            :      range and see what we end up with.  */
<span class="lineNum">    1412 </span><span class="lineCov">   23150731 :   if (code == PLUS_EXPR || code == MINUS_EXPR)</span>
<span class="lineNum">    1413 </span>            :     {
<span class="lineNum">    1414 </span>            :       /* This will normalize things such that calculating
<span class="lineNum">    1415 </span>            :          [0,0] - VR_VARYING is not dropped to varying, but is
<span class="lineNum">    1416 </span>            :          calculated as [MIN+1, MAX].  */
<span class="lineNum">    1417 </span><span class="lineCov">   13731736 :       if (vr0.type == VR_VARYING)</span>
<span class="lineNum">    1418 </span>            :         {
<span class="lineNum">    1419 </span><span class="lineCov">    2829045 :           vr0.type = VR_RANGE;</span>
<span class="lineNum">    1420 </span><span class="lineCov">    2829045 :           vr0.min = vrp_val_min (expr_type);</span>
<span class="lineNum">    1421 </span><span class="lineCov">    2829045 :           vr0.max = vrp_val_max (expr_type);</span>
<span class="lineNum">    1422 </span>            :         }
<span class="lineNum">    1423 </span><span class="lineCov">   13731736 :       if (vr1.type == VR_VARYING)</span>
<span class="lineNum">    1424 </span>            :         {
<span class="lineNum">    1425 </span><span class="lineCov">    1218094 :           vr1.type = VR_RANGE;</span>
<span class="lineNum">    1426 </span><span class="lineCov">    1218094 :           vr1.min = vrp_val_min (expr_type);</span>
<span class="lineNum">    1427 </span><span class="lineCov">    1218094 :           vr1.max = vrp_val_max (expr_type);</span>
<span class="lineNum">    1428 </span>            :         }
<span class="lineNum">    1429 </span>            : 
<span class="lineNum">    1430 </span><span class="lineCov">   13731736 :       const bool minus_p = (code == MINUS_EXPR);</span>
<span class="lineNum">    1431 </span><span class="lineCov">   13731736 :       tree min_op0 = vr0.min;</span>
<span class="lineNum">    1432 </span><span class="lineCov">   13731736 :       tree min_op1 = minus_p ? vr1.max : vr1.min;</span>
<span class="lineNum">    1433 </span><span class="lineCov">   13731736 :       tree max_op0 = vr0.max;</span>
<span class="lineNum">    1434 </span><span class="lineCov">   13731736 :       tree max_op1 = minus_p ? vr1.min : vr1.max;</span>
<span class="lineNum">    1435 </span><span class="lineCov">   13731736 :       tree sym_min_op0 = NULL_TREE;</span>
<span class="lineNum">    1436 </span><span class="lineCov">   13731736 :       tree sym_min_op1 = NULL_TREE;</span>
<span class="lineNum">    1437 </span><span class="lineCov">   13731736 :       tree sym_max_op0 = NULL_TREE;</span>
<span class="lineNum">    1438 </span><span class="lineCov">   13731736 :       tree sym_max_op1 = NULL_TREE;</span>
<span class="lineNum">    1439 </span><span class="lineCov">   13731736 :       bool neg_min_op0, neg_min_op1, neg_max_op0, neg_max_op1;</span>
<span class="lineNum">    1440 </span>            : 
<span class="lineNum">    1441 </span><span class="lineCov">   13731736 :       neg_min_op0 = neg_min_op1 = neg_max_op0 = neg_max_op1 = false;</span>
<span class="lineNum">    1442 </span>            : 
<span class="lineNum">    1443 </span>            :       /* If we have a PLUS or MINUS with two VR_RANGEs, either constant or
<span class="lineNum">    1444 </span>            :          single-symbolic ranges, try to compute the precise resulting range,
<span class="lineNum">    1445 </span>            :          but only if we know that this resulting range will also be constant
<span class="lineNum">    1446 </span>            :          or single-symbolic.  */
<span class="lineNum">    1447 </span><span class="lineCov">   27393283 :       if (vr0.type == VR_RANGE &amp;&amp; vr1.type == VR_RANGE</span>
<span class="lineNum">    1448 </span><span class="lineCov">   13661547 :           &amp;&amp; (TREE_CODE (min_op0) == INTEGER_CST</span>
<span class="lineNum">    1449 </span><span class="lineCov">     387854 :               || (sym_min_op0</span>
<span class="lineNum">    1450 </span><span class="lineCov">     387854 :                   = get_single_symbol (min_op0, &amp;neg_min_op0, &amp;min_op0)))</span>
<span class="lineNum">    1451 </span><span class="lineCov">   13661547 :           &amp;&amp; (TREE_CODE (min_op1) == INTEGER_CST</span>
<span class="lineNum">    1452 </span><span class="lineCov">     224994 :               || (sym_min_op1</span>
<span class="lineNum">    1453 </span><span class="lineCov">     224994 :                   = get_single_symbol (min_op1, &amp;neg_min_op1, &amp;min_op1)))</span>
<span class="lineNum">    1454 </span><span class="lineCov">   13661547 :           &amp;&amp; (!(sym_min_op0 &amp;&amp; sym_min_op1)</span>
<span class="lineNum">    1455 </span><span class="lineCov">     117026 :               || (sym_min_op0 == sym_min_op1</span>
<span class="lineNum">    1456 </span><span class="lineCov">     144507 :                   &amp;&amp; neg_min_op0 == (minus_p ? neg_min_op1 : !neg_min_op1)))</span>
<span class="lineNum">    1457 </span><span class="lineCov">   13616397 :           &amp;&amp; (TREE_CODE (max_op0) == INTEGER_CST</span>
<span class="lineNum">    1458 </span><span class="lineCov">     360484 :               || (sym_max_op0</span>
<span class="lineNum">    1459 </span><span class="lineCov">     360484 :                   = get_single_symbol (max_op0, &amp;neg_max_op0, &amp;max_op0)))</span>
<span class="lineNum">    1460 </span><span class="lineCov">   13616397 :           &amp;&amp; (TREE_CODE (max_op1) == INTEGER_CST</span>
<span class="lineNum">    1461 </span><span class="lineCov">     111642 :               || (sym_max_op1</span>
<span class="lineNum">    1462 </span><span class="lineCov">     111642 :                   = get_single_symbol (max_op1, &amp;neg_max_op1, &amp;max_op1)))</span>
<span class="lineNum">    1463 </span><span class="lineCov">   27348133 :           &amp;&amp; (!(sym_max_op0 &amp;&amp; sym_max_op1)</span>
<span class="lineNum">    1464 </span><span class="lineCov">      10456 :               || (sym_max_op0 == sym_max_op1</span>
<span class="lineNum">    1465 </span><span class="lineCov">       9123 :                   &amp;&amp; neg_max_op0 == (minus_p ? neg_max_op1 : !neg_max_op1))))</span>
<span class="lineNum">    1466 </span>            :         {
<span class="lineNum">    1467 </span><span class="lineCov">   27220330 :           wide_int wmin, wmax;</span>
<span class="lineNum">    1468 </span><span class="lineCov">   13610165 :           wi::overflow_type min_ovf = wi::OVF_NONE;</span>
<span class="lineNum">    1469 </span><span class="lineCov">   13610165 :           wi::overflow_type max_ovf = wi::OVF_NONE;</span>
<span class="lineNum">    1470 </span>            : 
<span class="lineNum">    1471 </span>            :           /* Build the bounds.  */
<span class="lineNum">    1472 </span><span class="lineCov">   13610165 :           combine_bound (code, wmin, min_ovf, expr_type, min_op0, min_op1);</span>
<span class="lineNum">    1473 </span><span class="lineCov">   13610165 :           combine_bound (code, wmax, max_ovf, expr_type, max_op0, max_op1);</span>
<span class="lineNum">    1474 </span>            : 
<span class="lineNum">    1475 </span>            :           /* If we have overflow for the constant part and the resulting
<span class="lineNum">    1476 </span>            :              range will be symbolic, drop to VR_VARYING.  */
<span class="lineNum">    1477 </span><span class="lineCov">   13610165 :           if (((bool)min_ovf &amp;&amp; sym_min_op0 != sym_min_op1)</span>
<span class="lineNum">    1478 </span><span class="lineCov">   13597507 :               || ((bool)max_ovf &amp;&amp; sym_max_op0 != sym_max_op1))</span>
<span class="lineNum">    1479 </span>            :             {
<span class="lineNum">    1480 </span><span class="lineCov">      80448 :               set_value_range_to_varying (vr);</span>
<span class="lineNum">    1481 </span><span class="lineCov">    4688843 :               return;</span>
<span class="lineNum">    1482 </span>            :             }
<span class="lineNum">    1483 </span>            : 
<span class="lineNum">    1484 </span>            :           /* Adjust the range for possible overflow.  */
<span class="lineNum">    1485 </span><span class="lineCov">   13529717 :           set_value_range_with_overflow (*vr, expr_type,</span>
<span class="lineNum">    1486 </span>            :                                          wmin, wmax, min_ovf, max_ovf);
<span class="lineNum">    1487 </span><span class="lineCov">   13529717 :           if (vr-&gt;type == VR_VARYING)</span>
<span class="lineNum">    1488 </span>            :             return;
<span class="lineNum">    1489 </span>            : 
<span class="lineNum">    1490 </span>            :           /* Build the symbolic bounds if needed.  */
<span class="lineNum">    1491 </span><span class="lineCov">    8921322 :           adjust_symbolic_bound (vr-&gt;min, code, expr_type,</span>
<span class="lineNum">    1492 </span>            :                                  sym_min_op0, sym_min_op1,
<span class="lineNum">    1493 </span>            :                                  neg_min_op0, neg_min_op1);
<span class="lineNum">    1494 </span><span class="lineCov">    8921322 :           adjust_symbolic_bound (vr-&gt;max, code, expr_type,</span>
<span class="lineNum">    1495 </span>            :                                  sym_max_op0, sym_max_op1,
<span class="lineNum">    1496 </span>            :                                  neg_max_op0, neg_max_op1);
<span class="lineNum">    1497 </span>            :           /* ?? It would probably be cleaner to eliminate min/max/type
<span class="lineNum">    1498 </span>            :              entirely and hold these values in VR directly.  */
<span class="lineNum">    1499 </span><span class="lineCov">    8921322 :           min = vr-&gt;min;</span>
<span class="lineNum">    1500 </span><span class="lineCov">    8921322 :           max = vr-&gt;max;</span>
<span class="lineNum">    1501 </span><span class="lineCov">    8921322 :           type = vr-&gt;type;</span>
<span class="lineNum">    1502 </span>            :         }
<span class="lineNum">    1503 </span>            :       else
<span class="lineNum">    1504 </span>            :         {
<span class="lineNum">    1505 </span>            :           /* For other cases, for example if we have a PLUS_EXPR with two
<span class="lineNum">    1506 </span>            :              VR_ANTI_RANGEs, drop to VR_VARYING.  It would take more effort
<span class="lineNum">    1507 </span>            :              to compute a precise range for such a case.
<span class="lineNum">    1508 </span>            :              ???  General even mixed range kind operations can be expressed
<span class="lineNum">    1509 </span>            :              by for example transforming ~[3, 5] + [1, 2] to range-only
<span class="lineNum">    1510 </span>            :              operations and a union primitive:
<span class="lineNum">    1511 </span>            :                [-INF, 2] + [1, 2]  U  [5, +INF] + [1, 2]
<span class="lineNum">    1512 </span>            :                    [-INF+1, 4]     U    [6, +INF(OVF)]
<span class="lineNum">    1513 </span>            :              though usually the union is not exactly representable with
<span class="lineNum">    1514 </span>            :              a single range or anti-range as the above is
<span class="lineNum">    1515 </span>            :                  [-INF+1, +INF(OVF)] intersected with ~[5, 5]
<span class="lineNum">    1516 </span>            :              but one could use a scheme similar to equivalences for this. */
<span class="lineNum">    1517 </span><span class="lineCov">     121571 :           set_value_range_to_varying (vr);</span>
<span class="lineNum">    1518 </span><span class="lineCov">     121571 :           return;</span>
<span class="lineNum">    1519 </span>            :         }
<span class="lineNum">    1520 </span>            :     }
<span class="lineNum">    1521 </span><span class="lineCov">   18837990 :   else if (code == MIN_EXPR</span>
<span class="lineNum">    1522 </span><span class="lineCov">    9418995 :            || code == MAX_EXPR)</span>
<span class="lineNum">    1523 </span>            :     {
<span class="lineNum">    1524 </span><span class="lineCov">     692834 :       wide_int wmin, wmax;</span>
<span class="lineNum">    1525 </span><span class="lineCov">     692834 :       wide_int vr0_min, vr0_max;</span>
<span class="lineNum">    1526 </span><span class="lineCov">     692834 :       wide_int vr1_min, vr1_max;</span>
<span class="lineNum">    1527 </span><span class="lineCov">     346417 :       extract_range_into_wide_ints (&amp;vr0, sign, prec, vr0_min, vr0_max);</span>
<span class="lineNum">    1528 </span><span class="lineCov">     346417 :       extract_range_into_wide_ints (&amp;vr1, sign, prec, vr1_min, vr1_max);</span>
<span class="lineNum">    1529 </span><span class="lineCov">     346417 :       if (wide_int_range_min_max (wmin, wmax, code, sign, prec,</span>
<span class="lineNum">    1530 </span>            :                                   vr0_min, vr0_max, vr1_min, vr1_max))
<span class="lineNum">    1531 </span><span class="lineCov">     505300 :         set_value_range (vr, VR_RANGE,</span>
<span class="lineNum">    1532 </span>            :                          wide_int_to_tree (expr_type, wmin),
<span class="lineNum">    1533 </span>            :                          wide_int_to_tree (expr_type, wmax), NULL);
<span class="lineNum">    1534 </span>            :       else
<span class="lineNum">    1535 </span><span class="lineCov">      93767 :         set_value_range_to_varying (vr);</span>
<span class="lineNum">    1536 </span><span class="lineCov">     346417 :       return;</span>
<span class="lineNum">    1537 </span>            :     }
<span class="lineNum">    1538 </span><span class="lineCov">    9072578 :   else if (code == MULT_EXPR)</span>
<span class="lineNum">    1539 </span>            :     {
<span class="lineNum">    1540 </span><span class="lineCov">    3305510 :       if (!range_int_cst_p (&amp;vr0)</span>
<span class="lineNum">    1541 </span><span class="lineCov">    3305510 :           || !range_int_cst_p (&amp;vr1))</span>
<span class="lineNum">    1542 </span>            :         {
<span class="lineNum">    1543 </span><span class="lineNoCov">          0 :           set_value_range_to_varying (vr);</span>
<span class="lineNum">    1544 </span><span class="lineNoCov">          0 :           return;</span>
<span class="lineNum">    1545 </span>            :         }
<span class="lineNum">    1546 </span><span class="lineCov">    3305510 :       extract_range_from_multiplicative_op (vr, code, &amp;vr0, &amp;vr1);</span>
<span class="lineNum">    1547 </span><span class="lineCov">    3305510 :       return;</span>
<span class="lineNum">    1548 </span>            :     }
<span class="lineNum">    1549 </span><span class="lineCov">   11534136 :   else if (code == RSHIFT_EXPR</span>
<span class="lineNum">    1550 </span><span class="lineCov">    5767068 :            || code == LSHIFT_EXPR)</span>
<span class="lineNum">    1551 </span>            :     {
<span class="lineNum">    1552 </span><span class="lineCov">    1445229 :       if (range_int_cst_p (&amp;vr1)</span>
<span class="lineNum">    1553 </span><span class="lineCov">    2880112 :           &amp;&amp; !wide_int_range_shift_undefined_p (prec,</span>
<span class="lineNum">    1554 </span><span class="lineCov">    1434883 :                                                 wi::to_wide (vr1.min),</span>
<span class="lineNum">    1555 </span><span class="lineCov">    1512026 :                                                 wi::to_wide (vr1.max)))</span>
<span class="lineNum">    1556 </span>            :         {
<span class="lineNum">    1557 </span><span class="lineCov">    1368086 :           if (code == RSHIFT_EXPR)</span>
<span class="lineNum">    1558 </span>            :             {
<span class="lineNum">    1559 </span>            :               /* Even if vr0 is VARYING or otherwise not usable, we can derive
<span class="lineNum">    1560 </span>            :                  useful ranges just from the shift count.  E.g.
<span class="lineNum">    1561 </span>            :                  x &gt;&gt; 63 for signed 64-bit x is always [-1, 0].  */
<span class="lineNum">    1562 </span><span class="lineCov">    1054194 :               if (vr0.type != VR_RANGE || symbolic_range_p (&amp;vr0))</span>
<span class="lineNum">    1563 </span>            :                 {
<span class="lineNum">    1564 </span><span class="lineCov">     154427 :                   vr0.type = type = VR_RANGE;</span>
<span class="lineNum">    1565 </span><span class="lineCov">     154427 :                   vr0.min = vrp_val_min (expr_type);</span>
<span class="lineNum">    1566 </span><span class="lineCov">     154427 :                   vr0.max = vrp_val_max (expr_type);</span>
<span class="lineNum">    1567 </span>            :                 }
<span class="lineNum">    1568 </span><span class="lineCov">    1054194 :               extract_range_from_multiplicative_op (vr, code, &amp;vr0, &amp;vr1);</span>
<span class="lineNum">    1569 </span><span class="lineCov">    1054194 :               return;</span>
<span class="lineNum">    1570 </span>            :             }
<span class="lineNum">    1571 </span><span class="lineCov">     313892 :           else if (code == LSHIFT_EXPR</span>
<span class="lineNum">    1572 </span><span class="lineCov">     313892 :                    &amp;&amp; range_int_cst_p (&amp;vr0))</span>
<span class="lineNum">    1573 </span>            :             {
<span class="lineNum">    1574 </span><span class="lineCov">     627784 :               wide_int res_lb, res_ub;</span>
<span class="lineNum">    1575 </span><span class="lineCov">     941676 :               if (wide_int_range_lshift (res_lb, res_ub, sign, prec,</span>
<span class="lineNum">    1576 </span><span class="lineCov">     313892 :                                          wi::to_wide (vr0.min),</span>
<span class="lineNum">    1577 </span><span class="lineCov">     313892 :                                          wi::to_wide (vr0.max),</span>
<span class="lineNum">    1578 </span><span class="lineCov">     313892 :                                          wi::to_wide (vr1.min),</span>
<span class="lineNum">    1579 </span><span class="lineCov">     627784 :                                          wi::to_wide (vr1.max),</span>
<span class="lineNum">    1580 </span><span class="lineCov">     313892 :                                          TYPE_OVERFLOW_UNDEFINED (expr_type),</span>
<span class="lineNum">    1581 </span><span class="lineCov">     313892 :                                          TYPE_OVERFLOW_WRAPS (expr_type)))</span>
<span class="lineNum">    1582 </span>            :                 {
<span class="lineNum">    1583 </span><span class="lineCov">     363400 :                   min = wide_int_to_tree (expr_type, res_lb);</span>
<span class="lineNum">    1584 </span><span class="lineCov">     363400 :                   max = wide_int_to_tree (expr_type, res_ub);</span>
<span class="lineNum">    1585 </span><span class="lineCov">     181700 :                   set_and_canonicalize_value_range (vr, VR_RANGE,</span>
<span class="lineNum">    1586 </span>            :                                                     min, max, NULL);
<span class="lineNum">    1587 </span><span class="lineCov">     181700 :                   return;</span>
<span class="lineNum">    1588 </span>            :                 }
<span class="lineNum">    1589 </span>            :             }
<span class="lineNum">    1590 </span>            :         }
<span class="lineNum">    1591 </span><span class="lineCov">     209335 :       set_value_range_to_varying (vr);</span>
<span class="lineNum">    1592 </span><span class="lineCov">     209335 :       return;</span>
<span class="lineNum">    1593 </span>            :     }
<span class="lineNum">    1594 </span><span class="lineCov">    8643678 :   else if (code == TRUNC_DIV_EXPR</span>
<span class="lineNum">    1595 </span><span class="lineCov">    4321839 :            || code == FLOOR_DIV_EXPR</span>
<span class="lineNum">    1596 </span><span class="lineCov">    4035440 :            || code == CEIL_DIV_EXPR</span>
<span class="lineNum">    1597 </span><span class="lineCov">    4035440 :            || code == EXACT_DIV_EXPR</span>
<span class="lineNum">    1598 </span><span class="lineCov">    3777171 :            || code == ROUND_DIV_EXPR)</span>
<span class="lineNum">    1599 </span>            :     {
<span class="lineNum">    1600 </span><span class="lineCov">    2178672 :       wide_int dividend_min, dividend_max, divisor_min, divisor_max;</span>
<span class="lineNum">    1601 </span><span class="lineCov">    2178672 :       wide_int wmin, wmax, extra_min, extra_max;</span>
<span class="lineNum">    1602 </span><span class="lineCov">     544668 :       bool extra_range_p;</span>
<span class="lineNum">    1603 </span>            : 
<span class="lineNum">    1604 </span>            :       /* Special case explicit division by zero as undefined.  */
<span class="lineNum">    1605 </span><span class="lineCov">     544668 :       if (range_is_null (&amp;vr1))</span>
<span class="lineNum">    1606 </span>            :         {
<span class="lineNum">    1607 </span><span class="lineCov">       1503 :           set_value_range_to_undefined (vr);</span>
<span class="lineNum">    1608 </span><span class="lineCov">       1503 :           return;</span>
<span class="lineNum">    1609 </span>            :         }
<span class="lineNum">    1610 </span>            : 
<span class="lineNum">    1611 </span>            :       /* First, normalize ranges into constants we can handle.  Note
<span class="lineNum">    1612 </span>            :          that VR_ANTI_RANGE's of constants were already normalized
<span class="lineNum">    1613 </span>            :          before arriving here.
<span class="lineNum">    1614 </span>            : 
<span class="lineNum">    1615 </span>            :          NOTE: As a future improvement, we may be able to do better
<span class="lineNum">    1616 </span>            :          with mixed symbolic (anti-)ranges like [0, A].  See note in
<span class="lineNum">    1617 </span>            :          ranges_from_anti_range.  */
<span class="lineNum">    1618 </span><span class="lineCov">     543165 :       extract_range_into_wide_ints (&amp;vr0, sign, prec,</span>
<span class="lineNum">    1619 </span>            :                                     dividend_min, dividend_max);
<span class="lineNum">    1620 </span><span class="lineCov">     543165 :       extract_range_into_wide_ints (&amp;vr1, sign, prec,</span>
<span class="lineNum">    1621 </span>            :                                     divisor_min, divisor_max);
<span class="lineNum">    1622 </span><span class="lineCov">    1086330 :       if (!wide_int_range_div (wmin, wmax, code, sign, prec,</span>
<span class="lineNum">    1623 </span>            :                                dividend_min, dividend_max,
<span class="lineNum">    1624 </span>            :                                divisor_min, divisor_max,
<span class="lineNum">    1625 </span><span class="lineCov">     543165 :                                TYPE_OVERFLOW_UNDEFINED (expr_type),</span>
<span class="lineNum">    1626 </span><span class="lineCov">     543165 :                                TYPE_OVERFLOW_WRAPS (expr_type),</span>
<span class="lineNum">    1627 </span><span class="lineNoCov">          0 :                                extra_range_p, extra_min, extra_max))</span>
<span class="lineNum">    1628 </span>            :         {
<span class="lineNum">    1629 </span><span class="lineCov">       1123 :           set_value_range_to_varying (vr);</span>
<span class="lineNum">    1630 </span><span class="lineCov">       1123 :           return;</span>
<span class="lineNum">    1631 </span>            :         }
<span class="lineNum">    1632 </span><span class="lineCov">    1084084 :       set_value_range (vr, VR_RANGE,</span>
<span class="lineNum">    1633 </span>            :                        wide_int_to_tree (expr_type, wmin),
<span class="lineNum">    1634 </span>            :                        wide_int_to_tree (expr_type, wmax), NULL);
<span class="lineNum">    1635 </span><span class="lineCov">     542042 :       if (extra_range_p)</span>
<span class="lineNum">    1636 </span>            :         {
<span class="lineNum">    1637 </span><span class="lineCov">      58359 :           value_range extra_range = VR_INITIALIZER;</span>
<span class="lineNum">    1638 </span><span class="lineCov">     116718 :           set_value_range (&amp;extra_range, VR_RANGE,</span>
<span class="lineNum">    1639 </span>            :                            wide_int_to_tree (expr_type, extra_min),
<span class="lineNum">    1640 </span>            :                            wide_int_to_tree (expr_type, extra_max), NULL);
<span class="lineNum">    1641 </span><span class="lineCov">      58359 :           vrp_meet (vr, &amp;extra_range);</span>
<span class="lineNum">    1642 </span>            :         }
<span class="lineNum">    1643 </span><span class="lineCov">     542042 :       return;</span>
<span class="lineNum">    1644 </span>            :     }
<span class="lineNum">    1645 </span><span class="lineCov">    3777171 :   else if (code == TRUNC_MOD_EXPR)</span>
<span class="lineNum">    1646 </span>            :     {
<span class="lineNum">    1647 </span><span class="lineCov">     274564 :       if (range_is_null (&amp;vr1))</span>
<span class="lineNum">    1648 </span>            :         {
<span class="lineNum">    1649 </span><span class="lineCov">       1729 :           set_value_range_to_undefined (vr);</span>
<span class="lineNum">    1650 </span><span class="lineCov">       1729 :           return;</span>
<span class="lineNum">    1651 </span>            :         }
<span class="lineNum">    1652 </span><span class="lineCov">     818505 :       wide_int wmin, wmax, tmp;</span>
<span class="lineNum">    1653 </span><span class="lineCov">    1091340 :       wide_int vr0_min, vr0_max, vr1_min, vr1_max;</span>
<span class="lineNum">    1654 </span><span class="lineCov">     272835 :       extract_range_into_wide_ints (&amp;vr0, sign, prec, vr0_min, vr0_max);</span>
<span class="lineNum">    1655 </span><span class="lineCov">     272835 :       extract_range_into_wide_ints (&amp;vr1, sign, prec, vr1_min, vr1_max);</span>
<span class="lineNum">    1656 </span><span class="lineCov">     272835 :       wide_int_range_trunc_mod (wmin, wmax, sign, prec,</span>
<span class="lineNum">    1657 </span>            :                                 vr0_min, vr0_max, vr1_min, vr1_max);
<span class="lineNum">    1658 </span><span class="lineCov">     545670 :       min = wide_int_to_tree (expr_type, wmin);</span>
<span class="lineNum">    1659 </span><span class="lineCov">     545670 :       max = wide_int_to_tree (expr_type, wmax);</span>
<span class="lineNum">    1660 </span><span class="lineCov">     272835 :       set_value_range (vr, VR_RANGE, min, max, NULL);</span>
<span class="lineNum">    1661 </span><span class="lineCov">     272835 :       return;</span>
<span class="lineNum">    1662 </span>            :     }
<span class="lineNum">    1663 </span><span class="lineCov">    3502607 :   else if (code == BIT_AND_EXPR || code == BIT_IOR_EXPR || code == BIT_XOR_EXPR)</span>
<span class="lineNum">    1664 </span>            :     {
<span class="lineNum">    1665 </span><span class="lineCov">    7005214 :       wide_int may_be_nonzero0, may_be_nonzero1;</span>
<span class="lineNum">    1666 </span><span class="lineCov">    7005214 :       wide_int must_be_nonzero0, must_be_nonzero1;</span>
<span class="lineNum">    1667 </span><span class="lineCov">    7005214 :       wide_int wmin, wmax;</span>
<span class="lineNum">    1668 </span><span class="lineCov">   14010428 :       wide_int vr0_min, vr0_max, vr1_min, vr1_max;</span>
<span class="lineNum">    1669 </span><span class="lineCov">    3502607 :       vrp_set_zero_nonzero_bits (expr_type, &amp;vr0,</span>
<span class="lineNum">    1670 </span>            :                                  &amp;may_be_nonzero0, &amp;must_be_nonzero0);
<span class="lineNum">    1671 </span><span class="lineCov">    3502607 :       vrp_set_zero_nonzero_bits (expr_type, &amp;vr1,</span>
<span class="lineNum">    1672 </span>            :                                  &amp;may_be_nonzero1, &amp;must_be_nonzero1);
<span class="lineNum">    1673 </span><span class="lineCov">    3502607 :       extract_range_into_wide_ints (&amp;vr0, sign, prec, vr0_min, vr0_max);</span>
<span class="lineNum">    1674 </span><span class="lineCov">    3502607 :       extract_range_into_wide_ints (&amp;vr1, sign, prec, vr1_min, vr1_max);</span>
<span class="lineNum">    1675 </span><span class="lineCov">    3502607 :       if (code == BIT_AND_EXPR)</span>
<span class="lineNum">    1676 </span>            :         {
<span class="lineNum">    1677 </span><span class="lineCov">    1928193 :           if (wide_int_range_bit_and (wmin, wmax, sign, prec,</span>
<span class="lineNum">    1678 </span>            :                                       vr0_min, vr0_max,
<span class="lineNum">    1679 </span>            :                                       vr1_min, vr1_max,
<span class="lineNum">    1680 </span>            :                                       must_be_nonzero0,
<span class="lineNum">    1681 </span>            :                                       may_be_nonzero0,
<span class="lineNum">    1682 </span>            :                                       must_be_nonzero1,
<span class="lineNum">    1683 </span>            :                                       may_be_nonzero1))
<span class="lineNum">    1684 </span>            :             {
<span class="lineNum">    1685 </span><span class="lineCov">    3787576 :               min = wide_int_to_tree (expr_type, wmin);</span>
<span class="lineNum">    1686 </span><span class="lineCov">    3787576 :               max = wide_int_to_tree (expr_type, wmax);</span>
<span class="lineNum">    1687 </span><span class="lineCov">    1893788 :               set_value_range (vr, VR_RANGE, min, max, NULL);</span>
<span class="lineNum">    1688 </span>            :             }
<span class="lineNum">    1689 </span>            :           else
<span class="lineNum">    1690 </span><span class="lineCov">      34405 :             set_value_range_to_varying (vr);</span>
<span class="lineNum">    1691 </span><span class="lineCov">    3502607 :           return;</span>
<span class="lineNum">    1692 </span>            :         }
<span class="lineNum">    1693 </span><span class="lineCov">    1574414 :       else if (code == BIT_IOR_EXPR)</span>
<span class="lineNum">    1694 </span>            :         {
<span class="lineNum">    1695 </span><span class="lineCov">    1494504 :           if (wide_int_range_bit_ior (wmin, wmax, sign,</span>
<span class="lineNum">    1696 </span>            :                                       vr0_min, vr0_max,
<span class="lineNum">    1697 </span>            :                                       vr1_min, vr1_max,
<span class="lineNum">    1698 </span>            :                                       must_be_nonzero0,
<span class="lineNum">    1699 </span>            :                                       may_be_nonzero0,
<span class="lineNum">    1700 </span>            :                                       must_be_nonzero1,
<span class="lineNum">    1701 </span>            :                                       may_be_nonzero1))
<span class="lineNum">    1702 </span>            :             {
<span class="lineNum">    1703 </span><span class="lineCov">    2659320 :               min = wide_int_to_tree (expr_type, wmin);</span>
<span class="lineNum">    1704 </span><span class="lineCov">    2659320 :               max = wide_int_to_tree (expr_type, wmax);</span>
<span class="lineNum">    1705 </span><span class="lineCov">    1329660 :               set_value_range (vr, VR_RANGE, min, max, NULL);</span>
<span class="lineNum">    1706 </span>            :             }
<span class="lineNum">    1707 </span>            :           else
<span class="lineNum">    1708 </span><span class="lineCov">     164844 :             set_value_range_to_varying (vr);</span>
<span class="lineNum">    1709 </span><span class="lineCov">    1494504 :           return;</span>
<span class="lineNum">    1710 </span>            :         }
<span class="lineNum">    1711 </span><span class="lineCov">      79910 :       else if (code == BIT_XOR_EXPR)</span>
<span class="lineNum">    1712 </span>            :         {
<span class="lineNum">    1713 </span><span class="lineCov">      79910 :           if (wide_int_range_bit_xor (wmin, wmax, sign, prec,</span>
<span class="lineNum">    1714 </span>            :                                       must_be_nonzero0,
<span class="lineNum">    1715 </span>            :                                       may_be_nonzero0,
<span class="lineNum">    1716 </span>            :                                       must_be_nonzero1,
<span class="lineNum">    1717 </span>            :                                       may_be_nonzero1))
<span class="lineNum">    1718 </span>            :             {
<span class="lineNum">    1719 </span><span class="lineCov">     139286 :               min = wide_int_to_tree (expr_type, wmin);</span>
<span class="lineNum">    1720 </span><span class="lineCov">     139286 :               max = wide_int_to_tree (expr_type, wmax);</span>
<span class="lineNum">    1721 </span><span class="lineCov">      69643 :               set_value_range (vr, VR_RANGE, min, max, NULL);</span>
<span class="lineNum">    1722 </span>            :             }
<span class="lineNum">    1723 </span>            :           else
<span class="lineNum">    1724 </span><span class="lineCov">      10267 :             set_value_range_to_varying (vr);</span>
<span class="lineNum">    1725 </span><span class="lineCov">      79910 :           return;</span>
<span class="lineNum">    1726 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">    1727 </span>            :     }
<span class="lineNum">    1728 </span>            :   else
<span class="lineNum">    1729 </span><span class="lineNoCov">          0 :     gcc_unreachable ();</span>
<span class="lineNum">    1730 </span>            : 
<span class="lineNum">    1731 </span>            :   /* If either MIN or MAX overflowed, then set the resulting range to
<span class="lineNum">    1732 </span>            :      VARYING.  */
<span class="lineNum">    1733 </span><span class="lineCov">    8921322 :   if (min == NULL_TREE</span>
<span class="lineNum">    1734 </span><span class="lineCov">    8897349 :       || TREE_OVERFLOW_P (min)</span>
<span class="lineNum">    1735 </span><span class="lineCov">    8897349 :       || max == NULL_TREE</span>
<span class="lineNum">    1736 </span><span class="lineCov">   17808711 :       || TREE_OVERFLOW_P (max))</span>
<span class="lineNum">    1737 </span>            :     {
<span class="lineNum">    1738 </span><span class="lineCov">      33933 :       set_value_range_to_varying (vr);</span>
<span class="lineNum">    1739 </span><span class="lineCov">      33933 :       return;</span>
<span class="lineNum">    1740 </span>            :     }
<span class="lineNum">    1741 </span>            : 
<span class="lineNum">    1742 </span>            :   /* We punt for [-INF, +INF].
<span class="lineNum">    1743 </span>            :      We learn nothing when we have INF on both sides.
<span class="lineNum">    1744 </span>            :      Note that we do accept [-INF, -INF] and [+INF, +INF].  */
<span class="lineNum">    1745 </span><span class="lineCov">    8887389 :   if (vrp_val_is_min (min) &amp;&amp; vrp_val_is_max (max))</span>
<span class="lineNum">    1746 </span>            :     {
<span class="lineNum">    1747 </span><span class="lineCov">    1217334 :       set_value_range_to_varying (vr);</span>
<span class="lineNum">    1748 </span><span class="lineCov">    1217334 :       return;</span>
<span class="lineNum">    1749 </span>            :     }
<span class="lineNum">    1750 </span>            : 
<span class="lineNum">    1751 </span><span class="lineCov">    7670055 :   cmp = compare_values (min, max);</span>
<span class="lineNum">    1752 </span><span class="lineCov">    7670055 :   if (cmp == -2 || cmp == 1)</span>
<span class="lineNum">    1753 </span>            :     {
<span class="lineNum">    1754 </span>            :       /* If the new range has its limits swapped around (MIN &gt; MAX),
<span class="lineNum">    1755 </span>            :          then the operation caused one of them to wrap around, mark
<span class="lineNum">    1756 </span>            :          the new range VARYING.  */
<span class="lineNum">    1757 </span><span class="lineCov">     467931 :       set_value_range_to_varying (vr);</span>
<span class="lineNum">    1758 </span>            :     }
<span class="lineNum">    1759 </span>            :   else
<span class="lineNum">    1760 </span><span class="lineCov">    7202124 :     set_value_range (vr, type, min, max, NULL);</span>
<span class="lineNum">    1761 </span><span class="lineCov">      76105 : }</span>
<span class="lineNum">    1762 </span>            : 
<span class="lineNum">    1763 </span>            : /* Extract range information from a unary operation CODE based on
<span class="lineNum">    1764 </span>            :    the range of its operand *VR0 with type OP0_TYPE with resulting type TYPE.
<span class="lineNum">    1765 </span>            :    The resulting range is stored in *VR.  */
<span class="lineNum">    1766 </span>            : 
<span class="lineNum">    1767 </span>            : void
<span class="lineNum">    1768 </span><span class="lineCov">   14277450 : extract_range_from_unary_expr (value_range *vr,</span>
<span class="lineNum">    1769 </span>            :                                enum tree_code code, tree type,
<span class="lineNum">    1770 </span>            :                                const value_range *vr0_, tree op0_type)
<span class="lineNum">    1771 </span>            : {
<span class="lineNum">    1772 </span><span class="lineCov">   14277450 :   signop sign = TYPE_SIGN (type);</span>
<span class="lineNum">    1773 </span><span class="lineCov">   14277450 :   unsigned int prec = TYPE_PRECISION (type);</span>
<span class="lineNum">    1774 </span><span class="lineCov">   14277450 :   value_range vr0 = *vr0_, vrtem0 = VR_INITIALIZER, vrtem1 = VR_INITIALIZER;</span>
<span class="lineNum">    1775 </span>            : 
<span class="lineNum">    1776 </span>            :   /* VRP only operates on integral and pointer types.  */
<span class="lineNum">    1777 </span><span class="lineCov">   14277450 :   if (!(INTEGRAL_TYPE_P (op0_type)</span>
<span class="lineNum">    1778 </span><span class="lineCov">    1937055 :         || POINTER_TYPE_P (op0_type))</span>
<span class="lineNum">    1779 </span><span class="lineCov">   13814539 :       || !(INTEGRAL_TYPE_P (type)</span>
<span class="lineNum">    1780 </span><span class="lineCov">    1733895 :            || POINTER_TYPE_P (type)))</span>
<span class="lineNum">    1781 </span>            :     {
<span class="lineNum">    1782 </span><span class="lineCov">     462911 :       set_value_range_to_varying (vr);</span>
<span class="lineNum">    1783 </span><span class="lineCov">     462911 :       return;</span>
<span class="lineNum">    1784 </span>            :     }
<span class="lineNum">    1785 </span>            : 
<span class="lineNum">    1786 </span>            :   /* If VR0 is UNDEFINED, so is the result.  */
<span class="lineNum">    1787 </span><span class="lineCov">   13814539 :   if (vr0.type == VR_UNDEFINED)</span>
<span class="lineNum">    1788 </span>            :     {
<span class="lineNum">    1789 </span><span class="lineCov">      25735 :       set_value_range_to_undefined (vr);</span>
<span class="lineNum">    1790 </span><span class="lineCov">      25735 :       return;</span>
<span class="lineNum">    1791 </span>            :     }
<span class="lineNum">    1792 </span>            : 
<span class="lineNum">    1793 </span>            :   /* Handle operations that we express in terms of others.  */
<span class="lineNum">    1794 </span><span class="lineCov">   13788804 :   if (code == PAREN_EXPR || code == OBJ_TYPE_REF)</span>
<span class="lineNum">    1795 </span>            :     {
<span class="lineNum">    1796 </span>            :       /* PAREN_EXPR and OBJ_TYPE_REF are simple copies.  */
<span class="lineNum">    1797 </span><span class="lineNoCov">          0 :       copy_value_range (vr, &amp;vr0);</span>
<span class="lineNum">    1798 </span><span class="lineNoCov">          0 :       return;</span>
<span class="lineNum">    1799 </span>            :     }
<span class="lineNum">    1800 </span><span class="lineCov">   13788804 :   else if (code == NEGATE_EXPR)</span>
<span class="lineNum">    1801 </span>            :     {
<span class="lineNum">    1802 </span>            :       /* -X is simply 0 - X, so re-use existing code that also handles
<span class="lineNum">    1803 </span>            :          anti-ranges fine.  */
<span class="lineNum">    1804 </span><span class="lineCov">     255568 :       value_range zero = VR_INITIALIZER;</span>
<span class="lineNum">    1805 </span><span class="lineCov">     511136 :       set_value_range_to_value (&amp;zero, build_int_cst (type, 0), NULL);</span>
<span class="lineNum">    1806 </span><span class="lineCov">     255568 :       extract_range_from_binary_expr_1 (vr, MINUS_EXPR, type, &amp;zero, &amp;vr0);</span>
<span class="lineNum">    1807 </span><span class="lineCov">     255568 :       return;</span>
<span class="lineNum">    1808 </span>            :     }
<span class="lineNum">    1809 </span><span class="lineCov">   13533236 :   else if (code == BIT_NOT_EXPR)</span>
<span class="lineNum">    1810 </span>            :     {
<span class="lineNum">    1811 </span>            :       /* ~X is simply -1 - X, so re-use existing code that also handles
<span class="lineNum">    1812 </span>            :          anti-ranges fine.  */
<span class="lineNum">    1813 </span><span class="lineCov">     305503 :       value_range minusone = VR_INITIALIZER;</span>
<span class="lineNum">    1814 </span><span class="lineCov">     611006 :       set_value_range_to_value (&amp;minusone, build_int_cst (type, -1), NULL);</span>
<span class="lineNum">    1815 </span><span class="lineCov">     305503 :       extract_range_from_binary_expr_1 (vr, MINUS_EXPR,</span>
<span class="lineNum">    1816 </span>            :                                         type, &amp;minusone, &amp;vr0);
<span class="lineNum">    1817 </span><span class="lineCov">     305503 :       return;</span>
<span class="lineNum">    1818 </span>            :     }
<span class="lineNum">    1819 </span>            : 
<span class="lineNum">    1820 </span>            :   /* Now canonicalize anti-ranges to ranges when they are not symbolic
<span class="lineNum">    1821 </span>            :      and express op ~[]  as (op []') U (op []'').  */
<span class="lineNum">    1822 </span><span class="lineCov">   13227733 :   if (vr0.type == VR_ANTI_RANGE</span>
<span class="lineNum">    1823 </span><span class="lineCov">   13227733 :       &amp;&amp; ranges_from_anti_range (&amp;vr0, &amp;vrtem0, &amp;vrtem1))</span>
<span class="lineNum">    1824 </span>            :     {
<span class="lineNum">    1825 </span><span class="lineCov">     463451 :       extract_range_from_unary_expr (vr, code, type, &amp;vrtem0, op0_type);</span>
<span class="lineNum">    1826 </span><span class="lineCov">     463451 :       if (vrtem1.type != VR_UNDEFINED)</span>
<span class="lineNum">    1827 </span>            :         {
<span class="lineNum">    1828 </span><span class="lineCov">     395750 :           value_range vrres = VR_INITIALIZER;</span>
<span class="lineNum">    1829 </span><span class="lineCov">     395750 :           extract_range_from_unary_expr (&amp;vrres, code, type,</span>
<span class="lineNum">    1830 </span>            :                                          &amp;vrtem1, op0_type);
<span class="lineNum">    1831 </span><span class="lineCov">     395750 :           vrp_meet (vr, &amp;vrres);</span>
<span class="lineNum">    1832 </span>            :         }
<span class="lineNum">    1833 </span><span class="lineCov">     463451 :       return;</span>
<span class="lineNum">    1834 </span>            :     }
<span class="lineNum">    1835 </span>            : 
<span class="lineNum">    1836 </span><span class="lineCov">   12764282 :   if (CONVERT_EXPR_CODE_P (code))</span>
<span class="lineNum">    1837 </span>            :     {
<span class="lineNum">    1838 </span><span class="lineCov">   12753834 :       tree inner_type = op0_type;</span>
<span class="lineNum">    1839 </span><span class="lineCov">   12753834 :       tree outer_type = type;</span>
<span class="lineNum">    1840 </span>            : 
<span class="lineNum">    1841 </span>            :       /* If the expression evaluates to a pointer, we are only interested in
<span class="lineNum">    1842 </span>            :          determining if it evaluates to NULL [0, 0] or non-NULL (~[0, 0]).  */
<span class="lineNum">    1843 </span><span class="lineCov">   12753834 :       if (POINTER_TYPE_P (type))</span>
<span class="lineNum">    1844 </span>            :         {
<span class="lineNum">    1845 </span><span class="lineCov">    1599120 :           if (!range_includes_zero_p (&amp;vr0))</span>
<span class="lineNum">    1846 </span><span class="lineCov">     407443 :             set_value_range_to_nonnull (vr, type);</span>
<span class="lineNum">    1847 </span><span class="lineCov">    1191677 :           else if (range_is_null (&amp;vr0))</span>
<span class="lineNum">    1848 </span><span class="lineCov">       2593 :             set_value_range_to_null (vr, type);</span>
<span class="lineNum">    1849 </span>            :           else
<span class="lineNum">    1850 </span><span class="lineCov">    1189084 :             set_value_range_to_varying (vr);</span>
<span class="lineNum">    1851 </span><span class="lineCov">    1599120 :           return;</span>
<span class="lineNum">    1852 </span>            :         }
<span class="lineNum">    1853 </span>            : 
<span class="lineNum">    1854 </span>            :       /* We normalize everything to a VR_RANGE, but for constant
<span class="lineNum">    1855 </span>            :          anti-ranges we must handle them by leaving the final result
<span class="lineNum">    1856 </span>            :          as an anti range.  This allows us to convert things like
<span class="lineNum">    1857 </span>            :          ~[0,5] seamlessly.  */
<span class="lineNum">    1858 </span><span class="lineCov">   11154714 :       value_range_type vr_type = VR_RANGE;</span>
<span class="lineNum">    1859 </span><span class="lineCov">   11154714 :       if (vr0.type == VR_ANTI_RANGE</span>
<span class="lineNum">    1860 </span><span class="lineCov">     376112 :           &amp;&amp; TREE_CODE (vr0.min) == INTEGER_CST</span>
<span class="lineNum">    1861 </span><span class="lineCov">     263354 :           &amp;&amp; TREE_CODE (vr0.max) == INTEGER_CST)</span>
<span class="lineNum">    1862 </span><span class="lineCov">     263354 :         vr_type = VR_ANTI_RANGE;</span>
<span class="lineNum">    1863 </span>            : 
<span class="lineNum">    1864 </span>            :       /* NOTES: Previously we were returning VARYING for all symbolics, but
<span class="lineNum">    1865 </span>            :          we can do better by treating them as [-MIN, +MAX].  For
<span class="lineNum">    1866 </span>            :          example, converting [SYM, SYM] from INT to LONG UNSIGNED,
<span class="lineNum">    1867 </span>            :          we can return: ~[0x8000000, 0xffffffff7fffffff].
<span class="lineNum">    1868 </span>            : 
<span class="lineNum">    1869 </span>            :          We were also failing to convert ~[0,0] from char* to unsigned,
<span class="lineNum">    1870 </span>            :          instead choosing to return VR_VARYING.  Now we return ~[0,0].  */
<span class="lineNum">    1871 </span><span class="lineCov">   44618856 :       wide_int vr0_min, vr0_max, wmin, wmax;</span>
<span class="lineNum">    1872 </span><span class="lineCov">   11154714 :       signop inner_sign = TYPE_SIGN (inner_type);</span>
<span class="lineNum">    1873 </span><span class="lineCov">   11154714 :       signop outer_sign = TYPE_SIGN (outer_type);</span>
<span class="lineNum">    1874 </span><span class="lineCov">   11154714 :       unsigned inner_prec = TYPE_PRECISION (inner_type);</span>
<span class="lineNum">    1875 </span><span class="lineCov">   11154714 :       unsigned outer_prec = TYPE_PRECISION (outer_type);</span>
<span class="lineNum">    1876 </span><span class="lineCov">   11154714 :       extract_range_into_wide_ints (&amp;vr0, inner_sign, inner_prec,</span>
<span class="lineNum">    1877 </span>            :                                     vr0_min, vr0_max);
<span class="lineNum">    1878 </span><span class="lineCov">   11154714 :       if (wide_int_range_convert (wmin, wmax,</span>
<span class="lineNum">    1879 </span>            :                                   inner_sign, inner_prec,
<span class="lineNum">    1880 </span>            :                                   outer_sign, outer_prec,
<span class="lineNum">    1881 </span>            :                                   vr0_min, vr0_max))
<span class="lineNum">    1882 </span>            :         {
<span class="lineNum">    1883 </span><span class="lineCov">   18246408 :           tree min = wide_int_to_tree (outer_type, wmin);</span>
<span class="lineNum">    1884 </span><span class="lineCov">   18246408 :           tree max = wide_int_to_tree (outer_type, wmax);</span>
<span class="lineNum">    1885 </span><span class="lineCov">    9123204 :           set_and_canonicalize_value_range (vr, vr_type, min, max, NULL);</span>
<span class="lineNum">    1886 </span>            :         }
<span class="lineNum">    1887 </span>            :       else
<span class="lineNum">    1888 </span><span class="lineCov">    2031510 :         set_value_range_to_varying (vr);</span>
<span class="lineNum">    1889 </span><span class="lineCov">   11154714 :       return;</span>
<span class="lineNum">    1890 </span>            :     }
<span class="lineNum">    1891 </span><span class="lineCov">      10448 :   else if (code == ABS_EXPR)</span>
<span class="lineNum">    1892 </span>            :     {
<span class="lineNum">    1893 </span><span class="lineCov">      19620 :       wide_int wmin, wmax;</span>
<span class="lineNum">    1894 </span><span class="lineCov">      19620 :       wide_int vr0_min, vr0_max;</span>
<span class="lineNum">    1895 </span><span class="lineCov">       9810 :       extract_range_into_wide_ints (&amp;vr0, sign, prec, vr0_min, vr0_max);</span>
<span class="lineNum">    1896 </span><span class="lineCov">       9810 :       if (wide_int_range_abs (wmin, wmax, sign, prec, vr0_min, vr0_max,</span>
<span class="lineNum">    1897 </span><span class="lineCov">       9810 :                               TYPE_OVERFLOW_UNDEFINED (type)))</span>
<span class="lineNum">    1898 </span><span class="lineCov">      19398 :         set_value_range (vr, VR_RANGE,</span>
<span class="lineNum">    1899 </span>            :                          wide_int_to_tree (type, wmin),
<span class="lineNum">    1900 </span>            :                          wide_int_to_tree (type, wmax), NULL);
<span class="lineNum">    1901 </span>            :       else
<span class="lineNum">    1902 </span><span class="lineCov">        111 :         set_value_range_to_varying (vr);</span>
<span class="lineNum">    1903 </span><span class="lineCov">       9810 :       return;</span>
<span class="lineNum">    1904 </span>            :     }
<span class="lineNum">    1905 </span>            : 
<span class="lineNum">    1906 </span>            :   /* For unhandled operations fall back to varying.  */
<span class="lineNum">    1907 </span><span class="lineCov">        638 :   set_value_range_to_varying (vr);</span>
<span class="lineNum">    1908 </span><span class="lineCov">        638 :   return;</span>
<span class="lineNum">    1909 </span>            : }
<span class="lineNum">    1910 </span>            : 
<span class="lineNum">    1911 </span>            : /* Debugging dumps.  */
<span class="lineNum">    1912 </span>            : 
<span class="lineNum">    1913 </span>            : void dump_value_range (FILE *, const value_range *);
<span class="lineNum">    1914 </span>            : void debug_value_range (const value_range *);
<span class="lineNum">    1915 </span>            : void dump_all_value_ranges (FILE *);
<span class="lineNum">    1916 </span>            : void dump_vr_equiv (FILE *, bitmap);
<span class="lineNum">    1917 </span>            : void debug_vr_equiv (bitmap);
<span class="lineNum">    1918 </span>            : 
<span class="lineNum">    1919 </span>            : 
<span class="lineNum">    1920 </span>            : /* Dump value range VR to FILE.  */
<a name="1921"><span class="lineNum">    1921 </span>            : </a>
<span class="lineNum">    1922 </span>            : void
<span class="lineNum">    1923 </span><span class="lineCov">      18098 : dump_value_range (FILE *file, const value_range *vr)</span>
<span class="lineNum">    1924 </span>            : {
<span class="lineNum">    1925 </span><span class="lineCov">      18098 :   if (vr == NULL)</span>
<span class="lineNum">    1926 </span><span class="lineCov">         17 :     fprintf (file, &quot;[]&quot;);</span>
<span class="lineNum">    1927 </span><span class="lineCov">      18081 :   else if (vr-&gt;type == VR_UNDEFINED)</span>
<span class="lineNum">    1928 </span><span class="lineCov">        968 :     fprintf (file, &quot;UNDEFINED&quot;);</span>
<span class="lineNum">    1929 </span><span class="lineCov">      17113 :   else if (vr-&gt;type == VR_RANGE || vr-&gt;type == VR_ANTI_RANGE)</span>
<span class="lineNum">    1930 </span>            :     {
<span class="lineNum">    1931 </span><span class="lineCov">      12257 :       tree type = TREE_TYPE (vr-&gt;min);</span>
<span class="lineNum">    1932 </span>            : 
<span class="lineNum">    1933 </span><span class="lineCov">      21752 :       fprintf (file, &quot;%s[&quot;, (vr-&gt;type == VR_ANTI_RANGE) ? &quot;~&quot; : &quot;&quot;);</span>
<span class="lineNum">    1934 </span>            : 
<span class="lineNum">    1935 </span><span class="lineCov">      12257 :       if (INTEGRAL_TYPE_P (type)</span>
<span class="lineNum">    1936 </span><span class="lineCov">      10133 :           &amp;&amp; !TYPE_UNSIGNED (type)</span>
<span class="lineNum">    1937 </span><span class="lineCov">      17798 :           &amp;&amp; vrp_val_is_min (vr-&gt;min))</span>
<span class="lineNum">    1938 </span><span class="lineCov">        493 :         fprintf (file, &quot;-INF&quot;);</span>
<span class="lineNum">    1939 </span>            :       else
<span class="lineNum">    1940 </span><span class="lineCov">      11764 :         print_generic_expr (file, vr-&gt;min);</span>
<span class="lineNum">    1941 </span>            : 
<span class="lineNum">    1942 </span><span class="lineCov">      12257 :       fprintf (file, &quot;, &quot;);</span>
<span class="lineNum">    1943 </span>            : 
<span class="lineNum">    1944 </span><span class="lineCov">      12257 :       if (INTEGRAL_TYPE_P (type)</span>
<span class="lineNum">    1945 </span><span class="lineCov">      12257 :           &amp;&amp; vrp_val_is_max (vr-&gt;max))</span>
<span class="lineNum">    1946 </span><span class="lineCov">       2930 :         fprintf (file, &quot;+INF&quot;);</span>
<span class="lineNum">    1947 </span>            :       else
<span class="lineNum">    1948 </span><span class="lineCov">       9327 :         print_generic_expr (file, vr-&gt;max);</span>
<span class="lineNum">    1949 </span>            : 
<span class="lineNum">    1950 </span><span class="lineCov">      12257 :       fprintf (file, &quot;]&quot;);</span>
<span class="lineNum">    1951 </span>            : 
<span class="lineNum">    1952 </span><span class="lineCov">      12257 :       if (vr-&gt;equiv)</span>
<span class="lineNum">    1953 </span>            :         {
<span class="lineNum">    1954 </span><span class="lineCov">       4330 :           bitmap_iterator bi;</span>
<span class="lineNum">    1955 </span><span class="lineCov">       4330 :           unsigned i, c = 0;</span>
<span class="lineNum">    1956 </span>            : 
<span class="lineNum">    1957 </span><span class="lineCov">       4330 :           fprintf (file, &quot;  EQUIVALENCES: { &quot;);</span>
<span class="lineNum">    1958 </span>            : 
<span class="lineNum">    1959 </span><span class="lineCov">       9317 :           EXECUTE_IF_SET_IN_BITMAP (vr-&gt;equiv, 0, i, bi)</span>
<span class="lineNum">    1960 </span>            :             {
<span class="lineNum">    1961 </span><span class="lineCov">       4987 :               print_generic_expr (file, ssa_name (i));</span>
<span class="lineNum">    1962 </span><span class="lineCov">       4987 :               fprintf (file, &quot; &quot;);</span>
<span class="lineNum">    1963 </span><span class="lineCov">       4987 :               c++;</span>
<span class="lineNum">    1964 </span>            :             }
<span class="lineNum">    1965 </span>            : 
<span class="lineNum">    1966 </span><span class="lineCov">       4330 :           fprintf (file, &quot;} (%u elements)&quot;, c);</span>
<span class="lineNum">    1967 </span>            :         }
<span class="lineNum">    1968 </span>            :     }
<span class="lineNum">    1969 </span><span class="lineCov">       4856 :   else if (vr-&gt;type == VR_VARYING)</span>
<span class="lineNum">    1970 </span><span class="lineCov">       4856 :     fprintf (file, &quot;VARYING&quot;);</span>
<span class="lineNum">    1971 </span>            :   else
<span class="lineNum">    1972 </span><span class="lineNoCov">          0 :     fprintf (file, &quot;INVALID RANGE&quot;);</span>
<span class="lineNum">    1973 </span><span class="lineCov">      18098 : }</span>
<span class="lineNum">    1974 </span>            : 
<span class="lineNum">    1975 </span>            : 
<span class="lineNum">    1976 </span>            : /* Dump value range VR to stderr.  */
<a name="1977"><span class="lineNum">    1977 </span>            : </a>
<span class="lineNum">    1978 </span>            : DEBUG_FUNCTION void
<span class="lineNum">    1979 </span><span class="lineNoCov">          0 : debug_value_range (const value_range *vr)</span>
<span class="lineNum">    1980 </span>            : {
<span class="lineNum">    1981 </span><span class="lineNoCov">          0 :   dump_value_range (stderr, vr);</span>
<span class="lineNum">    1982 </span><span class="lineNoCov">          0 :   fprintf (stderr, &quot;\n&quot;);</span>
<span class="lineNum">    1983 </span><span class="lineNoCov">          0 : }</span>
<a name="1984"><span class="lineNum">    1984 </span>            : </a>
<span class="lineNum">    1985 </span>            : void
<span class="lineNum">    1986 </span><span class="lineNoCov">          0 : value_range::dump () const</span>
<span class="lineNum">    1987 </span>            : {
<span class="lineNum">    1988 </span><span class="lineNoCov">          0 :   debug_value_range (this);</span>
<span class="lineNum">    1989 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1990 </span>            : 
<span class="lineNum">    1991 </span>            : 
<span class="lineNum">    1992 </span>            : /* Given a COND_EXPR COND of the form 'V OP W', and an SSA name V,
<span class="lineNum">    1993 </span>            :    create a new SSA name N and return the assertion assignment
<span class="lineNum">    1994 </span>            :    'N = ASSERT_EXPR &lt;V, V OP W&gt;'.  */
<a name="1995"><span class="lineNum">    1995 </span>            : </a>
<span class="lineNum">    1996 </span>            : static gimple *
<span class="lineNum">    1997 </span><span class="lineCov">    4748909 : build_assert_expr_for (tree cond, tree v)</span>
<span class="lineNum">    1998 </span>            : {
<span class="lineNum">    1999 </span><span class="lineCov">    4748909 :   tree a;</span>
<span class="lineNum">    2000 </span><span class="lineCov">    4748909 :   gassign *assertion;</span>
<span class="lineNum">    2001 </span>            : 
<span class="lineNum">    2002 </span><span class="lineCov">    4748909 :   gcc_assert (TREE_CODE (v) == SSA_NAME</span>
<span class="lineNum">    2003 </span>            :               &amp;&amp; COMPARISON_CLASS_P (cond));
<span class="lineNum">    2004 </span>            : 
<span class="lineNum">    2005 </span><span class="lineCov">    4748909 :   a = build2 (ASSERT_EXPR, TREE_TYPE (v), v, cond);</span>
<span class="lineNum">    2006 </span><span class="lineCov">    4748909 :   assertion = gimple_build_assign (NULL_TREE, a);</span>
<span class="lineNum">    2007 </span>            : 
<span class="lineNum">    2008 </span>            :   /* The new ASSERT_EXPR, creates a new SSA name that replaces the
<span class="lineNum">    2009 </span>            :      operand of the ASSERT_EXPR.  Create it so the new name and the old one
<span class="lineNum">    2010 </span>            :      are registered in the replacement table so that we can fix the SSA web
<span class="lineNum">    2011 </span>            :      after adding all the ASSERT_EXPRs.  */
<span class="lineNum">    2012 </span><span class="lineCov">    4748909 :   tree new_def = create_new_def_for (v, assertion, NULL);</span>
<span class="lineNum">    2013 </span>            :   /* Make sure we preserve abnormalness throughout an ASSERT_EXPR chain
<span class="lineNum">    2014 </span>            :      given we have to be able to fully propagate those out to re-create
<span class="lineNum">    2015 </span>            :      valid SSA when removing the asserts.  */
<span class="lineNum">    2016 </span><span class="lineCov">    4748909 :   if (SSA_NAME_OCCURS_IN_ABNORMAL_PHI (v))</span>
<span class="lineNum">    2017 </span><span class="lineCov">         80 :     SSA_NAME_OCCURS_IN_ABNORMAL_PHI (new_def) = 1;</span>
<span class="lineNum">    2018 </span>            : 
<span class="lineNum">    2019 </span><span class="lineCov">    4748909 :   return assertion;</span>
<span class="lineNum">    2020 </span>            : }
<span class="lineNum">    2021 </span>            : 
<span class="lineNum">    2022 </span>            : 
<span class="lineNum">    2023 </span>            : /* Return false if EXPR is a predicate expression involving floating
<span class="lineNum">    2024 </span>            :    point values.  */
<a name="2025"><span class="lineNum">    2025 </span>            : </a>
<span class="lineNum">    2026 </span>            : static inline bool
<span class="lineNum">    2027 </span><span class="lineCov">    4499474 : fp_predicate (gimple *stmt)</span>
<span class="lineNum">    2028 </span>            : {
<span class="lineNum">    2029 </span><span class="lineCov">    8998948 :   GIMPLE_CHECK (stmt, GIMPLE_COND);</span>
<span class="lineNum">    2030 </span>            : 
<span class="lineNum">    2031 </span><span class="lineCov">    8998948 :   return FLOAT_TYPE_P (TREE_TYPE (gimple_cond_lhs (stmt)));</span>
<span class="lineNum">    2032 </span>            : }
<span class="lineNum">    2033 </span>            : 
<span class="lineNum">    2034 </span>            : /* If the range of values taken by OP can be inferred after STMT executes,
<span class="lineNum">    2035 </span>            :    return the comparison code (COMP_CODE_P) and value (VAL_P) that
<span class="lineNum">    2036 </span>            :    describes the inferred range.  Return true if a range could be
<span class="lineNum">    2037 </span>            :    inferred.  */
<a name="2038"><span class="lineNum">    2038 </span>            : </a>
<span class="lineNum">    2039 </span>            : bool
<span class="lineNum">    2040 </span><span class="lineCov">  127397114 : infer_value_range (gimple *stmt, tree op, tree_code *comp_code_p, tree *val_p)</span>
<span class="lineNum">    2041 </span>            : {
<span class="lineNum">    2042 </span><span class="lineCov">  127397114 :   *val_p = NULL_TREE;</span>
<span class="lineNum">    2043 </span><span class="lineCov">  127397114 :   *comp_code_p = ERROR_MARK;</span>
<span class="lineNum">    2044 </span>            : 
<span class="lineNum">    2045 </span>            :   /* Do not attempt to infer anything in names that flow through
<span class="lineNum">    2046 </span>            :      abnormal edges.  */
<span class="lineNum">    2047 </span><span class="lineCov">  127397114 :   if (SSA_NAME_OCCURS_IN_ABNORMAL_PHI (op))</span>
<span class="lineNum">    2048 </span>            :     return false;
<span class="lineNum">    2049 </span>            : 
<span class="lineNum">    2050 </span>            :   /* If STMT is the last statement of a basic block with no normal
<span class="lineNum">    2051 </span>            :      successors, there is no point inferring anything about any of its
<span class="lineNum">    2052 </span>            :      operands.  We would not be able to find a proper insertion point
<span class="lineNum">    2053 </span>            :      for the assertion, anyway.  */
<span class="lineNum">    2054 </span><span class="lineCov">  127388503 :   if (stmt_ends_bb_p (stmt))</span>
<span class="lineNum">    2055 </span>            :     {
<span class="lineNum">    2056 </span><span class="lineCov">   24659968 :       edge_iterator ei;</span>
<span class="lineNum">    2057 </span><span class="lineCov">   24659968 :       edge e;</span>
<span class="lineNum">    2058 </span>            : 
<span class="lineNum">    2059 </span><span class="lineCov">   75977608 :       FOR_EACH_EDGE (e, ei, gimple_bb (stmt)-&gt;succs)</span>
<span class="lineNum">    2060 </span><span class="lineCov">   26479725 :         if (!(e-&gt;flags &amp; (EDGE_ABNORMAL|EDGE_EH)))</span>
<span class="lineNum">    2061 </span>            :           break;
<span class="lineNum">    2062 </span><span class="lineCov">   24659968 :       if (e == NULL)</span>
<span class="lineNum">    2063 </span><span class="lineCov">     177947 :         return false;</span>
<span class="lineNum">    2064 </span>            :     }
<span class="lineNum">    2065 </span>            : 
<span class="lineNum">    2066 </span><span class="lineCov">  127210556 :   if (infer_nonnull_range (stmt, op))</span>
<span class="lineNum">    2067 </span>            :     {
<span class="lineNum">    2068 </span><span class="lineCov">   37374532 :       *val_p = build_int_cst (TREE_TYPE (op), 0);</span>
<span class="lineNum">    2069 </span><span class="lineCov">   18687266 :       *comp_code_p = NE_EXPR;</span>
<span class="lineNum">    2070 </span><span class="lineCov">   18687266 :       return true;</span>
<span class="lineNum">    2071 </span>            :     }
<span class="lineNum">    2072 </span>            : 
<span class="lineNum">    2073 </span>            :   return false;
<span class="lineNum">    2074 </span>            : }
<span class="lineNum">    2075 </span>            : 
<span class="lineNum">    2076 </span>            : 
<span class="lineNum">    2077 </span>            : void dump_asserts_for (FILE *, tree);
<span class="lineNum">    2078 </span>            : void debug_asserts_for (tree);
<span class="lineNum">    2079 </span>            : void dump_all_asserts (FILE *);
<span class="lineNum">    2080 </span>            : void debug_all_asserts (void);
<span class="lineNum">    2081 </span>            : 
<span class="lineNum">    2082 </span>            : /* Dump all the registered assertions for NAME to FILE.  */
<a name="2083"><span class="lineNum">    2083 </span>            : </a>
<span class="lineNum">    2084 </span>            : void
<span class="lineNum">    2085 </span><span class="lineCov">         83 : dump_asserts_for (FILE *file, tree name)</span>
<span class="lineNum">    2086 </span>            : {
<span class="lineNum">    2087 </span><span class="lineCov">         83 :   assert_locus *loc;</span>
<span class="lineNum">    2088 </span>            : 
<span class="lineNum">    2089 </span><span class="lineCov">         83 :   fprintf (file, &quot;Assertions to be inserted for &quot;);</span>
<span class="lineNum">    2090 </span><span class="lineCov">         83 :   print_generic_expr (file, name);</span>
<span class="lineNum">    2091 </span><span class="lineCov">         83 :   fprintf (file, &quot;\n&quot;);</span>
<span class="lineNum">    2092 </span>            : 
<span class="lineNum">    2093 </span><span class="lineCov">         83 :   loc = asserts_for[SSA_NAME_VERSION (name)];</span>
<span class="lineNum">    2094 </span><span class="lineCov">        204 :   while (loc)</span>
<span class="lineNum">    2095 </span>            :     {
<span class="lineNum">    2096 </span><span class="lineCov">        121 :       fprintf (file, &quot;\t&quot;);</span>
<span class="lineNum">    2097 </span><span class="lineCov">        242 :       print_gimple_stmt (file, gsi_stmt (loc-&gt;si), 0);</span>
<span class="lineNum">    2098 </span><span class="lineCov">        121 :       fprintf (file, &quot;\n\tBB #%d&quot;, loc-&gt;bb-&gt;index);</span>
<span class="lineNum">    2099 </span><span class="lineCov">        121 :       if (loc-&gt;e)</span>
<span class="lineNum">    2100 </span>            :         {
<span class="lineNum">    2101 </span><span class="lineCov">        220 :           fprintf (file, &quot;\n\tEDGE %d-&gt;%d&quot;, loc-&gt;e-&gt;src-&gt;index,</span>
<span class="lineNum">    2102 </span><span class="lineCov">        110 :                    loc-&gt;e-&gt;dest-&gt;index);</span>
<span class="lineNum">    2103 </span><span class="lineCov">        110 :           dump_edge_info (file, loc-&gt;e, dump_flags, 0);</span>
<span class="lineNum">    2104 </span>            :         }
<span class="lineNum">    2105 </span><span class="lineCov">        121 :       fprintf (file, &quot;\n\tPREDICATE: &quot;);</span>
<span class="lineNum">    2106 </span><span class="lineCov">        121 :       print_generic_expr (file, loc-&gt;expr);</span>
<span class="lineNum">    2107 </span><span class="lineCov">        121 :       fprintf (file, &quot; %s &quot;, get_tree_code_name (loc-&gt;comp_code));</span>
<span class="lineNum">    2108 </span><span class="lineCov">        121 :       print_generic_expr (file, loc-&gt;val);</span>
<span class="lineNum">    2109 </span><span class="lineCov">        121 :       fprintf (file, &quot;\n\n&quot;);</span>
<span class="lineNum">    2110 </span><span class="lineCov">        121 :       loc = loc-&gt;next;</span>
<span class="lineNum">    2111 </span>            :     }
<span class="lineNum">    2112 </span>            : 
<span class="lineNum">    2113 </span><span class="lineCov">         83 :   fprintf (file, &quot;\n&quot;);</span>
<span class="lineNum">    2114 </span><span class="lineCov">         83 : }</span>
<span class="lineNum">    2115 </span>            : 
<span class="lineNum">    2116 </span>            : 
<span class="lineNum">    2117 </span>            : /* Dump all the registered assertions for NAME to stderr.  */
<a name="2118"><span class="lineNum">    2118 </span>            : </a>
<span class="lineNum">    2119 </span>            : DEBUG_FUNCTION void
<span class="lineNum">    2120 </span><span class="lineNoCov">          0 : debug_asserts_for (tree name)</span>
<span class="lineNum">    2121 </span>            : {
<span class="lineNum">    2122 </span><span class="lineNoCov">          0 :   dump_asserts_for (stderr, name);</span>
<span class="lineNum">    2123 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    2124 </span>            : 
<span class="lineNum">    2125 </span>            : 
<span class="lineNum">    2126 </span>            : /* Dump all the registered assertions for all the names to FILE.  */
<a name="2127"><span class="lineNum">    2127 </span>            : </a>
<span class="lineNum">    2128 </span>            : void
<span class="lineNum">    2129 </span><span class="lineCov">         27 : dump_all_asserts (FILE *file)</span>
<span class="lineNum">    2130 </span>            : {
<span class="lineNum">    2131 </span><span class="lineCov">         27 :   unsigned i;</span>
<span class="lineNum">    2132 </span><span class="lineCov">         27 :   bitmap_iterator bi;</span>
<span class="lineNum">    2133 </span>            : 
<span class="lineNum">    2134 </span><span class="lineCov">         27 :   fprintf (file, &quot;\nASSERT_EXPRs to be inserted\n\n&quot;);</span>
<span class="lineNum">    2135 </span><span class="lineCov">        110 :   EXECUTE_IF_SET_IN_BITMAP (need_assert_for, 0, i, bi)</span>
<span class="lineNum">    2136 </span><span class="lineCov">         83 :     dump_asserts_for (file, ssa_name (i));</span>
<span class="lineNum">    2137 </span><span class="lineCov">         27 :   fprintf (file, &quot;\n&quot;);</span>
<span class="lineNum">    2138 </span><span class="lineCov">         27 : }</span>
<span class="lineNum">    2139 </span>            : 
<span class="lineNum">    2140 </span>            : 
<span class="lineNum">    2141 </span>            : /* Dump all the registered assertions for all the names to stderr.  */
<a name="2142"><span class="lineNum">    2142 </span>            : </a>
<span class="lineNum">    2143 </span>            : DEBUG_FUNCTION void
<span class="lineNum">    2144 </span><span class="lineNoCov">          0 : debug_all_asserts (void)</span>
<span class="lineNum">    2145 </span>            : {
<span class="lineNum">    2146 </span><span class="lineNoCov">          0 :   dump_all_asserts (stderr);</span>
<span class="lineNum">    2147 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    2148 </span>            : 
<span class="lineNum">    2149 </span>            : /* Push the assert info for NAME, EXPR, COMP_CODE and VAL to ASSERTS.  */
<a name="2150"><span class="lineNum">    2150 </span>            : </a>
<span class="lineNum">    2151 </span>            : static void
<span class="lineNum">    2152 </span><span class="lineCov">   28737787 : add_assert_info (vec&lt;assert_info&gt; &amp;asserts,</span>
<span class="lineNum">    2153 </span>            :                  tree name, tree expr, enum tree_code comp_code, tree val)
<span class="lineNum">    2154 </span>            : {
<span class="lineNum">    2155 </span><span class="lineCov">   28737787 :   assert_info info;</span>
<span class="lineNum">    2156 </span><span class="lineCov">   28737787 :   info.comp_code = comp_code;</span>
<span class="lineNum">    2157 </span><span class="lineCov">   28737787 :   info.name = name;</span>
<span class="lineNum">    2158 </span><span class="lineCov">   28737787 :   if (TREE_OVERFLOW_P (val))</span>
<span class="lineNum">    2159 </span><span class="lineCov">       2436 :     val = drop_tree_overflow (val);</span>
<span class="lineNum">    2160 </span><span class="lineCov">   28737787 :   info.val = val;</span>
<span class="lineNum">    2161 </span><span class="lineCov">   28737787 :   info.expr = expr;</span>
<span class="lineNum">    2162 </span><span class="lineCov">   28737787 :   asserts.safe_push (info);</span>
<span class="lineNum">    2163 </span><span class="lineCov">   28737787 : }</span>
<span class="lineNum">    2164 </span>            : 
<span class="lineNum">    2165 </span>            : /* If NAME doesn't have an ASSERT_EXPR registered for asserting
<span class="lineNum">    2166 </span>            :    'EXPR COMP_CODE VAL' at a location that dominates block BB or
<span class="lineNum">    2167 </span>            :    E-&gt;DEST, then register this location as a possible insertion point
<span class="lineNum">    2168 </span>            :    for ASSERT_EXPR &lt;NAME, EXPR COMP_CODE VAL&gt;.
<span class="lineNum">    2169 </span>            : 
<span class="lineNum">    2170 </span>            :    BB, E and SI provide the exact insertion point for the new
<span class="lineNum">    2171 </span>            :    ASSERT_EXPR.  If BB is NULL, then the ASSERT_EXPR is to be inserted
<span class="lineNum">    2172 </span>            :    on edge E.  Otherwise, if E is NULL, the ASSERT_EXPR is inserted on
<span class="lineNum">    2173 </span>            :    BB.  If SI points to a COND_EXPR or a SWITCH_EXPR statement, then E
<span class="lineNum">    2174 </span>            :    must not be NULL.  */
<a name="2175"><span class="lineNum">    2175 </span>            : </a>
<span class="lineNum">    2176 </span>            : static void
<span class="lineNum">    2177 </span><span class="lineCov">    6751841 : register_new_assert_for (tree name, tree expr,</span>
<span class="lineNum">    2178 </span>            :                          enum tree_code comp_code,
<span class="lineNum">    2179 </span>            :                          tree val,
<span class="lineNum">    2180 </span>            :                          basic_block bb,
<span class="lineNum">    2181 </span>            :                          edge e,
<span class="lineNum">    2182 </span>            :                          gimple_stmt_iterator si)
<span class="lineNum">    2183 </span>            : {
<span class="lineNum">    2184 </span><span class="lineCov">    6751841 :   assert_locus *n, *loc, *last_loc;</span>
<span class="lineNum">    2185 </span><span class="lineCov">    6751841 :   basic_block dest_bb;</span>
<span class="lineNum">    2186 </span>            : 
<span class="lineNum">    2187 </span><span class="lineCov">    6751841 :   gcc_checking_assert (bb == NULL || e == NULL);</span>
<span class="lineNum">    2188 </span>            : 
<span class="lineNum">    2189 </span><span class="lineCov">    6751841 :   if (e == NULL)</span>
<span class="lineNum">    2190 </span><span class="lineCov">    9941130 :     gcc_checking_assert (gimple_code (gsi_stmt (si)) != GIMPLE_COND</span>
<span class="lineNum">    2191 </span>            :                          &amp;&amp; gimple_code (gsi_stmt (si)) != GIMPLE_SWITCH);
<span class="lineNum">    2192 </span>            : 
<span class="lineNum">    2193 </span>            :   /* Never build an assert comparing against an integer constant with
<span class="lineNum">    2194 </span>            :      TREE_OVERFLOW set.  This confuses our undefined overflow warning
<span class="lineNum">    2195 </span>            :      machinery.  */
<span class="lineNum">    2196 </span><span class="lineCov">    6751841 :   if (TREE_OVERFLOW_P (val))</span>
<span class="lineNum">    2197 </span><span class="lineNoCov">          0 :     val = drop_tree_overflow (val);</span>
<span class="lineNum">    2198 </span>            : 
<span class="lineNum">    2199 </span>            :   /* The new assertion A will be inserted at BB or E.  We need to
<span class="lineNum">    2200 </span>            :      determine if the new location is dominated by a previously
<span class="lineNum">    2201 </span>            :      registered location for A.  If we are doing an edge insertion,
<span class="lineNum">    2202 </span>            :      assume that A will be inserted at E-&gt;DEST.  Note that this is not
<span class="lineNum">    2203 </span>            :      necessarily true.
<span class="lineNum">    2204 </span>            : 
<span class="lineNum">    2205 </span>            :      If E is a critical edge, it will be split.  But even if E is
<span class="lineNum">    2206 </span>            :      split, the new block will dominate the same set of blocks that
<span class="lineNum">    2207 </span>            :      E-&gt;DEST dominates.
<span class="lineNum">    2208 </span>            : 
<span class="lineNum">    2209 </span>            :      The reverse, however, is not true, blocks dominated by E-&gt;DEST
<span class="lineNum">    2210 </span>            :      will not be dominated by the new block created to split E.  So,
<span class="lineNum">    2211 </span>            :      if the insertion location is on a critical edge, we will not use
<span class="lineNum">    2212 </span>            :      the new location to move another assertion previously registered
<span class="lineNum">    2213 </span>            :      at a block dominated by E-&gt;DEST.  */
<span class="lineNum">    2214 </span><span class="lineCov">    6751841 :   dest_bb = (bb) ? bb : e-&gt;dest;</span>
<span class="lineNum">    2215 </span>            : 
<span class="lineNum">    2216 </span>            :   /* If NAME already has an ASSERT_EXPR registered for COMP_CODE and
<span class="lineNum">    2217 </span>            :      VAL at a block dominating DEST_BB, then we don't need to insert a new
<span class="lineNum">    2218 </span>            :      one.  Similarly, if the same assertion already exists at a block
<span class="lineNum">    2219 </span>            :      dominated by DEST_BB and the new location is not on a critical
<span class="lineNum">    2220 </span>            :      edge, then update the existing location for the assertion (i.e.,
<span class="lineNum">    2221 </span>            :      move the assertion up in the dominance tree).
<span class="lineNum">    2222 </span>            : 
<span class="lineNum">    2223 </span>            :      Note, this is implemented as a simple linked list because there
<span class="lineNum">    2224 </span>            :      should not be more than a handful of assertions registered per
<span class="lineNum">    2225 </span>            :      name.  If this becomes a performance problem, a table hashed by
<span class="lineNum">    2226 </span>            :      COMP_CODE and VAL could be implemented.  */
<span class="lineNum">    2227 </span><span class="lineCov">    6751841 :   loc = asserts_for[SSA_NAME_VERSION (name)];</span>
<span class="lineNum">    2228 </span><span class="lineCov">    6751841 :   last_loc = loc;</span>
<span class="lineNum">    2229 </span><span class="lineCov">   24515040 :   while (loc)</span>
<span class="lineNum">    2230 </span>            :     {
<span class="lineNum">    2231 </span><span class="lineCov">   19761054 :       if (loc-&gt;comp_code == comp_code</span>
<span class="lineNum">    2232 </span><span class="lineCov">   12447067 :           &amp;&amp; (loc-&gt;val == val</span>
<span class="lineNum">    2233 </span><span class="lineCov">    5942947 :               || operand_equal_p (loc-&gt;val, val, 0))</span>
<span class="lineNum">    2234 </span><span class="lineCov">   26335693 :           &amp;&amp; (loc-&gt;expr == expr</span>
<span class="lineNum">    2235 </span><span class="lineCov">      31941 :               || operand_equal_p (loc-&gt;expr, expr, 0)))</span>
<span class="lineNum">    2236 </span>            :         {
<span class="lineNum">    2237 </span>            :           /* If E is not a critical edge and DEST_BB
<span class="lineNum">    2238 </span>            :              dominates the existing location for the assertion, move
<span class="lineNum">    2239 </span>            :              the assertion up in the dominance tree by updating its
<span class="lineNum">    2240 </span>            :              location information.  */
<span class="lineNum">    2241 </span><span class="lineCov">     429042 :           if ((e == NULL || !EDGE_CRITICAL_P (e))</span>
<span class="lineNum">    2242 </span><span class="lineCov">    6872200 :               &amp;&amp; dominated_by_p (CDI_DOMINATORS, loc-&gt;bb, dest_bb))</span>
<span class="lineNum">    2243 </span>            :             {
<span class="lineNum">    2244 </span><span class="lineCov">    1997855 :               loc-&gt;bb = dest_bb;</span>
<span class="lineNum">    2245 </span><span class="lineCov">    1997855 :               loc-&gt;e = e;</span>
<span class="lineNum">    2246 </span><span class="lineCov">    1997855 :               loc-&gt;si = si;</span>
<span class="lineNum">    2247 </span><span class="lineCov">    1997855 :               return;</span>
<span class="lineNum">    2248 </span>            :             }
<span class="lineNum">    2249 </span>            :         }
<span class="lineNum">    2250 </span>            : 
<span class="lineNum">    2251 </span>            :       /* Update the last node of the list and move to the next one.  */
<span class="lineNum">    2252 </span><span class="lineCov">   17763199 :       last_loc = loc;</span>
<span class="lineNum">    2253 </span><span class="lineCov">   17763199 :       loc = loc-&gt;next;</span>
<span class="lineNum">    2254 </span>            :     }
<span class="lineNum">    2255 </span>            : 
<span class="lineNum">    2256 </span>            :   /* If we didn't find an assertion already registered for
<span class="lineNum">    2257 </span>            :      NAME COMP_CODE VAL, add a new one at the end of the list of
<span class="lineNum">    2258 </span>            :      assertions associated with NAME.  */
<span class="lineNum">    2259 </span><span class="lineCov">    4753986 :   n = XNEW (struct assert_locus);</span>
<span class="lineNum">    2260 </span><span class="lineCov">    4753986 :   n-&gt;bb = dest_bb;</span>
<span class="lineNum">    2261 </span><span class="lineCov">    4753986 :   n-&gt;e = e;</span>
<span class="lineNum">    2262 </span><span class="lineCov">    4753986 :   n-&gt;si = si;</span>
<span class="lineNum">    2263 </span><span class="lineCov">    4753986 :   n-&gt;comp_code = comp_code;</span>
<span class="lineNum">    2264 </span><span class="lineCov">    4753986 :   n-&gt;val = val;</span>
<span class="lineNum">    2265 </span><span class="lineCov">    4753986 :   n-&gt;expr = expr;</span>
<span class="lineNum">    2266 </span><span class="lineCov">    4753986 :   n-&gt;next = NULL;</span>
<span class="lineNum">    2267 </span>            : 
<span class="lineNum">    2268 </span><span class="lineCov">    4753986 :   if (last_loc)</span>
<span class="lineNum">    2269 </span><span class="lineCov">    1760182 :     last_loc-&gt;next = n;</span>
<span class="lineNum">    2270 </span>            :   else
<span class="lineNum">    2271 </span><span class="lineCov">    2993804 :     asserts_for[SSA_NAME_VERSION (name)] = n;</span>
<span class="lineNum">    2272 </span>            : 
<span class="lineNum">    2273 </span><span class="lineCov">    4753986 :   bitmap_set_bit (need_assert_for, SSA_NAME_VERSION (name));</span>
<span class="lineNum">    2274 </span>            : }
<span class="lineNum">    2275 </span>            : 
<span class="lineNum">    2276 </span>            : /* (COND_OP0 COND_CODE COND_OP1) is a predicate which uses NAME.
<span class="lineNum">    2277 </span>            :    Extract a suitable test code and value and store them into *CODE_P and
<span class="lineNum">    2278 </span>            :    *VAL_P so the predicate is normalized to NAME *CODE_P *VAL_P.
<span class="lineNum">    2279 </span>            : 
<span class="lineNum">    2280 </span>            :    If no extraction was possible, return FALSE, otherwise return TRUE.
<span class="lineNum">    2281 </span>            : 
<span class="lineNum">    2282 </span>            :    If INVERT is true, then we invert the result stored into *CODE_P.  */
<a name="2283"><span class="lineNum">    2283 </span>            : </a>
<span class="lineNum">    2284 </span>            : static bool
<span class="lineNum">    2285 </span><span class="lineCov">   50385785 : extract_code_and_val_from_cond_with_ops (tree name, enum tree_code cond_code,</span>
<span class="lineNum">    2286 </span>            :                                          tree cond_op0, tree cond_op1,
<span class="lineNum">    2287 </span>            :                                          bool invert, enum tree_code *code_p,
<span class="lineNum">    2288 </span>            :                                          tree *val_p)
<span class="lineNum">    2289 </span>            : {
<span class="lineNum">    2290 </span><span class="lineCov">   50385785 :   enum tree_code comp_code;</span>
<span class="lineNum">    2291 </span><span class="lineCov">   50385785 :   tree val;</span>
<span class="lineNum">    2292 </span>            : 
<span class="lineNum">    2293 </span>            :   /* Otherwise, we have a comparison of the form NAME COMP VAL
<span class="lineNum">    2294 </span>            :      or VAL COMP NAME.  */
<span class="lineNum">    2295 </span><span class="lineCov">   50385785 :   if (name == cond_op1)</span>
<span class="lineNum">    2296 </span>            :     {
<span class="lineNum">    2297 </span>            :       /* If the predicate is of the form VAL COMP NAME, flip
<span class="lineNum">    2298 </span>            :          COMP around because we need to register NAME as the
<span class="lineNum">    2299 </span>            :          first operand in the predicate.  */
<span class="lineNum">    2300 </span><span class="lineCov">   10473153 :       comp_code = swap_tree_comparison (cond_code);</span>
<span class="lineNum">    2301 </span><span class="lineCov">   10473153 :       val = cond_op0;</span>
<span class="lineNum">    2302 </span>            :     }
<span class="lineNum">    2303 </span><span class="lineCov">   39912632 :   else if (name == cond_op0)</span>
<span class="lineNum">    2304 </span>            :     {
<span class="lineNum">    2305 </span>            :       /* The comparison is of the form NAME COMP VAL, so the
<span class="lineNum">    2306 </span>            :          comparison code remains unchanged.  */
<span class="lineNum">    2307 </span>            :       comp_code = cond_code;
<span class="lineNum">    2308 </span>            :       val = cond_op1;
<span class="lineNum">    2309 </span>            :     }
<span class="lineNum">    2310 </span>            :   else
<span class="lineNum">    2311 </span><span class="lineNoCov">          0 :     gcc_unreachable ();</span>
<span class="lineNum">    2312 </span>            : 
<span class="lineNum">    2313 </span>            :   /* Invert the comparison code as necessary.  */
<span class="lineNum">    2314 </span><span class="lineCov">   50385785 :   if (invert)</span>
<span class="lineNum">    2315 </span><span class="lineCov">   24982544 :     comp_code = invert_tree_comparison (comp_code, 0);</span>
<span class="lineNum">    2316 </span>            : 
<span class="lineNum">    2317 </span>            :   /* VRP only handles integral and pointer types.  */
<span class="lineNum">    2318 </span><span class="lineCov">  149485325 :   if (! INTEGRAL_TYPE_P (TREE_TYPE (val))</span>
<span class="lineNum">    2319 </span><span class="lineCov">   69382225 :       &amp;&amp; ! POINTER_TYPE_P (TREE_TYPE (val)))</span>
<span class="lineNum">    2320 </span>            :     return false;
<span class="lineNum">    2321 </span>            : 
<span class="lineNum">    2322 </span>            :   /* Do not register always-false predicates.
<span class="lineNum">    2323 </span>            :      FIXME:  this works around a limitation in fold() when dealing with
<span class="lineNum">    2324 </span>            :      enumerations.  Given 'enum { N1, N2 } x;', fold will not
<span class="lineNum">    2325 </span>            :      fold 'if (x &gt; N2)' to 'if (0)'.  */
<span class="lineNum">    2326 </span><span class="lineCov">   50172946 :   if ((comp_code == GT_EXPR || comp_code == LT_EXPR)</span>
<span class="lineNum">    2327 </span><span class="lineCov">   50172946 :       &amp;&amp; INTEGRAL_TYPE_P (TREE_TYPE (val)))</span>
<span class="lineNum">    2328 </span>            :     {
<span class="lineNum">    2329 </span><span class="lineCov">   13914284 :       tree min = TYPE_MIN_VALUE (TREE_TYPE (val));</span>
<span class="lineNum">    2330 </span><span class="lineCov">   13914284 :       tree max = TYPE_MAX_VALUE (TREE_TYPE (val));</span>
<span class="lineNum">    2331 </span>            : 
<span class="lineNum">    2332 </span><span class="lineCov">    6957142 :       if (comp_code == GT_EXPR</span>
<span class="lineNum">    2333 </span><span class="lineCov">    6957142 :           &amp;&amp; (!max</span>
<span class="lineNum">    2334 </span><span class="lineCov">    4186324 :               || compare_values (val, max) == 0))</span>
<span class="lineNum">    2335 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">    2336 </span>            : 
<span class="lineNum">    2337 </span><span class="lineCov">    6957142 :       if (comp_code == LT_EXPR</span>
<span class="lineNum">    2338 </span><span class="lineCov">    6957142 :           &amp;&amp; (!min</span>
<span class="lineNum">    2339 </span><span class="lineCov">    2770818 :               || compare_values (val, min) == 0))</span>
<span class="lineNum">    2340 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">    2341 </span>            :     }
<span class="lineNum">    2342 </span><span class="lineCov">   50172946 :   *code_p = comp_code;</span>
<span class="lineNum">    2343 </span><span class="lineCov">   50172946 :   *val_p = val;</span>
<span class="lineNum">    2344 </span><span class="lineCov">   50172946 :   return true;</span>
<span class="lineNum">    2345 </span>            : }
<span class="lineNum">    2346 </span>            : 
<span class="lineNum">    2347 </span>            : /* Find out smallest RES where RES &gt; VAL &amp;&amp; (RES &amp; MASK) == RES, if any
<span class="lineNum">    2348 </span>            :    (otherwise return VAL).  VAL and MASK must be zero-extended for
<span class="lineNum">    2349 </span>            :    precision PREC.  If SGNBIT is non-zero, first xor VAL with SGNBIT
<span class="lineNum">    2350 </span>            :    (to transform signed values into unsigned) and at the end xor
<span class="lineNum">    2351 </span>            :    SGNBIT back.  */
<span class="lineNum">    2352 </span>            : 
<span class="lineNum">    2353 </span>            : static wide_int
<span class="lineNum">    2354 </span><span class="lineCov">     348326 : masked_increment (const wide_int &amp;val_in, const wide_int &amp;mask,</span>
<span class="lineNum">    2355 </span>            :                   const wide_int &amp;sgnbit, unsigned int prec)
<span class="lineNum">    2356 </span>            : {
<span class="lineNum">    2357 </span><span class="lineCov">     571451 :   wide_int bit = wi::one (prec), res;</span>
<span class="lineNum">    2358 </span><span class="lineCov">     348326 :   unsigned int i;</span>
<span class="lineNum">    2359 </span>            : 
<span class="lineNum">    2360 </span><span class="lineCov">     348326 :   wide_int val = val_in ^ sgnbit;</span>
<span class="lineNum">    2361 </span><span class="lineCov">    1767196 :   for (i = 0; i &lt; prec; i++, bit += bit)</span>
<span class="lineNum">    2362 </span>            :     {
<span class="lineNum">    2363 </span><span class="lineCov">    1767190 :       res = mask;</span>
<span class="lineNum">    2364 </span><span class="lineCov">    2115897 :       if ((res &amp; bit) == 0)</span>
<span class="lineNum">    2365 </span><span class="lineCov">    1418480 :         continue;</span>
<span class="lineNum">    2366 </span><span class="lineCov">     348710 :       res = bit - 1;</span>
<span class="lineNum">    2367 </span><span class="lineCov">     348710 :       res = wi::bit_and_not (val + bit, res);</span>
<span class="lineNum">    2368 </span><span class="lineCov">     348710 :       res &amp;= mask;</span>
<span class="lineNum">    2369 </span><span class="lineCov">     348710 :       if (wi::gtu_p (res, val))</span>
<span class="lineNum">    2370 </span><span class="lineCov">     348320 :         return res ^ sgnbit;</span>
<span class="lineNum">    2371 </span>            :     }
<span class="lineNum">    2372 </span><span class="lineCov">          6 :   return val ^ sgnbit;</span>
<span class="lineNum">    2373 </span>            : }
<span class="lineNum">    2374 </span>            : 
<span class="lineNum">    2375 </span>            : /* Helper for overflow_comparison_p
<span class="lineNum">    2376 </span>            : 
<span class="lineNum">    2377 </span>            :    OP0 CODE OP1 is a comparison.  Examine the comparison and potentially
<span class="lineNum">    2378 </span>            :    OP1's defining statement to see if it ultimately has the form
<span class="lineNum">    2379 </span>            :    OP0 CODE (OP0 PLUS INTEGER_CST)
<span class="lineNum">    2380 </span>            : 
<span class="lineNum">    2381 </span>            :    If so, return TRUE indicating this is an overflow test and store into
<span class="lineNum">    2382 </span>            :    *NEW_CST an updated constant that can be used in a narrowed range test.
<span class="lineNum">    2383 </span>            : 
<span class="lineNum">    2384 </span>            :    REVERSED indicates if the comparison was originally:
<span class="lineNum">    2385 </span>            : 
<span class="lineNum">    2386 </span>            :    OP1 CODE' OP0.
<span class="lineNum">    2387 </span>            : 
<span class="lineNum">    2388 </span>            :    This affects how we build the updated constant.  */
<span class="lineNum">    2389 </span>            : 
<span class="lineNum">    2390 </span>            : static bool
<span class="lineNum">    2391 </span><span class="lineCov">  106839298 : overflow_comparison_p_1 (enum tree_code code, tree op0, tree op1,</span>
<span class="lineNum">    2392 </span>            :                          bool follow_assert_exprs, bool reversed, tree *new_cst)
<span class="lineNum">    2393 </span>            : {
<span class="lineNum">    2394 </span>            :   /* See if this is a relational operation between two SSA_NAMES with
<span class="lineNum">    2395 </span>            :      unsigned, overflow wrapping values.  If so, check it more deeply.  */
<span class="lineNum">    2396 </span><span class="lineCov">  106839298 :   if ((code == LT_EXPR || code == LE_EXPR</span>
<span class="lineNum">    2397 </span><span class="lineCov">   85300379 :        || code == GE_EXPR || code == GT_EXPR)</span>
<span class="lineNum">    2398 </span><span class="lineCov">   30486218 :       &amp;&amp; TREE_CODE (op0) == SSA_NAME</span>
<span class="lineNum">    2399 </span><span class="lineCov">   24006302 :       &amp;&amp; TREE_CODE (op1) == SSA_NAME</span>
<span class="lineNum">    2400 </span><span class="lineCov">   17526840 :       &amp;&amp; INTEGRAL_TYPE_P (TREE_TYPE (op0))</span>
<span class="lineNum">    2401 </span><span class="lineCov">   32834536 :       &amp;&amp; TYPE_UNSIGNED (TREE_TYPE (op0))</span>
<span class="lineNum">    2402 </span><span class="lineCov">  115646202 :       &amp;&amp; TYPE_OVERFLOW_WRAPS (TREE_TYPE (op0)))</span>
<span class="lineNum">    2403 </span>            :     {
<span class="lineNum">    2404 </span><span class="lineCov">    4403452 :       gimple *op1_def = SSA_NAME_DEF_STMT (op1);</span>
<span class="lineNum">    2405 </span>            : 
<span class="lineNum">    2406 </span>            :       /* If requested, follow any ASSERT_EXPRs backwards for OP1.  */
<span class="lineNum">    2407 </span><span class="lineCov">    4403452 :       if (follow_assert_exprs)</span>
<span class="lineNum">    2408 </span>            :         {
<span class="lineNum">    2409 </span><span class="lineCov">     955058 :           while (gimple_assign_single_p (op1_def)</span>
<span class="lineNum">    2410 </span><span class="lineCov">     555108 :                  &amp;&amp; TREE_CODE (gimple_assign_rhs1 (op1_def)) == ASSERT_EXPR)</span>
<span class="lineNum">    2411 </span>            :             {
<span class="lineNum">    2412 </span><span class="lineCov">     211012 :               op1 = TREE_OPERAND (gimple_assign_rhs1 (op1_def), 0);</span>
<span class="lineNum">    2413 </span><span class="lineCov">     105506 :               if (TREE_CODE (op1) != SSA_NAME)</span>
<span class="lineNum">    2414 </span>            :                 break;
<span class="lineNum">    2415 </span><span class="lineCov">     211004 :               op1_def = SSA_NAME_DEF_STMT (op1);</span>
<span class="lineNum">    2416 </span>            :             }
<span class="lineNum">    2417 </span>            :         }
<span class="lineNum">    2418 </span>            : 
<span class="lineNum">    2419 </span>            :       /* Now look at the defining statement of OP1 to see if it adds
<span class="lineNum">    2420 </span>            :          or subtracts a nonzero constant from another operand.  */
<span class="lineNum">    2421 </span><span class="lineCov">    4403452 :       if (op1_def</span>
<span class="lineNum">    2422 </span><span class="lineCov">    8806904 :           &amp;&amp; is_gimple_assign (op1_def)</span>
<span class="lineNum">    2423 </span><span class="lineCov">    3294986 :           &amp;&amp; gimple_assign_rhs_code (op1_def) == PLUS_EXPR</span>
<span class="lineNum">    2424 </span><span class="lineCov">     807435 :           &amp;&amp; TREE_CODE (gimple_assign_rhs2 (op1_def)) == INTEGER_CST</span>
<span class="lineNum">    2425 </span><span class="lineCov">    4738531 :           &amp;&amp; !integer_zerop (gimple_assign_rhs2 (op1_def)))</span>
<span class="lineNum">    2426 </span>            :         {
<span class="lineNum">    2427 </span><span class="lineCov">     335079 :           tree target = gimple_assign_rhs1 (op1_def);</span>
<span class="lineNum">    2428 </span>            : 
<span class="lineNum">    2429 </span>            :           /* If requested, follow ASSERT_EXPRs backwards for op0 looking
<span class="lineNum">    2430 </span>            :              for one where TARGET appears on the RHS.  */
<span class="lineNum">    2431 </span><span class="lineCov">     335079 :           if (follow_assert_exprs)</span>
<span class="lineNum">    2432 </span>            :             {
<span class="lineNum">    2433 </span>            :               /* Now see if that &quot;other operand&quot; is op0, following the chain
<span class="lineNum">    2434 </span>            :                  of ASSERT_EXPRs if necessary.  */
<span class="lineNum">    2435 </span><span class="lineCov">      80193 :               gimple *op0_def = SSA_NAME_DEF_STMT (op0);</span>
<span class="lineNum">    2436 </span><span class="lineCov">     112135 :               while (op0 != target</span>
<span class="lineNum">    2437 </span><span class="lineCov">      95313 :                      &amp;&amp; gimple_assign_single_p (op0_def)</span>
<span class="lineNum">    2438 </span><span class="lineCov">     181750 :                      &amp;&amp; TREE_CODE (gimple_assign_rhs1 (op0_def)) == ASSERT_EXPR)</span>
<span class="lineNum">    2439 </span>            :                 {
<span class="lineNum">    2440 </span><span class="lineCov">      31942 :                   op0 = TREE_OPERAND (gimple_assign_rhs1 (op0_def), 0);</span>
<span class="lineNum">    2441 </span><span class="lineCov">      15971 :                   if (TREE_CODE (op0) != SSA_NAME)</span>
<span class="lineNum">    2442 </span>            :                     break;
<span class="lineNum">    2443 </span><span class="lineCov">      31942 :                   op0_def = SSA_NAME_DEF_STMT (op0);</span>
<span class="lineNum">    2444 </span>            :                 }
<span class="lineNum">    2445 </span>            :             }
<span class="lineNum">    2446 </span>            : 
<span class="lineNum">    2447 </span>            :           /* If we did not find our target SSA_NAME, then this is not
<span class="lineNum">    2448 </span>            :              an overflow test.  */
<span class="lineNum">    2449 </span><span class="lineCov">     335079 :           if (op0 != target)</span>
<span class="lineNum">    2450 </span>            :             return false;
<span class="lineNum">    2451 </span>            : 
<span class="lineNum">    2452 </span><span class="lineCov">       5020 :           tree type = TREE_TYPE (op0);</span>
<span class="lineNum">    2453 </span><span class="lineCov">       5020 :           wide_int max = wi::max_value (TYPE_PRECISION (type), UNSIGNED);</span>
<span class="lineNum">    2454 </span><span class="lineCov">       5020 :           tree inc = gimple_assign_rhs2 (op1_def);</span>
<span class="lineNum">    2455 </span><span class="lineCov">       5020 :           if (reversed)</span>
<span class="lineNum">    2456 </span><span class="lineCov">       2088 :             *new_cst = wide_int_to_tree (type, max + wi::to_wide (inc));</span>
<span class="lineNum">    2457 </span>            :           else
<span class="lineNum">    2458 </span><span class="lineCov">       2932 :             *new_cst = wide_int_to_tree (type, max - wi::to_wide (inc));</span>
<span class="lineNum">    2459 </span><span class="lineCov">       5020 :           return true;</span>
<span class="lineNum">    2460 </span>            :         }
<span class="lineNum">    2461 </span>            :     }
<span class="lineNum">    2462 </span>            :   return false;
<span class="lineNum">    2463 </span>            : }
<span class="lineNum">    2464 </span>            : 
<span class="lineNum">    2465 </span>            : /* OP0 CODE OP1 is a comparison.  Examine the comparison and potentially
<span class="lineNum">    2466 </span>            :    OP1's defining statement to see if it ultimately has the form
<span class="lineNum">    2467 </span>            :    OP0 CODE (OP0 PLUS INTEGER_CST)
<span class="lineNum">    2468 </span>            : 
<span class="lineNum">    2469 </span>            :    If so, return TRUE indicating this is an overflow test and store into
<span class="lineNum">    2470 </span>            :    *NEW_CST an updated constant that can be used in a narrowed range test.
<span class="lineNum">    2471 </span>            : 
<span class="lineNum">    2472 </span>            :    These statements are left as-is in the IL to facilitate discovery of
<span class="lineNum">    2473 </span>            :    {ADD,SUB}_OVERFLOW sequences later in the optimizer pipeline.  But
<span class="lineNum">    2474 </span>            :    the alternate range representation is often useful within VRP.  */
<a name="2475"><span class="lineNum">    2475 </span>            : </a>
<span class="lineNum">    2476 </span>            : bool
<span class="lineNum">    2477 </span><span class="lineCov">   53421115 : overflow_comparison_p (tree_code code, tree name, tree val,</span>
<span class="lineNum">    2478 </span>            :                        bool use_equiv_p, tree *new_cst)
<span class="lineNum">    2479 </span>            : {
<span class="lineNum">    2480 </span><span class="lineCov">   53421115 :   if (overflow_comparison_p_1 (code, name, val, use_equiv_p, false, new_cst))</span>
<span class="lineNum">    2481 </span>            :     return true;
<span class="lineNum">    2482 </span><span class="lineCov">   53418183 :   return overflow_comparison_p_1 (swap_tree_comparison (code), val, name,</span>
<span class="lineNum">    2483 </span><span class="lineCov">   53418183 :                                   use_equiv_p, true, new_cst);</span>
<span class="lineNum">    2484 </span>            : }
<span class="lineNum">    2485 </span>            : 
<span class="lineNum">    2486 </span>            : 
<span class="lineNum">    2487 </span>            : /* Try to register an edge assertion for SSA name NAME on edge E for
<span class="lineNum">    2488 </span>            :    the condition COND contributing to the conditional jump pointed to by BSI.
<span class="lineNum">    2489 </span>            :    Invert the condition COND if INVERT is true.  */
<span class="lineNum">    2490 </span>            : 
<span class="lineNum">    2491 </span>            : static void
<span class="lineNum">    2492 </span><span class="lineCov">   25704925 : register_edge_assert_for_2 (tree name, edge e,</span>
<span class="lineNum">    2493 </span>            :                             enum tree_code cond_code,
<span class="lineNum">    2494 </span>            :                             tree cond_op0, tree cond_op1, bool invert,
<span class="lineNum">    2495 </span>            :                             vec&lt;assert_info&gt; &amp;asserts)
<span class="lineNum">    2496 </span>            : {
<span class="lineNum">    2497 </span><span class="lineCov">   25704925 :   tree val;</span>
<span class="lineNum">    2498 </span><span class="lineCov">   25704925 :   enum tree_code comp_code;</span>
<span class="lineNum">    2499 </span>            : 
<span class="lineNum">    2500 </span><span class="lineCov">   25704925 :   if (!extract_code_and_val_from_cond_with_ops (name, cond_code,</span>
<span class="lineNum">    2501 </span>            :                                                 cond_op0,
<span class="lineNum">    2502 </span>            :                                                 cond_op1,
<span class="lineNum">    2503 </span>            :                                                 invert, &amp;comp_code, &amp;val))
<span class="lineNum">    2504 </span><span class="lineCov">     212223 :     return;</span>
<span class="lineNum">    2505 </span>            : 
<span class="lineNum">    2506 </span>            :   /* Queue the assert.  */
<span class="lineNum">    2507 </span><span class="lineCov">   25492702 :   tree x;</span>
<span class="lineNum">    2508 </span><span class="lineCov">   25492702 :   if (overflow_comparison_p (comp_code, name, val, false, &amp;x))</span>
<span class="lineNum">    2509 </span>            :     {
<span class="lineNum">    2510 </span><span class="lineCov">       6408 :       enum tree_code new_code = ((comp_code == GT_EXPR || comp_code == GE_EXPR)</span>
<span class="lineNum">    2511 </span><span class="lineCov">       3204 :                                  ? GT_EXPR : LE_EXPR);</span>
<span class="lineNum">    2512 </span><span class="lineCov">       3204 :       add_assert_info (asserts, name, name, new_code, x);</span>
<span class="lineNum">    2513 </span>            :     }
<span class="lineNum">    2514 </span><span class="lineCov">   25492702 :   add_assert_info (asserts, name, name, comp_code, val);</span>
<span class="lineNum">    2515 </span>            : 
<span class="lineNum">    2516 </span>            :   /* In the case of NAME &lt;= CST and NAME being defined as
<span class="lineNum">    2517 </span>            :      NAME = (unsigned) NAME2 + CST2 we can assert NAME2 &gt;= -CST2
<span class="lineNum">    2518 </span>            :      and NAME2 &lt;= CST - CST2.  We can do the same for NAME &gt; CST.
<span class="lineNum">    2519 </span>            :      This catches range and anti-range tests.  */
<span class="lineNum">    2520 </span><span class="lineCov">   25492702 :   if ((comp_code == LE_EXPR</span>
<span class="lineNum">    2521 </span><span class="lineCov">   25492702 :        || comp_code == GT_EXPR)</span>
<span class="lineNum">    2522 </span><span class="lineCov">    4272062 :       &amp;&amp; TREE_CODE (val) == INTEGER_CST</span>
<span class="lineNum">    2523 </span><span class="lineCov">   27242597 :       &amp;&amp; TYPE_UNSIGNED (TREE_TYPE (val)))</span>
<span class="lineNum">    2524 </span>            :     {
<span class="lineNum">    2525 </span><span class="lineCov">     642126 :       gimple *def_stmt = SSA_NAME_DEF_STMT (name);</span>
<span class="lineNum">    2526 </span><span class="lineCov">     642126 :       tree cst2 = NULL_TREE, name2 = NULL_TREE, name3 = NULL_TREE;</span>
<span class="lineNum">    2527 </span>            : 
<span class="lineNum">    2528 </span>            :       /* Extract CST2 from the (optional) addition.  */
<span class="lineNum">    2529 </span><span class="lineCov">     642126 :       if (is_gimple_assign (def_stmt)</span>
<span class="lineNum">    2530 </span><span class="lineCov">     642126 :           &amp;&amp; gimple_assign_rhs_code (def_stmt) == PLUS_EXPR)</span>
<span class="lineNum">    2531 </span>            :         {
<span class="lineNum">    2532 </span><span class="lineCov">     133707 :           name2 = gimple_assign_rhs1 (def_stmt);</span>
<span class="lineNum">    2533 </span><span class="lineCov">     133707 :           cst2 = gimple_assign_rhs2 (def_stmt);</span>
<span class="lineNum">    2534 </span><span class="lineCov">     133707 :           if (TREE_CODE (name2) == SSA_NAME</span>
<span class="lineNum">    2535 </span><span class="lineCov">     133707 :               &amp;&amp; TREE_CODE (cst2) == INTEGER_CST)</span>
<span class="lineNum">    2536 </span><span class="lineCov">     234196 :             def_stmt = SSA_NAME_DEF_STMT (name2);</span>
<span class="lineNum">    2537 </span>            :         }
<span class="lineNum">    2538 </span>            : 
<span class="lineNum">    2539 </span>            :       /* Extract NAME2 from the (optional) sign-changing cast.  */
<span class="lineNum">    2540 </span><span class="lineCov">     642126 :       if (gimple_assign_cast_p (def_stmt))</span>
<span class="lineNum">    2541 </span>            :         {
<span class="lineNum">    2542 </span><span class="lineCov">     209296 :           if (CONVERT_EXPR_CODE_P (gimple_assign_rhs_code (def_stmt))</span>
<span class="lineNum">    2543 </span><span class="lineCov">     208658 :               &amp;&amp; ! TYPE_UNSIGNED (TREE_TYPE (gimple_assign_rhs1 (def_stmt)))</span>
<span class="lineNum">    2544 </span><span class="lineCov">     391394 :               &amp;&amp; (TYPE_PRECISION (gimple_expr_type (def_stmt))</span>
<span class="lineNum">    2545 </span><span class="lineCov">     182417 :                   == TYPE_PRECISION (TREE_TYPE (gimple_assign_rhs1 (def_stmt)))))</span>
<span class="lineNum">    2546 </span><span class="lineCov">     177069 :             name3 = gimple_assign_rhs1 (def_stmt);</span>
<span class="lineNum">    2547 </span>            :         }
<span class="lineNum">    2548 </span>            : 
<span class="lineNum">    2549 </span>            :       /* If name3 is used later, create an ASSERT_EXPR for it.  */
<span class="lineNum">    2550 </span><span class="lineCov">     177069 :       if (name3 != NULL_TREE</span>
<span class="lineNum">    2551 </span><span class="lineCov">     177069 :           &amp;&amp; TREE_CODE (name3) == SSA_NAME</span>
<span class="lineNum">    2552 </span><span class="lineCov">     177069 :           &amp;&amp; (cst2 == NULL_TREE</span>
<span class="lineNum">    2553 </span><span class="lineCov">      40283 :               || TREE_CODE (cst2) == INTEGER_CST)</span>
<span class="lineNum">    2554 </span><span class="lineCov">     354138 :           &amp;&amp; INTEGRAL_TYPE_P (TREE_TYPE (name3)))</span>
<span class="lineNum">    2555 </span>            :         {
<span class="lineNum">    2556 </span><span class="lineCov">     177069 :           tree tmp;</span>
<span class="lineNum">    2557 </span>            : 
<span class="lineNum">    2558 </span>            :           /* Build an expression for the range test.  */
<span class="lineNum">    2559 </span><span class="lineCov">     177069 :           tmp = build1 (NOP_EXPR, TREE_TYPE (name), name3);</span>
<span class="lineNum">    2560 </span><span class="lineCov">     177069 :           if (cst2 != NULL_TREE)</span>
<span class="lineNum">    2561 </span><span class="lineCov">      40283 :             tmp = build2 (PLUS_EXPR, TREE_TYPE (name), tmp, cst2);</span>
<span class="lineNum">    2562 </span>            : 
<span class="lineNum">    2563 </span><span class="lineCov">     177069 :           if (dump_file)</span>
<span class="lineNum">    2564 </span>            :             {
<span class="lineNum">    2565 </span><span class="lineCov">        142 :               fprintf (dump_file, &quot;Adding assert for &quot;);</span>
<span class="lineNum">    2566 </span><span class="lineCov">        142 :               print_generic_expr (dump_file, name3);</span>
<span class="lineNum">    2567 </span><span class="lineCov">        142 :               fprintf (dump_file, &quot; from &quot;);</span>
<span class="lineNum">    2568 </span><span class="lineCov">        142 :               print_generic_expr (dump_file, tmp);</span>
<span class="lineNum">    2569 </span><span class="lineCov">        142 :               fprintf (dump_file, &quot;\n&quot;);</span>
<span class="lineNum">    2570 </span>            :             }
<span class="lineNum">    2571 </span>            : 
<span class="lineNum">    2572 </span><span class="lineCov">     177069 :           add_assert_info (asserts, name3, tmp, comp_code, val);</span>
<span class="lineNum">    2573 </span>            :         }
<span class="lineNum">    2574 </span>            : 
<span class="lineNum">    2575 </span>            :       /* If name2 is used later, create an ASSERT_EXPR for it.  */
<span class="lineNum">    2576 </span><span class="lineCov">     642126 :       if (name2 != NULL_TREE</span>
<span class="lineNum">    2577 </span><span class="lineCov">     133707 :           &amp;&amp; TREE_CODE (name2) == SSA_NAME</span>
<span class="lineNum">    2578 </span><span class="lineCov">     133707 :           &amp;&amp; TREE_CODE (cst2) == INTEGER_CST</span>
<span class="lineNum">    2579 </span><span class="lineCov">     759224 :           &amp;&amp; INTEGRAL_TYPE_P (TREE_TYPE (name2)))</span>
<span class="lineNum">    2580 </span>            :         {
<span class="lineNum">    2581 </span><span class="lineCov">     117098 :           tree tmp;</span>
<span class="lineNum">    2582 </span>            : 
<span class="lineNum">    2583 </span>            :           /* Build an expression for the range test.  */
<span class="lineNum">    2584 </span><span class="lineCov">     117098 :           tmp = name2;</span>
<span class="lineNum">    2585 </span><span class="lineCov">     117098 :           if (TREE_TYPE (name) != TREE_TYPE (name2))</span>
<span class="lineNum">    2586 </span><span class="lineCov">      53102 :             tmp = build1 (NOP_EXPR, TREE_TYPE (name), tmp);</span>
<span class="lineNum">    2587 </span><span class="lineCov">     117098 :           if (cst2 != NULL_TREE)</span>
<span class="lineNum">    2588 </span><span class="lineCov">     117098 :             tmp = build2 (PLUS_EXPR, TREE_TYPE (name), tmp, cst2);</span>
<span class="lineNum">    2589 </span>            : 
<span class="lineNum">    2590 </span><span class="lineCov">     117098 :           if (dump_file)</span>
<span class="lineNum">    2591 </span>            :             {
<span class="lineNum">    2592 </span><span class="lineCov">        146 :               fprintf (dump_file, &quot;Adding assert for &quot;);</span>
<span class="lineNum">    2593 </span><span class="lineCov">        146 :               print_generic_expr (dump_file, name2);</span>
<span class="lineNum">    2594 </span><span class="lineCov">        146 :               fprintf (dump_file, &quot; from &quot;);</span>
<span class="lineNum">    2595 </span><span class="lineCov">        146 :               print_generic_expr (dump_file, tmp);</span>
<span class="lineNum">    2596 </span><span class="lineCov">        146 :               fprintf (dump_file, &quot;\n&quot;);</span>
<span class="lineNum">    2597 </span>            :             }
<span class="lineNum">    2598 </span>            : 
<span class="lineNum">    2599 </span><span class="lineCov">     117098 :           add_assert_info (asserts, name2, tmp, comp_code, val);</span>
<span class="lineNum">    2600 </span>            :         }
<span class="lineNum">    2601 </span>            :     }
<span class="lineNum">    2602 </span>            : 
<span class="lineNum">    2603 </span>            :   /* In the case of post-in/decrement tests like if (i++) ... and uses
<span class="lineNum">    2604 </span>            :      of the in/decremented value on the edge the extra name we want to
<span class="lineNum">    2605 </span>            :      assert for is not on the def chain of the name compared.  Instead
<span class="lineNum">    2606 </span>            :      it is in the set of use stmts.
<span class="lineNum">    2607 </span>            :      Similar cases happen for conversions that were simplified through
<span class="lineNum">    2608 </span>            :      fold_{sign_changed,widened}_comparison.  */
<span class="lineNum">    2609 </span><span class="lineCov">   50985404 :   if ((comp_code == NE_EXPR</span>
<span class="lineNum">    2610 </span><span class="lineCov">   25492702 :        || comp_code == EQ_EXPR)</span>
<span class="lineNum">    2611 </span><span class="lineCov">   17998623 :       &amp;&amp; TREE_CODE (val) == INTEGER_CST)</span>
<span class="lineNum">    2612 </span>            :     {
<span class="lineNum">    2613 </span><span class="lineCov">   12498059 :       imm_use_iterator ui;</span>
<span class="lineNum">    2614 </span><span class="lineCov">   12498059 :       gimple *use_stmt;</span>
<span class="lineNum">    2615 </span><span class="lineCov">   47496143 :       FOR_EACH_IMM_USE_STMT (use_stmt, ui, name)</span>
<span class="lineNum">    2616 </span>            :         {
<span class="lineNum">    2617 </span><span class="lineCov">   69996168 :           if (!is_gimple_assign (use_stmt))</span>
<span class="lineNum">    2618 </span>            :             continue;
<span class="lineNum">    2619 </span>            : 
<span class="lineNum">    2620 </span>            :           /* Cut off to use-stmts that are dominating the predecessor.  */
<span class="lineNum">    2621 </span><span class="lineCov">   16016332 :           if (!dominated_by_p (CDI_DOMINATORS, e-&gt;src, gimple_bb (use_stmt)))</span>
<span class="lineNum">    2622 </span>            :             continue;
<span class="lineNum">    2623 </span>            : 
<span class="lineNum">    2624 </span><span class="lineCov">    1549996 :           tree name2 = gimple_assign_lhs (use_stmt);</span>
<span class="lineNum">    2625 </span><span class="lineCov">    1549996 :           if (TREE_CODE (name2) != SSA_NAME)</span>
<span class="lineNum">    2626 </span>            :             continue;
<span class="lineNum">    2627 </span>            : 
<span class="lineNum">    2628 </span><span class="lineCov">    1243347 :           enum tree_code code = gimple_assign_rhs_code (use_stmt);</span>
<span class="lineNum">    2629 </span><span class="lineCov">    1243347 :           tree cst;</span>
<span class="lineNum">    2630 </span><span class="lineCov">    2486694 :           if (code == PLUS_EXPR</span>
<span class="lineNum">    2631 </span><span class="lineCov">    1243347 :               || code == MINUS_EXPR)</span>
<span class="lineNum">    2632 </span>            :             {
<span class="lineNum">    2633 </span><span class="lineCov">     155578 :               cst = gimple_assign_rhs2 (use_stmt);</span>
<span class="lineNum">    2634 </span><span class="lineCov">     155578 :               if (TREE_CODE (cst) != INTEGER_CST)</span>
<span class="lineNum">    2635 </span>            :                 continue;
<span class="lineNum">    2636 </span><span class="lineCov">      94063 :               cst = int_const_binop (code, val, cst);</span>
<span class="lineNum">    2637 </span>            :             }
<span class="lineNum">    2638 </span><span class="lineCov">    1087769 :           else if (CONVERT_EXPR_CODE_P (code))</span>
<span class="lineNum">    2639 </span>            :             {
<span class="lineNum">    2640 </span>            :               /* For truncating conversions we cannot record
<span class="lineNum">    2641 </span>            :                  an inequality.  */
<span class="lineNum">    2642 </span><span class="lineCov">     155931 :               if (comp_code == NE_EXPR</span>
<span class="lineNum">    2643 </span><span class="lineCov">     155931 :                   &amp;&amp; (TYPE_PRECISION (TREE_TYPE (name2))</span>
<span class="lineNum">    2644 </span><span class="lineCov">      84661 :                       &lt; TYPE_PRECISION (TREE_TYPE (name))))</span>
<span class="lineNum">    2645 </span>            :                 continue;
<span class="lineNum">    2646 </span><span class="lineCov">     150846 :               cst = fold_convert (TREE_TYPE (name2), val);</span>
<span class="lineNum">    2647 </span>            :             }
<span class="lineNum">    2648 </span>            :           else
<span class="lineNum">    2649 </span>            :             continue;
<span class="lineNum">    2650 </span>            : 
<span class="lineNum">    2651 </span><span class="lineCov">     244909 :           if (TREE_OVERFLOW_P (cst))</span>
<span class="lineNum">    2652 </span><span class="lineCov">       3819 :             cst = drop_tree_overflow (cst);</span>
<span class="lineNum">    2653 </span><span class="lineCov">     244909 :           add_assert_info (asserts, name2, name2, comp_code, cst);</span>
<span class="lineNum">    2654 </span>            :         }
<span class="lineNum">    2655 </span>            :     }
<span class="lineNum">    2656 </span>            :  
<span class="lineNum">    2657 </span><span class="lineCov">   25492702 :   if (TREE_CODE_CLASS (comp_code) == tcc_comparison</span>
<span class="lineNum">    2658 </span><span class="lineCov">   25492702 :       &amp;&amp; TREE_CODE (val) == INTEGER_CST)</span>
<span class="lineNum">    2659 </span>            :     {
<span class="lineNum">    2660 </span><span class="lineCov">   14944844 :       gimple *def_stmt = SSA_NAME_DEF_STMT (name);</span>
<span class="lineNum">    2661 </span><span class="lineCov">   14944844 :       tree name2 = NULL_TREE, names[2], cst2 = NULL_TREE;</span>
<span class="lineNum">    2662 </span><span class="lineCov">   14944844 :       tree val2 = NULL_TREE;</span>
<span class="lineNum">    2663 </span><span class="lineCov">   14944844 :       unsigned int prec = TYPE_PRECISION (TREE_TYPE (val));</span>
<span class="lineNum">    2664 </span><span class="lineCov">   29889688 :       wide_int mask = wi::zero (prec);</span>
<span class="lineNum">    2665 </span><span class="lineCov">   14944844 :       unsigned int nprec = prec;</span>
<span class="lineNum">    2666 </span><span class="lineCov">   14944844 :       enum tree_code rhs_code = ERROR_MARK;</span>
<span class="lineNum">    2667 </span>            : 
<span class="lineNum">    2668 </span><span class="lineCov">   29889688 :       if (is_gimple_assign (def_stmt))</span>
<span class="lineNum">    2669 </span><span class="lineCov">    9336346 :         rhs_code = gimple_assign_rhs_code (def_stmt);</span>
<span class="lineNum">    2670 </span>            : 
<span class="lineNum">    2671 </span>            :       /* In the case of NAME != CST1 where NAME = A +- CST2 we can
<span class="lineNum">    2672 </span>            :          assert that A != CST1 -+ CST2.  */
<span class="lineNum">    2673 </span><span class="lineCov">   14944844 :       if ((comp_code == EQ_EXPR || comp_code == NE_EXPR)</span>
<span class="lineNum">    2674 </span><span class="lineCov">   12498059 :           &amp;&amp; (rhs_code == PLUS_EXPR || rhs_code == MINUS_EXPR))</span>
<span class="lineNum">    2675 </span>            :         {
<span class="lineNum">    2676 </span><span class="lineCov">     717714 :           tree op0 = gimple_assign_rhs1 (def_stmt);</span>
<span class="lineNum">    2677 </span><span class="lineCov">     717714 :           tree op1 = gimple_assign_rhs2 (def_stmt);</span>
<span class="lineNum">    2678 </span><span class="lineCov">     717714 :           if (TREE_CODE (op0) == SSA_NAME</span>
<span class="lineNum">    2679 </span><span class="lineCov">     713074 :               &amp;&amp; TREE_CODE (op1) == INTEGER_CST)</span>
<span class="lineNum">    2680 </span>            :             {
<span class="lineNum">    2681 </span><span class="lineCov">    1174062 :               enum tree_code reverse_op = (rhs_code == PLUS_EXPR</span>
<span class="lineNum">    2682 </span><span class="lineCov">     587031 :                                            ? MINUS_EXPR : PLUS_EXPR);</span>
<span class="lineNum">    2683 </span><span class="lineCov">     587031 :               op1 = int_const_binop (reverse_op, val, op1);</span>
<span class="lineNum">    2684 </span><span class="lineCov">     587031 :               if (TREE_OVERFLOW (op1))</span>
<span class="lineNum">    2685 </span><span class="lineCov">       2369 :                 op1 = drop_tree_overflow (op1);</span>
<span class="lineNum">    2686 </span><span class="lineCov">     587031 :               add_assert_info (asserts, op0, op0, comp_code, op1);</span>
<span class="lineNum">    2687 </span>            :             }
<span class="lineNum">    2688 </span>            :         }
<span class="lineNum">    2689 </span>            : 
<span class="lineNum">    2690 </span>            :       /* Add asserts for NAME cmp CST and NAME being defined
<span class="lineNum">    2691 </span>            :          as NAME = (int) NAME2.  */
<span class="lineNum">    2692 </span><span class="lineCov">   14944844 :       if (!TYPE_UNSIGNED (TREE_TYPE (val))</span>
<span class="lineNum">    2693 </span><span class="lineCov">    5843824 :           &amp;&amp; (comp_code == LE_EXPR || comp_code == LT_EXPR</span>
<span class="lineNum">    2694 </span><span class="lineCov">    5843824 :               || comp_code == GT_EXPR || comp_code == GE_EXPR)</span>
<span class="lineNum">    2695 </span><span class="lineCov">   16741817 :           &amp;&amp; gimple_assign_cast_p (def_stmt))</span>
<span class="lineNum">    2696 </span>            :         {
<span class="lineNum">    2697 </span><span class="lineCov">     243821 :           name2 = gimple_assign_rhs1 (def_stmt);</span>
<span class="lineNum">    2698 </span><span class="lineCov">       2165 :           if (CONVERT_EXPR_CODE_P (rhs_code)</span>
<span class="lineNum">    2699 </span><span class="lineCov">     241656 :               &amp;&amp; INTEGRAL_TYPE_P (TREE_TYPE (name2))</span>
<span class="lineNum">    2700 </span><span class="lineCov">     481588 :               &amp;&amp; TYPE_UNSIGNED (TREE_TYPE (name2))</span>
<span class="lineNum">    2701 </span><span class="lineCov">     492594 :               &amp;&amp; prec == TYPE_PRECISION (TREE_TYPE (name2))</span>
<span class="lineNum">    2702 </span><span class="lineCov">     385045 :               &amp;&amp; (comp_code == LE_EXPR || comp_code == GT_EXPR</span>
<span class="lineNum">    2703 </span><span class="lineCov">     105603 :                   || !tree_int_cst_equal (val,</span>
<span class="lineNum">    2704 </span><span class="lineCov">     211206 :                                           TYPE_MIN_VALUE (TREE_TYPE (val)))))</span>
<span class="lineNum">    2705 </span>            :             {
<span class="lineNum">    2706 </span><span class="lineCov">     141224 :               tree tmp, cst;</span>
<span class="lineNum">    2707 </span><span class="lineCov">     141224 :               enum tree_code new_comp_code = comp_code;</span>
<span class="lineNum">    2708 </span>            : 
<span class="lineNum">    2709 </span><span class="lineCov">     141224 :               cst = fold_convert (TREE_TYPE (name2),</span>
<span class="lineNum">    2710 </span>            :                                   TYPE_MIN_VALUE (TREE_TYPE (val)));
<span class="lineNum">    2711 </span>            :               /* Build an expression for the range test.  */
<span class="lineNum">    2712 </span><span class="lineCov">     141224 :               tmp = build2 (PLUS_EXPR, TREE_TYPE (name2), name2, cst);</span>
<span class="lineNum">    2713 </span><span class="lineCov">     141224 :               cst = fold_build2 (PLUS_EXPR, TREE_TYPE (name2), cst,</span>
<span class="lineNum">    2714 </span>            :                                  fold_convert (TREE_TYPE (name2), val));
<span class="lineNum">    2715 </span><span class="lineCov">     141224 :               if (comp_code == LT_EXPR || comp_code == GE_EXPR)</span>
<span class="lineNum">    2716 </span>            :                 {
<span class="lineNum">    2717 </span><span class="lineCov">     105603 :                   new_comp_code = comp_code == LT_EXPR ? LE_EXPR : GT_EXPR;</span>
<span class="lineNum">    2718 </span><span class="lineCov">     211206 :                   cst = fold_build2 (MINUS_EXPR, TREE_TYPE (name2), cst,</span>
<span class="lineNum">    2719 </span>            :                                      build_int_cst (TREE_TYPE (name2), 1));
<span class="lineNum">    2720 </span>            :                 }
<span class="lineNum">    2721 </span>            : 
<span class="lineNum">    2722 </span><span class="lineCov">     141224 :               if (dump_file)</span>
<span class="lineNum">    2723 </span>            :                 {
<span class="lineNum">    2724 </span><span class="lineCov">          4 :                   fprintf (dump_file, &quot;Adding assert for &quot;);</span>
<span class="lineNum">    2725 </span><span class="lineCov">          4 :                   print_generic_expr (dump_file, name2);</span>
<span class="lineNum">    2726 </span><span class="lineCov">          4 :                   fprintf (dump_file, &quot; from &quot;);</span>
<span class="lineNum">    2727 </span><span class="lineCov">          4 :                   print_generic_expr (dump_file, tmp);</span>
<span class="lineNum">    2728 </span><span class="lineCov">          4 :                   fprintf (dump_file, &quot;\n&quot;);</span>
<span class="lineNum">    2729 </span>            :                 }
<span class="lineNum">    2730 </span>            : 
<span class="lineNum">    2731 </span><span class="lineCov">     141224 :               add_assert_info (asserts, name2, tmp, new_comp_code, cst);</span>
<span class="lineNum">    2732 </span>            :             }
<span class="lineNum">    2733 </span>            :         }
<span class="lineNum">    2734 </span>            : 
<span class="lineNum">    2735 </span>            :       /* Add asserts for NAME cmp CST and NAME being defined as
<span class="lineNum">    2736 </span>            :          NAME = NAME2 &gt;&gt; CST2.
<span class="lineNum">    2737 </span>            : 
<span class="lineNum">    2738 </span>            :          Extract CST2 from the right shift.  */
<span class="lineNum">    2739 </span><span class="lineCov">   14944844 :       if (rhs_code == RSHIFT_EXPR)</span>
<span class="lineNum">    2740 </span>            :         {
<span class="lineNum">    2741 </span><span class="lineCov">      34071 :           name2 = gimple_assign_rhs1 (def_stmt);</span>
<span class="lineNum">    2742 </span><span class="lineCov">      34071 :           cst2 = gimple_assign_rhs2 (def_stmt);</span>
<span class="lineNum">    2743 </span><span class="lineCov">      34071 :           if (TREE_CODE (name2) == SSA_NAME</span>
<span class="lineNum">    2744 </span><span class="lineCov">      33052 :               &amp;&amp; tree_fits_uhwi_p (cst2)</span>
<span class="lineNum">    2745 </span><span class="lineCov">      31651 :               &amp;&amp; INTEGRAL_TYPE_P (TREE_TYPE (name2))</span>
<span class="lineNum">    2746 </span><span class="lineCov">      31651 :               &amp;&amp; IN_RANGE (tree_to_uhwi (cst2), 1, prec - 1)</span>
<span class="lineNum">    2747 </span><span class="lineCov">      65722 :               &amp;&amp; type_has_mode_precision_p (TREE_TYPE (val)))</span>
<span class="lineNum">    2748 </span>            :             {
<span class="lineNum">    2749 </span><span class="lineCov">      31651 :               mask = wi::mask (tree_to_uhwi (cst2), false, prec);</span>
<span class="lineNum">    2750 </span><span class="lineCov">      31651 :               val2 = fold_binary (LSHIFT_EXPR, TREE_TYPE (val), val, cst2);</span>
<span class="lineNum">    2751 </span>            :             }
<span class="lineNum">    2752 </span>            :         }
<span class="lineNum">    2753 </span><span class="lineCov">   14944844 :       if (val2 != NULL_TREE</span>
<span class="lineNum">    2754 </span><span class="lineCov">      31651 :           &amp;&amp; TREE_CODE (val2) == INTEGER_CST</span>
<span class="lineNum">    2755 </span><span class="lineCov">   14976495 :           &amp;&amp; simple_cst_equal (fold_build2 (RSHIFT_EXPR,</span>
<span class="lineNum">    2756 </span>            :                                             TREE_TYPE (val),
<span class="lineNum">    2757 </span>            :                                             val2, cst2), val))
<span class="lineNum">    2758 </span>            :         {
<span class="lineNum">    2759 </span><span class="lineCov">      31651 :           enum tree_code new_comp_code = comp_code;</span>
<span class="lineNum">    2760 </span><span class="lineCov">      31651 :           tree tmp, new_val;</span>
<span class="lineNum">    2761 </span>            : 
<span class="lineNum">    2762 </span><span class="lineCov">      31651 :           tmp = name2;</span>
<span class="lineNum">    2763 </span><span class="lineCov">      31651 :           if (comp_code == EQ_EXPR || comp_code == NE_EXPR)</span>
<span class="lineNum">    2764 </span>            :             {
<span class="lineNum">    2765 </span><span class="lineCov">      23665 :               if (!TYPE_UNSIGNED (TREE_TYPE (val)))</span>
<span class="lineNum">    2766 </span>            :                 {
<span class="lineNum">    2767 </span><span class="lineCov">      11399 :                   tree type = build_nonstandard_integer_type (prec, 1);</span>
<span class="lineNum">    2768 </span><span class="lineCov">      11399 :                   tmp = build1 (NOP_EXPR, type, name2);</span>
<span class="lineNum">    2769 </span><span class="lineCov">      11399 :                   val2 = fold_convert (type, val2);</span>
<span class="lineNum">    2770 </span>            :                 }
<span class="lineNum">    2771 </span><span class="lineCov">      23665 :               tmp = fold_build2 (MINUS_EXPR, TREE_TYPE (tmp), tmp, val2);</span>
<span class="lineNum">    2772 </span><span class="lineCov">      47330 :               new_val = wide_int_to_tree (TREE_TYPE (tmp), mask);</span>
<span class="lineNum">    2773 </span><span class="lineCov">      23665 :               new_comp_code = comp_code == EQ_EXPR ? LE_EXPR : GT_EXPR;</span>
<span class="lineNum">    2774 </span>            :             }
<span class="lineNum">    2775 </span><span class="lineCov">       7986 :           else if (comp_code == LT_EXPR || comp_code == GE_EXPR)</span>
<span class="lineNum">    2776 </span>            :             {
<span class="lineNum">    2777 </span><span class="lineCov">        332 :               wide_int minval</span>
<span class="lineNum">    2778 </span><span class="lineCov">        332 :                 = wi::min_value (prec, TYPE_SIGN (TREE_TYPE (val)));</span>
<span class="lineNum">    2779 </span><span class="lineCov">        332 :               new_val = val2;</span>
<span class="lineNum">    2780 </span><span class="lineCov">        332 :               if (minval == wi::to_wide (new_val))</span>
<span class="lineNum">    2781 </span><span class="lineCov">        332 :                 new_val = NULL_TREE;</span>
<span class="lineNum">    2782 </span>            :             }
<span class="lineNum">    2783 </span>            :           else
<span class="lineNum">    2784 </span>            :             {
<span class="lineNum">    2785 </span><span class="lineCov">       7654 :               wide_int maxval</span>
<span class="lineNum">    2786 </span><span class="lineCov">       7654 :                 = wi::max_value (prec, TYPE_SIGN (TREE_TYPE (val)));</span>
<span class="lineNum">    2787 </span><span class="lineCov">       7654 :               mask |= wi::to_wide (val2);</span>
<span class="lineNum">    2788 </span><span class="lineCov">       7654 :               if (wi::eq_p (mask, maxval))</span>
<span class="lineNum">    2789 </span>            :                 new_val = NULL_TREE;
<span class="lineNum">    2790 </span>            :               else
<span class="lineNum">    2791 </span><span class="lineCov">      15308 :                 new_val = wide_int_to_tree (TREE_TYPE (val2), mask);</span>
<span class="lineNum">    2792 </span>            :             }
<span class="lineNum">    2793 </span>            : 
<span class="lineNum">    2794 </span><span class="lineCov">      31651 :           if (new_val)</span>
<span class="lineNum">    2795 </span>            :             {
<span class="lineNum">    2796 </span><span class="lineCov">      31639 :               if (dump_file)</span>
<span class="lineNum">    2797 </span>            :                 {
<span class="lineNum">    2798 </span><span class="lineCov">          6 :                   fprintf (dump_file, &quot;Adding assert for &quot;);</span>
<span class="lineNum">    2799 </span><span class="lineCov">          6 :                   print_generic_expr (dump_file, name2);</span>
<span class="lineNum">    2800 </span><span class="lineCov">          6 :                   fprintf (dump_file, &quot; from &quot;);</span>
<span class="lineNum">    2801 </span><span class="lineCov">          6 :                   print_generic_expr (dump_file, tmp);</span>
<span class="lineNum">    2802 </span><span class="lineCov">          6 :                   fprintf (dump_file, &quot;\n&quot;);</span>
<span class="lineNum">    2803 </span>            :                 }
<span class="lineNum">    2804 </span>            : 
<span class="lineNum">    2805 </span><span class="lineCov">      31639 :               add_assert_info (asserts, name2, tmp, new_comp_code, new_val);</span>
<span class="lineNum">    2806 </span>            :             }
<span class="lineNum">    2807 </span>            :         }
<span class="lineNum">    2808 </span>            : 
<span class="lineNum">    2809 </span>            :       /* Add asserts for NAME cmp CST and NAME being defined as
<span class="lineNum">    2810 </span>            :          NAME = NAME2 &amp; CST2.
<span class="lineNum">    2811 </span>            : 
<span class="lineNum">    2812 </span>            :          Extract CST2 from the and.
<span class="lineNum">    2813 </span>            : 
<span class="lineNum">    2814 </span>            :          Also handle
<span class="lineNum">    2815 </span>            :          NAME = (unsigned) NAME2;
<span class="lineNum">    2816 </span>            :          casts where NAME's type is unsigned and has smaller precision
<span class="lineNum">    2817 </span>            :          than NAME2's type as if it was NAME = NAME2 &amp; MASK.  */
<span class="lineNum">    2818 </span><span class="lineCov">   14944844 :       names[0] = NULL_TREE;</span>
<span class="lineNum">    2819 </span><span class="lineCov">   14944844 :       names[1] = NULL_TREE;</span>
<span class="lineNum">    2820 </span><span class="lineCov">   14944844 :       cst2 = NULL_TREE;</span>
<span class="lineNum">    2821 </span><span class="lineCov">   14944844 :       if (rhs_code == BIT_AND_EXPR</span>
<span class="lineNum">    2822 </span><span class="lineCov">   14944844 :           || (CONVERT_EXPR_CODE_P (rhs_code)</span>
<span class="lineNum">    2823 </span><span class="lineCov">     936943 :               &amp;&amp; INTEGRAL_TYPE_P (TREE_TYPE (val))</span>
<span class="lineNum">    2824 </span><span class="lineCov">    1872112 :               &amp;&amp; TYPE_UNSIGNED (TREE_TYPE (val))</span>
<span class="lineNum">    2825 </span><span class="lineCov">     519081 :               &amp;&amp; TYPE_PRECISION (TREE_TYPE (gimple_assign_rhs1 (def_stmt)))</span>
<span class="lineNum">    2826 </span>            :                  &gt; prec))
<span class="lineNum">    2827 </span>            :         {
<span class="lineNum">    2828 </span><span class="lineCov">     954746 :           name2 = gimple_assign_rhs1 (def_stmt);</span>
<span class="lineNum">    2829 </span><span class="lineCov">     954746 :           if (rhs_code == BIT_AND_EXPR)</span>
<span class="lineNum">    2830 </span><span class="lineCov">     735134 :             cst2 = gimple_assign_rhs2 (def_stmt);</span>
<span class="lineNum">    2831 </span>            :           else
<span class="lineNum">    2832 </span>            :             {
<span class="lineNum">    2833 </span><span class="lineCov">     219612 :               cst2 = TYPE_MAX_VALUE (TREE_TYPE (val));</span>
<span class="lineNum">    2834 </span><span class="lineCov">     219612 :               nprec = TYPE_PRECISION (TREE_TYPE (name2));</span>
<span class="lineNum">    2835 </span>            :             }
<span class="lineNum">    2836 </span><span class="lineCov">     954746 :           if (TREE_CODE (name2) == SSA_NAME</span>
<span class="lineNum">    2837 </span><span class="lineCov">     954746 :               &amp;&amp; INTEGRAL_TYPE_P (TREE_TYPE (name2))</span>
<span class="lineNum">    2838 </span><span class="lineCov">     954746 :               &amp;&amp; TREE_CODE (cst2) == INTEGER_CST</span>
<span class="lineNum">    2839 </span><span class="lineCov">     703197 :               &amp;&amp; !integer_zerop (cst2)</span>
<span class="lineNum">    2840 </span><span class="lineCov">    1657943 :               &amp;&amp; (nprec &gt; 1</span>
<span class="lineNum">    2841 </span><span class="lineNoCov">          0 :                   || TYPE_UNSIGNED (TREE_TYPE (val))))</span>
<span class="lineNum">    2842 </span>            :             {
<span class="lineNum">    2843 </span><span class="lineCov">     703197 :               gimple *def_stmt2 = SSA_NAME_DEF_STMT (name2);</span>
<span class="lineNum">    2844 </span><span class="lineCov">     703197 :               if (gimple_assign_cast_p (def_stmt2))</span>
<span class="lineNum">    2845 </span>            :                 {
<span class="lineNum">    2846 </span><span class="lineCov">      46773 :                   names[1] = gimple_assign_rhs1 (def_stmt2);</span>
<span class="lineNum">    2847 </span><span class="lineCov">      48876 :                   if (!CONVERT_EXPR_CODE_P (gimple_assign_rhs_code (def_stmt2))</span>
<span class="lineNum">    2848 </span><span class="lineCov">      44672 :                       || !INTEGRAL_TYPE_P (TREE_TYPE (names[1]))</span>
<span class="lineNum">    2849 </span><span class="lineCov">      80244 :                       || (TYPE_PRECISION (TREE_TYPE (name2))</span>
<span class="lineNum">    2850 </span><span class="lineCov">      66942 :                           != TYPE_PRECISION (TREE_TYPE (names[1]))))</span>
<span class="lineNum">    2851 </span><span class="lineCov">      19091 :                     names[1] = NULL_TREE;</span>
<span class="lineNum">    2852 </span>            :                 }
<span class="lineNum">    2853 </span><span class="lineCov">     703197 :               names[0] = name2;</span>
<span class="lineNum">    2854 </span>            :             }
<span class="lineNum">    2855 </span>            :         }
<span class="lineNum">    2856 </span><span class="lineCov">   14944844 :       if (names[0] || names[1])</span>
<span class="lineNum">    2857 </span>            :         {
<span class="lineNum">    2858 </span><span class="lineCov">    2812788 :           wide_int minv, maxv, valv, cst2v;</span>
<span class="lineNum">    2859 </span><span class="lineCov">    1406394 :           wide_int tem, sgnbit;</span>
<span class="lineNum">    2860 </span><span class="lineCov">     703197 :           bool valid_p = false, valn, cst2n;</span>
<span class="lineNum">    2861 </span><span class="lineCov">     703197 :           enum tree_code ccode = comp_code;</span>
<span class="lineNum">    2862 </span>            : 
<span class="lineNum">    2863 </span><span class="lineCov">     703197 :           valv = wide_int::from (wi::to_wide (val), nprec, UNSIGNED);</span>
<span class="lineNum">    2864 </span><span class="lineCov">     703197 :           cst2v = wide_int::from (wi::to_wide (cst2), nprec, UNSIGNED);</span>
<span class="lineNum">    2865 </span><span class="lineCov">     703197 :           valn = wi::neg_p (valv, TYPE_SIGN (TREE_TYPE (val)));</span>
<span class="lineNum">    2866 </span><span class="lineCov">    2109591 :           cst2n = wi::neg_p (cst2v, TYPE_SIGN (TREE_TYPE (val)));</span>
<span class="lineNum">    2867 </span>            :           /* If CST2 doesn't have most significant bit set,
<span class="lineNum">    2868 </span>            :              but VAL is negative, we have comparison like
<span class="lineNum">    2869 </span>            :              if ((x &amp; 0x123) &gt; -4) (always true).  Just give up.  */
<span class="lineNum">    2870 </span><span class="lineCov">     703197 :           if (!cst2n &amp;&amp; valn)</span>
<span class="lineNum">    2871 </span><span class="lineNoCov">          0 :             ccode = ERROR_MARK;</span>
<span class="lineNum">    2872 </span><span class="lineCov">     703197 :           if (cst2n)</span>
<span class="lineNum">    2873 </span><span class="lineCov">       3863 :             sgnbit = wi::set_bit_in_zero (nprec - 1, nprec);</span>
<span class="lineNum">    2874 </span>            :           else
<span class="lineNum">    2875 </span><span class="lineCov">    1398668 :             sgnbit = wi::zero (nprec);</span>
<span class="lineNum">    2876 </span><span class="lineCov">     703197 :           minv = valv &amp; cst2v;</span>
<span class="lineNum">    2877 </span><span class="lineCov">     703197 :           switch (ccode)</span>
<span class="lineNum">    2878 </span>            :             {
<span class="lineNum">    2879 </span><span class="lineCov">     299495 :             case EQ_EXPR:</span>
<span class="lineNum">    2880 </span>            :               /* Minimum unsigned value for equality is VAL &amp; CST2
<span class="lineNum">    2881 </span>            :                  (should be equal to VAL, otherwise we probably should
<span class="lineNum">    2882 </span>            :                  have folded the comparison into false) and
<span class="lineNum">    2883 </span>            :                  maximum unsigned value is VAL | ~CST2.  */
<span class="lineNum">    2884 </span><span class="lineCov">     299495 :               maxv = valv | ~cst2v;</span>
<span class="lineNum">    2885 </span><span class="lineCov">     299495 :               valid_p = true;</span>
<span class="lineNum">    2886 </span><span class="lineCov">     299495 :               break;</span>
<span class="lineNum">    2887 </span>            : 
<span class="lineNum">    2888 </span><span class="lineCov">     382695 :             case NE_EXPR:</span>
<span class="lineNum">    2889 </span><span class="lineCov">     382695 :               tem = valv | ~cst2v;</span>
<span class="lineNum">    2890 </span>            :               /* If VAL is 0, handle (X &amp; CST2) != 0 as (X &amp; CST2) &gt; 0U.  */
<span class="lineNum">    2891 </span><span class="lineCov">     382695 :               if (valv == 0)</span>
<span class="lineNum">    2892 </span>            :                 {
<span class="lineNum">    2893 </span><span class="lineCov">     338238 :                   cst2n = false;</span>
<span class="lineNum">    2894 </span><span class="lineCov">     676476 :                   sgnbit = wi::zero (nprec);</span>
<span class="lineNum">    2895 </span><span class="lineCov">     338238 :                   goto gt_expr;</span>
<span class="lineNum">    2896 </span>            :                 }
<span class="lineNum">    2897 </span>            :               /* If (VAL | ~CST2) is all ones, handle it as
<span class="lineNum">    2898 </span>            :                  (X &amp; CST2) &lt; VAL.  */
<span class="lineNum">    2899 </span><span class="lineCov">      44457 :               if (tem == -1)</span>
<span class="lineNum">    2900 </span>            :                 {
<span class="lineNum">    2901 </span><span class="lineCov">      18464 :                   cst2n = false;</span>
<span class="lineNum">    2902 </span><span class="lineCov">      18464 :                   valn = false;</span>
<span class="lineNum">    2903 </span><span class="lineCov">      36928 :                   sgnbit = wi::zero (nprec);</span>
<span class="lineNum">    2904 </span><span class="lineCov">      18464 :                   goto lt_expr;</span>
<span class="lineNum">    2905 </span>            :                 }
<span class="lineNum">    2906 </span><span class="lineCov">      25993 :               if (!cst2n &amp;&amp; wi::neg_p (cst2v))</span>
<span class="lineNum">    2907 </span><span class="lineCov">       1886 :                 sgnbit = wi::set_bit_in_zero (nprec - 1, nprec);</span>
<span class="lineNum">    2908 </span><span class="lineCov">      25993 :               if (sgnbit != 0)</span>
<span class="lineNum">    2909 </span>            :                 {
<span class="lineNum">    2910 </span><span class="lineCov">       3217 :                   if (valv == sgnbit)</span>
<span class="lineNum">    2911 </span>            :                     {
<span class="lineNum">    2912 </span>            :                       cst2n = true;
<span class="lineNum">    2913 </span>            :                       valn = true;
<span class="lineNum">    2914 </span>            :                       goto gt_expr;
<span class="lineNum">    2915 </span>            :                     }
<span class="lineNum">    2916 </span><span class="lineCov">       2843 :                   if (tem == wi::mask (nprec - 1, false, nprec))</span>
<span class="lineNum">    2917 </span>            :                     {
<span class="lineNum">    2918 </span>            :                       cst2n = true;
<span class="lineNum">    2919 </span>            :                       goto lt_expr;
<span class="lineNum">    2920 </span>            :                     }
<span class="lineNum">    2921 </span><span class="lineCov">       2689 :                   if (!cst2n)</span>
<span class="lineNum">    2922 </span><span class="lineCov">       3040 :                     sgnbit = wi::zero (nprec);</span>
<span class="lineNum">    2923 </span>            :                 }
<span class="lineNum">    2924 </span>            :               break;
<span class="lineNum">    2925 </span>            : 
<span class="lineNum">    2926 </span><span class="lineCov">       1046 :             case GE_EXPR:</span>
<span class="lineNum">    2927 </span>            :               /* Minimum unsigned value for &gt;= if (VAL &amp; CST2) == VAL
<span class="lineNum">    2928 </span>            :                  is VAL and maximum unsigned value is ~0.  For signed
<span class="lineNum">    2929 </span>            :                  comparison, if CST2 doesn't have most significant bit
<span class="lineNum">    2930 </span>            :                  set, handle it similarly.  If CST2 has MSB set,
<span class="lineNum">    2931 </span>            :                  the minimum is the same, and maximum is ~0U/2.  */
<span class="lineNum">    2932 </span><span class="lineCov">       1046 :               if (minv != valv)</span>
<span class="lineNum">    2933 </span>            :                 {
<span class="lineNum">    2934 </span>            :                   /* If (VAL &amp; CST2) != VAL, X &amp; CST2 can't be equal to
<span class="lineNum">    2935 </span>            :                      VAL.  */
<span class="lineNum">    2936 </span><span class="lineCov">         26 :                   minv = masked_increment (valv, cst2v, sgnbit, nprec);</span>
<span class="lineNum">    2937 </span><span class="lineCov">         26 :                   if (minv == valv)</span>
<span class="lineNum">    2938 </span>            :                     break;
<span class="lineNum">    2939 </span>            :                 }
<span class="lineNum">    2940 </span><span class="lineCov">       1046 :               maxv = wi::mask (nprec - (cst2n ? 1 : 0), false, nprec);</span>
<span class="lineNum">    2941 </span><span class="lineCov">       1046 :               valid_p = true;</span>
<span class="lineNum">    2942 </span><span class="lineCov">       1046 :               break;</span>
<span class="lineNum">    2943 </span>            : 
<span class="lineNum">    2944 </span><span class="lineCov">     347918 :             case GT_EXPR:</span>
<span class="lineNum">    2945 </span><span class="lineCov">     695836 :             gt_expr:</span>
<span class="lineNum">    2946 </span>            :               /* Find out smallest MINV where MINV &gt; VAL
<span class="lineNum">    2947 </span>            :                  &amp;&amp; (MINV &amp; CST2) == MINV, if any.  If VAL is signed and
<span class="lineNum">    2948 </span>            :                  CST2 has MSB set, compute it biased by 1 &lt;&lt; (nprec - 1).  */
<span class="lineNum">    2949 </span><span class="lineCov">     347918 :               minv = masked_increment (valv, cst2v, sgnbit, nprec);</span>
<span class="lineNum">    2950 </span><span class="lineCov">     347918 :               if (minv == valv)</span>
<span class="lineNum">    2951 </span>            :                 break;
<span class="lineNum">    2952 </span><span class="lineCov">     347916 :               maxv = wi::mask (nprec - (cst2n ? 1 : 0), false, nprec);</span>
<span class="lineNum">    2953 </span><span class="lineCov">     347916 :               valid_p = true;</span>
<span class="lineNum">    2954 </span><span class="lineCov">     347916 :               break;</span>
<span class="lineNum">    2955 </span>            : 
<span class="lineNum">    2956 </span><span class="lineCov">      10406 :             case LE_EXPR:</span>
<span class="lineNum">    2957 </span>            :               /* Minimum unsigned value for &lt;= is 0 and maximum
<span class="lineNum">    2958 </span>            :                  unsigned value is VAL | ~CST2 if (VAL &amp; CST2) == VAL.
<span class="lineNum">    2959 </span>            :                  Otherwise, find smallest VAL2 where VAL2 &gt; VAL
<span class="lineNum">    2960 </span>            :                  &amp;&amp; (VAL2 &amp; CST2) == VAL2 and use (VAL2 - 1) | ~CST2
<span class="lineNum">    2961 </span>            :                  as maximum.
<span class="lineNum">    2962 </span>            :                  For signed comparison, if CST2 doesn't have most
<span class="lineNum">    2963 </span>            :                  significant bit set, handle it similarly.  If CST2 has
<span class="lineNum">    2964 </span>            :                  MSB set, the maximum is the same and minimum is INT_MIN.  */
<span class="lineNum">    2965 </span><span class="lineCov">      10406 :               if (minv == valv)</span>
<span class="lineNum">    2966 </span><span class="lineCov">      10050 :                 maxv = valv;</span>
<span class="lineNum">    2967 </span>            :               else
<span class="lineNum">    2968 </span>            :                 {
<span class="lineNum">    2969 </span><span class="lineCov">        356 :                   maxv = masked_increment (valv, cst2v, sgnbit, nprec);</span>
<span class="lineNum">    2970 </span><span class="lineCov">        356 :                   if (maxv == valv)</span>
<span class="lineNum">    2971 </span>            :                     break;
<span class="lineNum">    2972 </span><span class="lineCov">        352 :                   maxv -= 1;</span>
<span class="lineNum">    2973 </span>            :                 }
<span class="lineNum">    2974 </span><span class="lineCov">      10402 :               maxv |= ~cst2v;</span>
<span class="lineNum">    2975 </span><span class="lineCov">      10402 :               minv = sgnbit;</span>
<span class="lineNum">    2976 </span><span class="lineCov">      10402 :               valid_p = true;</span>
<span class="lineNum">    2977 </span><span class="lineCov">      10402 :               break;</span>
<span class="lineNum">    2978 </span>            : 
<span class="lineNum">    2979 </span><span class="lineCov">      18867 :             case LT_EXPR:</span>
<span class="lineNum">    2980 </span><span class="lineCov">      37734 :             lt_expr:</span>
<span class="lineNum">    2981 </span>            :               /* Minimum unsigned value for &lt; is 0 and maximum
<span class="lineNum">    2982 </span>            :                  unsigned value is (VAL-1) | ~CST2 if (VAL &amp; CST2) == VAL.
<span class="lineNum">    2983 </span>            :                  Otherwise, find smallest VAL2 where VAL2 &gt; VAL
<span class="lineNum">    2984 </span>            :                  &amp;&amp; (VAL2 &amp; CST2) == VAL2 and use (VAL2 - 1) | ~CST2
<span class="lineNum">    2985 </span>            :                  as maximum.
<span class="lineNum">    2986 </span>            :                  For signed comparison, if CST2 doesn't have most
<span class="lineNum">    2987 </span>            :                  significant bit set, handle it similarly.  If CST2 has
<span class="lineNum">    2988 </span>            :                  MSB set, the maximum is the same and minimum is INT_MIN.  */
<span class="lineNum">    2989 </span><span class="lineCov">      18867 :               if (minv == valv)</span>
<span class="lineNum">    2990 </span>            :                 {
<span class="lineNum">    2991 </span><span class="lineCov">      18841 :                   if (valv == sgnbit)</span>
<span class="lineNum">    2992 </span>            :                     break;
<span class="lineNum">    2993 </span><span class="lineCov">      18815 :                   maxv = valv;</span>
<span class="lineNum">    2994 </span>            :                 }
<span class="lineNum">    2995 </span>            :               else
<span class="lineNum">    2996 </span>            :                 {
<span class="lineNum">    2997 </span><span class="lineCov">         26 :                   maxv = masked_increment (valv, cst2v, sgnbit, nprec);</span>
<span class="lineNum">    2998 </span><span class="lineCov">         26 :                   if (maxv == valv)</span>
<span class="lineNum">    2999 </span>            :                     break;
<span class="lineNum">    3000 </span>            :                 }
<span class="lineNum">    3001 </span><span class="lineCov">      18841 :               maxv -= 1;</span>
<span class="lineNum">    3002 </span><span class="lineCov">      18841 :               maxv |= ~cst2v;</span>
<span class="lineNum">    3003 </span><span class="lineCov">      18841 :               minv = sgnbit;</span>
<span class="lineNum">    3004 </span><span class="lineCov">      18841 :               valid_p = true;</span>
<span class="lineNum">    3005 </span><span class="lineCov">      18841 :               break;</span>
<span class="lineNum">    3006 </span>            : 
<span class="lineNum">    3007 </span>            :             default:
<span class="lineNum">    3008 </span>            :               break;
<span class="lineNum">    3009 </span>            :             }
<span class="lineNum">    3010 </span><span class="lineCov">     679220 :           if (valid_p</span>
<span class="lineNum">    3011 </span><span class="lineCov">    1380586 :               &amp;&amp; (maxv - minv) != -1)</span>
<span class="lineNum">    3012 </span>            :             {
<span class="lineNum">    3013 </span>            :               tree tmp, new_val, type;
<span class="lineNum">    3014 </span>            :               int i;
<span class="lineNum">    3015 </span>            : 
<span class="lineNum">    3016 </span><span class="lineCov">    2032797 :               for (i = 0; i &lt; 2; i++)</span>
<span class="lineNum">    3017 </span><span class="lineCov">    1355198 :                 if (names[i])</span>
<span class="lineNum">    3018 </span>            :                   {
<span class="lineNum">    3019 </span><span class="lineCov">     704712 :                     wide_int maxv2 = maxv;</span>
<span class="lineNum">    3020 </span><span class="lineCov">     704712 :                     tmp = names[i];</span>
<span class="lineNum">    3021 </span><span class="lineCov">     704712 :                     type = TREE_TYPE (names[i]);</span>
<span class="lineNum">    3022 </span><span class="lineCov">     704712 :                     if (!TYPE_UNSIGNED (type))</span>
<span class="lineNum">    3023 </span>            :                       {
<span class="lineNum">    3024 </span><span class="lineCov">     241318 :                         type = build_nonstandard_integer_type (nprec, 1);</span>
<span class="lineNum">    3025 </span><span class="lineCov">     241318 :                         tmp = build1 (NOP_EXPR, type, names[i]);</span>
<span class="lineNum">    3026 </span>            :                       }
<span class="lineNum">    3027 </span><span class="lineCov">     704712 :                     if (minv != 0)</span>
<span class="lineNum">    3028 </span>            :                       {
<span class="lineNum">    3029 </span><span class="lineCov">     419545 :                         tmp = build2 (PLUS_EXPR, type, tmp,</span>
<span class="lineNum">    3030 </span><span class="lineCov">     419545 :                                       wide_int_to_tree (type, -minv));</span>
<span class="lineNum">    3031 </span><span class="lineCov">     419545 :                         maxv2 = maxv - minv;</span>
<span class="lineNum">    3032 </span>            :                       }
<span class="lineNum">    3033 </span><span class="lineCov">    1409424 :                     new_val = wide_int_to_tree (type, maxv2);</span>
<span class="lineNum">    3034 </span>            : 
<span class="lineNum">    3035 </span><span class="lineCov">     704712 :                     if (dump_file)</span>
<span class="lineNum">    3036 </span>            :                       {
<span class="lineNum">    3037 </span><span class="lineCov">        217 :                         fprintf (dump_file, &quot;Adding assert for &quot;);</span>
<span class="lineNum">    3038 </span><span class="lineCov">        217 :                         print_generic_expr (dump_file, names[i]);</span>
<span class="lineNum">    3039 </span><span class="lineCov">        217 :                         fprintf (dump_file, &quot; from &quot;);</span>
<span class="lineNum">    3040 </span><span class="lineCov">        217 :                         print_generic_expr (dump_file, tmp);</span>
<span class="lineNum">    3041 </span><span class="lineCov">        217 :                         fprintf (dump_file, &quot;\n&quot;);</span>
<span class="lineNum">    3042 </span>            :                       }
<span class="lineNum">    3043 </span>            : 
<span class="lineNum">    3044 </span><span class="lineCov">     704712 :                     add_assert_info (asserts, names[i], tmp, LE_EXPR, new_val);</span>
<span class="lineNum">    3045 </span>            :                   }
<span class="lineNum">    3046 </span>            :             }
<span class="lineNum">    3047 </span>            :         }
<span class="lineNum">    3048 </span>            :     }
<span class="lineNum">    3049 </span>            : }
<span class="lineNum">    3050 </span>            : 
<span class="lineNum">    3051 </span>            : /* OP is an operand of a truth value expression which is known to have
<span class="lineNum">    3052 </span>            :    a particular value.  Register any asserts for OP and for any
<span class="lineNum">    3053 </span>            :    operands in OP's defining statement.
<span class="lineNum">    3054 </span>            : 
<span class="lineNum">    3055 </span>            :    If CODE is EQ_EXPR, then we want to register OP is zero (false),
<span class="lineNum">    3056 </span>            :    if CODE is NE_EXPR, then we want to register OP is nonzero (true).   */
<a name="3057"><span class="lineNum">    3057 </span>            : </a>
<span class="lineNum">    3058 </span>            : static void
<span class="lineNum">    3059 </span><span class="lineCov">    1347555 : register_edge_assert_for_1 (tree op, enum tree_code code,</span>
<span class="lineNum">    3060 </span>            :                             edge e, vec&lt;assert_info&gt; &amp;asserts)
<span class="lineNum">    3061 </span>            : {
<span class="lineNum">    3062 </span><span class="lineCov">    1437533 :   gimple *op_def;</span>
<span class="lineNum">    3063 </span><span class="lineCov">    1437533 :   tree val;</span>
<span class="lineNum">    3064 </span><span class="lineCov">    1437533 :   enum tree_code rhs_code;</span>
<span class="lineNum">    3065 </span>            : 
<span class="lineNum">    3066 </span>            :   /* We only care about SSA_NAMEs.  */
<span class="lineNum">    3067 </span><span class="lineCov">    1437533 :   if (TREE_CODE (op) != SSA_NAME)</span>
<span class="lineNum">    3068 </span>            :     return;
<span class="lineNum">    3069 </span>            : 
<span class="lineNum">    3070 </span>            :   /* We know that OP will have a zero or nonzero value.  */
<span class="lineNum">    3071 </span><span class="lineCov">    2476398 :   val = build_int_cst (TREE_TYPE (op), 0);</span>
<span class="lineNum">    3072 </span><span class="lineCov">    1238199 :   add_assert_info (asserts, op, op, code, val);</span>
<span class="lineNum">    3073 </span>            : 
<span class="lineNum">    3074 </span>            :   /* Now look at how OP is set.  If it's set from a comparison,
<span class="lineNum">    3075 </span>            :      a truth operation or some bit operations, then we may be able
<span class="lineNum">    3076 </span>            :      to register information about the operands of that assignment.  */
<span class="lineNum">    3077 </span><span class="lineCov">    1238199 :   op_def = SSA_NAME_DEF_STMT (op);</span>
<span class="lineNum">    3078 </span><span class="lineCov">    2476398 :   if (gimple_code (op_def) != GIMPLE_ASSIGN)</span>
<span class="lineNum">    3079 </span>            :     return;
<span class="lineNum">    3080 </span>            : 
<span class="lineNum">    3081 </span><span class="lineCov">    1132778 :   rhs_code = gimple_assign_rhs_code (op_def);</span>
<span class="lineNum">    3082 </span>            : 
<span class="lineNum">    3083 </span><span class="lineCov">    1132778 :   if (TREE_CODE_CLASS (rhs_code) == tcc_comparison)</span>
<span class="lineNum">    3084 </span>            :     {
<span class="lineNum">    3085 </span><span class="lineCov">     811835 :       bool invert = (code == EQ_EXPR ? true : false);</span>
<span class="lineNum">    3086 </span><span class="lineCov">     811835 :       tree op0 = gimple_assign_rhs1 (op_def);</span>
<span class="lineNum">    3087 </span><span class="lineCov">     811835 :       tree op1 = gimple_assign_rhs2 (op_def);</span>
<span class="lineNum">    3088 </span>            : 
<span class="lineNum">    3089 </span><span class="lineCov">     811835 :       if (TREE_CODE (op0) == SSA_NAME)</span>
<span class="lineNum">    3090 </span><span class="lineCov">     810660 :         register_edge_assert_for_2 (op0, e, rhs_code, op0, op1, invert, asserts);</span>
<span class="lineNum">    3091 </span><span class="lineCov">     811835 :       if (TREE_CODE (op1) == SSA_NAME)</span>
<span class="lineNum">    3092 </span><span class="lineCov">     204284 :         register_edge_assert_for_2 (op1, e, rhs_code, op0, op1, invert, asserts);</span>
<span class="lineNum">    3093 </span>            :     }
<span class="lineNum">    3094 </span><span class="lineCov">     320943 :   else if ((code == NE_EXPR</span>
<span class="lineNum">    3095 </span><span class="lineCov">     249942 :             &amp;&amp; gimple_assign_rhs_code (op_def) == BIT_AND_EXPR)</span>
<span class="lineNum">    3096 </span><span class="lineCov">     558915 :            || (code == EQ_EXPR</span>
<span class="lineNum">    3097 </span><span class="lineCov">      71001 :                &amp;&amp; gimple_assign_rhs_code (op_def) == BIT_IOR_EXPR))</span>
<span class="lineNum">    3098 </span>            :     {
<span class="lineNum">    3099 </span>            :       /* Recurse on each operand.  */
<span class="lineNum">    3100 </span><span class="lineCov">      46021 :       tree op0 = gimple_assign_rhs1 (op_def);</span>
<span class="lineNum">    3101 </span><span class="lineCov">      46021 :       tree op1 = gimple_assign_rhs2 (op_def);</span>
<span class="lineNum">    3102 </span><span class="lineCov">      46021 :       if (TREE_CODE (op0) == SSA_NAME</span>
<span class="lineNum">    3103 </span><span class="lineCov">      46021 :           &amp;&amp; has_single_use (op0))</span>
<span class="lineNum">    3104 </span><span class="lineCov">      42011 :         register_edge_assert_for_1 (op0, code, e, asserts);</span>
<span class="lineNum">    3105 </span><span class="lineCov">      46021 :       if (TREE_CODE (op1) == SSA_NAME</span>
<span class="lineNum">    3106 </span><span class="lineCov">      46021 :           &amp;&amp; has_single_use (op1))</span>
<span class="lineNum">    3107 </span>            :         register_edge_assert_for_1 (op1, code, e, asserts);
<span class="lineNum">    3108 </span>            :     }
<span class="lineNum">    3109 </span><span class="lineCov">     274922 :   else if (gimple_assign_rhs_code (op_def) == BIT_NOT_EXPR</span>
<span class="lineNum">    3110 </span><span class="lineCov">     274922 :            &amp;&amp; TYPE_PRECISION (TREE_TYPE (gimple_assign_lhs (op_def))) == 1)</span>
<span class="lineNum">    3111 </span>            :     {
<span class="lineNum">    3112 </span>            :       /* Recurse, flipping CODE.  */
<span class="lineNum">    3113 </span><span class="lineCov">      15453 :       code = invert_tree_comparison (code, false);</span>
<span class="lineNum">    3114 </span><span class="lineCov">      15453 :       register_edge_assert_for_1 (gimple_assign_rhs1 (op_def), code, e, asserts);</span>
<span class="lineNum">    3115 </span>            :     }
<span class="lineNum">    3116 </span><span class="lineCov">     259469 :   else if (gimple_assign_rhs_code (op_def) == SSA_NAME)</span>
<span class="lineNum">    3117 </span>            :     {
<span class="lineNum">    3118 </span>            :       /* Recurse through the copy.  */
<span class="lineNum">    3119 </span><span class="lineCov">        296 :       register_edge_assert_for_1 (gimple_assign_rhs1 (op_def), code, e, asserts);</span>
<span class="lineNum">    3120 </span>            :     }
<span class="lineNum">    3121 </span><span class="lineCov">     259321 :   else if (CONVERT_EXPR_CODE_P (gimple_assign_rhs_code (op_def)))</span>
<span class="lineNum">    3122 </span>            :     {
<span class="lineNum">    3123 </span>            :       /* Recurse through the type conversion, unless it is a narrowing
<span class="lineNum">    3124 </span>            :          conversion or conversion from non-integral type.  */
<span class="lineNum">    3125 </span><span class="lineCov">      50440 :       tree rhs = gimple_assign_rhs1 (op_def);</span>
<span class="lineNum">    3126 </span><span class="lineCov">     150142 :       if (INTEGRAL_TYPE_P (TREE_TYPE (rhs))</span>
<span class="lineNum">    3127 </span><span class="lineCov">     123028 :           &amp;&amp; (TYPE_PRECISION (TREE_TYPE (rhs))</span>
<span class="lineNum">    3128 </span><span class="lineCov">      36883 :               &lt;= TYPE_PRECISION (TREE_TYPE (op))))</span>
<span class="lineNum">    3129 </span>            :         register_edge_assert_for_1 (rhs, code, e, asserts);
<span class="lineNum">    3130 </span>            :     }
<span class="lineNum">    3131 </span>            : }
<span class="lineNum">    3132 </span>            : 
<span class="lineNum">    3133 </span>            : /* Check if comparison
<span class="lineNum">    3134 </span>            :      NAME COND_OP INTEGER_CST
<span class="lineNum">    3135 </span>            :    has a form of
<span class="lineNum">    3136 </span>            :      (X &amp; 11...100..0) COND_OP XX...X00...0
<span class="lineNum">    3137 </span>            :    Such comparison can yield assertions like
<span class="lineNum">    3138 </span>            :      X &gt;= XX...X00...0
<span class="lineNum">    3139 </span>            :      X &lt;= XX...X11...1
<span class="lineNum">    3140 </span>            :    in case of COND_OP being EQ_EXPR or
<span class="lineNum">    3141 </span>            :      X &lt; XX...X00...0
<span class="lineNum">    3142 </span>            :      X &gt; XX...X11...1
<span class="lineNum">    3143 </span>            :    in case of NE_EXPR.  */
<span class="lineNum">    3144 </span>            : 
<span class="lineNum">    3145 </span>            : static bool
<span class="lineNum">    3146 </span><span class="lineCov">   12296729 : is_masked_range_test (tree name, tree valt, enum tree_code cond_code,</span>
<span class="lineNum">    3147 </span>            :                       tree *new_name, tree *low, enum tree_code *low_code,
<span class="lineNum">    3148 </span>            :                       tree *high, enum tree_code *high_code)
<span class="lineNum">    3149 </span>            : {
<span class="lineNum">    3150 </span><span class="lineCov">   12296729 :   gimple *def_stmt = SSA_NAME_DEF_STMT (name);</span>
<span class="lineNum">    3151 </span>            : 
<span class="lineNum">    3152 </span><span class="lineCov">   12296729 :   if (!is_gimple_assign (def_stmt)</span>
<span class="lineNum">    3153 </span><span class="lineCov">   12296729 :       || gimple_assign_rhs_code (def_stmt) != BIT_AND_EXPR)</span>
<span class="lineNum">    3154 </span>            :     return false;
<span class="lineNum">    3155 </span>            : 
<span class="lineNum">    3156 </span><span class="lineCov">     701655 :   tree t = gimple_assign_rhs1 (def_stmt);</span>
<span class="lineNum">    3157 </span><span class="lineCov">     701655 :   tree maskt = gimple_assign_rhs2 (def_stmt);</span>
<span class="lineNum">    3158 </span><span class="lineCov">     701655 :   if (TREE_CODE (t) != SSA_NAME || TREE_CODE (maskt) != INTEGER_CST)</span>
<span class="lineNum">    3159 </span>            :     return false;
<span class="lineNum">    3160 </span>            : 
<span class="lineNum">    3161 </span><span class="lineCov">     451562 :   wi::tree_to_wide_ref mask = wi::to_wide (maskt);</span>
<span class="lineNum">    3162 </span><span class="lineCov">     451562 :   wide_int inv_mask = ~mask;</span>
<span class="lineNum">    3163 </span>            :   /* Must have been removed by now so don't bother optimizing.  */
<span class="lineNum">    3164 </span><span class="lineCov">     451562 :   if (mask == 0 || inv_mask == 0)</span>
<span class="lineNum">    3165 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    3166 </span>            : 
<span class="lineNum">    3167 </span>            :   /* Assume VALT is INTEGER_CST.  */
<span class="lineNum">    3168 </span><span class="lineCov">     451562 :   wi::tree_to_wide_ref val = wi::to_wide (valt);</span>
<span class="lineNum">    3169 </span>            : 
<span class="lineNum">    3170 </span><span class="lineCov">     451562 :   if ((inv_mask &amp; (inv_mask + 1)) != 0</span>
<span class="lineNum">    3171 </span><span class="lineCov">       9353 :       || (val &amp; mask) != val)</span>
<span class="lineNum">    3172 </span><span class="lineCov">     442209 :     return false;</span>
<span class="lineNum">    3173 </span>            : 
<span class="lineNum">    3174 </span><span class="lineCov">       9353 :   bool is_range = cond_code == EQ_EXPR;</span>
<span class="lineNum">    3175 </span>            : 
<span class="lineNum">    3176 </span><span class="lineCov">       9353 :   tree type = TREE_TYPE (t);</span>
<span class="lineNum">    3177 </span><span class="lineCov">       9353 :   wide_int min = wi::min_value (type),</span>
<span class="lineNum">    3178 </span><span class="lineCov">       9353 :     max = wi::max_value (type);</span>
<span class="lineNum">    3179 </span>            : 
<span class="lineNum">    3180 </span><span class="lineCov">       9353 :   if (is_range)</span>
<span class="lineNum">    3181 </span>            :     {
<span class="lineNum">    3182 </span><span class="lineCov">       5770 :       *low_code = val == min ? ERROR_MARK : GE_EXPR;</span>
<span class="lineNum">    3183 </span><span class="lineCov">      11540 :       *high_code = val == max ? ERROR_MARK : LE_EXPR;</span>
<span class="lineNum">    3184 </span>            :     }
<span class="lineNum">    3185 </span>            :   else
<span class="lineNum">    3186 </span>            :     {
<span class="lineNum">    3187 </span>            :       /* We can still generate assertion if one of alternatives
<span class="lineNum">    3188 </span>            :          is known to always be false.  */
<span class="lineNum">    3189 </span><span class="lineCov">       3583 :       if (val == min)</span>
<span class="lineNum">    3190 </span>            :         {
<span class="lineNum">    3191 </span><span class="lineCov">       2486 :           *low_code = (enum tree_code) 0;</span>
<span class="lineNum">    3192 </span><span class="lineCov">       2486 :           *high_code = GT_EXPR;</span>
<span class="lineNum">    3193 </span>            :         }
<span class="lineNum">    3194 </span><span class="lineCov">       1097 :       else if ((val | inv_mask) == max)</span>
<span class="lineNum">    3195 </span>            :         {
<span class="lineNum">    3196 </span><span class="lineCov">        141 :           *low_code = LT_EXPR;</span>
<span class="lineNum">    3197 </span><span class="lineCov">        141 :           *high_code = (enum tree_code) 0;</span>
<span class="lineNum">    3198 </span>            :         }
<span class="lineNum">    3199 </span>            :       else
<span class="lineNum">    3200 </span>            :         return false;
<span class="lineNum">    3201 </span>            :     }
<span class="lineNum">    3202 </span>            : 
<span class="lineNum">    3203 </span><span class="lineCov">       8397 :   *new_name = t;</span>
<span class="lineNum">    3204 </span><span class="lineCov">      16794 :   *low = wide_int_to_tree (type, val);</span>
<span class="lineNum">    3205 </span><span class="lineCov">       8397 :   *high = wide_int_to_tree (type, val | inv_mask);</span>
<span class="lineNum">    3206 </span>            : 
<span class="lineNum">    3207 </span><span class="lineCov">       8397 :   return true;</span>
<span class="lineNum">    3208 </span>            : }
<span class="lineNum">    3209 </span>            : 
<span class="lineNum">    3210 </span>            : /* Try to register an edge assertion for SSA name NAME on edge E for
<span class="lineNum">    3211 </span>            :    the condition COND contributing to the conditional jump pointed to by
<span class="lineNum">    3212 </span>            :    SI.  */
<a name="3213"><span class="lineNum">    3213 </span>            : </a>
<span class="lineNum">    3214 </span>            : void
<span class="lineNum">    3215 </span><span class="lineCov">   24681273 : register_edge_assert_for (tree name, edge e,</span>
<span class="lineNum">    3216 </span>            :                           enum tree_code cond_code, tree cond_op0,
<span class="lineNum">    3217 </span>            :                           tree cond_op1, vec&lt;assert_info&gt; &amp;asserts)
<span class="lineNum">    3218 </span>            : {
<span class="lineNum">    3219 </span><span class="lineCov">   24681273 :   tree val;</span>
<span class="lineNum">    3220 </span><span class="lineCov">   24681273 :   enum tree_code comp_code;</span>
<span class="lineNum">    3221 </span><span class="lineCov">   24681273 :   bool is_else_edge = (e-&gt;flags &amp; EDGE_FALSE_VALUE) != 0;</span>
<span class="lineNum">    3222 </span>            : 
<span class="lineNum">    3223 </span>            :   /* Do not attempt to infer anything in names that flow through
<span class="lineNum">    3224 </span>            :      abnormal edges.  */
<span class="lineNum">    3225 </span><span class="lineCov">   24681273 :   if (SSA_NAME_OCCURS_IN_ABNORMAL_PHI (name))</span>
<span class="lineNum">    3226 </span><span class="lineCov">       1029 :     return;</span>
<span class="lineNum">    3227 </span>            : 
<span class="lineNum">    3228 </span><span class="lineCov">   24680860 :   if (!extract_code_and_val_from_cond_with_ops (name, cond_code,</span>
<span class="lineNum">    3229 </span>            :                                                 cond_op0, cond_op1,
<span class="lineNum">    3230 </span>            :                                                 is_else_edge,
<span class="lineNum">    3231 </span>            :                                                 &amp;comp_code, &amp;val))
<span class="lineNum">    3232 </span>            :     return;
<span class="lineNum">    3233 </span>            : 
<span class="lineNum">    3234 </span>            :   /* Register ASSERT_EXPRs for name.  */
<span class="lineNum">    3235 </span><span class="lineCov">   24680244 :   register_edge_assert_for_2 (name, e, cond_code, cond_op0,</span>
<span class="lineNum">    3236 </span>            :                               cond_op1, is_else_edge, asserts);
<span class="lineNum">    3237 </span>            : 
<span class="lineNum">    3238 </span>            : 
<span class="lineNum">    3239 </span>            :   /* If COND is effectively an equality test of an SSA_NAME against
<span class="lineNum">    3240 </span>            :      the value zero or one, then we may be able to assert values
<span class="lineNum">    3241 </span>            :      for SSA_NAMEs which flow into COND.  */
<span class="lineNum">    3242 </span>            : 
<span class="lineNum">    3243 </span>            :   /* In the case of NAME == 1 or NAME != 0, for BIT_AND_EXPR defining
<span class="lineNum">    3244 </span>            :      statement of NAME we can assert both operands of the BIT_AND_EXPR
<span class="lineNum">    3245 </span>            :      have nonzero value.  */
<span class="lineNum">    3246 </span><span class="lineCov">    8620726 :   if (((comp_code == EQ_EXPR &amp;&amp; integer_onep (val))</span>
<span class="lineNum">    3247 </span><span class="lineCov">   32970723 :        || (comp_code == NE_EXPR &amp;&amp; integer_zerop (val))))</span>
<span class="lineNum">    3248 </span>            :     {
<span class="lineNum">    3249 </span><span class="lineCov">    5215365 :       gimple *def_stmt = SSA_NAME_DEF_STMT (name);</span>
<span class="lineNum">    3250 </span>            : 
<span class="lineNum">    3251 </span><span class="lineCov">    5215365 :       if (is_gimple_assign (def_stmt)</span>
<span class="lineNum">    3252 </span><span class="lineCov">    5215365 :           &amp;&amp; gimple_assign_rhs_code (def_stmt) == BIT_AND_EXPR)</span>
<span class="lineNum">    3253 </span>            :         {
<span class="lineNum">    3254 </span><span class="lineCov">     339593 :           tree op0 = gimple_assign_rhs1 (def_stmt);</span>
<span class="lineNum">    3255 </span><span class="lineCov">     339593 :           tree op1 = gimple_assign_rhs2 (def_stmt);</span>
<span class="lineNum">    3256 </span><span class="lineCov">     339593 :           register_edge_assert_for_1 (op0, NE_EXPR, e, asserts);</span>
<span class="lineNum">    3257 </span><span class="lineCov">     339593 :           register_edge_assert_for_1 (op1, NE_EXPR, e, asserts);</span>
<span class="lineNum">    3258 </span>            :         }
<span class="lineNum">    3259 </span>            :     }
<span class="lineNum">    3260 </span>            : 
<span class="lineNum">    3261 </span>            :   /* In the case of NAME == 0 or NAME != 1, for BIT_IOR_EXPR defining
<span class="lineNum">    3262 </span>            :      statement of NAME we can assert both operands of the BIT_IOR_EXPR
<span class="lineNum">    3263 </span>            :      have zero value.  */
<span class="lineNum">    3264 </span><span class="lineCov">    8620726 :   if (((comp_code == EQ_EXPR &amp;&amp; integer_zerop (val))</span>
<span class="lineNum">    3265 </span><span class="lineCov">   29234859 :        || (comp_code == NE_EXPR &amp;&amp; integer_onep (val))))</span>
<span class="lineNum">    3266 </span>            :     {
<span class="lineNum">    3267 </span><span class="lineCov">    4349024 :       gimple *def_stmt = SSA_NAME_DEF_STMT (name);</span>
<span class="lineNum">    3268 </span>            : 
<span class="lineNum">    3269 </span>            :       /* For BIT_IOR_EXPR only if NAME == 0 both operands have
<span class="lineNum">    3270 </span>            :          necessarily zero value, or if type-precision is one.  */
<span class="lineNum">    3271 </span><span class="lineCov">    4349024 :       if (is_gimple_assign (def_stmt)</span>
<span class="lineNum">    3272 </span><span class="lineCov">    4349024 :           &amp;&amp; (gimple_assign_rhs_code (def_stmt) == BIT_IOR_EXPR</span>
<span class="lineNum">    3273 </span><span class="lineCov">     313312 :               &amp;&amp; (TYPE_PRECISION (TREE_TYPE (name)) == 1</span>
<span class="lineNum">    3274 </span><span class="lineCov">       9520 :                   || comp_code == EQ_EXPR)))</span>
<span class="lineNum">    3275 </span>            :         {
<span class="lineNum">    3276 </span><span class="lineCov">     313179 :           tree op0 = gimple_assign_rhs1 (def_stmt);</span>
<span class="lineNum">    3277 </span><span class="lineCov">     313179 :           tree op1 = gimple_assign_rhs2 (def_stmt);</span>
<span class="lineNum">    3278 </span><span class="lineCov">     313179 :           register_edge_assert_for_1 (op0, EQ_EXPR, e, asserts);</span>
<span class="lineNum">    3279 </span><span class="lineCov">     313179 :           register_edge_assert_for_1 (op1, EQ_EXPR, e, asserts);</span>
<span class="lineNum">    3280 </span>            :         }
<span class="lineNum">    3281 </span>            :     }
<span class="lineNum">    3282 </span>            : 
<span class="lineNum">    3283 </span>            :   /* Sometimes we can infer ranges from (NAME &amp; MASK) == VALUE.  */
<span class="lineNum">    3284 </span><span class="lineCov">   24680244 :   if ((comp_code == EQ_EXPR || comp_code == NE_EXPR)</span>
<span class="lineNum">    3285 </span><span class="lineCov">   17732676 :       &amp;&amp; TREE_CODE (val) == INTEGER_CST)</span>
<span class="lineNum">    3286 </span>            :     {
<span class="lineNum">    3287 </span><span class="lineCov">   12296729 :       enum tree_code low_code, high_code;</span>
<span class="lineNum">    3288 </span><span class="lineCov">   12296729 :       tree low, high;</span>
<span class="lineNum">    3289 </span><span class="lineCov">   12296729 :       if (is_masked_range_test (name, val, comp_code, &amp;name, &amp;low,</span>
<span class="lineNum">    3290 </span>            :                                 &amp;low_code, &amp;high, &amp;high_code))
<span class="lineNum">    3291 </span>            :         {
<span class="lineNum">    3292 </span><span class="lineCov">       8397 :           if (low_code != ERROR_MARK)</span>
<span class="lineNum">    3293 </span><span class="lineCov">       1481 :             register_edge_assert_for_2 (name, e, low_code, name,</span>
<span class="lineNum">    3294 </span>            :                                         low, /*invert*/false, asserts);
<span class="lineNum">    3295 </span><span class="lineCov">       8397 :           if (high_code != ERROR_MARK)</span>
<span class="lineNum">    3296 </span><span class="lineCov">       8256 :             register_edge_assert_for_2 (name, e, high_code, name,</span>
<span class="lineNum">    3297 </span>            :                                         high, /*invert*/false, asserts);
<span class="lineNum">    3298 </span>            :         }
<span class="lineNum">    3299 </span>            :     }
<span class="lineNum">    3300 </span>            : }
<span class="lineNum">    3301 </span>            : 
<span class="lineNum">    3302 </span>            : /* Finish found ASSERTS for E and register them at GSI.  */
<a name="3303"><span class="lineNum">    3303 </span>            : </a>
<span class="lineNum">    3304 </span>            : static void
<span class="lineNum">    3305 </span><span class="lineCov">    8523196 : finish_register_edge_assert_for (edge e, gimple_stmt_iterator gsi,</span>
<span class="lineNum">    3306 </span>            :                                  vec&lt;assert_info&gt; &amp;asserts)
<span class="lineNum">    3307 </span>            : {
<span class="lineNum">    3308 </span><span class="lineCov">   41382122 :   for (unsigned i = 0; i &lt; asserts.length (); ++i)</span>
<span class="lineNum">    3309 </span>            :     /* Only register an ASSERT_EXPR if NAME was found in the sub-graph
<span class="lineNum">    3310 </span>            :        reachable from E.  */
<span class="lineNum">    3311 </span><span class="lineCov">   12167865 :     if (live_on_edge (e, asserts[i].name))</span>
<span class="lineNum">    3312 </span><span class="lineCov">    6871150 :       register_new_assert_for (asserts[i].name, asserts[i].expr,</span>
<span class="lineNum">    3313 </span><span class="lineCov">   10306725 :                                asserts[i].comp_code, asserts[i].val,</span>
<span class="lineNum">    3314 </span>            :                                NULL, e, gsi);
<span class="lineNum">    3315 </span><span class="lineCov">    8523196 : }</span>
<span class="lineNum">    3316 </span>            : 
<span class="lineNum">    3317 </span>            : 
<span class="lineNum">    3318 </span>            : 
<span class="lineNum">    3319 </span>            : /* Determine whether the outgoing edges of BB should receive an
<span class="lineNum">    3320 </span>            :    ASSERT_EXPR for each of the operands of BB's LAST statement.
<span class="lineNum">    3321 </span>            :    The last statement of BB must be a COND_EXPR.
<span class="lineNum">    3322 </span>            : 
<span class="lineNum">    3323 </span>            :    If any of the sub-graphs rooted at BB have an interesting use of
<span class="lineNum">    3324 </span>            :    the predicate operands, an assert location node is added to the
<span class="lineNum">    3325 </span>            :    list of assertions for the corresponding operands.  */
<a name="3326"><span class="lineNum">    3326 </span>            : </a>
<span class="lineNum">    3327 </span>            : static void
<span class="lineNum">    3328 </span><span class="lineCov">    4221767 : find_conditional_asserts (basic_block bb, gcond *last)</span>
<span class="lineNum">    3329 </span>            : {
<span class="lineNum">    3330 </span><span class="lineCov">    4221767 :   gimple_stmt_iterator bsi;</span>
<span class="lineNum">    3331 </span><span class="lineCov">    4221767 :   tree op;</span>
<span class="lineNum">    3332 </span><span class="lineCov">    4221767 :   edge_iterator ei;</span>
<span class="lineNum">    3333 </span><span class="lineCov">    4221767 :   edge e;</span>
<span class="lineNum">    3334 </span><span class="lineCov">    4221767 :   ssa_op_iter iter;</span>
<span class="lineNum">    3335 </span>            : 
<span class="lineNum">    3336 </span><span class="lineCov">    4221767 :   bsi = gsi_for_stmt (last);</span>
<span class="lineNum">    3337 </span>            : 
<span class="lineNum">    3338 </span>            :   /* Look for uses of the operands in each of the sub-graphs
<span class="lineNum">    3339 </span>            :      rooted at BB.  We need to check each of the outgoing edges
<span class="lineNum">    3340 </span>            :      separately, so that we know what kind of ASSERT_EXPR to
<span class="lineNum">    3341 </span>            :      insert.  */
<span class="lineNum">    3342 </span><span class="lineCov">   16887068 :   FOR_EACH_EDGE (e, ei, bb-&gt;succs)</span>
<span class="lineNum">    3343 </span>            :     {
<span class="lineNum">    3344 </span><span class="lineCov">    8443534 :       if (e-&gt;dest == bb)</span>
<span class="lineNum">    3345 </span><span class="lineNoCov">          0 :         continue;</span>
<span class="lineNum">    3346 </span>            : 
<span class="lineNum">    3347 </span>            :       /* Register the necessary assertions for each operand in the
<span class="lineNum">    3348 </span>            :          conditional predicate.  */
<span class="lineNum">    3349 </span><span class="lineCov">   16887068 :       auto_vec&lt;assert_info, 8&gt; asserts;</span>
<span class="lineNum">    3350 </span><span class="lineCov">   18997288 :       FOR_EACH_SSA_TREE_OPERAND (op, last, iter, SSA_OP_USE)</span>
<span class="lineNum">    3351 </span><span class="lineCov">   42215016 :         register_edge_assert_for (op, e,</span>
<span class="lineNum">    3352 </span>            :                                   gimple_cond_code (last),
<span class="lineNum">    3353 </span>            :                                   gimple_cond_lhs (last),
<span class="lineNum">    3354 </span>            :                                   gimple_cond_rhs (last), asserts);
<span class="lineNum">    3355 </span><span class="lineCov">    8443534 :       finish_register_edge_assert_for (e, bsi, asserts);</span>
<span class="lineNum">    3356 </span>            :     }
<span class="lineNum">    3357 </span><span class="lineCov">    4221767 : }</span>
<span class="lineNum">    3358 </span>            : 
<span class="lineNum">    3359 </span>            : struct case_info
<span class="lineNum">    3360 </span>            : {
<span class="lineNum">    3361 </span>            :   tree expr;
<span class="lineNum">    3362 </span>            :   basic_block bb;
<span class="lineNum">    3363 </span>            : };
<span class="lineNum">    3364 </span>            : 
<span class="lineNum">    3365 </span>            : /* Compare two case labels sorting first by the destination bb index
<span class="lineNum">    3366 </span>            :    and then by the case value.  */
<a name="3367"><span class="lineNum">    3367 </span>            : </a>
<span class="lineNum">    3368 </span>            : static int
<span class="lineNum">    3369 </span><span class="lineCov">    1220798 : compare_case_labels (const void *p1, const void *p2)</span>
<span class="lineNum">    3370 </span>            : {
<span class="lineNum">    3371 </span><span class="lineCov">    1220798 :   const struct case_info *ci1 = (const struct case_info *) p1;</span>
<span class="lineNum">    3372 </span><span class="lineCov">    1220798 :   const struct case_info *ci2 = (const struct case_info *) p2;</span>
<span class="lineNum">    3373 </span><span class="lineCov">    1220798 :   int idx1 = ci1-&gt;bb-&gt;index;</span>
<span class="lineNum">    3374 </span><span class="lineCov">    1220798 :   int idx2 = ci2-&gt;bb-&gt;index;</span>
<span class="lineNum">    3375 </span>            : 
<span class="lineNum">    3376 </span><span class="lineCov">    1220798 :   if (idx1 &lt; idx2)</span>
<span class="lineNum">    3377 </span>            :     return -1;
<span class="lineNum">    3378 </span><span class="lineCov">     607965 :   else if (idx1 == idx2)</span>
<span class="lineNum">    3379 </span>            :     {
<span class="lineNum">    3380 </span>            :       /* Make sure the default label is first in a group.  */
<span class="lineNum">    3381 </span><span class="lineCov">      75126 :       if (!CASE_LOW (ci1-&gt;expr))</span>
<span class="lineNum">    3382 </span>            :         return -1;
<span class="lineNum">    3383 </span><span class="lineCov">      75126 :       else if (!CASE_LOW (ci2-&gt;expr))</span>
<span class="lineNum">    3384 </span>            :         return 1;
<span class="lineNum">    3385 </span>            :       else
<span class="lineNum">    3386 </span><span class="lineCov">     150252 :         return tree_int_cst_compare (CASE_LOW (ci1-&gt;expr),</span>
<span class="lineNum">    3387 </span><span class="lineCov">     225378 :                                      CASE_LOW (ci2-&gt;expr));</span>
<span class="lineNum">    3388 </span>            :     }
<span class="lineNum">    3389 </span>            :   else
<span class="lineNum">    3390 </span>            :     return 1;
<span class="lineNum">    3391 </span>            : }
<span class="lineNum">    3392 </span>            : 
<span class="lineNum">    3393 </span>            : /* Determine whether the outgoing edges of BB should receive an
<span class="lineNum">    3394 </span>            :    ASSERT_EXPR for each of the operands of BB's LAST statement.
<span class="lineNum">    3395 </span>            :    The last statement of BB must be a SWITCH_EXPR.
<span class="lineNum">    3396 </span>            : 
<span class="lineNum">    3397 </span>            :    If any of the sub-graphs rooted at BB have an interesting use of
<span class="lineNum">    3398 </span>            :    the predicate operands, an assert location node is added to the
<span class="lineNum">    3399 </span>            :    list of assertions for the corresponding operands.  */
<span class="lineNum">    3400 </span>            : 
<span class="lineNum">    3401 </span>            : static void
<span class="lineNum">    3402 </span><span class="lineCov">      15777 : find_switch_asserts (basic_block bb, gswitch *last)</span>
<span class="lineNum">    3403 </span>            : {
<span class="lineNum">    3404 </span><span class="lineCov">      15777 :   gimple_stmt_iterator bsi;</span>
<span class="lineNum">    3405 </span><span class="lineCov">      15777 :   tree op;</span>
<span class="lineNum">    3406 </span><span class="lineCov">      15777 :   edge e;</span>
<span class="lineNum">    3407 </span><span class="lineCov">      15777 :   struct case_info *ci;</span>
<span class="lineNum">    3408 </span><span class="lineCov">      15777 :   size_t n = gimple_switch_num_labels (last);</span>
<span class="lineNum">    3409 </span>            : #if GCC_VERSION &gt;= 4000
<span class="lineNum">    3410 </span><span class="lineCov">      15777 :   unsigned int idx;</span>
<span class="lineNum">    3411 </span>            : #else
<span class="lineNum">    3412 </span>            :   /* Work around GCC 3.4 bug (PR 37086).  */
<span class="lineNum">    3413 </span>            :   volatile unsigned int idx;
<span class="lineNum">    3414 </span>            : #endif
<span class="lineNum">    3415 </span>            : 
<span class="lineNum">    3416 </span><span class="lineCov">      15777 :   bsi = gsi_for_stmt (last);</span>
<span class="lineNum">    3417 </span><span class="lineCov">      15777 :   op = gimple_switch_index (last);</span>
<span class="lineNum">    3418 </span><span class="lineCov">      15777 :   if (TREE_CODE (op) != SSA_NAME)</span>
<span class="lineNum">    3419 </span><span class="lineCov">      13510 :     return;</span>
<span class="lineNum">    3420 </span>            : 
<span class="lineNum">    3421 </span>            :   /* Build a vector of case labels sorted by destination label.  */
<span class="lineNum">    3422 </span><span class="lineCov">      15777 :   ci = XNEWVEC (struct case_info, n);</span>
<span class="lineNum">    3423 </span><span class="lineCov">     116792 :   for (idx = 0; idx &lt; n; ++idx)</span>
<span class="lineNum">    3424 </span>            :     {
<span class="lineNum">    3425 </span><span class="lineCov">     101015 :       ci[idx].expr = gimple_switch_label (last, idx);</span>
<span class="lineNum">    3426 </span><span class="lineCov">     101015 :       ci[idx].bb = label_to_block (cfun, CASE_LABEL (ci[idx].expr));</span>
<span class="lineNum">    3427 </span>            :     }
<span class="lineNum">    3428 </span><span class="lineCov">      15777 :   edge default_edge = find_edge (bb, ci[0].bb);</span>
<span class="lineNum">    3429 </span><span class="lineCov">      15777 :   qsort (ci, n, sizeof (struct case_info), compare_case_labels);</span>
<span class="lineNum">    3430 </span>            : 
<span class="lineNum">    3431 </span><span class="lineCov">     106500 :   for (idx = 0; idx &lt; n; ++idx)</span>
<span class="lineNum">    3432 </span>            :     {
<span class="lineNum">    3433 </span><span class="lineCov">      90723 :       tree min, max;</span>
<span class="lineNum">    3434 </span><span class="lineCov">      90723 :       tree cl = ci[idx].expr;</span>
<span class="lineNum">    3435 </span><span class="lineCov">      90723 :       basic_block cbb = ci[idx].bb;</span>
<span class="lineNum">    3436 </span>            : 
<span class="lineNum">    3437 </span><span class="lineCov">      90723 :       min = CASE_LOW (cl);</span>
<span class="lineNum">    3438 </span><span class="lineCov">     181446 :       max = CASE_HIGH (cl);</span>
<span class="lineNum">    3439 </span>            : 
<span class="lineNum">    3440 </span>            :       /* If there are multiple case labels with the same destination
<span class="lineNum">    3441 </span>            :          we need to combine them to a single value range for the edge.  */
<span class="lineNum">    3442 </span><span class="lineCov">      90723 :       if (idx + 1 &lt; n &amp;&amp; cbb == ci[idx + 1].bb)</span>
<span class="lineNum">    3443 </span>            :         {
<span class="lineNum">    3444 </span>            :           /* Skip labels until the last of the group.  */
<span class="lineNum">    3445 </span><span class="lineCov">      15434 :           do {</span>
<span class="lineNum">    3446 </span><span class="lineCov">      15434 :             ++idx;</span>
<span class="lineNum">    3447 </span><span class="lineCov">      15434 :           } while (idx &lt; n &amp;&amp; cbb == ci[idx].bb);</span>
<span class="lineNum">    3448 </span><span class="lineCov">       5142 :           --idx;</span>
<span class="lineNum">    3449 </span>            : 
<span class="lineNum">    3450 </span>            :           /* Pick up the maximum of the case label range.  */
<span class="lineNum">    3451 </span><span class="lineCov">       5142 :           if (CASE_HIGH (ci[idx].expr))</span>
<span class="lineNum">    3452 </span><span class="lineCov">       1634 :             max = CASE_HIGH (ci[idx].expr);</span>
<span class="lineNum">    3453 </span>            :           else
<span class="lineNum">    3454 </span><span class="lineCov">       8650 :             max = CASE_LOW (ci[idx].expr);</span>
<span class="lineNum">    3455 </span>            :         }
<span class="lineNum">    3456 </span>            : 
<span class="lineNum">    3457 </span>            :       /* Can't extract a useful assertion out of a range that includes the
<span class="lineNum">    3458 </span>            :          default label.  */
<span class="lineNum">    3459 </span><span class="lineCov">      90723 :       if (min == NULL_TREE)</span>
<span class="lineNum">    3460 </span><span class="lineCov">      15777 :         continue;</span>
<span class="lineNum">    3461 </span>            : 
<span class="lineNum">    3462 </span>            :       /* Find the edge to register the assert expr on.  */
<span class="lineNum">    3463 </span><span class="lineCov">      74946 :       e = find_edge (bb, cbb);</span>
<span class="lineNum">    3464 </span>            : 
<span class="lineNum">    3465 </span>            :       /* Register the necessary assertions for the operand in the
<span class="lineNum">    3466 </span>            :          SWITCH_EXPR.  */
<span class="lineNum">    3467 </span><span class="lineCov">     149892 :       auto_vec&lt;assert_info, 8&gt; asserts;</span>
<span class="lineNum">    3468 </span><span class="lineCov">     141762 :       register_edge_assert_for (op, e,</span>
<span class="lineNum">    3469 </span>            :                                 max ? GE_EXPR : EQ_EXPR,
<span class="lineNum">    3470 </span><span class="lineCov">      74946 :                                 op, fold_convert (TREE_TYPE (op), min),</span>
<span class="lineNum">    3471 </span>            :                                 asserts);
<span class="lineNum">    3472 </span><span class="lineCov">      74946 :       if (max)</span>
<span class="lineNum">    3473 </span><span class="lineCov">       8130 :         register_edge_assert_for (op, e, LE_EXPR, op,</span>
<span class="lineNum">    3474 </span><span class="lineCov">       8130 :                                   fold_convert (TREE_TYPE (op), max),</span>
<span class="lineNum">    3475 </span>            :                                   asserts);
<span class="lineNum">    3476 </span><span class="lineCov">      74946 :       finish_register_edge_assert_for (e, bsi, asserts);</span>
<span class="lineNum">    3477 </span>            :     }
<span class="lineNum">    3478 </span>            : 
<span class="lineNum">    3479 </span><span class="lineCov">      15777 :   XDELETEVEC (ci);</span>
<span class="lineNum">    3480 </span>            : 
<span class="lineNum">    3481 </span><span class="lineCov">      15777 :   if (!live_on_edge (default_edge, op))</span>
<span class="lineNum">    3482 </span>            :     return;
<span class="lineNum">    3483 </span>            : 
<span class="lineNum">    3484 </span>            :   /* Now register along the default label assertions that correspond to the
<span class="lineNum">    3485 </span>            :      anti-range of each label.  */
<span class="lineNum">    3486 </span><span class="lineCov">       2267 :   int insertion_limit = PARAM_VALUE (PARAM_MAX_VRP_SWITCH_ASSERTIONS);</span>
<span class="lineNum">    3487 </span><span class="lineCov">       2267 :   if (insertion_limit == 0)</span>
<span class="lineNum">    3488 </span>            :     return;
<span class="lineNum">    3489 </span>            : 
<span class="lineNum">    3490 </span>            :   /* We can't do this if the default case shares a label with another case.  */
<span class="lineNum">    3491 </span><span class="lineCov">       2267 :   tree default_cl = gimple_switch_default_label (last);</span>
<span class="lineNum">    3492 </span><span class="lineCov">       9489 :   for (idx = 1; idx &lt; n; idx++)</span>
<span class="lineNum">    3493 </span>            :     {
<span class="lineNum">    3494 </span><span class="lineCov">       7272 :       tree min, max;</span>
<span class="lineNum">    3495 </span><span class="lineCov">       7272 :       tree cl = gimple_switch_label (last, idx);</span>
<span class="lineNum">    3496 </span><span class="lineCov">       7272 :       if (CASE_LABEL (cl) == CASE_LABEL (default_cl))</span>
<span class="lineNum">    3497 </span>            :         continue;
<span class="lineNum">    3498 </span>            : 
<span class="lineNum">    3499 </span><span class="lineCov">      14544 :       min = CASE_LOW (cl);</span>
<span class="lineNum">    3500 </span><span class="lineCov">      14544 :       max = CASE_HIGH (cl);</span>
<span class="lineNum">    3501 </span>            : 
<span class="lineNum">    3502 </span>            :       /* Combine contiguous case ranges to reduce the number of assertions
<span class="lineNum">    3503 </span>            :          to insert.  */
<span class="lineNum">    3504 </span><span class="lineCov">      11883 :       for (idx = idx + 1; idx &lt; n; idx++)</span>
<span class="lineNum">    3505 </span>            :         {
<span class="lineNum">    3506 </span><span class="lineCov">       9627 :           tree next_min, next_max;</span>
<span class="lineNum">    3507 </span><span class="lineCov">       9627 :           tree next_cl = gimple_switch_label (last, idx);</span>
<span class="lineNum">    3508 </span><span class="lineCov">       9627 :           if (CASE_LABEL (next_cl) == CASE_LABEL (default_cl))</span>
<span class="lineNum">    3509 </span>            :             break;
<span class="lineNum">    3510 </span>            : 
<span class="lineNum">    3511 </span><span class="lineCov">      19254 :           next_min = CASE_LOW (next_cl);</span>
<span class="lineNum">    3512 </span><span class="lineCov">      19254 :           next_max = CASE_HIGH (next_cl);</span>
<span class="lineNum">    3513 </span>            : 
<span class="lineNum">    3514 </span><span class="lineCov">       9627 :           wide_int difference = (wi::to_wide (next_min)</span>
<span class="lineNum">    3515 </span><span class="lineCov">      23559 :                                  - wi::to_wide (max ? max : min));</span>
<span class="lineNum">    3516 </span><span class="lineCov">      14643 :           if (wi::eq_p (difference, 1))</span>
<span class="lineNum">    3517 </span><span class="lineCov">       8931 :             max = next_max ? next_max : next_min;</span>
<span class="lineNum">    3518 </span>            :           else
<span class="lineNum">    3519 </span>            :             break;
<span class="lineNum">    3520 </span>            :         }
<span class="lineNum">    3521 </span><span class="lineCov">       7272 :       idx--;</span>
<span class="lineNum">    3522 </span>            : 
<span class="lineNum">    3523 </span><span class="lineCov">       7272 :       if (max == NULL_TREE)</span>
<span class="lineNum">    3524 </span>            :         {
<span class="lineNum">    3525 </span>            :           /* Register the assertion OP != MIN.  */
<span class="lineNum">    3526 </span><span class="lineCov">       9432 :           auto_vec&lt;assert_info, 8&gt; asserts;</span>
<span class="lineNum">    3527 </span><span class="lineCov">       4716 :           min = fold_convert (TREE_TYPE (op), min);</span>
<span class="lineNum">    3528 </span><span class="lineCov">       4716 :           register_edge_assert_for (op, default_edge, NE_EXPR, op, min,</span>
<span class="lineNum">    3529 </span>            :                                     asserts);
<span class="lineNum">    3530 </span><span class="lineCov">       4716 :           finish_register_edge_assert_for (default_edge, bsi, asserts);</span>
<span class="lineNum">    3531 </span>            :         }
<span class="lineNum">    3532 </span>            :       else
<span class="lineNum">    3533 </span>            :         {
<span class="lineNum">    3534 </span>            :           /* Register the assertion (unsigned)OP - MIN &gt; (MAX - MIN),
<span class="lineNum">    3535 </span>            :              which will give OP the anti-range ~[MIN,MAX].  */
<span class="lineNum">    3536 </span><span class="lineCov">       2556 :           tree uop = fold_convert (unsigned_type_for (TREE_TYPE (op)), op);</span>
<span class="lineNum">    3537 </span><span class="lineCov">       2556 :           min = fold_convert (TREE_TYPE (uop), min);</span>
<span class="lineNum">    3538 </span><span class="lineCov">       2556 :           max = fold_convert (TREE_TYPE (uop), max);</span>
<span class="lineNum">    3539 </span>            : 
<span class="lineNum">    3540 </span><span class="lineCov">       2556 :           tree lhs = fold_build2 (MINUS_EXPR, TREE_TYPE (uop), uop, min);</span>
<span class="lineNum">    3541 </span><span class="lineCov">       2556 :           tree rhs = int_const_binop (MINUS_EXPR, max, min);</span>
<span class="lineNum">    3542 </span><span class="lineCov">       2556 :           register_new_assert_for (op, lhs, GT_EXPR, rhs,</span>
<span class="lineNum">    3543 </span>            :                                    NULL, default_edge, bsi);
<span class="lineNum">    3544 </span>            :         }
<span class="lineNum">    3545 </span>            : 
<span class="lineNum">    3546 </span><span class="lineCov">       7272 :       if (--insertion_limit == 0)</span>
<span class="lineNum">    3547 </span>            :         break;
<span class="lineNum">    3548 </span>            :     }
<span class="lineNum">    3549 </span>            : }
<span class="lineNum">    3550 </span>            : 
<span class="lineNum">    3551 </span>            : 
<span class="lineNum">    3552 </span>            : /* Traverse all the statements in block BB looking for statements that
<span class="lineNum">    3553 </span>            :    may generate useful assertions for the SSA names in their operand.
<span class="lineNum">    3554 </span>            :    If a statement produces a useful assertion A for name N_i, then the
<span class="lineNum">    3555 </span>            :    list of assertions already generated for N_i is scanned to
<span class="lineNum">    3556 </span>            :    determine if A is actually needed.
<span class="lineNum">    3557 </span>            : 
<span class="lineNum">    3558 </span>            :    If N_i already had the assertion A at a location dominating the
<span class="lineNum">    3559 </span>            :    current location, then nothing needs to be done.  Otherwise, the
<span class="lineNum">    3560 </span>            :    new location for A is recorded instead.
<span class="lineNum">    3561 </span>            : 
<span class="lineNum">    3562 </span>            :    1- For every statement S in BB, all the variables used by S are
<span class="lineNum">    3563 </span>            :       added to bitmap FOUND_IN_SUBGRAPH.
<span class="lineNum">    3564 </span>            : 
<span class="lineNum">    3565 </span>            :    2- If statement S uses an operand N in a way that exposes a known
<span class="lineNum">    3566 </span>            :       value range for N, then if N was not already generated by an
<span class="lineNum">    3567 </span>            :       ASSERT_EXPR, create a new assert location for N.  For instance,
<span class="lineNum">    3568 </span>            :       if N is a pointer and the statement dereferences it, we can
<span class="lineNum">    3569 </span>            :       assume that N is not NULL.
<span class="lineNum">    3570 </span>            : 
<span class="lineNum">    3571 </span>            :    3- COND_EXPRs are a special case of #2.  We can derive range
<span class="lineNum">    3572 </span>            :       information from the predicate but need to insert different
<span class="lineNum">    3573 </span>            :       ASSERT_EXPRs for each of the sub-graphs rooted at the
<span class="lineNum">    3574 </span>            :       conditional block.  If the last statement of BB is a conditional
<span class="lineNum">    3575 </span>            :       expression of the form 'X op Y', then
<span class="lineNum">    3576 </span>            : 
<span class="lineNum">    3577 </span>            :       a) Remove X and Y from the set FOUND_IN_SUBGRAPH.
<span class="lineNum">    3578 </span>            : 
<span class="lineNum">    3579 </span>            :       b) If the conditional is the only entry point to the sub-graph
<span class="lineNum">    3580 </span>            :          corresponding to the THEN_CLAUSE, recurse into it.  On
<span class="lineNum">    3581 </span>            :          return, if X and/or Y are marked in FOUND_IN_SUBGRAPH, then
<span class="lineNum">    3582 </span>            :          an ASSERT_EXPR is added for the corresponding variable.
<span class="lineNum">    3583 </span>            : 
<span class="lineNum">    3584 </span>            :       c) Repeat step (b) on the ELSE_CLAUSE.
<span class="lineNum">    3585 </span>            : 
<span class="lineNum">    3586 </span>            :       d) Mark X and Y in FOUND_IN_SUBGRAPH.
<span class="lineNum">    3587 </span>            : 
<span class="lineNum">    3588 </span>            :       For instance,
<span class="lineNum">    3589 </span>            : 
<span class="lineNum">    3590 </span>            :             if (a == 9)
<span class="lineNum">    3591 </span>            :               b = a;
<span class="lineNum">    3592 </span>            :             else
<span class="lineNum">    3593 </span>            :               b = c + 1;
<span class="lineNum">    3594 </span>            : 
<span class="lineNum">    3595 </span>            :       In this case, an assertion on the THEN clause is useful to
<span class="lineNum">    3596 </span>            :       determine that 'a' is always 9 on that edge.  However, an assertion
<span class="lineNum">    3597 </span>            :       on the ELSE clause would be unnecessary.
<span class="lineNum">    3598 </span>            : 
<span class="lineNum">    3599 </span>            :    4- If BB does not end in a conditional expression, then we recurse
<span class="lineNum">    3600 </span>            :       into BB's dominator children.
<span class="lineNum">    3601 </span>            : 
<span class="lineNum">    3602 </span>            :    At the end of the recursive traversal, every SSA name will have a
<span class="lineNum">    3603 </span>            :    list of locations where ASSERT_EXPRs should be added.  When a new
<span class="lineNum">    3604 </span>            :    location for name N is found, it is registered by calling
<span class="lineNum">    3605 </span>            :    register_new_assert_for.  That function keeps track of all the
<span class="lineNum">    3606 </span>            :    registered assertions to prevent adding unnecessary assertions.
<span class="lineNum">    3607 </span>            :    For instance, if a pointer P_4 is dereferenced more than once in a
<span class="lineNum">    3608 </span>            :    dominator tree, only the location dominating all the dereference of
<span class="lineNum">    3609 </span>            :    P_4 will receive an ASSERT_EXPR.  */
<a name="3610"><span class="lineNum">    3610 </span>            : </a>
<span class="lineNum">    3611 </span>            : static void
<span class="lineNum">    3612 </span><span class="lineCov">   11762118 : find_assert_locations_1 (basic_block bb, sbitmap live)</span>
<span class="lineNum">    3613 </span>            : {
<span class="lineNum">    3614 </span><span class="lineCov">   11762118 :   gimple *last;</span>
<span class="lineNum">    3615 </span>            : 
<span class="lineNum">    3616 </span><span class="lineCov">   11762118 :   last = last_stmt (bb);</span>
<span class="lineNum">    3617 </span>            : 
<span class="lineNum">    3618 </span>            :   /* If BB's last statement is a conditional statement involving integer
<span class="lineNum">    3619 </span>            :      operands, determine if we need to add ASSERT_EXPRs.  */
<span class="lineNum">    3620 </span><span class="lineCov">   11762118 :   if (last</span>
<span class="lineNum">    3621 </span><span class="lineCov">   21873248 :       &amp;&amp; gimple_code (last) == GIMPLE_COND</span>
<span class="lineNum">    3622 </span><span class="lineCov">    4499474 :       &amp;&amp; !fp_predicate (last)</span>
<span class="lineNum">    3623 </span><span class="lineCov">   20242436 :       &amp;&amp; !ZERO_SSA_OPERANDS (last, SSA_OP_USE))</span>
<span class="lineNum">    3624 </span><span class="lineCov">    4221767 :     find_conditional_asserts (bb, as_a &lt;gcond *&gt; (last));</span>
<span class="lineNum">    3625 </span>            : 
<span class="lineNum">    3626 </span>            :   /* If BB's last statement is a switch statement involving integer
<span class="lineNum">    3627 </span>            :      operands, determine if we need to add ASSERT_EXPRs.  */
<span class="lineNum">    3628 </span><span class="lineCov">   11762118 :   if (last</span>
<span class="lineNum">    3629 </span><span class="lineCov">   21873248 :       &amp;&amp; gimple_code (last) == GIMPLE_SWITCH</span>
<span class="lineNum">    3630 </span><span class="lineCov">   11793672 :       &amp;&amp; !ZERO_SSA_OPERANDS (last, SSA_OP_USE))</span>
<span class="lineNum">    3631 </span><span class="lineCov">      15777 :     find_switch_asserts (bb, as_a &lt;gswitch *&gt; (last));</span>
<span class="lineNum">    3632 </span>            : 
<span class="lineNum">    3633 </span>            :   /* Traverse all the statements in BB marking used names and looking
<span class="lineNum">    3634 </span>            :      for statements that may infer assertions for their used operands.  */
<span class="lineNum">    3635 </span><span class="lineCov">  233173006 :   for (gimple_stmt_iterator si = gsi_last_bb (bb); !gsi_end_p (si);</span>
<span class="lineNum">    3636 </span><span class="lineCov">   98943326 :        gsi_prev (&amp;si))</span>
<span class="lineNum">    3637 </span>            :     {
<span class="lineNum">    3638 </span><span class="lineCov">   98943326 :       gimple *stmt;</span>
<span class="lineNum">    3639 </span><span class="lineCov">   98943326 :       tree op;</span>
<span class="lineNum">    3640 </span><span class="lineCov">   98943326 :       ssa_op_iter i;</span>
<span class="lineNum">    3641 </span>            : 
<span class="lineNum">    3642 </span><span class="lineCov">   98943326 :       stmt = gsi_stmt (si);</span>
<span class="lineNum">    3643 </span>            : 
<span class="lineNum">    3644 </span><span class="lineCov">  197886652 :       if (is_gimple_debug (stmt))</span>
<span class="lineNum">    3645 </span><span class="lineCov">   60108526 :         continue;</span>
<span class="lineNum">    3646 </span>            : 
<span class="lineNum">    3647 </span>            :       /* See if we can derive an assertion for any of STMT's operands.  */
<span class="lineNum">    3648 </span><span class="lineCov">   70048893 :       FOR_EACH_SSA_TREE_OPERAND (op, stmt, i, SSA_OP_USE)</span>
<span class="lineNum">    3649 </span>            :         {
<span class="lineNum">    3650 </span><span class="lineCov">   31214093 :           tree value;</span>
<span class="lineNum">    3651 </span><span class="lineCov">   31214093 :           enum tree_code comp_code;</span>
<span class="lineNum">    3652 </span>            : 
<span class="lineNum">    3653 </span>            :           /* If op is not live beyond this stmt, do not bother to insert
<span class="lineNum">    3654 </span>            :              asserts for it.  */
<span class="lineNum">    3655 </span><span class="lineCov">   31214093 :           if (!bitmap_bit_p (live, SSA_NAME_VERSION (op)))</span>
<span class="lineNum">    3656 </span><span class="lineCov">   18848382 :             continue;</span>
<span class="lineNum">    3657 </span>            : 
<span class="lineNum">    3658 </span>            :           /* If OP is used in such a way that we can infer a value
<span class="lineNum">    3659 </span>            :              range for it, and we don't find a previous assertion for
<span class="lineNum">    3660 </span>            :              it, create a new assertion location node for OP.  */
<span class="lineNum">    3661 </span><span class="lineCov">   12365711 :           if (infer_value_range (stmt, op, &amp;comp_code, &amp;value))</span>
<span class="lineNum">    3662 </span>            :             {
<span class="lineNum">    3663 </span>            :               /* If we are able to infer a nonzero value range for OP,
<span class="lineNum">    3664 </span>            :                  then walk backwards through the use-def chain to see if OP
<span class="lineNum">    3665 </span>            :                  was set via a typecast.
<span class="lineNum">    3666 </span>            : 
<span class="lineNum">    3667 </span>            :                  If so, then we can also infer a nonzero value range
<span class="lineNum">    3668 </span>            :                  for the operand of the NOP_EXPR.  */
<span class="lineNum">    3669 </span><span class="lineCov">    3313710 :               if (comp_code == NE_EXPR &amp;&amp; integer_zerop (value))</span>
<span class="lineNum">    3670 </span>            :                 {
<span class="lineNum">    3671 </span><span class="lineCov">    3313710 :                   tree t = op;</span>
<span class="lineNum">    3672 </span><span class="lineCov">    3313710 :                   gimple *def_stmt = SSA_NAME_DEF_STMT (t);</span>
<span class="lineNum">    3673 </span>            : 
<span class="lineNum">    3674 </span><span class="lineCov">    3313710 :                   while (is_gimple_assign (def_stmt)</span>
<span class="lineNum">    3675 </span><span class="lineCov">     806495 :                          &amp;&amp; CONVERT_EXPR_CODE_P</span>
<span class="lineNum">    3676 </span>            :                              (gimple_assign_rhs_code (def_stmt))
<span class="lineNum">    3677 </span><span class="lineCov">     235124 :                          &amp;&amp; TREE_CODE</span>
<span class="lineNum">    3678 </span>            :                              (gimple_assign_rhs1 (def_stmt)) == SSA_NAME
<span class="lineNum">    3679 </span><span class="lineCov">    3548834 :                          &amp;&amp; POINTER_TYPE_P</span>
<span class="lineNum">    3680 </span>            :                              (TREE_TYPE (gimple_assign_rhs1 (def_stmt))))
<span class="lineNum">    3681 </span>            :                     {
<span class="lineNum">    3682 </span><span class="lineNoCov">          0 :                       t = gimple_assign_rhs1 (def_stmt);</span>
<span class="lineNum">    3683 </span><span class="lineNoCov">          0 :                       def_stmt = SSA_NAME_DEF_STMT (t);</span>
<span class="lineNum">    3684 </span>            : 
<span class="lineNum">    3685 </span>            :                       /* Note we want to register the assert for the
<span class="lineNum">    3686 </span>            :                          operand of the NOP_EXPR after SI, not after the
<span class="lineNum">    3687 </span>            :                          conversion.  */
<span class="lineNum">    3688 </span><span class="lineNoCov">          0 :                       if (bitmap_bit_p (live, SSA_NAME_VERSION (t)))</span>
<span class="lineNum">    3689 </span><span class="lineNoCov">          0 :                         register_new_assert_for (t, t, comp_code, value,</span>
<span class="lineNum">    3690 </span>            :                                                  bb, NULL, si);
<span class="lineNum">    3691 </span>            :                     }
<span class="lineNum">    3692 </span>            :                 }
<span class="lineNum">    3693 </span>            : 
<span class="lineNum">    3694 </span><span class="lineCov">    3313710 :               register_new_assert_for (op, op, comp_code, value, bb, NULL, si);</span>
<span class="lineNum">    3695 </span>            :             }
<span class="lineNum">    3696 </span>            :         }
<span class="lineNum">    3697 </span>            : 
<span class="lineNum">    3698 </span>            :       /* Update live.  */
<span class="lineNum">    3699 </span><span class="lineCov">  101262986 :       FOR_EACH_SSA_TREE_OPERAND (op, stmt, i, SSA_OP_USE)</span>
<span class="lineNum">    3700 </span><span class="lineCov">   31214093 :         bitmap_set_bit (live, SSA_NAME_VERSION (op));</span>
<span class="lineNum">    3701 </span><span class="lineCov">   75460652 :       FOR_EACH_SSA_TREE_OPERAND (op, stmt, i, SSA_OP_DEF)</span>
<span class="lineNum">    3702 </span><span class="lineCov">   18312926 :         bitmap_clear_bit (live, SSA_NAME_VERSION (op));</span>
<span class="lineNum">    3703 </span>            :     }
<span class="lineNum">    3704 </span>            : 
<span class="lineNum">    3705 </span>            :   /* Traverse all PHI nodes in BB, updating live.  */
<span class="lineNum">    3706 </span><span class="lineCov">   22110152 :   for (gphi_iterator si = gsi_start_phis (bb); !gsi_end_p (si);</span>
<span class="lineNum">    3707 </span><span class="lineCov">    5174017 :        gsi_next (&amp;si))</span>
<span class="lineNum">    3708 </span>            :     {
<span class="lineNum">    3709 </span><span class="lineCov">    5174017 :       use_operand_p arg_p;</span>
<span class="lineNum">    3710 </span><span class="lineCov">    5174017 :       ssa_op_iter i;</span>
<span class="lineNum">    3711 </span><span class="lineCov">    5174017 :       gphi *phi = si.phi ();</span>
<span class="lineNum">    3712 </span><span class="lineCov">    5174017 :       tree res = gimple_phi_result (phi);</span>
<span class="lineNum">    3713 </span>            : 
<span class="lineNum">    3714 </span><span class="lineCov">   10348034 :       if (virtual_operand_p (res))</span>
<span class="lineNum">    3715 </span><span class="lineCov">    2089759 :         continue;</span>
<span class="lineNum">    3716 </span>            : 
<span class="lineNum">    3717 </span><span class="lineCov">    9123313 :       FOR_EACH_PHI_ARG (arg_p, phi, i, SSA_OP_USE)</span>
<span class="lineNum">    3718 </span>            :         {
<span class="lineNum">    3719 </span><span class="lineCov">    6039055 :           tree arg = USE_FROM_PTR (arg_p);</span>
<span class="lineNum">    3720 </span><span class="lineCov">    6039055 :           if (TREE_CODE (arg) == SSA_NAME)</span>
<span class="lineNum">    3721 </span><span class="lineCov">    9182580 :             bitmap_set_bit (live, SSA_NAME_VERSION (arg));</span>
<span class="lineNum">    3722 </span>            :         }
<span class="lineNum">    3723 </span>            : 
<span class="lineNum">    3724 </span><span class="lineCov">    3084258 :       bitmap_clear_bit (live, SSA_NAME_VERSION (res));</span>
<span class="lineNum">    3725 </span>            :     }
<span class="lineNum">    3726 </span><span class="lineCov">   11762118 : }</span>
<span class="lineNum">    3727 </span>            : 
<span class="lineNum">    3728 </span>            : /* Do an RPO walk over the function computing SSA name liveness
<span class="lineNum">    3729 </span>            :    on-the-fly and deciding on assert expressions to insert.  */
<a name="3730"><span class="lineNum">    3730 </span>            : </a>
<span class="lineNum">    3731 </span>            : static void
<span class="lineNum">    3732 </span><span class="lineCov">    1167974 : find_assert_locations (void)</span>
<span class="lineNum">    3733 </span>            : {
<span class="lineNum">    3734 </span><span class="lineCov">    1167974 :   int *rpo = XNEWVEC (int, last_basic_block_for_fn (cfun));</span>
<span class="lineNum">    3735 </span><span class="lineCov">    1167974 :   int *bb_rpo = XNEWVEC (int, last_basic_block_for_fn (cfun));</span>
<span class="lineNum">    3736 </span><span class="lineCov">    1167974 :   int *last_rpo = XCNEWVEC (int, last_basic_block_for_fn (cfun));</span>
<span class="lineNum">    3737 </span><span class="lineCov">    1167974 :   int rpo_cnt, i;</span>
<span class="lineNum">    3738 </span>            : 
<span class="lineNum">    3739 </span><span class="lineCov">    1167974 :   live = XCNEWVEC (sbitmap, last_basic_block_for_fn (cfun));</span>
<span class="lineNum">    3740 </span><span class="lineCov">    1167974 :   rpo_cnt = pre_and_rev_post_order_compute (NULL, rpo, false);</span>
<span class="lineNum">    3741 </span><span class="lineCov">   12930092 :   for (i = 0; i &lt; rpo_cnt; ++i)</span>
<span class="lineNum">    3742 </span><span class="lineCov">   11762118 :     bb_rpo[rpo[i]] = i;</span>
<span class="lineNum">    3743 </span>            : 
<span class="lineNum">    3744 </span>            :   /* Pre-seed loop latch liveness from loop header PHI nodes.  Due to
<span class="lineNum">    3745 </span>            :      the order we compute liveness and insert asserts we otherwise
<span class="lineNum">    3746 </span>            :      fail to insert asserts into the loop latch.  */
<span class="lineNum">    3747 </span><span class="lineCov">    1167974 :   loop_p loop;</span>
<span class="lineNum">    3748 </span><span class="lineCov">    1772683 :   FOR_EACH_LOOP (loop, 0)</span>
<span class="lineNum">    3749 </span>            :     {
<span class="lineNum">    3750 </span><span class="lineCov">     604709 :       i = loop-&gt;latch-&gt;index;</span>
<span class="lineNum">    3751 </span><span class="lineCov">     604709 :       unsigned int j = single_succ_edge (loop-&gt;latch)-&gt;dest_idx;</span>
<span class="lineNum">    3752 </span><span class="lineCov">     604709 :       for (gphi_iterator gsi = gsi_start_phis (loop-&gt;header);</span>
<span class="lineNum">    3753 </span><span class="lineCov">    2610331 :            !gsi_end_p (gsi); gsi_next (&amp;gsi))</span>
<span class="lineNum">    3754 </span>            :         {
<span class="lineNum">    3755 </span><span class="lineCov">    1400913 :           gphi *phi = gsi.phi ();</span>
<span class="lineNum">    3756 </span><span class="lineCov">    4202739 :           if (virtual_operand_p (gimple_phi_result (phi)))</span>
<span class="lineNum">    3757 </span>            :             continue;
<span class="lineNum">    3758 </span><span class="lineCov">     952420 :           tree arg = gimple_phi_arg_def (phi, j);</span>
<span class="lineNum">    3759 </span><span class="lineCov">     952420 :           if (TREE_CODE (arg) == SSA_NAME)</span>
<span class="lineNum">    3760 </span>            :             {
<span class="lineNum">    3761 </span><span class="lineCov">     946882 :               if (live[i] == NULL)</span>
<span class="lineNum">    3762 </span>            :                 {
<span class="lineNum">    3763 </span><span class="lineCov">    1073760 :                   live[i] = sbitmap_alloc (num_ssa_names);</span>
<span class="lineNum">    3764 </span><span class="lineCov">     536880 :                   bitmap_clear (live[i]);</span>
<span class="lineNum">    3765 </span>            :                 }
<span class="lineNum">    3766 </span><span class="lineCov">     946882 :               bitmap_set_bit (live[i], SSA_NAME_VERSION (arg));</span>
<span class="lineNum">    3767 </span>            :             }
<span class="lineNum">    3768 </span>            :         }
<span class="lineNum">    3769 </span>            :     }
<span class="lineNum">    3770 </span>            : 
<span class="lineNum">    3771 </span><span class="lineCov">   12930092 :   for (i = rpo_cnt - 1; i &gt;= 0; --i)</span>
<span class="lineNum">    3772 </span>            :     {
<span class="lineNum">    3773 </span><span class="lineCov">   11762118 :       basic_block bb = BASIC_BLOCK_FOR_FN (cfun, rpo[i]);</span>
<span class="lineNum">    3774 </span><span class="lineCov">   11762118 :       edge e;</span>
<span class="lineNum">    3775 </span><span class="lineCov">   11762118 :       edge_iterator ei;</span>
<span class="lineNum">    3776 </span>            : 
<span class="lineNum">    3777 </span><span class="lineCov">   11762118 :       if (!live[rpo[i]])</span>
<span class="lineNum">    3778 </span>            :         {
<span class="lineNum">    3779 </span><span class="lineCov">    7954198 :           live[rpo[i]] = sbitmap_alloc (num_ssa_names);</span>
<span class="lineNum">    3780 </span><span class="lineCov">    3977099 :           bitmap_clear (live[rpo[i]]);</span>
<span class="lineNum">    3781 </span>            :         }
<span class="lineNum">    3782 </span>            : 
<span class="lineNum">    3783 </span>            :       /* Process BB and update the live information with uses in
<span class="lineNum">    3784 </span>            :          this block.  */
<span class="lineNum">    3785 </span><span class="lineCov">   11762118 :       find_assert_locations_1 (bb, live[rpo[i]]);</span>
<span class="lineNum">    3786 </span>            : 
<span class="lineNum">    3787 </span>            :       /* Merge liveness into the predecessor blocks and free it.  */
<span class="lineNum">    3788 </span><span class="lineCov">   11762118 :       if (!bitmap_empty_p (live[rpo[i]]))</span>
<span class="lineNum">    3789 </span>            :         {
<span class="lineNum">    3790 </span><span class="lineCov">    8841701 :           int pred_rpo = i;</span>
<span class="lineNum">    3791 </span><span class="lineCov">   29344115 :           FOR_EACH_EDGE (e, ei, bb-&gt;preds)</span>
<span class="lineNum">    3792 </span>            :             {
<span class="lineNum">    3793 </span><span class="lineCov">   11660713 :               int pred = e-&gt;src-&gt;index;</span>
<span class="lineNum">    3794 </span><span class="lineCov">   11660713 :               if ((e-&gt;flags &amp; EDGE_DFS_BACK) || pred == ENTRY_BLOCK)</span>
<span class="lineNum">    3795 </span>            :                 continue;
<span class="lineNum">    3796 </span>            : 
<span class="lineNum">    3797 </span><span class="lineCov">   10460432 :               if (!live[pred])</span>
<span class="lineNum">    3798 </span>            :                 {
<span class="lineNum">    3799 </span><span class="lineCov">   14863792 :                   live[pred] = sbitmap_alloc (num_ssa_names);</span>
<span class="lineNum">    3800 </span><span class="lineCov">    7431896 :                   bitmap_clear (live[pred]);</span>
<span class="lineNum">    3801 </span>            :                 }
<span class="lineNum">    3802 </span><span class="lineCov">   10460432 :               bitmap_ior (live[pred], live[pred], live[rpo[i]]);</span>
<span class="lineNum">    3803 </span>            : 
<span class="lineNum">    3804 </span><span class="lineCov">   10460432 :               if (bb_rpo[pred] &lt; pred_rpo)</span>
<span class="lineNum">    3805 </span><span class="lineCov">    8794411 :                 pred_rpo = bb_rpo[pred];</span>
<span class="lineNum">    3806 </span>            :             }
<span class="lineNum">    3807 </span>            : 
<span class="lineNum">    3808 </span>            :           /* Record the RPO number of the last visited block that needs
<span class="lineNum">    3809 </span>            :              live information from this block.  */
<span class="lineNum">    3810 </span><span class="lineCov">    8841701 :           last_rpo[rpo[i]] = pred_rpo;</span>
<span class="lineNum">    3811 </span>            :         }
<span class="lineNum">    3812 </span>            :       else
<span class="lineNum">    3813 </span>            :         {
<span class="lineNum">    3814 </span><span class="lineCov">    2920417 :           sbitmap_free (live[rpo[i]]);</span>
<span class="lineNum">    3815 </span><span class="lineCov">    2920417 :           live[rpo[i]] = NULL;</span>
<span class="lineNum">    3816 </span>            :         }
<span class="lineNum">    3817 </span>            : 
<span class="lineNum">    3818 </span>            :       /* We can free all successors live bitmaps if all their
<span class="lineNum">    3819 </span>            :          predecessors have been visited already.  */
<span class="lineNum">    3820 </span><span class="lineCov">   40244859 :       FOR_EACH_EDGE (e, ei, bb-&gt;succs)</span>
<span class="lineNum">    3821 </span><span class="lineCov">   16720623 :         if (last_rpo[e-&gt;dest-&gt;index] == i</span>
<span class="lineNum">    3822 </span><span class="lineCov">    8883924 :             &amp;&amp; live[e-&gt;dest-&gt;index])</span>
<span class="lineNum">    3823 </span>            :           {
<span class="lineNum">    3824 </span><span class="lineCov">    7942702 :             sbitmap_free (live[e-&gt;dest-&gt;index]);</span>
<span class="lineNum">    3825 </span><span class="lineCov">    7942702 :             live[e-&gt;dest-&gt;index] = NULL;</span>
<span class="lineNum">    3826 </span>            :           }
<span class="lineNum">    3827 </span>            :     }
<span class="lineNum">    3828 </span>            : 
<span class="lineNum">    3829 </span><span class="lineCov">    1167974 :   XDELETEVEC (rpo);</span>
<span class="lineNum">    3830 </span><span class="lineCov">    1167974 :   XDELETEVEC (bb_rpo);</span>
<span class="lineNum">    3831 </span><span class="lineCov">    1167974 :   XDELETEVEC (last_rpo);</span>
<span class="lineNum">    3832 </span><span class="lineCov">   15310185 :   for (i = 0; i &lt; last_basic_block_for_fn (cfun); ++i)</span>
<span class="lineNum">    3833 </span><span class="lineCov">   14142211 :     if (live[i])</span>
<span class="lineNum">    3834 </span><span class="lineCov">    1082756 :       sbitmap_free (live[i]);</span>
<span class="lineNum">    3835 </span><span class="lineCov">    1167974 :   XDELETEVEC (live);</span>
<span class="lineNum">    3836 </span><span class="lineCov">    1167974 : }</span>
<span class="lineNum">    3837 </span>            : 
<span class="lineNum">    3838 </span>            : /* Create an ASSERT_EXPR for NAME and insert it in the location
<span class="lineNum">    3839 </span>            :    indicated by LOC.  Return true if we made any edge insertions.  */
<a name="3840"><span class="lineNum">    3840 </span>            : </a>
<span class="lineNum">    3841 </span>            : static bool
<span class="lineNum">    3842 </span><span class="lineCov">    4748909 : process_assert_insertions_for (tree name, assert_locus *loc)</span>
<span class="lineNum">    3843 </span>            : {
<span class="lineNum">    3844 </span>            :   /* Build the comparison expression NAME_i COMP_CODE VAL.  */
<span class="lineNum">    3845 </span><span class="lineCov">    4748909 :   gimple *stmt;</span>
<span class="lineNum">    3846 </span><span class="lineCov">    4748909 :   tree cond;</span>
<span class="lineNum">    3847 </span><span class="lineCov">    4748909 :   gimple *assert_stmt;</span>
<span class="lineNum">    3848 </span><span class="lineCov">    4748909 :   edge_iterator ei;</span>
<span class="lineNum">    3849 </span><span class="lineCov">    4748909 :   edge e;</span>
<span class="lineNum">    3850 </span>            : 
<span class="lineNum">    3851 </span>            :   /* If we have X &lt;=&gt; X do not insert an assert expr for that.  */
<span class="lineNum">    3852 </span><span class="lineCov">    4748909 :   if (loc-&gt;expr == loc-&gt;val)</span>
<span class="lineNum">    3853 </span>            :     return false;
<span class="lineNum">    3854 </span>            : 
<span class="lineNum">    3855 </span><span class="lineCov">    4748909 :   cond = build2 (loc-&gt;comp_code, boolean_type_node, loc-&gt;expr, loc-&gt;val);</span>
<span class="lineNum">    3856 </span><span class="lineCov">    4748909 :   assert_stmt = build_assert_expr_for (cond, name);</span>
<span class="lineNum">    3857 </span><span class="lineCov">    4748909 :   if (loc-&gt;e)</span>
<span class="lineNum">    3858 </span>            :     {
<span class="lineNum">    3859 </span>            :       /* We have been asked to insert the assertion on an edge.  This
<span class="lineNum">    3860 </span>            :          is used only by COND_EXPR and SWITCH_EXPR assertions.  */
<span class="lineNum">    3861 </span><span class="lineCov">   10269129 :       gcc_checking_assert (gimple_code (gsi_stmt (loc-&gt;si)) == GIMPLE_COND</span>
<span class="lineNum">    3862 </span>            :                            || (gimple_code (gsi_stmt (loc-&gt;si))
<span class="lineNum">    3863 </span>            :                                == GIMPLE_SWITCH));
<span class="lineNum">    3864 </span>            : 
<span class="lineNum">    3865 </span><span class="lineCov">    3423043 :       gsi_insert_on_edge (loc-&gt;e, assert_stmt);</span>
<span class="lineNum">    3866 </span><span class="lineCov">    3423043 :       return true;</span>
<span class="lineNum">    3867 </span>            :     }
<span class="lineNum">    3868 </span>            : 
<span class="lineNum">    3869 </span>            :   /* If the stmt iterator points at the end then this is an insertion
<span class="lineNum">    3870 </span>            :      at the beginning of a block.  */
<span class="lineNum">    3871 </span><span class="lineCov">    2651732 :   if (gsi_end_p (loc-&gt;si))</span>
<span class="lineNum">    3872 </span>            :     {
<span class="lineNum">    3873 </span><span class="lineCov">       4133 :       gimple_stmt_iterator si = gsi_after_labels (loc-&gt;bb);</span>
<span class="lineNum">    3874 </span><span class="lineCov">       4133 :       gsi_insert_before (&amp;si, assert_stmt, GSI_SAME_STMT);</span>
<span class="lineNum">    3875 </span><span class="lineCov">       4133 :       return false;</span>
<span class="lineNum">    3876 </span>            : 
<span class="lineNum">    3877 </span>            :     }
<span class="lineNum">    3878 </span>            :   /* Otherwise, we can insert right after LOC-&gt;SI iff the
<span class="lineNum">    3879 </span>            :      statement must not be the last statement in the block.  */
<span class="lineNum">    3880 </span><span class="lineCov">    1321733 :   stmt = gsi_stmt (loc-&gt;si);</span>
<span class="lineNum">    3881 </span><span class="lineCov">    1321733 :   if (!stmt_ends_bb_p (stmt))</span>
<span class="lineNum">    3882 </span>            :     {
<span class="lineNum">    3883 </span><span class="lineCov">    1263026 :       gsi_insert_after (&amp;loc-&gt;si, assert_stmt, GSI_SAME_STMT);</span>
<span class="lineNum">    3884 </span><span class="lineCov">    1263026 :       return false;</span>
<span class="lineNum">    3885 </span>            :     }
<span class="lineNum">    3886 </span>            : 
<span class="lineNum">    3887 </span>            :   /* If STMT must be the last statement in BB, we can only insert new
<span class="lineNum">    3888 </span>            :      assertions on the non-abnormal edge out of BB.  Note that since
<span class="lineNum">    3889 </span>            :      STMT is not control flow, there may only be one non-abnormal/eh edge
<span class="lineNum">    3890 </span>            :      out of BB.  */
<span class="lineNum">    3891 </span><span class="lineCov">     168838 :   FOR_EACH_EDGE (e, ei, loc-&gt;bb-&gt;succs)</span>
<span class="lineNum">    3892 </span><span class="lineCov">     110131 :     if (!(e-&gt;flags &amp; (EDGE_ABNORMAL|EDGE_EH)))</span>
<span class="lineNum">    3893 </span>            :       {
<span class="lineNum">    3894 </span><span class="lineCov">      58707 :         gsi_insert_on_edge (e, assert_stmt);</span>
<span class="lineNum">    3895 </span><span class="lineCov">      58707 :         return true;</span>
<span class="lineNum">    3896 </span>            :       }
<span class="lineNum">    3897 </span>            : 
<span class="lineNum">    3898 </span><span class="lineNoCov">          0 :   gcc_unreachable ();</span>
<span class="lineNum">    3899 </span>            : }
<span class="lineNum">    3900 </span>            : 
<span class="lineNum">    3901 </span>            : /* Qsort helper for sorting assert locations.  If stable is true, don't
<span class="lineNum">    3902 </span>            :    use iterative_hash_expr because it can be unstable for -fcompare-debug,
<span class="lineNum">    3903 </span>            :    on the other side some pointers might be NULL.  */
<span class="lineNum">    3904 </span>            : 
<a name="3905"><span class="lineNum">    3905 </span>            : template &lt;bool stable&gt;</a>
<span class="lineNum">    3906 </span>            : static int
<span class="lineNum">    3907 </span><span class="lineCov">   37104377 : compare_assert_loc (const void *pa, const void *pb)</span>
<span class="lineNum">    3908 </span>            : {
<span class="lineNum">    3909 </span><span class="lineCov">   37104377 :   assert_locus * const a = *(assert_locus * const *)pa;</span>
<span class="lineNum">    3910 </span><span class="lineCov">   37104377 :   assert_locus * const b = *(assert_locus * const *)pb;</span>
<span class="lineNum">    3911 </span>            : 
<span class="lineNum">    3912 </span>            :   /* If stable, some asserts might be optimized away already, sort
<span class="lineNum">    3913 </span>            :      them last.  */
<span class="lineNum">    3914 </span>            :   if (stable)
<span class="lineNum">    3915 </span>            :     {
<span class="lineNum">    3916 </span><span class="lineCov">   18102218 :       if (a == NULL)</span>
<span class="lineNum">    3917 </span><span class="lineCov">      41711 :         return b != NULL;</span>
<span class="lineNum">    3918 </span><span class="lineCov">   18060507 :       else if (b == NULL)</span>
<span class="lineNum">    3919 </span>            :         return -1;
<span class="lineNum">    3920 </span>            :     }
<span class="lineNum">    3921 </span>            : 
<span class="lineNum">    3922 </span><span class="lineCov">   37021481 :   if (a-&gt;e == NULL &amp;&amp; b-&gt;e != NULL)</span>
<span class="lineNum">    3923 </span>            :     return 1;
<span class="lineNum">    3924 </span><span class="lineCov">   36469400 :   else if (a-&gt;e != NULL &amp;&amp; b-&gt;e == NULL)</span>
<span class="lineNum">    3925 </span>            :     return -1;
<span class="lineNum">    3926 </span>            : 
<span class="lineNum">    3927 </span>            :   /* After the above checks, we know that (a-&gt;e == NULL) == (b-&gt;e == NULL),
<span class="lineNum">    3928 </span>            :      no need to test both a-&gt;e and b-&gt;e.  */
<span class="lineNum">    3929 </span>            : 
<span class="lineNum">    3930 </span>            :   /* Sort after destination index.  */
<span class="lineNum">    3931 </span><span class="lineCov">   35785750 :   if (a-&gt;e == NULL)</span>
<span class="lineNum">    3932 </span>            :     ;
<span class="lineNum">    3933 </span><span class="lineCov">   29313779 :   else if (a-&gt;e-&gt;dest-&gt;index &gt; b-&gt;e-&gt;dest-&gt;index)</span>
<span class="lineNum">    3934 </span>            :     return 1;
<span class="lineNum">    3935 </span><span class="lineCov">   16111362 :   else if (a-&gt;e-&gt;dest-&gt;index &lt; b-&gt;e-&gt;dest-&gt;index)</span>
<span class="lineNum">    3936 </span>            :     return -1;
<span class="lineNum">    3937 </span>            : 
<span class="lineNum">    3938 </span>            :   /* Sort after comp_code.  */
<span class="lineNum">    3939 </span><span class="lineCov">    7749709 :   if (a-&gt;comp_code &gt; b-&gt;comp_code)</span>
<span class="lineNum">    3940 </span>            :     return 1;
<span class="lineNum">    3941 </span><span class="lineCov">    7439730 :   else if (a-&gt;comp_code &lt; b-&gt;comp_code)</span>
<span class="lineNum">    3942 </span>            :     return -1;
<span class="lineNum">    3943 </span>            : 
<span class="lineNum">    3944 </span>            :   hashval_t ha, hb;
<span class="lineNum">    3945 </span>            : 
<span class="lineNum">    3946 </span>            :   /* E.g. if a-&gt;val is ADDR_EXPR of a VAR_DECL, iterative_hash_expr
<span class="lineNum">    3947 </span>            :      uses DECL_UID of the VAR_DECL, so sorting might differ between
<span class="lineNum">    3948 </span>            :      -g and -g0.  When doing the removal of redundant assert exprs
<span class="lineNum">    3949 </span>            :      and commonization to successors, this does not matter, but for
<span class="lineNum">    3950 </span>            :      the final sort needs to be stable.  */
<span class="lineNum">    3951 </span>            :   if (stable)
<span class="lineNum">    3952 </span>            :     {
<span class="lineNum">    3953 </span><span class="lineCov">    3452170 :       ha = 0;</span>
<span class="lineNum">    3954 </span><span class="lineCov">    3452170 :       hb = 0;</span>
<span class="lineNum">    3955 </span>            :     }
<span class="lineNum">    3956 </span>            :   else
<span class="lineNum">    3957 </span>            :     {
<span class="lineNum">    3958 </span><span class="lineCov">    3631852 :       ha = iterative_hash_expr (a-&gt;expr, iterative_hash_expr (a-&gt;val, 0));</span>
<span class="lineNum">    3959 </span><span class="lineCov">    3631852 :       hb = iterative_hash_expr (b-&gt;expr, iterative_hash_expr (b-&gt;val, 0));</span>
<span class="lineNum">    3960 </span>            :     }
<span class="lineNum">    3961 </span>            : 
<span class="lineNum">    3962 </span>            :   /* Break the tie using hashing and source/bb index.  */
<span class="lineNum">    3963 </span><span class="lineCov">    3631852 :   if (ha == hb)</span>
<span class="lineNum">    3964 </span><span class="lineCov">    3358568 :     return (a-&gt;e != NULL</span>
<span class="lineNum">    3965 </span><span class="lineCov">     340250 :             ? a-&gt;e-&gt;src-&gt;index - b-&gt;e-&gt;src-&gt;index</span>
<span class="lineNum">    3966 </span><span class="lineCov">    6810738 :             : a-&gt;bb-&gt;index - b-&gt;bb-&gt;index);</span>
<span class="lineNum">    3967 </span><span class="lineCov">     273284 :   return ha &gt; hb ? 1 : -1;</span>
<span class="lineNum">    3968 </span>            : }
<span class="lineNum">    3969 </span><span class="lineCov">   18102218 : </span>
<span class="lineNum">    3970 </span>            : /* Process all the insertions registered for every name N_i registered
<span class="lineNum">    3971 </span><span class="lineCov">   18102218 :    in NEED_ASSERT_FOR.  The list of assertions to be inserted are</span>
<span class="lineNum">    3972 </span><span class="lineCov">   18102218 :    found in ASSERTS_FOR[i].  */</span>
<a name="3973"><span class="lineNum">    3973 </span>            : </a>
<span class="lineNum">    3974 </span>            : static void
<span class="lineNum">    3975 </span>            : process_assert_insertions (void)
<span class="lineNum">    3976 </span>            : {
<span class="lineNum">    3977 </span>            :   unsigned i;
<span class="lineNum">    3978 </span><span class="lineCov">   18102218 :   bitmap_iterator bi;</span>
<span class="lineNum">    3979 </span><span class="lineCov">      41711 :   bool update_edges_p = false;</span>
<span class="lineNum">    3980 </span><span class="lineCov">   18060507 :   int num_asserts = 0;</span>
<span class="lineNum">    3981 </span>            : 
<span class="lineNum">    3982 </span>            :   if (dump_file &amp;&amp; (dump_flags &amp; TDF_DETAILS))
<span class="lineNum">    3983 </span>            :     dump_all_asserts (dump_file);
<span class="lineNum">    3984 </span><span class="lineCov">   18019322 : </span>
<span class="lineNum">    3985 </span>            :   EXECUTE_IF_SET_IN_BITMAP (need_assert_for, 0, i, bi)
<span class="lineNum">    3986 </span><span class="lineCov">   17698975 :     {</span>
<span class="lineNum">    3987 </span>            :       assert_locus *loc = asserts_for[i];
<span class="lineNum">    3988 </span>            :       gcc_assert (loc);
<span class="lineNum">    3989 </span>            : 
<span class="lineNum">    3990 </span>            :       auto_vec&lt;assert_locus *, 16&gt; asserts;
<span class="lineNum">    3991 </span>            :       for (; loc; loc = loc-&gt;next)
<span class="lineNum">    3992 </span>            :         asserts.safe_push (loc);
<span class="lineNum">    3993 </span><span class="lineCov">   17392941 :       asserts.qsort (compare_assert_loc&lt;false&gt;);</span>
<span class="lineNum">    3994 </span>            : 
<span class="lineNum">    3995 </span><span class="lineCov">   14228645 :       /* Push down common asserts to successors and remove redundant ones.  */</span>
<span class="lineNum">    3996 </span>            :       unsigned ecnt = 0;
<span class="lineNum">    3997 </span><span class="lineCov">    7146511 :       assert_locus *common = NULL;</span>
<span class="lineNum">    3998 </span>            :       unsigned commonj = 0;
<span class="lineNum">    3999 </span>            :       for (unsigned j = 0; j &lt; asserts.length (); ++j)
<span class="lineNum">    4000 </span>            :         {
<span class="lineNum">    4001 </span><span class="lineCov">    3782009 :           loc = asserts[j];</span>
<span class="lineNum">    4002 </span>            :           if (! loc-&gt;e)
<span class="lineNum">    4003 </span><span class="lineCov">    3610960 :             common = NULL;</span>
<span class="lineNum">    4004 </span>            :           else if (! common
<span class="lineNum">    4005 </span>            :                    || loc-&gt;e-&gt;dest != common-&gt;e-&gt;dest
<span class="lineNum">    4006 </span>            :                    || loc-&gt;comp_code != common-&gt;comp_code
<span class="lineNum">    4007 </span>            :                    || ! operand_equal_p (loc-&gt;val, common-&gt;val, 0)
<span class="lineNum">    4008 </span>            :                    || ! operand_equal_p (loc-&gt;expr, common-&gt;expr, 0))
<span class="lineNum">    4009 </span>            :             {
<span class="lineNum">    4010 </span>            :               commonj = j;
<span class="lineNum">    4011 </span>            :               common = loc;
<span class="lineNum">    4012 </span>            :               ecnt = 1;
<span class="lineNum">    4013 </span>            :             }
<span class="lineNum">    4014 </span>            :           else if (loc-&gt;e == asserts[j-1]-&gt;e)
<span class="lineNum">    4015 </span><span class="lineCov">    3452170 :             {</span>
<span class="lineNum">    4016 </span><span class="lineCov">    3452170 :               /* Remove duplicate asserts.  */</span>
<span class="lineNum">    4017 </span>            :               if (commonj == j - 1)
<span class="lineNum">    4018 </span>            :                 {
<span class="lineNum">    4019 </span>            :                   commonj = j;
<span class="lineNum">    4020 </span>            :                   common = loc;
<span class="lineNum">    4021 </span>            :                 }
<span class="lineNum">    4022 </span>            :               free (asserts[j-1]);
<span class="lineNum">    4023 </span>            :               asserts[j-1] = NULL;
<span class="lineNum">    4024 </span>            :             }
<span class="lineNum">    4025 </span>            :           else
<span class="lineNum">    4026 </span>            :             {
<span class="lineNum">    4027 </span><span class="lineCov">     289357 :               ecnt++;</span>
<span class="lineNum">    4028 </span><span class="lineCov">    3452170 :               if (EDGE_COUNT (common-&gt;e-&gt;dest-&gt;preds) == ecnt)</span>
<span class="lineNum">    4029 </span>            :                 {
<span class="lineNum">    4030 </span>            :                   /* We have the same assertion on all incoming edges of a BB.
<span class="lineNum">    4031 </span><span class="lineCov">   19002159 :                      Insert it at the beginning of that block.  */</span>
<span class="lineNum">    4032 </span>            :                   loc-&gt;bb = loc-&gt;e-&gt;dest;
<span class="lineNum">    4033 </span><span class="lineCov">   19002159 :                   loc-&gt;e = NULL;</span>
<span class="lineNum">    4034 </span><span class="lineCov">   19002159 :                   loc-&gt;si = gsi_none ();</span>
<span class="lineNum">    4035 </span>            :                   common = NULL;
<span class="lineNum">    4036 </span>            :                   /* Clear asserts commoned.  */
<span class="lineNum">    4037 </span>            :                   for (; commonj != j; ++commonj)
<span class="lineNum">    4038 </span>            :                     if (asserts[commonj])
<span class="lineNum">    4039 </span>            :                       {
<span class="lineNum">    4040 </span>            :                         free (asserts[commonj]);
<span class="lineNum">    4041 </span>            :                         asserts[commonj] = NULL;
<span class="lineNum">    4042 </span>            :                       }
<span class="lineNum">    4043 </span>            :                 }
<span class="lineNum">    4044 </span>            :             }
<span class="lineNum">    4045 </span>            :         }
<span class="lineNum">    4046 </span><span class="lineCov">   19002159 : </span>
<span class="lineNum">    4047 </span>            :       /* The asserts vector sorting above might be unstable for
<span class="lineNum">    4048 </span><span class="lineCov">   18770425 :          -fcompare-debug, sort again to ensure a stable sort.  */</span>
<span class="lineNum">    4049 </span>            :       asserts.qsort (compare_assert_loc&lt;true&gt;);
<span class="lineNum">    4050 </span>            :       for (unsigned j = 0; j &lt; asserts.length (); ++j)
<span class="lineNum">    4051 </span>            :         {
<span class="lineNum">    4052 </span>            :           loc = asserts[j];
<span class="lineNum">    4053 </span>            :           if (! loc)
<span class="lineNum">    4054 </span>            :             break;
<span class="lineNum">    4055 </span><span class="lineCov">   18392809 :           update_edges_p |= process_assert_insertions_for (ssa_name (i), loc);</span>
<span class="lineNum">    4056 </span>            :           num_asserts++;
<span class="lineNum">    4057 </span><span class="lineCov">   15085134 :           free (loc);</span>
<span class="lineNum">    4058 </span>            :         }
<span class="lineNum">    4059 </span><span class="lineCov">    8964851 :     }</span>
<span class="lineNum">    4060 </span>            : 
<span class="lineNum">    4061 </span>            :   if (update_edges_p)
<span class="lineNum">    4062 </span>            :     gsi_commit_edge_inserts ();
<span class="lineNum">    4063 </span><span class="lineCov">    3967700 : </span>
<span class="lineNum">    4064 </span>            :   statistics_counter_event (cfun, &quot;Number of ASSERT_EXPR expressions inserted&quot;,
<span class="lineNum">    4065 </span><span class="lineCov">    3828770 :                             num_asserts);</span>
<span class="lineNum">    4066 </span>            : }
<span class="lineNum">    4067 </span>            : 
<span class="lineNum">    4068 </span>            : 
<span class="lineNum">    4069 </span>            : /* Traverse the flowgraph looking for conditional jumps to insert range
<span class="lineNum">    4070 </span>            :    expressions.  These range expressions are meant to provide information
<span class="lineNum">    4071 </span>            :    to optimizations that need to reason in terms of value ranges.  They
<span class="lineNum">    4072 </span>            :    will not be expanded into RTL.  For instance, given:
<span class="lineNum">    4073 </span>            : 
<span class="lineNum">    4074 </span>            :    x = ...
<span class="lineNum">    4075 </span>            :    y = ...
<span class="lineNum">    4076 </span>            :    if (x &lt; y)
<span class="lineNum">    4077 </span>            :      y = x - 2;
<span class="lineNum">    4078 </span>            :    else
<span class="lineNum">    4079 </span>            :      x = y + 3;
<span class="lineNum">    4080 </span>            : 
<span class="lineNum">    4081 </span>            :    this pass will transform the code into:
<span class="lineNum">    4082 </span><span class="lineCov">    3631852 : </span>
<span class="lineNum">    4083 </span><span class="lineCov">    3631852 :    x = ...</span>
<span class="lineNum">    4084 </span>            :    y = ...
<span class="lineNum">    4085 </span>            :    if (x &lt; y)
<span class="lineNum">    4086 </span>            :     {
<span class="lineNum">    4087 </span><span class="lineCov">    3631852 :       x = ASSERT_EXPR &lt;x, x &lt; y&gt;</span>
<span class="lineNum">    4088 </span><span class="lineCov">    3358568 :       y = x - 2</span>
<span class="lineNum">    4089 </span><span class="lineCov">      50893 :     }</span>
<span class="lineNum">    4090 </span><span class="lineCov">    3358568 :    else</span>
<span class="lineNum">    4091 </span><span class="lineCov">     273284 :     {</span>
<span class="lineNum">    4092 </span>            :       y = ASSERT_EXPR &lt;y, x &gt;= y&gt;
<span class="lineNum">    4093 </span>            :       x = y + 3
<span class="lineNum">    4094 </span>            :     }
<span class="lineNum">    4095 </span>            : 
<span class="lineNum">    4096 </span>            :    The idea is that once copy and constant propagation have run, other
<span class="lineNum">    4097 </span>            :    optimizations will be able to determine what ranges of values can 'x'
<span class="lineNum">    4098 </span>            :    take in different paths of the code, simply by checking the reaching
<span class="lineNum">    4099 </span><span class="lineCov">     487183 :    definition of 'x'.  */</span>
<a name="4100"><span class="lineNum">    4100 </span>            : </a>
<span class="lineNum">    4101 </span><span class="lineCov">     487183 : static void</span>
<span class="lineNum">    4102 </span><span class="lineCov">     487183 : insert_range_assertions (void)</span>
<span class="lineNum">    4103 </span><span class="lineCov">     487183 : {</span>
<span class="lineNum">    4104 </span><span class="lineCov">     487183 :   need_assert_for = BITMAP_ALLOC (NULL);</span>
<span class="lineNum">    4105 </span>            :   asserts_for = XCNEWVEC (assert_locus *, num_ssa_names);
<span class="lineNum">    4106 </span><span class="lineCov">     487183 : </span>
<span class="lineNum">    4107 </span><span class="lineCov">         27 :   calculate_dominance_info (CDI_DOMINATORS);</span>
<span class="lineNum">    4108 </span>            : 
<span class="lineNum">    4109 </span><span class="lineCov">    3480987 :   find_assert_locations ();</span>
<span class="lineNum">    4110 </span>            :   if (!bitmap_empty_p (need_assert_for))
<span class="lineNum">    4111 </span><span class="lineCov">    2993804 :     {</span>
<span class="lineNum">    4112 </span><span class="lineCov">    2993804 :       process_assert_insertions ();</span>
<span class="lineNum">    4113 </span>            :       update_ssa (TODO_update_ssa_no_phi);
<span class="lineNum">    4114 </span><span class="lineCov">    8981412 :     }</span>
<span class="lineNum">    4115 </span><span class="lineCov">    7747790 : </span>
<span class="lineNum">    4116 </span><span class="lineCov">    4753986 :   if (dump_file &amp;&amp; (dump_flags &amp; TDF_DETAILS))</span>
<span class="lineNum">    4117 </span><span class="lineCov">    2993804 :     {</span>
<span class="lineNum">    4118 </span>            :       fprintf (dump_file, &quot;\nSSA form after inserting ASSERT_EXPRs\n&quot;);
<span class="lineNum">    4119 </span>            :       dump_function_to_file (current_function_decl, dump_file, dump_flags);
<span class="lineNum">    4120 </span>            :     }
<span class="lineNum">    4121 </span>            : 
<span class="lineNum">    4122 </span>            :   free (asserts_for);
<span class="lineNum">    4123 </span><span class="lineCov">   15495580 :   BITMAP_FREE (need_assert_for);</span>
<span class="lineNum">    4124 </span>            : }
<span class="lineNum">    4125 </span><span class="lineCov">    4753986 : </span>
<span class="lineNum">    4126 </span><span class="lineCov">    4753986 : class vrp_prop : public ssa_propagation_engine</span>
<span class="lineNum">    4127 </span>            : {
<span class="lineNum">    4128 </span><span class="lineCov">    3432253 :  public:</span>
<span class="lineNum">    4129 </span><span class="lineCov">    1334437 :   enum ssa_prop_result visit_stmt (gimple *, edge *, tree *) FINAL OVERRIDE;</span>
<span class="lineNum">    4130 </span><span class="lineCov">     113423 :   enum ssa_prop_result visit_phi (gphi *) FINAL OVERRIDE;</span>
<span class="lineNum">    4131 </span><span class="lineCov">      42292 : </span>
<span class="lineNum">    4132 </span><span class="lineCov">    3442843 :   void vrp_initialize (void);</span>
<span class="lineNum">    4133 </span>            :   void vrp_finalize (bool);
<span class="lineNum">    4134 </span><span class="lineCov">    3422424 :   void check_all_array_refs (void);</span>
<span class="lineNum">    4135 </span><span class="lineCov">    3422424 :   void check_array_ref (location_t, tree, bool);</span>
<span class="lineNum">    4136 </span><span class="lineCov">    3422424 :   void check_mem_ref (location_t, tree, bool);</span>
<span class="lineNum">    4137 </span>            :   void search_for_addr_array (tree, location_t);
<span class="lineNum">    4138 </span><span class="lineCov">       9829 : </span>
<span class="lineNum">    4139 </span>            :   class vr_values vr_values;
<span class="lineNum">    4140 </span>            :   /* Temporary delegator to minimize code churn.  */
<span class="lineNum">    4141 </span><span class="lineCov">         24 :   value_range *get_value_range (const_tree op)</span>
<span class="lineNum">    4142 </span>            :     { return vr_values.get_value_range (op); }
<span class="lineNum">    4143 </span><span class="lineCov">         24 :   void set_defs_to_varying (gimple *stmt)</span>
<span class="lineNum">    4144 </span><span class="lineCov">         24 :     { return vr_values.set_defs_to_varying (stmt); }</span>
<span class="lineNum">    4145 </span>            :   void extract_range_from_stmt (gimple *stmt, edge *taken_edge_p,
<span class="lineNum">    4146 </span><span class="lineCov">         24 :                                 tree *output_p, value_range *vr)</span>
<span class="lineNum">    4147 </span><span class="lineCov">         24 :     { vr_values.extract_range_from_stmt (stmt, taken_edge_p, output_p, vr); }</span>
<span class="lineNum">    4148 </span>            :   bool update_value_range (const_tree op, value_range *vr)
<span class="lineNum">    4149 </span>            :     { return vr_values.update_value_range (op, vr); }
<span class="lineNum">    4150 </span>            :   void extract_range_basic (value_range *vr, gimple *stmt)
<span class="lineNum">    4151 </span><span class="lineCov">       9805 :     { vr_values.extract_range_basic (vr, stmt); }</span>
<span class="lineNum">    4152 </span><span class="lineCov">      19610 :   void extract_range_from_phi_node (gphi *phi, value_range *vr)</span>
<span class="lineNum">    4153 </span>            :     { vr_values.extract_range_from_phi_node (phi, vr); }
<span class="lineNum">    4154 </span>            : };
<span class="lineNum">    4155 </span>            : /* Checks one ARRAY_REF in REF, located at LOCUS. Ignores flexible arrays
<span class="lineNum">    4156 </span><span class="lineCov">       4133 :    and &quot;struct&quot; hacks. If VRP can determine that the</span>
<span class="lineNum">    4157 </span><span class="lineCov">       4133 :    array subscript is a constant, check if it is outside valid</span>
<span class="lineNum">    4158 </span><span class="lineCov">       4133 :    range. If the array subscript is a RANGE, warn if it is</span>
<span class="lineNum">    4159 </span><span class="lineCov">       4133 :    non-overlapping with valid range.</span>
<span class="lineNum">    4160 </span>            :    IGNORE_OFF_BY_ONE is true if the ARRAY_REF is inside a ADDR_EXPR.  */
<span class="lineNum">    4161 </span><span class="lineCov">       9186 : </span>
<span class="lineNum">    4162 </span><span class="lineCov">       5053 : void</span>
<span class="lineNum">    4163 </span>            : vrp_prop::check_array_ref (location_t location, tree ref,
<span class="lineNum">    4164 </span><span class="lineCov">       5053 :                            bool ignore_off_by_one)</span>
<span class="lineNum">    4165 </span><span class="lineCov">       5053 : {</span>
<span class="lineNum">    4166 </span>            :   const value_range *vr = NULL;
<span class="lineNum">    4167 </span>            :   tree low_sub, up_sub;
<span class="lineNum">    4168 </span>            :   tree low_bound, up_bound, up_bound_p1;
<span class="lineNum">    4169 </span>            : 
<span class="lineNum">    4170 </span>            :   if (TREE_NO_WARNING (ref))
<span class="lineNum">    4171 </span>            :     return;
<span class="lineNum">    4172 </span>            : 
<span class="lineNum">    4173 </span><span class="lineCov">    2993804 :   low_sub = up_sub = TREE_OPERAND (ref, 1);</span>
<span class="lineNum">    4174 </span><span class="lineCov">   15485426 :   up_bound = array_ref_up_bound (ref);</span>
<span class="lineNum">    4175 </span>            : 
<span class="lineNum">    4176 </span><span class="lineCov">    4752589 :   if (!up_bound</span>
<span class="lineNum">    4177 </span><span class="lineCov">    4752589 :       || TREE_CODE (up_bound) != INTEGER_CST</span>
<span class="lineNum">    4178 </span>            :       || (warn_array_bounds &lt; 2
<span class="lineNum">    4179 </span><span class="lineCov">    4748909 :           &amp;&amp; array_at_struct_end_p (ref)))</span>
<span class="lineNum">    4180 </span><span class="lineCov">    4748909 :     {</span>
<span class="lineNum">    4181 </span><span class="lineCov">    4748909 :       /* Accesses to trailing arrays via pointers may access storage</span>
<span class="lineNum">    4182 </span>            :          beyond the types array bounds.  For such arrays, or for flexible
<span class="lineNum">    4183 </span>            :          array members, as well as for other arrays of an unknown size,
<span class="lineNum">    4184 </span>            :          replace the upper bound with a more permissive one that assumes
<span class="lineNum">    4185 </span><span class="lineCov">     487183 :          the size of the largest object is PTRDIFF_MAX.  */</span>
<span class="lineNum">    4186 </span><span class="lineCov">     381493 :       tree eltsize = array_ref_element_size (ref);</span>
<span class="lineNum">    4187 </span>            : 
<span class="lineNum">    4188 </span><span class="lineCov">     487183 :       if (TREE_CODE (eltsize) != INTEGER_CST</span>
<span class="lineNum">    4189 </span>            :           || integer_zerop (eltsize))
<span class="lineNum">    4190 </span><span class="lineCov">     487183 :         {</span>
<span class="lineNum">    4191 </span>            :           up_bound = NULL_TREE;
<span class="lineNum">    4192 </span>            :           up_bound_p1 = NULL_TREE;
<span class="lineNum">    4193 </span>            :         }
<span class="lineNum">    4194 </span>            :       else
<span class="lineNum">    4195 </span>            :         {
<span class="lineNum">    4196 </span>            :           tree maxbound = TYPE_MAX_VALUE (ptrdiff_type_node);
<span class="lineNum">    4197 </span>            :           tree arg = TREE_OPERAND (ref, 0);
<span class="lineNum">    4198 </span>            :           poly_int64 off;
<span class="lineNum">    4199 </span>            : 
<span class="lineNum">    4200 </span>            :           if (get_addr_base_and_unit_offset (arg, &amp;off) &amp;&amp; known_gt (off, 0))
<span class="lineNum">    4201 </span>            :             maxbound = wide_int_to_tree (sizetype,
<span class="lineNum">    4202 </span>            :                                          wi::sub (wi::to_wide (maxbound),
<span class="lineNum">    4203 </span>            :                                                   off));
<span class="lineNum">    4204 </span>            :           else
<span class="lineNum">    4205 </span>            :             maxbound = fold_convert (sizetype, maxbound);
<span class="lineNum">    4206 </span>            : 
<span class="lineNum">    4207 </span>            :           up_bound_p1 = int_const_binop (TRUNC_DIV_EXPR, maxbound, eltsize);
<span class="lineNum">    4208 </span>            : 
<span class="lineNum">    4209 </span>            :           up_bound = int_const_binop (MINUS_EXPR, up_bound_p1,
<span class="lineNum">    4210 </span>            :                                       build_int_cst (ptrdiff_type_node, 1));
<span class="lineNum">    4211 </span>            :         }
<span class="lineNum">    4212 </span>            :     }
<span class="lineNum">    4213 </span>            :   else
<span class="lineNum">    4214 </span>            :     up_bound_p1 = int_const_binop (PLUS_EXPR, up_bound,
<span class="lineNum">    4215 </span>            :                                    build_int_cst (TREE_TYPE (up_bound), 1));
<span class="lineNum">    4216 </span>            : 
<span class="lineNum">    4217 </span>            :   low_bound = array_ref_low_bound (ref);
<span class="lineNum">    4218 </span>            : 
<span class="lineNum">    4219 </span>            :   tree artype = TREE_TYPE (TREE_OPERAND (ref, 0));
<span class="lineNum">    4220 </span>            : 
<span class="lineNum">    4221 </span>            :   bool warned = false;
<span class="lineNum">    4222 </span>            : 
<span class="lineNum">    4223 </span>            :   /* Empty array.  */
<span class="lineNum">    4224 </span>            :   if (up_bound &amp;&amp; tree_int_cst_equal (low_bound, up_bound_p1))
<span class="lineNum">    4225 </span>            :     warned = warning_at (location, OPT_Warray_bounds,
<span class="lineNum">    4226 </span><span class="lineCov">    1167974 :                          &quot;array subscript %E is above array bounds of %qT&quot;,</span>
<span class="lineNum">    4227 </span>            :                          low_bound, artype);
<span class="lineNum">    4228 </span><span class="lineCov">    1167974 : </span>
<span class="lineNum">    4229 </span><span class="lineCov">    2335948 :   if (TREE_CODE (low_sub) == SSA_NAME)</span>
<span class="lineNum">    4230 </span>            :     {
<span class="lineNum">    4231 </span><span class="lineCov">    1167974 :       vr = get_value_range (low_sub);</span>
<span class="lineNum">    4232 </span>            :       if (vr-&gt;type == VR_RANGE || vr-&gt;type == VR_ANTI_RANGE)
<span class="lineNum">    4233 </span><span class="lineCov">    1167974 :         {</span>
<span class="lineNum">    4234 </span><span class="lineCov">    2335948 :           low_sub = vr-&gt;type == VR_RANGE ? vr-&gt;max : vr-&gt;min;</span>
<span class="lineNum">    4235 </span>            :           up_sub = vr-&gt;type == VR_RANGE ? vr-&gt;min : vr-&gt;max;
<span class="lineNum">    4236 </span><span class="lineCov">     487183 :         }</span>
<span class="lineNum">    4237 </span><span class="lineCov">     487183 :     }</span>
<span class="lineNum">    4238 </span>            : 
<span class="lineNum">    4239 </span>            :   if (vr &amp;&amp; vr-&gt;type == VR_ANTI_RANGE)
<span class="lineNum">    4240 </span><span class="lineCov">    1167974 :     {</span>
<span class="lineNum">    4241 </span>            :       if (up_bound
<span class="lineNum">    4242 </span><span class="lineCov">         34 :           &amp;&amp; TREE_CODE (up_sub) == INTEGER_CST</span>
<span class="lineNum">    4243 </span><span class="lineCov">         34 :           &amp;&amp; (ignore_off_by_one</span>
<span class="lineNum">    4244 </span>            :               ? tree_int_cst_lt (up_bound, up_sub)
<span class="lineNum">    4245 </span>            :               : tree_int_cst_le (up_bound, up_sub))
<span class="lineNum">    4246 </span><span class="lineCov">    1167974 :           &amp;&amp; TREE_CODE (low_sub) == INTEGER_CST</span>
<span class="lineNum">    4247 </span><span class="lineCov">    1167974 :           &amp;&amp; tree_int_cst_le (low_sub, low_bound))</span>
<span class="lineNum">    4248 </span><span class="lineCov">    1167974 :         warned = warning_at (location, OPT_Warray_bounds,</span>
<span class="lineNum">    4249 </span>            :                              &quot;array subscript [%E, %E] is outside &quot;
<span class="lineNum">    4250 </span><span class="lineCov">    3503922 :                              &quot;array bounds of %qT&quot;,</span>
<span class="lineNum">    4251 </span>            :                              low_sub, up_sub, artype);
<span class="lineNum">    4252 </span>            :     }
<span class="lineNum">    4253 </span>            :   else if (up_bound
<span class="lineNum">    4254 </span>            :            &amp;&amp; TREE_CODE (up_sub) == INTEGER_CST
<span class="lineNum">    4255 </span>            :            &amp;&amp; (ignore_off_by_one
<span class="lineNum">    4256 </span>            :                ? !tree_int_cst_le (up_sub, up_bound_p1)
<span class="lineNum">    4257 </span>            :                : !tree_int_cst_le (up_sub, up_bound)))
<span class="lineNum">    4258 </span>            :     {
<span class="lineNum">    4259 </span>            :       if (dump_file &amp;&amp; (dump_flags &amp; TDF_DETAILS))
<span class="lineNum">    4260 </span>            :         {
<span class="lineNum">    4261 </span>            :           fprintf (dump_file, &quot;Array bound warning for &quot;);
<span class="lineNum">    4262 </span>            :           dump_generic_expr (MSG_NOTE, TDF_SLIM, ref);
<span class="lineNum">    4263 </span>            :           fprintf (dump_file, &quot;\n&quot;);
<span class="lineNum">    4264 </span>            :         }
<span class="lineNum">    4265 </span>            :       warned = warning_at (location, OPT_Warray_bounds,
<span class="lineNum">    4266 </span><span class="lineCov">   49218909 :                            &quot;array subscript %E is above array bounds of %qT&quot;,</span>
<span class="lineNum">    4267 </span>            :                            up_sub, artype);
<span class="lineNum">    4268 </span><span class="lineCov">   88332640 :     }</span>
<span class="lineNum">    4269 </span>            :   else if (TREE_CODE (low_sub) == INTEGER_CST
<span class="lineNum">    4270 </span>            :            &amp;&amp; tree_int_cst_lt (low_sub, low_bound))
<span class="lineNum">    4271 </span><span class="lineCov">   27719152 :     {</span>
<span class="lineNum">    4272 </span>            :       if (dump_file &amp;&amp; (dump_flags &amp; TDF_DETAILS))
<span class="lineNum">    4273 </span><span class="lineCov">   25100877 :         {</span>
<span class="lineNum">    4274 </span>            :           fprintf (dump_file, &quot;Array bound warning for &quot;);
<span class="lineNum">    4275 </span><span class="lineCov">     108990 :           dump_generic_expr (MSG_NOTE, TDF_SLIM, ref);</span>
<span class="lineNum">    4276 </span>            :           fprintf (dump_file, &quot;\n&quot;);
<span class="lineNum">    4277 </span><span class="lineCov">    5163382 :         }</span>
<span class="lineNum">    4278 </span>            :       warned = warning_at (location, OPT_Warray_bounds,
<span class="lineNum">    4279 </span>            :                            &quot;array subscript %E is below array bounds of %qT&quot;,
<span class="lineNum">    4280 </span>            :                            low_sub, artype);
<span class="lineNum">    4281 </span>            :     }
<span class="lineNum">    4282 </span>            : 
<span class="lineNum">    4283 </span>            :   if (warned)
<span class="lineNum">    4284 </span>            :     {
<span class="lineNum">    4285 </span>            :       ref = TREE_OPERAND (ref, 0);
<span class="lineNum">    4286 </span>            : 
<span class="lineNum">    4287 </span><span class="lineCov">     174362 :       if (DECL_P (ref))</span>
<span class="lineNum">    4288 </span>            :         inform (DECL_SOURCE_LOCATION (ref), &quot;while referencing %qD&quot;, ref);
<span class="lineNum">    4289 </span>            : 
<span class="lineNum">    4290 </span><span class="lineCov">     174362 :       TREE_NO_WARNING (ref) = 1;</span>
<span class="lineNum">    4291 </span><span class="lineCov">     174362 :     }</span>
<span class="lineNum">    4292 </span><span class="lineCov">     174362 : }</span>
<span class="lineNum">    4293 </span>            : 
<span class="lineNum">    4294 </span><span class="lineCov">     174362 : /* Checks one MEM_REF in REF, located at LOCATION, for out-of-bounds</span>
<span class="lineNum">    4295 </span>            :    references to string constants.  If VRP can determine that the array
<span class="lineNum">    4296 </span>            :    subscript is a constant, check if it is outside valid range.
<span class="lineNum">    4297 </span><span class="lineCov">     174310 :    If the array subscript is a RANGE, warn if it is non-overlapping</span>
<span class="lineNum">    4298 </span><span class="lineCov">     174310 :    with valid range.</span>
<span class="lineNum">    4299 </span>            :    IGNORE_OFF_BY_ONE is true if the MEM_REF is inside an ADDR_EXPR
<span class="lineNum">    4300 </span><span class="lineCov">     174310 :    (used to allow one-past-the-end indices for code that takes</span>
<span class="lineNum">    4301 </span><span class="lineCov">     111689 :    the address of the just-past-the-end element of an array).  */</span>
<span class="lineNum">    4302 </span><span class="lineCov">     285242 : </span>
<span class="lineNum">    4303 </span><span class="lineCov">     110843 : void</span>
<span class="lineNum">    4304 </span>            : vrp_prop::check_mem_ref (location_t location, tree ref,
<span class="lineNum">    4305 </span>            :                          bool ignore_off_by_one)
<span class="lineNum">    4306 </span>            : {
<span class="lineNum">    4307 </span>            :   if (TREE_NO_WARNING (ref))
<span class="lineNum">    4308 </span>            :     return;
<span class="lineNum">    4309 </span>            : 
<span class="lineNum">    4310 </span><span class="lineCov">      67231 :   tree arg = TREE_OPERAND (ref, 0);</span>
<span class="lineNum">    4311 </span>            :   /* The constant and variable offset of the reference.  */
<span class="lineNum">    4312 </span><span class="lineCov">      67231 :   tree cstoff = TREE_OPERAND (ref, 1);</span>
<span class="lineNum">    4313 </span><span class="lineCov">      67231 :   tree varoff = NULL_TREE;</span>
<span class="lineNum">    4314 </span>            : 
<span class="lineNum">    4315 </span>            :   const offset_int maxobjsize = tree_to_shwi (max_object_size ());
<span class="lineNum">    4316 </span>            : 
<span class="lineNum">    4317 </span>            :   /* The array or string constant bounds in bytes.  Initially set
<span class="lineNum">    4318 </span>            :      to [-MAXOBJSIZE - 1, MAXOBJSIZE]  until a tighter bound is
<span class="lineNum">    4319 </span>            :      determined.  */
<span class="lineNum">    4320 </span><span class="lineCov">      66948 :   offset_int arrbounds[2] = { -maxobjsize - 1, maxobjsize };</span>
<span class="lineNum">    4321 </span><span class="lineCov">      66948 : </span>
<span class="lineNum">    4322 </span><span class="lineCov">      66948 :   /* The minimum and maximum intermediate offset.  For a reference</span>
<span class="lineNum">    4323 </span>            :      to be valid, not only does the final offset/subscript must be
<span class="lineNum">    4324 </span><span class="lineCov">      66948 :      in bounds but all intermediate offsets should be as well.</span>
<span class="lineNum">    4325 </span><span class="lineCov">      60740 :      GCC may be able to deal gracefully with such out-of-bounds</span>
<span class="lineNum">    4326 </span><span class="lineCov">     121480 :      offsets so the checking is only enbaled at -Warray-bounds=2</span>
<span class="lineNum">    4327 </span><span class="lineCov">      60740 :      where it may help detect bugs in uses of the intermediate</span>
<span class="lineNum">    4328 </span>            :      offsets that could otherwise not be detectable.  */
<span class="lineNum">    4329 </span><span class="lineCov">       6208 :   offset_int ioff = wi::to_offset (fold_convert (ptrdiff_type_node, cstoff));</span>
<span class="lineNum">    4330 </span>            :   offset_int extrema[2] = { 0, wi::abs (ioff) };
<span class="lineNum">    4331 </span><span class="lineCov">      66948 : </span>
<span class="lineNum">    4332 </span>            :   /* The range of the byte offset into the reference.  */
<span class="lineNum">    4333 </span><span class="lineCov">      66948 :   offset_int offrange[2] = { 0, 0 };</span>
<span class="lineNum">    4334 </span><span class="lineCov">     200844 : </span>
<span class="lineNum">    4335 </span>            :   const value_range *vr = NULL;
<span class="lineNum">    4336 </span>            : 
<span class="lineNum">    4337 </span>            :   /* Determine the offsets and increment OFFRANGE for the bounds of each.
<span class="lineNum">    4338 </span><span class="lineCov">     107079 :      The loop computes the the range of the final offset for expressions</span>
<span class="lineNum">    4339 </span><span class="lineCov">     321237 :      such as (A + i0 + ... + iN)[CSTOFF] where i0 through iN are SSA_NAMEs</span>
<span class="lineNum">    4340 </span>            :      in some range.  */
<span class="lineNum">    4341 </span><span class="lineCov">     174310 :   while (TREE_CODE (arg) == SSA_NAME)</span>
<span class="lineNum">    4342 </span>            :     {
<span class="lineNum">    4343 </span><span class="lineCov">     174310 :       gimple *def = SSA_NAME_DEF_STMT (arg);</span>
<span class="lineNum">    4344 </span>            :       if (!is_gimple_assign (def))
<span class="lineNum">    4345 </span><span class="lineCov">     174310 :         break;</span>
<span class="lineNum">    4346 </span>            : 
<span class="lineNum">    4347 </span>            :       tree_code code = gimple_assign_rhs_code (def);
<span class="lineNum">    4348 </span><span class="lineCov">     174310 :       if (code == POINTER_PLUS_EXPR)</span>
<span class="lineNum">    4349 </span><span class="lineCov">          3 :         {</span>
<span class="lineNum">    4350 </span>            :           arg = gimple_assign_rhs1 (def);
<span class="lineNum">    4351 </span>            :           varoff = gimple_assign_rhs2 (def);
<span class="lineNum">    4352 </span>            :         }
<span class="lineNum">    4353 </span><span class="lineCov">     174310 :       else if (code == ASSERT_EXPR)</span>
<span class="lineNum">    4354 </span>            :         {
<span class="lineNum">    4355 </span><span class="lineCov">     103097 :           arg = TREE_OPERAND (gimple_assign_rhs1 (def), 0);</span>
<span class="lineNum">    4356 </span><span class="lineCov">     103097 :           continue;</span>
<span class="lineNum">    4357 </span>            :         }
<span class="lineNum">    4358 </span><span class="lineCov">     100294 :       else</span>
<span class="lineNum">    4359 </span><span class="lineCov">     100294 :         return;</span>
<span class="lineNum">    4360 </span>            : 
<span class="lineNum">    4361 </span>            :       /* VAROFF should always be a SSA_NAME here (and not even
<span class="lineNum">    4362 </span>            :          INTEGER_CST) but there's no point in taking chances.  */
<span class="lineNum">    4363 </span><span class="lineCov">     174310 :       if (TREE_CODE (varoff) != SSA_NAME)</span>
<span class="lineNum">    4364 </span>            :         break;
<span class="lineNum">    4365 </span><span class="lineCov">       2452 : </span>
<span class="lineNum">    4366 </span><span class="lineCov">       2452 :       vr = get_value_range (varoff);</span>
<span class="lineNum">    4367 </span><span class="lineCov">          7 :       if (!vr || vr-&gt;type == VR_UNDEFINED || !vr-&gt;min || !vr-&gt;max)</span>
<span class="lineNum">    4368 </span><span class="lineCov">        757 :         break;</span>
<span class="lineNum">    4369 </span><span class="lineCov">        750 : </span>
<span class="lineNum">    4370 </span><span class="lineCov">        379 :       if (TREE_CODE (vr-&gt;min) != INTEGER_CST</span>
<span class="lineNum">    4371 </span><span class="lineCov">       3588 :           || TREE_CODE (vr-&gt;max) != INTEGER_CST)</span>
<span class="lineNum">    4372 </span><span class="lineCov">          2 :         break;</span>
<span class="lineNum">    4373 </span>            : 
<span class="lineNum">    4374 </span>            :       if (vr-&gt;type == VR_RANGE)
<span class="lineNum">    4375 </span>            :         {
<span class="lineNum">    4376 </span>            :           if (tree_int_cst_lt (vr-&gt;min, vr-&gt;max))
<span class="lineNum">    4377 </span><span class="lineCov">     171858 :             {</span>
<span class="lineNum">    4378 </span><span class="lineCov">     171575 :               offset_int min</span>
<span class="lineNum">    4379 </span><span class="lineCov">     343359 :                 = wi::to_offset (fold_convert (ptrdiff_type_node, vr-&gt;min));</span>
<span class="lineNum">    4380 </span><span class="lineCov">     168396 :               offset_int max</span>
<span class="lineNum">    4381 </span><span class="lineCov">     165291 :                 = wi::to_offset (fold_convert (ptrdiff_type_node, vr-&gt;max));</span>
<span class="lineNum">    4382 </span>            :               if (min &lt; max)
<span class="lineNum">    4383 </span><span class="lineCov">        305 :                 {</span>
<span class="lineNum">    4384 </span>            :                   offrange[0] += min;
<span class="lineNum">    4385 </span><span class="lineNoCov">          0 :                   offrange[1] += max;</span>
<span class="lineNum">    4386 </span><span class="lineNoCov">          0 :                 }</span>
<span class="lineNum">    4387 </span><span class="lineNoCov">          0 :               else</span>
<span class="lineNum">    4388 </span>            :                 {
<span class="lineNum">    4389 </span><span class="lineCov">        305 :                   offrange[0] += max;</span>
<span class="lineNum">    4390 </span>            :                   offrange[1] += min;
<span class="lineNum">    4391 </span>            :                 }
<span class="lineNum">    4392 </span>            :             }
<span class="lineNum">    4393 </span><span class="lineCov">     171553 :           else</span>
<span class="lineNum">    4394 </span><span class="lineCov">     171553 :             {</span>
<span class="lineNum">    4395 </span>            :               /* Conservatively add [-MAXOBJSIZE -1, MAXOBJSIZE]
<span class="lineNum">    4396 </span><span class="lineCov">        224 :                  to OFFRANGE.  */</span>
<span class="lineNum">    4397 </span>            :               offrange[0] += arrbounds[0];
<span class="lineNum">    4398 </span><span class="lineNoCov">          0 :               offrange[1] += arrbounds[1];</span>
<span class="lineNum">    4399 </span><span class="lineNoCov">          0 :             }</span>
<span class="lineNum">    4400 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">    4401 </span>            :       else
<span class="lineNum">    4402 </span><span class="lineCov">        224 :         {</span>
<span class="lineNum">    4403 </span>            :           /* For an anti-range, analogously to the above, conservatively
<span class="lineNum">    4404 </span>            :              add [-MAXOBJSIZE -1, MAXOBJSIZE] to OFFRANGE.  */
<span class="lineNum">    4405 </span>            :           offrange[0] += arrbounds[0];
<span class="lineNum">    4406 </span>            :           offrange[1] += arrbounds[1];
<span class="lineNum">    4407 </span><span class="lineCov">     174310 :         }</span>
<span class="lineNum">    4408 </span>            : 
<span class="lineNum">    4409 </span><span class="lineCov">        534 :       /* Keep track of the minimum and maximum offset.  */</span>
<span class="lineNum">    4410 </span>            :       if (offrange[1] &lt; 0 &amp;&amp; offrange[1] &lt; extrema[0])
<span class="lineNum">    4411 </span><span class="lineCov">        534 :         extrema[0] = offrange[1];</span>
<span class="lineNum">    4412 </span><span class="lineCov">        171 :       if (offrange[0] &gt; 0 &amp;&amp; offrange[0] &gt; extrema[1])</span>
<span class="lineNum">    4413 </span>            :         extrema[1] = offrange[0];
<span class="lineNum">    4414 </span><span class="lineCov">        534 : </span>
<span class="lineNum">    4415 </span>            :       if (offrange[0] &lt; arrbounds[0])
<span class="lineNum">    4416 </span>            :         offrange[0] = arrbounds[0];
<span class="lineNum">    4417 </span>            : 
<span class="lineNum">    4418 </span>            :       if (offrange[1] &gt; arrbounds[1])
<span class="lineNum">    4419 </span>            :         offrange[1] = arrbounds[1];
<span class="lineNum">    4420 </span>            :     }
<span class="lineNum">    4421 </span>            : 
<span class="lineNum">    4422 </span>            :   if (TREE_CODE (arg) == ADDR_EXPR)
<span class="lineNum">    4423 </span>            :     {
<span class="lineNum">    4424 </span>            :       arg = TREE_OPERAND (arg, 0);
<span class="lineNum">    4425 </span>            :       if (TREE_CODE (arg) != STRING_CST
<span class="lineNum">    4426 </span>            :           &amp;&amp; TREE_CODE (arg) != VAR_DECL)
<span class="lineNum">    4427 </span>            :         return;
<span class="lineNum">    4428 </span><span class="lineCov">     512221 :     }</span>
<span class="lineNum">    4429 </span>            :   else
<span class="lineNum">    4430 </span>            :     return;
<span class="lineNum">    4431 </span><span class="lineCov">     512221 : </span>
<span class="lineNum">    4432 </span><span class="lineCov">     512151 :   /* The type of the object being referred to.  It can be an array,</span>
<span class="lineNum">    4433 </span>            :      string literal, or a non-array type when the MEM_REF represents
<span class="lineNum">    4434 </span><span class="lineCov">     512200 :      a reference/subscript via a pointer to an object that is not</span>
<span class="lineNum">    4435 </span>            :      an element of an array.  References to members of structs and
<span class="lineNum">    4436 </span><span class="lineCov">     512200 :      unions are excluded because MEM_REF doesn't make it possible</span>
<span class="lineNum">    4437 </span><span class="lineCov">     512200 :      to identify the member where the reference originated.</span>
<span class="lineNum">    4438 </span>            :      Incomplete types are excluded as well because their size is
<span class="lineNum">    4439 </span><span class="lineCov">     512200 :      not known.  */</span>
<span class="lineNum">    4440 </span>            :   tree reftype = TREE_TYPE (arg);
<span class="lineNum">    4441 </span>            :   if (POINTER_TYPE_P (reftype)
<span class="lineNum">    4442 </span>            :       || !COMPLETE_TYPE_P (reftype)
<span class="lineNum">    4443 </span>            :       || TREE_CODE (TYPE_SIZE_UNIT (reftype)) != INTEGER_CST
<span class="lineNum">    4444 </span><span class="lineCov">     512200 :       || RECORD_OR_UNION_TYPE_P (reftype))</span>
<span class="lineNum">    4445 </span>            :     return;
<span class="lineNum">    4446 </span>            : 
<span class="lineNum">    4447 </span>            :   offset_int eltsize;
<span class="lineNum">    4448 </span>            :   if (TREE_CODE (reftype) == ARRAY_TYPE)
<span class="lineNum">    4449 </span>            :     {
<span class="lineNum">    4450 </span>            :       eltsize = wi::to_offset (TYPE_SIZE_UNIT (TREE_TYPE (reftype)));
<span class="lineNum">    4451 </span>            : 
<span class="lineNum">    4452 </span>            :       if (tree dom = TYPE_DOMAIN (reftype))
<span class="lineNum">    4453 </span><span class="lineCov">     512200 :         {</span>
<span class="lineNum">    4454 </span><span class="lineCov">    1024400 :           tree bnds[] = { TYPE_MIN_VALUE (dom), TYPE_MAX_VALUE (dom) };</span>
<span class="lineNum">    4455 </span>            :           if (array_at_struct_end_p (arg)
<span class="lineNum">    4456 </span>            :               || !bnds[0] || !bnds[1])
<span class="lineNum">    4457 </span><span class="lineCov">    1024400 :             {</span>
<span class="lineNum">    4458 </span>            :               arrbounds[0] = 0;
<span class="lineNum">    4459 </span><span class="lineCov">     512200 :               arrbounds[1] = wi::lrshift (maxobjsize, wi::floor_log2 (eltsize));</span>
<span class="lineNum">    4460 </span>            :             }
<span class="lineNum">    4461 </span>            :           else
<span class="lineNum">    4462 </span>            :             {
<span class="lineNum">    4463 </span>            :               arrbounds[0] = wi::to_offset (bnds[0]) * eltsize;
<span class="lineNum">    4464 </span>            :               arrbounds[1] = (wi::to_offset (bnds[1]) + 1) * eltsize;
<span class="lineNum">    4465 </span><span class="lineCov">     941690 :             }</span>
<span class="lineNum">    4466 </span>            :         }
<span class="lineNum">    4467 </span><span class="lineCov">     840706 :       else</span>
<span class="lineNum">    4468 </span><span class="lineCov">    1681412 :         {</span>
<span class="lineNum">    4469 </span>            :           arrbounds[0] = 0;
<span class="lineNum">    4470 </span>            :           arrbounds[1] = wi::lrshift (maxobjsize, wi::floor_log2 (eltsize));
<span class="lineNum">    4471 </span><span class="lineCov">     544455 :         }</span>
<span class="lineNum">    4472 </span><span class="lineCov">     544455 : </span>
<span class="lineNum">    4473 </span>            :       if (TREE_CODE (ref) == MEM_REF)
<span class="lineNum">    4474 </span><span class="lineCov">      76853 :         {</span>
<span class="lineNum">    4475 </span><span class="lineCov">      76853 :           /* For MEM_REF determine a tighter bound of the non-array</span>
<span class="lineNum">    4476 </span>            :              element type.  */
<span class="lineNum">    4477 </span><span class="lineCov">     467602 :           tree eltype = TREE_TYPE (reftype);</span>
<span class="lineNum">    4478 </span>            :           while (TREE_CODE (eltype) == ARRAY_TYPE)
<span class="lineNum">    4479 </span><span class="lineCov">     709788 :             eltype = TREE_TYPE (eltype);</span>
<span class="lineNum">    4480 </span><span class="lineCov">     354894 :           eltsize = wi::to_offset (TYPE_SIZE_UNIT (eltype));</span>
<span class="lineNum">    4481 </span>            :         }
<span class="lineNum">    4482 </span>            :     }
<span class="lineNum">    4483 </span>            :   else
<span class="lineNum">    4484 </span>            :     {
<span class="lineNum">    4485 </span>            :       eltsize = 1;
<span class="lineNum">    4486 </span>            :       arrbounds[0] = 0;
<span class="lineNum">    4487 </span><span class="lineCov">      76853 :       arrbounds[1] = wi::to_offset (TYPE_SIZE_UNIT (reftype));</span>
<span class="lineNum">    4488 </span>            :     }
<span class="lineNum">    4489 </span>            : 
<span class="lineNum">    4490 </span><span class="lineCov">      76175 :   offrange[0] += ioff;</span>
<span class="lineNum">    4491 </span><span class="lineCov">      76175 :   offrange[1] += ioff;</span>
<span class="lineNum">    4492 </span>            : 
<span class="lineNum">    4493 </span>            :   /* Compute the more permissive upper bound when IGNORE_OFF_BY_ONE
<span class="lineNum">    4494 </span><span class="lineCov">      75460 :      is set (when taking the address of the one-past-last element</span>
<span class="lineNum">    4495 </span><span class="lineCov">      75342 :      of an array) but always use the stricter bound in diagnostics. */</span>
<span class="lineNum">    4496 </span>            :   offset_int ubound = arrbounds[1];
<span class="lineNum">    4497 </span>            :   if (ignore_off_by_one)
<span class="lineNum">    4498 </span><span class="lineCov">      74596 :     ubound += 1;</span>
<span class="lineNum">    4499 </span>            : 
<span class="lineNum">    4500 </span><span class="lineCov">      69054 :   if (offrange[0] &gt;= ubound || offrange[1] &lt; arrbounds[0])</span>
<span class="lineNum">    4501 </span>            :     {
<span class="lineNum">    4502 </span><span class="lineCov">      69054 :       /* Treat a reference to a non-array object as one to an array</span>
<span class="lineNum">    4503 </span><span class="lineCov">      69054 :          of a single element.  */</span>
<span class="lineNum">    4504 </span><span class="lineCov">      69054 :       if (TREE_CODE (reftype) != ARRAY_TYPE)</span>
<span class="lineNum">    4505 </span><span class="lineCov">      69054 :         reftype = build_array_type_nelts (reftype, 1);</span>
<span class="lineNum">    4506 </span><span class="lineCov">      69054 : </span>
<span class="lineNum">    4507 </span>            :       if (TREE_CODE (ref) == MEM_REF)
<span class="lineNum">    4508 </span><span class="lineCov">       3804 :         {</span>
<span class="lineNum">    4509 </span><span class="lineCov">       3804 :           /* Extract the element type out of MEM_REF and use its size</span>
<span class="lineNum">    4510 </span>            :              to compute the index to print in the diagnostic; arrays
<span class="lineNum">    4511 </span>            :              in MEM_REF don't mean anything.   */
<span class="lineNum">    4512 </span>            :           tree type = TREE_TYPE (ref);
<span class="lineNum">    4513 </span><span class="lineCov">      65250 :           while (TREE_CODE (type) == ARRAY_TYPE)</span>
<span class="lineNum">    4514 </span><span class="lineCov">      65250 :             type = TREE_TYPE (type);</span>
<span class="lineNum">    4515 </span>            :           tree size = TYPE_SIZE_UNIT (type);
<span class="lineNum">    4516 </span>            :           offrange[0] = offrange[0] / wi::to_offset (size);
<span class="lineNum">    4517 </span>            :           offrange[1] = offrange[1] / wi::to_offset (size);
<span class="lineNum">    4518 </span>            :         }
<span class="lineNum">    4519 </span>            :       else
<span class="lineNum">    4520 </span>            :         {
<span class="lineNum">    4521 </span><span class="lineNoCov">          0 :           /* For anything other than MEM_REF, compute the index to</span>
<span class="lineNum">    4522 </span><span class="lineNoCov">          0 :              print in the diagnostic as the offset over element size.  */</span>
<span class="lineNum">    4523 </span>            :           offrange[0] = offrange[0] / eltsize;
<span class="lineNum">    4524 </span>            :           offrange[1] = offrange[1] / eltsize;
<span class="lineNum">    4525 </span>            :         }
<span class="lineNum">    4526 </span>            : 
<span class="lineNum">    4527 </span>            :       bool warned;
<span class="lineNum">    4528 </span>            :       if (offrange[0] == offrange[1])
<span class="lineNum">    4529 </span><span class="lineCov">       5542 :         warned = warning_at (location, OPT_Warray_bounds,</span>
<span class="lineNum">    4530 </span><span class="lineCov">       5542 :                              &quot;array subscript %wi is outside array bounds &quot;</span>
<span class="lineNum">    4531 </span>            :                              &quot;of %qT&quot;,
<span class="lineNum">    4532 </span>            :                              offrange[0].to_shwi (), reftype);
<span class="lineNum">    4533 </span>            :       else
<span class="lineNum">    4534 </span><span class="lineCov">     149192 :         warned = warning_at (location, OPT_Warray_bounds,</span>
<span class="lineNum">    4535 </span><span class="lineCov">        108 :                              &quot;array subscript [%wi, %wi] is outside &quot;</span>
<span class="lineNum">    4536 </span><span class="lineCov">     149192 :                              &quot;array bounds of %qT&quot;,</span>
<span class="lineNum">    4537 </span><span class="lineCov">        581 :                              offrange[0].to_shwi (),</span>
<span class="lineNum">    4538 </span>            :                              offrange[1].to_shwi (), reftype);
<span class="lineNum">    4539 </span><span class="lineCov">      74596 :       if (warned &amp;&amp; DECL_P (arg))</span>
<span class="lineNum">    4540 </span><span class="lineCov">       3305 :         inform (DECL_SOURCE_LOCATION (arg), &quot;while referencing %qD&quot;, arg);</span>
<span class="lineNum">    4541 </span>            : 
<span class="lineNum">    4542 </span><span class="lineCov">      74596 :       TREE_NO_WARNING (ref) = 1;</span>
<span class="lineNum">    4543 </span><span class="lineCov">       1621 :       return;</span>
<span class="lineNum">    4544 </span>            :     }
<span class="lineNum">    4545 </span>            : 
<span class="lineNum">    4546 </span><span class="lineCov">     399492 :   if (warn_array_bounds &lt; 2)</span>
<span class="lineNum">    4547 </span>            :     return;
<span class="lineNum">    4548 </span><span class="lineCov">     100933 : </span>
<span class="lineNum">    4549 </span><span class="lineCov">     201866 :   /* At level 2 check also intermediate offsets.  */</span>
<span class="lineNum">    4550 </span><span class="lineCov">     100933 :   int i = 0;</span>
<span class="lineNum">    4551 </span>            :   if (extrema[i] &lt; -arrbounds[1] || extrema[i = 1] &gt; ubound)
<span class="lineNum">    4552 </span>            :     {
<span class="lineNum">    4553 </span>            :       HOST_WIDE_INT tmpidx = extrema[i].to_shwi () / eltsize.to_shwi ();
<span class="lineNum">    4554 </span>            : 
<span class="lineNum">    4555 </span>            :       warning_at (location, OPT_Warray_bounds,
<span class="lineNum">    4556 </span>            :                   &quot;intermediate array offset %wi is outside array bounds &quot;
<span class="lineNum">    4557 </span>            :                   &quot;of %qT&quot;,
<span class="lineNum">    4558 </span>            :                   tmpidx,  reftype);
<span class="lineNum">    4559 </span>            :       TREE_NO_WARNING (ref) = 1;
<span class="lineNum">    4560 </span>            :     }
<span class="lineNum">    4561 </span>            : }
<span class="lineNum">    4562 </span>            : 
<span class="lineNum">    4563 </span>            : /* Searches if the expr T, located at LOCATION computes
<span class="lineNum">    4564 </span><span class="lineCov">      95254 :    address of an ARRAY_REF, and call check_array_ref on it.  */</span>
<a name="4565"><span class="lineNum">    4565 </span><span class="lineCov">      95254 : </span></a>
<span class="lineNum">    4566 </span><span class="lineCov">      95231 : void</span>
<span class="lineNum">    4567 </span><span class="lineCov">     181654 : vrp_prop::search_for_addr_array (tree t, location_t location)</span>
<span class="lineNum">    4568 </span><span class="lineCov">     186081 : {</span>
<span class="lineNum">    4569 </span>            :   /* Check each ARRAY_REF and MEM_REF in the reference chain. */
<span class="lineNum">    4570 </span>            :   do
<span class="lineNum">    4571 </span><span class="lineCov">      11454 :     {</span>
<span class="lineNum">    4572 </span><span class="lineCov">      11454 :       if (TREE_CODE (t) == ARRAY_REF)</span>
<span class="lineNum">    4573 </span>            :         check_array_ref (location, t, true /*ignore_off_by_one*/);
<span class="lineNum">    4574 </span><span class="lineCov">      11202 :       else if (TREE_CODE (t) == MEM_REF)</span>
<span class="lineNum">    4575 </span>            :         check_mem_ref (location, t, true /*ignore_off_by_one*/);
<span class="lineNum">    4576 </span><span class="lineCov">      11202 : </span>
<span class="lineNum">    4577 </span>            :       t = TREE_OPERAND (t, 0);
<span class="lineNum">    4578 </span><span class="lineCov">      11202 :     }</span>
<span class="lineNum">    4579 </span><span class="lineCov">      11202 :   while (handled_component_p (t) || TREE_CODE (t) == MEM_REF);</span>
<span class="lineNum">    4580 </span><span class="lineCov">      11202 : </span>
<span class="lineNum">    4581 </span>            :   if (TREE_CODE (t) != MEM_REF
<span class="lineNum">    4582 </span><span class="lineNoCov">          0 :       || TREE_CODE (TREE_OPERAND (t, 0)) != ADDR_EXPR</span>
<span class="lineNum">    4583 </span><span class="lineNoCov">          0 :       || TREE_NO_WARNING (t))</span>
<span class="lineNum">    4584 </span>            :     return;
<span class="lineNum">    4585 </span>            : 
<span class="lineNum">    4586 </span>            :   tree tem = TREE_OPERAND (TREE_OPERAND (t, 0), 0);
<span class="lineNum">    4587 </span><span class="lineCov">      11202 :   tree low_bound, up_bound, el_sz;</span>
<span class="lineNum">    4588 </span><span class="lineCov">      11202 :   if (TREE_CODE (TREE_TYPE (tem)) != ARRAY_TYPE</span>
<span class="lineNum">    4589 </span>            :       || TREE_CODE (TREE_TYPE (TREE_TYPE (tem))) == ARRAY_TYPE
<span class="lineNum">    4590 </span>            :       || !TYPE_DOMAIN (TREE_TYPE (tem)))
<span class="lineNum">    4591 </span>            :     return;
<span class="lineNum">    4592 </span>            : 
<span class="lineNum">    4593 </span><span class="lineNoCov">          0 :   low_bound = TYPE_MIN_VALUE (TYPE_DOMAIN (TREE_TYPE (tem)));</span>
<span class="lineNum">    4594 </span><span class="lineNoCov">          0 :   up_bound = TYPE_MAX_VALUE (TYPE_DOMAIN (TREE_TYPE (tem)));</span>
<span class="lineNum">    4595 </span>            :   el_sz = TYPE_SIZE_UNIT (TREE_TYPE (TREE_TYPE (tem)));
<span class="lineNum">    4596 </span>            :   if (!low_bound
<span class="lineNum">    4597 </span><span class="lineCov">      11202 :       || TREE_CODE (low_bound) != INTEGER_CST</span>
<span class="lineNum">    4598 </span>            :       || !up_bound
<span class="lineNum">    4599 </span>            :       || TREE_CODE (up_bound) != INTEGER_CST
<span class="lineNum">    4600 </span>            :       || !el_sz
<span class="lineNum">    4601 </span><span class="lineCov">      11202 :       || TREE_CODE (el_sz) != INTEGER_CST)</span>
<span class="lineNum">    4602 </span><span class="lineCov">      11234 :     return;</span>
<span class="lineNum">    4603 </span><span class="lineCov">         32 : </span>
<span class="lineNum">    4604 </span><span class="lineCov">      11202 :   offset_int idx;</span>
<span class="lineNum">    4605 </span>            :   if (!mem_ref_offset (t).is_constant (&amp;idx))
<span class="lineNum">    4606 </span>            :     return;
<span class="lineNum">    4607 </span>            : 
<span class="lineNum">    4608 </span>            :   bool warned = false;
<span class="lineNum">    4609 </span><span class="lineCov">        252 :   idx = wi::sdiv_trunc (idx, wi::to_offset (el_sz));</span>
<span class="lineNum">    4610 </span><span class="lineCov">        252 :   if (idx &lt; 0)</span>
<span class="lineNum">    4611 </span><span class="lineCov">        252 :     {</span>
<span class="lineNum">    4612 </span>            :       if (dump_file &amp;&amp; (dump_flags &amp; TDF_DETAILS))
<span class="lineNum">    4613 </span>            :         {
<span class="lineNum">    4614 </span><span class="lineCov">      11454 :           fprintf (dump_file, &quot;Array bound warning for &quot;);</span>
<span class="lineNum">    4615 </span><span class="lineCov">      11454 :           dump_generic_expr (MSG_NOTE, TDF_SLIM, t);</span>
<span class="lineNum">    4616 </span>            :           fprintf (dump_file, &quot;\n&quot;);
<span class="lineNum">    4617 </span>            :         }
<span class="lineNum">    4618 </span>            :       warned = warning_at (location, OPT_Warray_bounds,
<span class="lineNum">    4619 </span>            :                            &quot;array subscript %wi is below &quot;
<span class="lineNum">    4620 </span><span class="lineCov">      11454 :                            &quot;array bounds of %qT&quot;,</span>
<span class="lineNum">    4621 </span><span class="lineCov">      11454 :                            idx.to_shwi (), TREE_TYPE (tem));</span>
<span class="lineNum">    4622 </span><span class="lineCov">       7520 :     }</span>
<span class="lineNum">    4623 </span>            :   else if (idx &gt; (wi::to_offset (up_bound)
<span class="lineNum">    4624 </span><span class="lineCov">      11454 :                   - wi::to_offset (low_bound) + 1))</span>
<span class="lineNum">    4625 </span>            :     {
<span class="lineNum">    4626 </span>            :       if (dump_file &amp;&amp; (dump_flags &amp; TDF_DETAILS))
<span class="lineNum">    4627 </span>            :         {
<span class="lineNum">    4628 </span><span class="lineCov">        133 :           fprintf (dump_file, &quot;Array bound warning for &quot;);</span>
<span class="lineNum">    4629 </span><span class="lineNoCov">          0 :           dump_generic_expr (MSG_NOTE, TDF_SLIM, t);</span>
<span class="lineNum">    4630 </span>            :           fprintf (dump_file, &quot;\n&quot;);
<span class="lineNum">    4631 </span><span class="lineCov">        133 :         }</span>
<span class="lineNum">    4632 </span>            :       warned = warning_at (location, OPT_Warray_bounds,
<span class="lineNum">    4633 </span>            :                            &quot;array subscript %wu is above &quot;
<span class="lineNum">    4634 </span>            :                            &quot;array bounds of %qT&quot;,
<span class="lineNum">    4635 </span>            :                            idx.to_uhwi (), TREE_TYPE (tem));
<span class="lineNum">    4636 </span><span class="lineCov">        133 :     }</span>
<span class="lineNum">    4637 </span><span class="lineCov">        177 : </span>
<span class="lineNum">    4638 </span><span class="lineCov">         44 :   if (warned)</span>
<span class="lineNum">    4639 </span><span class="lineCov">        133 :     {</span>
<span class="lineNum">    4640 </span><span class="lineCov">        133 :       if (DECL_P (t))</span>
<span class="lineNum">    4641 </span><span class="lineCov">        133 :         inform (DECL_SOURCE_LOCATION (t), &quot;while referencing %qD&quot;, t);</span>
<span class="lineNum">    4642 </span>            : 
<span class="lineNum">    4643 </span>            :       TREE_NO_WARNING (t) = 1;
<span class="lineNum">    4644 </span>            :     }
<span class="lineNum">    4645 </span>            : }
<span class="lineNum">    4646 </span>            : 
<span class="lineNum">    4647 </span><span class="lineNoCov">          0 : /* walk_tree() callback that checks if *TP is</span>
<span class="lineNum">    4648 </span><span class="lineNoCov">          0 :    an ARRAY_REF inside an ADDR_EXPR (in which an array</span>
<span class="lineNum">    4649 </span>            :    subscript one outside the valid range is allowed). Call
<span class="lineNum">    4650 </span>            :    check_array_ref for each ARRAY_REF found. The location is
<span class="lineNum">    4651 </span><span class="lineCov">        133 :    passed in DATA.  */</span>
<a name="4652"><span class="lineNum">    4652 </span><span class="lineCov">        266 : </span></a>
<span class="lineNum">    4653 </span><span class="lineCov">        194 : static tree</span>
<span class="lineNum">    4654 </span>            : check_array_bounds (tree *tp, int *walk_subtree, void *data)
<span class="lineNum">    4655 </span>            : {
<span class="lineNum">    4656 </span>            :   tree t = *tp;
<span class="lineNum">    4657 </span>            :   struct walk_stmt_info *wi = (struct walk_stmt_info *) data;
<span class="lineNum">    4658 </span><span class="lineCov">        108 :   location_t location;</span>
<span class="lineNum">    4659 </span>            : 
<span class="lineNum">    4660 </span>            :   if (EXPR_HAS_LOCATION (t))
<span class="lineNum">    4661 </span>            :     location = EXPR_LOCATION (t);
<span class="lineNum">    4662 </span>            :   else
<span class="lineNum">    4663 </span><span class="lineCov">        133 :     location = gimple_location (wi-&gt;stmt);</span>
<span class="lineNum">    4664 </span><span class="lineCov">         62 : </span>
<span class="lineNum">    4665 </span>            :   *walk_subtree = TRUE;
<span class="lineNum">    4666 </span><span class="lineCov">        133 : </span>
<span class="lineNum">    4667 </span><span class="lineCov">        133 :   vrp_prop *vrp_prop = (class vrp_prop *)wi-&gt;info;</span>
<span class="lineNum">    4668 </span>            :   if (TREE_CODE (t) == ARRAY_REF)
<span class="lineNum">    4669 </span>            :     vrp_prop-&gt;check_array_ref (location, t, false /*ignore_off_by_one*/);
<span class="lineNum">    4670 </span><span class="lineCov">      11321 :   else if (TREE_CODE (t) == MEM_REF)</span>
<span class="lineNum">    4671 </span>            :     vrp_prop-&gt;check_mem_ref (location, t, false /*ignore_off_by_one*/);
<span class="lineNum">    4672 </span>            :   else if (TREE_CODE (t) == ADDR_EXPR)
<span class="lineNum">    4673 </span>            :     {
<span class="lineNum">    4674 </span><span class="lineCov">         70 :       vrp_prop-&gt;search_for_addr_array (t, location);</span>
<span class="lineNum">    4675 </span><span class="lineCov">         70 :       *walk_subtree = FALSE;</span>
<span class="lineNum">    4676 </span>            :     }
<span class="lineNum">    4677 </span><span class="lineCov">         14 : </span>
<span class="lineNum">    4678 </span>            :   return NULL_TREE;
<span class="lineNum">    4679 </span><span class="lineCov">          7 : }</span>
<span class="lineNum">    4680 </span>            : 
<span class="lineNum">    4681 </span>            : /* A dom_walker subclass for use by vrp_prop::check_all_array_refs,
<span class="lineNum">    4682 </span>            :    to walk over all statements of all reachable BBs and call
<span class="lineNum">    4683 </span><span class="lineCov">          7 :    check_array_bounds on them.  */</span>
<span class="lineNum">    4684 </span>            : 
<span class="lineNum">    4685 </span>            : class check_array_bounds_dom_walker : public dom_walker
<span class="lineNum">    4686 </span>            : {
<span class="lineNum">    4687 </span>            :  public:
<span class="lineNum">    4688 </span>            :   check_array_bounds_dom_walker (vrp_prop *prop)
<span class="lineNum">    4689 </span>            :     : dom_walker (CDI_DOMINATORS,
<span class="lineNum">    4690 </span>            :                   /* Discover non-executable edges, preserving EDGE_EXECUTABLE
<span class="lineNum">    4691 </span><span class="lineCov">     613466 :                      flags, so that we can merge in information on</span>
<span class="lineNum">    4692 </span>            :                      non-executable edges from vrp_folder .  */
<span class="lineNum">    4693 </span>            :                   REACHABLE_BLOCKS_PRESERVING_FLAGS),
<span class="lineNum">    4694 </span><span class="lineCov">     704727 :       m_prop (prop) {}</span>
<span class="lineNum">    4695 </span>            :   ~check_array_bounds_dom_walker () {}
<span class="lineNum">    4696 </span><span class="lineCov">     704727 : </span>
<span class="lineNum">    4697 </span><span class="lineCov">       3439 :   edge before_dom_children (basic_block) FINAL OVERRIDE;</span>
<span class="lineNum">    4698 </span><span class="lineCov">     701288 : </span>
<span class="lineNum">    4699 </span><span class="lineCov">      37064 :  private:</span>
<span class="lineNum">    4700 </span>            :   vrp_prop *m_prop;
<span class="lineNum">    4701 </span><span class="lineCov">     704727 : };</span>
<span class="lineNum">    4702 </span>            : 
<span class="lineNum">    4703 </span><span class="lineCov">     704727 : /* Implementation of dom_walker::before_dom_children.</span>
<span class="lineNum">    4704 </span>            : 
<span class="lineNum">    4705 </span><span class="lineCov">     613466 :    Walk over all statements of BB and call check_array_bounds on them,</span>
<span class="lineNum">    4706 </span>            :    and determine if there's a unique successor edge.  */
<a name="4707"><span class="lineNum">    4707 </span>            : </a>
<span class="lineNum">    4708 </span><span class="lineCov">     613466 : edge</span>
<span class="lineNum">    4709 </span>            : check_array_bounds_dom_walker::before_dom_children (basic_block bb)
<span class="lineNum">    4710 </span>            : {
<span class="lineNum">    4711 </span>            :   gimple_stmt_iterator si;
<span class="lineNum">    4712 </span>            :   for (si = gsi_start_bb (bb); !gsi_end_p (si); gsi_next (&amp;si))
<span class="lineNum">    4713 </span>            :     {
<span class="lineNum">    4714 </span>            :       gimple *stmt = gsi_stmt (si);
<span class="lineNum">    4715 </span>            :       struct walk_stmt_info wi;
<span class="lineNum">    4716 </span>            :       if (!gimple_has_location (stmt)
<span class="lineNum">    4717 </span>            :           || is_gimple_debug (stmt))
<span class="lineNum">    4718 </span>            :         continue;
<span class="lineNum">    4719 </span>            : 
<span class="lineNum">    4720 </span>            :       memset (&amp;wi, 0, sizeof (wi));
<span class="lineNum">    4721 </span>            : 
<span class="lineNum">    4722 </span>            :       wi.info = m_prop;
<span class="lineNum">    4723 </span>            : 
<span class="lineNum">    4724 </span>            :       walk_gimple_op (stmt, check_array_bounds, &amp;wi);
<span class="lineNum">    4725 </span>            :     }
<span class="lineNum">    4726 </span>            : 
<span class="lineNum">    4727 </span>            :   /* Determine if there's a unique successor edge, and if so, return
<span class="lineNum">    4728 </span>            :      that back to dom_walker, ensuring that we don't visit blocks that
<span class="lineNum">    4729 </span>            :      became unreachable during the VRP propagation
<span class="lineNum">    4730 </span>            :      (PR tree-optimization/83312).  */
<span class="lineNum">    4731 </span>            :   return find_taken_edge (bb, NULL_TREE);
<span class="lineNum">    4732 </span>            : }
<span class="lineNum">    4733 </span>            : 
<span class="lineNum">    4734 </span>            : /* Walk over all statements of all reachable BBs and call check_array_bounds
<span class="lineNum">    4735 </span>            :    on them.  */
<a name="4736"><span class="lineNum">    4736 </span>            : </a>
<span class="lineNum">    4737 </span>            : void
<span class="lineNum">    4738 </span>            : vrp_prop::check_all_array_refs ()
<span class="lineNum">    4739 </span>            : {
<span class="lineNum">    4740 </span>            :   check_array_bounds_dom_walker w (this);
<span class="lineNum">    4741 </span>            :   w.walk (ENTRY_BLOCK_PTR_FOR_FN (cfun));
<span class="lineNum">    4742 </span>            : }
<span class="lineNum">    4743 </span>            : 
<span class="lineNum">    4744 </span>            : /* Return true if all imm uses of VAR are either in STMT, or
<span class="lineNum">    4745 </span>            :    feed (optionally through a chain of single imm uses) GIMPLE_COND
<span class="lineNum">    4746 </span>            :    in basic block COND_BB.  */
<a name="4747"><span class="lineNum">    4747 </span>            : </a>
<span class="lineNum">    4748 </span>            : static bool
<span class="lineNum">    4749 </span>            : all_imm_uses_in_stmt_or_feed_cond (tree var, gimple *stmt, basic_block cond_bb)
<span class="lineNum">    4750 </span>            : {
<span class="lineNum">    4751 </span>            :   use_operand_p use_p, use2_p;
<span class="lineNum">    4752 </span>            :   imm_use_iterator iter;
<span class="lineNum">    4753 </span>            : 
<span class="lineNum">    4754 </span>            :   FOR_EACH_IMM_USE_FAST (use_p, iter, var)
<span class="lineNum">    4755 </span>            :     if (USE_STMT (use_p) != stmt)
<span class="lineNum">    4756 </span>            :       {
<span class="lineNum">    4757 </span>            :         gimple *use_stmt = USE_STMT (use_p), *use_stmt2;
<span class="lineNum">    4758 </span>            :         if (is_gimple_debug (use_stmt))
<span class="lineNum">    4759 </span>            :           continue;
<span class="lineNum">    4760 </span>            :         while (is_gimple_assign (use_stmt)
<span class="lineNum">    4761 </span>            :                &amp;&amp; TREE_CODE (gimple_assign_lhs (use_stmt)) == SSA_NAME
<span class="lineNum">    4762 </span>            :                &amp;&amp; single_imm_use (gimple_assign_lhs (use_stmt),
<span class="lineNum">    4763 </span>            :                                   &amp;use2_p, &amp;use_stmt2))
<span class="lineNum">    4764 </span>            :           use_stmt = use_stmt2;
<span class="lineNum">    4765 </span>            :         if (gimple_code (use_stmt) != GIMPLE_COND
<span class="lineNum">    4766 </span>            :             || gimple_bb (use_stmt) != cond_bb)
<span class="lineNum">    4767 </span>            :           return false;
<span class="lineNum">    4768 </span>            :       }
<span class="lineNum">    4769 </span>            :   return true;
<span class="lineNum">    4770 </span>            : }
<span class="lineNum">    4771 </span>            : 
<span class="lineNum">    4772 </span>            : /* Handle
<span class="lineNum">    4773 </span>            :    _4 = x_3 &amp; 31;
<span class="lineNum">    4774 </span>            :    if (_4 != 0)
<span class="lineNum">    4775 </span>            :      goto &lt;bb 6&gt;;
<span class="lineNum">    4776 </span>            :    else
<span class="lineNum">    4777 </span>            :      goto &lt;bb 7&gt;;
<span class="lineNum">    4778 </span><span class="lineCov">    8125681 :    &lt;bb 6&gt;:</span>
<span class="lineNum">    4779 </span>            :    __builtin_unreachable ();
<span class="lineNum">    4780 </span><span class="lineCov">    8125681 :    &lt;bb 7&gt;:</span>
<span class="lineNum">    4781 </span><span class="lineCov">    8125681 :    x_5 = ASSERT_EXPR &lt;x_3, ...&gt;;</span>
<span class="lineNum">    4782 </span><span class="lineCov">    8125681 :    If x_3 has no other immediate uses (checked by caller),</span>
<span class="lineNum">    4783 </span>            :    var is the x_3 var from ASSERT_EXPR, we can clear low 5 bits
<span class="lineNum">    4784 </span><span class="lineCov">    8125681 :    from the non-zero bitmask.  */</span>
<span class="lineNum">    4785 </span><span class="lineCov">    1120834 : </span>
<span class="lineNum">    4786 </span>            : void
<span class="lineNum">    4787 </span><span class="lineCov">   14009694 : maybe_set_nonzero_bits (edge e, tree var)</span>
<span class="lineNum">    4788 </span>            : {
<span class="lineNum">    4789 </span><span class="lineCov">    8125681 :   basic_block cond_bb = e-&gt;src;</span>
<span class="lineNum">    4790 </span>            :   gimple *stmt = last_stmt (cond_bb);
<span class="lineNum">    4791 </span><span class="lineCov">    8125681 :   tree cst;</span>
<span class="lineNum">    4792 </span><span class="lineCov">    8125681 : </span>
<span class="lineNum">    4793 </span><span class="lineCov">     170923 :   if (stmt == NULL</span>
<span class="lineNum">    4794 </span><span class="lineCov">    7954758 :       || gimple_code (stmt) != GIMPLE_COND</span>
<span class="lineNum">    4795 </span><span class="lineCov">     475157 :       || gimple_cond_code (stmt) != ((e-&gt;flags &amp; EDGE_TRUE_VALUE)</span>
<span class="lineNum">    4796 </span><span class="lineCov">    7479601 :                                      ? EQ_EXPR : NE_EXPR)</span>
<span class="lineNum">    4797 </span>            :       || TREE_CODE (gimple_cond_lhs (stmt)) != SSA_NAME
<span class="lineNum">    4798 </span><span class="lineCov">     613466 :       || !integer_zerop (gimple_cond_rhs (stmt)))</span>
<span class="lineNum">    4799 </span><span class="lineCov">     613466 :     return;</span>
<span class="lineNum">    4800 </span>            : 
<span class="lineNum">    4801 </span>            :   stmt = SSA_NAME_DEF_STMT (gimple_cond_lhs (stmt));
<span class="lineNum">    4802 </span><span class="lineCov">    8125681 :   if (!is_gimple_assign (stmt)</span>
<span class="lineNum">    4803 </span>            :       || gimple_assign_rhs_code (stmt) != BIT_AND_EXPR
<span class="lineNum">    4804 </span>            :       || TREE_CODE (gimple_assign_rhs2 (stmt)) != INTEGER_CST)
<span class="lineNum">    4805 </span>            :     return;
<span class="lineNum">    4806 </span>            :   if (gimple_assign_rhs1 (stmt) != var)
<span class="lineNum">    4807 </span>            :     {
<span class="lineNum">    4808 </span>            :       gimple *stmt2;
<span class="lineNum">    4809 </span>            : 
<span class="lineNum">    4810 </span>            :       if (TREE_CODE (gimple_assign_rhs1 (stmt)) != SSA_NAME)
<span class="lineNum">    4811 </span>            :         return;
<span class="lineNum">    4812 </span>            :       stmt2 = SSA_NAME_DEF_STMT (gimple_assign_rhs1 (stmt));
<span class="lineNum">    4813 </span><span class="lineCov">      52565 :       if (!gimple_assign_cast_p (stmt2)</span>
<span class="lineNum">    4814 </span>            :           || gimple_assign_rhs1 (stmt2) != var
<span class="lineNum">    4815 </span>            :           || !CONVERT_EXPR_CODE_P (gimple_assign_rhs_code (stmt2))
<span class="lineNum">    4816 </span>            :           || (TYPE_PRECISION (TREE_TYPE (gimple_assign_rhs1 (stmt)))
<span class="lineNum">    4817 </span>            :                               != TYPE_PRECISION (TREE_TYPE (var))))
<span class="lineNum">    4818 </span><span class="lineCov">     105130 :         return;</span>
<span class="lineNum">    4819 </span><span class="lineCov">      52565 :     }</span>
<span class="lineNum">    4820 </span>            :   cst = gimple_assign_rhs2 (stmt);
<span class="lineNum">    4821 </span>            :   set_nonzero_bits (var, wi::bit_and_not (get_nonzero_bits (var),
<span class="lineNum">    4822 </span>            :                                           wi::to_wide (cst)));
<span class="lineNum">    4823 </span>            : }
<span class="lineNum">    4824 </span>            : 
<span class="lineNum">    4825 </span>            : /* Convert range assertion expressions into the implied copies and
<span class="lineNum">    4826 </span>            :    copy propagate away the copies.  Doing the trivial copy propagation
<span class="lineNum">    4827 </span>            :    here avoids the need to run the full copy propagation pass after
<span class="lineNum">    4828 </span>            :    VRP.
<span class="lineNum">    4829 </span>            : 
<span class="lineNum">    4830 </span>            :    FIXME, this will eventually lead to copy propagation removing the
<span class="lineNum">    4831 </span>            :    names that had useful range information attached to them.  For
<span class="lineNum">    4832 </span>            :    instance, if we had the assertion N_i = ASSERT_EXPR &lt;N_j, N_j &gt; 3&gt;,
<span class="lineNum">    4833 </span><span class="lineCov">     837390 :    then N_i will have the range [3, +INF].</span>
<span class="lineNum">    4834 </span>            : 
<span class="lineNum">    4835 </span><span class="lineCov">     837390 :    However, by converting the assertion into the implied copy</span>
<span class="lineNum">    4836 </span><span class="lineCov">    8785515 :    operation N_i = N_j, we will then copy-propagate N_j into the uses</span>
<span class="lineNum">    4837 </span>            :    of N_i and lose the range information.  We may want to hold on to
<span class="lineNum">    4838 </span><span class="lineCov">    7110735 :    ASSERT_EXPRs a little while longer as the ranges could be used in</span>
<span class="lineNum">    4839 </span><span class="lineCov">    7110735 :    things like jump threading.</span>
<span class="lineNum">    4840 </span><span class="lineCov">    7110735 : </span>
<span class="lineNum">    4841 </span><span class="lineCov">    7110735 :    The problem with keeping ASSERT_EXPRs around is that passes after</span>
<span class="lineNum">    4842 </span><span class="lineCov">    4748148 :    VRP need to handle them appropriately.</span>
<span class="lineNum">    4843 </span>            : 
<span class="lineNum">    4844 </span><span class="lineCov">    2362587 :    Another approach would be to make the range information a first</span>
<span class="lineNum">    4845 </span>            :    class property of the SSA_NAME so that it can be queried from
<span class="lineNum">    4846 </span><span class="lineCov">    2362587 :    any pass.  This is made somewhat more complex by the need for</span>
<span class="lineNum">    4847 </span>            :    multiple ranges to be associated with one SSA_NAME.  */
<span class="lineNum">    4848 </span><span class="lineCov">    2362587 : </span>
<span class="lineNum">    4849 </span>            : static void
<span class="lineNum">    4850 </span>            : remove_range_assertions (void)
<span class="lineNum">    4851 </span>            : {
<span class="lineNum">    4852 </span>            :   basic_block bb;
<span class="lineNum">    4853 </span>            :   gimple_stmt_iterator si;
<span class="lineNum">    4854 </span>            :   /* 1 if looking at ASSERT_EXPRs immediately at the beginning of
<span class="lineNum">    4855 </span><span class="lineCov">     837390 :      a basic block preceeded by GIMPLE_COND branching to it and</span>
<span class="lineNum">    4856 </span>            :      __builtin_trap, -1 if not yet checked, 0 otherwise.  */
<span class="lineNum">    4857 </span>            :   int is_unreachable;
<span class="lineNum">    4858 </span>            : 
<span class="lineNum">    4859 </span>            :   /* Note that the BSI iterator bump happens at the bottom of the
<span class="lineNum">    4860 </span>            :      loop and no bump is necessary if we're removing the statement
<span class="lineNum">    4861 </span>            :      referenced by the current BSI.  */
<span class="lineNum">    4862 </span><span class="lineCov">      52565 :   FOR_EACH_BB_FN (bb, cfun)</span>
<span class="lineNum">    4863 </span>            :     for (si = gsi_after_labels (bb), is_unreachable = -1; !gsi_end_p (si);)
<span class="lineNum">    4864 </span><span class="lineCov">      52565 :       {</span>
<span class="lineNum">    4865 </span><span class="lineCov">      52565 :         gimple *stmt = gsi_stmt (si);</span>
<span class="lineNum">    4866 </span><span class="lineCov">      52565 : </span>
<span class="lineNum">    4867 </span>            :         if (is_gimple_assign (stmt)
<span class="lineNum">    4868 </span>            :             &amp;&amp; gimple_assign_rhs_code (stmt) == ASSERT_EXPR)
<span class="lineNum">    4869 </span>            :           {
<span class="lineNum">    4870 </span>            :             tree lhs = gimple_assign_lhs (stmt);
<span class="lineNum">    4871 </span>            :             tree rhs = gimple_assign_rhs1 (stmt);
<span class="lineNum">    4872 </span>            :             tree var;
<span class="lineNum">    4873 </span><span class="lineCov">        448 : </span>
<span class="lineNum">    4874 </span>            :             var = ASSERT_EXPR_VAR (rhs);
<span class="lineNum">    4875 </span><span class="lineCov">        448 : </span>
<span class="lineNum">    4876 </span><span class="lineCov">        448 :             if (TREE_CODE (var) == SSA_NAME</span>
<span class="lineNum">    4877 </span>            :                 &amp;&amp; !POINTER_TYPE_P (TREE_TYPE (lhs))
<span class="lineNum">    4878 </span><span class="lineCov">       1625 :                 &amp;&amp; SSA_NAME_RANGE_INFO (lhs))</span>
<span class="lineNum">    4879 </span><span class="lineCov">       1337 :               {</span>
<span class="lineNum">    4880 </span>            :                 if (is_unreachable == -1)
<span class="lineNum">    4881 </span><span class="lineCov">        481 :                   {</span>
<span class="lineNum">    4882 </span><span class="lineCov">        962 :                     is_unreachable = 0;</span>
<span class="lineNum">    4883 </span><span class="lineCov">        112 :                     if (single_pred_p (bb)</span>
<span class="lineNum">    4884 </span><span class="lineCov">        491 :                         &amp;&amp; assert_unreachable_fallthru_edge_p</span>
<span class="lineNum">    4885 </span><span class="lineCov">        536 :                                                     (single_pred_edge (bb)))</span>
<span class="lineNum">    4886 </span><span class="lineCov">       1005 :                       is_unreachable = 1;</span>
<span class="lineNum">    4887 </span>            :                   }
<span class="lineNum">    4888 </span><span class="lineCov">        122 :                 /* Handle</span>
<span class="lineNum">    4889 </span><span class="lineCov">        369 :                    if (x_7 &gt;= 10 &amp;&amp; x_7 &lt; 20)</span>
<span class="lineNum">    4890 </span><span class="lineCov">        369 :                      __builtin_unreachable ();</span>
<span class="lineNum">    4891 </span><span class="lineCov">        160 :                    x_8 = ASSERT_EXPR &lt;x_7, ...&gt;;</span>
<span class="lineNum">    4892 </span>            :                    if the only uses of x_7 are in the ASSERT_EXPR and
<span class="lineNum">    4893 </span>            :                    in the condition.  In that case, we can copy the
<span class="lineNum">    4894 </span>            :                    range info from x_8 computed in this pass also
<span class="lineNum">    4895 </span>            :                    for x_7.  */
<span class="lineNum">    4896 </span>            :                 if (is_unreachable
<span class="lineNum">    4897 </span>            :                     &amp;&amp; all_imm_uses_in_stmt_or_feed_cond (var, stmt,
<span class="lineNum">    4898 </span>            :                                                           single_pred (bb)))
<span class="lineNum">    4899 </span>            :                   {
<span class="lineNum">    4900 </span>            :                     set_range_info (var, SSA_NAME_RANGE_TYPE (lhs),
<span class="lineNum">    4901 </span>            :                                     SSA_NAME_RANGE_INFO (lhs)-&gt;get_min (),
<span class="lineNum">    4902 </span>            :                                     SSA_NAME_RANGE_INFO (lhs)-&gt;get_max ());
<span class="lineNum">    4903 </span>            :                     maybe_set_nonzero_bits (single_pred_edge (bb), var);
<span class="lineNum">    4904 </span>            :                   }
<span class="lineNum">    4905 </span>            :               }
<span class="lineNum">    4906 </span>            : 
<span class="lineNum">    4907 </span>            :             /* Propagate the RHS into every use of the LHS.  For SSA names
<span class="lineNum">    4908 </span>            :                also propagate abnormals as it merely restores the original
<span class="lineNum">    4909 </span>            :                IL in this case (an replace_uses_by would assert).  */
<span class="lineNum">    4910 </span>            :             if (TREE_CODE (var) == SSA_NAME)
<span class="lineNum">    4911 </span><span class="lineCov">       2720 :               {</span>
<span class="lineNum">    4912 </span>            :                 imm_use_iterator iter;
<span class="lineNum">    4913 </span><span class="lineCov">       2720 :                 use_operand_p use_p;</span>
<span class="lineNum">    4914 </span><span class="lineCov">       2720 :                 gimple *use_stmt;</span>
<span class="lineNum">    4915 </span><span class="lineCov">       2720 :                 FOR_EACH_IMM_USE_STMT (use_stmt, iter, lhs)</span>
<span class="lineNum">    4916 </span>            :                   FOR_EACH_IMM_USE_ON_STMT (use_p, iter)
<span class="lineNum">    4917 </span><span class="lineCov">       2720 :                     SET_USE (use_p, var);</span>
<span class="lineNum">    4918 </span><span class="lineCov">       5440 :               }</span>
<span class="lineNum">    4919 </span><span class="lineCov">       4335 :             else</span>
<span class="lineNum">    4920 </span><span class="lineCov">       2720 :               replace_uses_by (lhs, var);</span>
<span class="lineNum">    4921 </span><span class="lineCov">       1920 : </span>
<span class="lineNum">    4922 </span><span class="lineCov">       4230 :             /* And finally, remove the copy, it is not needed.  */</span>
<span class="lineNum">    4923 </span><span class="lineCov">       2260 :             gsi_remove (&amp;si, true);</span>
<span class="lineNum">    4924 </span>            :             release_defs (stmt);
<span class="lineNum">    4925 </span><span class="lineCov">        460 :           }</span>
<span class="lineNum">    4926 </span><span class="lineCov">        460 :         else</span>
<span class="lineNum">    4927 </span><span class="lineCov">        175 :           {</span>
<span class="lineNum">    4928 </span><span class="lineCov">        498 :             if (!is_gimple_debug (gsi_stmt (si)))</span>
<span class="lineNum">    4929 </span>            :               is_unreachable = 0;
<span class="lineNum">    4930 </span><span class="lineCov">         76 :             gsi_next (&amp;si);</span>
<span class="lineNum">    4931 </span>            :           }
<span class="lineNum">    4932 </span><span class="lineCov">         24 :       }</span>
<span class="lineNum">    4933 </span>            : }
<span class="lineNum">    4934 </span><span class="lineCov">         48 : </span>
<span class="lineNum">    4935 </span>            : /* Return true if STMT is interesting for VRP.  */
<a name="4936"><span class="lineNum">    4936 </span><span class="lineCov">         48 : </span></a>
<span class="lineNum">    4937 </span><span class="lineCov">         24 : bool</span>
<span class="lineNum">    4938 </span><span class="lineCov">         20 : stmt_interesting_for_vrp (gimple *stmt)</span>
<span class="lineNum">    4939 </span><span class="lineCov">         10 : {</span>
<span class="lineNum">    4940 </span><span class="lineCov">         44 :   if (gimple_code (stmt) == GIMPLE_PHI)</span>
<span class="lineNum">    4941 </span><span class="lineCov">         10 :     {</span>
<span class="lineNum">    4942 </span>            :       tree res = gimple_phi_result (stmt);
<span class="lineNum">    4943 </span>            :       return (!virtual_operand_p (res)
<span class="lineNum">    4944 </span><span class="lineCov">         24 :               &amp;&amp; (INTEGRAL_TYPE_P (TREE_TYPE (res))</span>
<span class="lineNum">    4945 </span><span class="lineCov">         48 :                   || POINTER_TYPE_P (TREE_TYPE (res))));</span>
<span class="lineNum">    4946 </span><span class="lineCov">         48 :     }</span>
<span class="lineNum">    4947 </span>            :   else if (is_gimple_assign (stmt) || is_gimple_call (stmt))
<span class="lineNum">    4948 </span>            :     {
<span class="lineNum">    4949 </span>            :       tree lhs = gimple_get_lhs (stmt);
<span class="lineNum">    4950 </span>            : 
<span class="lineNum">    4951 </span>            :       /* In general, assignments with virtual operands are not useful
<span class="lineNum">    4952 </span>            :          for deriving ranges, with the obvious exception of calls to
<span class="lineNum">    4953 </span>            :          builtin functions.  */
<span class="lineNum">    4954 </span>            :       if (lhs &amp;&amp; TREE_CODE (lhs) == SSA_NAME
<span class="lineNum">    4955 </span>            :           &amp;&amp; (INTEGRAL_TYPE_P (TREE_TYPE (lhs))
<span class="lineNum">    4956 </span>            :               || POINTER_TYPE_P (TREE_TYPE (lhs)))
<span class="lineNum">    4957 </span>            :           &amp;&amp; (is_gimple_call (stmt)
<span class="lineNum">    4958 </span>            :               || !gimple_vuse (stmt)))
<span class="lineNum">    4959 </span>            :         return true;
<span class="lineNum">    4960 </span>            :       else if (is_gimple_call (stmt) &amp;&amp; gimple_call_internal_p (stmt))
<span class="lineNum">    4961 </span>            :         switch (gimple_call_internal_fn (stmt))
<span class="lineNum">    4962 </span>            :           {
<span class="lineNum">    4963 </span>            :           case IFN_ADD_OVERFLOW:
<span class="lineNum">    4964 </span>            :           case IFN_SUB_OVERFLOW:
<span class="lineNum">    4965 </span>            :           case IFN_MUL_OVERFLOW:
<span class="lineNum">    4966 </span>            :           case IFN_ATOMIC_COMPARE_EXCHANGE:
<span class="lineNum">    4967 </span>            :             /* These internal calls return _Complex integer type,
<span class="lineNum">    4968 </span>            :                but are interesting to VRP nevertheless.  */
<span class="lineNum">    4969 </span>            :             if (lhs &amp;&amp; TREE_CODE (lhs) == SSA_NAME)
<span class="lineNum">    4970 </span>            :               return true;
<span class="lineNum">    4971 </span>            :             break;
<span class="lineNum">    4972 </span>            :           default:
<span class="lineNum">    4973 </span>            :             break;
<span class="lineNum">    4974 </span><span class="lineCov">    1167974 :           }</span>
<span class="lineNum">    4975 </span>            :     }
<span class="lineNum">    4976 </span><span class="lineCov">    1167974 :   else if (gimple_code (stmt) == GIMPLE_COND</span>
<span class="lineNum">    4977 </span><span class="lineCov">    1167974 :            || gimple_code (stmt) == GIMPLE_SWITCH)</span>
<span class="lineNum">    4978 </span>            :     return true;
<span class="lineNum">    4979 </span>            : 
<span class="lineNum">    4980 </span>            :   return false;
<span class="lineNum">    4981 </span><span class="lineCov">    1167974 : }</span>
<span class="lineNum">    4982 </span>            : 
<span class="lineNum">    4983 </span>            : /* Initialization required by ssa_propagate engine.  */
<a name="4984"><span class="lineNum">    4984 </span>            : </a>
<span class="lineNum">    4985 </span>            : void
<span class="lineNum">    4986 </span><span class="lineCov">   13556182 : vrp_prop::vrp_initialize ()</span>
<span class="lineNum">    4987 </span><span class="lineCov">  230048604 : {</span>
<span class="lineNum">    4988 </span>            :   basic_block bb;
<span class="lineNum">    4989 </span><span class="lineCov">  102636094 : </span>
<span class="lineNum">    4990 </span>            :   FOR_EACH_BB_FN (bb, cfun)
<span class="lineNum">    4991 </span><span class="lineCov">  102636094 :     {</span>
<span class="lineNum">    4992 </span><span class="lineCov">  102636094 :       for (gphi_iterator si = gsi_start_phis (bb); !gsi_end_p (si);</span>
<span class="lineNum">    4993 </span>            :            gsi_next (&amp;si))
<span class="lineNum">    4994 </span><span class="lineCov">    4748909 :         {</span>
<span class="lineNum">    4995 </span><span class="lineCov">    4748909 :           gphi *phi = si.phi ();</span>
<span class="lineNum">    4996 </span><span class="lineCov">    4748909 :           if (!stmt_interesting_for_vrp (phi))</span>
<span class="lineNum">    4997 </span>            :             {
<span class="lineNum">    4998 </span><span class="lineCov">    4748909 :               tree lhs = PHI_RESULT (phi);</span>
<span class="lineNum">    4999 </span>            :               set_value_range_to_varying (get_value_range (lhs));
<span class="lineNum">    5000 </span><span class="lineCov">    4748909 :               prop_set_simulate_again (phi, false);</span>
<span class="lineNum">    5001 </span><span class="lineCov">    4742550 :             }</span>
<span class="lineNum">    5002 </span><span class="lineCov">    7270790 :           else</span>
<span class="lineNum">    5003 </span>            :             prop_set_simulate_again (phi, true);
<span class="lineNum">    5004 </span><span class="lineCov">    1751916 :         }</span>
<span class="lineNum">    5005 </span>            : 
<span class="lineNum">    5006 </span><span class="lineCov">    1557849 :       for (gimple_stmt_iterator si = gsi_start_bb (bb); !gsi_end_p (si);</span>
<span class="lineNum">    5007 </span><span class="lineCov">    1557849 :            gsi_next (&amp;si))</span>
<span class="lineNum">    5008 </span><span class="lineCov">    3113169 :         {</span>
<span class="lineNum">    5009 </span><span class="lineCov">    1555320 :           gimple *stmt = gsi_stmt (si);</span>
<span class="lineNum">    5010 </span>            : 
<span class="lineNum">    5011 </span>            :           /* If the statement is a control insn, then we do not
<span class="lineNum">    5012 </span>            :              want to avoid simulating the statement once.  Failure
<span class="lineNum">    5013 </span>            :              to do so means that those edges will never get added.  */
<span class="lineNum">    5014 </span>            :           if (stmt_ends_bb_p (stmt))
<span class="lineNum">    5015 </span>            :             prop_set_simulate_again (stmt, true);
<span class="lineNum">    5016 </span>            :           else if (!stmt_interesting_for_vrp (stmt))
<span class="lineNum">    5017 </span>            :             {
<span class="lineNum">    5018 </span>            :               set_defs_to_varying (stmt);
<span class="lineNum">    5019 </span>            :               prop_set_simulate_again (stmt, false);
<span class="lineNum">    5020 </span><span class="lineCov">     194067 :             }</span>
<span class="lineNum">    5021 </span><span class="lineCov">     194415 :           else</span>
<span class="lineNum">    5022 </span>            :             prop_set_simulate_again (stmt, true);
<span class="lineNum">    5023 </span>            :         }
<span class="lineNum">    5024 </span><span class="lineCov">        568 :     }</span>
<span class="lineNum">    5025 </span><span class="lineCov">        288 : }</span>
<span class="lineNum">    5026 </span><span class="lineCov">        288 : </span>
<span class="lineNum">    5027 </span><span class="lineCov">        288 : /* Searches the case label vector VEC for the index *IDX of the CASE_LABEL</span>
<span class="lineNum">    5028 </span>            :    that includes the value VAL.  The search is restricted to the range
<span class="lineNum">    5029 </span>            :    [START_IDX, n - 1] where n is the size of VEC.
<span class="lineNum">    5030 </span>            : 
<span class="lineNum">    5031 </span>            :    If there is a CASE_LABEL for VAL, its index is placed in IDX and true is
<span class="lineNum">    5032 </span>            :    returned.
<span class="lineNum">    5033 </span>            : 
<span class="lineNum">    5034 </span><span class="lineCov">    4748909 :    If there is no CASE_LABEL for VAL and there is one that is larger than VAL,</span>
<span class="lineNum">    5035 </span>            :    it is placed in IDX and false is returned.
<span class="lineNum">    5036 </span><span class="lineCov">    4742550 : </span>
<span class="lineNum">    5037 </span><span class="lineCov">    4742550 :    If VAL is larger than any CASE_LABEL, n is placed on IDX and false is</span>
<span class="lineNum">    5038 </span><span class="lineCov">    4742550 :    returned. */</span>
<a name="5039"><span class="lineNum">    5039 </span><span class="lineCov">   16111495 : </span></a>
<span class="lineNum">    5040 </span><span class="lineCov">   70520974 : bool</span>
<span class="lineNum">    5041 </span><span class="lineCov">   12522597 : find_case_label_index (gswitch *stmt, size_t start_idx, tree val, size_t *idx)</span>
<span class="lineNum">    5042 </span>            : {
<span class="lineNum">    5043 </span>            :   size_t n = gimple_switch_num_labels (stmt);
<span class="lineNum">    5044 </span><span class="lineCov">       6359 :   size_t low, high;</span>
<span class="lineNum">    5045 </span>            : 
<span class="lineNum">    5046 </span>            :   /* Find case label for minimum of the value range or the next one.
<span class="lineNum">    5047 </span><span class="lineCov">    4748909 :      At each iteration we are searching in [low, high - 1]. */</span>
<span class="lineNum">    5048 </span><span class="lineCov">    4748909 : </span>
<span class="lineNum">    5049 </span>            :   for (low = start_idx, high = n; high != low; )
<span class="lineNum">    5050 </span>            :     {
<span class="lineNum">    5051 </span>            :       tree t;
<span class="lineNum">    5052 </span><span class="lineCov">  293661555 :       int cmp;</span>
<span class="lineNum">    5053 </span><span class="lineCov">   37358278 :       /* Note that i != high, so we never ask for n. */</span>
<span class="lineNum">    5054 </span><span class="lineCov">   97887185 :       size_t i = (high + low) / 2;</span>
<span class="lineNum">    5055 </span>            :       t = gimple_switch_label (stmt, i);
<span class="lineNum">    5056 </span>            : 
<span class="lineNum">    5057 </span><span class="lineCov">    1167974 :       /* Cache the result of comparing CASE_LOW and val.  */</span>
<span class="lineNum">    5058 </span>            :       cmp = tree_int_cst_compare (CASE_LOW (t), val);
<span class="lineNum">    5059 </span>            : 
<span class="lineNum">    5060 </span>            :       if (cmp == 0)
<span class="lineNum">    5061 </span>            :         {
<span class="lineNum">    5062 </span><span class="lineCov">  461643486 :           /* Ranges cannot be empty. */</span>
<span class="lineNum">    5063 </span>            :           *idx = i;
<span class="lineNum">    5064 </span><span class="lineCov">  923286972 :           return true;</span>
<span class="lineNum">    5065 </span>            :         }
<span class="lineNum">    5066 </span><span class="lineCov">   10637762 :       else if (cmp &gt; 0)</span>
<span class="lineNum">    5067 </span><span class="lineCov">   10637762 :         high = i;</span>
<span class="lineNum">    5068 </span><span class="lineCov">   10637762 :       else</span>
<span class="lineNum">    5069 </span><span class="lineCov">    5862030 :         {</span>
<span class="lineNum">    5070 </span>            :           low = i + 1;
<span class="lineNum">    5071 </span><span class="lineCov">  902011448 :           if (CASE_HIGH (t) != NULL</span>
<span class="lineNum">    5072 </span>            :               &amp;&amp; tree_int_cst_compare (CASE_HIGH (t), val) &gt;= 0)
<span class="lineNum">    5073 </span><span class="lineCov">  225926308 :             {</span>
<span class="lineNum">    5074 </span>            :               *idx = i;
<span class="lineNum">    5075 </span>            :               return true;
<span class="lineNum">    5076 </span>            :             }
<span class="lineNum">    5077 </span>            :         }
<span class="lineNum">    5078 </span><span class="lineCov">  211063421 :     }</span>
<span class="lineNum">    5079 </span><span class="lineCov">  168838944 : </span>
<span class="lineNum">    5080 </span><span class="lineCov">  104150018 :   *idx = high;</span>
<span class="lineNum">    5081 </span><span class="lineCov">  547558386 :   return false;</span>
<span class="lineNum">    5082 </span><span class="lineCov">  293640082 : }</span>
<span class="lineNum">    5083 </span>            : 
<span class="lineNum">    5084 </span><span class="lineCov">  191001518 : /* Searches the case label vector VEC for the range of CASE_LABELs that is used</span>
<span class="lineNum">    5085 </span><span class="lineCov">     819050 :    for values between MIN and MAX. The first index is placed in MIN_IDX. The</span>
<span class="lineNum">    5086 </span>            :    last index is placed in MAX_IDX. If the range of CASE_LABELs is empty
<span class="lineNum">    5087 </span><span class="lineCov">     656544 :    then MAX_IDX &lt; MIN_IDX.</span>
<span class="lineNum">    5088 </span><span class="lineCov">     656544 :    Returns true if the default label is not needed. */</span>
<a name="5089"><span class="lineNum">    5089 </span><span class="lineCov">     656544 : </span></a>
<span class="lineNum">    5090 </span><span class="lineCov">     656544 : bool</span>
<span class="lineNum">    5091 </span>            : find_case_label_range (gswitch *stmt, tree min, tree max, size_t *min_idx,
<span class="lineNum">    5092 </span>            :                        size_t *max_idx)
<span class="lineNum">    5093 </span><span class="lineCov">     656544 : {</span>
<span class="lineNum">    5094 </span><span class="lineCov">     654162 :   size_t i, j;</span>
<span class="lineNum">    5095 </span>            :   bool min_take_default = !find_case_label_index (stmt, 1, min, &amp;i);
<span class="lineNum">    5096 </span>            :   bool max_take_default = !find_case_label_index (stmt, i, max, &amp;j);
<span class="lineNum">    5097 </span>            : 
<span class="lineNum">    5098 </span>            :   if (i == j
<span class="lineNum">    5099 </span>            :       &amp;&amp; min_take_default
<span class="lineNum">    5100 </span><span class="lineCov">  225079416 :       &amp;&amp; max_take_default)</span>
<span class="lineNum">    5101 </span><span class="lineCov">  225079416 :     {</span>
<span class="lineNum">    5102 </span><span class="lineCov">    5097357 :       /* Only the default case label reached.</span>
<span class="lineNum">    5103 </span>            :          Return an empty range. */
<span class="lineNum">    5104 </span>            :       *min_idx = 1;
<span class="lineNum">    5105 </span>            :       *max_idx = 0;
<span class="lineNum">    5106 </span>            :       return false;
<span class="lineNum">    5107 </span>            :     }
<span class="lineNum">    5108 </span>            :   else
<span class="lineNum">    5109 </span>            :     {
<span class="lineNum">    5110 </span><span class="lineCov">    1167974 :       bool take_default = min_take_default || max_take_default;</span>
<span class="lineNum">    5111 </span>            :       tree low, high;
<span class="lineNum">    5112 </span><span class="lineCov">    1167974 :       size_t k;</span>
<span class="lineNum">    5113 </span>            : 
<span class="lineNum">    5114 </span><span class="lineCov">   13556182 :       if (max_take_default)</span>
<span class="lineNum">    5115 </span>            :         j--;
<span class="lineNum">    5116 </span><span class="lineCov">   22736242 : </span>
<span class="lineNum">    5117 </span><span class="lineCov">    5174017 :       /* If the case label range is continuous, we do not need</span>
<span class="lineNum">    5118 </span>            :          the default case label.  Verify that.  */
<span class="lineNum">    5119 </span><span class="lineCov">    5174017 :       high = CASE_LOW (gimple_switch_label (stmt, i));</span>
<span class="lineNum">    5120 </span><span class="lineCov">    5174017 :       if (CASE_HIGH (gimple_switch_label (stmt, i)))</span>
<span class="lineNum">    5121 </span>            :         high = CASE_HIGH (gimple_switch_label (stmt, i));
<span class="lineNum">    5122 </span><span class="lineCov">    4555912 :       for (k = i + 1; k &lt;= j; ++k)</span>
<span class="lineNum">    5123 </span><span class="lineCov">    2277956 :         {</span>
<span class="lineNum">    5124 </span><span class="lineCov">    2277956 :           low = CASE_LOW (gimple_switch_label (stmt, k));</span>
<span class="lineNum">    5125 </span>            :           if (!integer_onep (int_const_binop (MINUS_EXPR, low, high)))
<span class="lineNum">    5126 </span>            :             {
<span class="lineNum">    5127 </span><span class="lineCov">    2896061 :               take_default = true;</span>
<span class="lineNum">    5128 </span>            :               break;
<span class="lineNum">    5129 </span>            :             }
<span class="lineNum">    5130 </span><span class="lineCov">  244552924 :           high = low;</span>
<span class="lineNum">    5131 </span><span class="lineCov">  103694150 :           if (CASE_HIGH (gimple_switch_label (stmt, k)))</span>
<span class="lineNum">    5132 </span>            :             high = CASE_HIGH (gimple_switch_label (stmt, k));
<span class="lineNum">    5133 </span><span class="lineCov">  103694150 :         }</span>
<span class="lineNum">    5134 </span>            : 
<span class="lineNum">    5135 </span>            :       *min_idx = i;
<span class="lineNum">    5136 </span>            :       *max_idx = j;
<span class="lineNum">    5137 </span>            :       return !take_default;
<span class="lineNum">    5138 </span><span class="lineCov">  103694150 :     }</span>
<span class="lineNum">    5139 </span><span class="lineCov">    7455053 : }</span>
<span class="lineNum">    5140 </span><span class="lineCov">   96239097 : </span>
<span class="lineNum">    5141 </span>            : /* Evaluate statement STMT.  If the statement produces a useful range,
<span class="lineNum">    5142 </span><span class="lineCov">   80653975 :    return SSA_PROP_INTERESTING and record the SSA name with the</span>
<span class="lineNum">    5143 </span><span class="lineCov">   80653975 :    interesting range into *OUTPUT_P.</span>
<span class="lineNum">    5144 </span>            : 
<span class="lineNum">    5145 </span>            :    If STMT is a conditional branch and we can determine its truth
<span class="lineNum">    5146 </span><span class="lineCov">   15585122 :    value, the taken edge is recorded in *TAKEN_EDGE_P.</span>
<span class="lineNum">    5147 </span>            : 
<span class="lineNum">    5148 </span>            :    If STMT produces a varying value, return SSA_PROP_VARYING.  */
<a name="5149"><span class="lineNum">    5149 </span><span class="lineCov">    1167974 : </span></a>
<span class="lineNum">    5150 </span>            : enum ssa_prop_result
<span class="lineNum">    5151 </span>            : vrp_prop::visit_stmt (gimple *stmt, edge *taken_edge_p, tree *output_p)
<span class="lineNum">    5152 </span>            : {
<span class="lineNum">    5153 </span>            :   value_range vr = VR_INITIALIZER;
<span class="lineNum">    5154 </span>            :   tree lhs = gimple_get_lhs (stmt);
<span class="lineNum">    5155 </span>            :   extract_range_from_stmt (stmt, taken_edge_p, output_p, &amp;vr);
<span class="lineNum">    5156 </span>            : 
<span class="lineNum">    5157 </span>            :   if (*output_p)
<span class="lineNum">    5158 </span>            :     {
<span class="lineNum">    5159 </span>            :       if (update_value_range (*output_p, &amp;vr))
<span class="lineNum">    5160 </span>            :         {
<span class="lineNum">    5161 </span>            :           if (dump_file &amp;&amp; (dump_flags &amp; TDF_DETAILS))
<span class="lineNum">    5162 </span>            :             {
<span class="lineNum">    5163 </span>            :               fprintf (dump_file, &quot;Found new range for &quot;);
<span class="lineNum">    5164 </span>            :               print_generic_expr (dump_file, *output_p);
<span class="lineNum">    5165 </span><span class="lineCov">      52307 :               fprintf (dump_file, &quot;: &quot;);</span>
<span class="lineNum">    5166 </span>            :               dump_value_range (dump_file, &amp;vr);
<span class="lineNum">    5167 </span><span class="lineCov">      52307 :               fprintf (dump_file, &quot;\n&quot;);</span>
<span class="lineNum">    5168 </span><span class="lineCov">      52307 :             }</span>
<span class="lineNum">    5169 </span>            : 
<span class="lineNum">    5170 </span>            :           if (vr.type == VR_VARYING)
<span class="lineNum">    5171 </span>            :             return SSA_PROP_VARYING;
<span class="lineNum">    5172 </span>            : 
<span class="lineNum">    5173 </span><span class="lineCov">     166970 :           return SSA_PROP_INTERESTING;</span>
<span class="lineNum">    5174 </span>            :         }
<span class="lineNum">    5175 </span><span class="lineCov">     131387 :       return SSA_PROP_NOT_INTERESTING;</span>
<span class="lineNum">    5176 </span><span class="lineCov">     131387 :     }</span>
<span class="lineNum">    5177 </span>            : 
<span class="lineNum">    5178 </span><span class="lineCov">     131387 :   if (is_gimple_call (stmt) &amp;&amp; gimple_call_internal_p (stmt))</span>
<span class="lineNum">    5179 </span><span class="lineCov">     131387 :     switch (gimple_call_internal_fn (stmt))</span>
<span class="lineNum">    5180 </span>            :       {
<span class="lineNum">    5181 </span>            :       case IFN_ADD_OVERFLOW:
<span class="lineNum">    5182 </span><span class="lineCov">     131387 :       case IFN_SUB_OVERFLOW:</span>
<span class="lineNum">    5183 </span>            :       case IFN_MUL_OVERFLOW:
<span class="lineNum">    5184 </span><span class="lineCov">     131387 :       case IFN_ATOMIC_COMPARE_EXCHANGE:</span>
<span class="lineNum">    5185 </span>            :         /* These internal calls return _Complex integer type,
<span class="lineNum">    5186 </span>            :            which VRP does not track, but the immediate uses
<span class="lineNum">    5187 </span><span class="lineCov">      16288 :            thereof might be interesting.  */</span>
<span class="lineNum">    5188 </span><span class="lineCov">      16288 :         if (lhs &amp;&amp; TREE_CODE (lhs) == SSA_NAME)</span>
<span class="lineNum">    5189 </span>            :           {
<span class="lineNum">    5190 </span><span class="lineCov">     115099 :             imm_use_iterator iter;</span>
<span class="lineNum">    5191 </span>            :             use_operand_p use_p;
<span class="lineNum">    5192 </span>            :             enum ssa_prop_result res = SSA_PROP_VARYING;
<span class="lineNum">    5193 </span>            : 
<span class="lineNum">    5194 </span><span class="lineCov">      40296 :             set_value_range_to_varying (get_value_range (lhs));</span>
<span class="lineNum">    5195 </span><span class="lineCov">      40296 : </span>
<span class="lineNum">    5196 </span><span class="lineCov">      40296 :             FOR_EACH_IMM_USE_FAST (use_p, iter, lhs)</span>
<span class="lineNum">    5197 </span>            :               {
<span class="lineNum">    5198 </span><span class="lineCov">        436 :                 gimple *use_stmt = USE_STMT (use_p);</span>
<span class="lineNum">    5199 </span><span class="lineCov">        436 :                 if (!is_gimple_assign (use_stmt))</span>
<span class="lineNum">    5200 </span>            :                   continue;
<span class="lineNum">    5201 </span>            :                 enum tree_code rhs_code = gimple_assign_rhs_code (use_stmt);
<span class="lineNum">    5202 </span>            :                 if (rhs_code != REALPART_EXPR &amp;&amp; rhs_code != IMAGPART_EXPR)
<span class="lineNum">    5203 </span>            :                   continue;
<span class="lineNum">    5204 </span><span class="lineCov">      35583 :                 tree rhs1 = gimple_assign_rhs1 (use_stmt);</span>
<span class="lineNum">    5205 </span><span class="lineCov">      35583 :                 tree use_lhs = gimple_assign_lhs (use_stmt);</span>
<span class="lineNum">    5206 </span>            :                 if (TREE_CODE (rhs1) != rhs_code
<span class="lineNum">    5207 </span>            :                     || TREE_OPERAND (rhs1, 0) != lhs
<span class="lineNum">    5208 </span>            :                     || TREE_CODE (use_lhs) != SSA_NAME
<span class="lineNum">    5209 </span>            :                     || !stmt_interesting_for_vrp (use_stmt)
<span class="lineNum">    5210 </span>            :                     || (!INTEGRAL_TYPE_P (TREE_TYPE (use_lhs))
<span class="lineNum">    5211 </span>            :                         || !TYPE_MIN_VALUE (TREE_TYPE (use_lhs))
<span class="lineNum">    5212 </span>            :                         || !TYPE_MAX_VALUE (TREE_TYPE (use_lhs))))
<span class="lineNum">    5213 </span>            :                   continue;
<span class="lineNum">    5214 </span>            : 
<span class="lineNum">    5215 </span><span class="lineCov">      26146 :                 /* If there is a change in the value range for any of the</span>
<span class="lineNum">    5216 </span>            :                    REALPART_EXPR/IMAGPART_EXPR immediate uses, return
<span class="lineNum">    5217 </span>            :                    SSA_PROP_INTERESTING.  If there are any REALPART_EXPR
<span class="lineNum">    5218 </span><span class="lineCov">      26146 :                    or IMAGPART_EXPR immediate uses, but none of them have</span>
<span class="lineNum">    5219 </span><span class="lineCov">      26146 :                    a change in their value ranges, return</span>
<span class="lineNum">    5220 </span><span class="lineCov">      26146 :                    SSA_PROP_NOT_INTERESTING.  If there are no</span>
<span class="lineNum">    5221 </span>            :                    {REAL,IMAG}PART_EXPR uses at all,
<span class="lineNum">    5222 </span><span class="lineCov">      26146 :                    return SSA_PROP_VARYING.  */</span>
<span class="lineNum">    5223 </span>            :                 value_range new_vr = VR_INITIALIZER;
<span class="lineNum">    5224 </span><span class="lineCov">       5436 :                 extract_range_basic (&amp;new_vr, use_stmt);</span>
<span class="lineNum">    5225 </span>            :                 const value_range *old_vr = get_value_range (use_lhs);
<span class="lineNum">    5226 </span>            :                 if (old_vr-&gt;type != new_vr.type
<span class="lineNum">    5227 </span>            :                     || !vrp_operand_equal_p (old_vr-&gt;min, new_vr.min)
<span class="lineNum">    5228 </span><span class="lineCov">       4046 :                     || !vrp_operand_equal_p (old_vr-&gt;max, new_vr.max)</span>
<span class="lineNum">    5229 </span><span class="lineCov">       4046 :                     || !vrp_bitmap_equal_p (old_vr-&gt;equiv, new_vr.equiv))</span>
<span class="lineNum">    5230 </span><span class="lineCov">       4046 :                   res = SSA_PROP_INTERESTING;</span>
<span class="lineNum">    5231 </span>            :                 else
<span class="lineNum">    5232 </span>            :                   res = SSA_PROP_NOT_INTERESTING;
<span class="lineNum">    5233 </span>            :                 BITMAP_FREE (new_vr.equiv);
<span class="lineNum">    5234 </span><span class="lineCov">      22100 :                 if (res == SSA_PROP_INTERESTING)</span>
<span class="lineNum">    5235 </span><span class="lineCov">      22100 :                   {</span>
<span class="lineNum">    5236 </span><span class="lineCov">      22100 :                     *output_p = lhs;</span>
<span class="lineNum">    5237 </span>            :                     return res;
<span class="lineNum">    5238 </span><span class="lineCov">      22100 :                   }</span>
<span class="lineNum">    5239 </span><span class="lineCov">      14436 :               }</span>
<span class="lineNum">    5240 </span>            : 
<span class="lineNum">    5241 </span>            :             return res;
<span class="lineNum">    5242 </span>            :           }
<span class="lineNum">    5243 </span><span class="lineCov">      22100 :         break;</span>
<span class="lineNum">    5244 </span><span class="lineCov">      66300 :       default:</span>
<span class="lineNum">    5245 </span><span class="lineCov">       5127 :         break;</span>
<span class="lineNum">    5246 </span><span class="lineCov">      76641 :       }</span>
<span class="lineNum">    5247 </span>            : 
<span class="lineNum">    5248 </span><span class="lineCov">      65501 :   /* All other statements produce nothing of interest for VRP, so mark</span>
<span class="lineNum">    5249 </span><span class="lineCov">      65501 :      their outputs varying and prevent further simulation.  */</span>
<span class="lineNum">    5250 </span>            :   set_defs_to_varying (stmt);
<span class="lineNum">    5251 </span>            : 
<span class="lineNum">    5252 </span>            :   return (*taken_edge_p) ? SSA_PROP_INTERESTING : SSA_PROP_VARYING;
<span class="lineNum">    5253 </span>            : }
<span class="lineNum">    5254 </span><span class="lineCov">      54541 : </span>
<span class="lineNum">    5255 </span><span class="lineCov">      54541 : /* Union the two value-ranges { *VR0TYPE, *VR0MIN, *VR0MAX } and</span>
<span class="lineNum">    5256 </span><span class="lineCov">       7560 :    { VR1TYPE, VR0MIN, VR0MAX } and store the result</span>
<span class="lineNum">    5257 </span>            :    in { *VR0TYPE, *VR0MIN, *VR0MAX }.  This may not be the smallest
<span class="lineNum">    5258 </span>            :    possible such range.  The resulting range is not canonicalized.  */
<a name="5259"><span class="lineNum">    5259 </span><span class="lineCov">      22100 : </span></a>
<span class="lineNum">    5260 </span><span class="lineCov">      22100 : static void</span>
<span class="lineNum">    5261 </span><span class="lineCov">      22100 : union_ranges (enum value_range_type *vr0type,</span>
<span class="lineNum">    5262 </span>            :               tree *vr0min, tree *vr0max,
<span class="lineNum">    5263 </span>            :               enum value_range_type vr1type,
<span class="lineNum">    5264 </span>            :               tree vr1min, tree vr1max)
<span class="lineNum">    5265 </span>            : {
<span class="lineNum">    5266 </span>            :   bool mineq = vrp_operand_equal_p (*vr0min, vr1min);
<span class="lineNum">    5267 </span>            :   bool maxeq = vrp_operand_equal_p (*vr0max, vr1max);
<span class="lineNum">    5268 </span>            : 
<span class="lineNum">    5269 </span>            :   /* [] is vr0, () is vr1 in the following classification comments.  */
<span class="lineNum">    5270 </span>            :   if (mineq &amp;&amp; maxeq)
<span class="lineNum">    5271 </span>            :     {
<span class="lineNum">    5272 </span>            :       /* [(  )] */
<span class="lineNum">    5273 </span>            :       if (*vr0type == vr1type)
<span class="lineNum">    5274 </span>            :         /* Nothing to do for equal ranges.  */
<span class="lineNum">    5275 </span><span class="lineCov">   27719152 :         ;</span>
<span class="lineNum">    5276 </span>            :       else if ((*vr0type == VR_RANGE
<span class="lineNum">    5277 </span><span class="lineCov">   27719152 :                 &amp;&amp; vr1type == VR_ANTI_RANGE)</span>
<span class="lineNum">    5278 </span><span class="lineCov">   27719152 :                || (*vr0type == VR_ANTI_RANGE</span>
<span class="lineNum">    5279 </span><span class="lineCov">   27719152 :                    &amp;&amp; vr1type == VR_RANGE))</span>
<span class="lineNum">    5280 </span>            :         {
<span class="lineNum">    5281 </span><span class="lineCov">   27719152 :           /* For anti-range with range union the result is varying.  */</span>
<span class="lineNum">    5282 </span>            :           goto give_up;
<span class="lineNum">    5283 </span><span class="lineCov">   19937495 :         }</span>
<span class="lineNum">    5284 </span>            :       else
<span class="lineNum">    5285 </span><span class="lineCov">   19069744 :         gcc_unreachable ();</span>
<span class="lineNum">    5286 </span>            :     }
<span class="lineNum">    5287 </span><span class="lineCov">        614 :   else if (operand_less_p (*vr0max, vr1min) == 1</span>
<span class="lineNum">    5288 </span><span class="lineCov">        614 :            || operand_less_p (vr1max, *vr0min) == 1)</span>
<span class="lineNum">    5289 </span><span class="lineCov">        614 :     {</span>
<span class="lineNum">    5290 </span><span class="lineCov">        614 :       /* [ ] ( ) or ( ) [ ]</span>
<span class="lineNum">    5291 </span><span class="lineCov">        614 :          If the ranges have an empty intersection, result of the union</span>
<span class="lineNum">    5292 </span>            :          operation is the anti-range or if both are anti-ranges
<span class="lineNum">    5293 </span>            :          it covers all.  */
<span class="lineNum">    5294 </span><span class="lineCov">   19069744 :       if (*vr0type == VR_ANTI_RANGE</span>
<span class="lineNum">    5295 </span>            :           &amp;&amp; vr1type == VR_ANTI_RANGE)
<span class="lineNum">    5296 </span>            :         goto give_up;
<span class="lineNum">    5297 </span><span class="lineCov">   15762594 :       else if (*vr0type == VR_ANTI_RANGE</span>
<span class="lineNum">    5298 </span>            :                &amp;&amp; vr1type == VR_RANGE)
<span class="lineNum">    5299 </span>            :         ;
<span class="lineNum">    5300 </span>            :       else if (*vr0type == VR_RANGE
<span class="lineNum">    5301 </span>            :                &amp;&amp; vr1type == VR_ANTI_RANGE)
<span class="lineNum">    5302 </span><span class="lineCov">   15563314 :         {</span>
<span class="lineNum">    5303 </span><span class="lineCov">     102992 :           *vr0type = vr1type;</span>
<span class="lineNum">    5304 </span>            :           *vr0min = vr1min;
<span class="lineNum">    5305 </span><span class="lineCov">     102992 :           *vr0max = vr1max;</span>
<span class="lineNum">    5306 </span><span class="lineCov">     102992 :         }</span>
<span class="lineNum">    5307 </span><span class="lineCov">     102992 :       else if (*vr0type == VR_RANGE</span>
<span class="lineNum">    5308 </span><span class="lineCov">     102992 :                &amp;&amp; vr1type == VR_RANGE)</span>
<span class="lineNum">    5309 </span>            :         {
<span class="lineNum">    5310 </span>            :           /* The result is the convex hull of both ranges.  */
<span class="lineNum">    5311 </span>            :           if (operand_less_p (*vr0max, vr1min) == 1)
<span class="lineNum">    5312 </span><span class="lineCov">     102992 :             {</span>
<span class="lineNum">    5313 </span>            :               /* If the result can be an anti-range, create one.  */
<span class="lineNum">    5314 </span><span class="lineCov">     102992 :               if (TREE_CODE (*vr0max) == INTEGER_CST</span>
<span class="lineNum">    5315 </span><span class="lineCov">     102992 :                   &amp;&amp; TREE_CODE (vr1min) == INTEGER_CST</span>
<span class="lineNum">    5316 </span><span class="lineCov">     102992 :                   &amp;&amp; vrp_val_is_min (*vr0min)</span>
<span class="lineNum">    5317 </span>            :                   &amp;&amp; vrp_val_is_max (vr1max))
<span class="lineNum">    5318 </span><span class="lineCov">     102992 :                 {</span>
<span class="lineNum">    5319 </span>            :                   tree min = int_const_binop (PLUS_EXPR,
<span class="lineNum">    5320 </span><span class="lineCov">     115951 :                                               *vr0max,</span>
<span class="lineNum">    5321 </span>            :                                               build_int_cst (TREE_TYPE (*vr0max), 1));
<span class="lineNum">    5322 </span><span class="lineCov">     109685 :                   tree max = int_const_binop (MINUS_EXPR,</span>
<span class="lineNum">    5323 </span><span class="lineCov">     219370 :                                               vr1min,</span>
<span class="lineNum">    5324 </span><span class="lineCov">        695 :                                               build_int_cst (TREE_TYPE (vr1min), 1));</span>
<span class="lineNum">    5325 </span><span class="lineCov">     108990 :                   if (!operand_less_p (max, min))</span>
<span class="lineNum">    5326 </span><span class="lineCov">     108990 :                     {</span>
<span class="lineNum">    5327 </span>            :                       *vr0type = VR_ANTI_RANGE;
<span class="lineNum">    5328 </span><span class="lineCov">     108990 :                       *vr0min = min;</span>
<span class="lineNum">    5329 </span><span class="lineCov">     108990 :                       *vr0max = max;</span>
<span class="lineNum">    5330 </span><span class="lineCov">     108990 :                     }</span>
<span class="lineNum">    5331 </span><span class="lineCov">     108990 :                   else</span>
<span class="lineNum">    5332 </span><span class="lineCov">     108990 :                     *vr0max = vr1max;</span>
<span class="lineNum">    5333 </span><span class="lineCov">     108990 :                 }</span>
<span class="lineNum">    5334 </span><span class="lineCov">     217980 :               else</span>
<span class="lineNum">    5335 </span><span class="lineCov">     217980 :                 *vr0max = vr1max;</span>
<span class="lineNum">    5336 </span><span class="lineCov">     217980 :             }</span>
<span class="lineNum">    5337 </span><span class="lineNoCov">          0 :           else</span>
<span class="lineNum">    5338 </span>            :             {
<span class="lineNum">    5339 </span>            :               /* If the result can be an anti-range, create one.  */
<span class="lineNum">    5340 </span>            :               if (TREE_CODE (vr1max) == INTEGER_CST
<span class="lineNum">    5341 </span>            :                   &amp;&amp; TREE_CODE (*vr0min) == INTEGER_CST
<span class="lineNum">    5342 </span>            :                   &amp;&amp; vrp_val_is_min (vr1min)
<span class="lineNum">    5343 </span>            :                   &amp;&amp; vrp_val_is_max (*vr0max))
<span class="lineNum">    5344 </span>            :                 {
<span class="lineNum">    5345 </span>            :                   tree min = int_const_binop (PLUS_EXPR,
<span class="lineNum">    5346 </span>            :                                               vr1max,
<span class="lineNum">    5347 </span><span class="lineCov">     108990 :                                               build_int_cst (TREE_TYPE (vr1max), 1));</span>
<span class="lineNum">    5348 </span><span class="lineCov">     108990 :                   tree max = int_const_binop (MINUS_EXPR,</span>
<span class="lineNum">    5349 </span><span class="lineCov">     108990 :                                               *vr0min,</span>
<span class="lineNum">    5350 </span><span class="lineCov">     108990 :                                               build_int_cst (TREE_TYPE (*vr0min), 1));</span>
<span class="lineNum">    5351 </span><span class="lineCov">      12287 :                   if (!operand_less_p (max, min))</span>
<span class="lineNum">    5352 </span><span class="lineCov">      12287 :                     {</span>
<span class="lineNum">    5353 </span><span class="lineCov">     121254 :                       *vr0type = VR_ANTI_RANGE;</span>
<span class="lineNum">    5354 </span>            :                       *vr0min = min;
<span class="lineNum">    5355 </span>            :                       *vr0max = max;
<span class="lineNum">    5356 </span>            :                     }
<span class="lineNum">    5357 </span><span class="lineCov">     108990 :                   else</span>
<span class="lineNum">    5358 </span><span class="lineCov">     108990 :                     *vr0min = vr1min;</span>
<span class="lineNum">    5359 </span>            :                 }
<span class="lineNum">    5360 </span><span class="lineCov">      96726 :               else</span>
<span class="lineNum">    5361 </span><span class="lineCov">      96726 :                 *vr0min = vr1min;</span>
<span class="lineNum">    5362 </span>            :             }
<span class="lineNum">    5363 </span>            :         }
<span class="lineNum">    5364 </span>            :       else
<span class="lineNum">    5365 </span><span class="lineCov">       6266 :         gcc_unreachable ();</span>
<span class="lineNum">    5366 </span>            :     }
<span class="lineNum">    5367 </span>            :   else if ((maxeq || operand_less_p (vr1max, *vr0max) == 1)
<span class="lineNum">    5368 </span>            :            &amp;&amp; (mineq || operand_less_p (*vr0min, vr1min) == 1))
<span class="lineNum">    5369 </span>            :     {
<span class="lineNum">    5370 </span>            :       /* [ (  ) ] or [(  ) ] or [ (  )] */
<span class="lineNum">    5371 </span>            :       if (*vr0type == VR_RANGE
<span class="lineNum">    5372 </span>            :           &amp;&amp; vr1type == VR_RANGE)
<span class="lineNum">    5373 </span>            :         ;
<span class="lineNum">    5374 </span><span class="lineCov">    7678665 :       else if (*vr0type == VR_ANTI_RANGE</span>
<span class="lineNum">    5375 </span>            :                &amp;&amp; vr1type == VR_ANTI_RANGE)
<span class="lineNum">    5376 </span><span class="lineCov">    7678665 :         {</span>
<span class="lineNum">    5377 </span>            :           *vr0type = vr1type;
<span class="lineNum">    5378 </span>            :           *vr0min = vr1min;
<span class="lineNum">    5379 </span>            :           *vr0max = vr1max;
<span class="lineNum">    5380 </span>            :         }
<span class="lineNum">    5381 </span>            :       else if (*vr0type == VR_ANTI_RANGE
<span class="lineNum">    5382 </span>            :                &amp;&amp; vr1type == VR_RANGE)
<span class="lineNum">    5383 </span>            :         {
<span class="lineNum">    5384 </span>            :           /* Arbitrarily choose the right or left gap.  */
<span class="lineNum">    5385 </span><span class="lineCov">    8079333 :           if (!mineq &amp;&amp; TREE_CODE (vr1min) == INTEGER_CST)</span>
<span class="lineNum">    5386 </span>            :             *vr0max = int_const_binop (MINUS_EXPR, vr1min,
<span class="lineNum">    5387 </span>            :                                        build_int_cst (TREE_TYPE (vr1min), 1));
<span class="lineNum">    5388 </span>            :           else if (!maxeq &amp;&amp; TREE_CODE (vr1max) == INTEGER_CST)
<span class="lineNum">    5389 </span>            :             *vr0min = int_const_binop (PLUS_EXPR, vr1max,
<span class="lineNum">    5390 </span><span class="lineCov">    8079333 :                                        build_int_cst (TREE_TYPE (vr1max), 1));</span>
<span class="lineNum">    5391 </span><span class="lineCov">    8079333 :           else</span>
<span class="lineNum">    5392 </span>            :             goto give_up;
<span class="lineNum">    5393 </span>            :         }
<span class="lineNum">    5394 </span><span class="lineCov">    8079333 :       else if (*vr0type == VR_RANGE</span>
<span class="lineNum">    5395 </span>            :                &amp;&amp; vr1type == VR_ANTI_RANGE)
<span class="lineNum">    5396 </span>            :         /* The result covers everything.  */
<span class="lineNum">    5397 </span><span class="lineCov">    1657871 :         goto give_up;</span>
<span class="lineNum">    5398 </span>            :       else
<span class="lineNum">    5399 </span>            :         gcc_unreachable ();
<span class="lineNum">    5400 </span><span class="lineCov">      72660 :     }</span>
<span class="lineNum">    5401 </span><span class="lineCov">      38158 :   else if ((maxeq || operand_less_p (*vr0max, vr1max) == 1)</span>
<span class="lineNum">    5402 </span><span class="lineCov">      34502 :            &amp;&amp; (mineq || operand_less_p (vr1min, *vr0min) == 1))</span>
<span class="lineNum">    5403 </span><span class="lineCov">      34502 :     {</span>
<span class="lineNum">    5404 </span>            :       /* ( [  ] ) or ([  ] ) or ( [  ]) */
<span class="lineNum">    5405 </span>            :       if (*vr0type == VR_RANGE
<span class="lineNum">    5406 </span>            :           &amp;&amp; vr1type == VR_RANGE)
<span class="lineNum">    5407 </span>            :         {
<span class="lineNum">    5408 </span>            :           *vr0type = vr1type;
<span class="lineNum">    5409 </span><span class="lineNoCov">          0 :           *vr0min = vr1min;</span>
<span class="lineNum">    5410 </span>            :           *vr0max = vr1max;
<span class="lineNum">    5411 </span><span class="lineCov">    6421462 :         }</span>
<span class="lineNum">    5412 </span><span class="lineCov">    6421462 :       else if (*vr0type == VR_ANTI_RANGE</span>
<span class="lineNum">    5413 </span>            :                &amp;&amp; vr1type == VR_ANTI_RANGE)
<span class="lineNum">    5414 </span>            :         ;
<span class="lineNum">    5415 </span>            :       else if (*vr0type == VR_RANGE
<span class="lineNum">    5416 </span>            :                &amp;&amp; vr1type == VR_ANTI_RANGE)
<span class="lineNum">    5417 </span>            :         {
<span class="lineNum">    5418 </span><span class="lineCov">    2183990 :           *vr0type = VR_ANTI_RANGE;</span>
<span class="lineNum">    5419 </span><span class="lineCov">      86684 :           if (!mineq &amp;&amp; TREE_CODE (*vr0min) == INTEGER_CST)</span>
<span class="lineNum">    5420 </span>            :             {
<span class="lineNum">    5421 </span><span class="lineCov">    2168686 :               *vr0max = int_const_binop (MINUS_EXPR, *vr0min,</span>
<span class="lineNum">    5422 </span><span class="lineCov">      71380 :                                          build_int_cst (TREE_TYPE (*vr0min), 1));</span>
<span class="lineNum">    5423 </span>            :               *vr0min = vr1min;
<span class="lineNum">    5424 </span><span class="lineCov">    2097306 :             }</span>
<span class="lineNum">    5425 </span><span class="lineCov">    2097306 :           else if (!maxeq &amp;&amp; TREE_CODE (*vr0max) == INTEGER_CST)</span>
<span class="lineNum">    5426 </span>            :             {
<span class="lineNum">    5427 </span><span class="lineCov">      51827 :               *vr0min = int_const_binop (PLUS_EXPR, *vr0max,</span>
<span class="lineNum">    5428 </span><span class="lineCov">      51827 :                                          build_int_cst (TREE_TYPE (*vr0max), 1));</span>
<span class="lineNum">    5429 </span><span class="lineCov">      51827 :               *vr0max = vr1max;</span>
<span class="lineNum">    5430 </span>            :             }
<span class="lineNum">    5431 </span><span class="lineCov">    2045479 :           else</span>
<span class="lineNum">    5432 </span><span class="lineCov">    2045479 :             goto give_up;</span>
<span class="lineNum">    5433 </span>            :         }
<span class="lineNum">    5434 </span>            :       else if (*vr0type == VR_ANTI_RANGE
<span class="lineNum">    5435 </span><span class="lineCov">    2045479 :                &amp;&amp; vr1type == VR_RANGE)</span>
<span class="lineNum">    5436 </span>            :         /* The result covers everything.  */
<span class="lineNum">    5437 </span>            :         goto give_up;
<span class="lineNum">    5438 </span><span class="lineCov">    1370360 :       else</span>
<span class="lineNum">    5439 </span><span class="lineCov">    1351307 :         gcc_unreachable ();</span>
<span class="lineNum">    5440 </span><span class="lineCov">    1344179 :     }</span>
<span class="lineNum">    5441 </span><span class="lineCov">    2137482 :   else if ((operand_less_p (vr1min, *vr0max) == 1</span>
<span class="lineNum">    5442 </span>            :             || operand_equal_p (vr1min, *vr0max, 0))
<span class="lineNum">    5443 </span><span class="lineCov">     115089 :            &amp;&amp; operand_less_p (*vr0min, vr1min) == 1</span>
<span class="lineNum">    5444 </span>            :            &amp;&amp; operand_less_p (*vr0max, vr1max) == 1)
<span class="lineNum">    5445 </span><span class="lineCov">     230178 :     {</span>
<span class="lineNum">    5446 </span><span class="lineCov">     115089 :       /* [  (  ]  ) or [   ](   ) */</span>
<span class="lineNum">    5447 </span>            :       if (*vr0type == VR_RANGE
<span class="lineNum">    5448 </span><span class="lineCov">     230178 :           &amp;&amp; vr1type == VR_RANGE)</span>
<span class="lineNum">    5449 </span><span class="lineCov">     115089 :         *vr0max = vr1max;</span>
<span class="lineNum">    5450 </span>            :       else if (*vr0type == VR_ANTI_RANGE
<span class="lineNum">    5451 </span><span class="lineCov">      24955 :                &amp;&amp; vr1type == VR_ANTI_RANGE)</span>
<span class="lineNum">    5452 </span><span class="lineCov">      24955 :         *vr0min = vr1min;</span>
<span class="lineNum">    5453 </span><span class="lineCov">      24955 :       else if (*vr0type == VR_ANTI_RANGE</span>
<span class="lineNum">    5454 </span>            :                &amp;&amp; vr1type == VR_RANGE)
<span class="lineNum">    5455 </span>            :         {
<span class="lineNum">    5456 </span><span class="lineCov">      90134 :           if (TREE_CODE (vr1min) == INTEGER_CST)</span>
<span class="lineNum">    5457 </span>            :             *vr0max = int_const_binop (MINUS_EXPR, vr1min,
<span class="lineNum">    5458 </span>            :                                        build_int_cst (TREE_TYPE (vr1min), 1));
<span class="lineNum">    5459 </span><span class="lineCov">    1255271 :           else</span>
<span class="lineNum">    5460 </span>            :             goto give_up;
<span class="lineNum">    5461 </span>            :         }
<span class="lineNum">    5462 </span>            :       else if (*vr0type == VR_RANGE
<span class="lineNum">    5463 </span>            :                &amp;&amp; vr1type == VR_ANTI_RANGE)
<span class="lineNum">    5464 </span><span class="lineCov">     675119 :         {</span>
<span class="lineNum">    5465 </span><span class="lineCov">     665570 :           if (TREE_CODE (*vr0max) == INTEGER_CST)</span>
<span class="lineNum">    5466 </span><span class="lineCov">     661963 :             {</span>
<span class="lineNum">    5467 </span><span class="lineCov">     823058 :               *vr0type = vr1type;</span>
<span class="lineNum">    5468 </span>            :               *vr0min = int_const_binop (PLUS_EXPR, *vr0max,
<span class="lineNum">    5469 </span><span class="lineCov">      82027 :                                          build_int_cst (TREE_TYPE (*vr0max), 1));</span>
<span class="lineNum">    5470 </span>            :               *vr0max = vr1max;
<span class="lineNum">    5471 </span><span class="lineCov">     164054 :             }</span>
<span class="lineNum">    5472 </span><span class="lineCov">      82027 :           else</span>
<span class="lineNum">    5473 </span>            :             goto give_up;
<span class="lineNum">    5474 </span><span class="lineCov">     164054 :         }</span>
<span class="lineNum">    5475 </span><span class="lineCov">      82027 :       else</span>
<span class="lineNum">    5476 </span>            :         gcc_unreachable ();
<span class="lineNum">    5477 </span><span class="lineCov">      17426 :     }</span>
<span class="lineNum">    5478 </span><span class="lineCov">      17426 :   else if ((operand_less_p (*vr0min, vr1max) == 1</span>
<span class="lineNum">    5479 </span><span class="lineCov">      17426 :             || operand_equal_p (*vr0min, vr1max, 0))</span>
<span class="lineNum">    5480 </span>            :            &amp;&amp; operand_less_p (vr1min, *vr0min) == 1
<span class="lineNum">    5481 </span>            :            &amp;&amp; operand_less_p (vr1max, *vr0max) == 1)
<span class="lineNum">    5482 </span><span class="lineCov">      64601 :     {</span>
<span class="lineNum">    5483 </span>            :       /* (  [  )  ] or (   )[   ] */
<span class="lineNum">    5484 </span>            :       if (*vr0type == VR_RANGE
<span class="lineNum">    5485 </span><span class="lineCov">     593092 :           &amp;&amp; vr1type == VR_RANGE)</span>
<span class="lineNum">    5486 </span>            :         *vr0min = vr1min;
<span class="lineNum">    5487 </span>            :       else if (*vr0type == VR_ANTI_RANGE
<span class="lineNum">    5488 </span>            :                &amp;&amp; vr1type == VR_ANTI_RANGE)
<span class="lineNum">    5489 </span><span class="lineNoCov">          0 :         *vr0max = vr1max;</span>
<span class="lineNum">    5490 </span>            :       else if (*vr0type == VR_ANTI_RANGE
<span class="lineNum">    5491 </span><span class="lineCov">    3635374 :                &amp;&amp; vr1type == VR_RANGE)</span>
<span class="lineNum">    5492 </span><span class="lineCov">    5195009 :         {</span>
<span class="lineNum">    5493 </span>            :           if (TREE_CODE (vr1max) == INTEGER_CST)
<span class="lineNum">    5494 </span>            :             *vr0min = int_const_binop (PLUS_EXPR, vr1max,
<span class="lineNum">    5495 </span><span class="lineCov">    1281126 :                                        build_int_cst (TREE_TYPE (vr1max), 1));</span>
<span class="lineNum">    5496 </span><span class="lineCov">    1173470 :           else</span>
<span class="lineNum">    5497 </span>            :             goto give_up;
<span class="lineNum">    5498 </span><span class="lineCov">     121696 :         }</span>
<span class="lineNum">    5499 </span><span class="lineCov">     107656 :       else if (*vr0type == VR_RANGE</span>
<span class="lineNum">    5500 </span>            :                &amp;&amp; vr1type == VR_ANTI_RANGE)
<span class="lineNum">    5501 </span><span class="lineCov">       3535 :         {</span>
<span class="lineNum">    5502 </span><span class="lineCov">       3535 :           if (TREE_CODE (*vr0min) == INTEGER_CST)</span>
<span class="lineNum">    5503 </span><span class="lineCov">       3535 :             {</span>
<span class="lineNum">    5504 </span>            :               *vr0type = vr1type;
<span class="lineNum">    5505 </span><span class="lineCov">     118161 :               *vr0max = int_const_binop (MINUS_EXPR, *vr0min,</span>
<span class="lineNum">    5506 </span><span class="lineCov">     104121 :                                          build_int_cst (TREE_TYPE (*vr0min), 1));</span>
<span class="lineNum">    5507 </span>            :               *vr0min = vr1min;
<span class="lineNum">    5508 </span>            :             }
<span class="lineNum">    5509 </span><span class="lineCov">     104121 :           else</span>
<span class="lineNum">    5510 </span><span class="lineCov">      95122 :             goto give_up;</span>
<span class="lineNum">    5511 </span><span class="lineCov">     285366 :         }</span>
<span class="lineNum">    5512 </span><span class="lineCov">       8999 :       else</span>
<span class="lineNum">    5513 </span><span class="lineCov">       8999 :         gcc_unreachable ();</span>
<span class="lineNum">    5514 </span><span class="lineCov">      26997 :     }</span>
<span class="lineNum">    5515 </span>            :   else
<span class="lineNum">    5516 </span>            :     goto give_up;
<span class="lineNum">    5517 </span>            : 
<span class="lineNum">    5518 </span><span class="lineCov">      14040 :   return;</span>
<span class="lineNum">    5519 </span><span class="lineCov">      14040 : </span>
<span class="lineNum">    5520 </span>            : give_up:
<span class="lineNum">    5521 </span>            :   *vr0type = VR_VARYING;
<span class="lineNum">    5522 </span>            :   *vr0min = NULL_TREE;
<span class="lineNum">    5523 </span><span class="lineNoCov">          0 :   *vr0max = NULL_TREE;</span>
<span class="lineNum">    5524 </span>            : }
<span class="lineNum">    5525 </span><span class="lineCov">    2839919 : </span>
<span class="lineNum">    5526 </span><span class="lineCov">    3538374 : /* Intersect the two value-ranges { *VR0TYPE, *VR0MIN, *VR0MAX } and</span>
<span class="lineNum">    5527 </span>            :    { VR1TYPE, VR0MIN, VR0MAX } and store the result
<span class="lineNum">    5528 </span>            :    in { *VR0TYPE, *VR0MIN, *VR0MAX }.  This may not be the smallest
<span class="lineNum">    5529 </span><span class="lineCov">     529545 :    possible such range.  The resulting range is not canonicalized.  */</span>
<span class="lineNum">    5530 </span><span class="lineCov">     517630 : </span>
<span class="lineNum">    5531 </span>            : static void
<span class="lineNum">    5532 </span><span class="lineCov">     434162 : intersect_ranges (enum value_range_type *vr0type,</span>
<span class="lineNum">    5533 </span><span class="lineCov">     434162 :                   tree *vr0min, tree *vr0max,</span>
<span class="lineNum">    5534 </span><span class="lineCov">     434162 :                   enum value_range_type vr1type,</span>
<span class="lineNum">    5535 </span>            :                   tree vr1min, tree vr1max)
<span class="lineNum">    5536 </span><span class="lineCov">      95383 : {</span>
<span class="lineNum">    5537 </span><span class="lineCov">      11915 :   bool mineq = vrp_operand_equal_p (*vr0min, vr1min);</span>
<span class="lineNum">    5538 </span>            :   bool maxeq = vrp_operand_equal_p (*vr0max, vr1max);
<span class="lineNum">    5539 </span><span class="lineCov">      92916 : </span>
<span class="lineNum">    5540 </span><span class="lineCov">      83468 :   /* [] is vr0, () is vr1 in the following classification comments.  */</span>
<span class="lineNum">    5541 </span>            :   if (mineq &amp;&amp; maxeq)
<span class="lineNum">    5542 </span><span class="lineCov">      83468 :     {</span>
<span class="lineNum">    5543 </span><span class="lineCov">      83468 :       /* [(  )] */</span>
<span class="lineNum">    5544 </span>            :       if (*vr0type == vr1type)
<span class="lineNum">    5545 </span><span class="lineCov">       7365 :         /* Nothing to do for equal ranges.  */</span>
<span class="lineNum">    5546 </span><span class="lineCov">      14730 :         ;</span>
<span class="lineNum">    5547 </span><span class="lineCov">       7365 :       else if ((*vr0type == VR_RANGE</span>
<span class="lineNum">    5548 </span>            :                 &amp;&amp; vr1type == VR_ANTI_RANGE)
<span class="lineNum">    5549 </span><span class="lineCov">      76103 :                || (*vr0type == VR_ANTI_RANGE</span>
<span class="lineNum">    5550 </span>            :                    &amp;&amp; vr1type == VR_RANGE))
<span class="lineNum">    5551 </span><span class="lineCov">      76103 :         {</span>
<span class="lineNum">    5552 </span><span class="lineCov">     152206 :           /* For anti-range with range intersection the result is empty.  */</span>
<span class="lineNum">    5553 </span><span class="lineCov">      76103 :           *vr0type = VR_UNDEFINED;</span>
<span class="lineNum">    5554 </span>            :           *vr0min = NULL_TREE;
<span class="lineNum">    5555 </span>            :           *vr0max = NULL_TREE;
<span class="lineNum">    5556 </span>            :         }
<span class="lineNum">    5557 </span>            :       else
<span class="lineNum">    5558 </span><span class="lineCov">       9448 :         gcc_unreachable ();</span>
<span class="lineNum">    5559 </span><span class="lineCov">       9448 :     }</span>
<span class="lineNum">    5560 </span>            :   else if (operand_less_p (*vr0max, vr1min) == 1
<span class="lineNum">    5561 </span>            :            || operand_less_p (vr1max, *vr0min) == 1)
<span class="lineNum">    5562 </span>            :     {
<span class="lineNum">    5563 </span><span class="lineNoCov">          0 :       /* [ ] ( ) or ( ) [ ]</span>
<span class="lineNum">    5564 </span>            :          If the ranges have an empty intersection, the result of the
<span class="lineNum">    5565 </span><span class="lineCov">    2426801 :          intersect operation is the range for intersecting an</span>
<span class="lineNum">    5566 </span><span class="lineCov">    2143908 :          anti-range with a range or empty when intersecting two ranges.  */</span>
<span class="lineNum">    5567 </span><span class="lineCov">     329935 :       if (*vr0type == VR_RANGE</span>
<span class="lineNum">    5568 </span><span class="lineCov">    2583725 :           &amp;&amp; vr1type == VR_ANTI_RANGE)</span>
<span class="lineNum">    5569 </span>            :         ;
<span class="lineNum">    5570 </span>            :       else if (*vr0type == VR_ANTI_RANGE
<span class="lineNum">    5571 </span><span class="lineCov">     156870 :                &amp;&amp; vr1type == VR_RANGE)</span>
<span class="lineNum">    5572 </span><span class="lineCov">     143677 :         {</span>
<span class="lineNum">    5573 </span><span class="lineCov">     110448 :           *vr0type = vr1type;</span>
<span class="lineNum">    5574 </span><span class="lineCov">      46422 :           *vr0min = vr1min;</span>
<span class="lineNum">    5575 </span><span class="lineCov">      13193 :           *vr0max = vr1max;</span>
<span class="lineNum">    5576 </span><span class="lineCov">       3114 :         }</span>
<span class="lineNum">    5577 </span><span class="lineCov">      43308 :       else if (*vr0type == VR_RANGE</span>
<span class="lineNum">    5578 </span><span class="lineCov">      10079 :                &amp;&amp; vr1type == VR_RANGE)</span>
<span class="lineNum">    5579 </span>            :         {
<span class="lineNum">    5580 </span><span class="lineCov">      10079 :           *vr0type = VR_UNDEFINED;</span>
<span class="lineNum">    5581 </span><span class="lineCov">      10079 :           *vr0min = NULL_TREE;</span>
<span class="lineNum">    5582 </span><span class="lineCov">      30237 :           *vr0max = NULL_TREE;</span>
<span class="lineNum">    5583 </span>            :         }
<span class="lineNum">    5584 </span>            :       else if (*vr0type == VR_ANTI_RANGE
<span class="lineNum">    5585 </span>            :                &amp;&amp; vr1type == VR_ANTI_RANGE)
<span class="lineNum">    5586 </span><span class="lineCov">      33229 :         {</span>
<span class="lineNum">    5587 </span><span class="lineCov">      33229 :           /* If the anti-ranges are adjacent to each other merge them.  */</span>
<span class="lineNum">    5588 </span>            :           if (TREE_CODE (*vr0max) == INTEGER_CST
<span class="lineNum">    5589 </span><span class="lineCov">      33229 :               &amp;&amp; TREE_CODE (vr1min) == INTEGER_CST</span>
<span class="lineNum">    5590 </span>            :               &amp;&amp; operand_less_p (*vr0max, vr1min) == 1
<span class="lineNum">    5591 </span><span class="lineCov">      33229 :               &amp;&amp; integer_onep (int_const_binop (MINUS_EXPR,</span>
<span class="lineNum">    5592 </span><span class="lineCov">      33229 :                                                 vr1min, *vr0max)))</span>
<span class="lineNum">    5593 </span><span class="lineCov">      66458 :             *vr0max = vr1max;</span>
<span class="lineNum">    5594 </span><span class="lineCov">      33229 :           else if (TREE_CODE (vr1max) == INTEGER_CST</span>
<span class="lineNum">    5595 </span>            :                    &amp;&amp; TREE_CODE (*vr0min) == INTEGER_CST
<span class="lineNum">    5596 </span>            :                    &amp;&amp; operand_less_p (vr1max, *vr0min) == 1
<span class="lineNum">    5597 </span>            :                    &amp;&amp; integer_onep (int_const_binop (MINUS_EXPR,
<span class="lineNum">    5598 </span>            :                                                      *vr0min, vr1max)))
<span class="lineNum">    5599 </span>            :             *vr0min = vr1min;
<span class="lineNum">    5600 </span><span class="lineNoCov">          0 :           /* Else arbitrarily take VR0.  */</span>
<span class="lineNum">    5601 </span>            :         }
<span class="lineNum">    5602 </span><span class="lineCov">    2269931 :     }</span>
<span class="lineNum">    5603 </span><span class="lineCov">    2136566 :   else if ((maxeq || operand_less_p (vr1max, *vr0max) == 1)</span>
<span class="lineNum">    5604 </span><span class="lineCov">     171045 :            &amp;&amp; (mineq || operand_less_p (*vr0min, vr1min) == 1))</span>
<span class="lineNum">    5605 </span><span class="lineCov">    2426823 :     {</span>
<span class="lineNum">    5606 </span>            :       /* [ (  ) ] or [(  ) ] or [ (  )] */
<span class="lineNum">    5607 </span>            :       if (*vr0type == VR_RANGE
<span class="lineNum">    5608 </span><span class="lineCov">     156837 :           &amp;&amp; vr1type == VR_RANGE)</span>
<span class="lineNum">    5609 </span><span class="lineCov">     125111 :         {</span>
<span class="lineNum">    5610 </span><span class="lineCov">     112138 :           /* If both are ranges the result is the inner one.  */</span>
<span class="lineNum">    5611 </span><span class="lineCov">      44699 :           *vr0type = vr1type;</span>
<span class="lineNum">    5612 </span><span class="lineCov">      31726 :           *vr0min = vr1min;</span>
<span class="lineNum">    5613 </span><span class="lineCov">      19053 :           *vr0max = vr1max;</span>
<span class="lineNum">    5614 </span><span class="lineCov">      25646 :         }</span>
<span class="lineNum">    5615 </span><span class="lineCov">      12673 :       else if (*vr0type == VR_RANGE</span>
<span class="lineNum">    5616 </span>            :                &amp;&amp; vr1type == VR_ANTI_RANGE)
<span class="lineNum">    5617 </span><span class="lineCov">      12673 :         {</span>
<span class="lineNum">    5618 </span><span class="lineCov">      12673 :           /* Choose the right gap if the left one is empty.  */</span>
<span class="lineNum">    5619 </span><span class="lineCov">      38019 :           if (mineq)</span>
<span class="lineNum">    5620 </span>            :             {
<span class="lineNum">    5621 </span>            :               if (TREE_CODE (vr1max) != INTEGER_CST)
<span class="lineNum">    5622 </span>            :                 *vr0min = vr1max;
<span class="lineNum">    5623 </span><span class="lineCov">      12973 :               else if (TYPE_PRECISION (TREE_TYPE (vr1max)) == 1</span>
<span class="lineNum">    5624 </span><span class="lineCov">      12973 :                        &amp;&amp; !TYPE_UNSIGNED (TREE_TYPE (vr1max)))</span>
<span class="lineNum">    5625 </span>            :                 *vr0min
<span class="lineNum">    5626 </span><span class="lineCov">      12973 :                   = int_const_binop (MINUS_EXPR, vr1max,</span>
<span class="lineNum">    5627 </span>            :                                      build_int_cst (TREE_TYPE (vr1max), -1));
<span class="lineNum">    5628 </span><span class="lineCov">      12973 :               else</span>
<span class="lineNum">    5629 </span><span class="lineCov">      12973 :                 *vr0min</span>
<span class="lineNum">    5630 </span><span class="lineCov">      25946 :                   = int_const_binop (PLUS_EXPR, vr1max,</span>
<span class="lineNum">    5631 </span><span class="lineCov">      12973 :                                      build_int_cst (TREE_TYPE (vr1max), 1));</span>
<span class="lineNum">    5632 </span>            :             }
<span class="lineNum">    5633 </span>            :           /* Choose the left gap if the right one is empty.  */
<span class="lineNum">    5634 </span>            :           else if (maxeq)
<span class="lineNum">    5635 </span>            :             {
<span class="lineNum">    5636 </span>            :               if (TREE_CODE (vr1min) != INTEGER_CST)
<span class="lineNum">    5637 </span><span class="lineNoCov">          0 :                 *vr0max = vr1min;</span>
<span class="lineNum">    5638 </span>            :               else if (TYPE_PRECISION (TREE_TYPE (vr1min)) == 1
<span class="lineNum">    5639 </span>            :                        &amp;&amp; !TYPE_UNSIGNED (TREE_TYPE (vr1min)))
<span class="lineNum">    5640 </span><span class="lineCov">    2113094 :                 *vr0max</span>
<span class="lineNum">    5641 </span>            :                   = int_const_binop (PLUS_EXPR, vr1min,
<span class="lineNum">    5642 </span>            :                                      build_int_cst (TREE_TYPE (vr1min), -1));
<span class="lineNum">    5643 </span>            :               else
<span class="lineNum">    5644 </span><span class="lineCov">    2224546 :                 *vr0max</span>
<span class="lineNum">    5645 </span><span class="lineCov">    2224546 :                   = int_const_binop (MINUS_EXPR, vr1min,</span>
<span class="lineNum">    5646 </span><span class="lineCov">    2224546 :                                      build_int_cst (TREE_TYPE (vr1min), 1));</span>
<span class="lineNum">    5647 </span><span class="lineCov">    2224546 :             }</span>
<span class="lineNum">    5648 </span>            :           /* Choose the anti-range if the range is effectively varying.  */
<span class="lineNum">    5649 </span>            :           else if (vrp_val_is_min (*vr0min)
<span class="lineNum">    5650 </span>            :                    &amp;&amp; vrp_val_is_max (*vr0max))
<span class="lineNum">    5651 </span>            :             {
<span class="lineNum">    5652 </span>            :               *vr0type = vr1type;
<span class="lineNum">    5653 </span>            :               *vr0min = vr1min;
<span class="lineNum">    5654 </span>            :               *vr0max = vr1max;
<span class="lineNum">    5655 </span>            :             }
<span class="lineNum">    5656 </span><span class="lineCov">   36191724 :           /* Else choose the range.  */</span>
<span class="lineNum">    5657 </span>            :         }
<span class="lineNum">    5658 </span>            :       else if (*vr0type == VR_ANTI_RANGE
<span class="lineNum">    5659 </span>            :                &amp;&amp; vr1type == VR_ANTI_RANGE)
<span class="lineNum">    5660 </span>            :         /* If both are anti-ranges the result is the outer one.  */
<span class="lineNum">    5661 </span><span class="lineCov">   36191724 :         ;</span>
<span class="lineNum">    5662 </span><span class="lineCov">   36191724 :       else if (*vr0type == VR_ANTI_RANGE</span>
<span class="lineNum">    5663 </span>            :                &amp;&amp; vr1type == VR_RANGE)
<span class="lineNum">    5664 </span>            :         {
<span class="lineNum">    5665 </span><span class="lineCov">   36191724 :           /* The intersection is empty.  */</span>
<span class="lineNum">    5666 </span>            :           *vr0type = VR_UNDEFINED;
<span class="lineNum">    5667 </span>            :           *vr0min = NULL_TREE;
<span class="lineNum">    5668 </span><span class="lineCov">   20545905 :           *vr0max = NULL_TREE;</span>
<span class="lineNum">    5669 </span>            :         }
<span class="lineNum">    5670 </span>            :       else
<span class="lineNum">    5671 </span><span class="lineCov">      11406 :         gcc_unreachable ();</span>
<span class="lineNum">    5672 </span><span class="lineCov">        415 :     }</span>
<span class="lineNum">    5673 </span><span class="lineCov">      10991 :   else if ((maxeq || operand_less_p (*vr0max, vr1max) == 1)</span>
<span class="lineNum">    5674 </span><span class="lineCov">      10991 :            &amp;&amp; (mineq || operand_less_p (vr1min, *vr0min) == 1))</span>
<span class="lineNum">    5675 </span>            :     {
<span class="lineNum">    5676 </span>            :       /* ( [  ] ) or ([  ] ) or ( [  ]) */
<span class="lineNum">    5677 </span><span class="lineCov">      11406 :       if (*vr0type == VR_RANGE</span>
<span class="lineNum">    5678 </span><span class="lineCov">      11406 :           &amp;&amp; vr1type == VR_RANGE)</span>
<span class="lineNum">    5679 </span><span class="lineCov">      11406 :         /* Choose the inner range.  */</span>
<span class="lineNum">    5680 </span>            :         ;
<span class="lineNum">    5681 </span>            :       else if (*vr0type == VR_ANTI_RANGE
<span class="lineNum">    5682 </span><span class="lineNoCov">          0 :                &amp;&amp; vr1type == VR_RANGE)</span>
<span class="lineNum">    5683 </span>            :         {
<span class="lineNum">    5684 </span><span class="lineCov">   15645819 :           /* Choose the right gap if the left is empty.  */</span>
<span class="lineNum">    5685 </span><span class="lineCov">   15645819 :           if (mineq)</span>
<span class="lineNum">    5686 </span>            :             {
<span class="lineNum">    5687 </span>            :               *vr0type = VR_RANGE;
<span class="lineNum">    5688 </span>            :               if (TREE_CODE (*vr0max) != INTEGER_CST)
<span class="lineNum">    5689 </span>            :                 *vr0min = *vr0max;
<span class="lineNum">    5690 </span>            :               else if (TYPE_PRECISION (TREE_TYPE (*vr0max)) == 1
<span class="lineNum">    5691 </span><span class="lineCov">    1143788 :                        &amp;&amp; !TYPE_UNSIGNED (TREE_TYPE (*vr0max)))</span>
<span class="lineNum">    5692 </span><span class="lineCov">     376513 :                 *vr0min</span>
<span class="lineNum">    5693 </span>            :                   = int_const_binop (MINUS_EXPR, *vr0max,
<span class="lineNum">    5694 </span><span class="lineCov">     771144 :                                      build_int_cst (TREE_TYPE (*vr0max), -1));</span>
<span class="lineNum">    5695 </span><span class="lineCov">     767275 :               else</span>
<span class="lineNum">    5696 </span>            :                 *vr0min
<span class="lineNum">    5697 </span><span class="lineCov">     543745 :                   = int_const_binop (PLUS_EXPR, *vr0max,</span>
<span class="lineNum">    5698 </span><span class="lineCov">     543745 :                                      build_int_cst (TREE_TYPE (*vr0max), 1));</span>
<span class="lineNum">    5699 </span><span class="lineCov">     543745 :               *vr0max = vr1max;</span>
<span class="lineNum">    5700 </span>            :             }
<span class="lineNum">    5701 </span><span class="lineCov">     227399 :           /* Choose the left gap if the right is empty.  */</span>
<span class="lineNum">    5702 </span><span class="lineCov">       3869 :           else if (maxeq)</span>
<span class="lineNum">    5703 </span>            :             {
<span class="lineNum">    5704 </span><span class="lineCov">       3869 :               *vr0type = VR_RANGE;</span>
<span class="lineNum">    5705 </span><span class="lineCov">       3869 :               if (TREE_CODE (*vr0min) != INTEGER_CST)</span>
<span class="lineNum">    5706 </span><span class="lineCov">       3869 :                 *vr0max = *vr0min;</span>
<span class="lineNum">    5707 </span>            :               else if (TYPE_PRECISION (TREE_TYPE (*vr0min)) == 1
<span class="lineNum">    5708 </span><span class="lineCov">     223530 :                        &amp;&amp; !TYPE_UNSIGNED (TREE_TYPE (*vr0min)))</span>
<span class="lineNum">    5709 </span><span class="lineCov">     223530 :                 *vr0max</span>
<span class="lineNum">    5710 </span>            :                   = int_const_binop (PLUS_EXPR, *vr0min,
<span class="lineNum">    5711 </span>            :                                      build_int_cst (TREE_TYPE (*vr0min), -1));
<span class="lineNum">    5712 </span><span class="lineCov">     223530 :               else</span>
<span class="lineNum">    5713 </span><span class="lineCov">     197053 :                 *vr0max</span>
<span class="lineNum">    5714 </span><span class="lineCov">     175748 :                   = int_const_binop (MINUS_EXPR, *vr0min,</span>
<span class="lineNum">    5715 </span><span class="lineCov">     316833 :                                      build_int_cst (TREE_TYPE (*vr0min), 1));</span>
<span class="lineNum">    5716 </span>            :               *vr0min = vr1min;
<span class="lineNum">    5717 </span><span class="lineCov">      24760 :             }</span>
<span class="lineNum">    5718 </span><span class="lineCov">     198770 :           /* Choose the anti-range if the range is effectively varying.  */</span>
<span class="lineNum">    5719 </span><span class="lineCov">     177291 :           else if (vrp_val_is_min (vr1min)</span>
<span class="lineNum">    5720 </span><span class="lineCov">     150988 :                    &amp;&amp; vrp_val_is_max (vr1max))</span>
<span class="lineNum">    5721 </span><span class="lineCov">     281215 :             ;</span>
<span class="lineNum">    5722 </span>            :           /* Choose the anti-range if it is ~[0,0], that range is special
<span class="lineNum">    5723 </span><span class="lineCov">      39294 :              enough to special case when vr1's range is relatively wide.</span>
<span class="lineNum">    5724 </span>            :              At least for types bigger than int - this covers pointers
<span class="lineNum">    5725 </span>            :              and arguments to functions like ctz.  */
<span class="lineNum">    5726 </span>            :           else if (*vr0min == *vr0max
<span class="lineNum">    5727 </span><span class="lineCov">   11929266 :                    &amp;&amp; integer_zerop (*vr0min)</span>
<span class="lineNum">    5728 </span><span class="lineCov">   16141925 :                    &amp;&amp; ((TYPE_PRECISION (TREE_TYPE (*vr0min))</span>
<span class="lineNum">    5729 </span>            :                         &gt;= TYPE_PRECISION (integer_type_node))
<span class="lineNum">    5730 </span>            :                        || POINTER_TYPE_P (TREE_TYPE (*vr0min)))
<span class="lineNum">    5731 </span><span class="lineCov">    1299716 :                    &amp;&amp; TREE_CODE (vr1max) == INTEGER_CST</span>
<span class="lineNum">    5732 </span><span class="lineCov">    1245171 :                    &amp;&amp; TREE_CODE (vr1min) == INTEGER_CST</span>
<span class="lineNum">    5733 </span>            :                    &amp;&amp; (wi::clz (wi::to_wide (vr1max) - wi::to_wide (vr1min))
<span class="lineNum">    5734 </span>            :                        &lt; TYPE_PRECISION (TREE_TYPE (*vr0min)) / 2))
<span class="lineNum">    5735 </span><span class="lineCov">    1075015 :             ;</span>
<span class="lineNum">    5736 </span><span class="lineCov">    1075015 :           /* Else choose the range.  */</span>
<span class="lineNum">    5737 </span><span class="lineCov">    1075015 :           else</span>
<span class="lineNum">    5738 </span>            :             {
<span class="lineNum">    5739 </span><span class="lineCov">     224701 :               *vr0type = vr1type;</span>
<span class="lineNum">    5740 </span><span class="lineCov">     170156 :               *vr0min = vr1min;</span>
<span class="lineNum">    5741 </span>            :               *vr0max = vr1max;
<span class="lineNum">    5742 </span>            :             }
<span class="lineNum">    5743 </span><span class="lineCov">     170156 :         }</span>
<span class="lineNum">    5744 </span>            :       else if (*vr0type == VR_ANTI_RANGE
<span class="lineNum">    5745 </span><span class="lineCov">      38050 :                &amp;&amp; vr1type == VR_ANTI_RANGE)</span>
<span class="lineNum">    5746 </span><span class="lineCov">        166 :         {</span>
<span class="lineNum">    5747 </span><span class="lineCov">      37884 :           /* If both are anti-ranges the result is the outer one.  */</span>
<span class="lineNum">    5748 </span><span class="lineCov">      37884 :           *vr0type = vr1type;</span>
<span class="lineNum">    5749 </span><span class="lineNoCov">          0 :           *vr0min = vr1min;</span>
<span class="lineNum">    5750 </span><span class="lineNoCov">          0 :           *vr0max = vr1max;</span>
<span class="lineNum">    5751 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">    5752 </span>            :       else if (vr1type == VR_ANTI_RANGE
<span class="lineNum">    5753 </span><span class="lineCov">      37884 :                &amp;&amp; *vr0type == VR_RANGE)</span>
<span class="lineNum">    5754 </span><span class="lineCov">      37884 :         {</span>
<span class="lineNum">    5755 </span><span class="lineCov">     151536 :           /* The intersection is empty.  */</span>
<span class="lineNum">    5756 </span>            :           *vr0type = VR_UNDEFINED;
<span class="lineNum">    5757 </span>            :           *vr0min = NULL_TREE;
<span class="lineNum">    5758 </span><span class="lineCov">     132106 :           *vr0max = NULL_TREE;</span>
<span class="lineNum">    5759 </span>            :         }
<span class="lineNum">    5760 </span><span class="lineCov">      49133 :       else</span>
<span class="lineNum">    5761 </span><span class="lineCov">        210 :         gcc_unreachable ();</span>
<span class="lineNum">    5762 </span><span class="lineCov">      48923 :     }</span>
<span class="lineNum">    5763 </span><span class="lineCov">      48923 :   else if ((operand_less_p (vr1min, *vr0max) == 1</span>
<span class="lineNum">    5764 </span><span class="lineNoCov">          0 :             || operand_equal_p (vr1min, *vr0max, 0))</span>
<span class="lineNum">    5765 </span><span class="lineNoCov">          0 :            &amp;&amp; operand_less_p (*vr0min, vr1min) == 1)</span>
<span class="lineNum">    5766 </span><span class="lineNoCov">          0 :     {</span>
<span class="lineNum">    5767 </span>            :       /* [  (  ]  ) or [  ](  ) */
<span class="lineNum">    5768 </span><span class="lineCov">      48923 :       if (*vr0type == VR_ANTI_RANGE</span>
<span class="lineNum">    5769 </span><span class="lineCov">      48923 :           &amp;&amp; vr1type == VR_ANTI_RANGE)</span>
<span class="lineNum">    5770 </span><span class="lineCov">     195692 :         *vr0max = vr1max;</span>
<span class="lineNum">    5771 </span>            :       else if (*vr0type == VR_RANGE
<span class="lineNum">    5772 </span>            :                &amp;&amp; vr1type == VR_RANGE)
<span class="lineNum">    5773 </span><span class="lineCov">      82973 :         *vr0min = vr1min;</span>
<span class="lineNum">    5774 </span><span class="lineCov">      82973 :       else if (*vr0type == VR_RANGE</span>
<span class="lineNum">    5775 </span>            :                &amp;&amp; vr1type == VR_ANTI_RANGE)
<span class="lineNum">    5776 </span><span class="lineCov">      25092 :         {</span>
<span class="lineNum">    5777 </span><span class="lineCov">      25092 :           if (TREE_CODE (vr1min) == INTEGER_CST)</span>
<span class="lineNum">    5778 </span><span class="lineCov">      25092 :             *vr0max = int_const_binop (MINUS_EXPR, vr1min,</span>
<span class="lineNum">    5779 </span>            :                                        build_int_cst (TREE_TYPE (vr1min), 1));
<span class="lineNum">    5780 </span>            :           else
<span class="lineNum">    5781 </span>            :             *vr0max = vr1min;
<span class="lineNum">    5782 </span><span class="lineCov">      54545 :         }</span>
<span class="lineNum">    5783 </span><span class="lineCov">      54545 :       else if (*vr0type == VR_ANTI_RANGE</span>
<span class="lineNum">    5784 </span>            :                &amp;&amp; vr1type == VR_RANGE)
<span class="lineNum">    5785 </span>            :         {
<span class="lineNum">    5786 </span><span class="lineCov">        187 :           *vr0type = VR_RANGE;</span>
<span class="lineNum">    5787 </span><span class="lineCov">        187 :           if (TREE_CODE (*vr0max) == INTEGER_CST)</span>
<span class="lineNum">    5788 </span>            :             *vr0min = int_const_binop (PLUS_EXPR, *vr0max,
<span class="lineNum">    5789 </span>            :                                        build_int_cst (TREE_TYPE (*vr0max), 1));
<span class="lineNum">    5790 </span><span class="lineCov">        187 :           else</span>
<span class="lineNum">    5791 </span><span class="lineCov">        187 :             *vr0min = *vr0max;</span>
<span class="lineNum">    5792 </span><span class="lineCov">        187 :           *vr0max = vr1max;</span>
<span class="lineNum">    5793 </span>            :         }
<span class="lineNum">    5794 </span>            :       else
<span class="lineNum">    5795 </span><span class="lineNoCov">          0 :         gcc_unreachable ();</span>
<span class="lineNum">    5796 </span>            :     }
<span class="lineNum">    5797 </span><span class="lineCov">   10905827 :   else if ((operand_less_p (*vr0min, vr1max) == 1</span>
<span class="lineNum">    5798 </span><span class="lineCov">   20268104 :             || operand_equal_p (*vr0min, vr1max, 0))</span>
<span class="lineNum">    5799 </span>            :            &amp;&amp; operand_less_p (vr1min, *vr0min) == 1)
<span class="lineNum">    5800 </span>            :     {
<span class="lineNum">    5801 </span><span class="lineCov">    8545682 :       /* (  [  )  ] or (  )[  ] */</span>
<span class="lineNum">    5802 </span><span class="lineCov">    7089166 :       if (*vr0type == VR_ANTI_RANGE</span>
<span class="lineNum">    5803 </span>            :           &amp;&amp; vr1type == VR_ANTI_RANGE)
<span class="lineNum">    5804 </span>            :         *vr0min = vr1min;
<span class="lineNum">    5805 </span><span class="lineCov">    1456570 :       else if (*vr0type == VR_RANGE</span>
<span class="lineNum">    5806 </span><span class="lineCov">    1456516 :                &amp;&amp; vr1type == VR_RANGE)</span>
<span class="lineNum">    5807 </span>            :         *vr0max = vr1max;
<span class="lineNum">    5808 </span>            :       else if (*vr0type == VR_RANGE
<span class="lineNum">    5809 </span><span class="lineCov">    1437657 :                &amp;&amp; vr1type == VR_ANTI_RANGE)</span>
<span class="lineNum">    5810 </span>            :         {
<span class="lineNum">    5811 </span><span class="lineCov">     635788 :           if (TREE_CODE (vr1max) == INTEGER_CST)</span>
<span class="lineNum">    5812 </span><span class="lineCov">     635788 :             *vr0min = int_const_binop (PLUS_EXPR, vr1max,</span>
<span class="lineNum">    5813 </span><span class="lineCov">        346 :                                        build_int_cst (TREE_TYPE (vr1max), 1));</span>
<span class="lineNum">    5814 </span><span class="lineCov">     635442 :           else</span>
<span class="lineNum">    5815 </span><span class="lineCov">     635442 :             *vr0min = vr1max;</span>
<span class="lineNum">    5816 </span><span class="lineNoCov">          0 :         }</span>
<span class="lineNum">    5817 </span><span class="lineNoCov">          0 :       else if (*vr0type == VR_ANTI_RANGE</span>
<span class="lineNum">    5818 </span><span class="lineNoCov">          0 :                &amp;&amp; vr1type == VR_RANGE)</span>
<span class="lineNum">    5819 </span>            :         {
<span class="lineNum">    5820 </span><span class="lineCov">     635442 :           *vr0type = VR_RANGE;</span>
<span class="lineNum">    5821 </span><span class="lineCov">     635442 :           if (TREE_CODE (*vr0min) == INTEGER_CST)</span>
<span class="lineNum">    5822 </span><span class="lineCov">    2541768 :             *vr0max = int_const_binop (MINUS_EXPR, *vr0min,</span>
<span class="lineNum">    5823 </span><span class="lineCov">     635788 :                                        build_int_cst (TREE_TYPE (*vr0min), 1));</span>
<span class="lineNum">    5824 </span>            :           else
<span class="lineNum">    5825 </span>            :             *vr0max = *vr0min;
<span class="lineNum">    5826 </span><span class="lineCov">     801869 :           *vr0min = vr1min;</span>
<span class="lineNum">    5827 </span>            :         }
<span class="lineNum">    5828 </span><span class="lineCov">     377597 :       else</span>
<span class="lineNum">    5829 </span><span class="lineCov">     377597 :         gcc_unreachable ();</span>
<span class="lineNum">    5830 </span><span class="lineCov">         15 :     }</span>
<span class="lineNum">    5831 </span><span class="lineCov">     377582 : </span>
<span class="lineNum">    5832 </span><span class="lineCov">     377582 :   /* As a fallback simply use { *VRTYPE, *VR0MIN, *VR0MAX } as</span>
<span class="lineNum">    5833 </span><span class="lineNoCov">          0 :      result for the intersection.  That's always a conservative</span>
<span class="lineNum">    5834 </span><span class="lineNoCov">          0 :      correct estimate unless VR1 is a constant singleton range</span>
<span class="lineNum">    5835 </span><span class="lineNoCov">          0 :      in which case we choose that.  */</span>
<span class="lineNum">    5836 </span>            :   if (vr1type == VR_RANGE
<span class="lineNum">    5837 </span><span class="lineCov">     377582 :       &amp;&amp; is_gimple_min_invariant (vr1min)</span>
<span class="lineNum">    5838 </span><span class="lineCov">     377582 :       &amp;&amp; vrp_operand_equal_p (vr1min, vr1max))</span>
<span class="lineNum">    5839 </span><span class="lineCov">    1510328 :     {</span>
<span class="lineNum">    5840 </span><span class="lineCov">     377597 :       *vr0type = vr1type;</span>
<span class="lineNum">    5841 </span>            :       *vr0min = vr1min;
<span class="lineNum">    5842 </span>            :       *vr0max = vr1max;
<span class="lineNum">    5843 </span><span class="lineCov">     424272 :     }</span>
<span class="lineNum">    5844 </span><span class="lineCov">     424272 : </span>
<span class="lineNum">    5845 </span>            :   return;
<span class="lineNum">    5846 </span>            : }
<span class="lineNum">    5847 </span>            : 
<span class="lineNum">    5848 </span>            : 
<span class="lineNum">    5849 </span>            : /* Intersect the two value-ranges *VR0 and *VR1 and store the result
<span class="lineNum">    5850 </span><span class="lineCov">     266827 :    in *VR0.  This may not be the smallest possible such range.  */</span>
<a name="5851"><span class="lineNum">    5851 </span><span class="lineCov">     230476 : </span></a>
<span class="lineNum">    5852 </span><span class="lineCov">      33918 : static void</span>
<span class="lineNum">    5853 </span><span class="lineCov">      33918 : vrp_intersect_ranges_1 (value_range *vr0, const value_range *vr1)</span>
<span class="lineNum">    5854 </span><span class="lineCov">       1280 : {</span>
<span class="lineNum">    5855 </span><span class="lineCov">      33278 :   value_range saved;</span>
<span class="lineNum">    5856 </span><span class="lineCov">      33278 : </span>
<span class="lineNum">    5857 </span><span class="lineCov">     320943 :   /* If either range is VR_VARYING the other one wins.  */</span>
<span class="lineNum">    5858 </span><span class="lineCov">      33278 :   if (vr1-&gt;type == VR_VARYING)</span>
<span class="lineNum">    5859 </span>            :     return;
<span class="lineNum">    5860 </span>            :   if (vr0-&gt;type == VR_VARYING)
<span class="lineNum">    5861 </span>            :     {
<span class="lineNum">    5862 </span>            :       copy_value_range (vr0, vr1);
<span class="lineNum">    5863 </span><span class="lineCov">     245989 :       return;</span>
<span class="lineNum">    5864 </span><span class="lineCov">     245989 :     }</span>
<span class="lineNum">    5865 </span><span class="lineCov">     245989 : </span>
<span class="lineNum">    5866 </span>            :   /* When either range is VR_UNDEFINED the resulting range is
<span class="lineNum">    5867 </span>            :      VR_UNDEFINED, too.  */
<span class="lineNum">    5868 </span><span class="lineCov">      18913 :   if (vr0-&gt;type == VR_UNDEFINED)</span>
<span class="lineNum">    5869 </span><span class="lineCov">      18859 :     return;</span>
<span class="lineNum">    5870 </span>            :   if (vr1-&gt;type == VR_UNDEFINED)
<span class="lineNum">    5871 </span>            :     {
<span class="lineNum">    5872 </span><span class="lineCov">      18859 :       set_value_range_to_undefined (vr0);</span>
<span class="lineNum">    5873 </span><span class="lineCov">      18859 :       return;</span>
<span class="lineNum">    5874 </span><span class="lineCov">      18859 :     }</span>
<span class="lineNum">    5875 </span>            : 
<span class="lineNum">    5876 </span><span class="lineCov">         54 :   /* Save the original vr0 so we can return it as conservative intersection</span>
<span class="lineNum">    5877 </span><span class="lineCov">         54 :      result when our worker turns things to varying.  */</span>
<span class="lineNum">    5878 </span>            :   saved = *vr0;
<span class="lineNum">    5879 </span>            :   intersect_ranges (&amp;vr0-&gt;type, &amp;vr0-&gt;min, &amp;vr0-&gt;max,
<span class="lineNum">    5880 </span><span class="lineCov">         54 :                     vr1-&gt;type, vr1-&gt;min, vr1-&gt;max);</span>
<span class="lineNum">    5881 </span><span class="lineCov">         54 :   /* Make sure to canonicalize the result though as the inversion of a</span>
<span class="lineNum">    5882 </span><span class="lineCov">         54 :      VR_RANGE can still be a VR_RANGE.  */</span>
<span class="lineNum">    5883 </span>            :   set_and_canonicalize_value_range (vr0, vr0-&gt;type,
<span class="lineNum">    5884 </span>            :                                     vr0-&gt;min, vr0-&gt;max, vr0-&gt;equiv);
<span class="lineNum">    5885 </span><span class="lineNoCov">          0 :   /* If that failed, use the saved original VR0.  */</span>
<span class="lineNum">    5886 </span>            :   if (vr0-&gt;type == VR_VARYING)
<span class="lineNum">    5887 </span><span class="lineCov">    4656633 :     {</span>
<span class="lineNum">    5888 </span><span class="lineCov">    3067144 :       *vr0 = saved;</span>
<span class="lineNum">    5889 </span><span class="lineCov">    4816531 :       return;</span>
<span class="lineNum">    5890 </span>            :     }
<span class="lineNum">    5891 </span>            :   /* If the result is VR_UNDEFINED there is no need to mess with
<span class="lineNum">    5892 </span><span class="lineCov">     413850 :      the equivalencies.  */</span>
<span class="lineNum">    5893 </span><span class="lineCov">       7379 :   if (vr0-&gt;type == VR_UNDEFINED)</span>
<span class="lineNum">    5894 </span><span class="lineCov">       2848 :     return;</span>
<span class="lineNum">    5895 </span><span class="lineCov">     411002 : </span>
<span class="lineNum">    5896 </span><span class="lineCov">     406471 :   /* The resulting set of equivalences for range intersection is the union of</span>
<span class="lineNum">    5897 </span><span class="lineCov">     393374 :      the two sets.  */</span>
<span class="lineNum">    5898 </span><span class="lineCov">      17628 :   if (vr0-&gt;equiv &amp;&amp; vr1-&gt;equiv &amp;&amp; vr0-&gt;equiv != vr1-&gt;equiv)</span>
<span class="lineNum">    5899 </span><span class="lineCov">      13097 :     bitmap_ior_into (vr0-&gt;equiv, vr1-&gt;equiv);</span>
<span class="lineNum">    5900 </span>            :   else if (vr1-&gt;equiv &amp;&amp; !vr0-&gt;equiv)
<span class="lineNum">    5901 </span><span class="lineCov">      13097 :     {</span>
<span class="lineNum">    5902 </span><span class="lineCov">      13097 :       /* All equivalence bitmaps are allocated from the same obstack.  So</span>
<span class="lineNum">    5903 </span><span class="lineCov">      39291 :          we can use the obstack associated with VR to allocate vr0-&gt;equiv.  */</span>
<span class="lineNum">    5904 </span>            :       vr0-&gt;equiv = BITMAP_ALLOC (vr1-&gt;equiv-&gt;obstack);
<span class="lineNum">    5905 </span><span class="lineNoCov">          0 :       bitmap_copy (vr0-&gt;equiv, vr1-&gt;equiv);</span>
<span class="lineNum">    5906 </span>            :     }
<span class="lineNum">    5907 </span><span class="lineCov">       4531 : }</span>
<a name="5908"><span class="lineNum">    5908 </span><span class="lineCov">       4531 : </span></a>
<span class="lineNum">    5909 </span>            : void
<span class="lineNum">    5910 </span><span class="lineCov">       4531 : vrp_intersect_ranges (value_range *vr0, const value_range *vr1)</span>
<span class="lineNum">    5911 </span><span class="lineCov">       4531 : {</span>
<span class="lineNum">    5912 </span><span class="lineCov">       4531 :   if (dump_file &amp;&amp; (dump_flags &amp; TDF_DETAILS))</span>
<span class="lineNum">    5913 </span><span class="lineCov">      13593 :     {</span>
<span class="lineNum">    5914 </span>            :       fprintf (dump_file, &quot;Intersecting\n  &quot;);
<span class="lineNum">    5915 </span><span class="lineNoCov">          0 :       dump_value_range (dump_file, vr0);</span>
<span class="lineNum">    5916 </span><span class="lineCov">       4531 :       fprintf (dump_file, &quot;\nand\n  &quot;);</span>
<span class="lineNum">    5917 </span>            :       dump_value_range (dump_file, vr1);
<span class="lineNum">    5918 </span>            :       fprintf (dump_file, &quot;\n&quot;);
<span class="lineNum">    5919 </span><span class="lineNoCov">          0 :     }</span>
<span class="lineNum">    5920 </span>            :   vrp_intersect_ranges_1 (vr0, vr1);
<span class="lineNum">    5921 </span><span class="lineCov">    4242783 :   if (dump_file &amp;&amp; (dump_flags &amp; TDF_DETAILS))</span>
<span class="lineNum">    5922 </span><span class="lineCov">    2923775 :     {</span>
<span class="lineNum">    5923 </span><span class="lineCov">    4409228 :       fprintf (dump_file, &quot;to\n  &quot;);</span>
<span class="lineNum">    5924 </span>            :       dump_value_range (dump_file, vr0);
<span class="lineNum">    5925 </span>            :       fprintf (dump_file, &quot;\n&quot;);
<span class="lineNum">    5926 </span><span class="lineCov">     489640 :     }</span>
<span class="lineNum">    5927 </span><span class="lineCov">      15326 : }</span>
<span class="lineNum">    5928 </span><span class="lineCov">       1394 : </span>
<span class="lineNum">    5929 </span><span class="lineCov">     488246 : /* Meet operation for value ranges.  Given two value ranges VR0 and</span>
<span class="lineNum">    5930 </span><span class="lineCov">     474314 :    VR1, store in VR0 a range that contains both VR0 and VR1.  This</span>
<span class="lineNum">    5931 </span><span class="lineCov">     449843 :    may not be the smallest possible such range.  */</span>
<a name="5932"><span class="lineNum">    5932 </span><span class="lineCov">      38403 : </span></a>
<span class="lineNum">    5933 </span><span class="lineCov">      24471 : static void</span>
<span class="lineNum">    5934 </span>            : vrp_meet_1 (value_range *vr0, const value_range *vr1)
<span class="lineNum">    5935 </span><span class="lineCov">      24471 : {</span>
<span class="lineNum">    5936 </span><span class="lineCov">      24471 :   value_range saved;</span>
<span class="lineNum">    5937 </span><span class="lineCov">      73413 : </span>
<span class="lineNum">    5938 </span>            :   if (vr0-&gt;type == VR_UNDEFINED)
<span class="lineNum">    5939 </span><span class="lineNoCov">          0 :     {</span>
<span class="lineNum">    5940 </span>            :       set_value_range (vr0, vr1-&gt;type, vr1-&gt;min, vr1-&gt;max, vr1-&gt;equiv);
<span class="lineNum">    5941 </span><span class="lineCov">      13932 :       return;</span>
<span class="lineNum">    5942 </span><span class="lineCov">      13932 :     }</span>
<span class="lineNum">    5943 </span>            : 
<span class="lineNum">    5944 </span><span class="lineCov">      13932 :   if (vr1-&gt;type == VR_UNDEFINED)</span>
<span class="lineNum">    5945 </span><span class="lineCov">      13932 :     {</span>
<span class="lineNum">    5946 </span><span class="lineCov">      13932 :       /* VR0 already has the resulting range.  */</span>
<span class="lineNum">    5947 </span><span class="lineCov">      41796 :       return;</span>
<span class="lineNum">    5948 </span>            :     }
<span class="lineNum">    5949 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">    5950 </span><span class="lineCov">      13932 :   if (vr0-&gt;type == VR_VARYING)</span>
<span class="lineNum">    5951 </span>            :     {
<span class="lineNum">    5952 </span>            :       /* Nothing to do.  VR0 already has the resulting range.  */
<span class="lineNum">    5953 </span><span class="lineNoCov">          0 :       return;</span>
<span class="lineNum">    5954 </span>            :     }
<span class="lineNum">    5955 </span>            : 
<span class="lineNum">    5956 </span>            :   if (vr1-&gt;type == VR_VARYING)
<span class="lineNum">    5957 </span>            :     {
<span class="lineNum">    5958 </span>            :       set_value_range_to_varying (vr0);
<span class="lineNum">    5959 </span>            :       return;
<span class="lineNum">    5960 </span><span class="lineCov">   36191724 :     }</span>
<span class="lineNum">    5961 </span><span class="lineCov">   22534290 : </span>
<span class="lineNum">    5962 </span><span class="lineCov">   57698966 :   saved = *vr0;</span>
<span class="lineNum">    5963 </span>            :   union_ranges (&amp;vr0-&gt;type, &amp;vr0-&gt;min, &amp;vr0-&gt;max,
<span class="lineNum">    5964 </span><span class="lineCov">    1252196 :                 vr1-&gt;type, vr1-&gt;min, vr1-&gt;max);</span>
<span class="lineNum">    5965 </span><span class="lineCov">    1252196 :   if (vr0-&gt;type == VR_VARYING)</span>
<span class="lineNum">    5966 </span><span class="lineCov">    1252196 :     {</span>
<span class="lineNum">    5967 </span>            :       /* Failed to find an efficient meet.  Before giving up and setting
<span class="lineNum">    5968 </span>            :          the result to VARYING, see if we can at least derive a useful
<span class="lineNum">    5969 </span><span class="lineCov">   36191724 :          anti-range.  */</span>
<span class="lineNum">    5970 </span>            :       if (range_includes_zero_p (&amp;saved) == 0
<span class="lineNum">    5971 </span>            :           &amp;&amp; range_includes_zero_p (vr1) == 0)
<span class="lineNum">    5972 </span>            :         {
<span class="lineNum">    5973 </span>            :           set_value_range_to_nonnull (vr0, TREE_TYPE (saved.min));
<span class="lineNum">    5974 </span>            : 
<span class="lineNum">    5975 </span>            :           /* Since this meet operation did not result from the meeting of
<span class="lineNum">    5976 </span>            :              two equivalent names, VR0 cannot have any equivalences.  */
<span class="lineNum">    5977 </span><span class="lineCov">   52577050 :           if (vr0-&gt;equiv)</span>
<span class="lineNum">    5978 </span>            :             bitmap_clear (vr0-&gt;equiv);
<span class="lineNum">    5979 </span><span class="lineCov">   52577050 :           return;</span>
<span class="lineNum">    5980 </span>            :         }
<span class="lineNum">    5981 </span>            : 
<span class="lineNum">    5982 </span><span class="lineCov">   52577050 :       set_value_range_to_varying (vr0);</span>
<span class="lineNum">    5983 </span>            :       return;
<span class="lineNum">    5984 </span><span class="lineCov">   36847807 :     }</span>
<span class="lineNum">    5985 </span>            :   set_and_canonicalize_value_range (vr0, vr0-&gt;type, vr0-&gt;min, vr0-&gt;max,
<span class="lineNum">    5986 </span><span class="lineCov">     631396 :                                     vr0-&gt;equiv);</span>
<span class="lineNum">    5987 </span><span class="lineCov">     631396 :   if (vr0-&gt;type == VR_VARYING)</span>
<span class="lineNum">    5988 </span>            :     return;
<span class="lineNum">    5989 </span>            : 
<span class="lineNum">    5990 </span>            :   /* The resulting set of equivalences is always the intersection of
<span class="lineNum">    5991 </span>            :      the two sets.  */
<span class="lineNum">    5992 </span><span class="lineCov">   36216411 :   if (vr0-&gt;equiv &amp;&amp; vr1-&gt;equiv &amp;&amp; vr0-&gt;equiv != vr1-&gt;equiv)</span>
<span class="lineNum">    5993 </span>            :     bitmap_and_into (vr0-&gt;equiv, vr1-&gt;equiv);
<span class="lineNum">    5994 </span><span class="lineCov">   36213133 :   else if (vr0-&gt;equiv &amp;&amp; !vr1-&gt;equiv)</span>
<span class="lineNum">    5995 </span>            :     bitmap_clear (vr0-&gt;equiv);
<span class="lineNum">    5996 </span><span class="lineCov">      21409 : }</span>
<a name="5997"><span class="lineNum">    5997 </span><span class="lineCov">      21409 : </span></a>
<span class="lineNum">    5998 </span>            : void
<span class="lineNum">    5999 </span>            : vrp_meet (value_range *vr0, const value_range *vr1)
<span class="lineNum">    6000 </span>            : {
<span class="lineNum">    6001 </span>            :   if (dump_file &amp;&amp; (dump_flags &amp; TDF_DETAILS))
<span class="lineNum">    6002 </span><span class="lineCov">   36191724 :     {</span>
<span class="lineNum">    6003 </span><span class="lineCov">   72383448 :       fprintf (dump_file, &quot;Meeting\n  &quot;);</span>
<span class="lineNum">    6004 </span><span class="lineCov">   36191724 :       dump_value_range (dump_file, vr0);</span>
<span class="lineNum">    6005 </span>            :       fprintf (dump_file, &quot;\nand\n  &quot;);
<span class="lineNum">    6006 </span>            :       dump_value_range (dump_file, vr1);
<span class="lineNum">    6007 </span><span class="lineCov">   36191724 :       fprintf (dump_file, &quot;\n&quot;);</span>
<span class="lineNum">    6008 </span>            :     }
<span class="lineNum">    6009 </span>            :   vrp_meet_1 (vr0, vr1);
<span class="lineNum">    6010 </span><span class="lineCov">   36191724 :   if (dump_file &amp;&amp; (dump_flags &amp; TDF_DETAILS))</span>
<span class="lineNum">    6011 </span>            :     {
<span class="lineNum">    6012 </span><span class="lineNoCov">          0 :       fprintf (dump_file, &quot;to\n  &quot;);</span>
<span class="lineNum">    6013 </span><span class="lineNoCov">          0 :       dump_value_range (dump_file, vr0);</span>
<span class="lineNum">    6014 </span>            :       fprintf (dump_file, &quot;\n&quot;);
<span class="lineNum">    6015 </span>            :     }
<span class="lineNum">    6016 </span>            : }
<span class="lineNum">    6017 </span><span class="lineCov">   36191724 : </span>
<span class="lineNum">    6018 </span>            : 
<span class="lineNum">    6019 </span>            : /* Visit all arguments for PHI node PHI that flow through executable
<span class="lineNum">    6020 </span>            :    edges.  If a valid value range can be derived from all the incoming
<span class="lineNum">    6021 </span>            :    value ranges, set a new range for the LHS of PHI.  */
<a name="6022"><span class="lineNum">    6022 </span><span class="lineCov">   36188597 : </span></a>
<span class="lineNum">    6023 </span><span class="lineCov">    8593035 : enum ssa_prop_result</span>
<span class="lineNum">    6024 </span><span class="lineCov">   27595562 : vrp_prop::visit_phi (gphi *phi)</span>
<span class="lineNum">    6025 </span>            : {
<span class="lineNum">    6026 </span>            :   tree lhs = PHI_RESULT (phi);
<span class="lineNum">    6027 </span>            :   value_range vr_result = VR_INITIALIZER;
<span class="lineNum">    6028 </span><span class="lineNoCov">          0 :   extract_range_from_phi_node (phi, &amp;vr_result);</span>
<span class="lineNum">    6029 </span><span class="lineNoCov">          0 :   if (update_value_range (lhs, &amp;vr_result))</span>
<span class="lineNum">    6030 </span>            :     {
<span class="lineNum">    6031 </span>            :       if (dump_file &amp;&amp; (dump_flags &amp; TDF_DETAILS))
<span class="lineNum">    6032 </span>            :         {
<span class="lineNum">    6033 </span>            :           fprintf (dump_file, &quot;Found new range for &quot;);
<span class="lineNum">    6034 </span><span class="lineCov">   52577050 :           print_generic_expr (dump_file, lhs);</span>
<span class="lineNum">    6035 </span>            :           fprintf (dump_file, &quot;: &quot;);
<span class="lineNum">    6036 </span><span class="lineCov">   52577050 :           dump_value_range (dump_file, &amp;vr_result);</span>
<span class="lineNum">    6037 </span>            :           fprintf (dump_file, &quot;\n&quot;);
<span class="lineNum">    6038 </span><span class="lineCov">       1740 :         }</span>
<span class="lineNum">    6039 </span><span class="lineCov">       1740 : </span>
<span class="lineNum">    6040 </span><span class="lineCov">       1740 :       if (vr_result.type == VR_VARYING)</span>
<span class="lineNum">    6041 </span><span class="lineCov">       1740 :         return SSA_PROP_VARYING;</span>
<span class="lineNum">    6042 </span><span class="lineCov">       1740 : </span>
<span class="lineNum">    6043 </span>            :       return SSA_PROP_INTERESTING;
<span class="lineNum">    6044 </span><span class="lineCov">   52577050 :     }</span>
<span class="lineNum">    6045 </span><span class="lineCov">   52577050 : </span>
<span class="lineNum">    6046 </span>            :   /* Nothing changed, don't add outgoing edges.  */
<span class="lineNum">    6047 </span><span class="lineCov">       1740 :   return SSA_PROP_NOT_INTERESTING;</span>
<span class="lineNum">    6048 </span><span class="lineCov">       1740 : }</span>
<span class="lineNum">    6049 </span><span class="lineCov">       1740 : </span>
<span class="lineNum">    6050 </span>            : class vrp_folder : public substitute_and_fold_engine
<span class="lineNum">    6051 </span><span class="lineCov">   52577050 : {</span>
<span class="lineNum">    6052 </span>            :  public:
<span class="lineNum">    6053 </span>            :   tree get_value (tree) FINAL OVERRIDE;
<span class="lineNum">    6054 </span>            :   bool fold_stmt (gimple_stmt_iterator *) FINAL OVERRIDE;
<span class="lineNum">    6055 </span>            :   bool fold_predicate_in (gimple_stmt_iterator *);
<span class="lineNum">    6056 </span>            : 
<span class="lineNum">    6057 </span>            :   class vr_values *vr_values;
<a name="6058"><span class="lineNum">    6058 </span><span class="lineCov">    8902605 : </span></a>
<span class="lineNum">    6059 </span>            :   /* Delegators.  */
<span class="lineNum">    6060 </span><span class="lineCov">    8902605 :   tree vrp_evaluate_conditional (tree_code code, tree op0,</span>
<a name="6061"><span class="lineNum">    6061 </span>            :                                  tree op1, gimple *stmt)</a>
<span class="lineNum">    6062 </span><span class="lineCov">    8902605 :     { return vr_values-&gt;vrp_evaluate_conditional (code, op0, op1, stmt); }</span>
<a name="6063"><span class="lineNum">    6063 </span>            :   bool simplify_stmt_using_ranges (gimple_stmt_iterator *gsi)</a>
<span class="lineNum">    6064 </span><span class="lineCov">      81178 :     { return vr_values-&gt;simplify_stmt_using_ranges (gsi); }</span>
<span class="lineNum">    6065 </span><span class="lineCov">    3047818 :  tree op_with_constant_singleton_value_range (tree op)</span>
<span class="lineNum">    6066 </span>            :     { return vr_values-&gt;op_with_constant_singleton_value_range (op); }
<span class="lineNum">    6067 </span>            : };
<span class="lineNum">    6068 </span><span class="lineCov">    8821427 : </span>
<span class="lineNum">    6069 </span>            : /* If the statement pointed by SI has a predicate whose value can be
<span class="lineNum">    6070 </span>            :    computed using the value range information computed by VRP, compute
<span class="lineNum">    6071 </span>            :    its value and return true.  Otherwise, return false.  */
<a name="6072"><span class="lineNum">    6072 </span>            : </a>
<span class="lineNum">    6073 </span>            : bool
<span class="lineNum">    6074 </span><span class="lineCov">    8799256 : vrp_folder::fold_predicate_in (gimple_stmt_iterator *si)</span>
<span class="lineNum">    6075 </span>            : {
<span class="lineNum">    6076 </span>            :   bool assignment_p = false;
<span class="lineNum">    6077 </span>            :   tree val;
<span class="lineNum">    6078 </span>            :   gimple *stmt = gsi_stmt (*si);
<span class="lineNum">    6079 </span>            : 
<span class="lineNum">    6080 </span><span class="lineCov">    8392014 :   if (is_gimple_assign (stmt)</span>
<span class="lineNum">    6081 </span>            :       &amp;&amp; TREE_CODE_CLASS (gimple_assign_rhs_code (stmt)) == tcc_comparison)
<span class="lineNum">    6082 </span><span class="lineCov">     312681 :     {</span>
<span class="lineNum">    6083 </span><span class="lineCov">     312681 :       assignment_p = true;</span>
<span class="lineNum">    6084 </span>            :       val = vrp_evaluate_conditional (gimple_assign_rhs_code (stmt),
<span class="lineNum">    6085 </span>            :                                       gimple_assign_rhs1 (stmt),
<span class="lineNum">    6086 </span><span class="lineCov">    8079333 :                                       gimple_assign_rhs2 (stmt),</span>
<span class="lineNum">    6087 </span><span class="lineCov">   16158666 :                                       stmt);</span>
<span class="lineNum">    6088 </span><span class="lineCov">    8079333 :     }</span>
<span class="lineNum">    6089 </span><span class="lineCov">    8079333 :   else if (gcond *cond_stmt = dyn_cast &lt;gcond *&gt; (stmt))</span>
<span class="lineNum">    6090 </span>            :     val = vrp_evaluate_conditional (gimple_cond_code (cond_stmt),
<span class="lineNum">    6091 </span>            :                                     gimple_cond_lhs (cond_stmt),
<span class="lineNum">    6092 </span>            :                                     gimple_cond_rhs (cond_stmt),
<span class="lineNum">    6093 </span>            :                                     stmt);
<span class="lineNum">    6094 </span><span class="lineCov">    2224546 :   else</span>
<span class="lineNum">    6095 </span><span class="lineCov">    2224546 :     return false;</span>
<span class="lineNum">    6096 </span>            : 
<span class="lineNum">    6097 </span><span class="lineCov">      28062 :   if (val)</span>
<span class="lineNum">    6098 </span>            :     {
<span class="lineNum">    6099 </span>            :       if (assignment_p)
<span class="lineNum">    6100 </span>            :         val = fold_convert (gimple_expr_type (stmt), val);
<span class="lineNum">    6101 </span><span class="lineCov">      28062 : </span>
<span class="lineNum">    6102 </span><span class="lineCov">         50 :       if (dump_file)</span>
<span class="lineNum">    6103 </span><span class="lineCov">      28062 :         {</span>
<span class="lineNum">    6104 </span>            :           fprintf (dump_file, &quot;Folding predicate &quot;);
<span class="lineNum">    6105 </span>            :           print_gimple_expr (dump_file, stmt, 0);
<span class="lineNum">    6106 </span><span class="lineCov">    2196484 :           fprintf (dump_file, &quot; to &quot;);</span>
<span class="lineNum">    6107 </span><span class="lineCov">    2196484 :           print_generic_expr (dump_file, val);</span>
<span class="lineNum">    6108 </span>            :           fprintf (dump_file, &quot;\n&quot;);
<span class="lineNum">    6109 </span><span class="lineCov">    5854787 :         }</span>
<span class="lineNum">    6110 </span>            : 
<span class="lineNum">    6111 </span><span class="lineCov">    5854787 :       if (is_gimple_assign (stmt))</span>
<span class="lineNum">    6112 </span>            :         gimple_assign_set_rhs_from_tree (si, val);
<span class="lineNum">    6113 </span>            :       else
<span class="lineNum">    6114 </span>            :         {
<span class="lineNum">    6115 </span>            :           gcc_assert (gimple_code (stmt) == GIMPLE_COND);
<span class="lineNum">    6116 </span><span class="lineCov">    5854787 :           gcond *cond_stmt = as_a &lt;gcond *&gt; (stmt);</span>
<span class="lineNum">    6117 </span><span class="lineCov">     142114 :           if (integer_zerop (val))</span>
<span class="lineNum">    6118 </span><span class="lineCov">    5712673 :             gimple_cond_make_false (cond_stmt);</span>
<span class="lineNum">    6119 </span><span class="lineCov">     131727 :           else if (integer_onep (val))</span>
<span class="lineNum">    6120 </span>            :             gimple_cond_make_true (cond_stmt);
<span class="lineNum">    6121 </span>            :           else
<span class="lineNum">    6122 </span>            :             gcc_unreachable ();
<span class="lineNum">    6123 </span><span class="lineCov">    8902605 :         }</span>
<span class="lineNum">    6124 </span>            : 
<span class="lineNum">    6125 </span><span class="lineCov">    8902605 :       return true;</span>
<span class="lineNum">    6126 </span>            :     }
<span class="lineNum">    6127 </span><span class="lineCov">        353 : </span>
<span class="lineNum">    6128 </span><span class="lineCov">        353 :   return false;</span>
<span class="lineNum">    6129 </span><span class="lineCov">        353 : }</span>
<span class="lineNum">    6130 </span><span class="lineCov">        353 : </span>
<span class="lineNum">    6131 </span><span class="lineCov">        353 : /* Callback for substitute_and_fold folding the stmt at *SI.  */</span>
<a name="6132"><span class="lineNum">    6132 </span>            : </a>
<span class="lineNum">    6133 </span><span class="lineCov">    8902605 : bool</span>
<span class="lineNum">    6134 </span><span class="lineCov">    8902605 : vrp_folder::fold_stmt (gimple_stmt_iterator *si)</span>
<span class="lineNum">    6135 </span>            : {
<span class="lineNum">    6136 </span><span class="lineCov">        353 :   if (fold_predicate_in (si))</span>
<span class="lineNum">    6137 </span><span class="lineCov">        353 :     return true;</span>
<span class="lineNum">    6138 </span><span class="lineCov">        353 : </span>
<span class="lineNum">    6139 </span>            :   return simplify_stmt_using_ranges (si);
<span class="lineNum">    6140 </span><span class="lineCov">    8902605 : }</span>
<span class="lineNum">    6141 </span>            : 
<span class="lineNum">    6142 </span>            : /* If OP has a value range with a single constant value return that,
<span class="lineNum">    6143 </span>            :    otherwise return NULL_TREE.  This returns OP itself if OP is a
<span class="lineNum">    6144 </span>            :    constant.
<span class="lineNum">    6145 </span>            : 
<span class="lineNum">    6146 </span>            :    Implemented as a pure wrapper right now, but this will change.  */
<a name="6147"><span class="lineNum">    6147 </span>            : </a>
<span class="lineNum">    6148 </span><span class="lineCov">    5163382 : tree</span>
<span class="lineNum">    6149 </span>            : vrp_folder::get_value (tree op)
<span class="lineNum">    6150 </span><span class="lineCov">   10326764 : {</span>
<span class="lineNum">    6151 </span><span class="lineCov">    5163382 :   return op_with_constant_singleton_value_range (op);</span>
<span class="lineNum">    6152 </span><span class="lineCov">    5163382 : }</span>
<span class="lineNum">    6153 </span><span class="lineCov">    5163382 : </span>
<span class="lineNum">    6154 </span>            : /* Return the LHS of any ASSERT_EXPR where OP appears as the first
<span class="lineNum">    6155 </span><span class="lineCov">    4653408 :    argument to the ASSERT_EXPR and in which the ASSERT_EXPR dominates</span>
<span class="lineNum">    6156 </span>            :    BB.  If no such ASSERT_EXPR is found, return OP.  */
<a name="6157"><span class="lineNum">    6157 </span><span class="lineCov">        188 : </span></a>
<span class="lineNum">    6158 </span><span class="lineCov">        188 : static tree</span>
<span class="lineNum">    6159 </span><span class="lineCov">        188 : lhs_of_dominating_assert (tree op, basic_block bb, gimple *stmt)</span>
<span class="lineNum">    6160 </span><span class="lineCov">        188 : {</span>
<span class="lineNum">    6161 </span><span class="lineCov">        188 :   imm_use_iterator imm_iter;</span>
<span class="lineNum">    6162 </span>            :   gimple *use_stmt;
<span class="lineNum">    6163 </span>            :   use_operand_p use_p;
<span class="lineNum">    6164 </span><span class="lineCov">    4653408 : </span>
<span class="lineNum">    6165 </span>            :   if (TREE_CODE (op) == SSA_NAME)
<span class="lineNum">    6166 </span>            :     {
<span class="lineNum">    6167 </span><span class="lineCov">    3741615 :       FOR_EACH_IMM_USE_FAST (use_p, imm_iter, op)</span>
<span class="lineNum">    6168 </span>            :         {
<span class="lineNum">    6169 </span>            :           use_stmt = USE_STMT (use_p);
<span class="lineNum">    6170 </span>            :           if (use_stmt != stmt
<span class="lineNum">    6171 </span>            :               &amp;&amp; gimple_assign_single_p (use_stmt)
<span class="lineNum">    6172 </span>            :               &amp;&amp; TREE_CODE (gimple_assign_rhs1 (use_stmt)) == ASSERT_EXPR
<span class="lineNum">    6173 </span>            :               &amp;&amp; TREE_OPERAND (gimple_assign_rhs1 (use_stmt), 0) == op
<span class="lineNum">    6174 </span><span class="lineCov">    2335948 :               &amp;&amp; dominated_by_p (CDI_DOMINATORS, bb, gimple_bb (use_stmt)))</span>
<span class="lineNum">    6175 </span>            :             return gimple_assign_lhs (use_stmt);
<span class="lineNum">    6176 </span>            :         }
<span class="lineNum">    6177 </span>            :     }
<span class="lineNum">    6178 </span>            :   return op;
<span class="lineNum">    6179 </span>            : }
<span class="lineNum">    6180 </span>            : 
<span class="lineNum">    6181 </span>            : /* A hack.  */
<span class="lineNum">    6182 </span>            : static class vr_values *x_vr_values;
<span class="lineNum">    6183 </span>            : 
<span class="lineNum">    6184 </span><span class="lineNoCov">          0 : /* A trivial wrapper so that we can present the generic jump threading</span>
<span class="lineNum">    6185 </span>            :    code with a simple API for simplifying statements.  STMT is the
<span class="lineNum">    6186 </span><span class="lineNoCov">          0 :    statement we want to simplify, WITHIN_STMT provides the location</span>
<span class="lineNum">    6187 </span><span class="lineNoCov">          0 :    for any overflow warnings.  */</span>
<a name="6188"><span class="lineNum">    6188 </span><span class="lineNoCov">          0 : </span></a>
<span class="lineNum">    6189 </span><span class="lineNoCov">          0 : static tree</span>
<span class="lineNum">    6190 </span><span class="lineNoCov">          0 : simplify_stmt_for_jump_threading (gimple *stmt, gimple *within_stmt,</span>
<span class="lineNum">    6191 </span>            :     class avail_exprs_stack *avail_exprs_stack ATTRIBUTE_UNUSED,
<span class="lineNum">    6192 </span>            :     basic_block bb)
<span class="lineNum">    6193 </span>            : {
<span class="lineNum">    6194 </span>            :   /* First see if the conditional is in the hash table.  */
<span class="lineNum">    6195 </span>            :   tree cached_lhs = avail_exprs_stack-&gt;lookup_avail_expr (stmt, false, true);
<span class="lineNum">    6196 </span>            :   if (cached_lhs &amp;&amp; is_gimple_min_invariant (cached_lhs))
<span class="lineNum">    6197 </span>            :     return cached_lhs;
<span class="lineNum">    6198 </span><span class="lineCov">  103296008 : </span>
<span class="lineNum">    6199 </span>            :   vr_values *vr_values = x_vr_values;
<span class="lineNum">    6200 </span><span class="lineCov">  103296008 :   if (gcond *cond_stmt = dyn_cast &lt;gcond *&gt; (stmt))</span>
<span class="lineNum">    6201 </span><span class="lineCov">  103296008 :     {</span>
<span class="lineNum">    6202 </span><span class="lineCov">  103296008 :       tree op0 = gimple_cond_lhs (cond_stmt);</span>
<span class="lineNum">    6203 </span>            :       op0 = lhs_of_dominating_assert (op0, bb, stmt);
<span class="lineNum">    6204 </span><span class="lineCov">  103296008 : </span>
<span class="lineNum">    6205 </span><span class="lineCov">  103296008 :       tree op1 = gimple_cond_rhs (cond_stmt);</span>
<span class="lineNum">    6206 </span>            :       op1 = lhs_of_dominating_assert (op1, bb, stmt);
<span class="lineNum">    6207 </span><span class="lineCov">     512100 : </span>
<span class="lineNum">    6208 </span><span class="lineCov">     512100 :       return vr_values-&gt;vrp_evaluate_conditional (gimple_cond_code (cond_stmt),</span>
<span class="lineNum">    6209 </span>            :                                                   op0, op1, within_stmt);
<span class="lineNum">    6210 </span>            :     }
<span class="lineNum">    6211 </span>            : 
<span class="lineNum">    6212 </span>            :   /* We simplify a switch statement by trying to determine which case label
<span class="lineNum">    6213 </span><span class="lineCov">  102783908 :      will be taken.  If we are successful then we return the corresponding</span>
<span class="lineNum">    6214 </span><span class="lineCov">   17997896 :      CASE_LABEL_EXPR.  */</span>
<span class="lineNum">    6215 </span>            :   if (gswitch *switch_stmt = dyn_cast &lt;gswitch *&gt; (stmt))
<span class="lineNum">    6216 </span>            :     {
<span class="lineNum">    6217 </span>            :       tree op = gimple_switch_index (switch_stmt);
<span class="lineNum">    6218 </span>            :       if (TREE_CODE (op) != SSA_NAME)
<span class="lineNum">    6219 </span>            :         return NULL_TREE;
<span class="lineNum">    6220 </span>            : 
<span class="lineNum">    6221 </span><span class="lineCov">    5011574 :       op = lhs_of_dominating_assert (op, bb, stmt);</span>
<span class="lineNum">    6222 </span>            : 
<span class="lineNum">    6223 </span><span class="lineCov">      35250 :       const value_range *vr = vr_values-&gt;get_value_range (op);</span>
<span class="lineNum">    6224 </span><span class="lineCov">         52 :       if ((vr-&gt;type != VR_RANGE &amp;&amp; vr-&gt;type != VR_ANTI_RANGE)</span>
<span class="lineNum">    6225 </span>            :           || symbolic_range_p (vr))
<span class="lineNum">    6226 </span><span class="lineCov">      35250 :         return NULL_TREE;</span>
<span class="lineNum">    6227 </span>            : 
<span class="lineNum">    6228 </span><span class="lineCov">         49 :       if (vr-&gt;type == VR_RANGE)</span>
<span class="lineNum">    6229 </span><span class="lineCov">         49 :         {</span>
<span class="lineNum">    6230 </span><span class="lineCov">         49 :           size_t i, j;</span>
<span class="lineNum">    6231 </span><span class="lineCov">         49 :           /* Get the range of labels that contain a part of the operand's</span>
<span class="lineNum">    6232 </span><span class="lineCov">         49 :              value range.  */</span>
<span class="lineNum">    6233 </span>            :           find_case_label_range (switch_stmt, vr-&gt;min, vr-&gt;max, &amp;i, &amp;j);
<span class="lineNum">    6234 </span>            : 
<span class="lineNum">    6235 </span><span class="lineCov">      70500 :           /* Is there only one such label?  */</span>
<span class="lineNum">    6236 </span><span class="lineCov">         52 :           if (i == j)</span>
<span class="lineNum">    6237 </span>            :             {
<span class="lineNum">    6238 </span>            :               tree label = gimple_switch_label (switch_stmt, i);
<span class="lineNum">    6239 </span><span class="lineCov">      70396 : </span>
<span class="lineNum">    6240 </span><span class="lineCov">      35198 :               /* The i'th label will be taken only if the value range of the</span>
<span class="lineNum">    6241 </span><span class="lineCov">      35198 :                  operand is entirely within the bounds of this label.  */</span>
<span class="lineNum">    6242 </span><span class="lineCov">      28033 :               if (CASE_HIGH (label) != NULL_TREE</span>
<span class="lineNum">    6243 </span><span class="lineCov">       7165 :                   ? (tree_int_cst_compare (CASE_LOW (label), vr-&gt;min) &lt;= 0</span>
<span class="lineNum">    6244 </span><span class="lineCov">       7165 :                      &amp;&amp; tree_int_cst_compare (CASE_HIGH (label), vr-&gt;max) &gt;= 0)</span>
<span class="lineNum">    6245 </span>            :                   : (tree_int_cst_equal (CASE_LOW (label), vr-&gt;min)
<span class="lineNum">    6246 </span><span class="lineNoCov">          0 :                      &amp;&amp; tree_int_cst_equal (vr-&gt;min, vr-&gt;max)))</span>
<span class="lineNum">    6247 </span>            :                 return label;
<span class="lineNum">    6248 </span>            :             }
<span class="lineNum">    6249 </span><span class="lineCov">      35250 : </span>
<span class="lineNum">    6250 </span>            :           /* If there are no such labels then the default label will be
<span class="lineNum">    6251 </span>            :              taken.  */
<span class="lineNum">    6252 </span>            :           if (i &gt; j)
<span class="lineNum">    6253 </span>            :             return gimple_switch_label (switch_stmt, 0);
<span class="lineNum">    6254 </span>            :         }
<span class="lineNum">    6255 </span>            : 
<span class="lineNum">    6256 </span>            :       if (vr-&gt;type == VR_ANTI_RANGE)
<span class="lineNum">    6257 </span>            :         {
<span class="lineNum">    6258 </span><span class="lineCov">  103296008 :           unsigned n = gimple_switch_num_labels (switch_stmt);</span>
<span class="lineNum">    6259 </span>            :           tree min_label = gimple_switch_label (switch_stmt, 1);
<span class="lineNum">    6260 </span><span class="lineCov">  103296008 :           tree max_label = gimple_switch_label (switch_stmt, n - 1);</span>
<span class="lineNum">    6261 </span>            : 
<span class="lineNum">    6262 </span>            :           /* The default label will be taken only if the anti-range of the
<span class="lineNum">    6263 </span><span class="lineCov">  103260758 :              operand is entirely outside the bounds of all the (non-default)</span>
<span class="lineNum">    6264 </span>            :              case labels.  */
<span class="lineNum">    6265 </span>            :           if (tree_int_cst_compare (vr-&gt;min, CASE_LOW (min_label)) &lt;= 0
<span class="lineNum">    6266 </span>            :               &amp;&amp; (CASE_HIGH (max_label) != NULL_TREE
<span class="lineNum">    6267 </span>            :                   ? tree_int_cst_compare (vr-&gt;max, CASE_HIGH (max_label)) &gt;= 0
<span class="lineNum">    6268 </span>            :                   : tree_int_cst_compare (vr-&gt;max, CASE_LOW (max_label)) &gt;= 0))
<span class="lineNum">    6269 </span>            :           return gimple_switch_label (switch_stmt, 0);
<span class="lineNum">    6270 </span>            :         }
<span class="lineNum">    6271 </span>            : 
<span class="lineNum">    6272 </span>            :       return NULL_TREE;
<span class="lineNum">    6273 </span><span class="lineCov">   81788934 :     }</span>
<span class="lineNum">    6274 </span>            : 
<span class="lineNum">    6275 </span><span class="lineCov">   81788934 :   if (gassign *assign_stmt = dyn_cast &lt;gassign *&gt; (stmt))</span>
<span class="lineNum">    6276 </span>            :     {
<span class="lineNum">    6277 </span>            :       tree lhs = gimple_assign_lhs (assign_stmt);
<span class="lineNum">    6278 </span>            :       if (TREE_CODE (lhs) == SSA_NAME
<span class="lineNum">    6279 </span>            :           &amp;&amp; (INTEGRAL_TYPE_P (TREE_TYPE (lhs))
<span class="lineNum">    6280 </span>            :               || POINTER_TYPE_P (TREE_TYPE (lhs)))
<span class="lineNum">    6281 </span>            :           &amp;&amp; stmt_interesting_for_vrp (stmt))
<span class="lineNum">    6282 </span>            :         {
<span class="lineNum">    6283 </span><span class="lineCov">    8799890 :           edge dummy_e;</span>
<span class="lineNum">    6284 </span>            :           tree dummy_tree;
<span class="lineNum">    6285 </span><span class="lineCov">    8799890 :           value_range new_vr = VR_INITIALIZER;</span>
<span class="lineNum">    6286 </span><span class="lineCov">    8799890 :           vr_values-&gt;extract_range_from_stmt (stmt, &amp;dummy_e,</span>
<span class="lineNum">    6287 </span><span class="lineCov">    8799890 :                                               &amp;dummy_tree, &amp;new_vr);</span>
<span class="lineNum">    6288 </span>            :           if (range_int_cst_singleton_p (&amp;new_vr))
<span class="lineNum">    6289 </span><span class="lineCov">    8799890 :             return new_vr.min;</span>
<span class="lineNum">    6290 </span>            :         }
<span class="lineNum">    6291 </span><span class="lineCov">   29570875 :     }</span>
<span class="lineNum">    6292 </span>            : 
<span class="lineNum">    6293 </span><span class="lineCov">   24624095 :   return NULL_TREE;</span>
<span class="lineNum">    6294 </span><span class="lineCov">   24624095 : }</span>
<span class="lineNum">    6295 </span><span class="lineCov">   24624095 : </span>
<span class="lineNum">    6296 </span><span class="lineCov">   25924694 : class vrp_dom_walker : public dom_walker</span>
<span class="lineNum">    6297 </span><span class="lineCov">   24117256 : {</span>
<span class="lineNum">    6298 </span><span class="lineCov">   46394447 : public:</span>
<span class="lineNum">    6299 </span><span class="lineCov">     373306 :   vrp_dom_walker (cdi_direction direction,</span>
<span class="lineNum">    6300 </span>            :                   class const_and_copies *const_and_copies,
<span class="lineNum">    6301 </span>            :                   class avail_exprs_stack *avail_exprs_stack)
<span class="lineNum">    6302 </span>            :     : dom_walker (direction, REACHABLE_BLOCKS),
<span class="lineNum">    6303 </span>            :       m_const_and_copies (const_and_copies),
<span class="lineNum">    6304 </span>            :       m_avail_exprs_stack (avail_exprs_stack),
<span class="lineNum">    6305 </span>            :       m_dummy_cond (NULL) {}
<span class="lineNum">    6306 </span>            : 
<span class="lineNum">    6307 </span>            :   virtual edge before_dom_children (basic_block);
<span class="lineNum">    6308 </span>            :   virtual void after_dom_children (basic_block);
<span class="lineNum">    6309 </span>            : 
<span class="lineNum">    6310 </span>            :   class vr_values *vr_values;
<span class="lineNum">    6311 </span>            : 
<span class="lineNum">    6312 </span>            : private:
<span class="lineNum">    6313 </span>            :   class const_and_copies *m_const_and_copies;
<span class="lineNum">    6314 </span><span class="lineCov">   13660686 :   class avail_exprs_stack *m_avail_exprs_stack;</span>
<span class="lineNum">    6315 </span>            : 
<span class="lineNum">    6316 </span>            :   gcond *m_dummy_cond;
<span class="lineNum">    6317 </span>            : 
<span class="lineNum">    6318 </span>            : };
<span class="lineNum">    6319 </span><span class="lineCov">   13660686 : </span>
<span class="lineNum">    6320 </span><span class="lineCov">   13660686 : /* Called before processing dominator children of BB.  We want to look</span>
<span class="lineNum">    6321 </span>            :    at ASSERT_EXPRs and record information from them in the appropriate
<span class="lineNum">    6322 </span>            :    tables.
<span class="lineNum">    6323 </span><span class="lineCov">   13575537 : </span>
<span class="lineNum">    6324 </span><span class="lineCov">   13575537 :    We could look at other statements here.  It's not seen as likely</span>
<span class="lineNum">    6325 </span>            :    to significantly increase the jump threads we discover.  */
<a name="6326"><span class="lineNum">    6326 </span><span class="lineCov">    4395512 : </span></a>
<span class="lineNum">    6327 </span><span class="lineCov">    4395512 : edge</span>
<span class="lineNum">    6328 </span>            : vrp_dom_walker::before_dom_children (basic_block bb)
<span class="lineNum">    6329 </span><span class="lineCov">    4395512 : {</span>
<span class="lineNum">    6330 </span><span class="lineCov">    4395512 :   gimple_stmt_iterator gsi;</span>
<span class="lineNum">    6331 </span>            : 
<span class="lineNum">    6332 </span><span class="lineCov">    8791024 :   m_avail_exprs_stack-&gt;push_marker ();</span>
<span class="lineNum">    6333 </span><span class="lineCov">    4395512 :   m_const_and_copies-&gt;push_marker ();</span>
<span class="lineNum">    6334 </span>            :   for (gsi = gsi_start_nondebug_bb (bb); !gsi_end_p (gsi); gsi_next (&amp;gsi))
<span class="lineNum">    6335 </span>            :     {
<span class="lineNum">    6336 </span>            :       gimple *stmt = gsi_stmt (gsi);
<span class="lineNum">    6337 </span>            :       if (gimple_assign_single_p (stmt)
<span class="lineNum">    6338 </span>            :          &amp;&amp; TREE_CODE (gimple_assign_rhs1 (stmt)) == ASSERT_EXPR)
<span class="lineNum">    6339 </span><span class="lineCov">    9180025 :         {</span>
<span class="lineNum">    6340 </span>            :           tree rhs1 = gimple_assign_rhs1 (stmt);
<span class="lineNum">    6341 </span><span class="lineCov">       8866 :           tree cond = TREE_OPERAND (rhs1, 1);</span>
<span class="lineNum">    6342 </span><span class="lineCov">       8866 :           tree inverted = invert_truthvalue (cond);</span>
<span class="lineNum">    6343 </span>            :           vec&lt;cond_equivalence&gt; p;
<span class="lineNum">    6344 </span>            :           p.create (3);
<span class="lineNum">    6345 </span><span class="lineCov">       8866 :           record_conditions (&amp;p, cond, inverted);</span>
<span class="lineNum">    6346 </span>            :           for (unsigned int i = 0; i &lt; p.length (); i++)
<span class="lineNum">    6347 </span><span class="lineCov">       8866 :             m_avail_exprs_stack-&gt;record_cond (&amp;p[i]);</span>
<span class="lineNum">    6348 </span><span class="lineCov">       8866 : </span>
<span class="lineNum">    6349 </span><span class="lineCov">       8866 :           tree lhs = gimple_assign_lhs (stmt);</span>
<span class="lineNum">    6350 </span><span class="lineCov">       6284 :           m_const_and_copies-&gt;record_const_or_copy (lhs,</span>
<span class="lineNum">    6351 </span>            :                                                     TREE_OPERAND (rhs1, 0));
<span class="lineNum">    6352 </span><span class="lineCov">       2582 :           p.release ();</span>
<span class="lineNum">    6353 </span>            :           continue;
<span class="lineNum">    6354 </span><span class="lineCov">       1970 :         }</span>
<span class="lineNum">    6355 </span>            :       break;
<span class="lineNum">    6356 </span>            :     }
<span class="lineNum">    6357 </span><span class="lineCov">       1970 :   return NULL;</span>
<span class="lineNum">    6358 </span>            : }
<span class="lineNum">    6359 </span>            : 
<span class="lineNum">    6360 </span><span class="lineCov">       1970 : /* Called after processing dominator children of BB.  This is where we</span>
<a name="6361"><span class="lineNum">    6361 </span>            :    actually call into the threader.  */</a>
<span class="lineNum">    6362 </span><span class="lineCov">        199 : void</span>
<span class="lineNum">    6363 </span>            : vrp_dom_walker::after_dom_children (basic_block bb)
<span class="lineNum">    6364 </span>            : {
<span class="lineNum">    6365 </span>            :   if (!m_dummy_cond)
<span class="lineNum">    6366 </span><span class="lineCov">        199 :     m_dummy_cond = gimple_build_cond (NE_EXPR,</span>
<span class="lineNum">    6367 </span><span class="lineCov">        199 :                                       integer_zero_node, integer_zero_node,</span>
<span class="lineNum">    6368 </span><span class="lineCov">          5 :                                       NULL, NULL);</span>
<span class="lineNum">    6369 </span><span class="lineCov">        388 : </span>
<span class="lineNum">    6370 </span><span class="lineCov">        194 :   x_vr_values = vr_values;</span>
<span class="lineNum">    6371 </span><span class="lineCov">        165 :   thread_outgoing_edges (bb, m_dummy_cond, m_const_and_copies,</span>
<span class="lineNum">    6372 </span>            :                          m_avail_exprs_stack, NULL,
<span class="lineNum">    6373 </span>            :                          simplify_stmt_for_jump_threading);
<span class="lineNum">    6374 </span>            :   x_vr_values = NULL;
<span class="lineNum">    6375 </span>            : 
<span class="lineNum">    6376 </span><span class="lineCov">       1805 :   m_avail_exprs_stack-&gt;pop_to_marker ();</span>
<span class="lineNum">    6377 </span><span class="lineCov">         65 :   m_const_and_copies-&gt;pop_to_marker ();</span>
<span class="lineNum">    6378 </span>            : }
<span class="lineNum">    6379 </span>            : 
<span class="lineNum">    6380 </span><span class="lineCov">       2352 : /* Blocks which have more than one predecessor and more than</span>
<span class="lineNum">    6381 </span>            :    one successor present jump threading opportunities, i.e.,
<span class="lineNum">    6382 </span><span class="lineCov">        612 :    when the block is reached from a specific predecessor, we</span>
<span class="lineNum">    6383 </span><span class="lineCov">        612 :    may be able to determine which of the outgoing edges will</span>
<span class="lineNum">    6384 </span><span class="lineCov">        612 :    be traversed.  When this optimization applies, we are able</span>
<span class="lineNum">    6385 </span>            :    to avoid conditionals at runtime and we may expose secondary
<span class="lineNum">    6386 </span>            :    optimization opportunities.
<span class="lineNum">    6387 </span>            : 
<span class="lineNum">    6388 </span>            :    This routine is effectively a driver for the generic jump
<span class="lineNum">    6389 </span><span class="lineCov">        612 :    threading code.  It basically just presents the generic code</span>
<span class="lineNum">    6390 </span><span class="lineCov">        624 :    with edges that may be suitable for jump threading.</span>
<span class="lineNum">    6391 </span><span class="lineCov">        321 : </span>
<span class="lineNum">    6392 </span><span class="lineCov">        594 :    Unlike DOM, we do not iterate VRP if jump threading was successful.</span>
<span class="lineNum">    6393 </span><span class="lineCov">          9 :    While iterating may expose new opportunities for VRP, it is expected</span>
<span class="lineNum">    6394 </span>            :    those opportunities would be very limited and the compile time cost
<span class="lineNum">    6395 </span>            :    to expose those opportunities would be significant.
<span class="lineNum">    6396 </span><span class="lineCov">       2343 : </span>
<span class="lineNum">    6397 </span>            :    As jump threading opportunities are discovered, they are registered
<span class="lineNum">    6398 </span>            :    for later realization.  */
<a name="6399"><span class="lineNum">    6399 </span><span class="lineCov">    9171159 : </span></a>
<span class="lineNum">    6400 </span>            : static void
<span class="lineNum">    6401 </span><span class="lineCov">    8354926 : identify_jump_threads (class vr_values *vr_values)</span>
<span class="lineNum">    6402 </span><span class="lineCov">    8354926 : {</span>
<span class="lineNum">    6403 </span><span class="lineCov">    8354926 :   /* Ugh.  When substituting values earlier in this pass we can</span>
<span class="lineNum">    6404 </span><span class="lineCov">    5660004 :      wipe the dominance information.  So rebuild the dominator</span>
<span class="lineNum">    6405 </span><span class="lineCov">   16116876 :      information as we need it within the jump threading code.  */</span>
<span class="lineNum">    6406 </span>            :   calculate_dominance_info (CDI_DOMINATORS);
<span class="lineNum">    6407 </span><span class="lineCov">    4775016 : </span>
<span class="lineNum">    6408 </span><span class="lineCov">    4775016 :   /* We do not allow VRP information to be used for jump threading</span>
<span class="lineNum">    6409 </span><span class="lineCov">    4775016 :      across a back edge in the CFG.  Otherwise it becomes too</span>
<span class="lineNum">    6410 </span><span class="lineCov">    4775016 :      difficult to avoid eliminating loop exit tests.  Of course</span>
<span class="lineNum">    6411 </span>            :      EDGE_DFS_BACK is not accurate at this time so we have to
<span class="lineNum">    6412 </span><span class="lineCov">    4775016 :      recompute it.  */</span>
<span class="lineNum">    6413 </span><span class="lineCov">       2160 :   mark_dfs_back_edges ();</span>
<span class="lineNum">    6414 </span>            : 
<span class="lineNum">    6415 </span>            :   /* Allocate our unwinder stack to unwind any temporary equivalences
<span class="lineNum">    6416 </span>            :      that might be recorded.  */
<span class="lineNum">    6417 </span>            :   const_and_copies *equiv_stack = new const_and_copies ();
<span class="lineNum">    6418 </span>            : 
<span class="lineNum">    6419 </span>            :   hash_table&lt;expr_elt_hasher&gt; *avail_exprs
<span class="lineNum">    6420 </span><span class="lineCov">    1167974 :     = new hash_table&lt;expr_elt_hasher&gt; (1024);</span>
<span class="lineNum">    6421 </span>            :   avail_exprs_stack *avail_exprs_stack
<span class="lineNum">    6422 </span>            :     = new class avail_exprs_stack (avail_exprs);
<span class="lineNum">    6423 </span>            : 
<span class="lineNum">    6424 </span>            :   vrp_dom_walker walker (CDI_DOMINATORS, equiv_stack, avail_exprs_stack);
<span class="lineNum">    6425 </span>            :   walker.vr_values = vr_values;
<span class="lineNum">    6426 </span><span class="lineCov">    1167974 :   walker.walk (cfun-&gt;cfg-&gt;x_entry_block_ptr);</span>
<span class="lineNum">    6427 </span>            : 
<span class="lineNum">    6428 </span>            :   /* We do not actually update the CFG or SSA graphs at this point as
<span class="lineNum">    6429 </span><span class="lineCov">    2335948 :      ASSERT_EXPRs are still in the IL and cfg cleanup code does not yet</span>
<span class="lineNum">    6430 </span>            :      handle ASSERT_EXPRs gracefully.  */
<span class="lineNum">    6431 </span>            :   delete equiv_stack;
<span class="lineNum">    6432 </span>            :   delete avail_exprs;
<span class="lineNum">    6433 </span>            :   delete avail_exprs_stack;
<span class="lineNum">    6434 </span>            : }
<span class="lineNum">    6435 </span>            : 
<span class="lineNum">    6436 </span>            : /* Traverse all the blocks folding conditionals with known ranges.  */
<span class="lineNum">    6437 </span>            : 
<span class="lineNum">    6438 </span>            : void
<span class="lineNum">    6439 </span>            : vrp_prop::vrp_finalize (bool warn_array_bounds_p)
<span class="lineNum">    6440 </span>            : {
<span class="lineNum">    6441 </span>            :   size_t i;
<span class="lineNum">    6442 </span>            : 
<span class="lineNum">    6443 </span>            :   /* We have completed propagating through the lattice.  */
<span class="lineNum">    6444 </span>            :   vr_values.set_lattice_propagation_complete ();
<span class="lineNum">    6445 </span>            : 
<span class="lineNum">    6446 </span>            :   if (dump_file)
<span class="lineNum">    6447 </span>            :     {
<span class="lineNum">    6448 </span>            :       fprintf (dump_file, &quot;\nValue ranges after VRP:\n\n&quot;);
<span class="lineNum">    6449 </span>            :       vr_values.dump_all_value_ranges (dump_file);
<span class="lineNum">    6450 </span>            :       fprintf (dump_file, &quot;\n&quot;);
<span class="lineNum">    6451 </span>            :     }
<span class="lineNum">    6452 </span><span class="lineCov">   13556182 : </span>
<span class="lineNum">    6453 </span>            :   /* Set value range to non pointer SSA_NAMEs.  */
<span class="lineNum">    6454 </span><span class="lineCov">   13556182 :   for (i = 0; i &lt; num_ssa_names; i++)</span>
<span class="lineNum">    6455 </span>            :     {
<span class="lineNum">    6456 </span><span class="lineCov">   13556182 :       tree name = ssa_name (i);</span>
<span class="lineNum">    6457 </span><span class="lineCov">   13556182 :       if (!name)</span>
<span class="lineNum">    6458 </span><span class="lineCov">   20479992 :         continue;</span>
<span class="lineNum">    6459 </span>            : 
<span class="lineNum">    6460 </span><span class="lineCov">   14397584 :       const value_range *vr = get_value_range (name);</span>
<span class="lineNum">    6461 </span><span class="lineCov">   14397584 :       if (!name</span>
<span class="lineNum">    6462 </span><span class="lineCov">   14277592 :           || (vr-&gt;type == VR_VARYING)</span>
<span class="lineNum">    6463 </span>            :           || (vr-&gt;type == VR_UNDEFINED)
<span class="lineNum">    6464 </span><span class="lineCov">    3461905 :           || (TREE_CODE (vr-&gt;min) != INTEGER_CST)</span>
<span class="lineNum">    6465 </span><span class="lineCov">    3461905 :           || (TREE_CODE (vr-&gt;max) != INTEGER_CST))</span>
<span class="lineNum">    6466 </span><span class="lineCov">    3461905 :         continue;</span>
<span class="lineNum">    6467 </span><span class="lineCov">    3461905 : </span>
<span class="lineNum">    6468 </span><span class="lineCov">    3461905 :       if (POINTER_TYPE_P (TREE_TYPE (name))</span>
<span class="lineNum">    6469 </span><span class="lineCov">    3461905 :           &amp;&amp; range_includes_zero_p (vr) == 0)</span>
<span class="lineNum">    6470 </span><span class="lineCov">   26100442 :         set_ptr_nonnull (name);</span>
<span class="lineNum">    6471 </span><span class="lineCov">    9588316 :       else if (!POINTER_TYPE_P (TREE_TYPE (name)))</span>
<span class="lineNum">    6472 </span>            :         set_range_info (name, vr-&gt;type,
<span class="lineNum">    6473 </span><span class="lineCov">    3461905 :                         wi::to_wide (vr-&gt;min),</span>
<span class="lineNum">    6474 </span><span class="lineCov">    3461905 :                         wi::to_wide (vr-&gt;max));</span>
<span class="lineNum">    6475 </span><span class="lineCov">    3461905 :     }</span>
<span class="lineNum">    6476 </span><span class="lineCov">    3461905 : </span>
<span class="lineNum">    6477 </span><span class="lineCov">    3461905 :   /* If we're checking array refs, we want to merge information on</span>
<span class="lineNum">    6478 </span>            :      the executability of each edge between vrp_folder and the
<span class="lineNum">    6479 </span>            :      check_array_bounds_dom_walker: each can clear the
<span class="lineNum">    6480 </span>            :      EDGE_EXECUTABLE flag on edges, in different ways.
<span class="lineNum">    6481 </span><span class="lineCov">   13556182 : </span>
<span class="lineNum">    6482 </span>            :      Hence, if we're going to call check_all_array_refs, set
<span class="lineNum">    6483 </span>            :      the flag on every edge now, rather than in
<span class="lineNum">    6484 </span>            :      check_array_bounds_dom_walker's ctor; vrp_folder may clear
<span class="lineNum">    6485 </span>            :      it from some edges.  */
<span class="lineNum">    6486 </span>            :   if (warn_array_bounds &amp;&amp; warn_array_bounds_p)
<span class="lineNum">    6487 </span><span class="lineCov">   13556182 :     set_all_edges_as_executable (cfun);</span>
<span class="lineNum">    6488 </span>            : 
<span class="lineNum">    6489 </span><span class="lineCov">   13556182 :   class vrp_folder vrp_folder;</span>
<span class="lineNum">    6490 </span><span class="lineCov">    1167974 :   vrp_folder.vr_values = &amp;vr_values;</span>
<span class="lineNum">    6491 </span>            :   vrp_folder.substitute_and_fold ();
<span class="lineNum">    6492 </span>            : 
<span class="lineNum">    6493 </span>            :   if (warn_array_bounds &amp;&amp; warn_array_bounds_p)
<span class="lineNum">    6494 </span><span class="lineCov">   13556182 :     check_all_array_refs ();</span>
<span class="lineNum">    6495 </span><span class="lineCov">   13556182 : }</span>
<span class="lineNum">    6496 </span>            : 
<span class="lineNum">    6497 </span>            : /* Main entry point to VRP (Value Range Propagation).  This pass is
<span class="lineNum">    6498 </span><span class="lineCov">   13556182 :    loosely based on J. R. C. Patterson, ``Accurate Static Branch</span>
<span class="lineNum">    6499 </span>            :    Prediction by Value Range Propagation,'' in SIGPLAN Conference on
<span class="lineNum">    6500 </span><span class="lineCov">   13556182 :    Programming Language Design and Implementation, pp. 67-78, 1995.</span>
<span class="lineNum">    6501 </span><span class="lineCov">   13556182 :    Also available at http://citeseer.ist.psu.edu/patterson95accurate.html</span>
<span class="lineNum">    6502 </span><span class="lineCov">   13556182 : </span>
<span class="lineNum">    6503 </span>            :    This is essentially an SSA-CCP pass modified to deal with ranges
<span class="lineNum">    6504 </span>            :    instead of constants.
<span class="lineNum">    6505 </span>            : 
<span class="lineNum">    6506 </span>            :    While propagating ranges, we may find that two or more SSA name
<span class="lineNum">    6507 </span>            :    have equivalent, though distinct ranges.  For instance,
<span class="lineNum">    6508 </span>            : 
<span class="lineNum">    6509 </span>            :      1  x_9 = p_3-&gt;a;
<span class="lineNum">    6510 </span>            :      2  p_4 = ASSERT_EXPR &lt;p_3, p_3 != 0&gt;
<span class="lineNum">    6511 </span>            :      3  if (p_4 == q_2)
<span class="lineNum">    6512 </span>            :      4    p_5 = ASSERT_EXPR &lt;p_4, p_4 == q_2&gt;;
<span class="lineNum">    6513 </span>            :      5  endif
<span class="lineNum">    6514 </span>            :      6  if (q_2)
<span class="lineNum">    6515 </span>            : 
<span class="lineNum">    6516 </span>            :    In the code above, pointer p_5 has range [q_2, q_2], but from the
<span class="lineNum">    6517 </span>            :    code we can also determine that p_5 cannot be NULL and, if q_2 had
<span class="lineNum">    6518 </span>            :    a non-varying range, p_5's range should also be compatible with it.
<span class="lineNum">    6519 </span>            : 
<span class="lineNum">    6520 </span>            :    These equivalences are created by two expressions: ASSERT_EXPR and
<span class="lineNum">    6521 </span>            :    copy operations.  Since p_5 is an assertion on p_4, and p_4 was the
<span class="lineNum">    6522 </span>            :    result of another assertion, then we can use the fact that p_5 and
<span class="lineNum">    6523 </span>            :    p_4 are equivalent when evaluating p_5's range.
<span class="lineNum">    6524 </span>            : 
<span class="lineNum">    6525 </span><span class="lineCov">    1167974 :    Together with value ranges, we also propagate these equivalences</span>
<span class="lineNum">    6526 </span>            :    between names so that we can take advantage of information from
<span class="lineNum">    6527 </span>            :    multiple ranges when doing final replacement.  Note that this
<span class="lineNum">    6528 </span>            :    equivalency relation is transitive but not symmetric.
<span class="lineNum">    6529 </span>            : 
<span class="lineNum">    6530 </span><span class="lineCov">    1167974 :    In the example above, p_5 is equivalent to p_4, q_2 and p_3, but we</span>
<span class="lineNum">    6531 </span>            :    cannot assert that q_2 is equivalent to p_5 because q_2 may be used
<span class="lineNum">    6532 </span>            :    in contexts where that assertion does not hold (e.g., in line 6).
<span class="lineNum">    6533 </span>            : 
<span class="lineNum">    6534 </span>            :    TODO, the main difference between this pass and Patterson's is that
<span class="lineNum">    6535 </span>            :    we do not propagate edge probabilities.  We only compute whether
<span class="lineNum">    6536 </span>            :    edges can be taken or not.  That is, instead of having a spectrum
<span class="lineNum">    6537 </span><span class="lineCov">    1167974 :    of jump probabilities between 0 and 1, we only deal with 0, 1 and</span>
<span class="lineNum">    6538 </span>            :    DON'T KNOW.  In the future, it may be worthwhile to propagate
<span class="lineNum">    6539 </span>            :    probabilities to aid branch prediction.  */
<a name="6540"><span class="lineNum">    6540 </span>            : </a>
<span class="lineNum">    6541 </span><span class="lineCov">    1167974 : static unsigned int</span>
<span class="lineNum">    6542 </span>            : execute_vrp (bool warn_array_bounds_p)
<span class="lineNum">    6543 </span><span class="lineCov">    1167974 : {</span>
<span class="lineNum">    6544 </span><span class="lineCov">    1167974 : </span>
<span class="lineNum">    6545 </span><span class="lineCov">    1167974 :   loop_optimizer_init (LOOPS_NORMAL | LOOPS_HAVE_RECORDED_EXITS);</span>
<span class="lineNum">    6546 </span><span class="lineCov">    1167974 :   rewrite_into_loop_closed_ssa (NULL, TODO_update_ssa);</span>
<span class="lineNum">    6547 </span>            :   scev_initialize ();
<span class="lineNum">    6548 </span><span class="lineCov">    2335948 : </span>
<span class="lineNum">    6549 </span><span class="lineCov">    1167974 :   /* ???  This ends up using stale EDGE_DFS_BACK for liveness computation.</span>
<span class="lineNum">    6550 </span><span class="lineCov">    1167974 :      Inserting assertions may split edges which will invalidate</span>
<span class="lineNum">    6551 </span>            :      EDGE_DFS_BACK.  */
<span class="lineNum">    6552 </span>            :   insert_range_assertions ();
<span class="lineNum">    6553 </span>            : 
<span class="lineNum">    6554 </span>            :   threadedge_initialize_values ();
<span class="lineNum">    6555 </span><span class="lineCov">    2335948 : </span>
<span class="lineNum">    6556 </span><span class="lineCov">    1167974 :   /* For visiting PHI nodes we need EDGE_DFS_BACK computed.  */</span>
<span class="lineNum">    6557 </span><span class="lineCov">    2335948 :   mark_dfs_back_edges ();</span>
<span class="lineNum">    6558 </span><span class="lineCov">    1167974 : </span>
<span class="lineNum">    6559 </span>            :   class vrp_prop vrp_prop;
<span class="lineNum">    6560 </span>            :   vrp_prop.vrp_initialize ();
<span class="lineNum">    6561 </span>            :   vrp_prop.ssa_propagate ();
<span class="lineNum">    6562 </span>            :   vrp_prop.vrp_finalize (warn_array_bounds_p);
<span class="lineNum">    6563 </span><span class="lineCov">    1167974 : </span>
<span class="lineNum">    6564 </span>            :   /* We must identify jump threading opportunities before we release
<span class="lineNum">    6565 </span><span class="lineCov">    1167974 :      the datastructures built by VRP.  */</span>
<span class="lineNum">    6566 </span>            :   identify_jump_threads (&amp;vrp_prop.vr_values);
<span class="lineNum">    6567 </span>            : 
<span class="lineNum">    6568 </span><span class="lineCov">    1167974 :   /* A comparison of an SSA_NAME against a constant where the SSA_NAME</span>
<span class="lineNum">    6569 </span>            :      was set by a type conversion can often be rewritten to use the
<span class="lineNum">    6570 </span><span class="lineCov">    1167974 :      RHS of the type conversion.</span>
<span class="lineNum">    6571 </span>            : 
<span class="lineNum">    6572 </span><span class="lineCov">        859 :      However, doing so inhibits jump threading through the comparison.</span>
<span class="lineNum">    6573 </span><span class="lineCov">        859 :      So that transformation is not performed until after jump threading</span>
<span class="lineNum">    6574 </span><span class="lineCov">        859 :      is complete.  */</span>
<span class="lineNum">    6575 </span>            :   basic_block bb;
<span class="lineNum">    6576 </span>            :   FOR_EACH_BB_FN (bb, cfun)
<span class="lineNum">    6577 </span>            :     {
<span class="lineNum">    6578 </span><span class="lineCov">  109652852 :       gimple *last = last_stmt (bb);</span>
<span class="lineNum">    6579 </span>            :       if (last &amp;&amp; gimple_code (last) == GIMPLE_COND)
<span class="lineNum">    6580 </span><span class="lineCov">   53658452 :         vrp_prop.vr_values.simplify_cond_using_ranges_2 (as_a &lt;gcond *&gt; (last));</span>
<span class="lineNum">    6581 </span><span class="lineCov">   53658452 :     }</span>
<span class="lineNum">    6582 </span>            : 
<span class="lineNum">    6583 </span>            :   free_numbers_of_iterations_estimates (cfun);
<span class="lineNum">    6584 </span><span class="lineCov">   46549699 : </span>
<span class="lineNum">    6585 </span><span class="lineCov">   46549699 :   /* ASSERT_EXPRs must be removed before finalizing jump threads</span>
<span class="lineNum">    6586 </span><span class="lineCov">   46549699 :      as finalizing jump threads calls the CFG cleanup code which</span>
<span class="lineNum">    6587 </span><span class="lineCov">   14638211 :      does not properly handle ASSERT_EXPRs.  */</span>
<span class="lineNum">    6588 </span><span class="lineCov">   14602248 :   remove_range_assertions ();</span>
<span class="lineNum">    6589 </span><span class="lineCov">   13122926 : </span>
<span class="lineNum">    6590 </span>            :   /* If we exposed any new variables, go ahead and put them into
<span class="lineNum">    6591 </span>            :      SSA form now, before we handle jump threading.  This simplifies
<span class="lineNum">    6592 </span><span class="lineCov">   32435037 :      interactions between rewriting of _DECL nodes into SSA form</span>
<span class="lineNum">    6593 </span><span class="lineCov">   13023518 :      and rewriting SSA_NAME nodes into SSA form after block</span>
<span class="lineNum">    6594 </span><span class="lineCov">    3139082 :      duplication and CFG manipulation.  */</span>
<span class="lineNum">    6595 </span><span class="lineCov">    9637609 :   update_ssa (TODO_update_ssa);</span>
<span class="lineNum">    6596 </span><span class="lineCov">    9582346 : </span>
<span class="lineNum">    6597 </span><span class="lineCov">    9582346 :   /* We identified all the jump threading opportunities earlier, but could</span>
<span class="lineNum">    6598 </span><span class="lineCov">   19164692 :      not transform the CFG at that time.  This routine transforms the</span>
<span class="lineNum">    6599 </span>            :      CFG and arranges for the dominator tree to be rebuilt if necessary.
<span class="lineNum">    6600 </span>            : 
<span class="lineNum">    6601 </span>            :      Note the SSA graph update will occur during the normal TODO
<span class="lineNum">    6602 </span>            :      processing by the pass manager.  */
<span class="lineNum">    6603 </span>            :   thread_through_all_blocks (false);
<span class="lineNum">    6604 </span>            : 
<span class="lineNum">    6605 </span>            :   vrp_prop.vr_values.cleanup_edges_and_switches ();
<span class="lineNum">    6606 </span>            :   threadedge_finalize_values ();
<span class="lineNum">    6607 </span>            : 
<span class="lineNum">    6608 </span>            :   scev_finalize ();
<span class="lineNum">    6609 </span>            :   loop_optimizer_finalize ();
<span class="lineNum">    6610 </span><span class="lineCov">    1167974 :   return 0;</span>
<span class="lineNum">    6611 </span><span class="lineCov">      52565 : }</span>
<span class="lineNum">    6612 </span>            : 
<span class="lineNum">    6613 </span><span class="lineCov">    4671896 : namespace {</span>
<span class="lineNum">    6614 </span><span class="lineCov">    1167974 : </span>
<span class="lineNum">    6615 </span><span class="lineCov">    1167974 : const pass_data pass_data_vrp =</span>
<span class="lineNum">    6616 </span>            : {
<span class="lineNum">    6617 </span><span class="lineCov">    1167974 :   GIMPLE_PASS, /* type */</span>
<span class="lineNum">    6618 </span><span class="lineCov">      52565 :   &quot;vrp&quot;, /* name */</span>
<span class="lineNum">    6619 </span><span class="lineCov">    1167974 :   OPTGROUP_NONE, /* optinfo_flags */</span>
<span class="lineNum">    6620 </span>            :   TV_TREE_VRP, /* tv_id */
<span class="lineNum">    6621 </span>            :   PROP_ssa, /* properties_required */
<span class="lineNum">    6622 </span>            :   0, /* properties_provided */
<span class="lineNum">    6623 </span>            :   0, /* properties_destroyed */
<span class="lineNum">    6624 </span>            :   0, /* todo_flags_start */
<span class="lineNum">    6625 </span>            :   ( TODO_cleanup_cfg | TODO_update_ssa ), /* todo_flags_finish */
<span class="lineNum">    6626 </span>            : };
<span class="lineNum">    6627 </span>            : 
<span class="lineNum">    6628 </span>            : class pass_vrp : public gimple_opt_pass
<span class="lineNum">    6629 </span>            : {
<span class="lineNum">    6630 </span>            : public:
<span class="lineNum">    6631 </span>            :   pass_vrp (gcc::context *ctxt)
<span class="lineNum">    6632 </span>            :     : gimple_opt_pass (pass_data_vrp, ctxt), warn_array_bounds_p (false)
<span class="lineNum">    6633 </span>            :   {}
<a name="6634"><span class="lineNum">    6634 </span>            : </a>
<a name="6635"><span class="lineNum">    6635 </span>            :   /* opt_pass methods: */</a>
<span class="lineNum">    6636 </span>            :   opt_pass * clone () { return new pass_vrp (m_ctxt); }
<span class="lineNum">    6637 </span>            :   void set_pass_param (unsigned int n, bool param)
<span class="lineNum">    6638 </span>            :     {
<span class="lineNum">    6639 </span>            :       gcc_assert (n == 0);
<a name="6640"><span class="lineNum">    6640 </span>            :       warn_array_bounds_p = param;</a>
<a name="6641"><span class="lineNum">    6641 </span>            :     }</a>
<span class="lineNum">    6642 </span>            :   virtual bool gate (function *) { return flag_tree_vrp != 0; }
<span class="lineNum">    6643 </span>            :   virtual unsigned int execute (function *)
<span class="lineNum">    6644 </span>            :     { return execute_vrp (warn_array_bounds_p); }
<span class="lineNum">    6645 </span>            : 
<span class="lineNum">    6646 </span>            :  private:
<span class="lineNum">    6647 </span>            :   bool warn_array_bounds_p;
<span class="lineNum">    6648 </span>            : }; // class pass_vrp
<span class="lineNum">    6649 </span>            : 
<span class="lineNum">    6650 </span>            : } // anon namespace
<a name="6651"><span class="lineNum">    6651 </span>            : </a>
<span class="lineNum">    6652 </span>            : gimple_opt_pass *
<span class="lineNum">    6653 </span>            : make_pass_vrp (gcc::context *ctxt)
<span class="lineNum">    6654 </span>            : {
<span class="lineNum">    6655 </span>            :   return new pass_vrp (ctxt);
<span class="lineNum">    6656 </span>            : }
<span class="lineNum">    6657 </span>            : 
<span class="lineNum">    6658 </span>            : 
<span class="lineNum">    6659 </span>            : /* Worker for determine_value_range.  */
<span class="lineNum">    6660 </span>            : 
<span class="lineNum">    6661 </span>            : static void
<span class="lineNum">    6662 </span>            : determine_value_range_1 (value_range *vr, tree expr)
<span class="lineNum">    6663 </span>            : {
<span class="lineNum">    6664 </span>            :   if (BINARY_CLASS_P (expr))
<span class="lineNum">    6665 </span>            :     {
<span class="lineNum">    6666 </span><span class="lineCov">    1167974 :       value_range vr0 = VR_INITIALIZER, vr1 = VR_INITIALIZER;</span>
<span class="lineNum">    6667 </span>            :       determine_value_range_1 (&amp;vr0, TREE_OPERAND (expr, 0));
<span class="lineNum">    6668 </span>            :       determine_value_range_1 (&amp;vr1, TREE_OPERAND (expr, 1));
<span class="lineNum">    6669 </span><span class="lineCov">    1167974 :       extract_range_from_binary_expr_1 (vr, TREE_CODE (expr), TREE_TYPE (expr),</span>
<span class="lineNum">    6670 </span><span class="lineCov">    1167974 :                                         &amp;vr0, &amp;vr1);</span>
<span class="lineNum">    6671 </span><span class="lineCov">    1167974 :     }</span>
<span class="lineNum">    6672 </span>            :   else if (UNARY_CLASS_P (expr))
<span class="lineNum">    6673 </span>            :     {
<span class="lineNum">    6674 </span>            :       value_range vr0 = VR_INITIALIZER;
<span class="lineNum">    6675 </span>            :       determine_value_range_1 (&amp;vr0, TREE_OPERAND (expr, 0));
<span class="lineNum">    6676 </span><span class="lineCov">    1167974 :       extract_range_from_unary_expr (vr, TREE_CODE (expr), TREE_TYPE (expr),</span>
<span class="lineNum">    6677 </span>            :                                      &amp;vr0, TREE_TYPE (TREE_OPERAND (expr, 0)));
<span class="lineNum">    6678 </span><span class="lineCov">    1167974 :     }</span>
<span class="lineNum">    6679 </span>            :   else if (TREE_CODE (expr) == INTEGER_CST)
<span class="lineNum">    6680 </span>            :     set_value_range_to_value (vr, expr, NULL);
<span class="lineNum">    6681 </span><span class="lineCov">    1167974 :   else</span>
<span class="lineNum">    6682 </span>            :     {
<span class="lineNum">    6683 </span><span class="lineCov">    1167974 :       value_range_type kind;</span>
<span class="lineNum">    6684 </span><span class="lineCov">    1167974 :       wide_int min, max;</span>
<span class="lineNum">    6685 </span><span class="lineCov">    1167974 :       /* For SSA names try to extract range info computed by VRP.  Otherwise</span>
<span class="lineNum">    6686 </span><span class="lineCov">    1167974 :          fall back to varying.  */</span>
<span class="lineNum">    6687 </span>            :       if (TREE_CODE (expr) == SSA_NAME
<span class="lineNum">    6688 </span>            :           &amp;&amp; INTEGRAL_TYPE_P (TREE_TYPE (expr))
<span class="lineNum">    6689 </span>            :           &amp;&amp; (kind = get_range_info (expr, &amp;min, &amp;max)) != VR_VARYING)
<span class="lineNum">    6690 </span><span class="lineCov">    1167974 :         set_value_range (vr, kind, wide_int_to_tree (TREE_TYPE (expr), min),</span>
<span class="lineNum">    6691 </span>            :                          wide_int_to_tree (TREE_TYPE (expr), max), NULL);
<span class="lineNum">    6692 </span>            :       else
<span class="lineNum">    6693 </span>            :         set_value_range_to_varying (vr);
<span class="lineNum">    6694 </span>            :     }
<span class="lineNum">    6695 </span>            : }
<span class="lineNum">    6696 </span>            : 
<span class="lineNum">    6697 </span>            : /* Compute a value-range for EXPR and set it in *MIN and *MAX.  Return
<span class="lineNum">    6698 </span>            :    the determined range type.  */
<span class="lineNum">    6699 </span><span class="lineCov">    1167974 : </span>
<span class="lineNum">    6700 </span><span class="lineCov">   13556182 : value_range_type</span>
<span class="lineNum">    6701 </span>            : determine_value_range (tree expr, wide_int *min, wide_int *max)
<span class="lineNum">    6702 </span><span class="lineCov">   12388208 : {</span>
<span class="lineNum">    6703 </span><span class="lineCov">   12388208 :   value_range vr = VR_INITIALIZER;</span>
<span class="lineNum">    6704 </span><span class="lineCov">    8998948 :   determine_value_range_1 (&amp;vr, expr);</span>
<span class="lineNum">    6705 </span>            :   if ((vr.type == VR_RANGE
<span class="lineNum">    6706 </span>            :        || vr.type == VR_ANTI_RANGE)
<span class="lineNum">    6707 </span><span class="lineCov">    1167974 :       &amp;&amp; !symbolic_range_p (&amp;vr))</span>
<span class="lineNum">    6708 </span>            :     {
<span class="lineNum">    6709 </span>            :       *min = wi::to_wide (vr.min);
<span class="lineNum">    6710 </span>            :       *max = wi::to_wide (vr.max);
<span class="lineNum">    6711 </span>            :       return vr.type;
<span class="lineNum">    6712 </span><span class="lineCov">    1167974 :     }</span>
<span class="lineNum">    6713 </span>            : 
<span class="lineNum">    6714 </span>            :   return VR_VARYING;
<span class="lineNum">    6715 </span>            : }
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.0</a></td></tr>
  </table>
  <br>
<h3>LCOV profile is generated on x86_64 machine using following configure options: configure --disable-bootstrap --enable-coverage=opt --enable-languages=c,c++,fortran,go,jit,lto --enable-host-shared. GCC test suite is run with the built compiler.</h3></body></html>
