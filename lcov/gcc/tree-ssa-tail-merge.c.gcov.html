<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - gcc.info - gcc/tree-ssa-tail-merge.c</title>
  <link rel="stylesheet" type="text/css" href="../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../index.html">top level</a> - <a href="index.html">gcc</a> - tree-ssa-tail-merge.c<span style="font-size: 80%;"> (source / <a href="tree-ssa-tail-merge.c.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">gcc.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">699</td>
            <td class="headerCovTableEntry">738</td>
            <td class="headerCovTableEntryHi">94.7 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2018-09-22 10:58:49</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">50</td>
            <td class="headerCovTableEntry">56</td>
            <td class="headerCovTableEntryMed">89.3 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /* Tail merging for gimple.</a>
<span class="lineNum">       2 </span>            :    Copyright (C) 2011-2018 Free Software Foundation, Inc.
<span class="lineNum">       3 </span>            :    Contributed by Tom de Vries (tom@codesourcery.com)
<span class="lineNum">       4 </span>            : 
<span class="lineNum">       5 </span>            : This file is part of GCC.
<span class="lineNum">       6 </span>            : 
<span class="lineNum">       7 </span>            : GCC is free software; you can redistribute it and/or modify
<span class="lineNum">       8 </span>            : it under the terms of the GNU General Public License as published by
<span class="lineNum">       9 </span>            : the Free Software Foundation; either version 3, or (at your option)
<span class="lineNum">      10 </span>            : any later version.
<span class="lineNum">      11 </span>            : 
<span class="lineNum">      12 </span>            : GCC is distributed in the hope that it will be useful,
<span class="lineNum">      13 </span>            : but WITHOUT ANY WARRANTY; without even the implied warranty of
<span class="lineNum">      14 </span>            : MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
<span class="lineNum">      15 </span>            : GNU General Public License for more details.
<span class="lineNum">      16 </span>            : 
<span class="lineNum">      17 </span>            : You should have received a copy of the GNU General Public License
<span class="lineNum">      18 </span>            : along with GCC; see the file COPYING3.  If not see
<span class="lineNum">      19 </span>            : &lt;http://www.gnu.org/licenses/&gt;.  */
<span class="lineNum">      20 </span>            : 
<span class="lineNum">      21 </span>            : /* Pass overview.
<span class="lineNum">      22 </span>            : 
<span class="lineNum">      23 </span>            : 
<span class="lineNum">      24 </span>            :    MOTIVATIONAL EXAMPLE
<span class="lineNum">      25 </span>            : 
<span class="lineNum">      26 </span>            :    gimple representation of gcc/testsuite/gcc.dg/pr43864.c at
<span class="lineNum">      27 </span>            : 
<span class="lineNum">      28 </span>            :    hprofStartupp (charD.1 * outputFileNameD.2600, charD.1 * ctxD.2601)
<span class="lineNum">      29 </span>            :    {
<span class="lineNum">      30 </span>            :      struct FILED.1638 * fpD.2605;
<span class="lineNum">      31 </span>            :      charD.1 fileNameD.2604[1000];
<span class="lineNum">      32 </span>            :      intD.0 D.3915;
<span class="lineNum">      33 </span>            :      const charD.1 * restrict outputFileName.0D.3914;
<span class="lineNum">      34 </span>            : 
<span class="lineNum">      35 </span>            :      # BLOCK 2 freq:10000
<span class="lineNum">      36 </span>            :      # PRED: ENTRY [100.0%]  (fallthru,exec)
<span class="lineNum">      37 </span>            :      # PT = nonlocal { D.3926 } (restr)
<span class="lineNum">      38 </span>            :      outputFileName.0D.3914_3
<span class="lineNum">      39 </span>            :        = (const charD.1 * restrict) outputFileNameD.2600_2(D);
<span class="lineNum">      40 </span>            :      # .MEMD.3923_13 = VDEF &lt;.MEMD.3923_12(D)&gt;
<span class="lineNum">      41 </span>            :      # USE = nonlocal null { fileNameD.2604 D.3926 } (restr)
<span class="lineNum">      42 </span>            :      # CLB = nonlocal null { fileNameD.2604 D.3926 } (restr)
<span class="lineNum">      43 </span>            :      sprintfD.759 (&amp;fileNameD.2604, outputFileName.0D.3914_3);
<span class="lineNum">      44 </span>            :      # .MEMD.3923_14 = VDEF &lt;.MEMD.3923_13&gt;
<span class="lineNum">      45 </span>            :      # USE = nonlocal null { fileNameD.2604 D.3926 } (restr)
<span class="lineNum">      46 </span>            :      # CLB = nonlocal null { fileNameD.2604 D.3926 } (restr)
<span class="lineNum">      47 </span>            :      D.3915_4 = accessD.2606 (&amp;fileNameD.2604, 1);
<span class="lineNum">      48 </span>            :      if (D.3915_4 == 0)
<span class="lineNum">      49 </span>            :        goto &lt;bb 3&gt;;
<span class="lineNum">      50 </span>            :      else
<span class="lineNum">      51 </span>            :        goto &lt;bb 4&gt;;
<span class="lineNum">      52 </span>            :      # SUCC: 3 [10.0%]  (true,exec) 4 [90.0%]  (false,exec)
<span class="lineNum">      53 </span>            : 
<span class="lineNum">      54 </span>            :      # BLOCK 3 freq:1000
<span class="lineNum">      55 </span>            :      # PRED: 2 [10.0%]  (true,exec)
<span class="lineNum">      56 </span>            :      # .MEMD.3923_15 = VDEF &lt;.MEMD.3923_14&gt;
<span class="lineNum">      57 </span>            :      # USE = nonlocal null { fileNameD.2604 D.3926 } (restr)
<span class="lineNum">      58 </span>            :      # CLB = nonlocal null { fileNameD.2604 D.3926 } (restr)
<span class="lineNum">      59 </span>            :      freeD.898 (ctxD.2601_5(D));
<span class="lineNum">      60 </span>            :      goto &lt;bb 7&gt;;
<span class="lineNum">      61 </span>            :      # SUCC: 7 [100.0%]  (fallthru,exec)
<span class="lineNum">      62 </span>            : 
<span class="lineNum">      63 </span>            :      # BLOCK 4 freq:9000
<span class="lineNum">      64 </span>            :      # PRED: 2 [90.0%]  (false,exec)
<span class="lineNum">      65 </span>            :      # .MEMD.3923_16 = VDEF &lt;.MEMD.3923_14&gt;
<span class="lineNum">      66 </span>            :      # PT = nonlocal escaped
<span class="lineNum">      67 </span>            :      # USE = nonlocal null { fileNameD.2604 D.3926 } (restr)
<span class="lineNum">      68 </span>            :      # CLB = nonlocal null { fileNameD.2604 D.3926 } (restr)
<span class="lineNum">      69 </span>            :      fpD.2605_8 = fopenD.1805 (&amp;fileNameD.2604[0], 0B);
<span class="lineNum">      70 </span>            :      if (fpD.2605_8 == 0B)
<span class="lineNum">      71 </span>            :        goto &lt;bb 5&gt;;
<span class="lineNum">      72 </span>            :      else
<span class="lineNum">      73 </span>            :        goto &lt;bb 6&gt;;
<span class="lineNum">      74 </span>            :      # SUCC: 5 [1.9%]  (true,exec) 6 [98.1%]  (false,exec)
<span class="lineNum">      75 </span>            : 
<span class="lineNum">      76 </span>            :      # BLOCK 5 freq:173
<span class="lineNum">      77 </span>            :      # PRED: 4 [1.9%]  (true,exec)
<span class="lineNum">      78 </span>            :      # .MEMD.3923_17 = VDEF &lt;.MEMD.3923_16&gt;
<span class="lineNum">      79 </span>            :      # USE = nonlocal null { fileNameD.2604 D.3926 } (restr)
<span class="lineNum">      80 </span>            :      # CLB = nonlocal null { fileNameD.2604 D.3926 } (restr)
<span class="lineNum">      81 </span>            :      freeD.898 (ctxD.2601_5(D));
<span class="lineNum">      82 </span>            :      goto &lt;bb 7&gt;;
<span class="lineNum">      83 </span>            :      # SUCC: 7 [100.0%]  (fallthru,exec)
<span class="lineNum">      84 </span>            : 
<span class="lineNum">      85 </span>            :      # BLOCK 6 freq:8827
<span class="lineNum">      86 </span>            :      # PRED: 4 [98.1%]  (false,exec)
<span class="lineNum">      87 </span>            :      # .MEMD.3923_18 = VDEF &lt;.MEMD.3923_16&gt;
<span class="lineNum">      88 </span>            :      # USE = nonlocal null { fileNameD.2604 D.3926 } (restr)
<span class="lineNum">      89 </span>            :      # CLB = nonlocal null { fileNameD.2604 D.3926 } (restr)
<span class="lineNum">      90 </span>            :      fooD.2599 (outputFileNameD.2600_2(D), fpD.2605_8);
<span class="lineNum">      91 </span>            :      # SUCC: 7 [100.0%]  (fallthru,exec)
<span class="lineNum">      92 </span>            : 
<span class="lineNum">      93 </span>            :      # BLOCK 7 freq:10000
<span class="lineNum">      94 </span>            :      # PRED: 3 [100.0%]  (fallthru,exec) 5 [100.0%]  (fallthru,exec)
<span class="lineNum">      95 </span>            :              6 [100.0%]  (fallthru,exec)
<span class="lineNum">      96 </span>            :      # PT = nonlocal null
<span class="lineNum">      97 </span>            : 
<span class="lineNum">      98 </span>            :      # ctxD.2601_1 = PHI &lt;0B(3), 0B(5), ctxD.2601_5(D)(6)&gt;
<span class="lineNum">      99 </span>            :      # .MEMD.3923_11 = PHI &lt;.MEMD.3923_15(3), .MEMD.3923_17(5),
<span class="lineNum">     100 </span>            :                             .MEMD.3923_18(6)&gt;
<span class="lineNum">     101 </span>            :      # VUSE &lt;.MEMD.3923_11&gt;
<span class="lineNum">     102 </span>            :      return ctxD.2601_1;
<span class="lineNum">     103 </span>            :      # SUCC: EXIT [100.0%]
<span class="lineNum">     104 </span>            :    }
<span class="lineNum">     105 </span>            : 
<span class="lineNum">     106 </span>            :    bb 3 and bb 5 can be merged.  The blocks have different predecessors, but the
<span class="lineNum">     107 </span>            :    same successors, and the same operations.
<span class="lineNum">     108 </span>            : 
<span class="lineNum">     109 </span>            : 
<span class="lineNum">     110 </span>            :    CONTEXT
<span class="lineNum">     111 </span>            : 
<span class="lineNum">     112 </span>            :    A technique called tail merging (or cross jumping) can fix the example
<span class="lineNum">     113 </span>            :    above.  For a block, we look for common code at the end (the tail) of the
<span class="lineNum">     114 </span>            :    predecessor blocks, and insert jumps from one block to the other.
<span class="lineNum">     115 </span>            :    The example is a special case for tail merging, in that 2 whole blocks
<span class="lineNum">     116 </span>            :    can be merged, rather than just the end parts of it.
<span class="lineNum">     117 </span>            :    We currently only focus on whole block merging, so in that sense
<span class="lineNum">     118 </span>            :    calling this pass tail merge is a bit of a misnomer.
<span class="lineNum">     119 </span>            : 
<span class="lineNum">     120 </span>            :    We distinguish 2 kinds of situations in which blocks can be merged:
<span class="lineNum">     121 </span>            :    - same operations, same predecessors.  The successor edges coming from one
<span class="lineNum">     122 </span>            :      block are redirected to come from the other block.
<span class="lineNum">     123 </span>            :    - same operations, same successors.  The predecessor edges entering one block
<span class="lineNum">     124 </span>            :      are redirected to enter the other block.  Note that this operation might
<span class="lineNum">     125 </span>            :      involve introducing phi operations.
<span class="lineNum">     126 </span>            : 
<span class="lineNum">     127 </span>            :    For efficient implementation, we would like to value numbers the blocks, and
<span class="lineNum">     128 </span>            :    have a comparison operator that tells us whether the blocks are equal.
<span class="lineNum">     129 </span>            :    Besides being runtime efficient, block value numbering should also abstract
<span class="lineNum">     130 </span>            :    from irrelevant differences in order of operations, much like normal value
<span class="lineNum">     131 </span>            :    numbering abstracts from irrelevant order of operations.
<span class="lineNum">     132 </span>            : 
<span class="lineNum">     133 </span>            :    For the first situation (same_operations, same predecessors), normal value
<span class="lineNum">     134 </span>            :    numbering fits well.  We can calculate a block value number based on the
<span class="lineNum">     135 </span>            :    value numbers of the defs and vdefs.
<span class="lineNum">     136 </span>            : 
<span class="lineNum">     137 </span>            :    For the second situation (same operations, same successors), this approach
<span class="lineNum">     138 </span>            :    doesn't work so well.  We can illustrate this using the example.  The calls
<span class="lineNum">     139 </span>            :    to free use different vdefs: MEMD.3923_16 and MEMD.3923_14, and these will
<span class="lineNum">     140 </span>            :    remain different in value numbering, since they represent different memory
<span class="lineNum">     141 </span>            :    states.  So the resulting vdefs of the frees will be different in value
<span class="lineNum">     142 </span>            :    numbering, so the block value numbers will be different.
<span class="lineNum">     143 </span>            : 
<span class="lineNum">     144 </span>            :    The reason why we call the blocks equal is not because they define the same
<span class="lineNum">     145 </span>            :    values, but because uses in the blocks use (possibly different) defs in the
<span class="lineNum">     146 </span>            :    same way.  To be able to detect this efficiently, we need to do some kind of
<span class="lineNum">     147 </span>            :    reverse value numbering, meaning number the uses rather than the defs, and
<span class="lineNum">     148 </span>            :    calculate a block value number based on the value number of the uses.
<span class="lineNum">     149 </span>            :    Ideally, a block comparison operator will also indicate which phis are needed
<span class="lineNum">     150 </span>            :    to merge the blocks.
<span class="lineNum">     151 </span>            : 
<span class="lineNum">     152 </span>            :    For the moment, we don't do block value numbering, but we do insn-by-insn
<span class="lineNum">     153 </span>            :    matching, using scc value numbers to match operations with results, and
<span class="lineNum">     154 </span>            :    structural comparison otherwise, while ignoring vop mismatches.
<span class="lineNum">     155 </span>            : 
<span class="lineNum">     156 </span>            : 
<span class="lineNum">     157 </span>            :    IMPLEMENTATION
<span class="lineNum">     158 </span>            : 
<span class="lineNum">     159 </span>            :    1. The pass first determines all groups of blocks with the same successor
<span class="lineNum">     160 </span>            :       blocks.
<span class="lineNum">     161 </span>            :    2. Within each group, it tries to determine clusters of equal basic blocks.
<span class="lineNum">     162 </span>            :    3. The clusters are applied.
<span class="lineNum">     163 </span>            :    4. The same successor groups are updated.
<span class="lineNum">     164 </span>            :    5. This process is repeated from 2 onwards, until no more changes.
<span class="lineNum">     165 </span>            : 
<span class="lineNum">     166 </span>            : 
<span class="lineNum">     167 </span>            :    LIMITATIONS/TODO
<span class="lineNum">     168 </span>            : 
<span class="lineNum">     169 </span>            :    - block only
<span class="lineNum">     170 </span>            :    - handles only 'same operations, same successors'.
<span class="lineNum">     171 </span>            :      It handles same predecessors as a special subcase though.
<span class="lineNum">     172 </span>            :    - does not implement the reverse value numbering and block value numbering.
<span class="lineNum">     173 </span>            :    - improve memory allocation: use garbage collected memory, obstacks,
<span class="lineNum">     174 </span>            :      allocpools where appropriate.
<span class="lineNum">     175 </span>            :    - no insertion of gimple_reg phis,  We only introduce vop-phis.
<span class="lineNum">     176 </span>            :    - handle blocks with gimple_reg phi_nodes.
<span class="lineNum">     177 </span>            : 
<span class="lineNum">     178 </span>            : 
<span class="lineNum">     179 </span>            :    PASS PLACEMENT
<span class="lineNum">     180 </span>            :    This 'pass' is not a stand-alone gimple pass, but runs as part of
<span class="lineNum">     181 </span>            :    pass_pre, in order to share the value numbering.
<span class="lineNum">     182 </span>            : 
<span class="lineNum">     183 </span>            : 
<span class="lineNum">     184 </span>            :    SWITCHES
<span class="lineNum">     185 </span>            : 
<span class="lineNum">     186 </span>            :    - ftree-tail-merge.  On at -O2.  We may have to enable it only at -Os.  */
<span class="lineNum">     187 </span>            : 
<span class="lineNum">     188 </span>            : #include &quot;config.h&quot;
<span class="lineNum">     189 </span>            : #include &quot;system.h&quot;
<span class="lineNum">     190 </span>            : #include &quot;coretypes.h&quot;
<span class="lineNum">     191 </span>            : #include &quot;backend.h&quot;
<span class="lineNum">     192 </span>            : #include &quot;tree.h&quot;
<span class="lineNum">     193 </span>            : #include &quot;gimple.h&quot;
<span class="lineNum">     194 </span>            : #include &quot;cfghooks.h&quot;
<span class="lineNum">     195 </span>            : #include &quot;tree-pass.h&quot;
<span class="lineNum">     196 </span>            : #include &quot;ssa.h&quot;
<span class="lineNum">     197 </span>            : #include &quot;fold-const.h&quot;
<span class="lineNum">     198 </span>            : #include &quot;trans-mem.h&quot;
<span class="lineNum">     199 </span>            : #include &quot;cfganal.h&quot;
<span class="lineNum">     200 </span>            : #include &quot;cfgcleanup.h&quot;
<span class="lineNum">     201 </span>            : #include &quot;gimple-iterator.h&quot;
<span class="lineNum">     202 </span>            : #include &quot;tree-cfg.h&quot;
<span class="lineNum">     203 </span>            : #include &quot;tree-into-ssa.h&quot;
<span class="lineNum">     204 </span>            : #include &quot;params.h&quot;
<span class="lineNum">     205 </span>            : #include &quot;tree-ssa-sccvn.h&quot;
<span class="lineNum">     206 </span>            : #include &quot;cfgloop.h&quot;
<span class="lineNum">     207 </span>            : #include &quot;tree-eh.h&quot;
<span class="lineNum">     208 </span>            : #include &quot;tree-cfgcleanup.h&quot;
<span class="lineNum">     209 </span>            : 
<span class="lineNum">     210 </span>            : const int ignore_edge_flags = EDGE_DFS_BACK | EDGE_EXECUTABLE;
<span class="lineNum">     211 </span>            : 
<span class="lineNum">     212 </span>            : /* Describes a group of bbs with the same successors.  The successor bbs are
<span class="lineNum">     213 </span>            :    cached in succs, and the successor edge flags are cached in succ_flags.
<span class="lineNum">     214 </span>            :    If a bb has the EDGE_TRUE/FALSE_VALUE flags swapped compared to succ_flags,
<span class="lineNum">     215 </span>            :    it's marked in inverse.
<span class="lineNum">     216 </span>            :    Additionally, the hash value for the struct is cached in hashval, and
<span class="lineNum">     217 </span>            :    in_worklist indicates whether it's currently part of worklist.  */
<span class="lineNum">     218 </span>            : 
<span class="lineNum">     219 </span>            : struct same_succ : pointer_hash &lt;same_succ&gt;
<span class="lineNum">     220 </span>            : {
<span class="lineNum">     221 </span>            :   /* The bbs that have the same successor bbs.  */
<span class="lineNum">     222 </span>            :   bitmap bbs;
<span class="lineNum">     223 </span>            :   /* The successor bbs.  */
<span class="lineNum">     224 </span>            :   bitmap succs;
<span class="lineNum">     225 </span>            :   /* Indicates whether the EDGE_TRUE/FALSE_VALUEs of succ_flags are swapped for
<span class="lineNum">     226 </span>            :      bb.  */
<span class="lineNum">     227 </span>            :   bitmap inverse;
<span class="lineNum">     228 </span>            :   /* The edge flags for each of the successor bbs.  */
<span class="lineNum">     229 </span>            :   vec&lt;int&gt; succ_flags;
<span class="lineNum">     230 </span>            :   /* Indicates whether the struct is currently in the worklist.  */
<span class="lineNum">     231 </span>            :   bool in_worklist;
<span class="lineNum">     232 </span>            :   /* The hash value of the struct.  */
<span class="lineNum">     233 </span>            :   hashval_t hashval;
<span class="lineNum">     234 </span>            : 
<span class="lineNum">     235 </span>            :   /* hash_table support.  */
<span class="lineNum">     236 </span>            :   static inline hashval_t hash (const same_succ *);
<span class="lineNum">     237 </span>            :   static int equal (const same_succ *, const same_succ *);
<span class="lineNum">     238 </span>            :   static void remove (same_succ *);
<span class="lineNum">     239 </span>            : };
<span class="lineNum">     240 </span>            : 
<span class="lineNum">     241 </span>            : /* hash routine for hash_table support, returns hashval of E.  */
<a name="242"><span class="lineNum">     242 </span>            : </a>
<span class="lineNum">     243 </span>            : inline hashval_t
<span class="lineNum">     244 </span><span class="lineNoCov">          0 : same_succ::hash (const same_succ *e)</span>
<span class="lineNum">     245 </span>            : {
<span class="lineNum">     246 </span><span class="lineCov">     477819 :   return e-&gt;hashval;</span>
<span class="lineNum">     247 </span>            : }
<span class="lineNum">     248 </span>            : 
<span class="lineNum">     249 </span>            : /* A group of bbs where 1 bb from bbs can replace the other bbs.  */
<span class="lineNum">     250 </span>            : 
<span class="lineNum">     251 </span>            : struct bb_cluster
<span class="lineNum">     252 </span>            : {
<span class="lineNum">     253 </span>            :   /* The bbs in the cluster.  */
<span class="lineNum">     254 </span>            :   bitmap bbs;
<span class="lineNum">     255 </span>            :   /* The preds of the bbs in the cluster.  */
<span class="lineNum">     256 </span>            :   bitmap preds;
<span class="lineNum">     257 </span>            :   /* Index in all_clusters vector.  */
<span class="lineNum">     258 </span>            :   int index;
<span class="lineNum">     259 </span>            :   /* The bb to replace the cluster with.  */
<span class="lineNum">     260 </span>            :   basic_block rep_bb;
<span class="lineNum">     261 </span>            : };
<span class="lineNum">     262 </span>            : 
<span class="lineNum">     263 </span>            : /* Per bb-info.  */
<span class="lineNum">     264 </span>            : 
<span class="lineNum">     265 </span>            : struct aux_bb_info
<span class="lineNum">     266 </span>            : {
<span class="lineNum">     267 </span>            :   /* The number of non-debug statements in the bb.  */
<span class="lineNum">     268 </span>            :   int size;
<span class="lineNum">     269 </span>            :   /* The same_succ that this bb is a member of.  */
<span class="lineNum">     270 </span>            :   same_succ *bb_same_succ;
<span class="lineNum">     271 </span>            :   /* The cluster that this bb is a member of.  */
<span class="lineNum">     272 </span>            :   bb_cluster *cluster;
<span class="lineNum">     273 </span>            :   /* The vop state at the exit of a bb.  This is shortlived data, used to
<span class="lineNum">     274 </span>            :      communicate data between update_block_by and update_vuses.  */
<span class="lineNum">     275 </span>            :   tree vop_at_exit;
<span class="lineNum">     276 </span>            :   /* The bb that either contains or is dominated by the dependencies of the
<span class="lineNum">     277 </span>            :      bb.  */
<span class="lineNum">     278 </span>            :   basic_block dep_bb;
<span class="lineNum">     279 </span>            : };
<span class="lineNum">     280 </span>            : 
<span class="lineNum">     281 </span>            : /* Macros to access the fields of struct aux_bb_info.  */
<span class="lineNum">     282 </span>            : 
<span class="lineNum">     283 </span>            : #define BB_SIZE(bb) (((struct aux_bb_info *)bb-&gt;aux)-&gt;size)
<span class="lineNum">     284 </span>            : #define BB_SAME_SUCC(bb) (((struct aux_bb_info *)bb-&gt;aux)-&gt;bb_same_succ)
<span class="lineNum">     285 </span>            : #define BB_CLUSTER(bb) (((struct aux_bb_info *)bb-&gt;aux)-&gt;cluster)
<span class="lineNum">     286 </span>            : #define BB_VOP_AT_EXIT(bb) (((struct aux_bb_info *)bb-&gt;aux)-&gt;vop_at_exit)
<span class="lineNum">     287 </span>            : #define BB_DEP_BB(bb) (((struct aux_bb_info *)bb-&gt;aux)-&gt;dep_bb)
<span class="lineNum">     288 </span>            : 
<span class="lineNum">     289 </span>            : /* Valueization helper querying the VN lattice.  */
<a name="290"><span class="lineNum">     290 </span>            : </a>
<span class="lineNum">     291 </span>            : static tree
<span class="lineNum">     292 </span><span class="lineCov">    7224503 : tail_merge_valueize (tree name)</span>
<span class="lineNum">     293 </span>            : {
<span class="lineNum">     294 </span><span class="lineCov">    7224503 :   if (TREE_CODE (name) == SSA_NAME</span>
<span class="lineNum">     295 </span><span class="lineCov">    7224503 :       &amp;&amp; has_VN_INFO (name))</span>
<span class="lineNum">     296 </span>            :     {
<span class="lineNum">     297 </span><span class="lineCov">    2355359 :       tree tem = VN_INFO (name)-&gt;valnum;</span>
<span class="lineNum">     298 </span><span class="lineCov">    2355359 :       if (tem != VN_TOP)</span>
<span class="lineNum">     299 </span><span class="lineCov">    2355359 :         return tem;</span>
<span class="lineNum">     300 </span>            :     }
<span class="lineNum">     301 </span>            :   return name;
<span class="lineNum">     302 </span>            : }
<span class="lineNum">     303 </span>            : 
<span class="lineNum">     304 </span>            : /* Returns true if the only effect a statement STMT has, is to define locally
<span class="lineNum">     305 </span>            :    used SSA_NAMEs.  */
<span class="lineNum">     306 </span>            : 
<span class="lineNum">     307 </span>            : static bool
<span class="lineNum">     308 </span><span class="lineCov">   23154037 : stmt_local_def (gimple *stmt)</span>
<span class="lineNum">     309 </span>            : {
<span class="lineNum">     310 </span><span class="lineCov">   23154037 :   basic_block bb, def_bb;</span>
<span class="lineNum">     311 </span><span class="lineCov">   23154037 :   imm_use_iterator iter;</span>
<span class="lineNum">     312 </span><span class="lineCov">   23154037 :   use_operand_p use_p;</span>
<span class="lineNum">     313 </span><span class="lineCov">   23154037 :   tree val;</span>
<span class="lineNum">     314 </span><span class="lineCov">   23154037 :   def_operand_p def_p;</span>
<span class="lineNum">     315 </span>            : 
<span class="lineNum">     316 </span><span class="lineCov">   23154037 :   if (gimple_vdef (stmt) != NULL_TREE</span>
<span class="lineNum">     317 </span><span class="lineCov">   14245878 :       || gimple_has_side_effects (stmt)</span>
<span class="lineNum">     318 </span><span class="lineCov">   13835739 :       || gimple_could_trap_p_1 (stmt, false, false)</span>
<span class="lineNum">     319 </span><span class="lineCov">   22143069 :       || gimple_vuse (stmt) != NULL_TREE</span>
<span class="lineNum">     320 </span>            :       /* Copied from tree-ssa-ifcombine.c:bb_no_side_effects_p():
<span class="lineNum">     321 </span>            :          const calls don't match any of the above, yet they could
<span class="lineNum">     322 </span>            :          still have some side-effects - they could contain
<span class="lineNum">     323 </span>            :          gimple_could_trap_p statements, like floating point
<span class="lineNum">     324 </span>            :          exceptions or integer division by zero.  See PR70586.
<span class="lineNum">     325 </span>            :          FIXME: perhaps gimple_has_side_effects or gimple_could_trap_p
<span class="lineNum">     326 </span>            :          should handle this.  */
<span class="lineNum">     327 </span><span class="lineCov">   37886282 :       || is_gimple_call (stmt))</span>
<span class="lineNum">     328 </span><span class="lineCov">   13513457 :     return false;</span>
<span class="lineNum">     329 </span>            : 
<span class="lineNum">     330 </span><span class="lineCov">    9640580 :   def_p = SINGLE_SSA_DEF_OPERAND (stmt, SSA_OP_DEF);</span>
<span class="lineNum">     331 </span><span class="lineCov">    9640580 :   if (def_p == NULL)</span>
<span class="lineNum">     332 </span>            :     return false;
<span class="lineNum">     333 </span>            : 
<span class="lineNum">     334 </span><span class="lineCov">    4799944 :   val = DEF_FROM_PTR (def_p);</span>
<span class="lineNum">     335 </span><span class="lineCov">    4799944 :   if (val == NULL_TREE || TREE_CODE (val) != SSA_NAME)</span>
<span class="lineNum">     336 </span>            :     return false;
<span class="lineNum">     337 </span>            : 
<span class="lineNum">     338 </span><span class="lineCov">    4799944 :   def_bb = gimple_bb (stmt);</span>
<span class="lineNum">     339 </span>            : 
<span class="lineNum">     340 </span><span class="lineCov">    9940002 :   FOR_EACH_IMM_USE_FAST (use_p, iter, val)</span>
<span class="lineNum">     341 </span>            :     {
<span class="lineNum">     342 </span><span class="lineCov">   11993354 :       if (is_gimple_debug (USE_STMT (use_p)))</span>
<span class="lineNum">     343 </span>            :         continue;
<span class="lineNum">     344 </span><span class="lineCov">    5276788 :       bb = gimple_bb (USE_STMT (use_p));</span>
<span class="lineNum">     345 </span><span class="lineCov">    5276788 :       if (bb == def_bb)</span>
<span class="lineNum">     346 </span>            :         continue;
<span class="lineNum">     347 </span>            : 
<span class="lineNum">     348 </span><span class="lineCov">    1261995 :       if (gimple_code (USE_STMT (use_p)) == GIMPLE_PHI</span>
<span class="lineNum">     349 </span><span class="lineCov">    1261995 :           &amp;&amp; EDGE_PRED (bb, PHI_ARG_INDEX_FROM_USE (use_p))-&gt;src == def_bb)</span>
<span class="lineNum">     350 </span>            :         continue;
<span class="lineNum">     351 </span>            : 
<span class="lineNum">     352 </span>            :       return false;
<span class="lineNum">     353 </span>            :     }
<span class="lineNum">     354 </span>            : 
<span class="lineNum">     355 </span>            :   return true;
<span class="lineNum">     356 </span>            : }
<span class="lineNum">     357 </span>            : 
<span class="lineNum">     358 </span>            : /* Let GSI skip forwards over local defs.  */
<a name="359"><span class="lineNum">     359 </span>            : </a>
<span class="lineNum">     360 </span>            : static void
<span class="lineNum">     361 </span><span class="lineCov">    4920382 : gsi_advance_fw_nondebug_nonlocal (gimple_stmt_iterator *gsi)</span>
<span class="lineNum">     362 </span>            : {
<span class="lineNum">     363 </span><span class="lineCov">    5232150 :   gimple *stmt;</span>
<span class="lineNum">     364 </span>            : 
<span class="lineNum">     365 </span><span class="lineCov">    5232150 :   while (true)</span>
<span class="lineNum">     366 </span>            :     {
<span class="lineNum">     367 </span><span class="lineCov">   10464300 :       if (gsi_end_p (*gsi))</span>
<span class="lineNum">     368 </span>            :         return;
<span class="lineNum">     369 </span><span class="lineCov">    2057194 :       stmt = gsi_stmt (*gsi);</span>
<span class="lineNum">     370 </span><span class="lineCov">    2057194 :       if (!stmt_local_def (stmt))</span>
<span class="lineNum">     371 </span>            :         return;
<span class="lineNum">     372 </span>            :       gsi_next_nondebug (gsi);
<span class="lineNum">     373 </span>            :     }
<span class="lineNum">     374 </span>            : }
<span class="lineNum">     375 </span>            : 
<span class="lineNum">     376 </span>            : /* VAL1 and VAL2 are either:
<span class="lineNum">     377 </span>            :    - uses in BB1 and BB2, or
<span class="lineNum">     378 </span>            :    - phi alternatives for BB1 and BB2.
<span class="lineNum">     379 </span>            :    Return true if the uses have the same gvn value.  */
<a name="380"><span class="lineNum">     380 </span>            : </a>
<span class="lineNum">     381 </span>            : static bool
<span class="lineNum">     382 </span><span class="lineCov">     526950 : gvn_uses_equal (tree val1, tree val2)</span>
<span class="lineNum">     383 </span>            : {
<span class="lineNum">     384 </span><span class="lineCov">     526950 :   gcc_checking_assert (val1 != NULL_TREE &amp;&amp; val2 != NULL_TREE);</span>
<span class="lineNum">     385 </span>            : 
<span class="lineNum">     386 </span><span class="lineCov">     526950 :   if (val1 == val2)</span>
<span class="lineNum">     387 </span>            :     return true;
<span class="lineNum">     388 </span>            : 
<span class="lineNum">     389 </span><span class="lineCov">     526950 :   if (tail_merge_valueize (val1) != tail_merge_valueize (val2))</span>
<span class="lineNum">     390 </span>            :     return false;
<span class="lineNum">     391 </span>            : 
<span class="lineNum">     392 </span><span class="lineNoCov">          0 :   return ((TREE_CODE (val1) == SSA_NAME || CONSTANT_CLASS_P (val1))</span>
<span class="lineNum">     393 </span><span class="lineCov">       4201 :           &amp;&amp; (TREE_CODE (val2) == SSA_NAME || CONSTANT_CLASS_P (val2)));</span>
<span class="lineNum">     394 </span>            : }
<span class="lineNum">     395 </span>            : 
<span class="lineNum">     396 </span>            : /* Prints E to FILE.  */
<span class="lineNum">     397 </span>            : 
<span class="lineNum">     398 </span>            : static void
<span class="lineNum">     399 </span><span class="lineCov">         20 : same_succ_print (FILE *file, const same_succ *e)</span>
<span class="lineNum">     400 </span>            : {
<span class="lineNum">     401 </span><span class="lineCov">         20 :   unsigned int i;</span>
<span class="lineNum">     402 </span><span class="lineCov">         20 :   bitmap_print (file, e-&gt;bbs, &quot;bbs:&quot;, &quot;\n&quot;);</span>
<span class="lineNum">     403 </span><span class="lineCov">         20 :   bitmap_print (file, e-&gt;succs, &quot;succs:&quot;, &quot;\n&quot;);</span>
<span class="lineNum">     404 </span><span class="lineCov">         20 :   bitmap_print (file, e-&gt;inverse, &quot;inverse:&quot;, &quot;\n&quot;);</span>
<span class="lineNum">     405 </span><span class="lineCov">         20 :   fprintf (file, &quot;flags:&quot;);</span>
<span class="lineNum">     406 </span><span class="lineCov">         80 :   for (i = 0; i &lt; e-&gt;succ_flags.length (); ++i)</span>
<span class="lineNum">     407 </span><span class="lineCov">         20 :     fprintf (file, &quot; %x&quot;, e-&gt;succ_flags[i]);</span>
<span class="lineNum">     408 </span><span class="lineCov">         20 :   fprintf (file, &quot;\n&quot;);</span>
<span class="lineNum">     409 </span><span class="lineCov">         20 : }</span>
<span class="lineNum">     410 </span>            : 
<span class="lineNum">     411 </span>            : /* Prints same_succ VE to VFILE.  */
<a name="412"><span class="lineNum">     412 </span>            : </a>
<span class="lineNum">     413 </span>            : inline int
<span class="lineNum">     414 </span><span class="lineNoCov">          0 : ssa_same_succ_print_traverse (same_succ **pe, FILE *file)</span>
<span class="lineNum">     415 </span>            : {
<span class="lineNum">     416 </span><span class="lineNoCov">          0 :   const same_succ *e = *pe;</span>
<span class="lineNum">     417 </span><span class="lineNoCov">          0 :   same_succ_print (file, e);</span>
<span class="lineNum">     418 </span><span class="lineNoCov">          0 :   return 1;</span>
<span class="lineNum">     419 </span>            : }
<span class="lineNum">     420 </span>            : 
<span class="lineNum">     421 </span>            : /* Update BB_DEP_BB (USE_BB), given a use of VAL in USE_BB.  */
<a name="422"><span class="lineNum">     422 </span>            : </a>
<span class="lineNum">     423 </span>            : static void
<span class="lineNum">     424 </span><span class="lineCov">   19380738 : update_dep_bb (basic_block use_bb, tree val)</span>
<span class="lineNum">     425 </span>            : {
<span class="lineNum">     426 </span><span class="lineCov">   19380738 :   basic_block dep_bb;</span>
<span class="lineNum">     427 </span>            : 
<span class="lineNum">     428 </span>            :   /* Not a dep.  */
<span class="lineNum">     429 </span><span class="lineCov">   19380738 :   if (TREE_CODE (val) != SSA_NAME)</span>
<span class="lineNum">     430 </span>            :     return;
<span class="lineNum">     431 </span>            : 
<span class="lineNum">     432 </span>            :   /* Skip use of global def.  */
<span class="lineNum">     433 </span><span class="lineCov">   37387074 :   if (SSA_NAME_IS_DEFAULT_DEF (val))</span>
<span class="lineNum">     434 </span>            :     return;
<span class="lineNum">     435 </span>            : 
<span class="lineNum">     436 </span>            :   /* Skip use of local def.  */
<span class="lineNum">     437 </span><span class="lineCov">   32612724 :   dep_bb = gimple_bb (SSA_NAME_DEF_STMT (val));</span>
<span class="lineNum">     438 </span><span class="lineCov">   16306362 :   if (dep_bb == use_bb)</span>
<span class="lineNum">     439 </span>            :     return;
<span class="lineNum">     440 </span>            : 
<span class="lineNum">     441 </span><span class="lineCov">    5853344 :   if (BB_DEP_BB (use_bb) == NULL</span>
<span class="lineNum">     442 </span><span class="lineCov">    5853344 :       || dominated_by_p (CDI_DOMINATORS, dep_bb, BB_DEP_BB (use_bb)))</span>
<span class="lineNum">     443 </span><span class="lineCov">    5045508 :     BB_DEP_BB (use_bb) = dep_bb;</span>
<span class="lineNum">     444 </span>            : }
<span class="lineNum">     445 </span>            : 
<span class="lineNum">     446 </span>            : /* Update BB_DEP_BB, given the dependencies in STMT.  */
<a name="447"><span class="lineNum">     447 </span>            : </a>
<span class="lineNum">     448 </span>            : static void
<span class="lineNum">     449 </span><span class="lineCov">   20600697 : stmt_update_dep_bb (gimple *stmt)</span>
<span class="lineNum">     450 </span>            : {
<span class="lineNum">     451 </span><span class="lineCov">   20600697 :   ssa_op_iter iter;</span>
<span class="lineNum">     452 </span><span class="lineCov">   20600697 :   use_operand_p use;</span>
<span class="lineNum">     453 </span>            : 
<span class="lineNum">     454 </span><span class="lineCov">   37231948 :   FOR_EACH_SSA_USE_OPERAND (use, stmt, iter, SSA_OP_USE)</span>
<span class="lineNum">     455 </span><span class="lineCov">   49893753 :     update_dep_bb (gimple_bb (stmt), USE_FROM_PTR (use));</span>
<span class="lineNum">     456 </span><span class="lineCov">   20600697 : }</span>
<span class="lineNum">     457 </span>            : 
<span class="lineNum">     458 </span>            : /* Calculates hash value for same_succ VE.  */
<span class="lineNum">     459 </span>            : 
<span class="lineNum">     460 </span>            : static hashval_t
<span class="lineNum">     461 </span><span class="lineCov">    8202971 : same_succ_hash (const same_succ *e)</span>
<span class="lineNum">     462 </span>            : {
<span class="lineNum">     463 </span><span class="lineCov">    8202971 :   inchash::hash hstate (bitmap_hash (e-&gt;succs));</span>
<span class="lineNum">     464 </span><span class="lineCov">    8202971 :   int flags;</span>
<span class="lineNum">     465 </span><span class="lineCov">    8202971 :   unsigned int i;</span>
<span class="lineNum">     466 </span><span class="lineCov">    8202971 :   unsigned int first = bitmap_first_set_bit (e-&gt;bbs);</span>
<span class="lineNum">     467 </span><span class="lineCov">    8202971 :   basic_block bb = BASIC_BLOCK_FOR_FN (cfun, first);</span>
<span class="lineNum">     468 </span><span class="lineCov">    8202971 :   int size = 0;</span>
<span class="lineNum">     469 </span><span class="lineCov">    8202971 :   gimple *stmt;</span>
<span class="lineNum">     470 </span><span class="lineCov">    8202971 :   tree arg;</span>
<span class="lineNum">     471 </span><span class="lineCov">    8202971 :   unsigned int s;</span>
<span class="lineNum">     472 </span><span class="lineCov">    8202971 :   bitmap_iterator bs;</span>
<span class="lineNum">     473 </span>            : 
<span class="lineNum">     474 </span><span class="lineCov">    8202971 :   for (gimple_stmt_iterator gsi = gsi_start_nondebug_bb (bb);</span>
<span class="lineNum">     475 </span><span class="lineCov">   78208033 :        !gsi_end_p (gsi); gsi_next_nondebug (&amp;gsi))</span>
<span class="lineNum">     476 </span>            :     {
<span class="lineNum">     477 </span><span class="lineCov">   20600697 :       stmt = gsi_stmt (gsi);</span>
<span class="lineNum">     478 </span><span class="lineCov">   20600697 :       stmt_update_dep_bb (stmt);</span>
<span class="lineNum">     479 </span><span class="lineCov">   20600697 :       if (stmt_local_def (stmt))</span>
<span class="lineNum">     480 </span>            :         continue;
<span class="lineNum">     481 </span><span class="lineCov">   16973088 :       size++;</span>
<span class="lineNum">     482 </span>            : 
<span class="lineNum">     483 </span><span class="lineCov">   33946176 :       hstate.add_int (gimple_code (stmt));</span>
<span class="lineNum">     484 </span><span class="lineCov">   33946176 :       if (is_gimple_assign (stmt))</span>
<span class="lineNum">     485 </span><span class="lineCov">    9210040 :         hstate.add_int (gimple_assign_rhs_code (stmt));</span>
<span class="lineNum">     486 </span><span class="lineCov">   33946176 :       if (!is_gimple_call (stmt))</span>
<span class="lineNum">     487 </span>            :         continue;
<span class="lineNum">     488 </span><span class="lineCov">    3408077 :       if (gimple_call_internal_p (stmt))</span>
<span class="lineNum">     489 </span><span class="lineCov">      69537 :         hstate.add_int (gimple_call_internal_fn (stmt));</span>
<span class="lineNum">     490 </span>            :       else
<span class="lineNum">     491 </span>            :         {
<span class="lineNum">     492 </span><span class="lineCov">    6677080 :           inchash::add_expr (gimple_call_fn (stmt), hstate);</span>
<span class="lineNum">     493 </span><span class="lineCov">    3338540 :           if (gimple_call_chain (stmt))</span>
<span class="lineNum">     494 </span><span class="lineCov">      30000 :             inchash::add_expr (gimple_call_chain (stmt), hstate);</span>
<span class="lineNum">     495 </span>            :         }
<span class="lineNum">     496 </span><span class="lineCov">    9577938 :       for (i = 0; i &lt; gimple_call_num_args (stmt); i++)</span>
<span class="lineNum">     497 </span>            :         {
<span class="lineNum">     498 </span><span class="lineCov">    6169861 :           arg = gimple_call_arg (stmt, i);</span>
<span class="lineNum">     499 </span><span class="lineCov">    6169861 :           arg = tail_merge_valueize (arg);</span>
<span class="lineNum">     500 </span><span class="lineCov">    6169861 :           inchash::add_expr (arg, hstate);</span>
<span class="lineNum">     501 </span>            :         }
<span class="lineNum">     502 </span>            :     }
<span class="lineNum">     503 </span>            : 
<span class="lineNum">     504 </span><span class="lineCov">    8202971 :   hstate.add_int (size);</span>
<span class="lineNum">     505 </span><span class="lineCov">    8202971 :   BB_SIZE (bb) = size;</span>
<span class="lineNum">     506 </span>            : 
<span class="lineNum">     507 </span><span class="lineCov">    8202971 :   hstate.add_int (bb-&gt;loop_father-&gt;num);</span>
<span class="lineNum">     508 </span>            : 
<span class="lineNum">     509 </span><span class="lineCov">   38746354 :   for (i = 0; i &lt; e-&gt;succ_flags.length (); ++i)</span>
<span class="lineNum">     510 </span>            :     {
<span class="lineNum">     511 </span><span class="lineCov">   11170206 :       flags = e-&gt;succ_flags[i];</span>
<span class="lineNum">     512 </span><span class="lineCov">   11170206 :       flags = flags &amp; ~(EDGE_TRUE_VALUE | EDGE_FALSE_VALUE);</span>
<span class="lineNum">     513 </span><span class="lineCov">   22340412 :       hstate.add_int (flags);</span>
<span class="lineNum">     514 </span>            :     }
<span class="lineNum">     515 </span>            : 
<span class="lineNum">     516 </span><span class="lineCov">   19373177 :   EXECUTE_IF_SET_IN_BITMAP (e-&gt;succs, 0, s, bs)</span>
<span class="lineNum">     517 </span>            :     {
<span class="lineNum">     518 </span><span class="lineCov">   11170206 :       int n = find_edge (bb, BASIC_BLOCK_FOR_FN (cfun, s))-&gt;dest_idx;</span>
<span class="lineNum">     519 </span><span class="lineCov">   11170206 :       for (gphi_iterator gsi = gsi_start_phis (BASIC_BLOCK_FOR_FN (cfun, s));</span>
<span class="lineNum">     520 </span><span class="lineCov">   33001766 :            !gsi_end_p (gsi);</span>
<span class="lineNum">     521 </span><span class="lineCov">    5330677 :            gsi_next (&amp;gsi))</span>
<span class="lineNum">     522 </span>            :         {
<span class="lineNum">     523 </span><span class="lineCov">    5330677 :           gphi *phi = gsi.phi ();</span>
<span class="lineNum">     524 </span><span class="lineCov">    5330677 :           tree lhs = gimple_phi_result (phi);</span>
<span class="lineNum">     525 </span><span class="lineCov">    5330677 :           tree val = gimple_phi_arg_def (phi, n);</span>
<span class="lineNum">     526 </span>            : 
<span class="lineNum">     527 </span><span class="lineCov">   10661354 :           if (virtual_operand_p (lhs))</span>
<span class="lineNum">     528 </span>            :             continue;
<span class="lineNum">     529 </span><span class="lineCov">    2749487 :           update_dep_bb (bb, val);</span>
<span class="lineNum">     530 </span>            :         }
<span class="lineNum">     531 </span>            :     }
<span class="lineNum">     532 </span>            : 
<span class="lineNum">     533 </span><span class="lineCov">   16405942 :   return hstate.end ();</span>
<span class="lineNum">     534 </span>            : }
<span class="lineNum">     535 </span>            : 
<span class="lineNum">     536 </span>            : /* Returns true if E1 and E2 have 2 successors, and if the successor flags
<span class="lineNum">     537 </span>            :    are inverse for the EDGE_TRUE_VALUE and EDGE_FALSE_VALUE flags, and equal for
<span class="lineNum">     538 </span>            :    the other edge flags.  */
<span class="lineNum">     539 </span>            : 
<span class="lineNum">     540 </span>            : static bool
<span class="lineNum">     541 </span><span class="lineCov">    3174988 : inverse_flags (const same_succ *e1, const same_succ *e2)</span>
<span class="lineNum">     542 </span>            : {
<span class="lineNum">     543 </span><span class="lineCov">    3174988 :   int f1a, f1b, f2a, f2b;</span>
<span class="lineNum">     544 </span><span class="lineCov">    3174988 :   int mask = ~(EDGE_TRUE_VALUE | EDGE_FALSE_VALUE);</span>
<span class="lineNum">     545 </span>            : 
<span class="lineNum">     546 </span><span class="lineCov">    3174988 :   if (e1-&gt;succ_flags.length () != 2)</span>
<span class="lineNum">     547 </span>            :     return false;
<span class="lineNum">     548 </span>            : 
<span class="lineNum">     549 </span><span class="lineCov">       6016 :   f1a = e1-&gt;succ_flags[0];</span>
<span class="lineNum">     550 </span><span class="lineCov">       6016 :   f1b = e1-&gt;succ_flags[1];</span>
<span class="lineNum">     551 </span><span class="lineCov">       6016 :   f2a = e2-&gt;succ_flags[0];</span>
<span class="lineNum">     552 </span><span class="lineCov">       6016 :   f2b = e2-&gt;succ_flags[1];</span>
<span class="lineNum">     553 </span>            : 
<span class="lineNum">     554 </span><span class="lineCov">       6016 :   if (f1a == f2a &amp;&amp; f1b == f2b)</span>
<span class="lineNum">     555 </span>            :     return false;
<span class="lineNum">     556 </span>            : 
<span class="lineNum">     557 </span><span class="lineCov">        244 :   return (f1a &amp; mask) == (f2a &amp; mask) &amp;&amp; (f1b &amp; mask) == (f2b &amp; mask);</span>
<span class="lineNum">     558 </span>            : }
<span class="lineNum">     559 </span>            : 
<span class="lineNum">     560 </span>            : /* Compares SAME_SUCCs E1 and E2.  */
<span class="lineNum">     561 </span>            : 
<span class="lineNum">     562 </span>            : int
<span class="lineNum">     563 </span><span class="lineCov">   44755686 : same_succ::equal (const same_succ *e1, const same_succ *e2)</span>
<span class="lineNum">     564 </span>            : {
<span class="lineNum">     565 </span><span class="lineCov">   44755686 :   unsigned int i, first1, first2;</span>
<span class="lineNum">     566 </span><span class="lineCov">   44755686 :   gimple_stmt_iterator gsi1, gsi2;</span>
<span class="lineNum">     567 </span><span class="lineCov">   44755686 :   gimple *s1, *s2;</span>
<span class="lineNum">     568 </span><span class="lineCov">   44755686 :   basic_block bb1, bb2;</span>
<span class="lineNum">     569 </span>            : 
<span class="lineNum">     570 </span><span class="lineCov">   44755686 :   if (e1 == e2)</span>
<span class="lineNum">     571 </span>            :     return 1;
<span class="lineNum">     572 </span>            : 
<span class="lineNum">     573 </span><span class="lineCov">   44079019 :   if (e1-&gt;hashval != e2-&gt;hashval)</span>
<span class="lineNum">     574 </span>            :     return 0;
<span class="lineNum">     575 </span>            : 
<span class="lineNum">     576 </span><span class="lineCov">  113214426 :   if (e1-&gt;succ_flags.length () != e2-&gt;succ_flags.length ())</span>
<span class="lineNum">     577 </span>            :     return 0;
<span class="lineNum">     578 </span>            : 
<span class="lineNum">     579 </span><span class="lineCov">   37738142 :   if (!bitmap_equal_p (e1-&gt;succs, e2-&gt;succs))</span>
<span class="lineNum">     580 </span>            :     return 0;
<span class="lineNum">     581 </span>            : 
<span class="lineNum">     582 </span><span class="lineCov">    1587510 :   if (!inverse_flags (e1, e2))</span>
<span class="lineNum">     583 </span>            :     {
<span class="lineNum">     584 </span><span class="lineCov">    6009088 :       for (i = 0; i &lt; e1-&gt;succ_flags.length (); ++i)</span>
<span class="lineNum">     585 </span><span class="lineCov">    1417156 :         if (e1-&gt;succ_flags[i] != e2-&gt;succ_flags[i])</span>
<span class="lineNum">     586 </span>            :           return 0;
<span class="lineNum">     587 </span>            :     }
<span class="lineNum">     588 </span>            : 
<span class="lineNum">     589 </span><span class="lineCov">    1587510 :   first1 = bitmap_first_set_bit (e1-&gt;bbs);</span>
<span class="lineNum">     590 </span><span class="lineCov">    1587510 :   first2 = bitmap_first_set_bit (e2-&gt;bbs);</span>
<span class="lineNum">     591 </span>            : 
<span class="lineNum">     592 </span><span class="lineCov">    1587510 :   bb1 = BASIC_BLOCK_FOR_FN (cfun, first1);</span>
<span class="lineNum">     593 </span><span class="lineCov">    1587510 :   bb2 = BASIC_BLOCK_FOR_FN (cfun, first2);</span>
<span class="lineNum">     594 </span>            : 
<span class="lineNum">     595 </span><span class="lineCov">    1587510 :   if (BB_SIZE (bb1) != BB_SIZE (bb2))</span>
<span class="lineNum">     596 </span>            :     return 0;
<span class="lineNum">     597 </span>            : 
<span class="lineNum">     598 </span><span class="lineCov">    1587510 :   if (bb1-&gt;loop_father != bb2-&gt;loop_father)</span>
<span class="lineNum">     599 </span>            :     return 0;
<span class="lineNum">     600 </span>            : 
<span class="lineNum">     601 </span><span class="lineCov">    1587510 :   gsi1 = gsi_start_nondebug_bb (bb1);</span>
<span class="lineNum">     602 </span><span class="lineCov">    1587510 :   gsi2 = gsi_start_nondebug_bb (bb2);</span>
<span class="lineNum">     603 </span><span class="lineCov">    1587510 :   gsi_advance_fw_nondebug_nonlocal (&amp;gsi1);</span>
<span class="lineNum">     604 </span><span class="lineCov">    1587510 :   gsi_advance_fw_nondebug_nonlocal (&amp;gsi2);</span>
<span class="lineNum">     605 </span><span class="lineCov">    4047701 :   while (!(gsi_end_p (gsi1) || gsi_end_p (gsi2)))</span>
<span class="lineNum">     606 </span>            :     {
<span class="lineNum">     607 </span><span class="lineCov">     872713 :       s1 = gsi_stmt (gsi1);</span>
<span class="lineNum">     608 </span><span class="lineCov">     872713 :       s2 = gsi_stmt (gsi2);</span>
<span class="lineNum">     609 </span><span class="lineCov">    2618139 :       if (gimple_code (s1) != gimple_code (s2))</span>
<span class="lineNum">     610 </span>            :         return 0;
<span class="lineNum">     611 </span><span class="lineCov">    1745426 :       if (is_gimple_call (s1) &amp;&amp; !gimple_call_same_target_p (s1, s2))</span>
<span class="lineNum">     612 </span>            :         return 0;
<span class="lineNum">     613 </span>            :       gsi_next_nondebug (&amp;gsi1);
<span class="lineNum">     614 </span><span class="lineCov">     872681 :       gsi_next_nondebug (&amp;gsi2);</span>
<span class="lineNum">     615 </span><span class="lineCov">     872681 :       gsi_advance_fw_nondebug_nonlocal (&amp;gsi1);</span>
<span class="lineNum">     616 </span><span class="lineCov">     872681 :       gsi_advance_fw_nondebug_nonlocal (&amp;gsi2);</span>
<span class="lineNum">     617 </span>            :     }
<span class="lineNum">     618 </span>            : 
<span class="lineNum">     619 </span>            :   return 1;
<span class="lineNum">     620 </span>            : }
<span class="lineNum">     621 </span>            : 
<span class="lineNum">     622 </span>            : /* Alloc and init a new SAME_SUCC.  */
<span class="lineNum">     623 </span>            : 
<span class="lineNum">     624 </span>            : static same_succ *
<span class="lineNum">     625 </span><span class="lineCov">    7322809 : same_succ_alloc (void)</span>
<span class="lineNum">     626 </span>            : {
<span class="lineNum">     627 </span><span class="lineCov">    7322809 :   same_succ *same = XNEW (struct same_succ);</span>
<span class="lineNum">     628 </span>            : 
<span class="lineNum">     629 </span><span class="lineCov">    7322809 :   same-&gt;bbs = BITMAP_ALLOC (NULL);</span>
<span class="lineNum">     630 </span><span class="lineCov">    7322809 :   same-&gt;succs = BITMAP_ALLOC (NULL);</span>
<span class="lineNum">     631 </span><span class="lineCov">    7322809 :   same-&gt;inverse = BITMAP_ALLOC (NULL);</span>
<span class="lineNum">     632 </span><span class="lineCov">    7322809 :   same-&gt;succ_flags.create (10);</span>
<span class="lineNum">     633 </span><span class="lineCov">    7322809 :   same-&gt;in_worklist = false;</span>
<span class="lineNum">     634 </span>            : 
<span class="lineNum">     635 </span><span class="lineCov">    7322809 :   return same;</span>
<span class="lineNum">     636 </span>            : }
<span class="lineNum">     637 </span>            : 
<span class="lineNum">     638 </span>            : /* Delete same_succ E.  */
<span class="lineNum">     639 </span>            : 
<span class="lineNum">     640 </span>            : void
<span class="lineNum">     641 </span><span class="lineCov">    7322809 : same_succ::remove (same_succ *e)</span>
<span class="lineNum">     642 </span>            : {
<span class="lineNum">     643 </span><span class="lineCov">    7322809 :   BITMAP_FREE (e-&gt;bbs);</span>
<span class="lineNum">     644 </span><span class="lineCov">    7322809 :   BITMAP_FREE (e-&gt;succs);</span>
<span class="lineNum">     645 </span><span class="lineCov">    7322809 :   BITMAP_FREE (e-&gt;inverse);</span>
<span class="lineNum">     646 </span><span class="lineCov">    7322809 :   e-&gt;succ_flags.release ();</span>
<span class="lineNum">     647 </span>            : 
<span class="lineNum">     648 </span><span class="lineCov">    7322809 :   XDELETE (e);</span>
<span class="lineNum">     649 </span><span class="lineCov">    7322809 : }</span>
<span class="lineNum">     650 </span>            : 
<span class="lineNum">     651 </span>            : /* Reset same_succ SAME.  */
<a name="652"><span class="lineNum">     652 </span>            : </a>
<span class="lineNum">     653 </span>            : static void
<span class="lineNum">     654 </span><span class="lineCov">    1587478 : same_succ_reset (same_succ *same)</span>
<span class="lineNum">     655 </span>            : {
<span class="lineNum">     656 </span><span class="lineCov">    1587478 :   bitmap_clear (same-&gt;bbs);</span>
<span class="lineNum">     657 </span><span class="lineCov">    1587478 :   bitmap_clear (same-&gt;succs);</span>
<span class="lineNum">     658 </span><span class="lineCov">    1587478 :   bitmap_clear (same-&gt;inverse);</span>
<span class="lineNum">     659 </span><span class="lineCov">    1587478 :   same-&gt;succ_flags.truncate (0);</span>
<span class="lineNum">     660 </span><span class="lineCov">    1587478 : }</span>
<span class="lineNum">     661 </span>            : 
<span class="lineNum">     662 </span>            : static hash_table&lt;same_succ&gt; *same_succ_htab;
<span class="lineNum">     663 </span>            : 
<span class="lineNum">     664 </span>            : /* Array that is used to store the edge flags for a successor.  */
<span class="lineNum">     665 </span>            : 
<span class="lineNum">     666 </span>            : static int *same_succ_edge_flags;
<span class="lineNum">     667 </span>            : 
<span class="lineNum">     668 </span>            : /* Bitmap that is used to mark bbs that are recently deleted.  */
<span class="lineNum">     669 </span>            : 
<span class="lineNum">     670 </span>            : static bitmap deleted_bbs;
<span class="lineNum">     671 </span>            : 
<span class="lineNum">     672 </span>            : /* Bitmap that is used to mark predecessors of bbs that are
<span class="lineNum">     673 </span>            :    deleted.  */
<span class="lineNum">     674 </span>            : 
<span class="lineNum">     675 </span>            : static bitmap deleted_bb_preds;
<span class="lineNum">     676 </span>            : 
<span class="lineNum">     677 </span>            : /* Prints same_succ_htab to stderr.  */
<span class="lineNum">     678 </span>            : 
<a name="679"><span class="lineNum">     679 </span>            : extern void debug_same_succ (void);</a>
<span class="lineNum">     680 </span>            : DEBUG_FUNCTION void
<span class="lineNum">     681 </span><span class="lineNoCov">          0 : debug_same_succ ( void)</span>
<span class="lineNum">     682 </span>            : {
<span class="lineNum">     683 </span><span class="lineNoCov">          0 :   same_succ_htab-&gt;traverse &lt;FILE *, ssa_same_succ_print_traverse&gt; (stderr);</span>
<span class="lineNum">     684 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     685 </span>            : 
<span class="lineNum">     686 </span>            : 
<span class="lineNum">     687 </span>            : /* Vector of bbs to process.  */
<span class="lineNum">     688 </span>            : 
<span class="lineNum">     689 </span>            : static vec&lt;same_succ *&gt; worklist;
<span class="lineNum">     690 </span>            : 
<span class="lineNum">     691 </span>            : /* Prints worklist to FILE.  */
<span class="lineNum">     692 </span>            : 
<span class="lineNum">     693 </span>            : static void
<span class="lineNum">     694 </span><span class="lineCov">         14 : print_worklist (FILE *file)</span>
<span class="lineNum">     695 </span>            : {
<span class="lineNum">     696 </span><span class="lineCov">         14 :   unsigned int i;</span>
<span class="lineNum">     697 </span><span class="lineCov">         48 :   for (i = 0; i &lt; worklist.length (); ++i)</span>
<span class="lineNum">     698 </span><span class="lineCov">         10 :     same_succ_print (file, worklist[i]);</span>
<span class="lineNum">     699 </span><span class="lineCov">         14 : }</span>
<span class="lineNum">     700 </span>            : 
<span class="lineNum">     701 </span>            : /* Adds SAME to worklist.  */
<a name="702"><span class="lineNum">     702 </span>            : </a>
<span class="lineNum">     703 </span>            : static void
<span class="lineNum">     704 </span><span class="lineCov">    8202971 : add_to_worklist (same_succ *same)</span>
<span class="lineNum">     705 </span>            : {
<span class="lineNum">     706 </span><span class="lineCov">    8202971 :   if (same-&gt;in_worklist)</span>
<span class="lineNum">     707 </span>            :     return;
<span class="lineNum">     708 </span>            : 
<span class="lineNum">     709 </span><span class="lineCov">    7244790 :   if (bitmap_count_bits (same-&gt;bbs) &lt; 2)</span>
<span class="lineNum">     710 </span>            :     return;
<span class="lineNum">     711 </span>            : 
<span class="lineNum">     712 </span><span class="lineCov">     629297 :   same-&gt;in_worklist = true;</span>
<span class="lineNum">     713 </span><span class="lineCov">     629297 :   worklist.safe_push (same);</span>
<span class="lineNum">     714 </span>            : }
<span class="lineNum">     715 </span>            : 
<span class="lineNum">     716 </span>            : /* Add BB to same_succ_htab.  */
<a name="717"><span class="lineNum">     717 </span>            : </a>
<span class="lineNum">     718 </span>            : static void
<span class="lineNum">     719 </span><span class="lineCov">    8202971 : find_same_succ_bb (basic_block bb, same_succ **same_p)</span>
<span class="lineNum">     720 </span>            : {
<span class="lineNum">     721 </span><span class="lineCov">    8202971 :   unsigned int j;</span>
<span class="lineNum">     722 </span><span class="lineCov">    8202971 :   bitmap_iterator bj;</span>
<span class="lineNum">     723 </span><span class="lineCov">    8202971 :   same_succ *same = *same_p;</span>
<span class="lineNum">     724 </span><span class="lineCov">    8202971 :   same_succ **slot;</span>
<span class="lineNum">     725 </span><span class="lineCov">    8202971 :   edge_iterator ei;</span>
<span class="lineNum">     726 </span><span class="lineCov">    8202971 :   edge e;</span>
<span class="lineNum">     727 </span>            : 
<span class="lineNum">     728 </span><span class="lineCov">    8202971 :   if (bb == NULL)</span>
<span class="lineNum">     729 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">     730 </span><span class="lineCov">    8202971 :   bitmap_set_bit (same-&gt;bbs, bb-&gt;index);</span>
<span class="lineNum">     731 </span><span class="lineCov">   27576148 :   FOR_EACH_EDGE (e, ei, bb-&gt;succs)</span>
<span class="lineNum">     732 </span>            :     {
<span class="lineNum">     733 </span><span class="lineCov">   11170206 :       int index = e-&gt;dest-&gt;index;</span>
<span class="lineNum">     734 </span><span class="lineCov">   11170206 :       bitmap_set_bit (same-&gt;succs, index);</span>
<span class="lineNum">     735 </span><span class="lineCov">   11170206 :       same_succ_edge_flags[index] = (e-&gt;flags &amp; ~ignore_edge_flags);</span>
<span class="lineNum">     736 </span>            :     }
<span class="lineNum">     737 </span><span class="lineCov">   19373177 :   EXECUTE_IF_SET_IN_BITMAP (same-&gt;succs, 0, j, bj)</span>
<span class="lineNum">     738 </span><span class="lineCov">   11170206 :     same-&gt;succ_flags.safe_push (same_succ_edge_flags[j]);</span>
<span class="lineNum">     739 </span>            : 
<span class="lineNum">     740 </span><span class="lineCov">    8202971 :   same-&gt;hashval = same_succ_hash (same);</span>
<span class="lineNum">     741 </span>            : 
<span class="lineNum">     742 </span><span class="lineCov">    8202971 :   slot = same_succ_htab-&gt;find_slot_with_hash (same, same-&gt;hashval, INSERT);</span>
<span class="lineNum">     743 </span><span class="lineCov">    8202971 :   if (*slot == NULL)</span>
<span class="lineNum">     744 </span>            :     {
<span class="lineNum">     745 </span><span class="lineCov">    6615493 :       *slot = same;</span>
<span class="lineNum">     746 </span><span class="lineCov">    6615493 :       BB_SAME_SUCC (bb) = same;</span>
<span class="lineNum">     747 </span><span class="lineCov">    6615493 :       add_to_worklist (same);</span>
<span class="lineNum">     748 </span><span class="lineCov">    6615493 :       *same_p = NULL;</span>
<span class="lineNum">     749 </span>            :     }
<span class="lineNum">     750 </span>            :   else
<span class="lineNum">     751 </span>            :     {
<span class="lineNum">     752 </span><span class="lineCov">    1587478 :       bitmap_set_bit ((*slot)-&gt;bbs, bb-&gt;index);</span>
<span class="lineNum">     753 </span><span class="lineCov">    1587478 :       BB_SAME_SUCC (bb) = *slot;</span>
<span class="lineNum">     754 </span><span class="lineCov">    1587478 :       add_to_worklist (*slot);</span>
<span class="lineNum">     755 </span><span class="lineCov">    1587478 :       if (inverse_flags (same, *slot))</span>
<span class="lineNum">     756 </span><span class="lineCov">        122 :         bitmap_set_bit ((*slot)-&gt;inverse, bb-&gt;index);</span>
<span class="lineNum">     757 </span><span class="lineCov">    1587478 :       same_succ_reset (same);</span>
<span class="lineNum">     758 </span>            :     }
<span class="lineNum">     759 </span>            : }
<span class="lineNum">     760 </span>            : 
<span class="lineNum">     761 </span>            : /* Find bbs with same successors.  */
<a name="762"><span class="lineNum">     762 </span>            : </a>
<span class="lineNum">     763 </span>            : static void
<span class="lineNum">     764 </span><span class="lineCov">     584016 : find_same_succ (void)</span>
<span class="lineNum">     765 </span>            : {
<span class="lineNum">     766 </span><span class="lineCov">     584016 :   same_succ *same = same_succ_alloc ();</span>
<span class="lineNum">     767 </span><span class="lineCov">     584016 :   basic_block bb;</span>
<span class="lineNum">     768 </span>            : 
<span class="lineNum">     769 </span><span class="lineCov">    8110194 :   FOR_EACH_BB_FN (bb, cfun)</span>
<span class="lineNum">     770 </span>            :     {
<span class="lineNum">     771 </span><span class="lineCov">    7526178 :       find_same_succ_bb (bb, &amp;same);</span>
<span class="lineNum">     772 </span><span class="lineCov">    7526178 :       if (same == NULL)</span>
<span class="lineNum">     773 </span><span class="lineCov">    5974858 :         same = same_succ_alloc ();</span>
<span class="lineNum">     774 </span>            :     }
<span class="lineNum">     775 </span>            : 
<span class="lineNum">     776 </span><span class="lineCov">     584016 :   same_succ::remove (same);</span>
<span class="lineNum">     777 </span><span class="lineCov">     584016 : }</span>
<span class="lineNum">     778 </span>            : 
<span class="lineNum">     779 </span>            : /* Initializes worklist administration.  */
<span class="lineNum">     780 </span>            : 
<span class="lineNum">     781 </span>            : static void
<span class="lineNum">     782 </span><span class="lineCov">     584016 : init_worklist (void)</span>
<span class="lineNum">     783 </span>            : {
<span class="lineNum">     784 </span><span class="lineCov">     584016 :   alloc_aux_for_blocks (sizeof (struct aux_bb_info));</span>
<span class="lineNum">     785 </span><span class="lineCov">     584016 :   same_succ_htab = new hash_table&lt;same_succ&gt; (n_basic_blocks_for_fn (cfun));</span>
<span class="lineNum">     786 </span><span class="lineCov">     584016 :   same_succ_edge_flags = XCNEWVEC (int, last_basic_block_for_fn (cfun));</span>
<span class="lineNum">     787 </span><span class="lineCov">     584016 :   deleted_bbs = BITMAP_ALLOC (NULL);</span>
<span class="lineNum">     788 </span><span class="lineCov">     584016 :   deleted_bb_preds = BITMAP_ALLOC (NULL);</span>
<span class="lineNum">     789 </span><span class="lineCov">     584016 :   worklist.create (n_basic_blocks_for_fn (cfun));</span>
<span class="lineNum">     790 </span><span class="lineCov">     584016 :   find_same_succ ();</span>
<span class="lineNum">     791 </span>            : 
<span class="lineNum">     792 </span><span class="lineCov">     584016 :   if (dump_file &amp;&amp; (dump_flags &amp; TDF_DETAILS))</span>
<span class="lineNum">     793 </span>            :     {
<span class="lineNum">     794 </span><span class="lineCov">         14 :       fprintf (dump_file, &quot;initial worklist:\n&quot;);</span>
<span class="lineNum">     795 </span><span class="lineCov">         14 :       print_worklist (dump_file);</span>
<span class="lineNum">     796 </span>            :     }
<span class="lineNum">     797 </span><span class="lineCov">     584016 : }</span>
<span class="lineNum">     798 </span>            : 
<span class="lineNum">     799 </span>            : /* Deletes worklist administration.  */
<span class="lineNum">     800 </span>            : 
<span class="lineNum">     801 </span>            : static void
<span class="lineNum">     802 </span><span class="lineCov">     584016 : delete_worklist (void)</span>
<span class="lineNum">     803 </span>            : {
<span class="lineNum">     804 </span><span class="lineCov">     584016 :   free_aux_for_blocks ();</span>
<span class="lineNum">     805 </span><span class="lineCov">     584016 :   delete same_succ_htab;</span>
<span class="lineNum">     806 </span><span class="lineCov">     584016 :   same_succ_htab = NULL;</span>
<span class="lineNum">     807 </span><span class="lineCov">     584016 :   XDELETEVEC (same_succ_edge_flags);</span>
<span class="lineNum">     808 </span><span class="lineCov">     584016 :   same_succ_edge_flags = NULL;</span>
<span class="lineNum">     809 </span><span class="lineCov">     584016 :   BITMAP_FREE (deleted_bbs);</span>
<span class="lineNum">     810 </span><span class="lineCov">     584016 :   BITMAP_FREE (deleted_bb_preds);</span>
<span class="lineNum">     811 </span><span class="lineCov">     584016 :   worklist.release ();</span>
<span class="lineNum">     812 </span><span class="lineCov">     584016 : }</span>
<span class="lineNum">     813 </span>            : 
<span class="lineNum">     814 </span>            : /* Mark BB as deleted, and mark its predecessors.  */
<a name="815"><span class="lineNum">     815 </span>            : </a>
<span class="lineNum">     816 </span>            : static void
<span class="lineNum">     817 </span><span class="lineCov">     731262 : mark_basic_block_deleted (basic_block bb)</span>
<span class="lineNum">     818 </span>            : {
<span class="lineNum">     819 </span><span class="lineCov">     731262 :   edge e;</span>
<span class="lineNum">     820 </span><span class="lineCov">     731262 :   edge_iterator ei;</span>
<span class="lineNum">     821 </span>            : 
<span class="lineNum">     822 </span><span class="lineCov">     731262 :   bitmap_set_bit (deleted_bbs, bb-&gt;index);</span>
<span class="lineNum">     823 </span>            : 
<span class="lineNum">     824 </span><span class="lineCov">    2291658 :   FOR_EACH_EDGE (e, ei, bb-&gt;preds)</span>
<span class="lineNum">     825 </span><span class="lineCov">     829134 :     bitmap_set_bit (deleted_bb_preds, e-&gt;src-&gt;index);</span>
<span class="lineNum">     826 </span><span class="lineCov">     731262 : }</span>
<span class="lineNum">     827 </span>            : 
<span class="lineNum">     828 </span>            : /* Removes BB from its corresponding same_succ.  */
<a name="829"><span class="lineNum">     829 </span>            : </a>
<span class="lineNum">     830 </span>            : static void
<span class="lineNum">     831 </span><span class="lineCov">    1408055 : same_succ_flush_bb (basic_block bb)</span>
<span class="lineNum">     832 </span>            : {
<span class="lineNum">     833 </span><span class="lineCov">    1408055 :   same_succ *same = BB_SAME_SUCC (bb);</span>
<span class="lineNum">     834 </span><span class="lineCov">    1408055 :   if (! same)</span>
<span class="lineNum">     835 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">     836 </span>            : 
<span class="lineNum">     837 </span><span class="lineCov">    1408055 :   BB_SAME_SUCC (bb) = NULL;</span>
<span class="lineNum">     838 </span><span class="lineCov">    1408055 :   if (bitmap_single_bit_set_p (same-&gt;bbs))</span>
<span class="lineNum">     839 </span><span class="lineCov">     676667 :     same_succ_htab-&gt;remove_elt_with_hash (same, same-&gt;hashval);</span>
<span class="lineNum">     840 </span>            :   else
<span class="lineNum">     841 </span><span class="lineCov">     731388 :     bitmap_clear_bit (same-&gt;bbs, bb-&gt;index);</span>
<span class="lineNum">     842 </span>            : }
<span class="lineNum">     843 </span>            : 
<span class="lineNum">     844 </span>            : /* Removes all bbs in BBS from their corresponding same_succ.  */
<span class="lineNum">     845 </span>            : 
<span class="lineNum">     846 </span>            : static void
<span class="lineNum">     847 </span><span class="lineCov">     123300 : same_succ_flush_bbs (bitmap bbs)</span>
<span class="lineNum">     848 </span>            : {
<span class="lineNum">     849 </span><span class="lineCov">     123300 :   unsigned int i;</span>
<span class="lineNum">     850 </span><span class="lineCov">     123300 :   bitmap_iterator bi;</span>
<span class="lineNum">     851 </span>            : 
<span class="lineNum">     852 </span><span class="lineCov">     800093 :   EXECUTE_IF_SET_IN_BITMAP (bbs, 0, i, bi)</span>
<span class="lineNum">     853 </span><span class="lineCov">     676793 :     same_succ_flush_bb (BASIC_BLOCK_FOR_FN (cfun, i));</span>
<span class="lineNum">     854 </span><span class="lineCov">     123300 : }</span>
<span class="lineNum">     855 </span>            : 
<span class="lineNum">     856 </span>            : /* Release the last vdef in BB, either normal or phi result.  */
<a name="857"><span class="lineNum">     857 </span>            : </a>
<span class="lineNum">     858 </span>            : static void
<span class="lineNum">     859 </span><span class="lineCov">     731262 : release_last_vdef (basic_block bb)</span>
<span class="lineNum">     860 </span>            : {
<span class="lineNum">     861 </span><span class="lineCov">    2205092 :   for (gimple_stmt_iterator i = gsi_last_bb (bb); !gsi_end_p (i);</span>
<span class="lineNum">     862 </span>            :        gsi_prev_nondebug (&amp;i))
<span class="lineNum">     863 </span>            :     {
<span class="lineNum">     864 </span><span class="lineCov">     181129 :       gimple *stmt = gsi_stmt (i);</span>
<span class="lineNum">     865 </span><span class="lineCov">     358523 :       if (gimple_vdef (stmt) == NULL_TREE)</span>
<span class="lineNum">     866 </span>            :         continue;
<span class="lineNum">     867 </span>            : 
<span class="lineNum">     868 </span><span class="lineCov">     175476 :       mark_virtual_operand_for_renaming (gimple_vdef (stmt));</span>
<span class="lineNum">     869 </span><span class="lineCov">     175476 :       return;</span>
<span class="lineNum">     870 </span>            :     }
<span class="lineNum">     871 </span>            : 
<span class="lineNum">     872 </span><span class="lineCov">     555786 :   for (gphi_iterator i = gsi_start_phis (bb); !gsi_end_p (i);</span>
<span class="lineNum">     873 </span><span class="lineNoCov">          0 :        gsi_next (&amp;i))</span>
<span class="lineNum">     874 </span>            :     {
<span class="lineNum">     875 </span><span class="lineCov">        104 :       gphi *phi = i.phi ();</span>
<span class="lineNum">     876 </span><span class="lineCov">        104 :       tree res = gimple_phi_result (phi);</span>
<span class="lineNum">     877 </span>            : 
<span class="lineNum">     878 </span><span class="lineCov">        208 :       if (!virtual_operand_p (res))</span>
<span class="lineNum">     879 </span><span class="lineNoCov">          0 :         continue;</span>
<span class="lineNum">     880 </span>            : 
<span class="lineNum">     881 </span><span class="lineCov">        104 :       mark_virtual_phi_result_for_renaming (phi);</span>
<span class="lineNum">     882 </span><span class="lineCov">        104 :       return;</span>
<span class="lineNum">     883 </span>            :     }
<span class="lineNum">     884 </span>            : }
<span class="lineNum">     885 </span>            : 
<span class="lineNum">     886 </span>            : /* For deleted_bb_preds, find bbs with same successors.  */
<span class="lineNum">     887 </span>            : 
<span class="lineNum">     888 </span>            : static void
<span class="lineNum">     889 </span><span class="lineCov">     123300 : update_worklist (void)</span>
<span class="lineNum">     890 </span>            : {
<span class="lineNum">     891 </span><span class="lineCov">     123300 :   unsigned int i;</span>
<span class="lineNum">     892 </span><span class="lineCov">     123300 :   bitmap_iterator bi;</span>
<span class="lineNum">     893 </span><span class="lineCov">     123300 :   basic_block bb;</span>
<span class="lineNum">     894 </span><span class="lineCov">     123300 :   same_succ *same;</span>
<span class="lineNum">     895 </span>            : 
<span class="lineNum">     896 </span><span class="lineCov">     123300 :   bitmap_and_compl_into (deleted_bb_preds, deleted_bbs);</span>
<span class="lineNum">     897 </span><span class="lineCov">     123300 :   bitmap_clear (deleted_bbs);</span>
<span class="lineNum">     898 </span>            : 
<span class="lineNum">     899 </span><span class="lineCov">     123300 :   bitmap_clear_bit (deleted_bb_preds, ENTRY_BLOCK);</span>
<span class="lineNum">     900 </span><span class="lineCov">     123300 :   same_succ_flush_bbs (deleted_bb_preds);</span>
<span class="lineNum">     901 </span>            : 
<span class="lineNum">     902 </span><span class="lineCov">     123300 :   same = same_succ_alloc ();</span>
<span class="lineNum">     903 </span><span class="lineCov">     800093 :   EXECUTE_IF_SET_IN_BITMAP (deleted_bb_preds, 0, i, bi)</span>
<span class="lineNum">     904 </span>            :     {
<span class="lineNum">     905 </span><span class="lineCov">     676793 :       bb = BASIC_BLOCK_FOR_FN (cfun, i);</span>
<span class="lineNum">     906 </span><span class="lineCov">     676793 :       gcc_assert (bb != NULL);</span>
<span class="lineNum">     907 </span><span class="lineCov">     676793 :       find_same_succ_bb (bb, &amp;same);</span>
<span class="lineNum">     908 </span><span class="lineCov">     676793 :       if (same == NULL)</span>
<span class="lineNum">     909 </span><span class="lineCov">     640635 :         same = same_succ_alloc ();</span>
<span class="lineNum">     910 </span>            :     }
<span class="lineNum">     911 </span><span class="lineCov">     123300 :   same_succ::remove (same);</span>
<span class="lineNum">     912 </span><span class="lineCov">     123300 :   bitmap_clear (deleted_bb_preds);</span>
<span class="lineNum">     913 </span><span class="lineCov">     123300 : }</span>
<span class="lineNum">     914 </span>            : 
<span class="lineNum">     915 </span>            : /* Prints cluster C to FILE.  */
<a name="916"><span class="lineNum">     916 </span>            : </a>
<span class="lineNum">     917 </span>            : static void
<span class="lineNum">     918 </span><span class="lineNoCov">          0 : print_cluster (FILE *file, bb_cluster *c)</span>
<span class="lineNum">     919 </span>            : {
<span class="lineNum">     920 </span><span class="lineNoCov">          0 :   if (c == NULL)</span>
<span class="lineNum">     921 </span>            :     return;
<span class="lineNum">     922 </span><span class="lineNoCov">          0 :   bitmap_print (file, c-&gt;bbs, &quot;bbs:&quot;, &quot;\n&quot;);</span>
<span class="lineNum">     923 </span><span class="lineNoCov">          0 :   bitmap_print (file, c-&gt;preds, &quot;preds:&quot;, &quot;\n&quot;);</span>
<span class="lineNum">     924 </span>            : }
<span class="lineNum">     925 </span>            : 
<span class="lineNum">     926 </span>            : /* Prints cluster C to stderr.  */
<span class="lineNum">     927 </span>            : 
<a name="928"><span class="lineNum">     928 </span>            : extern void debug_cluster (bb_cluster *);</a>
<span class="lineNum">     929 </span>            : DEBUG_FUNCTION void
<span class="lineNum">     930 </span><span class="lineNoCov">          0 : debug_cluster (bb_cluster *c)</span>
<span class="lineNum">     931 </span>            : {
<span class="lineNum">     932 </span><span class="lineNoCov">          0 :   print_cluster (stderr, c);</span>
<span class="lineNum">     933 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     934 </span>            : 
<span class="lineNum">     935 </span>            : /* Update C-&gt;rep_bb, given that BB is added to the cluster.  */
<a name="936"><span class="lineNum">     936 </span>            : </a>
<span class="lineNum">     937 </span>            : static void
<span class="lineNum">     938 </span><span class="lineCov">    1073786 : update_rep_bb (bb_cluster *c, basic_block bb)</span>
<span class="lineNum">     939 </span>            : {
<span class="lineNum">     940 </span>            :   /* Initial.  */
<span class="lineNum">     941 </span><span class="lineCov">    1073786 :   if (c-&gt;rep_bb == NULL)</span>
<span class="lineNum">     942 </span>            :     {
<span class="lineNum">     943 </span><span class="lineCov">     342524 :       c-&gt;rep_bb = bb;</span>
<span class="lineNum">     944 </span><span class="lineCov">     342524 :       return;</span>
<span class="lineNum">     945 </span>            :     }
<span class="lineNum">     946 </span>            : 
<span class="lineNum">     947 </span>            :   /* Current needs no deps, keep it.  */
<span class="lineNum">     948 </span><span class="lineCov">     731262 :   if (BB_DEP_BB (c-&gt;rep_bb) == NULL)</span>
<span class="lineNum">     949 </span>            :     return;
<span class="lineNum">     950 </span>            : 
<span class="lineNum">     951 </span>            :   /* Bb needs no deps, change rep_bb.  */
<span class="lineNum">     952 </span><span class="lineCov">        140 :   if (BB_DEP_BB (bb) == NULL)</span>
<span class="lineNum">     953 </span>            :     {
<span class="lineNum">     954 </span><span class="lineCov">         64 :       c-&gt;rep_bb = bb;</span>
<span class="lineNum">     955 </span><span class="lineCov">         64 :       return;</span>
<span class="lineNum">     956 </span>            :     }
<span class="lineNum">     957 </span>            : 
<span class="lineNum">     958 </span>            :   /* Bb needs last deps earlier than current, change rep_bb.  A potential
<span class="lineNum">     959 </span>            :      problem with this, is that the first deps might also be earlier, which
<span class="lineNum">     960 </span>            :      would mean we prefer longer lifetimes for the deps.  To be able to check
<span class="lineNum">     961 </span>            :      for this, we would have to trace BB_FIRST_DEP_BB as well, besides
<span class="lineNum">     962 </span>            :      BB_DEP_BB, which is really BB_LAST_DEP_BB.
<span class="lineNum">     963 </span>            :      The benefit of choosing the bb with last deps earlier, is that it can
<span class="lineNum">     964 </span>            :      potentially be used as replacement for more bbs.  */
<span class="lineNum">     965 </span><span class="lineCov">         76 :   if (dominated_by_p (CDI_DOMINATORS, BB_DEP_BB (c-&gt;rep_bb), BB_DEP_BB (bb)))</span>
<span class="lineNum">     966 </span><span class="lineCov">         76 :     c-&gt;rep_bb = bb;</span>
<span class="lineNum">     967 </span>            : }
<span class="lineNum">     968 </span>            : 
<span class="lineNum">     969 </span>            : /* Add BB to cluster C.  Sets BB in C-&gt;bbs, and preds of BB in C-&gt;preds.  */
<a name="970"><span class="lineNum">     970 </span>            : </a>
<span class="lineNum">     971 </span>            : static void
<span class="lineNum">     972 </span><span class="lineCov">    1073786 : add_bb_to_cluster (bb_cluster *c, basic_block bb)</span>
<span class="lineNum">     973 </span>            : {
<span class="lineNum">     974 </span><span class="lineCov">    1073786 :   edge e;</span>
<span class="lineNum">     975 </span><span class="lineCov">    1073786 :   edge_iterator ei;</span>
<span class="lineNum">     976 </span>            : 
<span class="lineNum">     977 </span><span class="lineCov">    1073786 :   bitmap_set_bit (c-&gt;bbs, bb-&gt;index);</span>
<span class="lineNum">     978 </span>            : 
<span class="lineNum">     979 </span><span class="lineCov">    3442354 :   FOR_EACH_EDGE (e, ei, bb-&gt;preds)</span>
<span class="lineNum">     980 </span><span class="lineCov">    1294782 :     bitmap_set_bit (c-&gt;preds, e-&gt;src-&gt;index);</span>
<span class="lineNum">     981 </span>            : 
<span class="lineNum">     982 </span><span class="lineCov">    1073786 :   update_rep_bb (c, bb);</span>
<span class="lineNum">     983 </span><span class="lineCov">    1073786 : }</span>
<span class="lineNum">     984 </span>            : 
<span class="lineNum">     985 </span>            : /* Allocate and init new cluster.  */
<a name="986"><span class="lineNum">     986 </span>            : </a>
<span class="lineNum">     987 </span>            : static bb_cluster *
<span class="lineNum">     988 </span><span class="lineCov">     342524 : new_cluster (void)</span>
<span class="lineNum">     989 </span>            : {
<span class="lineNum">     990 </span><span class="lineCov">     342524 :   bb_cluster *c;</span>
<span class="lineNum">     991 </span><span class="lineCov">     342524 :   c = XCNEW (bb_cluster);</span>
<span class="lineNum">     992 </span><span class="lineCov">     342524 :   c-&gt;bbs = BITMAP_ALLOC (NULL);</span>
<span class="lineNum">     993 </span><span class="lineCov">     342524 :   c-&gt;preds = BITMAP_ALLOC (NULL);</span>
<span class="lineNum">     994 </span><span class="lineCov">     342524 :   c-&gt;rep_bb = NULL;</span>
<span class="lineNum">     995 </span><span class="lineCov">     342524 :   return c;</span>
<span class="lineNum">     996 </span>            : }
<span class="lineNum">     997 </span>            : 
<span class="lineNum">     998 </span>            : /* Delete clusters.  */
<a name="999"><span class="lineNum">     999 </span>            : </a>
<span class="lineNum">    1000 </span>            : static void
<span class="lineNum">    1001 </span><span class="lineCov">     342524 : delete_cluster (bb_cluster *c)</span>
<span class="lineNum">    1002 </span>            : {
<span class="lineNum">    1003 </span><span class="lineCov">     342524 :   if (c == NULL)</span>
<span class="lineNum">    1004 </span>            :     return;
<span class="lineNum">    1005 </span><span class="lineCov">     342524 :   BITMAP_FREE (c-&gt;bbs);</span>
<span class="lineNum">    1006 </span><span class="lineCov">     342524 :   BITMAP_FREE (c-&gt;preds);</span>
<span class="lineNum">    1007 </span><span class="lineCov">     342524 :   XDELETE (c);</span>
<span class="lineNum">    1008 </span>            : }
<span class="lineNum">    1009 </span>            : 
<span class="lineNum">    1010 </span>            : 
<span class="lineNum">    1011 </span>            : /* Array that contains all clusters.  */
<span class="lineNum">    1012 </span>            : 
<span class="lineNum">    1013 </span>            : static vec&lt;bb_cluster *&gt; all_clusters;
<span class="lineNum">    1014 </span>            : 
<span class="lineNum">    1015 </span>            : /* Allocate all cluster vectors.  */
<span class="lineNum">    1016 </span>            : 
<span class="lineNum">    1017 </span>            : static void
<span class="lineNum">    1018 </span><span class="lineCov">     161856 : alloc_cluster_vectors (void)</span>
<span class="lineNum">    1019 </span>            : {
<span class="lineNum">    1020 </span><span class="lineCov">     161856 :   all_clusters.create (n_basic_blocks_for_fn (cfun));</span>
<span class="lineNum">    1021 </span><span class="lineCov">     161856 : }</span>
<span class="lineNum">    1022 </span>            : 
<span class="lineNum">    1023 </span>            : /* Reset all cluster vectors.  */
<span class="lineNum">    1024 </span>            : 
<span class="lineNum">    1025 </span>            : static void
<span class="lineNum">    1026 </span><span class="lineCov">       6088 : reset_cluster_vectors (void)</span>
<span class="lineNum">    1027 </span>            : {
<span class="lineNum">    1028 </span><span class="lineCov">       6088 :   unsigned int i;</span>
<span class="lineNum">    1029 </span><span class="lineCov">       6088 :   basic_block bb;</span>
<span class="lineNum">    1030 </span><span class="lineCov">     148938 :   for (i = 0; i &lt; all_clusters.length (); ++i)</span>
<span class="lineNum">    1031 </span><span class="lineCov">      68381 :     delete_cluster (all_clusters[i]);</span>
<span class="lineNum">    1032 </span><span class="lineCov">       6088 :   all_clusters.truncate (0);</span>
<span class="lineNum">    1033 </span><span class="lineCov">     565275 :   FOR_EACH_BB_FN (bb, cfun)</span>
<span class="lineNum">    1034 </span><span class="lineCov">     559187 :     BB_CLUSTER (bb) = NULL;</span>
<span class="lineNum">    1035 </span><span class="lineCov">       6088 : }</span>
<span class="lineNum">    1036 </span>            : 
<span class="lineNum">    1037 </span>            : /* Delete all cluster vectors.  */
<span class="lineNum">    1038 </span>            : 
<span class="lineNum">    1039 </span>            : static void
<span class="lineNum">    1040 </span><span class="lineCov">     161856 : delete_cluster_vectors (void)</span>
<span class="lineNum">    1041 </span>            : {
<span class="lineNum">    1042 </span><span class="lineCov">     161856 :   unsigned int i;</span>
<span class="lineNum">    1043 </span><span class="lineCov">     871998 :   for (i = 0; i &lt; all_clusters.length (); ++i)</span>
<span class="lineNum">    1044 </span><span class="lineCov">     274143 :     delete_cluster (all_clusters[i]);</span>
<span class="lineNum">    1045 </span><span class="lineCov">     161856 :   all_clusters.release ();</span>
<span class="lineNum">    1046 </span><span class="lineCov">     161856 : }</span>
<span class="lineNum">    1047 </span>            : 
<span class="lineNum">    1048 </span>            : /* Merge cluster C2 into C1.  */
<a name="1049"><span class="lineNum">    1049 </span>            : </a>
<span class="lineNum">    1050 </span>            : static void
<span class="lineNum">    1051 </span><span class="lineNoCov">          0 : merge_clusters (bb_cluster *c1, bb_cluster *c2)</span>
<span class="lineNum">    1052 </span>            : {
<span class="lineNum">    1053 </span><span class="lineNoCov">          0 :   bitmap_ior_into (c1-&gt;bbs, c2-&gt;bbs);</span>
<span class="lineNum">    1054 </span><span class="lineNoCov">          0 :   bitmap_ior_into (c1-&gt;preds, c2-&gt;preds);</span>
<span class="lineNum">    1055 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1056 </span>            : 
<span class="lineNum">    1057 </span>            : /* Register equivalence of BB1 and BB2 (members of cluster C).  Store c in
<span class="lineNum">    1058 </span>            :    all_clusters, or merge c with existing cluster.  */
<span class="lineNum">    1059 </span>            : 
<span class="lineNum">    1060 </span>            : static void
<span class="lineNum">    1061 </span><span class="lineCov">     731262 : set_cluster (basic_block bb1, basic_block bb2)</span>
<span class="lineNum">    1062 </span>            : {
<span class="lineNum">    1063 </span><span class="lineCov">     731262 :   basic_block merge_bb, other_bb;</span>
<span class="lineNum">    1064 </span><span class="lineCov">     731262 :   bb_cluster *merge, *old, *c;</span>
<span class="lineNum">    1065 </span>            : 
<span class="lineNum">    1066 </span><span class="lineCov">     731262 :   if (BB_CLUSTER (bb1) == NULL &amp;&amp; BB_CLUSTER (bb2) == NULL)</span>
<span class="lineNum">    1067 </span>            :     {
<span class="lineNum">    1068 </span><span class="lineCov">     342524 :       c = new_cluster ();</span>
<span class="lineNum">    1069 </span><span class="lineCov">     342524 :       add_bb_to_cluster (c, bb1);</span>
<span class="lineNum">    1070 </span><span class="lineCov">     342524 :       add_bb_to_cluster (c, bb2);</span>
<span class="lineNum">    1071 </span><span class="lineCov">     342524 :       BB_CLUSTER (bb1) = c;</span>
<span class="lineNum">    1072 </span><span class="lineCov">     342524 :       BB_CLUSTER (bb2) = c;</span>
<span class="lineNum">    1073 </span><span class="lineCov">     342524 :       c-&gt;index = all_clusters.length ();</span>
<span class="lineNum">    1074 </span><span class="lineCov">     342524 :       all_clusters.safe_push (c);</span>
<span class="lineNum">    1075 </span>            :     }
<span class="lineNum">    1076 </span><span class="lineCov">     388738 :   else if (BB_CLUSTER (bb1) == NULL || BB_CLUSTER (bb2) == NULL)</span>
<span class="lineNum">    1077 </span>            :     {
<span class="lineNum">    1078 </span><span class="lineCov">     388738 :       merge_bb = BB_CLUSTER (bb1) == NULL ? bb2 : bb1;</span>
<span class="lineNum">    1079 </span><span class="lineCov">     388738 :       other_bb = BB_CLUSTER (bb1) == NULL ? bb1 : bb2;</span>
<span class="lineNum">    1080 </span><span class="lineCov">     388738 :       merge = BB_CLUSTER (merge_bb);</span>
<span class="lineNum">    1081 </span><span class="lineCov">     388738 :       add_bb_to_cluster (merge, other_bb);</span>
<span class="lineNum">    1082 </span><span class="lineCov">     388738 :       BB_CLUSTER (other_bb) = merge;</span>
<span class="lineNum">    1083 </span>            :     }
<span class="lineNum">    1084 </span><span class="lineNoCov">          0 :   else if (BB_CLUSTER (bb1) != BB_CLUSTER (bb2))</span>
<span class="lineNum">    1085 </span>            :     {
<span class="lineNum">    1086 </span><span class="lineNoCov">          0 :       unsigned int i;</span>
<span class="lineNum">    1087 </span><span class="lineNoCov">          0 :       bitmap_iterator bi;</span>
<span class="lineNum">    1088 </span>            : 
<span class="lineNum">    1089 </span><span class="lineNoCov">          0 :       old = BB_CLUSTER (bb2);</span>
<span class="lineNum">    1090 </span><span class="lineNoCov">          0 :       merge = BB_CLUSTER (bb1);</span>
<span class="lineNum">    1091 </span><span class="lineNoCov">          0 :       merge_clusters (merge, old);</span>
<span class="lineNum">    1092 </span><span class="lineNoCov">          0 :       EXECUTE_IF_SET_IN_BITMAP (old-&gt;bbs, 0, i, bi)</span>
<span class="lineNum">    1093 </span><span class="lineNoCov">          0 :         BB_CLUSTER (BASIC_BLOCK_FOR_FN (cfun, i)) = merge;</span>
<span class="lineNum">    1094 </span><span class="lineNoCov">          0 :       all_clusters[old-&gt;index] = NULL;</span>
<span class="lineNum">    1095 </span><span class="lineNoCov">          0 :       update_rep_bb (merge, old-&gt;rep_bb);</span>
<span class="lineNum">    1096 </span><span class="lineNoCov">          0 :       delete_cluster (old);</span>
<span class="lineNum">    1097 </span>            :     }
<span class="lineNum">    1098 </span>            :   else
<span class="lineNum">    1099 </span><span class="lineNoCov">          0 :     gcc_unreachable ();</span>
<span class="lineNum">    1100 </span><span class="lineCov">     731262 : }</span>
<span class="lineNum">    1101 </span>            : 
<span class="lineNum">    1102 </span>            : /* Return true if gimple operands T1 and T2 have the same value.  */
<a name="1103"><span class="lineNum">    1103 </span>            : </a>
<span class="lineNum">    1104 </span>            : static bool
<span class="lineNum">    1105 </span><span class="lineCov">     286286 : gimple_operand_equal_value_p (tree t1, tree t2)</span>
<span class="lineNum">    1106 </span>            : {
<span class="lineNum">    1107 </span><span class="lineCov">     286286 :   if (t1 == t2)</span>
<span class="lineNum">    1108 </span>            :     return true;
<span class="lineNum">    1109 </span>            : 
<span class="lineNum">    1110 </span><span class="lineCov">     126248 :   if (t1 == NULL_TREE</span>
<span class="lineNum">    1111 </span><span class="lineCov">      63124 :       || t2 == NULL_TREE)</span>
<span class="lineNum">    1112 </span>            :     return false;
<span class="lineNum">    1113 </span>            : 
<span class="lineNum">    1114 </span><span class="lineCov">      63124 :   if (operand_equal_p (t1, t2, OEP_MATCH_SIDE_EFFECTS))</span>
<span class="lineNum">    1115 </span>            :     return true;
<span class="lineNum">    1116 </span>            : 
<span class="lineNum">    1117 </span><span class="lineCov">      25482 :   return gvn_uses_equal (t1, t2);</span>
<span class="lineNum">    1118 </span>            : }
<span class="lineNum">    1119 </span>            : 
<span class="lineNum">    1120 </span>            : /* Return true if gimple statements S1 and S2 are equal.  Gimple_bb (s1) and
<span class="lineNum">    1121 </span>            :    gimple_bb (s2) are members of SAME_SUCC.  */
<a name="1122"><span class="lineNum">    1122 </span>            : </a>
<span class="lineNum">    1123 </span>            : static bool
<span class="lineNum">    1124 </span><span class="lineCov">     244521 : gimple_equal_p (same_succ *same_succ, gimple *s1, gimple *s2)</span>
<span class="lineNum">    1125 </span>            : {
<span class="lineNum">    1126 </span><span class="lineCov">     244521 :   unsigned int i;</span>
<span class="lineNum">    1127 </span><span class="lineCov">     244521 :   tree lhs1, lhs2;</span>
<span class="lineNum">    1128 </span><span class="lineCov">     489042 :   basic_block bb1 = gimple_bb (s1), bb2 = gimple_bb (s2);</span>
<span class="lineNum">    1129 </span><span class="lineCov">     244521 :   tree t1, t2;</span>
<span class="lineNum">    1130 </span><span class="lineCov">     244521 :   bool inv_cond;</span>
<span class="lineNum">    1131 </span><span class="lineCov">     244521 :   enum tree_code code1, code2;</span>
<span class="lineNum">    1132 </span>            : 
<span class="lineNum">    1133 </span><span class="lineCov">     733563 :   if (gimple_code (s1) != gimple_code (s2))</span>
<span class="lineNum">    1134 </span>            :     return false;
<span class="lineNum">    1135 </span>            : 
<span class="lineNum">    1136 </span><span class="lineCov">     489042 :   switch (gimple_code (s1))</span>
<span class="lineNum">    1137 </span>            :     {
<span class="lineNum">    1138 </span><span class="lineCov">     174470 :     case GIMPLE_CALL:</span>
<span class="lineNum">    1139 </span><span class="lineCov">     174470 :       if (!gimple_call_same_target_p (s1, s2))</span>
<span class="lineNum">    1140 </span>            :         return false;
<span class="lineNum">    1141 </span>            : 
<span class="lineNum">    1142 </span><span class="lineCov">     174470 :       t1 = gimple_call_chain (s1);</span>
<span class="lineNum">    1143 </span><span class="lineCov">     174470 :       t2 = gimple_call_chain (s2);</span>
<span class="lineNum">    1144 </span><span class="lineCov">     174470 :       if (!gimple_operand_equal_value_p (t1, t2))</span>
<span class="lineNum">    1145 </span>            :         return false;
<span class="lineNum">    1146 </span>            : 
<span class="lineNum">    1147 </span><span class="lineCov">     174470 :       if (gimple_call_num_args (s1) != gimple_call_num_args (s2))</span>
<span class="lineNum">    1148 </span>            :         return false;
<span class="lineNum">    1149 </span>            : 
<span class="lineNum">    1150 </span><span class="lineCov">     238081 :       for (i = 0; i &lt; gimple_call_num_args (s1); ++i)</span>
<span class="lineNum">    1151 </span>            :         {
<span class="lineNum">    1152 </span><span class="lineCov">      63611 :           t1 = gimple_call_arg (s1, i);</span>
<span class="lineNum">    1153 </span><span class="lineCov">      63611 :           t2 = gimple_call_arg (s2, i);</span>
<span class="lineNum">    1154 </span><span class="lineCov">      63611 :           if (!gimple_operand_equal_value_p (t1, t2))</span>
<span class="lineNum">    1155 </span>            :             return false;
<span class="lineNum">    1156 </span>            :         }
<span class="lineNum">    1157 </span>            : 
<span class="lineNum">    1158 </span><span class="lineCov">     174470 :       lhs1 = gimple_get_lhs (s1);</span>
<span class="lineNum">    1159 </span><span class="lineCov">     174470 :       lhs2 = gimple_get_lhs (s2);</span>
<span class="lineNum">    1160 </span><span class="lineCov">     174470 :       if (lhs1 == NULL_TREE &amp;&amp; lhs2 == NULL_TREE)</span>
<span class="lineNum">    1161 </span>            :         return true;
<span class="lineNum">    1162 </span><span class="lineCov">        828 :       if (lhs1 == NULL_TREE || lhs2 == NULL_TREE)</span>
<span class="lineNum">    1163 </span>            :         return false;
<span class="lineNum">    1164 </span><span class="lineCov">        828 :       if (TREE_CODE (lhs1) == SSA_NAME &amp;&amp; TREE_CODE (lhs2) == SSA_NAME)</span>
<span class="lineNum">    1165 </span><span class="lineCov">        371 :         return tail_merge_valueize (lhs1) == tail_merge_valueize (lhs2);</span>
<span class="lineNum">    1166 </span><span class="lineCov">        457 :       return operand_equal_p (lhs1, lhs2, 0);</span>
<span class="lineNum">    1167 </span>            : 
<span class="lineNum">    1168 </span><span class="lineCov">      55666 :     case GIMPLE_ASSIGN:</span>
<span class="lineNum">    1169 </span><span class="lineCov">      55666 :       lhs1 = gimple_get_lhs (s1);</span>
<span class="lineNum">    1170 </span><span class="lineCov">      55666 :       lhs2 = gimple_get_lhs (s2);</span>
<span class="lineNum">    1171 </span><span class="lineCov">      55666 :       if (TREE_CODE (lhs1) != SSA_NAME</span>
<span class="lineNum">    1172 </span><span class="lineCov">      52783 :           &amp;&amp; TREE_CODE (lhs2) != SSA_NAME)</span>
<span class="lineNum">    1173 </span><span class="lineCov">      52783 :         return (operand_equal_p (lhs1, lhs2, 0)</span>
<span class="lineNum">    1174 </span><span class="lineCov">      52783 :                 &amp;&amp; gimple_operand_equal_value_p (gimple_assign_rhs1 (s1),</span>
<span class="lineNum">    1175 </span>            :                                                  gimple_assign_rhs1 (s2)));
<span class="lineNum">    1176 </span><span class="lineCov">       2883 :       else if (TREE_CODE (lhs1) == SSA_NAME</span>
<span class="lineNum">    1177 </span><span class="lineCov">       2883 :                &amp;&amp; TREE_CODE (lhs2) == SSA_NAME)</span>
<span class="lineNum">    1178 </span><span class="lineCov">       2872 :         return operand_equal_p (gimple_assign_rhs1 (s1),</span>
<span class="lineNum">    1179 </span><span class="lineCov">       5744 :                                 gimple_assign_rhs1 (s2), 0);</span>
<span class="lineNum">    1180 </span>            :       return false;
<span class="lineNum">    1181 </span>            : 
<span class="lineNum">    1182 </span><span class="lineCov">       1497 :     case GIMPLE_COND:</span>
<span class="lineNum">    1183 </span><span class="lineCov">       1497 :       t1 = gimple_cond_lhs (s1);</span>
<span class="lineNum">    1184 </span><span class="lineCov">       1497 :       t2 = gimple_cond_lhs (s2);</span>
<span class="lineNum">    1185 </span><span class="lineCov">       1497 :       if (!gimple_operand_equal_value_p (t1, t2))</span>
<span class="lineNum">    1186 </span>            :         return false;
<span class="lineNum">    1187 </span>            : 
<span class="lineNum">    1188 </span><span class="lineCov">        535 :       t1 = gimple_cond_rhs (s1);</span>
<span class="lineNum">    1189 </span><span class="lineCov">        535 :       t2 = gimple_cond_rhs (s2);</span>
<span class="lineNum">    1190 </span><span class="lineCov">        535 :       if (!gimple_operand_equal_value_p (t1, t2))</span>
<span class="lineNum">    1191 </span>            :         return false;
<span class="lineNum">    1192 </span>            : 
<span class="lineNum">    1193 </span><span class="lineCov">        353 :       code1 = gimple_expr_code (s1);</span>
<span class="lineNum">    1194 </span><span class="lineCov">        353 :       code2 = gimple_expr_code (s2);</span>
<span class="lineNum">    1195 </span><span class="lineCov">        353 :       inv_cond = (bitmap_bit_p (same_succ-&gt;inverse, bb1-&gt;index)</span>
<span class="lineNum">    1196 </span><span class="lineCov">        353 :                   != bitmap_bit_p (same_succ-&gt;inverse, bb2-&gt;index));</span>
<span class="lineNum">    1197 </span><span class="lineCov">        353 :       if (inv_cond)</span>
<span class="lineNum">    1198 </span>            :         {
<span class="lineNum">    1199 </span><span class="lineCov">          7 :           bool honor_nans = HONOR_NANS (t1);</span>
<span class="lineNum">    1200 </span><span class="lineCov">          7 :           code2 = invert_tree_comparison (code2, honor_nans);</span>
<span class="lineNum">    1201 </span>            :         }
<span class="lineNum">    1202 </span><span class="lineCov">        353 :       return code1 == code2;</span>
<span class="lineNum">    1203 </span>            : 
<span class="lineNum">    1204 </span>            :     default:
<span class="lineNum">    1205 </span>            :       return false;
<span class="lineNum">    1206 </span>            :     }
<span class="lineNum">    1207 </span>            : }
<span class="lineNum">    1208 </span>            : 
<span class="lineNum">    1209 </span>            : /* Let GSI skip backwards over local defs.  Return the earliest vuse in VUSE.
<span class="lineNum">    1210 </span>            :    Return true in VUSE_ESCAPED if the vuse influenced a SSA_OP_DEF of one of the
<span class="lineNum">    1211 </span>            :    processed statements.  */
<a name="1212"><span class="lineNum">    1212 </span>            : </a>
<span class="lineNum">    1213 </span>            : static void
<span class="lineNum">    1214 </span><span class="lineCov">    1951902 : gsi_advance_bw_nondebug_nonlocal (gimple_stmt_iterator *gsi, tree *vuse,</span>
<span class="lineNum">    1215 </span>            :                                   bool *vuse_escaped)
<span class="lineNum">    1216 </span>            : {
<span class="lineNum">    1217 </span><span class="lineCov">    1955850 :   gimple *stmt;</span>
<span class="lineNum">    1218 </span><span class="lineCov">    1955850 :   tree lvuse;</span>
<span class="lineNum">    1219 </span>            : 
<span class="lineNum">    1220 </span><span class="lineCov">    1955850 :   while (true)</span>
<span class="lineNum">    1221 </span>            :     {
<span class="lineNum">    1222 </span><span class="lineCov">    3911700 :       if (gsi_end_p (*gsi))</span>
<span class="lineNum">    1223 </span>            :         return;
<span class="lineNum">    1224 </span><span class="lineCov">     496146 :       stmt = gsi_stmt (*gsi);</span>
<span class="lineNum">    1225 </span>            : 
<span class="lineNum">    1226 </span><span class="lineCov">     496146 :       lvuse = gimple_vuse (stmt);</span>
<span class="lineNum">    1227 </span><span class="lineCov">     466684 :       if (lvuse != NULL_TREE)</span>
<span class="lineNum">    1228 </span>            :         {
<span class="lineNum">    1229 </span><span class="lineCov">     462116 :           *vuse = lvuse;</span>
<span class="lineNum">    1230 </span><span class="lineCov">     924232 :           if (!ZERO_SSA_OPERANDS (stmt, SSA_OP_DEF))</span>
<span class="lineNum">    1231 </span><span class="lineCov">       6267 :             *vuse_escaped = true;</span>
<span class="lineNum">    1232 </span>            :         }
<span class="lineNum">    1233 </span>            : 
<span class="lineNum">    1234 </span><span class="lineCov">     496146 :       if (!stmt_local_def (stmt))</span>
<span class="lineNum">    1235 </span>            :         return;
<span class="lineNum">    1236 </span>            :       gsi_prev_nondebug (gsi);
<span class="lineNum">    1237 </span>            :     }
<span class="lineNum">    1238 </span>            : }
<span class="lineNum">    1239 </span>            : 
<span class="lineNum">    1240 </span>            : /* Return true if equal (in the sense of gimple_equal_p) statements STMT1 and
<span class="lineNum">    1241 </span>            :    STMT2 are allowed to be merged.  */
<a name="1242"><span class="lineNum">    1242 </span>            : </a>
<span class="lineNum">    1243 </span>            : static bool
<span class="lineNum">    1244 </span><span class="lineCov">     200414 : merge_stmts_p (gimple *stmt1, gimple *stmt2)</span>
<span class="lineNum">    1245 </span>            : {
<span class="lineNum">    1246 </span>            :   /* What could be better than this here is to blacklist the bb
<span class="lineNum">    1247 </span>            :      containing the stmt, when encountering the stmt f.i. in
<span class="lineNum">    1248 </span>            :      same_succ_hash.  */
<span class="lineNum">    1249 </span><span class="lineCov">     200414 :   if (is_tm_ending (stmt1))</span>
<span class="lineNum">    1250 </span>            :     return false;
<span class="lineNum">    1251 </span>            : 
<span class="lineNum">    1252 </span>            :   /* Verify EH landing pads.  */
<span class="lineNum">    1253 </span><span class="lineCov">     200365 :   if (lookup_stmt_eh_lp_fn (cfun, stmt1) != lookup_stmt_eh_lp_fn (cfun, stmt2))</span>
<span class="lineNum">    1254 </span>            :     return false;
<span class="lineNum">    1255 </span>            : 
<span class="lineNum">    1256 </span><span class="lineCov">     199307 :   if (is_gimple_call (stmt1)</span>
<span class="lineNum">    1257 </span><span class="lineCov">     199307 :       &amp;&amp; gimple_call_internal_p (stmt1))</span>
<span class="lineNum">    1258 </span><span class="lineCov">        211 :     switch (gimple_call_internal_fn (stmt1))</span>
<span class="lineNum">    1259 </span>            :       {
<span class="lineNum">    1260 </span><span class="lineCov">        204 :       case IFN_UBSAN_NULL:</span>
<span class="lineNum">    1261 </span><span class="lineCov">        204 :       case IFN_UBSAN_BOUNDS:</span>
<span class="lineNum">    1262 </span><span class="lineCov">        204 :       case IFN_UBSAN_VPTR:</span>
<span class="lineNum">    1263 </span><span class="lineCov">        204 :       case IFN_UBSAN_CHECK_ADD:</span>
<span class="lineNum">    1264 </span><span class="lineCov">        204 :       case IFN_UBSAN_CHECK_SUB:</span>
<span class="lineNum">    1265 </span><span class="lineCov">        204 :       case IFN_UBSAN_CHECK_MUL:</span>
<span class="lineNum">    1266 </span><span class="lineCov">        204 :       case IFN_UBSAN_OBJECT_SIZE:</span>
<span class="lineNum">    1267 </span><span class="lineCov">        204 :       case IFN_UBSAN_PTR:</span>
<span class="lineNum">    1268 </span><span class="lineCov">        204 :       case IFN_ASAN_CHECK:</span>
<span class="lineNum">    1269 </span>            :         /* For these internal functions, gimple_location is an implicit
<span class="lineNum">    1270 </span>            :            parameter, which will be used explicitly after expansion.
<span class="lineNum">    1271 </span>            :            Merging these statements may cause confusing line numbers in
<span class="lineNum">    1272 </span>            :            sanitizer messages.  */
<span class="lineNum">    1273 </span><span class="lineCov">        612 :         return gimple_location (stmt1) == gimple_location (stmt2);</span>
<span class="lineNum">    1274 </span>            :       default:
<span class="lineNum">    1275 </span>            :         break;
<span class="lineNum">    1276 </span>            :       }
<span class="lineNum">    1277 </span>            : 
<span class="lineNum">    1278 </span>            :   return true;
<span class="lineNum">    1279 </span>            : }
<span class="lineNum">    1280 </span>            : 
<span class="lineNum">    1281 </span>            : /* Determines whether BB1 and BB2 (members of same_succ) are duplicates.  If so,
<span class="lineNum">    1282 </span>            :    clusters them.  */
<a name="1283"><span class="lineNum">    1283 </span>            : </a>
<span class="lineNum">    1284 </span>            : static void
<span class="lineNum">    1285 </span><span class="lineCov">     776848 : find_duplicate (same_succ *same_succ, basic_block bb1, basic_block bb2)</span>
<span class="lineNum">    1286 </span>            : {
<span class="lineNum">    1287 </span><span class="lineCov">     776848 :   gimple_stmt_iterator gsi1 = gsi_last_nondebug_bb (bb1);</span>
<span class="lineNum">    1288 </span><span class="lineCov">     776848 :   gimple_stmt_iterator gsi2 = gsi_last_nondebug_bb (bb2);</span>
<span class="lineNum">    1289 </span><span class="lineCov">     776848 :   tree vuse1 = NULL_TREE, vuse2 = NULL_TREE;</span>
<span class="lineNum">    1290 </span><span class="lineCov">     776848 :   bool vuse_escaped = false;</span>
<span class="lineNum">    1291 </span>            : 
<span class="lineNum">    1292 </span><span class="lineCov">     776848 :   gsi_advance_bw_nondebug_nonlocal (&amp;gsi1, &amp;vuse1, &amp;vuse_escaped);</span>
<span class="lineNum">    1293 </span><span class="lineCov">     776848 :   gsi_advance_bw_nondebug_nonlocal (&amp;gsi2, &amp;vuse2, &amp;vuse_escaped);</span>
<span class="lineNum">    1294 </span>            : 
<span class="lineNum">    1295 </span><span class="lineCov">    1752799 :   while (!gsi_end_p (gsi1) &amp;&amp; !gsi_end_p (gsi2))</span>
<span class="lineNum">    1296 </span>            :     {
<span class="lineNum">    1297 </span><span class="lineCov">     246099 :       gimple *stmt1 = gsi_stmt (gsi1);</span>
<span class="lineNum">    1298 </span><span class="lineCov">     246099 :       gimple *stmt2 = gsi_stmt (gsi2);</span>
<span class="lineNum">    1299 </span>            : 
<span class="lineNum">    1300 </span><span class="lineCov">     246099 :       if (gimple_code (stmt1) == GIMPLE_LABEL</span>
<span class="lineNum">    1301 </span><span class="lineCov">     246099 :           &amp;&amp; gimple_code (stmt2) == GIMPLE_LABEL)</span>
<span class="lineNum">    1302 </span>            :         break;
<span class="lineNum">    1303 </span>            : 
<span class="lineNum">    1304 </span><span class="lineCov">     244521 :       if (!gimple_equal_p (same_succ, stmt1, stmt2))</span>
<span class="lineNum">    1305 </span><span class="lineCov">      45586 :         return;</span>
<span class="lineNum">    1306 </span>            : 
<span class="lineNum">    1307 </span><span class="lineCov">     200414 :       if (!merge_stmts_p (stmt1, stmt2))</span>
<span class="lineNum">    1308 </span>            :         return;
<span class="lineNum">    1309 </span>            : 
<span class="lineNum">    1310 </span>            :       gsi_prev_nondebug (&amp;gsi1);
<span class="lineNum">    1311 </span><span class="lineCov">     199103 :       gsi_prev_nondebug (&amp;gsi2);</span>
<span class="lineNum">    1312 </span><span class="lineCov">     199103 :       gsi_advance_bw_nondebug_nonlocal (&amp;gsi1, &amp;vuse1, &amp;vuse_escaped);</span>
<span class="lineNum">    1313 </span><span class="lineCov">     199103 :       gsi_advance_bw_nondebug_nonlocal (&amp;gsi2, &amp;vuse2, &amp;vuse_escaped);</span>
<span class="lineNum">    1314 </span>            :     }
<span class="lineNum">    1315 </span>            : 
<span class="lineNum">    1316 </span><span class="lineCov">    1466018 :   while (!gsi_end_p (gsi1) &amp;&amp; gimple_code (gsi_stmt (gsi1)) == GIMPLE_LABEL)</span>
<span class="lineNum">    1317 </span>            :     {
<span class="lineNum">    1318 </span><span class="lineCov">       4737 :       tree label = gimple_label_label (as_a &lt;glabel *&gt; (gsi_stmt (gsi1)));</span>
<span class="lineNum">    1319 </span><span class="lineCov">       1579 :       if (DECL_NONLOCAL (label) || FORCED_LABEL (label))</span>
<span class="lineNum">    1320 </span>            :         return;
<span class="lineNum">    1321 </span><span class="lineCov">       1579 :       gsi_prev (&amp;gsi1);</span>
<span class="lineNum">    1322 </span>            :     }
<span class="lineNum">    1323 </span><span class="lineCov">    1466018 :   while (!gsi_end_p (gsi2) &amp;&amp; gimple_code (gsi_stmt (gsi2)) == GIMPLE_LABEL)</span>
<span class="lineNum">    1324 </span>            :     {
<span class="lineNum">    1325 </span><span class="lineCov">       4737 :       tree label = gimple_label_label (as_a &lt;glabel *&gt; (gsi_stmt (gsi2)));</span>
<span class="lineNum">    1326 </span><span class="lineCov">       1579 :       if (DECL_NONLOCAL (label) || FORCED_LABEL (label))</span>
<span class="lineNum">    1327 </span>            :         return;
<span class="lineNum">    1328 </span><span class="lineCov">       1579 :       gsi_prev (&amp;gsi2);</span>
<span class="lineNum">    1329 </span>            :     }
<span class="lineNum">    1330 </span><span class="lineCov">    1462860 :   if (!(gsi_end_p (gsi1) &amp;&amp; gsi_end_p (gsi2)))</span>
<span class="lineNum">    1331 </span>            :     return;
<span class="lineNum">    1332 </span>            : 
<span class="lineNum">    1333 </span>            :   /* If the incoming vuses are not the same, and the vuse escaped into an
<span class="lineNum">    1334 </span>            :      SSA_OP_DEF, then merging the 2 blocks will change the value of the def,
<span class="lineNum">    1335 </span>            :      which potentially means the semantics of one of the blocks will be changed.
<span class="lineNum">    1336 </span>            :      TODO: make this check more precise.  */
<span class="lineNum">    1337 </span><span class="lineCov">     731430 :   if (vuse_escaped &amp;&amp; vuse1 != vuse2)</span>
<span class="lineNum">    1338 </span>            :     return;
<span class="lineNum">    1339 </span>            : 
<span class="lineNum">    1340 </span><span class="lineCov">     731262 :   if (dump_file)</span>
<span class="lineNum">    1341 </span><span class="lineCov">         24 :     fprintf (dump_file, &quot;find_duplicates: &lt;bb %d&gt; duplicate of &lt;bb %d&gt;\n&quot;,</span>
<span class="lineNum">    1342 </span>            :              bb1-&gt;index, bb2-&gt;index);
<span class="lineNum">    1343 </span>            : 
<span class="lineNum">    1344 </span><span class="lineCov">     731262 :   set_cluster (bb1, bb2);</span>
<span class="lineNum">    1345 </span>            : }
<span class="lineNum">    1346 </span>            : 
<span class="lineNum">    1347 </span>            : /* Returns whether for all phis in DEST the phi alternatives for E1 and
<span class="lineNum">    1348 </span>            :    E2 are equal.  */
<a name="1349"><span class="lineNum">    1349 </span>            : </a>
<span class="lineNum">    1350 </span>            : static bool
<span class="lineNum">    1351 </span><span class="lineCov">    1098223 : same_phi_alternatives_1 (basic_block dest, edge e1, edge e2)</span>
<span class="lineNum">    1352 </span>            : {
<span class="lineNum">    1353 </span><span class="lineCov">    1098223 :   int n1 = e1-&gt;dest_idx, n2 = e2-&gt;dest_idx;</span>
<span class="lineNum">    1354 </span><span class="lineCov">    1098223 :   gphi_iterator gsi;</span>
<span class="lineNum">    1355 </span>            : 
<span class="lineNum">    1356 </span><span class="lineCov">    1530503 :   for (gsi = gsi_start_phis (dest); !gsi_end_p (gsi); gsi_next (&amp;gsi))</span>
<span class="lineNum">    1357 </span>            :     {
<span class="lineNum">    1358 </span><span class="lineCov">     931555 :       gphi *phi = gsi.phi ();</span>
<span class="lineNum">    1359 </span><span class="lineCov">     931555 :       tree lhs = gimple_phi_result (phi);</span>
<span class="lineNum">    1360 </span><span class="lineCov">     931555 :       tree val1 = gimple_phi_arg_def (phi, n1);</span>
<span class="lineNum">    1361 </span><span class="lineCov">     931555 :       tree val2 = gimple_phi_arg_def (phi, n2);</span>
<span class="lineNum">    1362 </span>            : 
<span class="lineNum">    1363 </span><span class="lineCov">    1863110 :       if (virtual_operand_p (lhs))</span>
<span class="lineNum">    1364 </span>            :         continue;
<span class="lineNum">    1365 </span>            : 
<span class="lineNum">    1366 </span><span class="lineCov">     599805 :       if (operand_equal_for_phi_arg_p (val1, val2))</span>
<span class="lineNum">    1367 </span>            :         continue;
<span class="lineNum">    1368 </span><span class="lineCov">     501468 :       if (gvn_uses_equal (val1, val2))</span>
<span class="lineNum">    1369 </span>            :         continue;
<span class="lineNum">    1370 </span>            : 
<span class="lineNum">    1371 </span>            :       return false;
<span class="lineNum">    1372 </span>            :     }
<span class="lineNum">    1373 </span>            : 
<span class="lineNum">    1374 </span>            :   return true;
<span class="lineNum">    1375 </span>            : }
<span class="lineNum">    1376 </span>            : 
<span class="lineNum">    1377 </span>            : /* Returns whether for all successors of BB1 and BB2 (members of SAME_SUCC), the
<span class="lineNum">    1378 </span>            :    phi alternatives for BB1 and BB2 are equal.  */
<span class="lineNum">    1379 </span>            : 
<span class="lineNum">    1380 </span>            : static bool
<span class="lineNum">    1381 </span><span class="lineCov">    1276123 : same_phi_alternatives (same_succ *same_succ, basic_block bb1, basic_block bb2)</span>
<span class="lineNum">    1382 </span>            : {
<span class="lineNum">    1383 </span><span class="lineCov">    1276123 :   unsigned int s;</span>
<span class="lineNum">    1384 </span><span class="lineCov">    1276123 :   bitmap_iterator bs;</span>
<span class="lineNum">    1385 </span><span class="lineCov">    1276123 :   edge e1, e2;</span>
<span class="lineNum">    1386 </span><span class="lineCov">    1276123 :   basic_block succ;</span>
<span class="lineNum">    1387 </span>            : 
<span class="lineNum">    1388 </span><span class="lineCov">    1875071 :   EXECUTE_IF_SET_IN_BITMAP (same_succ-&gt;succs, 0, s, bs)</span>
<span class="lineNum">    1389 </span>            :     {
<span class="lineNum">    1390 </span><span class="lineCov">    1098223 :       succ = BASIC_BLOCK_FOR_FN (cfun, s);</span>
<span class="lineNum">    1391 </span><span class="lineCov">    1098223 :       e1 = find_edge (bb1, succ);</span>
<span class="lineNum">    1392 </span><span class="lineCov">    1098223 :       e2 = find_edge (bb2, succ);</span>
<span class="lineNum">    1393 </span><span class="lineCov">    1098223 :       if (e1-&gt;flags &amp; EDGE_COMPLEX</span>
<span class="lineNum">    1394 </span><span class="lineCov">    1098223 :           || e2-&gt;flags &amp; EDGE_COMPLEX)</span>
<span class="lineNum">    1395 </span>            :         return false;
<span class="lineNum">    1396 </span>            : 
<span class="lineNum">    1397 </span>            :       /* For all phis in bb, the phi alternatives for e1 and e2 need to have
<span class="lineNum">    1398 </span>            :          the same value.  */
<span class="lineNum">    1399 </span><span class="lineCov">    1098223 :       if (!same_phi_alternatives_1 (succ, e1, e2))</span>
<span class="lineNum">    1400 </span>            :         return false;
<span class="lineNum">    1401 </span>            :     }
<span class="lineNum">    1402 </span>            : 
<span class="lineNum">    1403 </span>            :   return true;
<span class="lineNum">    1404 </span>            : }
<span class="lineNum">    1405 </span>            : 
<span class="lineNum">    1406 </span>            : /* Return true if BB has non-vop phis.  */
<a name="1407"><span class="lineNum">    1407 </span>            : </a>
<span class="lineNum">    1408 </span>            : static bool
<span class="lineNum">    1409 </span><span class="lineCov">   13301427 : bb_has_non_vop_phi (basic_block bb)</span>
<span class="lineNum">    1410 </span>            : {
<span class="lineNum">    1411 </span><span class="lineCov">   13301427 :   gimple_seq phis = phi_nodes (bb);</span>
<span class="lineNum">    1412 </span><span class="lineCov">   13301427 :   gimple *phi;</span>
<span class="lineNum">    1413 </span>            : 
<span class="lineNum">    1414 </span><span class="lineCov">   13301427 :   if (phis == NULL)</span>
<span class="lineNum">    1415 </span>            :     return false;
<span class="lineNum">    1416 </span>            : 
<span class="lineNum">    1417 </span><span class="lineCov">      61619 :   if (!gimple_seq_singleton_p (phis))</span>
<span class="lineNum">    1418 </span>            :     return true;
<span class="lineNum">    1419 </span>            : 
<span class="lineNum">    1420 </span><span class="lineCov">      49276 :   phi = gimple_seq_first_stmt (phis);</span>
<span class="lineNum">    1421 </span><span class="lineCov">      98552 :   return !virtual_operand_p (gimple_phi_result (phi));</span>
<span class="lineNum">    1422 </span>            : }
<span class="lineNum">    1423 </span>            : 
<span class="lineNum">    1424 </span>            : /* Returns true if redirecting the incoming edges of FROM to TO maintains the
<span class="lineNum">    1425 </span>            :    invariant that uses in FROM are dominates by their defs.  */
<a name="1426"><span class="lineNum">    1426 </span>            : </a>
<span class="lineNum">    1427 </span>            : static bool
<span class="lineNum">    1428 </span><span class="lineCov">    3214636 : deps_ok_for_redirect_from_bb_to_bb (basic_block from, basic_block to)</span>
<span class="lineNum">    1429 </span>            : {
<span class="lineNum">    1430 </span><span class="lineCov">    3214636 :   basic_block cd, dep_bb = BB_DEP_BB (to);</span>
<span class="lineNum">    1431 </span><span class="lineCov">    3214636 :   edge_iterator ei;</span>
<span class="lineNum">    1432 </span><span class="lineCov">    3214636 :   edge e;</span>
<span class="lineNum">    1433 </span>            : 
<span class="lineNum">    1434 </span><span class="lineCov">    3214636 :   if (dep_bb == NULL)</span>
<span class="lineNum">    1435 </span>            :     return true;
<span class="lineNum">    1436 </span>            : 
<span class="lineNum">    1437 </span><span class="lineCov">     762318 :   bitmap from_preds = BITMAP_ALLOC (NULL);</span>
<span class="lineNum">    1438 </span><span class="lineCov">    2301404 :   FOR_EACH_EDGE (e, ei, from-&gt;preds)</span>
<span class="lineNum">    1439 </span><span class="lineCov">     776768 :     bitmap_set_bit (from_preds, e-&gt;src-&gt;index);</span>
<span class="lineNum">    1440 </span><span class="lineCov">     762318 :   cd = nearest_common_dominator_for_set (CDI_DOMINATORS, from_preds);</span>
<span class="lineNum">    1441 </span><span class="lineCov">     762318 :   BITMAP_FREE (from_preds);</span>
<span class="lineNum">    1442 </span>            : 
<span class="lineNum">    1443 </span><span class="lineCov">     762318 :   return dominated_by_p (CDI_DOMINATORS, dep_bb, cd);</span>
<span class="lineNum">    1444 </span>            : }
<span class="lineNum">    1445 </span>            : 
<span class="lineNum">    1446 </span>            : /* Returns true if replacing BB1 (or its replacement bb) by BB2 (or its
<span class="lineNum">    1447 </span>            :    replacement bb) and vice versa maintains the invariant that uses in the
<span class="lineNum">    1448 </span>            :    replacement are dominates by their defs.  */
<a name="1449"><span class="lineNum">    1449 </span>            : </a>
<span class="lineNum">    1450 </span>            : static bool
<span class="lineNum">    1451 </span><span class="lineCov">    1719250 : deps_ok_for_redirect (basic_block bb1, basic_block bb2)</span>
<span class="lineNum">    1452 </span>            : {
<span class="lineNum">    1453 </span><span class="lineCov">    1719250 :   if (BB_CLUSTER (bb1) != NULL)</span>
<span class="lineNum">    1454 </span><span class="lineCov">     728613 :     bb1 = BB_CLUSTER (bb1)-&gt;rep_bb;</span>
<span class="lineNum">    1455 </span>            : 
<span class="lineNum">    1456 </span><span class="lineCov">    1719250 :   if (BB_CLUSTER (bb2) != NULL)</span>
<span class="lineNum">    1457 </span><span class="lineCov">     277284 :     bb2 = BB_CLUSTER (bb2)-&gt;rep_bb;</span>
<span class="lineNum">    1458 </span>            : 
<span class="lineNum">    1459 </span><span class="lineCov">    1719250 :   return (deps_ok_for_redirect_from_bb_to_bb (bb1, bb2)</span>
<span class="lineNum">    1460 </span><span class="lineCov">    1719250 :           &amp;&amp; deps_ok_for_redirect_from_bb_to_bb (bb2, bb1));</span>
<span class="lineNum">    1461 </span>            : }
<span class="lineNum">    1462 </span>            : 
<span class="lineNum">    1463 </span>            : /* Within SAME_SUCC-&gt;bbs, find clusters of bbs which can be merged.  */
<span class="lineNum">    1464 </span>            : 
<span class="lineNum">    1465 </span>            : static void
<span class="lineNum">    1466 </span><span class="lineCov">     629297 : find_clusters_1 (same_succ *same_succ)</span>
<span class="lineNum">    1467 </span>            : {
<span class="lineNum">    1468 </span><span class="lineCov">     629297 :   basic_block bb1, bb2;</span>
<span class="lineNum">    1469 </span><span class="lineCov">     629297 :   unsigned int i, j;</span>
<span class="lineNum">    1470 </span><span class="lineCov">     629297 :   bitmap_iterator bi, bj;</span>
<span class="lineNum">    1471 </span><span class="lineCov">     629297 :   int nr_comparisons;</span>
<span class="lineNum">    1472 </span><span class="lineCov">     629297 :   int max_comparisons = PARAM_VALUE (PARAM_MAX_TAIL_MERGE_COMPARISONS);</span>
<span class="lineNum">    1473 </span>            : 
<span class="lineNum">    1474 </span><span class="lineCov">    2846123 :   EXECUTE_IF_SET_IN_BITMAP (same_succ-&gt;bbs, 0, i, bi)</span>
<span class="lineNum">    1475 </span>            :     {
<span class="lineNum">    1476 </span><span class="lineCov">    2216826 :       bb1 = BASIC_BLOCK_FOR_FN (cfun, i);</span>
<span class="lineNum">    1477 </span>            : 
<span class="lineNum">    1478 </span>            :       /* TODO: handle blocks with phi-nodes.  We'll have to find corresponding
<span class="lineNum">    1479 </span>            :          phi-nodes in bb1 and bb2, with the same alternatives for the same
<span class="lineNum">    1480 </span>            :          preds.  */
<span class="lineNum">    1481 </span><span class="lineCov">    4421493 :       if (bb_has_non_vop_phi (bb1) || bb_has_eh_pred (bb1)</span>
<span class="lineNum">    1482 </span><span class="lineCov">    3828099 :           || bb_has_abnormal_pred (bb1))</span>
<span class="lineNum">    1483 </span><span class="lineCov">     605676 :         continue;</span>
<span class="lineNum">    1484 </span>            : 
<span class="lineNum">    1485 </span><span class="lineCov">    1611150 :       nr_comparisons = 0;</span>
<span class="lineNum">    1486 </span><span class="lineCov">   12635420 :       EXECUTE_IF_SET_IN_BITMAP (same_succ-&gt;bbs, i + 1, j, bj)</span>
<span class="lineNum">    1487 </span>            :         {
<span class="lineNum">    1488 </span><span class="lineCov">   11084601 :           bb2 = BASIC_BLOCK_FOR_FN (cfun, j);</span>
<span class="lineNum">    1489 </span>            : 
<span class="lineNum">    1490 </span><span class="lineCov">   22162581 :           if (bb_has_non_vop_phi (bb2) || bb_has_eh_pred (bb2)</span>
<span class="lineNum">    1491 </span><span class="lineCov">   22162282 :               || bb_has_abnormal_pred (bb2))</span>
<span class="lineNum">    1492 </span><span class="lineCov">       6920 :             continue;</span>
<span class="lineNum">    1493 </span>            : 
<span class="lineNum">    1494 </span><span class="lineCov">   11077681 :           if (BB_CLUSTER (bb1) != NULL &amp;&amp; BB_CLUSTER (bb1) == BB_CLUSTER (bb2))</span>
<span class="lineNum">    1495 </span>            :             continue;
<span class="lineNum">    1496 </span>            : 
<span class="lineNum">    1497 </span>            :           /* Limit quadratic behavior.  */
<span class="lineNum">    1498 </span><span class="lineCov">    1779581 :           nr_comparisons++;</span>
<span class="lineNum">    1499 </span><span class="lineCov">    1779581 :           if (nr_comparisons &gt; max_comparisons)</span>
<span class="lineNum">    1500 </span>            :             break;
<span class="lineNum">    1501 </span>            : 
<span class="lineNum">    1502 </span>            :           /* This is a conservative dependency check.  We could test more
<span class="lineNum">    1503 </span>            :              precise for allowed replacement direction.  */
<span class="lineNum">    1504 </span><span class="lineCov">    1719250 :           if (!deps_ok_for_redirect (bb1, bb2))</span>
<span class="lineNum">    1505 </span>            :             continue;
<span class="lineNum">    1506 </span>            : 
<span class="lineNum">    1507 </span><span class="lineCov">    1276123 :           if (!(same_phi_alternatives (same_succ, bb1, bb2)))</span>
<span class="lineNum">    1508 </span>            :             continue;
<span class="lineNum">    1509 </span>            : 
<span class="lineNum">    1510 </span><span class="lineCov">     776848 :           find_duplicate (same_succ, bb1, bb2);</span>
<span class="lineNum">    1511 </span>            :         }
<span class="lineNum">    1512 </span>            :     }
<span class="lineNum">    1513 </span><span class="lineCov">     629297 : }</span>
<span class="lineNum">    1514 </span>            : 
<span class="lineNum">    1515 </span>            : /* Find clusters of bbs which can be merged.  */
<span class="lineNum">    1516 </span>            : 
<span class="lineNum">    1517 </span>            : static void
<span class="lineNum">    1518 </span><span class="lineCov">     167944 : find_clusters (void)</span>
<span class="lineNum">    1519 </span>            : {
<span class="lineNum">    1520 </span><span class="lineCov">     797241 :   same_succ *same;</span>
<span class="lineNum">    1521 </span>            : 
<span class="lineNum">    1522 </span><span class="lineCov">     797241 :   while (!worklist.is_empty ())</span>
<span class="lineNum">    1523 </span>            :     {
<span class="lineNum">    1524 </span><span class="lineCov">     629297 :       same = worklist.pop ();</span>
<span class="lineNum">    1525 </span><span class="lineCov">     629297 :       same-&gt;in_worklist = false;</span>
<span class="lineNum">    1526 </span><span class="lineCov">     629297 :       if (dump_file &amp;&amp; (dump_flags &amp; TDF_DETAILS))</span>
<span class="lineNum">    1527 </span>            :         {
<span class="lineNum">    1528 </span><span class="lineCov">         10 :           fprintf (dump_file, &quot;processing worklist entry\n&quot;);</span>
<span class="lineNum">    1529 </span><span class="lineCov">         10 :           same_succ_print (dump_file, same);</span>
<span class="lineNum">    1530 </span>            :         }
<span class="lineNum">    1531 </span><span class="lineCov">     629297 :       find_clusters_1 (same);</span>
<span class="lineNum">    1532 </span>            :     }
<span class="lineNum">    1533 </span><span class="lineCov">     167944 : }</span>
<span class="lineNum">    1534 </span>            : 
<span class="lineNum">    1535 </span>            : /* Returns the vop phi of BB, if any.  */
<a name="1536"><span class="lineNum">    1536 </span>            : </a>
<span class="lineNum">    1537 </span>            : static gphi *
<span class="lineNum">    1538 </span><span class="lineCov">     745528 : vop_phi (basic_block bb)</span>
<span class="lineNum">    1539 </span>            : {
<span class="lineNum">    1540 </span><span class="lineCov">     745528 :   gphi *stmt;</span>
<span class="lineNum">    1541 </span><span class="lineCov">     745528 :   gphi_iterator gsi;</span>
<span class="lineNum">    1542 </span><span class="lineCov">     745528 :   for (gsi = gsi_start_phis (bb); !gsi_end_p (gsi); gsi_next (&amp;gsi))</span>
<span class="lineNum">    1543 </span>            :     {
<span class="lineNum">    1544 </span><span class="lineCov">      25191 :       stmt = gsi.phi ();</span>
<span class="lineNum">    1545 </span><span class="lineCov">      75573 :       if (! virtual_operand_p (gimple_phi_result (stmt)))</span>
<span class="lineNum">    1546 </span><span class="lineNoCov">          0 :         continue;</span>
<span class="lineNum">    1547 </span>            :       return stmt;
<span class="lineNum">    1548 </span>            :     }
<span class="lineNum">    1549 </span>            :   return NULL;
<span class="lineNum">    1550 </span>            : }
<span class="lineNum">    1551 </span>            : 
<span class="lineNum">    1552 </span>            : /* Redirect all edges from BB1 to BB2, removes BB1 and marks it as removed.  */
<span class="lineNum">    1553 </span>            : 
<span class="lineNum">    1554 </span>            : static void
<span class="lineNum">    1555 </span><span class="lineCov">     731262 : replace_block_by (basic_block bb1, basic_block bb2)</span>
<span class="lineNum">    1556 </span>            : {
<span class="lineNum">    1557 </span><span class="lineCov">     731262 :   edge pred_edge;</span>
<span class="lineNum">    1558 </span><span class="lineCov">     731262 :   unsigned int i;</span>
<span class="lineNum">    1559 </span><span class="lineCov">     731262 :   gphi *bb2_phi;</span>
<span class="lineNum">    1560 </span>            : 
<span class="lineNum">    1561 </span><span class="lineCov">     731262 :   bb2_phi = vop_phi (bb2);</span>
<span class="lineNum">    1562 </span>            : 
<span class="lineNum">    1563 </span>            :   /* Mark the basic block as deleted.  */
<span class="lineNum">    1564 </span><span class="lineCov">     731262 :   mark_basic_block_deleted (bb1);</span>
<span class="lineNum">    1565 </span>            : 
<span class="lineNum">    1566 </span>            :   /* Redirect the incoming edges of bb1 to bb2.  */
<span class="lineNum">    1567 </span><span class="lineCov">    2291658 :   for (i = EDGE_COUNT (bb1-&gt;preds); i &gt; 0 ; --i)</span>
<span class="lineNum">    1568 </span>            :     {
<span class="lineNum">    1569 </span><span class="lineCov">     829134 :       pred_edge = EDGE_PRED (bb1, i - 1);</span>
<span class="lineNum">    1570 </span><span class="lineCov">     829134 :       pred_edge = redirect_edge_and_branch (pred_edge, bb2);</span>
<span class="lineNum">    1571 </span><span class="lineCov">     829134 :       gcc_assert (pred_edge != NULL);</span>
<span class="lineNum">    1572 </span>            : 
<span class="lineNum">    1573 </span><span class="lineCov">     829134 :       if (bb2_phi == NULL)</span>
<span class="lineNum">    1574 </span>            :         continue;
<span class="lineNum">    1575 </span>            : 
<span class="lineNum">    1576 </span>            :       /* The phi might have run out of capacity when the redirect added an
<span class="lineNum">    1577 </span>            :          argument, which means it could have been replaced.  Refresh it.  */
<span class="lineNum">    1578 </span><span class="lineCov">      14266 :       bb2_phi = vop_phi (bb2);</span>
<span class="lineNum">    1579 </span>            : 
<span class="lineNum">    1580 </span><span class="lineCov">      28532 :       add_phi_arg (bb2_phi, SSA_NAME_VAR (gimple_phi_result (bb2_phi)),</span>
<span class="lineNum">    1581 </span>            :                    pred_edge, UNKNOWN_LOCATION);
<span class="lineNum">    1582 </span>            :     }
<span class="lineNum">    1583 </span>            : 
<span class="lineNum">    1584 </span>            : 
<span class="lineNum">    1585 </span>            :   /* Merge the outgoing edge counts from bb1 onto bb2.  */
<span class="lineNum">    1586 </span><span class="lineCov">     731262 :   edge e1, e2;</span>
<span class="lineNum">    1587 </span><span class="lineCov">     731262 :   edge_iterator ei;</span>
<span class="lineNum">    1588 </span>            : 
<span class="lineNum">    1589 </span><span class="lineCov">    1462524 :   if (bb2-&gt;count.initialized_p ())</span>
<span class="lineNum">    1590 </span><span class="lineCov">    2027811 :     FOR_EACH_EDGE (e1, ei, bb1-&gt;succs)</span>
<span class="lineNum">    1591 </span>            :       {
<span class="lineNum">    1592 </span><span class="lineCov">     565425 :         e2 = find_edge (bb2, e1-&gt;dest);</span>
<span class="lineNum">    1593 </span><span class="lineCov">     565425 :         gcc_assert (e2);</span>
<span class="lineNum">    1594 </span>            : 
<span class="lineNum">    1595 </span>            :         /* If probabilities are same, we are done.
<span class="lineNum">    1596 </span>            :            If counts are nonzero we can distribute accordingly. In remaining
<span class="lineNum">    1597 </span>            :            cases just avreage the values and hope for the best.  */
<span class="lineNum">    1598 </span><span class="lineCov">     565425 :         e2-&gt;probability = e1-&gt;probability.combine_with_count</span>
<span class="lineNum">    1599 </span><span class="lineCov">     565425 :                              (bb1-&gt;count, e2-&gt;probability, bb2-&gt;count);</span>
<span class="lineNum">    1600 </span>            :       }
<span class="lineNum">    1601 </span><span class="lineCov">     731262 :   bb2-&gt;count += bb1-&gt;count;</span>
<span class="lineNum">    1602 </span>            : 
<span class="lineNum">    1603 </span>            :   /* Move over any user labels from bb1 after the bb2 labels.  */
<span class="lineNum">    1604 </span><span class="lineCov">     731262 :   gimple_stmt_iterator gsi1 = gsi_start_bb (bb1);</span>
<span class="lineNum">    1605 </span><span class="lineCov">    1462524 :   if (!gsi_end_p (gsi1) &amp;&amp; gimple_code (gsi_stmt (gsi1)) == GIMPLE_LABEL)</span>
<span class="lineNum">    1606 </span>            :     {
<span class="lineNum">    1607 </span><span class="lineCov">       1578 :       gimple_stmt_iterator gsi2 = gsi_after_labels (bb2);</span>
<span class="lineNum">    1608 </span><span class="lineCov">       3157 :       while (!gsi_end_p (gsi1)</span>
<span class="lineNum">    1609 </span><span class="lineCov">       3157 :              &amp;&amp; gimple_code (gsi_stmt (gsi1)) == GIMPLE_LABEL)</span>
<span class="lineNum">    1610 </span>            :         {
<span class="lineNum">    1611 </span><span class="lineCov">       4737 :           tree label = gimple_label_label (as_a &lt;glabel *&gt; (gsi_stmt (gsi1)));</span>
<span class="lineNum">    1612 </span><span class="lineCov">       1579 :           gcc_assert (!DECL_NONLOCAL (label) &amp;&amp; !FORCED_LABEL (label));</span>
<span class="lineNum">    1613 </span><span class="lineCov">       3158 :           if (DECL_ARTIFICIAL (label))</span>
<span class="lineNum">    1614 </span><span class="lineCov">       1570 :             gsi_next (&amp;gsi1);</span>
<span class="lineNum">    1615 </span>            :           else
<span class="lineNum">    1616 </span><span class="lineCov">          9 :             gsi_move_before (&amp;gsi1, &amp;gsi2);</span>
<span class="lineNum">    1617 </span>            :         }
<span class="lineNum">    1618 </span>            :     }
<span class="lineNum">    1619 </span>            : 
<span class="lineNum">    1620 </span>            :   /* Clear range info from all stmts in BB2 -- this transformation
<span class="lineNum">    1621 </span>            :      could make them out of date.  */
<span class="lineNum">    1622 </span><span class="lineCov">     731262 :   reset_flow_sensitive_info_in_bb (bb2);</span>
<span class="lineNum">    1623 </span>            : 
<span class="lineNum">    1624 </span>            :   /* Do updates that use bb1, before deleting bb1.  */
<span class="lineNum">    1625 </span><span class="lineCov">     731262 :   release_last_vdef (bb1);</span>
<span class="lineNum">    1626 </span><span class="lineCov">     731262 :   same_succ_flush_bb (bb1);</span>
<span class="lineNum">    1627 </span>            : 
<span class="lineNum">    1628 </span><span class="lineCov">     731262 :   delete_basic_block (bb1);</span>
<span class="lineNum">    1629 </span><span class="lineCov">     731262 : }</span>
<span class="lineNum">    1630 </span>            : 
<span class="lineNum">    1631 </span>            : /* Bbs for which update_debug_stmt need to be called.  */
<span class="lineNum">    1632 </span>            : 
<span class="lineNum">    1633 </span>            : static bitmap update_bbs;
<span class="lineNum">    1634 </span>            : 
<span class="lineNum">    1635 </span>            : /* For each cluster in all_clusters, merge all cluster-&gt;bbs.  Returns
<span class="lineNum">    1636 </span>            :    number of bbs removed.  */
<span class="lineNum">    1637 </span>            : 
<span class="lineNum">    1638 </span>            : static int
<span class="lineNum">    1639 </span><span class="lineCov">     127257 : apply_clusters (void)</span>
<span class="lineNum">    1640 </span>            : {
<span class="lineNum">    1641 </span><span class="lineCov">     127257 :   basic_block bb1, bb2;</span>
<span class="lineNum">    1642 </span><span class="lineCov">     127257 :   bb_cluster *c;</span>
<span class="lineNum">    1643 </span><span class="lineCov">     127257 :   unsigned int i, j;</span>
<span class="lineNum">    1644 </span><span class="lineCov">     127257 :   bitmap_iterator bj;</span>
<span class="lineNum">    1645 </span><span class="lineCov">     127257 :   int nr_bbs_removed = 0;</span>
<span class="lineNum">    1646 </span>            : 
<span class="lineNum">    1647 </span><span class="lineCov">     939562 :   for (i = 0; i &lt; all_clusters.length (); ++i)</span>
<span class="lineNum">    1648 </span>            :     {
<span class="lineNum">    1649 </span><span class="lineCov">     342524 :       c = all_clusters[i];</span>
<span class="lineNum">    1650 </span><span class="lineCov">     342524 :       if (c == NULL)</span>
<span class="lineNum">    1651 </span>            :         continue;
<span class="lineNum">    1652 </span>            : 
<span class="lineNum">    1653 </span><span class="lineCov">     342524 :       bb2 = c-&gt;rep_bb;</span>
<span class="lineNum">    1654 </span><span class="lineCov">     342524 :       bitmap_set_bit (update_bbs, bb2-&gt;index);</span>
<span class="lineNum">    1655 </span>            : 
<span class="lineNum">    1656 </span><span class="lineCov">     342524 :       bitmap_clear_bit (c-&gt;bbs, bb2-&gt;index);</span>
<span class="lineNum">    1657 </span><span class="lineCov">    1073786 :       EXECUTE_IF_SET_IN_BITMAP (c-&gt;bbs, 0, j, bj)</span>
<span class="lineNum">    1658 </span>            :         {
<span class="lineNum">    1659 </span><span class="lineCov">     731262 :           bb1 = BASIC_BLOCK_FOR_FN (cfun, j);</span>
<span class="lineNum">    1660 </span><span class="lineCov">     731262 :           bitmap_clear_bit (update_bbs, bb1-&gt;index);</span>
<span class="lineNum">    1661 </span>            : 
<span class="lineNum">    1662 </span><span class="lineCov">     731262 :           replace_block_by (bb1, bb2);</span>
<span class="lineNum">    1663 </span><span class="lineCov">     731262 :           nr_bbs_removed++;</span>
<span class="lineNum">    1664 </span>            :         }
<span class="lineNum">    1665 </span>            :     }
<span class="lineNum">    1666 </span>            : 
<span class="lineNum">    1667 </span><span class="lineCov">     127257 :   return nr_bbs_removed;</span>
<span class="lineNum">    1668 </span>            : }
<span class="lineNum">    1669 </span>            : 
<span class="lineNum">    1670 </span>            : /* Resets debug statement STMT if it has uses that are not dominated by their
<span class="lineNum">    1671 </span>            :    defs.  */
<a name="1672"><span class="lineNum">    1672 </span>            : </a>
<span class="lineNum">    1673 </span>            : static void
<span class="lineNum">    1674 </span><span class="lineCov">      37663 : update_debug_stmt (gimple *stmt)</span>
<span class="lineNum">    1675 </span>            : {
<span class="lineNum">    1676 </span><span class="lineCov">      37663 :   use_operand_p use_p;</span>
<span class="lineNum">    1677 </span><span class="lineCov">      37663 :   ssa_op_iter oi;</span>
<span class="lineNum">    1678 </span><span class="lineCov">      37663 :   basic_block bbuse;</span>
<span class="lineNum">    1679 </span>            : 
<span class="lineNum">    1680 </span><span class="lineCov">      37663 :   if (!gimple_debug_bind_p (stmt))</span>
<span class="lineNum">    1681 </span><span class="lineCov">       9421 :     return;</span>
<span class="lineNum">    1682 </span>            : 
<span class="lineNum">    1683 </span><span class="lineCov">      28242 :   bbuse = gimple_bb (stmt);</span>
<span class="lineNum">    1684 </span><span class="lineCov">      60724 :   FOR_EACH_PHI_OR_STMT_USE (use_p, stmt, oi, SSA_OP_USE)</span>
<span class="lineNum">    1685 </span>            :     {
<span class="lineNum">    1686 </span><span class="lineCov">       3612 :       tree name = USE_FROM_PTR (use_p);</span>
<span class="lineNum">    1687 </span><span class="lineCov">       3612 :       gimple *def_stmt = SSA_NAME_DEF_STMT (name);</span>
<span class="lineNum">    1688 </span><span class="lineCov">       3612 :       basic_block bbdef = gimple_bb (def_stmt);</span>
<span class="lineNum">    1689 </span><span class="lineCov">       3612 :       if (bbdef == NULL || bbuse == bbdef</span>
<span class="lineNum">    1690 </span><span class="lineCov">       3612 :           || dominated_by_p (CDI_DOMINATORS, bbuse, bbdef))</span>
<span class="lineNum">    1691 </span><span class="lineCov">       2120 :         continue;</span>
<span class="lineNum">    1692 </span>            : 
<span class="lineNum">    1693 </span><span class="lineCov">       1492 :       gimple_debug_bind_reset_value (stmt);</span>
<span class="lineNum">    1694 </span><span class="lineCov">       1492 :       update_stmt (stmt);</span>
<span class="lineNum">    1695 </span>            :       break;
<span class="lineNum">    1696 </span>            :     }
<span class="lineNum">    1697 </span>            : }
<span class="lineNum">    1698 </span>            : 
<span class="lineNum">    1699 </span>            : /* Resets all debug statements that have uses that are not
<span class="lineNum">    1700 </span>            :    dominated by their defs.  */
<span class="lineNum">    1701 </span>            : 
<span class="lineNum">    1702 </span>            : static void
<span class="lineNum">    1703 </span><span class="lineCov">      82439 : update_debug_stmts (void)</span>
<span class="lineNum">    1704 </span>            : {
<span class="lineNum">    1705 </span><span class="lineCov">      82439 :   basic_block bb;</span>
<span class="lineNum">    1706 </span><span class="lineCov">      82439 :   bitmap_iterator bi;</span>
<span class="lineNum">    1707 </span><span class="lineCov">      82439 :   unsigned int i;</span>
<span class="lineNum">    1708 </span>            : 
<span class="lineNum">    1709 </span><span class="lineCov">     318752 :   EXECUTE_IF_SET_IN_BITMAP (update_bbs, 0, i, bi)</span>
<span class="lineNum">    1710 </span>            :     {
<span class="lineNum">    1711 </span><span class="lineCov">     236313 :       gimple *stmt;</span>
<span class="lineNum">    1712 </span><span class="lineCov">     236313 :       gimple_stmt_iterator gsi;</span>
<span class="lineNum">    1713 </span>            : 
<span class="lineNum">    1714 </span><span class="lineCov">     236313 :       bb = BASIC_BLOCK_FOR_FN (cfun, i);</span>
<span class="lineNum">    1715 </span><span class="lineCov">     549656 :       for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&amp;gsi))</span>
<span class="lineNum">    1716 </span>            :         {
<span class="lineNum">    1717 </span><span class="lineCov">      77030 :           stmt = gsi_stmt (gsi);</span>
<span class="lineNum">    1718 </span><span class="lineCov">     154060 :           if (!is_gimple_debug (stmt))</span>
<span class="lineNum">    1719 </span>            :             continue;
<span class="lineNum">    1720 </span><span class="lineCov">      37663 :           update_debug_stmt (stmt);</span>
<span class="lineNum">    1721 </span>            :         }
<span class="lineNum">    1722 </span>            :     }
<span class="lineNum">    1723 </span><span class="lineCov">      82439 : }</span>
<span class="lineNum">    1724 </span>            : 
<span class="lineNum">    1725 </span>            : /* Runs tail merge optimization.  */
<span class="lineNum">    1726 </span>            : 
<span class="lineNum">    1727 </span>            : unsigned int
<span class="lineNum">    1728 </span><span class="lineCov">     584052 : tail_merge_optimize (unsigned int todo)</span>
<span class="lineNum">    1729 </span>            : {
<span class="lineNum">    1730 </span><span class="lineCov">     584052 :   int nr_bbs_removed_total = 0;</span>
<span class="lineNum">    1731 </span><span class="lineCov">     584052 :   int nr_bbs_removed;</span>
<span class="lineNum">    1732 </span><span class="lineCov">     584052 :   bool loop_entered = false;</span>
<span class="lineNum">    1733 </span><span class="lineCov">     584052 :   int iteration_nr = 0;</span>
<span class="lineNum">    1734 </span><span class="lineCov">     584052 :   int max_iterations = PARAM_VALUE (PARAM_MAX_TAIL_MERGE_ITERATIONS);</span>
<span class="lineNum">    1735 </span>            : 
<span class="lineNum">    1736 </span><span class="lineCov">     584052 :   if (!flag_tree_tail_merge</span>
<span class="lineNum">    1737 </span><span class="lineCov">     584023 :       || max_iterations == 0)</span>
<span class="lineNum">    1738 </span>            :     return 0;
<span class="lineNum">    1739 </span>            : 
<span class="lineNum">    1740 </span><span class="lineCov">     584016 :   timevar_push (TV_TREE_TAIL_MERGE);</span>
<span class="lineNum">    1741 </span>            : 
<span class="lineNum">    1742 </span>            :   /* We enter from PRE which has critical edges split.  Elimination
<span class="lineNum">    1743 </span>            :      does not process trivially dead code so cleanup the CFG if we
<span class="lineNum">    1744 </span>            :      are told so.  And re-split critical edges then.  */
<span class="lineNum">    1745 </span><span class="lineCov">     584016 :   if (todo &amp; TODO_cleanup_cfg)</span>
<span class="lineNum">    1746 </span>            :     {
<span class="lineNum">    1747 </span><span class="lineCov">      72740 :       cleanup_tree_cfg ();</span>
<span class="lineNum">    1748 </span><span class="lineCov">      72740 :       todo &amp;= ~TODO_cleanup_cfg;</span>
<span class="lineNum">    1749 </span><span class="lineCov">      72740 :       split_critical_edges ();</span>
<span class="lineNum">    1750 </span>            :     }
<span class="lineNum">    1751 </span>            : 
<span class="lineNum">    1752 </span><span class="lineCov">     584016 :   if (!dom_info_available_p (CDI_DOMINATORS))</span>
<span class="lineNum">    1753 </span>            :     {
<span class="lineNum">    1754 </span>            :       /* PRE can leave us with unreachable blocks, remove them now.  */
<span class="lineNum">    1755 </span><span class="lineNoCov">          0 :       delete_unreachable_blocks ();</span>
<span class="lineNum">    1756 </span><span class="lineNoCov">          0 :       calculate_dominance_info (CDI_DOMINATORS);</span>
<span class="lineNum">    1757 </span>            :     }
<span class="lineNum">    1758 </span><span class="lineCov">     584016 :   init_worklist ();</span>
<span class="lineNum">    1759 </span>            : 
<span class="lineNum">    1760 </span><span class="lineCov">     707316 :   while (!worklist.is_empty ())</span>
<span class="lineNum">    1761 </span>            :     {
<span class="lineNum">    1762 </span><span class="lineCov">     167944 :       if (!loop_entered)</span>
<span class="lineNum">    1763 </span>            :         {
<span class="lineNum">    1764 </span><span class="lineCov">     161856 :           loop_entered = true;</span>
<span class="lineNum">    1765 </span><span class="lineCov">     161856 :           alloc_cluster_vectors ();</span>
<span class="lineNum">    1766 </span><span class="lineCov">     161856 :           update_bbs = BITMAP_ALLOC (NULL);</span>
<span class="lineNum">    1767 </span>            :         }
<span class="lineNum">    1768 </span>            :       else
<span class="lineNum">    1769 </span><span class="lineCov">       6088 :         reset_cluster_vectors ();</span>
<span class="lineNum">    1770 </span>            : 
<span class="lineNum">    1771 </span><span class="lineCov">     167944 :       iteration_nr++;</span>
<span class="lineNum">    1772 </span><span class="lineCov">     167944 :       if (dump_file &amp;&amp; (dump_flags &amp; TDF_DETAILS))</span>
<span class="lineNum">    1773 </span><span class="lineCov">          9 :         fprintf (dump_file, &quot;worklist iteration #%d\n&quot;, iteration_nr);</span>
<span class="lineNum">    1774 </span>            : 
<span class="lineNum">    1775 </span><span class="lineCov">     167944 :       find_clusters ();</span>
<span class="lineNum">    1776 </span><span class="lineCov">     167944 :       gcc_assert (worklist.is_empty ());</span>
<span class="lineNum">    1777 </span><span class="lineCov">     167944 :       if (all_clusters.is_empty ())</span>
<span class="lineNum">    1778 </span>            :         break;
<span class="lineNum">    1779 </span>            : 
<span class="lineNum">    1780 </span><span class="lineCov">     127257 :       nr_bbs_removed = apply_clusters ();</span>
<span class="lineNum">    1781 </span><span class="lineCov">     127257 :       nr_bbs_removed_total += nr_bbs_removed;</span>
<span class="lineNum">    1782 </span><span class="lineCov">     127257 :       if (nr_bbs_removed == 0)</span>
<span class="lineNum">    1783 </span>            :         break;
<span class="lineNum">    1784 </span>            : 
<span class="lineNum">    1785 </span><span class="lineCov">     127257 :       free_dominance_info (CDI_DOMINATORS);</span>
<span class="lineNum">    1786 </span>            : 
<span class="lineNum">    1787 </span><span class="lineCov">     127257 :       if (iteration_nr == max_iterations)</span>
<span class="lineNum">    1788 </span>            :         break;
<span class="lineNum">    1789 </span>            : 
<span class="lineNum">    1790 </span><span class="lineCov">     123300 :       calculate_dominance_info (CDI_DOMINATORS);</span>
<span class="lineNum">    1791 </span><span class="lineCov">     123300 :       update_worklist ();</span>
<span class="lineNum">    1792 </span>            :     }
<span class="lineNum">    1793 </span>            : 
<span class="lineNum">    1794 </span><span class="lineCov">     584016 :   if (dump_file &amp;&amp; (dump_flags &amp; TDF_DETAILS))</span>
<span class="lineNum">    1795 </span><span class="lineCov">         28 :     fprintf (dump_file, &quot;htab collision / search: %f\n&quot;,</span>
<span class="lineNum">    1796 </span>            :              same_succ_htab-&gt;collisions ());
<span class="lineNum">    1797 </span>            : 
<span class="lineNum">    1798 </span><span class="lineCov">     584016 :   if (nr_bbs_removed_total &gt; 0)</span>
<span class="lineNum">    1799 </span>            :     {
<span class="lineNum">    1800 </span><span class="lineCov">     123300 :       if (MAY_HAVE_DEBUG_BIND_STMTS)</span>
<span class="lineNum">    1801 </span>            :         {
<span class="lineNum">    1802 </span><span class="lineCov">      82439 :           calculate_dominance_info (CDI_DOMINATORS);</span>
<span class="lineNum">    1803 </span><span class="lineCov">      82439 :           update_debug_stmts ();</span>
<span class="lineNum">    1804 </span>            :         }
<span class="lineNum">    1805 </span>            : 
<span class="lineNum">    1806 </span><span class="lineCov">     123300 :       if (dump_file &amp;&amp; (dump_flags &amp; TDF_DETAILS))</span>
<span class="lineNum">    1807 </span>            :         {
<span class="lineNum">    1808 </span><span class="lineCov">          2 :           fprintf (dump_file, &quot;Before TODOs.\n&quot;);</span>
<span class="lineNum">    1809 </span><span class="lineCov">          2 :           dump_function_to_file (current_function_decl, dump_file, dump_flags);</span>
<span class="lineNum">    1810 </span>            :         }
<span class="lineNum">    1811 </span>            : 
<span class="lineNum">    1812 </span><span class="lineCov">     123300 :       mark_virtual_operands_for_renaming (cfun);</span>
<span class="lineNum">    1813 </span>            :     }
<span class="lineNum">    1814 </span>            : 
<span class="lineNum">    1815 </span><span class="lineCov">     584016 :   delete_worklist ();</span>
<span class="lineNum">    1816 </span><span class="lineCov">     584016 :   if (loop_entered)</span>
<span class="lineNum">    1817 </span>            :     {
<span class="lineNum">    1818 </span><span class="lineCov">     161856 :       delete_cluster_vectors ();</span>
<span class="lineNum">    1819 </span><span class="lineCov">     161856 :       BITMAP_FREE (update_bbs);</span>
<span class="lineNum">    1820 </span>            :     }
<span class="lineNum">    1821 </span>            : 
<span class="lineNum">    1822 </span><span class="lineCov">     584016 :   timevar_pop (TV_TREE_TAIL_MERGE);</span>
<span class="lineNum">    1823 </span>            : 
<span class="lineNum">    1824 </span>            :   return todo;
<span class="lineNum">    1825 </span>            : }
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.0</a></td></tr>
  </table>
  <br>
<h3>LCOV profile is generated on x86_64 machine using following configure options: configure --disable-bootstrap --enable-coverage=opt --enable-languages=c,c++,fortran,go,jit,lto --enable-host-shared. GCC test suite is run with the built compiler.</h3></body></html>
