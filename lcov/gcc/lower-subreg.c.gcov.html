<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - gcc.info - gcc/lower-subreg.c</title>
  <link rel="stylesheet" type="text/css" href="../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../index.html">top level</a> - <a href="index.html">gcc</a> - lower-subreg.c<span style="font-size: 80%;"> (source / <a href="lower-subreg.c.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">gcc.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">653</td>
            <td class="headerCovTableEntry">726</td>
            <td class="headerCovTableEntryMed">89.9 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2018-09-22 10:58:49</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">31</td>
            <td class="headerCovTableEntry">33</td>
            <td class="headerCovTableEntryHi">93.9 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /* Decompose multiword subregs.</a>
<span class="lineNum">       2 </span>            :    Copyright (C) 2007-2018 Free Software Foundation, Inc.
<span class="lineNum">       3 </span>            :    Contributed by Richard Henderson &lt;rth@redhat.com&gt;
<span class="lineNum">       4 </span>            :                   Ian Lance Taylor &lt;iant@google.com&gt;
<span class="lineNum">       5 </span>            : 
<span class="lineNum">       6 </span>            : This file is part of GCC.
<span class="lineNum">       7 </span>            : 
<span class="lineNum">       8 </span>            : GCC is free software; you can redistribute it and/or modify it under
<span class="lineNum">       9 </span>            : the terms of the GNU General Public License as published by the Free
<span class="lineNum">      10 </span>            : Software Foundation; either version 3, or (at your option) any later
<span class="lineNum">      11 </span>            : version.
<span class="lineNum">      12 </span>            : 
<span class="lineNum">      13 </span>            : GCC is distributed in the hope that it will be useful, but WITHOUT ANY
<span class="lineNum">      14 </span>            : WARRANTY; without even the implied warranty of MERCHANTABILITY or
<span class="lineNum">      15 </span>            : FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
<span class="lineNum">      16 </span>            : for more details.
<span class="lineNum">      17 </span>            : 
<span class="lineNum">      18 </span>            : You should have received a copy of the GNU General Public License
<span class="lineNum">      19 </span>            : along with GCC; see the file COPYING3.  If not see
<span class="lineNum">      20 </span>            : &lt;http://www.gnu.org/licenses/&gt;.  */
<span class="lineNum">      21 </span>            : 
<span class="lineNum">      22 </span>            : #include &quot;config.h&quot;
<span class="lineNum">      23 </span>            : #include &quot;system.h&quot;
<span class="lineNum">      24 </span>            : #include &quot;coretypes.h&quot;
<span class="lineNum">      25 </span>            : #include &quot;backend.h&quot;
<span class="lineNum">      26 </span>            : #include &quot;rtl.h&quot;
<span class="lineNum">      27 </span>            : #include &quot;tree.h&quot;
<span class="lineNum">      28 </span>            : #include &quot;cfghooks.h&quot;
<span class="lineNum">      29 </span>            : #include &quot;df.h&quot;
<span class="lineNum">      30 </span>            : #include &quot;memmodel.h&quot;
<span class="lineNum">      31 </span>            : #include &quot;tm_p.h&quot;
<span class="lineNum">      32 </span>            : #include &quot;expmed.h&quot;
<span class="lineNum">      33 </span>            : #include &quot;insn-config.h&quot;
<span class="lineNum">      34 </span>            : #include &quot;emit-rtl.h&quot;
<span class="lineNum">      35 </span>            : #include &quot;recog.h&quot;
<span class="lineNum">      36 </span>            : #include &quot;cfgrtl.h&quot;
<span class="lineNum">      37 </span>            : #include &quot;cfgbuild.h&quot;
<span class="lineNum">      38 </span>            : #include &quot;dce.h&quot;
<span class="lineNum">      39 </span>            : #include &quot;expr.h&quot;
<span class="lineNum">      40 </span>            : #include &quot;tree-pass.h&quot;
<span class="lineNum">      41 </span>            : #include &quot;lower-subreg.h&quot;
<span class="lineNum">      42 </span>            : #include &quot;rtl-iter.h&quot;
<span class="lineNum">      43 </span>            : #include &quot;target.h&quot;
<span class="lineNum">      44 </span>            : 
<span class="lineNum">      45 </span>            : 
<span class="lineNum">      46 </span>            : /* Decompose multi-word pseudo-registers into individual
<span class="lineNum">      47 </span>            :    pseudo-registers when possible and profitable.  This is possible
<span class="lineNum">      48 </span>            :    when all the uses of a multi-word register are via SUBREG, or are
<span class="lineNum">      49 </span>            :    copies of the register to another location.  Breaking apart the
<span class="lineNum">      50 </span>            :    register permits more CSE and permits better register allocation.
<span class="lineNum">      51 </span>            :    This is profitable if the machine does not have move instructions
<span class="lineNum">      52 </span>            :    to do this.
<span class="lineNum">      53 </span>            : 
<span class="lineNum">      54 </span>            :    This pass only splits moves with modes that are wider than
<span class="lineNum">      55 </span>            :    word_mode and ASHIFTs, LSHIFTRTs, ASHIFTRTs and ZERO_EXTENDs with
<span class="lineNum">      56 </span>            :    integer modes that are twice the width of word_mode.  The latter
<span class="lineNum">      57 </span>            :    could be generalized if there was a need to do this, but the trend in
<span class="lineNum">      58 </span>            :    architectures is to not need this.
<span class="lineNum">      59 </span>            : 
<span class="lineNum">      60 </span>            :    There are two useful preprocessor defines for use by maintainers:
<span class="lineNum">      61 </span>            : 
<span class="lineNum">      62 </span>            :    #define LOG_COSTS 1
<span class="lineNum">      63 </span>            : 
<span class="lineNum">      64 </span>            :    if you wish to see the actual cost estimates that are being used
<span class="lineNum">      65 </span>            :    for each mode wider than word mode and the cost estimates for zero
<span class="lineNum">      66 </span>            :    extension and the shifts.   This can be useful when port maintainers
<span class="lineNum">      67 </span>            :    are tuning insn rtx costs.
<span class="lineNum">      68 </span>            : 
<span class="lineNum">      69 </span>            :    #define FORCE_LOWERING 1
<span class="lineNum">      70 </span>            : 
<span class="lineNum">      71 </span>            :    if you wish to test the pass with all the transformation forced on.
<span class="lineNum">      72 </span>            :    This can be useful for finding bugs in the transformations.  */
<span class="lineNum">      73 </span>            : 
<span class="lineNum">      74 </span>            : #define LOG_COSTS 0
<span class="lineNum">      75 </span>            : #define FORCE_LOWERING 0
<span class="lineNum">      76 </span>            : 
<span class="lineNum">      77 </span>            : /* Bit N in this bitmap is set if regno N is used in a context in
<span class="lineNum">      78 </span>            :    which we can decompose it.  */
<span class="lineNum">      79 </span>            : static bitmap decomposable_context;
<span class="lineNum">      80 </span>            : 
<span class="lineNum">      81 </span>            : /* Bit N in this bitmap is set if regno N is used in a context in
<span class="lineNum">      82 </span>            :    which it can not be decomposed.  */
<span class="lineNum">      83 </span>            : static bitmap non_decomposable_context;
<span class="lineNum">      84 </span>            : 
<span class="lineNum">      85 </span>            : /* Bit N in this bitmap is set if regno N is used in a subreg
<span class="lineNum">      86 </span>            :    which changes the mode but not the size.  This typically happens
<span class="lineNum">      87 </span>            :    when the register accessed as a floating-point value; we want to
<span class="lineNum">      88 </span>            :    avoid generating accesses to its subwords in integer modes.  */
<span class="lineNum">      89 </span>            : static bitmap subreg_context;
<span class="lineNum">      90 </span>            : 
<span class="lineNum">      91 </span>            : /* Bit N in the bitmap in element M of this array is set if there is a
<span class="lineNum">      92 </span>            :    copy from reg M to reg N.  */
<span class="lineNum">      93 </span>            : static vec&lt;bitmap&gt; reg_copy_graph;
<span class="lineNum">      94 </span>            : 
<span class="lineNum">      95 </span>            : struct target_lower_subreg default_target_lower_subreg;
<span class="lineNum">      96 </span>            : #if SWITCHABLE_TARGET
<span class="lineNum">      97 </span>            : struct target_lower_subreg *this_target_lower_subreg
<span class="lineNum">      98 </span>            :   = &amp;default_target_lower_subreg;
<span class="lineNum">      99 </span>            : #endif
<span class="lineNum">     100 </span>            : 
<span class="lineNum">     101 </span>            : #define twice_word_mode \
<span class="lineNum">     102 </span>            :   this_target_lower_subreg-&gt;x_twice_word_mode
<span class="lineNum">     103 </span>            : #define choices \
<span class="lineNum">     104 </span>            :   this_target_lower_subreg-&gt;x_choices
<span class="lineNum">     105 </span>            : 
<span class="lineNum">     106 </span>            : /* Return true if MODE is a mode we know how to lower.  When returning true,
<span class="lineNum">     107 </span>            :    store its byte size in *BYTES and its word size in *WORDS.  */
<a name="108"><span class="lineNum">     108 </span>            : </a>
<span class="lineNum">     109 </span>            : static inline bool
<span class="lineNum">     110 </span><span class="lineCov">   61816077 : interesting_mode_p (machine_mode mode, unsigned int *bytes,</span>
<span class="lineNum">     111 </span>            :                     unsigned int *words)
<span class="lineNum">     112 </span>            : {
<span class="lineNum">     113 </span><span class="lineCov">  123632154 :   if (!GET_MODE_SIZE (mode).is_constant (bytes))</span>
<span class="lineNum">     114 </span>            :     return false;
<span class="lineNum">     115 </span><span class="lineCov">   61816077 :   *words = CEIL (*bytes, UNITS_PER_WORD);</span>
<span class="lineNum">     116 </span><span class="lineCov">   61816077 :   return true;</span>
<span class="lineNum">     117 </span>            : }
<span class="lineNum">     118 </span>            : 
<span class="lineNum">     119 </span>            : /* RTXes used while computing costs.  */
<span class="lineNum">     120 </span>            : struct cost_rtxes {
<span class="lineNum">     121 </span>            :   /* Source and target registers.  */
<span class="lineNum">     122 </span>            :   rtx source;
<span class="lineNum">     123 </span>            :   rtx target;
<span class="lineNum">     124 </span>            : 
<span class="lineNum">     125 </span>            :   /* A twice_word_mode ZERO_EXTEND of SOURCE.  */
<span class="lineNum">     126 </span>            :   rtx zext;
<span class="lineNum">     127 </span>            : 
<span class="lineNum">     128 </span>            :   /* A shift of SOURCE.  */
<span class="lineNum">     129 </span>            :   rtx shift;
<span class="lineNum">     130 </span>            : 
<span class="lineNum">     131 </span>            :   /* A SET of TARGET.  */
<span class="lineNum">     132 </span>            :   rtx set;
<span class="lineNum">     133 </span>            : };
<span class="lineNum">     134 </span>            : 
<span class="lineNum">     135 </span>            : /* Return the cost of a CODE shift in mode MODE by OP1 bits, using the
<span class="lineNum">     136 </span>            :    rtxes in RTXES.  SPEED_P selects between the speed and size cost.  */
<a name="137"><span class="lineNum">     137 </span>            : </a>
<span class="lineNum">     138 </span>            : static int
<span class="lineNum">     139 </span><span class="lineCov">  114339768 : shift_cost (bool speed_p, struct cost_rtxes *rtxes, enum rtx_code code,</span>
<span class="lineNum">     140 </span>            :             machine_mode mode, int op1)
<span class="lineNum">     141 </span>            : {
<span class="lineNum">     142 </span><span class="lineCov">  114339768 :   PUT_CODE (rtxes-&gt;shift, code);</span>
<span class="lineNum">     143 </span><span class="lineCov">  114339768 :   PUT_MODE (rtxes-&gt;shift, mode);</span>
<span class="lineNum">     144 </span><span class="lineCov">  114339768 :   PUT_MODE (rtxes-&gt;source, mode);</span>
<span class="lineNum">     145 </span><span class="lineCov">  228679536 :   XEXP (rtxes-&gt;shift, 1) = gen_int_shift_amount (mode, op1);</span>
<span class="lineNum">     146 </span><span class="lineCov">  114339768 :   return set_src_cost (rtxes-&gt;shift, mode, speed_p);</span>
<span class="lineNum">     147 </span>            : }
<span class="lineNum">     148 </span>            : 
<span class="lineNum">     149 </span>            : /* For each X in the range [0, BITS_PER_WORD), set SPLITTING[X]
<span class="lineNum">     150 </span>            :    to true if it is profitable to split a double-word CODE shift
<span class="lineNum">     151 </span>            :    of X + BITS_PER_WORD bits.  SPEED_P says whether we are testing
<span class="lineNum">     152 </span>            :    for speed or size profitability.
<span class="lineNum">     153 </span>            : 
<span class="lineNum">     154 </span>            :    Use the rtxes in RTXES to calculate costs.  WORD_MOVE_ZERO_COST is
<span class="lineNum">     155 </span>            :    the cost of moving zero into a word-mode register.  WORD_MOVE_COST
<span class="lineNum">     156 </span>            :    is the cost of moving between word registers.  */
<a name="157"><span class="lineNum">     157 </span>            : </a>
<span class="lineNum">     158 </span>            : static void
<span class="lineNum">     159 </span><span class="lineCov">     785670 : compute_splitting_shift (bool speed_p, struct cost_rtxes *rtxes,</span>
<span class="lineNum">     160 </span>            :                          bool *splitting, enum rtx_code code,
<span class="lineNum">     161 </span>            :                          int word_move_zero_cost, int word_move_cost)
<span class="lineNum">     162 </span>            : {
<span class="lineNum">     163 </span><span class="lineCov">     785670 :   int wide_cost, narrow_cost, upper_cost, i;</span>
<span class="lineNum">     164 </span>            : 
<span class="lineNum">     165 </span><span class="lineCov">   51094524 :   for (i = 0; i &lt; BITS_PER_WORD; i++)</span>
<span class="lineNum">     166 </span>            :     {
<span class="lineNum">     167 </span><span class="lineCov">   98903424 :       wide_cost = shift_cost (speed_p, rtxes, code, twice_word_mode,</span>
<span class="lineNum">     168 </span><span class="lineCov">   49451712 :                               i + BITS_PER_WORD);</span>
<span class="lineNum">     169 </span><span class="lineCov">   49451712 :       if (i == 0)</span>
<span class="lineNum">     170 </span>            :         narrow_cost = word_move_cost;
<span class="lineNum">     171 </span>            :       else
<span class="lineNum">     172 </span><span class="lineCov">   97332084 :         narrow_cost = shift_cost (speed_p, rtxes, code, word_mode, i);</span>
<span class="lineNum">     173 </span>            : 
<span class="lineNum">     174 </span><span class="lineCov">   49451712 :       if (code != ASHIFTRT)</span>
<span class="lineNum">     175 </span>            :         upper_cost = word_move_zero_cost;
<span class="lineNum">     176 </span><span class="lineCov">   16760960 :       else if (i == BITS_PER_WORD - 1)</span>
<span class="lineNum">     177 </span>            :         upper_cost = word_move_cost;
<span class="lineNum">     178 </span>            :       else
<span class="lineNum">     179 </span><span class="lineCov">   16758810 :         upper_cost = shift_cost (speed_p, rtxes, code, word_mode,</span>
<span class="lineNum">     180 </span>            :                                  BITS_PER_WORD - 1);
<span class="lineNum">     181 </span>            : 
<span class="lineNum">     182 </span><span class="lineCov">   49451712 :       if (LOG_COSTS)</span>
<span class="lineNum">     183 </span>            :         fprintf (stderr, &quot;%s %s by %d: original cost %d, split cost %d + %d\n&quot;,
<span class="lineNum">     184 </span>            :                  GET_MODE_NAME (twice_word_mode), GET_RTX_NAME (code),
<span class="lineNum">     185 </span>            :                  i + BITS_PER_WORD, wide_cost, narrow_cost, upper_cost);
<span class="lineNum">     186 </span>            : 
<span class="lineNum">     187 </span><span class="lineCov">   49451712 :       if (FORCE_LOWERING || wide_cost &gt;= narrow_cost + upper_cost)</span>
<span class="lineNum">     188 </span><span class="lineCov">   49451712 :         splitting[i] = true;</span>
<span class="lineNum">     189 </span>            :     }
<span class="lineNum">     190 </span><span class="lineCov">     785670 : }</span>
<span class="lineNum">     191 </span>            : 
<span class="lineNum">     192 </span>            : /* Compute what we should do when optimizing for speed or size; SPEED_P
<span class="lineNum">     193 </span>            :    selects which.  Use RTXES for computing costs.  */
<a name="194"><span class="lineNum">     194 </span>            : </a>
<span class="lineNum">     195 </span>            : static void
<span class="lineNum">     196 </span><span class="lineCov">     261890 : compute_costs (bool speed_p, struct cost_rtxes *rtxes)</span>
<span class="lineNum">     197 </span>            : {
<span class="lineNum">     198 </span><span class="lineCov">     261890 :   unsigned int i;</span>
<span class="lineNum">     199 </span><span class="lineCov">     261890 :   int word_move_zero_cost, word_move_cost;</span>
<span class="lineNum">     200 </span>            : 
<span class="lineNum">     201 </span><span class="lineCov">     523780 :   PUT_MODE (rtxes-&gt;target, word_mode);</span>
<span class="lineNum">     202 </span><span class="lineCov">     261890 :   SET_SRC (rtxes-&gt;set) = CONST0_RTX (word_mode);</span>
<span class="lineNum">     203 </span><span class="lineCov">     261890 :   word_move_zero_cost = set_rtx_cost (rtxes-&gt;set, speed_p);</span>
<span class="lineNum">     204 </span>            : 
<span class="lineNum">     205 </span><span class="lineCov">     261890 :   SET_SRC (rtxes-&gt;set) = rtxes-&gt;source;</span>
<span class="lineNum">     206 </span><span class="lineCov">     261890 :   word_move_cost = set_rtx_cost (rtxes-&gt;set, speed_p);</span>
<span class="lineNum">     207 </span>            : 
<span class="lineNum">     208 </span><span class="lineCov">     261890 :   if (LOG_COSTS)</span>
<span class="lineNum">     209 </span>            :     fprintf (stderr, &quot;%s move: from zero cost %d, from reg cost %d\n&quot;,
<span class="lineNum">     210 </span>            :              GET_MODE_NAME (word_mode), word_move_zero_cost, word_move_cost);
<span class="lineNum">     211 </span>            : 
<span class="lineNum">     212 </span><span class="lineCov">   27760340 :   for (i = 0; i &lt; MAX_MACHINE_MODE; i++)</span>
<span class="lineNum">     213 </span>            :     {
<span class="lineNum">     214 </span><span class="lineCov">   27498450 :       machine_mode mode = (machine_mode) i;</span>
<span class="lineNum">     215 </span><span class="lineCov">   27498450 :       unsigned int size, factor;</span>
<span class="lineNum">     216 </span><span class="lineCov">   27498450 :       if (interesting_mode_p (mode, &amp;size, &amp;factor) &amp;&amp; factor &gt; 1)</span>
<span class="lineNum">     217 </span>            :         {
<span class="lineNum">     218 </span><span class="lineCov">   14525162 :           unsigned int mode_move_cost;</span>
<span class="lineNum">     219 </span>            : 
<span class="lineNum">     220 </span><span class="lineCov">   14525162 :           PUT_MODE (rtxes-&gt;target, mode);</span>
<span class="lineNum">     221 </span><span class="lineCov">   14525162 :           PUT_MODE (rtxes-&gt;source, mode);</span>
<span class="lineNum">     222 </span><span class="lineCov">   14525162 :           mode_move_cost = set_rtx_cost (rtxes-&gt;set, speed_p);</span>
<span class="lineNum">     223 </span>            : 
<span class="lineNum">     224 </span><span class="lineCov">   14525162 :           if (LOG_COSTS)</span>
<span class="lineNum">     225 </span>            :             fprintf (stderr, &quot;%s move: original cost %d, split cost %d * %d\n&quot;,
<span class="lineNum">     226 </span>            :                      GET_MODE_NAME (mode), mode_move_cost,
<span class="lineNum">     227 </span>            :                      word_move_cost, factor);
<span class="lineNum">     228 </span>            : 
<span class="lineNum">     229 </span><span class="lineCov">   14525162 :           if (FORCE_LOWERING || mode_move_cost &gt;= word_move_cost * factor)</span>
<span class="lineNum">     230 </span>            :             {
<span class="lineNum">     231 </span><span class="lineCov">   11228762 :               choices[speed_p].move_modes_to_split[i] = true;</span>
<span class="lineNum">     232 </span><span class="lineCov">   11228762 :               choices[speed_p].something_to_do = true;</span>
<span class="lineNum">     233 </span>            :             }
<span class="lineNum">     234 </span>            :         }
<span class="lineNum">     235 </span>            :     }
<span class="lineNum">     236 </span>            : 
<span class="lineNum">     237 </span>            :   /* For the moves and shifts, the only case that is checked is one
<span class="lineNum">     238 </span>            :      where the mode of the target is an integer mode twice the width
<span class="lineNum">     239 </span>            :      of the word_mode.
<span class="lineNum">     240 </span>            : 
<span class="lineNum">     241 </span>            :      If it is not profitable to split a double word move then do not
<span class="lineNum">     242 </span>            :      even consider the shifts or the zero extension.  */
<span class="lineNum">     243 </span><span class="lineCov">     523780 :   if (choices[speed_p].move_modes_to_split[(int) twice_word_mode])</span>
<span class="lineNum">     244 </span>            :     {
<span class="lineNum">     245 </span><span class="lineCov">     261890 :       int zext_cost;</span>
<span class="lineNum">     246 </span>            : 
<span class="lineNum">     247 </span>            :       /* The only case here to check to see if moving the upper part with a
<span class="lineNum">     248 </span>            :          zero is cheaper than doing the zext itself.  */
<span class="lineNum">     249 </span><span class="lineCov">     523780 :       PUT_MODE (rtxes-&gt;source, word_mode);</span>
<span class="lineNum">     250 </span><span class="lineCov">     523780 :       zext_cost = set_src_cost (rtxes-&gt;zext, twice_word_mode, speed_p);</span>
<span class="lineNum">     251 </span>            : 
<span class="lineNum">     252 </span><span class="lineCov">     261890 :       if (LOG_COSTS)</span>
<span class="lineNum">     253 </span>            :         fprintf (stderr, &quot;%s %s: original cost %d, split cost %d + %d\n&quot;,
<span class="lineNum">     254 </span>            :                  GET_MODE_NAME (twice_word_mode), GET_RTX_NAME (ZERO_EXTEND),
<span class="lineNum">     255 </span>            :                  zext_cost, word_move_cost, word_move_zero_cost);
<span class="lineNum">     256 </span>            : 
<span class="lineNum">     257 </span><span class="lineCov">     261890 :       if (FORCE_LOWERING || zext_cost &gt;= word_move_cost + word_move_zero_cost)</span>
<span class="lineNum">     258 </span><span class="lineNoCov">          0 :         choices[speed_p].splitting_zext = true;</span>
<span class="lineNum">     259 </span>            : 
<span class="lineNum">     260 </span><span class="lineCov">     523780 :       compute_splitting_shift (speed_p, rtxes,</span>
<span class="lineNum">     261 </span><span class="lineCov">     261890 :                                choices[speed_p].splitting_ashift, ASHIFT,</span>
<span class="lineNum">     262 </span>            :                                word_move_zero_cost, word_move_cost);
<span class="lineNum">     263 </span><span class="lineCov">     523780 :       compute_splitting_shift (speed_p, rtxes,</span>
<span class="lineNum">     264 </span><span class="lineCov">     261890 :                                choices[speed_p].splitting_lshiftrt, LSHIFTRT,</span>
<span class="lineNum">     265 </span>            :                                word_move_zero_cost, word_move_cost);
<span class="lineNum">     266 </span><span class="lineCov">     523780 :       compute_splitting_shift (speed_p, rtxes,</span>
<span class="lineNum">     267 </span><span class="lineCov">     261890 :                                choices[speed_p].splitting_ashiftrt, ASHIFTRT,</span>
<span class="lineNum">     268 </span>            :                                word_move_zero_cost, word_move_cost);
<span class="lineNum">     269 </span>            :     }
<span class="lineNum">     270 </span><span class="lineCov">     261890 : }</span>
<span class="lineNum">     271 </span>            : 
<span class="lineNum">     272 </span>            : /* Do one-per-target initialisation.  This involves determining
<span class="lineNum">     273 </span>            :    which operations on the machine are profitable.  If none are found,
<span class="lineNum">     274 </span>            :    then the pass just returns when called.  */
<a name="275"><span class="lineNum">     275 </span>            : </a>
<span class="lineNum">     276 </span>            : void
<span class="lineNum">     277 </span><span class="lineCov">     130945 : init_lower_subreg (void)</span>
<span class="lineNum">     278 </span>            : {
<span class="lineNum">     279 </span><span class="lineCov">     130945 :   struct cost_rtxes rtxes;</span>
<span class="lineNum">     280 </span>            : 
<span class="lineNum">     281 </span><span class="lineCov">     130945 :   memset (this_target_lower_subreg, 0, sizeof (*this_target_lower_subreg));</span>
<span class="lineNum">     282 </span>            : 
<span class="lineNum">     283 </span><span class="lineCov">     261890 :   twice_word_mode = GET_MODE_2XWIDER_MODE (word_mode).require ();</span>
<span class="lineNum">     284 </span>            : 
<span class="lineNum">     285 </span><span class="lineCov">     261890 :   rtxes.target = gen_rtx_REG (word_mode, LAST_VIRTUAL_REGISTER + 1);</span>
<span class="lineNum">     286 </span><span class="lineCov">     261890 :   rtxes.source = gen_rtx_REG (word_mode, LAST_VIRTUAL_REGISTER + 2);</span>
<span class="lineNum">     287 </span><span class="lineCov">     130945 :   rtxes.set = gen_rtx_SET (rtxes.target, rtxes.source);</span>
<span class="lineNum">     288 </span><span class="lineCov">     261890 :   rtxes.zext = gen_rtx_ZERO_EXTEND (twice_word_mode, rtxes.source);</span>
<span class="lineNum">     289 </span><span class="lineCov">     261890 :   rtxes.shift = gen_rtx_ASHIFT (twice_word_mode, rtxes.source, const0_rtx);</span>
<span class="lineNum">     290 </span>            : 
<span class="lineNum">     291 </span><span class="lineCov">     130945 :   if (LOG_COSTS)</span>
<span class="lineNum">     292 </span>            :     fprintf (stderr, &quot;\nSize costs\n==========\n\n&quot;);
<span class="lineNum">     293 </span><span class="lineCov">     130945 :   compute_costs (false, &amp;rtxes);</span>
<span class="lineNum">     294 </span>            : 
<span class="lineNum">     295 </span><span class="lineCov">     130945 :   if (LOG_COSTS)</span>
<span class="lineNum">     296 </span>            :     fprintf (stderr, &quot;\nSpeed costs\n===========\n\n&quot;);
<span class="lineNum">     297 </span><span class="lineCov">     130945 :   compute_costs (true, &amp;rtxes);</span>
<span class="lineNum">     298 </span><span class="lineCov">     130945 : }</span>
<a name="299"><span class="lineNum">     299 </span>            : </a>
<span class="lineNum">     300 </span>            : static bool
<span class="lineNum">     301 </span><span class="lineCov">   48711325 : simple_move_operand (rtx x)</span>
<span class="lineNum">     302 </span>            : {
<span class="lineNum">     303 </span><span class="lineCov">   48711325 :   if (GET_CODE (x) == SUBREG)</span>
<span class="lineNum">     304 </span><span class="lineCov">    2127826 :     x = SUBREG_REG (x);</span>
<span class="lineNum">     305 </span>            : 
<span class="lineNum">     306 </span><span class="lineCov">   48711325 :   if (!OBJECT_P (x))</span>
<span class="lineNum">     307 </span>            :     return false;
<span class="lineNum">     308 </span>            : 
<span class="lineNum">     309 </span><span class="lineCov">   96764300 :   if (GET_CODE (x) == LABEL_REF</span>
<span class="lineNum">     310 </span><span class="lineCov">   48382150 :       || GET_CODE (x) == SYMBOL_REF</span>
<span class="lineNum">     311 </span><span class="lineCov">   46238381 :       || GET_CODE (x) == HIGH</span>
<span class="lineNum">     312 </span><span class="lineCov">   46238381 :       || GET_CODE (x) == CONST)</span>
<span class="lineNum">     313 </span>            :     return false;
<span class="lineNum">     314 </span>            : 
<span class="lineNum">     315 </span><span class="lineCov">   46140359 :   if (MEM_P (x)</span>
<span class="lineNum">     316 </span><span class="lineCov">   46140359 :       &amp;&amp; (MEM_VOLATILE_P (x)</span>
<span class="lineNum">     317 </span><span class="lineCov">   14433547 :           || mode_dependent_address_p (XEXP (x, 0), MEM_ADDR_SPACE (x))))</span>
<span class="lineNum">     318 </span><span class="lineCov">    3220436 :     return false;</span>
<span class="lineNum">     319 </span>            : 
<span class="lineNum">     320 </span>            :   return true;
<span class="lineNum">     321 </span>            : }
<span class="lineNum">     322 </span>            : 
<span class="lineNum">     323 </span>            : /* If INSN is a single set between two objects that we want to split,
<span class="lineNum">     324 </span>            :    return the single set.  SPEED_P says whether we are optimizing
<span class="lineNum">     325 </span>            :    INSN for speed or size.
<span class="lineNum">     326 </span>            : 
<span class="lineNum">     327 </span>            :    INSN should have been passed to recog and extract_insn before this
<span class="lineNum">     328 </span>            :    is called.  */
<a name="329"><span class="lineNum">     329 </span>            : </a>
<span class="lineNum">     330 </span>            : static rtx
<span class="lineNum">     331 </span><span class="lineCov">   59349431 : simple_move (rtx_insn *insn, bool speed_p)</span>
<span class="lineNum">     332 </span>            : {
<span class="lineNum">     333 </span><span class="lineCov">   59349431 :   rtx x;</span>
<span class="lineNum">     334 </span><span class="lineCov">   59349431 :   rtx set;</span>
<span class="lineNum">     335 </span><span class="lineCov">   59349431 :   machine_mode mode;</span>
<span class="lineNum">     336 </span>            : 
<span class="lineNum">     337 </span><span class="lineCov">   59349431 :   if (recog_data.n_operands != 2)</span>
<span class="lineNum">     338 </span>            :     return NULL_RTX;
<span class="lineNum">     339 </span>            : 
<span class="lineNum">     340 </span><span class="lineCov">   33113581 :   set = single_set (insn);</span>
<span class="lineNum">     341 </span><span class="lineCov">   33113581 :   if (!set)</span>
<span class="lineNum">     342 </span>            :     return NULL_RTX;
<span class="lineNum">     343 </span>            : 
<span class="lineNum">     344 </span><span class="lineCov">   31371848 :   x = SET_DEST (set);</span>
<span class="lineNum">     345 </span><span class="lineCov">   31371848 :   if (x != recog_data.operand[0] &amp;&amp; x != recog_data.operand[1])</span>
<span class="lineNum">     346 </span>            :     return NULL_RTX;
<span class="lineNum">     347 </span><span class="lineCov">   26103214 :   if (!simple_move_operand (x))</span>
<span class="lineNum">     348 </span>            :     return NULL_RTX;
<span class="lineNum">     349 </span>            : 
<span class="lineNum">     350 </span><span class="lineCov">   23033816 :   x = SET_SRC (set);</span>
<span class="lineNum">     351 </span><span class="lineCov">   23033816 :   if (x != recog_data.operand[0] &amp;&amp; x != recog_data.operand[1])</span>
<span class="lineNum">     352 </span>            :     return NULL_RTX;
<span class="lineNum">     353 </span>            :   /* For the src we can handle ASM_OPERANDS, and it is beneficial for
<span class="lineNum">     354 </span>            :      things like x86 rdtsc which returns a DImode value.  */
<span class="lineNum">     355 </span><span class="lineCov">   22608111 :   if (GET_CODE (x) != ASM_OPERANDS</span>
<span class="lineNum">     356 </span><span class="lineCov">   22608111 :       &amp;&amp; !simple_move_operand (x))</span>
<span class="lineNum">     357 </span>            :     return NULL_RTX;
<span class="lineNum">     358 </span>            : 
<span class="lineNum">     359 </span>            :   /* We try to decompose in integer modes, to avoid generating
<span class="lineNum">     360 </span>            :      inefficient code copying between integer and floating point
<span class="lineNum">     361 </span>            :      registers.  That means that we can't decompose if this is a
<span class="lineNum">     362 </span>            :      non-integer mode for which there is no integer mode of the same
<span class="lineNum">     363 </span>            :      size.  */
<span class="lineNum">     364 </span><span class="lineCov">   19886107 :   mode = GET_MODE (SET_DEST (set));</span>
<span class="lineNum">     365 </span><span class="lineCov">   19886107 :   if (!SCALAR_INT_MODE_P (mode)</span>
<span class="lineNum">     366 </span><span class="lineCov">   22877071 :       &amp;&amp; !int_mode_for_size (GET_MODE_BITSIZE (mode), 0).exists ())</span>
<span class="lineNum">     367 </span>            :     return NULL_RTX;
<span class="lineNum">     368 </span>            : 
<span class="lineNum">     369 </span>            :   /* Reject PARTIAL_INT modes.  They are used for processor specific
<span class="lineNum">     370 </span>            :      purposes and it's probably best not to tamper with them.  */
<span class="lineNum">     371 </span><span class="lineCov">   19885209 :   if (GET_MODE_CLASS (mode) == MODE_PARTIAL_INT)</span>
<span class="lineNum">     372 </span>            :     return NULL_RTX;
<span class="lineNum">     373 </span>            : 
<span class="lineNum">     374 </span><span class="lineCov">   19885209 :   if (!choices[speed_p].move_modes_to_split[(int) mode])</span>
<span class="lineNum">     375 </span><span class="lineCov">   17725830 :     return NULL_RTX;</span>
<span class="lineNum">     376 </span>            : 
<span class="lineNum">     377 </span>            :   return set;
<span class="lineNum">     378 </span>            : }
<span class="lineNum">     379 </span>            : 
<span class="lineNum">     380 </span>            : /* If SET is a copy from one multi-word pseudo-register to another,
<span class="lineNum">     381 </span>            :    record that in reg_copy_graph.  Return whether it is such a
<span class="lineNum">     382 </span>            :    copy.  */
<a name="383"><span class="lineNum">     383 </span>            : </a>
<span class="lineNum">     384 </span>            : static bool
<span class="lineNum">     385 </span><span class="lineCov">    1297863 : find_pseudo_copy (rtx set)</span>
<span class="lineNum">     386 </span>            : {
<span class="lineNum">     387 </span><span class="lineCov">    1297863 :   rtx dest = SET_DEST (set);</span>
<span class="lineNum">     388 </span><span class="lineCov">    1297863 :   rtx src = SET_SRC (set);</span>
<span class="lineNum">     389 </span><span class="lineCov">    1297863 :   unsigned int rd, rs;</span>
<span class="lineNum">     390 </span><span class="lineCov">    1297863 :   bitmap b;</span>
<span class="lineNum">     391 </span>            : 
<span class="lineNum">     392 </span><span class="lineCov">    1297863 :   if (!REG_P (dest) || !REG_P (src))</span>
<span class="lineNum">     393 </span>            :     return false;
<span class="lineNum">     394 </span>            : 
<span class="lineNum">     395 </span><span class="lineCov">     475002 :   rd = REGNO (dest);</span>
<span class="lineNum">     396 </span><span class="lineCov">     475002 :   rs = REGNO (src);</span>
<span class="lineNum">     397 </span><span class="lineCov">     475002 :   if (HARD_REGISTER_NUM_P (rd) || HARD_REGISTER_NUM_P (rs))</span>
<span class="lineNum">     398 </span>            :     return false;
<span class="lineNum">     399 </span>            : 
<span class="lineNum">     400 </span><span class="lineCov">     283527 :   b = reg_copy_graph[rs];</span>
<span class="lineNum">     401 </span><span class="lineCov">     283527 :   if (b == NULL)</span>
<span class="lineNum">     402 </span>            :     {
<span class="lineNum">     403 </span><span class="lineCov">     169511 :       b = BITMAP_ALLOC (NULL);</span>
<span class="lineNum">     404 </span><span class="lineCov">     169511 :       reg_copy_graph[rs] = b;</span>
<span class="lineNum">     405 </span>            :     }
<span class="lineNum">     406 </span>            : 
<span class="lineNum">     407 </span><span class="lineCov">     283527 :   bitmap_set_bit (b, rd);</span>
<span class="lineNum">     408 </span>            : 
<span class="lineNum">     409 </span><span class="lineCov">     283527 :   return true;</span>
<span class="lineNum">     410 </span>            : }
<span class="lineNum">     411 </span>            : 
<span class="lineNum">     412 </span>            : /* Look through the registers in DECOMPOSABLE_CONTEXT.  For each case
<span class="lineNum">     413 </span>            :    where they are copied to another register, add the register to
<span class="lineNum">     414 </span>            :    which they are copied to DECOMPOSABLE_CONTEXT.  Use
<span class="lineNum">     415 </span>            :    NON_DECOMPOSABLE_CONTEXT to limit this--we don't bother to track
<span class="lineNum">     416 </span>            :    copies of registers which are in NON_DECOMPOSABLE_CONTEXT.  */
<a name="417"><span class="lineNum">     417 </span>            : </a>
<span class="lineNum">     418 </span>            : static void
<span class="lineNum">     419 </span><span class="lineCov">      81844 : propagate_pseudo_copies (void)</span>
<span class="lineNum">     420 </span>            : {
<span class="lineNum">     421 </span><span class="lineCov">     245532 :   auto_bitmap queue, propagate;</span>
<span class="lineNum">     422 </span>            : 
<span class="lineNum">     423 </span><span class="lineCov">     163688 :   bitmap_copy (queue, decomposable_context);</span>
<span class="lineNum">     424 </span><span class="lineCov">     101335 :   do</span>
<span class="lineNum">     425 </span>            :     {
<span class="lineNum">     426 </span><span class="lineCov">     101335 :       bitmap_iterator iter;</span>
<span class="lineNum">     427 </span><span class="lineCov">     101335 :       unsigned int i;</span>
<span class="lineNum">     428 </span>            : 
<span class="lineNum">     429 </span><span class="lineCov">     202670 :       bitmap_clear (propagate);</span>
<span class="lineNum">     430 </span>            : 
<span class="lineNum">     431 </span><span class="lineCov">     692273 :       EXECUTE_IF_SET_IN_BITMAP (queue, 0, i, iter)</span>
<span class="lineNum">     432 </span>            :         {
<span class="lineNum">     433 </span><span class="lineCov">     489603 :           bitmap b = reg_copy_graph[i];</span>
<span class="lineNum">     434 </span><span class="lineCov">     489603 :           if (b)</span>
<span class="lineNum">     435 </span><span class="lineCov">     215502 :             bitmap_ior_and_compl_into (propagate, b, non_decomposable_context);</span>
<span class="lineNum">     436 </span>            :         }
<span class="lineNum">     437 </span>            : 
<span class="lineNum">     438 </span><span class="lineCov">     304005 :       bitmap_and_compl (queue, propagate, decomposable_context);</span>
<span class="lineNum">     439 </span><span class="lineCov">     202670 :       bitmap_ior_into (decomposable_context, propagate);</span>
<span class="lineNum">     440 </span>            :     }
<span class="lineNum">     441 </span><span class="lineCov">     304005 :   while (!bitmap_empty_p (queue));</span>
<span class="lineNum">     442 </span><span class="lineCov">      81844 : }</span>
<span class="lineNum">     443 </span>            : 
<span class="lineNum">     444 </span>            : /* A pointer to one of these values is passed to
<span class="lineNum">     445 </span>            :    find_decomposable_subregs.  */
<span class="lineNum">     446 </span>            : 
<span class="lineNum">     447 </span>            : enum classify_move_insn
<span class="lineNum">     448 </span>            : {
<span class="lineNum">     449 </span>            :   /* Not a simple move from one location to another.  */
<span class="lineNum">     450 </span>            :   NOT_SIMPLE_MOVE,
<span class="lineNum">     451 </span>            :   /* A simple move we want to decompose.  */
<span class="lineNum">     452 </span>            :   DECOMPOSABLE_SIMPLE_MOVE,
<span class="lineNum">     453 </span>            :   /* Any other simple move.  */
<span class="lineNum">     454 </span>            :   SIMPLE_MOVE
<span class="lineNum">     455 </span>            : };
<span class="lineNum">     456 </span>            : 
<span class="lineNum">     457 </span>            : /* If we find a SUBREG in *LOC which we could use to decompose a
<span class="lineNum">     458 </span>            :    pseudo-register, set a bit in DECOMPOSABLE_CONTEXT.  If we find an
<span class="lineNum">     459 </span>            :    unadorned register which is not a simple pseudo-register copy,
<span class="lineNum">     460 </span>            :    DATA will point at the type of move, and we set a bit in
<span class="lineNum">     461 </span>            :    DECOMPOSABLE_CONTEXT or NON_DECOMPOSABLE_CONTEXT as appropriate.  */
<a name="462"><span class="lineNum">     462 </span>            : </a>
<span class="lineNum">     463 </span>            : static void
<span class="lineNum">     464 </span><span class="lineCov">   71755999 : find_decomposable_subregs (rtx *loc, enum classify_move_insn *pcmi)</span>
<span class="lineNum">     465 </span>            : {
<span class="lineNum">     466 </span><span class="lineCov">  143511998 :   subrtx_var_iterator::array_type array;</span>
<span class="lineNum">     467 </span><span class="lineCov">  163565596 :   FOR_EACH_SUBRTX_VAR (iter, array, *loc, NONCONST)</span>
<span class="lineNum">     468 </span>            :     {
<span class="lineNum">     469 </span><span class="lineCov">   91809597 :       rtx x = *iter;</span>
<span class="lineNum">     470 </span><span class="lineCov">   91809597 :       if (GET_CODE (x) == SUBREG)</span>
<span class="lineNum">     471 </span>            :         {
<span class="lineNum">     472 </span><span class="lineCov">    1737476 :           rtx inner = SUBREG_REG (x);</span>
<span class="lineNum">     473 </span><span class="lineCov">    1737476 :           unsigned int regno, outer_size, inner_size, outer_words, inner_words;</span>
<span class="lineNum">     474 </span>            : 
<span class="lineNum">     475 </span><span class="lineCov">    1737476 :           if (!REG_P (inner))</span>
<span class="lineNum">     476 </span><span class="lineCov">    1402138 :             continue;</span>
<span class="lineNum">     477 </span>            : 
<span class="lineNum">     478 </span><span class="lineCov">    1737465 :           regno = REGNO (inner);</span>
<span class="lineNum">     479 </span><span class="lineCov">    1737465 :           if (HARD_REGISTER_NUM_P (regno))</span>
<span class="lineNum">     480 </span>            :             {
<span class="lineNum">     481 </span><span class="lineCov">          2 :               iter.skip_subrtxes ();</span>
<span class="lineNum">     482 </span><span class="lineCov">          2 :               continue;</span>
<span class="lineNum">     483 </span>            :             }
<span class="lineNum">     484 </span>            : 
<span class="lineNum">     485 </span><span class="lineCov">    1737463 :           if (!interesting_mode_p (GET_MODE (x), &amp;outer_size, &amp;outer_words)</span>
<span class="lineNum">     486 </span><span class="lineCov">    1737463 :               || !interesting_mode_p (GET_MODE (inner), &amp;inner_size,</span>
<span class="lineNum">     487 </span>            :                                       &amp;inner_words))
<span class="lineNum">     488 </span><span class="lineNoCov">          0 :             continue;</span>
<span class="lineNum">     489 </span>            : 
<span class="lineNum">     490 </span>            :           /* We only try to decompose single word subregs of multi-word
<span class="lineNum">     491 </span>            :              registers.  When we find one, we return -1 to avoid iterating
<span class="lineNum">     492 </span>            :              over the inner register.
<span class="lineNum">     493 </span>            : 
<span class="lineNum">     494 </span>            :              ??? This doesn't allow, e.g., DImode subregs of TImode values
<span class="lineNum">     495 </span>            :              on 32-bit targets.  We would need to record the way the
<span class="lineNum">     496 </span>            :              pseudo-register was used, and only decompose if all the uses
<span class="lineNum">     497 </span>            :              were the same number and size of pieces.  Hopefully this
<span class="lineNum">     498 </span>            :              doesn't happen much.  */
<span class="lineNum">     499 </span>            : 
<span class="lineNum">     500 </span><span class="lineCov">    1737463 :           if (outer_words == 1</span>
<span class="lineNum">     501 </span><span class="lineCov">    1547768 :               &amp;&amp; inner_words &gt; 1</span>
<span class="lineNum">     502 </span>            :               /* Don't allow to decompose floating point subregs of
<span class="lineNum">     503 </span>            :                  multi-word pseudos if the floating point mode does
<span class="lineNum">     504 </span>            :                  not have word size, because otherwise we'd generate
<span class="lineNum">     505 </span>            :                  a subreg with that floating mode from a different
<span class="lineNum">     506 </span>            :                  sized integral pseudo which is not allowed by
<span class="lineNum">     507 </span>            :                  validate_subreg.  */
<span class="lineNum">     508 </span><span class="lineCov">    1378813 :               &amp;&amp; (!FLOAT_MODE_P (GET_MODE (x))</span>
<span class="lineNum">     509 </span><span class="lineCov">       8431 :                   || outer_size == UNITS_PER_WORD))</span>
<span class="lineNum">     510 </span>            :             {
<span class="lineNum">     511 </span><span class="lineCov">    1378645 :               bitmap_set_bit (decomposable_context, regno);</span>
<span class="lineNum">     512 </span><span class="lineCov">    1378645 :               iter.skip_subrtxes ();</span>
<span class="lineNum">     513 </span><span class="lineCov">    1378645 :               continue;</span>
<span class="lineNum">     514 </span>            :             }
<span class="lineNum">     515 </span>            : 
<span class="lineNum">     516 </span>            :           /* If this is a cast from one mode to another, where the modes
<span class="lineNum">     517 </span>            :              have the same size, and they are not tieable, then mark this
<span class="lineNum">     518 </span>            :              register as non-decomposable.  If we decompose it we are
<span class="lineNum">     519 </span>            :              likely to mess up whatever the backend is trying to do.  */
<span class="lineNum">     520 </span><span class="lineCov">     358818 :           if (outer_words &gt; 1</span>
<span class="lineNum">     521 </span><span class="lineCov">     189695 :               &amp;&amp; outer_size == inner_size</span>
<span class="lineNum">     522 </span><span class="lineCov">     498167 :               &amp;&amp; !targetm.modes_tieable_p (GET_MODE (x), GET_MODE (inner)))</span>
<span class="lineNum">     523 </span>            :             {
<span class="lineNum">     524 </span><span class="lineCov">      23480 :               bitmap_set_bit (non_decomposable_context, regno);</span>
<span class="lineNum">     525 </span><span class="lineCov">      23480 :               bitmap_set_bit (subreg_context, regno);</span>
<span class="lineNum">     526 </span><span class="lineCov">      23480 :               iter.skip_subrtxes ();</span>
<span class="lineNum">     527 </span><span class="lineCov">      23480 :               continue;</span>
<span class="lineNum">     528 </span>            :             }
<span class="lineNum">     529 </span>            :         }
<span class="lineNum">     530 </span><span class="lineCov">   90072121 :       else if (REG_P (x))</span>
<span class="lineNum">     531 </span>            :         {
<span class="lineNum">     532 </span><span class="lineCov">   43262804 :           unsigned int regno, size, words;</span>
<span class="lineNum">     533 </span>            : 
<span class="lineNum">     534 </span>            :           /* We will see an outer SUBREG before we see the inner REG, so
<span class="lineNum">     535 </span>            :              when we see a plain REG here it means a direct reference to
<span class="lineNum">     536 </span>            :              the register.
<span class="lineNum">     537 </span>            : 
<span class="lineNum">     538 </span>            :              If this is not a simple copy from one location to another,
<span class="lineNum">     539 </span>            :              then we can not decompose this register.  If this is a simple
<span class="lineNum">     540 </span>            :              copy we want to decompose, and the mode is right,
<span class="lineNum">     541 </span>            :              then we mark the register as decomposable.
<span class="lineNum">     542 </span>            :              Otherwise we don't say anything about this register --
<span class="lineNum">     543 </span>            :              it could be decomposed, but whether that would be
<span class="lineNum">     544 </span>            :              profitable depends upon how it is used elsewhere.
<span class="lineNum">     545 </span>            : 
<span class="lineNum">     546 </span>            :              We only set bits in the bitmap for multi-word
<span class="lineNum">     547 </span>            :              pseudo-registers, since those are the only ones we care about
<span class="lineNum">     548 </span>            :              and it keeps the size of the bitmaps down.  */
<span class="lineNum">     549 </span>            : 
<span class="lineNum">     550 </span><span class="lineCov">   43262804 :           regno = REGNO (x);</span>
<span class="lineNum">     551 </span><span class="lineCov">   43262804 :           if (!HARD_REGISTER_NUM_P (regno)</span>
<span class="lineNum">     552 </span><span class="lineCov">   25023994 :               &amp;&amp; interesting_mode_p (GET_MODE (x), &amp;size, &amp;words)</span>
<span class="lineNum">     553 </span><span class="lineCov">   68286798 :               &amp;&amp; words &gt; 1)</span>
<span class="lineNum">     554 </span>            :             {
<span class="lineNum">     555 </span><span class="lineCov">    3237411 :               switch (*pcmi)</span>
<span class="lineNum">     556 </span>            :                 {
<span class="lineNum">     557 </span><span class="lineCov">    1704348 :                 case NOT_SIMPLE_MOVE:</span>
<span class="lineNum">     558 </span><span class="lineCov">    1704348 :                   bitmap_set_bit (non_decomposable_context, regno);</span>
<span class="lineNum">     559 </span><span class="lineCov">    1704348 :                   break;</span>
<span class="lineNum">     560 </span><span class="lineCov">       4606 :                 case DECOMPOSABLE_SIMPLE_MOVE:</span>
<span class="lineNum">     561 </span><span class="lineCov">       9212 :                   if (targetm.modes_tieable_p (GET_MODE (x), word_mode))</span>
<span class="lineNum">     562 </span><span class="lineNoCov">          0 :                     bitmap_set_bit (decomposable_context, regno);</span>
<span class="lineNum">     563 </span>            :                   break;
<span class="lineNum">     564 </span>            :                 case SIMPLE_MOVE:
<span class="lineNum">     565 </span>            :                   break;
<span class="lineNum">     566 </span><span class="lineNoCov">          0 :                 default:</span>
<span class="lineNum">     567 </span><span class="lineNoCov">          0 :                   gcc_unreachable ();</span>
<span class="lineNum">     568 </span>            :                 }
<span class="lineNum">     569 </span>            :             }
<span class="lineNum">     570 </span>            :         }
<span class="lineNum">     571 </span><span class="lineCov">   46809317 :       else if (MEM_P (x))</span>
<span class="lineNum">     572 </span>            :         {
<span class="lineNum">     573 </span><span class="lineCov">   10409558 :           enum classify_move_insn cmi_mem = NOT_SIMPLE_MOVE;</span>
<span class="lineNum">     574 </span>            : 
<span class="lineNum">     575 </span>            :           /* Any registers used in a MEM do not participate in a
<span class="lineNum">     576 </span>            :              SIMPLE_MOVE or DECOMPOSABLE_SIMPLE_MOVE.  Do our own recursion
<span class="lineNum">     577 </span>            :              here, and return -1 to block the parent's recursion.  */
<span class="lineNum">     578 </span><span class="lineCov">   10409558 :           find_decomposable_subregs (&amp;XEXP (x, 0), &amp;cmi_mem);</span>
<span class="lineNum">     579 </span><span class="lineCov">   10409558 :           iter.skip_subrtxes ();</span>
<span class="lineNum">     580 </span>            :         }
<span class="lineNum">     581 </span>            :     }
<span class="lineNum">     582 </span><span class="lineCov">   71755999 : }</span>
<span class="lineNum">     583 </span>            : 
<span class="lineNum">     584 </span>            : /* Decompose REGNO into word-sized components.  We smash the REG node
<span class="lineNum">     585 </span>            :    in place.  This ensures that (1) something goes wrong quickly if we
<span class="lineNum">     586 </span>            :    fail to make some replacement, and (2) the debug information inside
<span class="lineNum">     587 </span>            :    the symbol table is automatically kept up to date.  */
<a name="588"><span class="lineNum">     588 </span>            : </a>
<span class="lineNum">     589 </span>            : static void
<span class="lineNum">     590 </span><span class="lineCov">     489603 : decompose_register (unsigned int regno)</span>
<span class="lineNum">     591 </span>            : {
<span class="lineNum">     592 </span><span class="lineCov">     489603 :   rtx reg;</span>
<span class="lineNum">     593 </span><span class="lineCov">     489603 :   unsigned int size, words, i;</span>
<span class="lineNum">     594 </span><span class="lineCov">     489603 :   rtvec v;</span>
<span class="lineNum">     595 </span>            : 
<span class="lineNum">     596 </span><span class="lineCov">     489603 :   reg = regno_reg_rtx[regno];</span>
<span class="lineNum">     597 </span>            : 
<span class="lineNum">     598 </span><span class="lineCov">     489603 :   regno_reg_rtx[regno] = NULL_RTX;</span>
<span class="lineNum">     599 </span>            : 
<span class="lineNum">     600 </span><span class="lineCov">     489603 :   if (!interesting_mode_p (GET_MODE (reg), &amp;size, &amp;words))</span>
<span class="lineNum">     601 </span><span class="lineNoCov">          0 :     gcc_unreachable ();</span>
<span class="lineNum">     602 </span>            : 
<span class="lineNum">     603 </span><span class="lineCov">     489603 :   v = rtvec_alloc (words);</span>
<span class="lineNum">     604 </span><span class="lineCov">    1472413 :   for (i = 0; i &lt; words; ++i)</span>
<span class="lineNum">     605 </span><span class="lineCov">    1148938 :     RTVEC_ELT (v, i) = gen_reg_rtx_offset (reg, word_mode, i * UNITS_PER_WORD);</span>
<span class="lineNum">     606 </span>            : 
<span class="lineNum">     607 </span><span class="lineCov">     489603 :   PUT_CODE (reg, CONCATN);</span>
<span class="lineNum">     608 </span><span class="lineCov">     489603 :   XVEC (reg, 0) = v;</span>
<span class="lineNum">     609 </span>            : 
<span class="lineNum">     610 </span><span class="lineCov">     489603 :   if (dump_file)</span>
<span class="lineNum">     611 </span>            :     {
<span class="lineNum">     612 </span><span class="lineNoCov">          0 :       fprintf (dump_file, &quot;; Splitting reg %u -&gt;&quot;, regno);</span>
<span class="lineNum">     613 </span><span class="lineNoCov">          0 :       for (i = 0; i &lt; words; ++i)</span>
<span class="lineNum">     614 </span><span class="lineNoCov">          0 :         fprintf (dump_file, &quot; %u&quot;, REGNO (XVECEXP (reg, 0, i)));</span>
<span class="lineNum">     615 </span><span class="lineNoCov">          0 :       fputc ('\n', dump_file);</span>
<span class="lineNum">     616 </span>            :     }
<span class="lineNum">     617 </span><span class="lineCov">     489603 : }</span>
<span class="lineNum">     618 </span>            : 
<span class="lineNum">     619 </span>            : /* Get a SUBREG of a CONCATN.  */
<a name="620"><span class="lineNum">     620 </span>            : </a>
<span class="lineNum">     621 </span>            : static rtx
<span class="lineNum">     622 </span><span class="lineCov">    2171900 : simplify_subreg_concatn (machine_mode outermode, rtx op, poly_uint64 orig_byte)</span>
<span class="lineNum">     623 </span>            : {
<span class="lineNum">     624 </span><span class="lineCov">    2171900 :   unsigned int outer_size, outer_words, inner_size, inner_words;</span>
<span class="lineNum">     625 </span><span class="lineCov">    2171900 :   machine_mode innermode, partmode;</span>
<span class="lineNum">     626 </span><span class="lineCov">    2171900 :   rtx part;</span>
<span class="lineNum">     627 </span><span class="lineCov">    2171900 :   unsigned int final_offset;</span>
<span class="lineNum">     628 </span><span class="lineCov">    2171900 :   unsigned int byte;</span>
<span class="lineNum">     629 </span>            : 
<span class="lineNum">     630 </span><span class="lineCov">    2171900 :   innermode = GET_MODE (op);</span>
<span class="lineNum">     631 </span><span class="lineCov">    2171900 :   if (!interesting_mode_p (outermode, &amp;outer_size, &amp;outer_words)</span>
<span class="lineNum">     632 </span><span class="lineCov">    2171900 :       || !interesting_mode_p (innermode, &amp;inner_size, &amp;inner_words))</span>
<span class="lineNum">     633 </span><span class="lineNoCov">          0 :     gcc_unreachable ();</span>
<span class="lineNum">     634 </span>            : 
<span class="lineNum">     635 </span>            :   /* Must be constant if interesting_mode_p passes.  */
<span class="lineNum">     636 </span><span class="lineCov">    2171900 :   byte = orig_byte.to_constant ();</span>
<span class="lineNum">     637 </span><span class="lineCov">    2171900 :   gcc_assert (GET_CODE (op) == CONCATN);</span>
<span class="lineNum">     638 </span><span class="lineCov">    2171900 :   gcc_assert (byte % outer_size == 0);</span>
<span class="lineNum">     639 </span>            : 
<span class="lineNum">     640 </span><span class="lineCov">    2171900 :   gcc_assert (byte &lt; inner_size);</span>
<span class="lineNum">     641 </span><span class="lineCov">    2171900 :   if (outer_size &gt; inner_size)</span>
<span class="lineNum">     642 </span>            :     return NULL_RTX;
<span class="lineNum">     643 </span>            : 
<span class="lineNum">     644 </span><span class="lineCov">    2171900 :   inner_size /= XVECLEN (op, 0);</span>
<span class="lineNum">     645 </span><span class="lineCov">    2171900 :   part = XVECEXP (op, 0, byte / inner_size);</span>
<span class="lineNum">     646 </span><span class="lineCov">    2171900 :   partmode = GET_MODE (part);</span>
<span class="lineNum">     647 </span>            : 
<span class="lineNum">     648 </span><span class="lineCov">    2171900 :   final_offset = byte % inner_size;</span>
<span class="lineNum">     649 </span><span class="lineCov">    2171900 :   if (final_offset + outer_size &gt; inner_size)</span>
<span class="lineNum">     650 </span>            :     return NULL_RTX;
<span class="lineNum">     651 </span>            : 
<span class="lineNum">     652 </span>            :   /* VECTOR_CSTs in debug expressions are expanded into CONCATN instead of
<span class="lineNum">     653 </span>            :      regular CONST_VECTORs.  They have vector or integer modes, depending
<span class="lineNum">     654 </span>            :      on the capabilities of the target.  Cope with them.  */
<span class="lineNum">     655 </span><span class="lineCov">    2171900 :   if (partmode == VOIDmode &amp;&amp; VECTOR_MODE_P (innermode))</span>
<span class="lineNum">     656 </span><span class="lineNoCov">          0 :     partmode = GET_MODE_INNER (innermode);</span>
<span class="lineNum">     657 </span><span class="lineCov">    2171900 :   else if (partmode == VOIDmode)</span>
<span class="lineNum">     658 </span><span class="lineNoCov">          0 :     partmode = mode_for_size (inner_size * BITS_PER_UNIT,</span>
<span class="lineNum">     659 </span><span class="lineNoCov">          0 :                               GET_MODE_CLASS (innermode), 0).require ();</span>
<span class="lineNum">     660 </span>            : 
<span class="lineNum">     661 </span><span class="lineCov">    4343800 :   return simplify_gen_subreg (outermode, part, partmode, final_offset);</span>
<span class="lineNum">     662 </span>            : }
<span class="lineNum">     663 </span>            : 
<span class="lineNum">     664 </span>            : /* Wrapper around simplify_gen_subreg which handles CONCATN.  */
<a name="665"><span class="lineNum">     665 </span>            : </a>
<span class="lineNum">     666 </span>            : static rtx
<span class="lineNum">     667 </span><span class="lineCov">    1850248 : simplify_gen_subreg_concatn (machine_mode outermode, rtx op,</span>
<span class="lineNum">     668 </span>            :                              machine_mode innermode, unsigned int byte)
<span class="lineNum">     669 </span>            : {
<span class="lineNum">     670 </span><span class="lineCov">    1850250 :   rtx ret;</span>
<span class="lineNum">     671 </span>            : 
<span class="lineNum">     672 </span>            :   /* We have to handle generating a SUBREG of a SUBREG of a CONCATN.
<span class="lineNum">     673 </span>            :      If OP is a SUBREG of a CONCATN, then it must be a simple mode
<span class="lineNum">     674 </span>            :      change with the same size and offset 0, or it must extract a
<span class="lineNum">     675 </span>            :      part.  We shouldn't see anything else here.  */
<span class="lineNum">     676 </span><span class="lineCov">    1850250 :   if (GET_CODE (op) == SUBREG &amp;&amp; GET_CODE (SUBREG_REG (op)) == CONCATN)</span>
<span class="lineNum">     677 </span>            :     {
<span class="lineNum">     678 </span><span class="lineCov">          2 :       rtx op2;</span>
<span class="lineNum">     679 </span>            : 
<span class="lineNum">     680 </span><span class="lineCov">          4 :       if (known_eq (GET_MODE_SIZE (GET_MODE (op)),</span>
<span class="lineNum">     681 </span>            :                     GET_MODE_SIZE (GET_MODE (SUBREG_REG (op))))
<span class="lineNum">     682 </span><span class="lineCov">          2 :           &amp;&amp; known_eq (SUBREG_BYTE (op), 0))</span>
<span class="lineNum">     683 </span>            :         return simplify_gen_subreg_concatn (outermode, SUBREG_REG (op),
<span class="lineNum">     684 </span>            :                                             GET_MODE (SUBREG_REG (op)), byte);
<span class="lineNum">     685 </span>            : 
<span class="lineNum">     686 </span><span class="lineNoCov">          0 :       op2 = simplify_subreg_concatn (GET_MODE (op), SUBREG_REG (op),</span>
<span class="lineNum">     687 </span><span class="lineNoCov">          0 :                                      SUBREG_BYTE (op));</span>
<span class="lineNum">     688 </span><span class="lineNoCov">          0 :       if (op2 == NULL_RTX)</span>
<span class="lineNum">     689 </span>            :         {
<span class="lineNum">     690 </span>            :           /* We don't handle paradoxical subregs here.  */
<span class="lineNum">     691 </span><span class="lineNoCov">          0 :           gcc_assert (!paradoxical_subreg_p (outermode, GET_MODE (op)));</span>
<span class="lineNum">     692 </span><span class="lineNoCov">          0 :           gcc_assert (!paradoxical_subreg_p (op));</span>
<span class="lineNum">     693 </span><span class="lineNoCov">          0 :           op2 = simplify_subreg_concatn (outermode, SUBREG_REG (op),</span>
<span class="lineNum">     694 </span><span class="lineNoCov">          0 :                                          byte + SUBREG_BYTE (op));</span>
<span class="lineNum">     695 </span><span class="lineNoCov">          0 :           gcc_assert (op2 != NULL_RTX);</span>
<span class="lineNum">     696 </span>            :           return op2;
<span class="lineNum">     697 </span>            :         }
<span class="lineNum">     698 </span>            : 
<span class="lineNum">     699 </span><span class="lineNoCov">          0 :       op = op2;</span>
<span class="lineNum">     700 </span><span class="lineNoCov">          0 :       gcc_assert (op != NULL_RTX);</span>
<span class="lineNum">     701 </span><span class="lineNoCov">          0 :       gcc_assert (innermode == GET_MODE (op));</span>
<span class="lineNum">     702 </span>            :     }
<span class="lineNum">     703 </span>            : 
<span class="lineNum">     704 </span><span class="lineCov">    1850248 :   if (GET_CODE (op) == CONCATN)</span>
<span class="lineNum">     705 </span><span class="lineCov">    2679080 :     return simplify_subreg_concatn (outermode, op, byte);</span>
<span class="lineNum">     706 </span>            : 
<span class="lineNum">     707 </span><span class="lineCov">    1021416 :   ret = simplify_gen_subreg (outermode, op, innermode, byte);</span>
<span class="lineNum">     708 </span>            : 
<span class="lineNum">     709 </span>            :   /* If we see an insn like (set (reg:DI) (subreg:DI (reg:SI) 0)) then
<span class="lineNum">     710 </span>            :      resolve_simple_move will ask for the high part of the paradoxical
<span class="lineNum">     711 </span>            :      subreg, which does not have a value.  Just return a zero.  */
<span class="lineNum">     712 </span><span class="lineCov">     510708 :   if (ret == NULL_RTX</span>
<span class="lineNum">     713 </span><span class="lineCov">     510708 :       &amp;&amp; paradoxical_subreg_p (op))</span>
<span class="lineNum">     714 </span><span class="lineCov">      23264 :     return CONST0_RTX (outermode);</span>
<span class="lineNum">     715 </span>            : 
<span class="lineNum">     716 </span><span class="lineCov">     487444 :   gcc_assert (ret != NULL_RTX);</span>
<span class="lineNum">     717 </span>            :   return ret;
<span class="lineNum">     718 </span>            : }
<span class="lineNum">     719 </span>            : 
<span class="lineNum">     720 </span>            : /* Return whether we should resolve X into the registers into which it
<span class="lineNum">     721 </span>            :    was decomposed.  */
<a name="722"><span class="lineNum">     722 </span>            : </a>
<span class="lineNum">     723 </span>            : static bool
<span class="lineNum">     724 </span><span class="lineNoCov">          0 : resolve_reg_p (rtx x)</span>
<span class="lineNum">     725 </span>            : {
<span class="lineNum">     726 </span><span class="lineCov">   66595850 :   return GET_CODE (x) == CONCATN;</span>
<span class="lineNum">     727 </span>            : }
<span class="lineNum">     728 </span>            : 
<span class="lineNum">     729 </span>            : /* Return whether X is a SUBREG of a register which we need to
<span class="lineNum">     730 </span>            :    resolve.  */
<a name="731"><span class="lineNum">     731 </span>            : </a>
<span class="lineNum">     732 </span>            : static bool
<span class="lineNum">     733 </span><span class="lineNoCov">          0 : resolve_subreg_p (rtx x)</span>
<span class="lineNum">     734 </span>            : {
<span class="lineNum">     735 </span><span class="lineNoCov">          0 :   if (GET_CODE (x) != SUBREG)</span>
<span class="lineNum">     736 </span>            :     return false;
<span class="lineNum">     737 </span><span class="lineNoCov">          0 :   return resolve_reg_p (SUBREG_REG (x));</span>
<span class="lineNum">     738 </span>            : }
<span class="lineNum">     739 </span>            : 
<span class="lineNum">     740 </span>            : /* Look for SUBREGs in *LOC which need to be decomposed.  */
<a name="741"><span class="lineNum">     741 </span>            : </a>
<span class="lineNum">     742 </span>            : static bool
<span class="lineNum">     743 </span><span class="lineCov">   31604153 : resolve_subreg_use (rtx *loc, rtx insn)</span>
<span class="lineNum">     744 </span>            : {
<span class="lineNum">     745 </span><span class="lineCov">   63208306 :   subrtx_ptr_iterator::array_type array;</span>
<span class="lineNum">     746 </span><span class="lineCov">   78616016 :   FOR_EACH_SUBRTX_PTR (iter, array, loc, NONCONST)</span>
<span class="lineNum">     747 </span>            :     {
<span class="lineNum">     748 </span><span class="lineCov">   47012137 :       rtx *loc = *iter;</span>
<span class="lineNum">     749 </span><span class="lineCov">   47012137 :       rtx x = *loc;</span>
<span class="lineNum">     750 </span><span class="lineCov">   47012137 :       if (resolve_subreg_p (x))</span>
<span class="lineNum">     751 </span>            :         {
<span class="lineNum">     752 </span><span class="lineCov">     800412 :           x = simplify_subreg_concatn (GET_MODE (x), SUBREG_REG (x),</span>
<span class="lineNum">     753 </span><span class="lineCov">     800412 :                                        SUBREG_BYTE (x));</span>
<span class="lineNum">     754 </span>            : 
<span class="lineNum">     755 </span>            :           /* It is possible for a note to contain a reference which we can
<span class="lineNum">     756 </span>            :              decompose.  In this case, return 1 to the caller to indicate
<span class="lineNum">     757 </span>            :              that the note must be removed.  */
<span class="lineNum">     758 </span><span class="lineCov">     800412 :           if (!x)</span>
<span class="lineNum">     759 </span>            :             {
<span class="lineNum">     760 </span><span class="lineNoCov">          0 :               gcc_assert (!insn);</span>
<span class="lineNum">     761 </span><span class="lineCov">        274 :               return true;</span>
<span class="lineNum">     762 </span>            :             }
<span class="lineNum">     763 </span>            : 
<span class="lineNum">     764 </span><span class="lineCov">     800412 :           validate_change (insn, loc, x, 1);</span>
<span class="lineNum">     765 </span><span class="lineCov">     800412 :           iter.skip_subrtxes ();</span>
<span class="lineNum">     766 </span>            :         }
<span class="lineNum">     767 </span><span class="lineCov">   46211725 :       else if (resolve_reg_p (x))</span>
<span class="lineNum">     768 </span>            :         /* Return 1 to the caller to indicate that we found a direct
<span class="lineNum">     769 </span>            :            reference to a register which is being decomposed.  This can
<span class="lineNum">     770 </span>            :            happen inside notes, multiword shift or zero-extend
<span class="lineNum">     771 </span>            :            instructions.  */
<span class="lineNum">     772 </span>            :         return true;
<span class="lineNum">     773 </span>            :     }
<span class="lineNum">     774 </span>            : 
<span class="lineNum">     775 </span><span class="lineCov">   31603879 :   return false;</span>
<span class="lineNum">     776 </span>            : }
<span class="lineNum">     777 </span>            : 
<span class="lineNum">     778 </span>            : /* Resolve any decomposed registers which appear in register notes on
<span class="lineNum">     779 </span>            :    INSN.  */
<a name="780"><span class="lineNum">     780 </span>            : </a>
<span class="lineNum">     781 </span>            : static void
<span class="lineNum">     782 </span><span class="lineCov">   20962040 : resolve_reg_notes (rtx_insn *insn)</span>
<span class="lineNum">     783 </span>            : {
<span class="lineNum">     784 </span><span class="lineCov">   20962040 :   rtx *pnote, note;</span>
<span class="lineNum">     785 </span>            : 
<span class="lineNum">     786 </span><span class="lineCov">   20962040 :   note = find_reg_equal_equiv_note (insn);</span>
<span class="lineNum">     787 </span><span class="lineCov">   20962040 :   if (note)</span>
<span class="lineNum">     788 </span>            :     {
<span class="lineNum">     789 </span><span class="lineCov">     308381 :       int old_count = num_validated_changes ();</span>
<span class="lineNum">     790 </span><span class="lineCov">     308381 :       if (resolve_subreg_use (&amp;XEXP (note, 0), NULL_RTX))</span>
<span class="lineNum">     791 </span><span class="lineCov">        274 :         remove_note (insn, note);</span>
<span class="lineNum">     792 </span>            :       else
<span class="lineNum">     793 </span><span class="lineCov">     308107 :         if (old_count != num_validated_changes ())</span>
<span class="lineNum">     794 </span><span class="lineCov">        405 :           df_notes_rescan (insn);</span>
<span class="lineNum">     795 </span>            :     }
<span class="lineNum">     796 </span>            : 
<span class="lineNum">     797 </span><span class="lineCov">   20962040 :   pnote = &amp;REG_NOTES (insn);</span>
<span class="lineNum">     798 </span><span class="lineCov">   27781278 :   while (*pnote != NULL_RTX)</span>
<span class="lineNum">     799 </span>            :     {
<span class="lineNum">     800 </span><span class="lineCov">    6819238 :       bool del = false;</span>
<span class="lineNum">     801 </span>            : 
<span class="lineNum">     802 </span><span class="lineCov">    6819238 :       note = *pnote;</span>
<span class="lineNum">     803 </span><span class="lineCov">    6819238 :       switch (REG_NOTE_KIND (note))</span>
<span class="lineNum">     804 </span>            :         {
<span class="lineNum">     805 </span><span class="lineCov">    2137603 :         case REG_DEAD:</span>
<span class="lineNum">     806 </span><span class="lineCov">    2137603 :         case REG_UNUSED:</span>
<span class="lineNum">     807 </span><span class="lineCov">    2137603 :           if (resolve_reg_p (XEXP (note, 0)))</span>
<span class="lineNum">     808 </span><span class="lineCov">      23337 :             del = true;</span>
<span class="lineNum">     809 </span>            :           break;
<span class="lineNum">     810 </span>            : 
<span class="lineNum">     811 </span>            :         default:
<span class="lineNum">     812 </span>            :           break;
<span class="lineNum">     813 </span>            :         }
<span class="lineNum">     814 </span>            : 
<span class="lineNum">     815 </span><span class="lineCov">      23337 :       if (del)</span>
<span class="lineNum">     816 </span><span class="lineCov">      23337 :         *pnote = XEXP (note, 1);</span>
<span class="lineNum">     817 </span>            :       else
<span class="lineNum">     818 </span><span class="lineCov">    6795901 :         pnote = &amp;XEXP (note, 1);</span>
<span class="lineNum">     819 </span>            :     }
<span class="lineNum">     820 </span><span class="lineCov">   20962040 : }</span>
<span class="lineNum">     821 </span>            : 
<span class="lineNum">     822 </span>            : /* Return whether X can be decomposed into subwords.  */
<a name="823"><span class="lineNum">     823 </span>            : </a>
<span class="lineNum">     824 </span>            : static bool
<span class="lineNum">     825 </span><span class="lineCov">     879854 : can_decompose_p (rtx x)</span>
<span class="lineNum">     826 </span>            : {
<span class="lineNum">     827 </span><span class="lineCov">     879854 :   if (REG_P (x))</span>
<span class="lineNum">     828 </span>            :     {
<span class="lineNum">     829 </span><span class="lineCov">     149378 :       unsigned int regno = REGNO (x);</span>
<span class="lineNum">     830 </span>            : 
<span class="lineNum">     831 </span><span class="lineCov">     149378 :       if (HARD_REGISTER_NUM_P (regno))</span>
<span class="lineNum">     832 </span>            :         {
<span class="lineNum">     833 </span><span class="lineCov">      87146 :           unsigned int byte, num_bytes, num_words;</span>
<span class="lineNum">     834 </span>            : 
<span class="lineNum">     835 </span><span class="lineCov">      87146 :           if (!interesting_mode_p (GET_MODE (x), &amp;num_bytes, &amp;num_words))</span>
<span class="lineNum">     836 </span>            :             return false;
<span class="lineNum">     837 </span><span class="lineCov">     265790 :           for (byte = 0; byte &lt; num_bytes; byte += UNITS_PER_WORD)</span>
<span class="lineNum">     838 </span><span class="lineCov">     522876 :             if (simplify_subreg_regno (regno, GET_MODE (x), byte, word_mode) &lt; 0)</span>
<span class="lineNum">     839 </span>            :               return false;
<span class="lineNum">     840 </span>            :           return true;
<span class="lineNum">     841 </span>            :         }
<span class="lineNum">     842 </span>            :       else
<span class="lineNum">     843 </span><span class="lineCov">      62232 :         return !bitmap_bit_p (subreg_context, regno);</span>
<span class="lineNum">     844 </span>            :     }
<span class="lineNum">     845 </span>            : 
<span class="lineNum">     846 </span>            :   return true;
<span class="lineNum">     847 </span>            : }
<span class="lineNum">     848 </span>            : 
<span class="lineNum">     849 </span>            : /* Decompose the registers used in a simple move SET within INSN.  If
<span class="lineNum">     850 </span>            :    we don't change anything, return INSN, otherwise return the start
<span class="lineNum">     851 </span>            :    of the sequence of moves.  */
<a name="852"><span class="lineNum">     852 </span>            : </a>
<span class="lineNum">     853 </span>            : static rtx_insn *
<span class="lineNum">     854 </span><span class="lineCov">     861520 : resolve_simple_move (rtx set, rtx_insn *insn)</span>
<span class="lineNum">     855 </span>            : {
<span class="lineNum">     856 </span><span class="lineCov">     861520 :   rtx src, dest, real_dest;</span>
<span class="lineNum">     857 </span><span class="lineCov">     861520 :   rtx_insn *insns;</span>
<span class="lineNum">     858 </span><span class="lineCov">     861520 :   machine_mode orig_mode, dest_mode;</span>
<span class="lineNum">     859 </span><span class="lineCov">     861520 :   unsigned int orig_size, words;</span>
<span class="lineNum">     860 </span><span class="lineCov">     861520 :   bool pushing;</span>
<span class="lineNum">     861 </span>            : 
<span class="lineNum">     862 </span><span class="lineCov">     861520 :   src = SET_SRC (set);</span>
<span class="lineNum">     863 </span><span class="lineCov">     861520 :   dest = SET_DEST (set);</span>
<span class="lineNum">     864 </span><span class="lineCov">     861520 :   orig_mode = GET_MODE (dest);</span>
<span class="lineNum">     865 </span>            : 
<span class="lineNum">     866 </span><span class="lineCov">     861520 :   if (!interesting_mode_p (orig_mode, &amp;orig_size, &amp;words))</span>
<span class="lineNum">     867 </span><span class="lineNoCov">          0 :     gcc_unreachable ();</span>
<span class="lineNum">     868 </span><span class="lineCov">     861520 :   gcc_assert (words &gt; 1);</span>
<span class="lineNum">     869 </span>            : 
<span class="lineNum">     870 </span><span class="lineCov">     861520 :   start_sequence ();</span>
<span class="lineNum">     871 </span>            : 
<span class="lineNum">     872 </span>            :   /* We have to handle copying from a SUBREG of a decomposed reg where
<span class="lineNum">     873 </span>            :      the SUBREG is larger than word size.  Rather than assume that we
<span class="lineNum">     874 </span>            :      can take a word_mode SUBREG of the destination, we copy to a new
<span class="lineNum">     875 </span>            :      register and then copy that to the destination.  */
<span class="lineNum">     876 </span>            : 
<span class="lineNum">     877 </span><span class="lineCov">     861520 :   real_dest = NULL_RTX;</span>
<span class="lineNum">     878 </span>            : 
<span class="lineNum">     879 </span><span class="lineCov">     861520 :   if (GET_CODE (src) == SUBREG</span>
<span class="lineNum">     880 </span><span class="lineCov">      27765 :       &amp;&amp; resolve_reg_p (SUBREG_REG (src))</span>
<span class="lineNum">     881 </span><span class="lineCov">     861521 :       &amp;&amp; (maybe_ne (SUBREG_BYTE (src), 0)</span>
<span class="lineNum">     882 </span><span class="lineCov">          3 :           || maybe_ne (orig_size, GET_MODE_SIZE (GET_MODE (SUBREG_REG (src))))))</span>
<span class="lineNum">     883 </span>            :     {
<span class="lineNum">     884 </span><span class="lineNoCov">          0 :       real_dest = dest;</span>
<span class="lineNum">     885 </span><span class="lineNoCov">          0 :       dest = gen_reg_rtx (orig_mode);</span>
<span class="lineNum">     886 </span><span class="lineNoCov">          0 :       if (REG_P (real_dest))</span>
<span class="lineNum">     887 </span><span class="lineNoCov">          0 :         REG_ATTRS (dest) = REG_ATTRS (real_dest);</span>
<span class="lineNum">     888 </span>            :     }
<span class="lineNum">     889 </span>            : 
<span class="lineNum">     890 </span>            :   /* Similarly if we are copying to a SUBREG of a decomposed reg where
<span class="lineNum">     891 </span>            :      the SUBREG is larger than word size.  */
<span class="lineNum">     892 </span>            : 
<span class="lineNum">     893 </span><span class="lineCov">     861520 :   if (GET_CODE (dest) == SUBREG</span>
<span class="lineNum">     894 </span><span class="lineCov">        702 :       &amp;&amp; resolve_reg_p (SUBREG_REG (dest))</span>
<span class="lineNum">     895 </span><span class="lineCov">     861520 :       &amp;&amp; (maybe_ne (SUBREG_BYTE (dest), 0)</span>
<span class="lineNum">     896 </span><span class="lineNoCov">          0 :           || maybe_ne (orig_size,</span>
<span class="lineNum">     897 </span><span class="lineNoCov">          0 :                        GET_MODE_SIZE (GET_MODE (SUBREG_REG (dest))))))</span>
<span class="lineNum">     898 </span>            :     {
<span class="lineNum">     899 </span><span class="lineNoCov">          0 :       rtx reg, smove;</span>
<span class="lineNum">     900 </span><span class="lineNoCov">          0 :       rtx_insn *minsn;</span>
<span class="lineNum">     901 </span>            : 
<span class="lineNum">     902 </span><span class="lineNoCov">          0 :       reg = gen_reg_rtx (orig_mode);</span>
<span class="lineNum">     903 </span><span class="lineNoCov">          0 :       minsn = emit_move_insn (reg, src);</span>
<span class="lineNum">     904 </span><span class="lineNoCov">          0 :       smove = single_set (minsn);</span>
<span class="lineNum">     905 </span><span class="lineNoCov">          0 :       gcc_assert (smove != NULL_RTX);</span>
<span class="lineNum">     906 </span><span class="lineNoCov">          0 :       resolve_simple_move (smove, minsn);</span>
<span class="lineNum">     907 </span><span class="lineNoCov">          0 :       src = reg;</span>
<span class="lineNum">     908 </span>            :     }
<span class="lineNum">     909 </span>            : 
<span class="lineNum">     910 </span>            :   /* If we didn't have any big SUBREGS of decomposed registers, and
<span class="lineNum">     911 </span>            :      neither side of the move is a register we are decomposing, then
<span class="lineNum">     912 </span>            :      we don't have to do anything here.  */
<span class="lineNum">     913 </span>            : 
<span class="lineNum">     914 </span><span class="lineCov">     861520 :   if (src == SET_SRC (set)</span>
<span class="lineNum">     915 </span><span class="lineCov">     861520 :       &amp;&amp; dest == SET_DEST (set)</span>
<span class="lineNum">     916 </span><span class="lineCov">     861520 :       &amp;&amp; !resolve_reg_p (src)</span>
<span class="lineNum">     917 </span><span class="lineCov">     617549 :       &amp;&amp; !resolve_subreg_p (src)</span>
<span class="lineNum">     918 </span><span class="lineCov">     617548 :       &amp;&amp; !resolve_reg_p (dest)</span>
<span class="lineNum">     919 </span><span class="lineCov">    1283113 :       &amp;&amp; !resolve_subreg_p (dest))</span>
<span class="lineNum">     920 </span>            :     {
<span class="lineNum">     921 </span><span class="lineCov">     421593 :       end_sequence ();</span>
<span class="lineNum">     922 </span><span class="lineCov">     421593 :       return insn;</span>
<span class="lineNum">     923 </span>            :     }
<span class="lineNum">     924 </span>            : 
<span class="lineNum">     925 </span>            :   /* It's possible for the code to use a subreg of a decomposed
<span class="lineNum">     926 </span>            :      register while forming an address.  We need to handle that before
<span class="lineNum">     927 </span>            :      passing the address to emit_move_insn.  We pass NULL_RTX as the
<span class="lineNum">     928 </span>            :      insn parameter to resolve_subreg_use because we can not validate
<span class="lineNum">     929 </span>            :      the insn yet.  */
<span class="lineNum">     930 </span><span class="lineCov">     439927 :   if (MEM_P (src) || MEM_P (dest))</span>
<span class="lineNum">     931 </span>            :     {
<span class="lineNum">     932 </span><span class="lineCov">      51853 :       int acg;</span>
<span class="lineNum">     933 </span>            : 
<span class="lineNum">     934 </span><span class="lineCov">      51853 :       if (MEM_P (src))</span>
<span class="lineNum">     935 </span><span class="lineCov">      42772 :         resolve_subreg_use (&amp;XEXP (src, 0), NULL_RTX);</span>
<span class="lineNum">     936 </span><span class="lineCov">      51853 :       if (MEM_P (dest))</span>
<span class="lineNum">     937 </span><span class="lineCov">       9081 :         resolve_subreg_use (&amp;XEXP (dest, 0), NULL_RTX);</span>
<span class="lineNum">     938 </span><span class="lineCov">      51853 :       acg = apply_change_group ();</span>
<span class="lineNum">     939 </span><span class="lineCov">      51853 :       gcc_assert (acg);</span>
<span class="lineNum">     940 </span>            :     }
<span class="lineNum">     941 </span>            : 
<span class="lineNum">     942 </span>            :   /* If SRC is a register which we can't decompose, or has side
<span class="lineNum">     943 </span>            :      effects, we need to move via a temporary register.  */
<span class="lineNum">     944 </span>            : 
<span class="lineNum">     945 </span><span class="lineCov">     439927 :   if (!can_decompose_p (src)</span>
<span class="lineNum">     946 </span><span class="lineCov">     439925 :       || side_effects_p (src)</span>
<span class="lineNum">     947 </span><span class="lineCov">     879852 :       || GET_CODE (src) == ASM_OPERANDS)</span>
<span class="lineNum">     948 </span>            :     {
<span class="lineNum">     949 </span><span class="lineCov">          2 :       rtx reg;</span>
<span class="lineNum">     950 </span>            : 
<span class="lineNum">     951 </span><span class="lineCov">          2 :       reg = gen_reg_rtx (orig_mode);</span>
<span class="lineNum">     952 </span>            : 
<span class="lineNum">     953 </span><span class="lineCov">          2 :       if (AUTO_INC_DEC)</span>
<span class="lineNum">     954 </span>            :         {
<span class="lineNum">     955 </span>            :           rtx_insn *move = emit_move_insn (reg, src);
<span class="lineNum">     956 </span>            :           if (MEM_P (src))
<span class="lineNum">     957 </span>            :             {
<span class="lineNum">     958 </span>            :               rtx note = find_reg_note (insn, REG_INC, NULL_RTX);
<span class="lineNum">     959 </span>            :               if (note)
<span class="lineNum">     960 </span>            :                 add_reg_note (move, REG_INC, XEXP (note, 0));
<span class="lineNum">     961 </span>            :             }
<span class="lineNum">     962 </span>            :         }
<span class="lineNum">     963 </span>            :       else
<span class="lineNum">     964 </span><span class="lineCov">          2 :         emit_move_insn (reg, src);</span>
<span class="lineNum">     965 </span>            : 
<span class="lineNum">     966 </span><span class="lineCov">          2 :       src = reg;</span>
<span class="lineNum">     967 </span>            :     }
<span class="lineNum">     968 </span>            : 
<span class="lineNum">     969 </span>            :   /* If DEST is a register which we can't decompose, or has side
<span class="lineNum">     970 </span>            :      effects, we need to first move to a temporary register.  We
<span class="lineNum">     971 </span>            :      handle the common case of pushing an operand directly.  We also
<span class="lineNum">     972 </span>            :      go through a temporary register if it holds a floating point
<span class="lineNum">     973 </span>            :      value.  This gives us better code on systems which can't move
<span class="lineNum">     974 </span>            :      data easily between integer and floating point registers.  */
<span class="lineNum">     975 </span>            : 
<span class="lineNum">     976 </span><span class="lineCov">     439927 :   dest_mode = orig_mode;</span>
<span class="lineNum">     977 </span><span class="lineCov">     439927 :   pushing = push_operand (dest, dest_mode);</span>
<span class="lineNum">     978 </span><span class="lineCov">     439927 :   if (!can_decompose_p (dest)</span>
<span class="lineNum">     979 </span><span class="lineCov">     439925 :       || (side_effects_p (dest) &amp;&amp; !pushing)</span>
<span class="lineNum">     980 </span><span class="lineCov">     879852 :       || (!SCALAR_INT_MODE_P (dest_mode)</span>
<span class="lineNum">     981 </span><span class="lineCov">          3 :           &amp;&amp; !resolve_reg_p (dest)</span>
<span class="lineNum">     982 </span><span class="lineCov">          2 :           &amp;&amp; !resolve_subreg_p (dest)))</span>
<span class="lineNum">     983 </span>            :     {
<span class="lineNum">     984 </span><span class="lineCov">          4 :       if (real_dest == NULL_RTX)</span>
<span class="lineNum">     985 </span><span class="lineCov">          4 :         real_dest = dest;</span>
<span class="lineNum">     986 </span><span class="lineCov">          4 :       if (!SCALAR_INT_MODE_P (dest_mode))</span>
<span class="lineNum">     987 </span><span class="lineCov">          2 :         dest_mode = int_mode_for_mode (dest_mode).require ();</span>
<span class="lineNum">     988 </span><span class="lineCov">          4 :       dest = gen_reg_rtx (dest_mode);</span>
<span class="lineNum">     989 </span><span class="lineCov">          4 :       if (REG_P (real_dest))</span>
<span class="lineNum">     990 </span><span class="lineCov">          3 :         REG_ATTRS (dest) = REG_ATTRS (real_dest);</span>
<span class="lineNum">     991 </span>            :     }
<span class="lineNum">     992 </span>            : 
<span class="lineNum">     993 </span><span class="lineCov">     439927 :   if (pushing)</span>
<span class="lineNum">     994 </span>            :     {
<span class="lineNum">     995 </span><span class="lineNoCov">          0 :       unsigned int i, j, jinc;</span>
<span class="lineNum">     996 </span>            : 
<span class="lineNum">     997 </span><span class="lineNoCov">          0 :       gcc_assert (orig_size % UNITS_PER_WORD == 0);</span>
<span class="lineNum">     998 </span><span class="lineNoCov">          0 :       gcc_assert (GET_CODE (XEXP (dest, 0)) != PRE_MODIFY);</span>
<span class="lineNum">     999 </span><span class="lineNoCov">          0 :       gcc_assert (GET_CODE (XEXP (dest, 0)) != POST_MODIFY);</span>
<span class="lineNum">    1000 </span>            : 
<span class="lineNum">    1001 </span><span class="lineNoCov">          0 :       if (WORDS_BIG_ENDIAN == STACK_GROWS_DOWNWARD)</span>
<span class="lineNum">    1002 </span>            :         {
<span class="lineNum">    1003 </span>            :           j = 0;
<span class="lineNum">    1004 </span>            :           jinc = 1;
<span class="lineNum">    1005 </span>            :         }
<span class="lineNum">    1006 </span>            :       else
<span class="lineNum">    1007 </span>            :         {
<span class="lineNum">    1008 </span><span class="lineNoCov">          0 :           j = words - 1;</span>
<span class="lineNum">    1009 </span><span class="lineNoCov">          0 :           jinc = -1;</span>
<span class="lineNum">    1010 </span>            :         }
<span class="lineNum">    1011 </span>            : 
<span class="lineNum">    1012 </span><span class="lineNoCov">          0 :       for (i = 0; i &lt; words; ++i, j += jinc)</span>
<span class="lineNum">    1013 </span>            :         {
<span class="lineNum">    1014 </span><span class="lineNoCov">          0 :           rtx temp;</span>
<span class="lineNum">    1015 </span>            : 
<span class="lineNum">    1016 </span><span class="lineNoCov">          0 :           temp = copy_rtx (XEXP (dest, 0));</span>
<span class="lineNum">    1017 </span><span class="lineNoCov">          0 :           temp = adjust_automodify_address_nv (dest, word_mode, temp,</span>
<span class="lineNum">    1018 </span>            :                                                j * UNITS_PER_WORD);
<span class="lineNum">    1019 </span><span class="lineNoCov">          0 :           emit_move_insn (temp,</span>
<span class="lineNum">    1020 </span>            :                           simplify_gen_subreg_concatn (word_mode, src,
<span class="lineNum">    1021 </span>            :                                                        orig_mode,
<span class="lineNum">    1022 </span><span class="lineNoCov">          0 :                                                        j * UNITS_PER_WORD));</span>
<span class="lineNum">    1023 </span>            :         }
<span class="lineNum">    1024 </span>            :     }
<span class="lineNum">    1025 </span>            :   else
<span class="lineNum">    1026 </span>            :     {
<span class="lineNum">    1027 </span><span class="lineCov">     439927 :       unsigned int i;</span>
<span class="lineNum">    1028 </span>            : 
<span class="lineNum">    1029 </span><span class="lineCov">     439927 :       if (REG_P (dest) &amp;&amp; !HARD_REGISTER_NUM_P (REGNO (dest)))</span>
<span class="lineNum">    1030 </span><span class="lineCov">       6395 :         emit_clobber (dest);</span>
<span class="lineNum">    1031 </span>            : 
<span class="lineNum">    1032 </span><span class="lineCov">    1323385 :       for (i = 0; i &lt; words; ++i)</span>
<span class="lineNum">    1033 </span><span class="lineCov">    3533832 :         emit_move_insn (simplify_gen_subreg_concatn (word_mode, dest,</span>
<span class="lineNum">    1034 </span>            :                                                      dest_mode,
<span class="lineNum">    1035 </span><span class="lineCov">     883458 :                                                      i * UNITS_PER_WORD),</span>
<span class="lineNum">    1036 </span>            :                         simplify_gen_subreg_concatn (word_mode, src,
<span class="lineNum">    1037 </span>            :                                                      orig_mode,
<span class="lineNum">    1038 </span><span class="lineCov">     883458 :                                                      i * UNITS_PER_WORD));</span>
<span class="lineNum">    1039 </span>            :     }
<span class="lineNum">    1040 </span>            : 
<span class="lineNum">    1041 </span><span class="lineCov">     439927 :   if (real_dest != NULL_RTX)</span>
<span class="lineNum">    1042 </span>            :     {
<span class="lineNum">    1043 </span><span class="lineCov">          4 :       rtx mdest, smove;</span>
<span class="lineNum">    1044 </span><span class="lineCov">          4 :       rtx_insn *minsn;</span>
<span class="lineNum">    1045 </span>            : 
<span class="lineNum">    1046 </span><span class="lineCov">          4 :       if (dest_mode == orig_mode)</span>
<span class="lineNum">    1047 </span>            :         mdest = dest;
<span class="lineNum">    1048 </span>            :       else
<span class="lineNum">    1049 </span><span class="lineCov">          4 :         mdest = simplify_gen_subreg (orig_mode, dest, GET_MODE (dest), 0);</span>
<span class="lineNum">    1050 </span><span class="lineCov">          4 :       minsn = emit_move_insn (real_dest, mdest);</span>
<span class="lineNum">    1051 </span>            : 
<span class="lineNum">    1052 </span><span class="lineCov">          4 :   if (AUTO_INC_DEC &amp;&amp; MEM_P (real_dest)</span>
<span class="lineNum">    1053 </span>            :       &amp;&amp; !(resolve_reg_p (real_dest) || resolve_subreg_p (real_dest)))
<span class="lineNum">    1054 </span>            :     {
<span class="lineNum">    1055 </span>            :       rtx note = find_reg_note (insn, REG_INC, NULL_RTX);
<span class="lineNum">    1056 </span>            :       if (note)
<span class="lineNum">    1057 </span>            :         add_reg_note (minsn, REG_INC, XEXP (note, 0));
<span class="lineNum">    1058 </span>            :     }
<span class="lineNum">    1059 </span>            : 
<span class="lineNum">    1060 </span><span class="lineCov">          4 :       smove = single_set (minsn);</span>
<span class="lineNum">    1061 </span><span class="lineCov">          4 :       gcc_assert (smove != NULL_RTX);</span>
<span class="lineNum">    1062 </span>            : 
<span class="lineNum">    1063 </span><span class="lineCov">          4 :       resolve_simple_move (smove, minsn);</span>
<span class="lineNum">    1064 </span>            :     }
<span class="lineNum">    1065 </span>            : 
<span class="lineNum">    1066 </span><span class="lineCov">     439927 :   insns = get_insns ();</span>
<span class="lineNum">    1067 </span><span class="lineCov">     439927 :   end_sequence ();</span>
<span class="lineNum">    1068 </span>            : 
<span class="lineNum">    1069 </span><span class="lineCov">     439927 :   copy_reg_eh_region_note_forward (insn, insns, NULL_RTX);</span>
<span class="lineNum">    1070 </span>            : 
<span class="lineNum">    1071 </span><span class="lineCov">     439927 :   emit_insn_before (insns, insn);</span>
<span class="lineNum">    1072 </span>            : 
<span class="lineNum">    1073 </span>            :   /* If we get here via self-recursion, then INSN is not yet in the insns
<span class="lineNum">    1074 </span>            :      chain and delete_insn will fail.  We only want to remove INSN from the
<span class="lineNum">    1075 </span>            :      current sequence.  See PR56738.  */
<span class="lineNum">    1076 </span><span class="lineCov">     439927 :   if (in_sequence_p ())</span>
<span class="lineNum">    1077 </span><span class="lineNoCov">          0 :     remove_insn (insn);</span>
<span class="lineNum">    1078 </span>            :   else
<span class="lineNum">    1079 </span><span class="lineCov">     439927 :     delete_insn (insn);</span>
<span class="lineNum">    1080 </span>            : 
<span class="lineNum">    1081 </span>            :   return insns;
<span class="lineNum">    1082 </span>            : }
<span class="lineNum">    1083 </span>            : 
<span class="lineNum">    1084 </span>            : /* Change a CLOBBER of a decomposed register into a CLOBBER of the
<span class="lineNum">    1085 </span>            :    component registers.  Return whether we changed something.  */
<a name="1086"><span class="lineNum">    1086 </span>            : </a>
<span class="lineNum">    1087 </span>            : static bool
<span class="lineNum">    1088 </span><span class="lineCov">      64979 : resolve_clobber (rtx pat, rtx_insn *insn)</span>
<span class="lineNum">    1089 </span>            : {
<span class="lineNum">    1090 </span><span class="lineCov">      64979 :   rtx reg;</span>
<span class="lineNum">    1091 </span><span class="lineCov">      64979 :   machine_mode orig_mode;</span>
<span class="lineNum">    1092 </span><span class="lineCov">      64979 :   unsigned int orig_size, words, i;</span>
<span class="lineNum">    1093 </span><span class="lineCov">      64979 :   int ret;</span>
<span class="lineNum">    1094 </span>            : 
<span class="lineNum">    1095 </span><span class="lineCov">      64979 :   reg = XEXP (pat, 0);</span>
<span class="lineNum">    1096 </span><span class="lineCov">      64979 :   if (!resolve_reg_p (reg) &amp;&amp; !resolve_subreg_p (reg))</span>
<span class="lineNum">    1097 </span>            :     return false;
<span class="lineNum">    1098 </span>            : 
<span class="lineNum">    1099 </span><span class="lineCov">      24038 :   orig_mode = GET_MODE (reg);</span>
<span class="lineNum">    1100 </span><span class="lineCov">      24038 :   if (!interesting_mode_p (orig_mode, &amp;orig_size, &amp;words))</span>
<span class="lineNum">    1101 </span><span class="lineNoCov">          0 :     gcc_unreachable ();</span>
<span class="lineNum">    1102 </span>            : 
<span class="lineNum">    1103 </span><span class="lineCov">      48076 :   ret = validate_change (NULL_RTX, &amp;XEXP (pat, 0),</span>
<span class="lineNum">    1104 </span>            :                          simplify_gen_subreg_concatn (word_mode, reg,
<span class="lineNum">    1105 </span>            :                                                       orig_mode, 0),
<span class="lineNum">    1106 </span>            :                          0);
<span class="lineNum">    1107 </span><span class="lineCov">      24038 :   df_insn_rescan (insn);</span>
<span class="lineNum">    1108 </span><span class="lineCov">      24038 :   gcc_assert (ret != 0);</span>
<span class="lineNum">    1109 </span>            : 
<span class="lineNum">    1110 </span><span class="lineCov">      48076 :   for (i = words - 1; i &gt; 0; --i)</span>
<span class="lineNum">    1111 </span>            :     {
<span class="lineNum">    1112 </span><span class="lineCov">      24038 :       rtx x;</span>
<span class="lineNum">    1113 </span>            : 
<span class="lineNum">    1114 </span><span class="lineCov">      48076 :       x = simplify_gen_subreg_concatn (word_mode, reg, orig_mode,</span>
<span class="lineNum">    1115 </span><span class="lineCov">      24038 :                                        i * UNITS_PER_WORD);</span>
<span class="lineNum">    1116 </span><span class="lineCov">      24038 :       x = gen_rtx_CLOBBER (VOIDmode, x);</span>
<span class="lineNum">    1117 </span><span class="lineCov">      24038 :       emit_insn_after (x, insn);</span>
<span class="lineNum">    1118 </span>            :     }
<span class="lineNum">    1119 </span>            : 
<span class="lineNum">    1120 </span><span class="lineCov">      24038 :   resolve_reg_notes (insn);</span>
<span class="lineNum">    1121 </span>            : 
<span class="lineNum">    1122 </span><span class="lineCov">      24038 :   return true;</span>
<span class="lineNum">    1123 </span>            : }
<span class="lineNum">    1124 </span>            : 
<span class="lineNum">    1125 </span>            : /* A USE of a decomposed register is no longer meaningful.  Return
<span class="lineNum">    1126 </span>            :    whether we changed something.  */
<a name="1127"><span class="lineNum">    1127 </span>            : </a>
<span class="lineNum">    1128 </span>            : static bool
<span class="lineNum">    1129 </span><span class="lineCov">      49772 : resolve_use (rtx pat, rtx_insn *insn)</span>
<span class="lineNum">    1130 </span>            : {
<span class="lineNum">    1131 </span><span class="lineCov">      49772 :   if (resolve_reg_p (XEXP (pat, 0)) || resolve_subreg_p (XEXP (pat, 0)))</span>
<span class="lineNum">    1132 </span>            :     {
<span class="lineNum">    1133 </span><span class="lineNoCov">          0 :       delete_insn (insn);</span>
<span class="lineNum">    1134 </span><span class="lineNoCov">          0 :       return true;</span>
<span class="lineNum">    1135 </span>            :     }
<span class="lineNum">    1136 </span>            : 
<span class="lineNum">    1137 </span><span class="lineCov">      49772 :   resolve_reg_notes (insn);</span>
<span class="lineNum">    1138 </span>            : 
<span class="lineNum">    1139 </span><span class="lineCov">      49772 :   return false;</span>
<span class="lineNum">    1140 </span>            : }
<span class="lineNum">    1141 </span>            : 
<span class="lineNum">    1142 </span>            : /* A VAR_LOCATION can be simplified.  */
<a name="1143"><span class="lineNum">    1143 </span>            : </a>
<span class="lineNum">    1144 </span>            : static void
<span class="lineNum">    1145 </span><span class="lineCov">    6420942 : resolve_debug (rtx_insn *insn)</span>
<span class="lineNum">    1146 </span>            : {
<span class="lineNum">    1147 </span><span class="lineCov">    6420942 :   subrtx_ptr_iterator::array_type array;</span>
<span class="lineNum">    1148 </span><span class="lineCov">   27670584 :   FOR_EACH_SUBRTX_PTR (iter, array, &amp;PATTERN (insn), NONCONST)</span>
<span class="lineNum">    1149 </span>            :     {
<span class="lineNum">    1150 </span><span class="lineCov">   14828700 :       rtx *loc = *iter;</span>
<span class="lineNum">    1151 </span><span class="lineCov">   14828700 :       rtx x = *loc;</span>
<span class="lineNum">    1152 </span><span class="lineCov">   14828700 :       if (resolve_subreg_p (x))</span>
<span class="lineNum">    1153 </span>            :         {
<span class="lineNum">    1154 </span><span class="lineCov">      31948 :           x = simplify_subreg_concatn (GET_MODE (x), SUBREG_REG (x),</span>
<span class="lineNum">    1155 </span><span class="lineCov">      31948 :                                        SUBREG_BYTE (x));</span>
<span class="lineNum">    1156 </span>            : 
<span class="lineNum">    1157 </span><span class="lineCov">      31948 :           if (x)</span>
<span class="lineNum">    1158 </span><span class="lineCov">      31948 :             *loc = x;</span>
<span class="lineNum">    1159 </span>            :           else
<span class="lineNum">    1160 </span><span class="lineNoCov">          0 :             x = copy_rtx (*loc);</span>
<span class="lineNum">    1161 </span>            :         }
<span class="lineNum">    1162 </span><span class="lineCov">   14828700 :       if (resolve_reg_p (x))</span>
<span class="lineNum">    1163 </span><span class="lineCov">      12264 :         *loc = copy_rtx (x);</span>
<span class="lineNum">    1164 </span>            :     }
<span class="lineNum">    1165 </span>            : 
<span class="lineNum">    1166 </span><span class="lineCov">    6420942 :   df_insn_rescan (insn);</span>
<span class="lineNum">    1167 </span>            : 
<span class="lineNum">    1168 </span><span class="lineCov">    6420942 :   resolve_reg_notes (insn);</span>
<span class="lineNum">    1169 </span><span class="lineCov">    6420942 : }</span>
<span class="lineNum">    1170 </span>            : 
<span class="lineNum">    1171 </span>            : /* Check if INSN is a decomposable multiword-shift or zero-extend and
<span class="lineNum">    1172 </span>            :    set the decomposable_context bitmap accordingly.  SPEED_P is true
<span class="lineNum">    1173 </span>            :    if we are optimizing INSN for speed rather than size.  Return true
<span class="lineNum">    1174 </span>            :    if INSN is decomposable.  */
<a name="1175"><span class="lineNum">    1175 </span>            : </a>
<span class="lineNum">    1176 </span>            : static bool
<span class="lineNum">    1177 </span><span class="lineCov">   44910202 : find_decomposable_shift_zext (rtx_insn *insn, bool speed_p)</span>
<span class="lineNum">    1178 </span>            : {
<span class="lineNum">    1179 </span><span class="lineCov">   44910202 :   rtx set;</span>
<span class="lineNum">    1180 </span><span class="lineCov">   44910202 :   rtx op;</span>
<span class="lineNum">    1181 </span><span class="lineCov">   44910202 :   rtx op_operand;</span>
<span class="lineNum">    1182 </span>            : 
<span class="lineNum">    1183 </span><span class="lineCov">   44910202 :   set = single_set (insn);</span>
<span class="lineNum">    1184 </span><span class="lineCov">   44910202 :   if (!set)</span>
<span class="lineNum">    1185 </span>            :     return false;
<span class="lineNum">    1186 </span>            : 
<span class="lineNum">    1187 </span><span class="lineCov">   26518588 :   op = SET_SRC (set);</span>
<span class="lineNum">    1188 </span><span class="lineCov">   26518588 :   if (GET_CODE (op) != ASHIFT</span>
<span class="lineNum">    1189 </span><span class="lineCov">   26370921 :       &amp;&amp; GET_CODE (op) != LSHIFTRT</span>
<span class="lineNum">    1190 </span><span class="lineCov">   26252515 :       &amp;&amp; GET_CODE (op) != ASHIFTRT</span>
<span class="lineNum">    1191 </span><span class="lineCov">   26214793 :       &amp;&amp; GET_CODE (op) != ZERO_EXTEND)</span>
<span class="lineNum">    1192 </span>            :     return false;
<span class="lineNum">    1193 </span>            : 
<span class="lineNum">    1194 </span><span class="lineCov">     397916 :   op_operand = XEXP (op, 0);</span>
<span class="lineNum">    1195 </span><span class="lineCov">     391827 :   if (!REG_P (SET_DEST (set)) || !REG_P (op_operand)</span>
<span class="lineNum">    1196 </span><span class="lineCov">     702118 :       || HARD_REGISTER_NUM_P (REGNO (SET_DEST (set)))</span>
<span class="lineNum">    1197 </span><span class="lineCov">     700938 :       || HARD_REGISTER_NUM_P (REGNO (op_operand))</span>
<span class="lineNum">    1198 </span><span class="lineCov">    1098832 :       || GET_MODE (op) != twice_word_mode)</span>
<span class="lineNum">    1199 </span>            :     return false;
<span class="lineNum">    1200 </span>            : 
<span class="lineNum">    1201 </span><span class="lineCov">      44562 :   if (GET_CODE (op) == ZERO_EXTEND)</span>
<span class="lineNum">    1202 </span>            :     {
<span class="lineNum">    1203 </span><span class="lineCov">       7091 :       if (GET_MODE (op_operand) != word_mode</span>
<span class="lineNum">    1204 </span><span class="lineCov">       7091 :           || !choices[speed_p].splitting_zext)</span>
<span class="lineNum">    1205 </span>            :         return false;
<span class="lineNum">    1206 </span>            :     }
<span class="lineNum">    1207 </span>            :   else /* left or right shift */
<span class="lineNum">    1208 </span>            :     {
<span class="lineNum">    1209 </span><span class="lineCov">      37471 :       bool *splitting = (GET_CODE (op) == ASHIFT</span>
<span class="lineNum">    1210 </span><span class="lineCov">      11768 :                          ? choices[speed_p].splitting_ashift</span>
<span class="lineNum">    1211 </span>            :                          : GET_CODE (op) == ASHIFTRT
<span class="lineNum">    1212 </span><span class="lineCov">       4242 :                          ? choices[speed_p].splitting_ashiftrt</span>
<span class="lineNum">    1213 </span><span class="lineCov">      21461 :                          : choices[speed_p].splitting_lshiftrt);</span>
<span class="lineNum">    1214 </span><span class="lineCov">      37471 :       if (!CONST_INT_P (XEXP (op, 1))</span>
<span class="lineNum">    1215 </span><span class="lineCov">      71670 :           || !IN_RANGE (INTVAL (XEXP (op, 1)), BITS_PER_WORD,</span>
<span class="lineNum">    1216 </span>            :                         2 * BITS_PER_WORD - 1)
<span class="lineNum">    1217 </span><span class="lineCov">      42398 :           || !splitting[INTVAL (XEXP (op, 1)) - BITS_PER_WORD])</span>
<span class="lineNum">    1218 </span>            :         return false;
<span class="lineNum">    1219 </span>            : 
<span class="lineNum">    1220 </span><span class="lineCov">      56118 :       bitmap_set_bit (decomposable_context, REGNO (op_operand));</span>
<span class="lineNum">    1221 </span>            :     }
<span class="lineNum">    1222 </span>            : 
<span class="lineNum">    1223 </span><span class="lineCov">      28059 :   bitmap_set_bit (decomposable_context, REGNO (SET_DEST (set)));</span>
<span class="lineNum">    1224 </span>            : 
<span class="lineNum">    1225 </span><span class="lineCov">      28059 :   return true;</span>
<span class="lineNum">    1226 </span>            : }
<span class="lineNum">    1227 </span>            : 
<span class="lineNum">    1228 </span>            : /* Decompose a more than word wide shift (in INSN) of a multiword
<span class="lineNum">    1229 </span>            :    pseudo or a multiword zero-extend of a wordmode pseudo into a move
<span class="lineNum">    1230 </span>            :    and 'set to zero' insn.  Return a pointer to the new insn when a
<span class="lineNum">    1231 </span>            :    replacement was done.  */
<a name="1232"><span class="lineNum">    1232 </span>            : </a>
<span class="lineNum">    1233 </span>            : static rtx_insn *
<span class="lineNum">    1234 </span><span class="lineCov">   13605772 : resolve_shift_zext (rtx_insn *insn)</span>
<span class="lineNum">    1235 </span>            : {
<span class="lineNum">    1236 </span><span class="lineCov">   13605772 :   rtx set;</span>
<span class="lineNum">    1237 </span><span class="lineCov">   13605772 :   rtx op;</span>
<span class="lineNum">    1238 </span><span class="lineCov">   13605772 :   rtx op_operand;</span>
<span class="lineNum">    1239 </span><span class="lineCov">   13605772 :   rtx_insn *insns;</span>
<span class="lineNum">    1240 </span><span class="lineCov">   13605772 :   rtx src_reg, dest_reg, dest_upper, upper_src = NULL_RTX;</span>
<span class="lineNum">    1241 </span><span class="lineCov">   13605772 :   int src_reg_num, dest_reg_num, offset1, offset2, src_offset;</span>
<span class="lineNum">    1242 </span><span class="lineCov">   13605772 :   scalar_int_mode inner_mode;</span>
<span class="lineNum">    1243 </span>            : 
<span class="lineNum">    1244 </span><span class="lineCov">   13605772 :   set = single_set (insn);</span>
<span class="lineNum">    1245 </span><span class="lineCov">   13605772 :   if (!set)</span>
<span class="lineNum">    1246 </span>            :     return NULL;
<span class="lineNum">    1247 </span>            : 
<span class="lineNum">    1248 </span><span class="lineCov">   12757250 :   op = SET_SRC (set);</span>
<span class="lineNum">    1249 </span><span class="lineCov">   12757250 :   if (GET_CODE (op) != ASHIFT</span>
<span class="lineNum">    1250 </span><span class="lineCov">   12695999 :       &amp;&amp; GET_CODE (op) != LSHIFTRT</span>
<span class="lineNum">    1251 </span><span class="lineCov">   12630560 :       &amp;&amp; GET_CODE (op) != ASHIFTRT</span>
<span class="lineNum">    1252 </span><span class="lineCov">   12613519 :       &amp;&amp; GET_CODE (op) != ZERO_EXTEND)</span>
<span class="lineNum">    1253 </span>            :     return NULL;
<span class="lineNum">    1254 </span>            : 
<span class="lineNum">    1255 </span><span class="lineCov">     197641 :   op_operand = XEXP (op, 0);</span>
<span class="lineNum">    1256 </span><span class="lineCov">     197641 :   if (!is_a &lt;scalar_int_mode&gt; (GET_MODE (op_operand), &amp;inner_mode))</span>
<span class="lineNum">    1257 </span>            :     return NULL;
<span class="lineNum">    1258 </span>            : 
<span class="lineNum">    1259 </span>            :   /* We can tear this operation apart only if the regs were already
<span class="lineNum">    1260 </span>            :      torn apart.  */
<span class="lineNum">    1261 </span><span class="lineCov">     191366 :   if (!resolve_reg_p (SET_DEST (set)) &amp;&amp; !resolve_reg_p (op_operand))</span>
<span class="lineNum">    1262 </span>            :     return NULL;
<span class="lineNum">    1263 </span>            : 
<span class="lineNum">    1264 </span>            :   /* src_reg_num is the number of the word mode register which we
<span class="lineNum">    1265 </span>            :      are operating on.  For a left shift and a zero_extend on little
<span class="lineNum">    1266 </span>            :      endian machines this is register 0.  */
<span class="lineNum">    1267 </span><span class="lineCov">      23504 :   src_reg_num = (GET_CODE (op) == LSHIFTRT || GET_CODE (op) == ASHIFTRT)</span>
<span class="lineNum">    1268 </span><span class="lineCov">      11752 :                 ? 1 : 0;</span>
<span class="lineNum">    1269 </span>            : 
<span class="lineNum">    1270 </span><span class="lineCov">      11752 :   if (WORDS_BIG_ENDIAN &amp;&amp; GET_MODE_SIZE (inner_mode) &gt; UNITS_PER_WORD)</span>
<span class="lineNum">    1271 </span>            :     src_reg_num = 1 - src_reg_num;
<span class="lineNum">    1272 </span>            : 
<span class="lineNum">    1273 </span><span class="lineCov">      11752 :   if (GET_CODE (op) == ZERO_EXTEND)</span>
<span class="lineNum">    1274 </span>            :     dest_reg_num = WORDS_BIG_ENDIAN ? 1 : 0;
<span class="lineNum">    1275 </span>            :   else
<span class="lineNum">    1276 </span><span class="lineCov">      11752 :     dest_reg_num = 1 - src_reg_num;</span>
<span class="lineNum">    1277 </span>            : 
<span class="lineNum">    1278 </span><span class="lineCov">      11752 :   offset1 = UNITS_PER_WORD * dest_reg_num;</span>
<span class="lineNum">    1279 </span><span class="lineCov">      11752 :   offset2 = UNITS_PER_WORD * (1 - dest_reg_num);</span>
<span class="lineNum">    1280 </span><span class="lineCov">      11752 :   src_offset = UNITS_PER_WORD * src_reg_num;</span>
<span class="lineNum">    1281 </span>            : 
<span class="lineNum">    1282 </span><span class="lineCov">      11752 :   start_sequence ();</span>
<span class="lineNum">    1283 </span>            : 
<span class="lineNum">    1284 </span><span class="lineCov">      11752 :   dest_reg = simplify_gen_subreg_concatn (word_mode, SET_DEST (set),</span>
<span class="lineNum">    1285 </span><span class="lineCov">      11752 :                                           GET_MODE (SET_DEST (set)),</span>
<span class="lineNum">    1286 </span>            :                                           offset1);
<span class="lineNum">    1287 </span><span class="lineCov">      11752 :   dest_upper = simplify_gen_subreg_concatn (word_mode, SET_DEST (set),</span>
<span class="lineNum">    1288 </span><span class="lineCov">      11752 :                                             GET_MODE (SET_DEST (set)),</span>
<span class="lineNum">    1289 </span>            :                                             offset2);
<span class="lineNum">    1290 </span><span class="lineCov">      11752 :   src_reg = simplify_gen_subreg_concatn (word_mode, op_operand,</span>
<span class="lineNum">    1291 </span><span class="lineCov">      11752 :                                          GET_MODE (op_operand),</span>
<span class="lineNum">    1292 </span>            :                                          src_offset);
<span class="lineNum">    1293 </span><span class="lineCov">      11752 :   if (GET_CODE (op) == ASHIFTRT</span>
<span class="lineNum">    1294 </span><span class="lineCov">       3573 :       &amp;&amp; INTVAL (XEXP (op, 1)) != 2 * BITS_PER_WORD - 1)</span>
<span class="lineNum">    1295 </span><span class="lineCov">       3480 :     upper_src = expand_shift (RSHIFT_EXPR, word_mode, copy_rtx (src_reg),</span>
<span class="lineNum">    1296 </span><span class="lineCov">       3538 :                               BITS_PER_WORD - 1, NULL_RTX, 0);</span>
<span class="lineNum">    1297 </span>            : 
<span class="lineNum">    1298 </span><span class="lineCov">      11752 :   if (GET_CODE (op) != ZERO_EXTEND)</span>
<span class="lineNum">    1299 </span>            :     {
<span class="lineNum">    1300 </span><span class="lineCov">      11752 :       int shift_count = INTVAL (XEXP (op, 1));</span>
<span class="lineNum">    1301 </span><span class="lineCov">      14174 :       if (shift_count &gt; BITS_PER_WORD)</span>
<span class="lineNum">    1302 </span><span class="lineCov">       2582 :         src_reg = expand_shift (GET_CODE (op) == ASHIFT ?</span>
<span class="lineNum">    1303 </span>            :                                 LSHIFT_EXPR : RSHIFT_EXPR,
<span class="lineNum">    1304 </span>            :                                 word_mode, src_reg,
<span class="lineNum">    1305 </span><span class="lineCov">        900 :                                 shift_count - BITS_PER_WORD,</span>
<span class="lineNum">    1306 </span>            :                                 dest_reg, GET_CODE (op) != ASHIFTRT);
<span class="lineNum">    1307 </span>            :     }
<span class="lineNum">    1308 </span>            : 
<span class="lineNum">    1309 </span><span class="lineCov">      11752 :   if (dest_reg != src_reg)</span>
<span class="lineNum">    1310 </span><span class="lineCov">      10852 :     emit_move_insn (dest_reg, src_reg);</span>
<span class="lineNum">    1311 </span><span class="lineCov">      11752 :   if (GET_CODE (op) != ASHIFTRT)</span>
<span class="lineNum">    1312 </span><span class="lineCov">      16492 :     emit_move_insn (dest_upper, CONST0_RTX (word_mode));</span>
<span class="lineNum">    1313 </span><span class="lineCov">       3573 :   else if (INTVAL (XEXP (op, 1)) == 2 * BITS_PER_WORD - 1)</span>
<span class="lineNum">    1314 </span><span class="lineCov">         26 :     emit_move_insn (dest_upper, copy_rtx (src_reg));</span>
<span class="lineNum">    1315 </span>            :   else
<span class="lineNum">    1316 </span><span class="lineCov">       3480 :     emit_move_insn (dest_upper, upper_src);</span>
<span class="lineNum">    1317 </span><span class="lineCov">      11752 :   insns = get_insns ();</span>
<span class="lineNum">    1318 </span>            : 
<span class="lineNum">    1319 </span><span class="lineCov">      11752 :   end_sequence ();</span>
<span class="lineNum">    1320 </span>            : 
<span class="lineNum">    1321 </span><span class="lineCov">      11752 :   emit_insn_before (insns, insn);</span>
<span class="lineNum">    1322 </span>            : 
<span class="lineNum">    1323 </span><span class="lineCov">      11752 :   if (dump_file)</span>
<span class="lineNum">    1324 </span>            :     {
<span class="lineNum">    1325 </span><span class="lineNoCov">          0 :       rtx_insn *in;</span>
<span class="lineNum">    1326 </span><span class="lineNoCov">          0 :       fprintf (dump_file, &quot;; Replacing insn: %d with insns: &quot;, INSN_UID (insn));</span>
<span class="lineNum">    1327 </span><span class="lineNoCov">          0 :       for (in = insns; in != insn; in = NEXT_INSN (in))</span>
<span class="lineNum">    1328 </span><span class="lineNoCov">          0 :         fprintf (dump_file, &quot;%d &quot;, INSN_UID (in));</span>
<span class="lineNum">    1329 </span><span class="lineNoCov">          0 :       fprintf (dump_file, &quot;\n&quot;);</span>
<span class="lineNum">    1330 </span>            :     }
<span class="lineNum">    1331 </span>            : 
<span class="lineNum">    1332 </span><span class="lineCov">      11752 :   delete_insn (insn);</span>
<span class="lineNum">    1333 </span><span class="lineCov">      11752 :   return insns;</span>
<span class="lineNum">    1334 </span>            : }
<span class="lineNum">    1335 </span>            : 
<span class="lineNum">    1336 </span>            : /* Print to dump_file a description of what we're doing with shift code CODE.
<span class="lineNum">    1337 </span>            :    SPLITTING[X] is true if we are splitting shifts by X + BITS_PER_WORD.  */
<a name="1338"><span class="lineNum">    1338 </span>            : </a>
<span class="lineNum">    1339 </span>            : static void
<span class="lineNum">    1340 </span><span class="lineCov">        360 : dump_shift_choices (enum rtx_code code, bool *splitting)</span>
<span class="lineNum">    1341 </span>            : {
<span class="lineNum">    1342 </span><span class="lineCov">        360 :   int i;</span>
<span class="lineNum">    1343 </span><span class="lineCov">        360 :   const char *sep;</span>
<span class="lineNum">    1344 </span>            : 
<span class="lineNum">    1345 </span><span class="lineCov">        720 :   fprintf (dump_file,</span>
<span class="lineNum">    1346 </span>            :            &quot;  Splitting mode %s for %s lowering with shift amounts = &quot;,
<span class="lineNum">    1347 </span><span class="lineCov">        360 :            GET_MODE_NAME (twice_word_mode), GET_RTX_NAME (code));</span>
<span class="lineNum">    1348 </span><span class="lineCov">        360 :   sep = &quot;&quot;;</span>
<span class="lineNum">    1349 </span><span class="lineCov">      23400 :   for (i = 0; i &lt; BITS_PER_WORD; i++)</span>
<span class="lineNum">    1350 </span><span class="lineCov">      23040 :     if (splitting[i])</span>
<span class="lineNum">    1351 </span>            :       {
<span class="lineNum">    1352 </span><span class="lineCov">      23040 :         fprintf (dump_file, &quot;%s%d&quot;, sep, i + BITS_PER_WORD);</span>
<span class="lineNum">    1353 </span><span class="lineCov">      23040 :         sep = &quot;,&quot;;</span>
<span class="lineNum">    1354 </span>            :       }
<span class="lineNum">    1355 </span><span class="lineCov">        360 :   fprintf (dump_file, &quot;\n&quot;);</span>
<span class="lineNum">    1356 </span><span class="lineCov">        360 : }</span>
<span class="lineNum">    1357 </span>            : 
<span class="lineNum">    1358 </span>            : /* Print to dump_file a description of what we're doing when optimizing
<span class="lineNum">    1359 </span>            :    for speed or size; SPEED_P says which.  DESCRIPTION is a description
<span class="lineNum">    1360 </span>            :    of the SPEED_P choice.  */
<a name="1361"><span class="lineNum">    1361 </span>            : </a>
<span class="lineNum">    1362 </span>            : static void
<span class="lineNum">    1363 </span><span class="lineCov">        120 : dump_choices (bool speed_p, const char *description)</span>
<span class="lineNum">    1364 </span>            : {
<span class="lineNum">    1365 </span><span class="lineCov">        120 :   unsigned int size, factor, i;</span>
<span class="lineNum">    1366 </span>            : 
<span class="lineNum">    1367 </span><span class="lineCov">        120 :   fprintf (dump_file, &quot;Choices when optimizing for %s:\n&quot;, description);</span>
<span class="lineNum">    1368 </span>            : 
<span class="lineNum">    1369 </span><span class="lineCov">      12720 :   for (i = 0; i &lt; MAX_MACHINE_MODE; i++)</span>
<span class="lineNum">    1370 </span><span class="lineCov">      12600 :     if (interesting_mode_p ((machine_mode) i, &amp;size, &amp;factor)</span>
<span class="lineNum">    1371 </span><span class="lineCov">      12600 :         &amp;&amp; factor &gt; 1)</span>
<span class="lineNum">    1372 </span><span class="lineCov">       6600 :       fprintf (dump_file, &quot;  %s mode %s for copy lowering.\n&quot;,</span>
<span class="lineNum">    1373 </span><span class="lineCov">       6600 :                choices[speed_p].move_modes_to_split[i]</span>
<span class="lineNum">    1374 </span>            :                ? &quot;Splitting&quot;
<span class="lineNum">    1375 </span>            :                : &quot;Skipping&quot;,
<span class="lineNum">    1376 </span><span class="lineCov">       6600 :                GET_MODE_NAME ((machine_mode) i));</span>
<span class="lineNum">    1377 </span>            : 
<span class="lineNum">    1378 </span><span class="lineCov">        120 :   fprintf (dump_file, &quot;  %s mode %s for zero_extend lowering.\n&quot;,</span>
<span class="lineNum">    1379 </span><span class="lineCov">        120 :            choices[speed_p].splitting_zext ? &quot;Splitting&quot; : &quot;Skipping&quot;,</span>
<span class="lineNum">    1380 </span><span class="lineCov">        240 :            GET_MODE_NAME (twice_word_mode));</span>
<span class="lineNum">    1381 </span>            : 
<span class="lineNum">    1382 </span><span class="lineCov">        120 :   dump_shift_choices (ASHIFT, choices[speed_p].splitting_ashift);</span>
<span class="lineNum">    1383 </span><span class="lineCov">        120 :   dump_shift_choices (LSHIFTRT, choices[speed_p].splitting_lshiftrt);</span>
<span class="lineNum">    1384 </span><span class="lineCov">        120 :   dump_shift_choices (ASHIFTRT, choices[speed_p].splitting_ashiftrt);</span>
<span class="lineNum">    1385 </span><span class="lineCov">        120 :   fprintf (dump_file, &quot;\n&quot;);</span>
<span class="lineNum">    1386 </span><span class="lineCov">        120 : }</span>
<span class="lineNum">    1387 </span>            : 
<span class="lineNum">    1388 </span>            : /* Look for registers which are always accessed via word-sized SUBREGs
<span class="lineNum">    1389 </span>            :    or -if DECOMPOSE_COPIES is true- via copies.  Decompose these
<span class="lineNum">    1390 </span>            :    registers into several word-sized pseudo-registers.  */
<a name="1391"><span class="lineNum">    1391 </span>            : </a>
<span class="lineNum">    1392 </span>            : static void
<span class="lineNum">    1393 </span><span class="lineCov">    1244911 : decompose_multiword_subregs (bool decompose_copies)</span>
<span class="lineNum">    1394 </span>            : {
<span class="lineNum">    1395 </span><span class="lineCov">    1244911 :   unsigned int max;</span>
<span class="lineNum">    1396 </span><span class="lineCov">    1244911 :   basic_block bb;</span>
<span class="lineNum">    1397 </span><span class="lineCov">    1244911 :   bool speed_p;</span>
<span class="lineNum">    1398 </span>            : 
<span class="lineNum">    1399 </span><span class="lineCov">    1244911 :   if (dump_file)</span>
<span class="lineNum">    1400 </span>            :     {
<span class="lineNum">    1401 </span><span class="lineCov">         60 :       dump_choices (false, &quot;size&quot;);</span>
<span class="lineNum">    1402 </span><span class="lineCov">         60 :       dump_choices (true, &quot;speed&quot;);</span>
<span class="lineNum">    1403 </span>            :     }
<span class="lineNum">    1404 </span>            : 
<span class="lineNum">    1405 </span>            :   /* Check if this target even has any modes to consider lowering.   */
<span class="lineNum">    1406 </span><span class="lineCov">    1244911 :   if (!choices[false].something_to_do &amp;&amp; !choices[true].something_to_do)</span>
<span class="lineNum">    1407 </span>            :     {
<span class="lineNum">    1408 </span><span class="lineNoCov">          0 :       if (dump_file)</span>
<span class="lineNum">    1409 </span><span class="lineNoCov">          0 :         fprintf (dump_file, &quot;Nothing to do!\n&quot;);</span>
<span class="lineNum">    1410 </span><span class="lineNoCov">          0 :       return;</span>
<span class="lineNum">    1411 </span>            :     }
<span class="lineNum">    1412 </span>            : 
<span class="lineNum">    1413 </span><span class="lineCov">    1244911 :   max = max_reg_num ();</span>
<span class="lineNum">    1414 </span>            : 
<span class="lineNum">    1415 </span>            :   /* First see if there are any multi-word pseudo-registers.  If there
<span class="lineNum">    1416 </span>            :      aren't, there is nothing we can do.  This should speed up this
<span class="lineNum">    1417 </span>            :      pass in the normal case, since it should be faster than scanning
<span class="lineNum">    1418 </span>            :      all the insns.  */
<span class="lineNum">    1419 </span><span class="lineCov">    1244911 :   {</span>
<span class="lineNum">    1420 </span><span class="lineCov">    1244911 :     unsigned int i;</span>
<span class="lineNum">    1421 </span><span class="lineCov">    1244911 :     bool useful_modes_seen = false;</span>
<span class="lineNum">    1422 </span>            : 
<span class="lineNum">    1423 </span><span class="lineCov">   42927802 :     for (i = FIRST_PSEUDO_REGISTER; i &lt; max; ++i)</span>
<span class="lineNum">    1424 </span><span class="lineCov">   41871151 :       if (regno_reg_rtx[i] != NULL)</span>
<span class="lineNum">    1425 </span>            :         {
<span class="lineNum">    1426 </span><span class="lineCov">   41676087 :           machine_mode mode = GET_MODE (regno_reg_rtx[i]);</span>
<span class="lineNum">    1427 </span><span class="lineCov">   41676087 :           if (choices[false].move_modes_to_split[(int) mode]</span>
<span class="lineNum">    1428 </span><span class="lineCov">   41487827 :               || choices[true].move_modes_to_split[(int) mode])</span>
<span class="lineNum">    1429 </span>            :             {
<span class="lineNum">    1430 </span>            :               useful_modes_seen = true;
<span class="lineNum">    1431 </span>            :               break;
<span class="lineNum">    1432 </span>            :             }
<span class="lineNum">    1433 </span>            :         }
<span class="lineNum">    1434 </span>            : 
<span class="lineNum">    1435 </span><span class="lineCov">    1244911 :     if (!useful_modes_seen)</span>
<span class="lineNum">    1436 </span>            :       {
<span class="lineNum">    1437 </span><span class="lineCov">    1056651 :         if (dump_file)</span>
<span class="lineNum">    1438 </span><span class="lineCov">         60 :           fprintf (dump_file, &quot;Nothing to lower in this function.\n&quot;);</span>
<span class="lineNum">    1439 </span><span class="lineCov">    1056651 :         return;</span>
<span class="lineNum">    1440 </span>            :       }
<span class="lineNum">    1441 </span>            :   }
<span class="lineNum">    1442 </span>            : 
<span class="lineNum">    1443 </span><span class="lineCov">     188260 :   if (df)</span>
<span class="lineNum">    1444 </span>            :     {
<span class="lineNum">    1445 </span><span class="lineCov">      77499 :       df_set_flags (DF_DEFER_INSN_RESCAN);</span>
<span class="lineNum">    1446 </span><span class="lineCov">      77499 :       run_word_dce ();</span>
<span class="lineNum">    1447 </span>            :     }
<span class="lineNum">    1448 </span>            : 
<span class="lineNum">    1449 </span>            :   /* FIXME: It may be possible to change this code to look for each
<span class="lineNum">    1450 </span>            :      multi-word pseudo-register and to find each insn which sets or
<span class="lineNum">    1451 </span>            :      uses that register.  That should be faster than scanning all the
<span class="lineNum">    1452 </span>            :      insns.  */
<span class="lineNum">    1453 </span>            : 
<span class="lineNum">    1454 </span><span class="lineCov">     188260 :   decomposable_context = BITMAP_ALLOC (NULL);</span>
<span class="lineNum">    1455 </span><span class="lineCov">     188260 :   non_decomposable_context = BITMAP_ALLOC (NULL);</span>
<span class="lineNum">    1456 </span><span class="lineCov">     188260 :   subreg_context = BITMAP_ALLOC (NULL);</span>
<span class="lineNum">    1457 </span>            : 
<span class="lineNum">    1458 </span><span class="lineCov">     188260 :   reg_copy_graph.create (max);</span>
<span class="lineNum">    1459 </span><span class="lineCov">     188260 :   reg_copy_graph.safe_grow_cleared (max);</span>
<span class="lineNum">    1460 </span><span class="lineCov">     188260 :   memset (reg_copy_graph.address (), 0, sizeof (bitmap) * max);</span>
<span class="lineNum">    1461 </span>            : 
<span class="lineNum">    1462 </span><span class="lineCov">     188260 :   speed_p = optimize_function_for_speed_p (cfun);</span>
<span class="lineNum">    1463 </span><span class="lineCov">    4243072 :   FOR_EACH_BB_FN (bb, cfun)</span>
<span class="lineNum">    1464 </span>            :     {
<span class="lineNum">    1465 </span><span class="lineCov">    4054812 :       rtx_insn *insn;</span>
<span class="lineNum">    1466 </span>            : 
<span class="lineNum">    1467 </span><span class="lineCov">  107585420 :       FOR_BB_INSNS (bb, insn)</span>
<span class="lineNum">    1468 </span>            :         {
<span class="lineNum">    1469 </span><span class="lineCov">   51765304 :           rtx set;</span>
<span class="lineNum">    1470 </span><span class="lineCov">   51765304 :           enum classify_move_insn cmi;</span>
<span class="lineNum">    1471 </span><span class="lineCov">   51765304 :           int i, n;</span>
<span class="lineNum">    1472 </span>            : 
<span class="lineNum">    1473 </span><span class="lineCov">   51765304 :           if (!INSN_P (insn)</span>
<span class="lineNum">    1474 </span><span class="lineCov">   90146222 :               || GET_CODE (PATTERN (insn)) == CLOBBER</span>
<span class="lineNum">    1475 </span><span class="lineCov">  141806596 :               || GET_CODE (PATTERN (insn)) == USE)</span>
<span class="lineNum">    1476 </span><span class="lineCov">    6883161 :             continue;</span>
<span class="lineNum">    1477 </span>            : 
<span class="lineNum">    1478 </span><span class="lineCov">   44910202 :           recog_memoized (insn);</span>
<span class="lineNum">    1479 </span>            : 
<span class="lineNum">    1480 </span><span class="lineCov">   44910202 :           if (find_decomposable_shift_zext (insn, speed_p))</span>
<span class="lineNum">    1481 </span>            :             continue;
<span class="lineNum">    1482 </span>            : 
<span class="lineNum">    1483 </span><span class="lineCov">   44882143 :           extract_insn (insn);</span>
<span class="lineNum">    1484 </span>            : 
<span class="lineNum">    1485 </span><span class="lineCov">   44882143 :           set = simple_move (insn, speed_p);</span>
<span class="lineNum">    1486 </span>            : 
<span class="lineNum">    1487 </span><span class="lineCov">   44882143 :           if (!set)</span>
<span class="lineNum">    1488 </span><span class="lineCov">   43584280 :             cmi = NOT_SIMPLE_MOVE;</span>
<span class="lineNum">    1489 </span>            :           else
<span class="lineNum">    1490 </span>            :             {
<span class="lineNum">    1491 </span>            :               /* We mark pseudo-to-pseudo copies as decomposable during the
<span class="lineNum">    1492 </span>            :                  second pass only.  The first pass is so early that there is
<span class="lineNum">    1493 </span>            :                  good chance such moves will be optimized away completely by
<span class="lineNum">    1494 </span>            :                  subsequent optimizations anyway.
<span class="lineNum">    1495 </span>            : 
<span class="lineNum">    1496 </span>            :                  However, we call find_pseudo_copy even during the first pass
<span class="lineNum">    1497 </span>            :                  so as to properly set up the reg_copy_graph.  */
<span class="lineNum">    1498 </span><span class="lineCov">    1297863 :               if (find_pseudo_copy (set))</span>
<span class="lineNum">    1499 </span><span class="lineCov">     564751 :                 cmi = decompose_copies? DECOMPOSABLE_SIMPLE_MOVE : SIMPLE_MOVE;</span>
<span class="lineNum">    1500 </span>            :               else
<span class="lineNum">    1501 </span><span class="lineCov">    1014336 :                 cmi = SIMPLE_MOVE;</span>
<span class="lineNum">    1502 </span>            :             }
<span class="lineNum">    1503 </span>            : 
<span class="lineNum">    1504 </span><span class="lineCov">   44882143 :           n = recog_data.n_operands;</span>
<span class="lineNum">    1505 </span><span class="lineCov">  106228584 :           for (i = 0; i &lt; n; ++i)</span>
<span class="lineNum">    1506 </span>            :             {
<span class="lineNum">    1507 </span><span class="lineCov">   61346441 :               find_decomposable_subregs (&amp;recog_data.operand[i], &amp;cmi);</span>
<span class="lineNum">    1508 </span>            : 
<span class="lineNum">    1509 </span>            :               /* We handle ASM_OPERANDS as a special case to support
<span class="lineNum">    1510 </span>            :                  things like x86 rdtsc which returns a DImode value.
<span class="lineNum">    1511 </span>            :                  We can decompose the output, which will certainly be
<span class="lineNum">    1512 </span>            :                  operand 0, but not the inputs.  */
<span class="lineNum">    1513 </span>            : 
<span class="lineNum">    1514 </span><span class="lineCov">   61346441 :               if (cmi == SIMPLE_MOVE</span>
<span class="lineNum">    1515 </span><span class="lineCov">    2591120 :                   &amp;&amp; GET_CODE (SET_SRC (set)) == ASM_OPERANDS)</span>
<span class="lineNum">    1516 </span>            :                 {
<span class="lineNum">    1517 </span><span class="lineNoCov">          0 :                   gcc_assert (i == 0);</span>
<span class="lineNum">    1518 </span><span class="lineNoCov">          0 :                   cmi = NOT_SIMPLE_MOVE;</span>
<span class="lineNum">    1519 </span>            :                 }
<span class="lineNum">    1520 </span>            :             }
<span class="lineNum">    1521 </span>            :         }
<span class="lineNum">    1522 </span>            :     }
<span class="lineNum">    1523 </span>            : 
<span class="lineNum">    1524 </span><span class="lineCov">     188260 :   bitmap_and_compl_into (decomposable_context, non_decomposable_context);</span>
<span class="lineNum">    1525 </span><span class="lineCov">     376520 :   if (!bitmap_empty_p (decomposable_context))</span>
<span class="lineNum">    1526 </span>            :     {
<span class="lineNum">    1527 </span><span class="lineCov">      81844 :       unsigned int i;</span>
<span class="lineNum">    1528 </span><span class="lineCov">      81844 :       sbitmap_iterator sbi;</span>
<span class="lineNum">    1529 </span><span class="lineCov">      81844 :       bitmap_iterator iter;</span>
<span class="lineNum">    1530 </span><span class="lineCov">      81844 :       unsigned int regno;</span>
<span class="lineNum">    1531 </span>            : 
<span class="lineNum">    1532 </span><span class="lineCov">      81844 :       propagate_pseudo_copies ();</span>
<span class="lineNum">    1533 </span>            : 
<span class="lineNum">    1534 </span><span class="lineCov">     245532 :       auto_sbitmap sub_blocks (last_basic_block_for_fn (cfun));</span>
<span class="lineNum">    1535 </span><span class="lineCov">     163688 :       bitmap_clear (sub_blocks);</span>
<span class="lineNum">    1536 </span>            : 
<span class="lineNum">    1537 </span><span class="lineCov">     571447 :       EXECUTE_IF_SET_IN_BITMAP (decomposable_context, 0, regno, iter)</span>
<span class="lineNum">    1538 </span><span class="lineCov">     489603 :         decompose_register (regno);</span>
<span class="lineNum">    1539 </span>            : 
<span class="lineNum">    1540 </span><span class="lineCov">    2094610 :       FOR_EACH_BB_FN (bb, cfun)</span>
<span class="lineNum">    1541 </span>            :         {
<span class="lineNum">    1542 </span><span class="lineCov">    2012766 :           rtx_insn *insn;</span>
<span class="lineNum">    1543 </span>            : 
<span class="lineNum">    1544 </span><span class="lineCov">   50363536 :           FOR_BB_INSNS (bb, insn)</span>
<span class="lineNum">    1545 </span>            :             {
<span class="lineNum">    1546 </span><span class="lineCov">   24175385 :               rtx pat;</span>
<span class="lineNum">    1547 </span>            : 
<span class="lineNum">    1548 </span><span class="lineCov">   24175385 :               if (!INSN_P (insn))</span>
<span class="lineNum">    1549 </span>            :                 continue;
<span class="lineNum">    1550 </span>            : 
<span class="lineNum">    1551 </span><span class="lineCov">   21002981 :               pat = PATTERN (insn);</span>
<span class="lineNum">    1552 </span><span class="lineCov">   21002981 :               if (GET_CODE (pat) == CLOBBER)</span>
<span class="lineNum">    1553 </span><span class="lineCov">      64979 :                 resolve_clobber (pat, insn);</span>
<span class="lineNum">    1554 </span><span class="lineCov">   20938002 :               else if (GET_CODE (pat) == USE)</span>
<span class="lineNum">    1555 </span><span class="lineCov">      49772 :                 resolve_use (pat, insn);</span>
<span class="lineNum">    1556 </span><span class="lineCov">   20888230 :               else if (DEBUG_INSN_P (insn))</span>
<span class="lineNum">    1557 </span><span class="lineCov">    6420942 :                 resolve_debug (insn);</span>
<span class="lineNum">    1558 </span>            :               else
<span class="lineNum">    1559 </span>            :                 {
<span class="lineNum">    1560 </span><span class="lineCov">   14467288 :                   rtx set;</span>
<span class="lineNum">    1561 </span><span class="lineCov">   14467288 :                   int i;</span>
<span class="lineNum">    1562 </span>            : 
<span class="lineNum">    1563 </span><span class="lineCov">   14467288 :                   recog_memoized (insn);</span>
<span class="lineNum">    1564 </span><span class="lineCov">   14467288 :                   extract_insn (insn);</span>
<span class="lineNum">    1565 </span>            : 
<span class="lineNum">    1566 </span><span class="lineCov">   14467288 :                   set = simple_move (insn, speed_p);</span>
<span class="lineNum">    1567 </span><span class="lineCov">   14467288 :                   if (set)</span>
<span class="lineNum">    1568 </span>            :                     {
<span class="lineNum">    1569 </span><span class="lineCov">     861516 :                       rtx_insn *orig_insn = insn;</span>
<span class="lineNum">    1570 </span><span class="lineCov">     861516 :                       bool cfi = control_flow_insn_p (insn);</span>
<span class="lineNum">    1571 </span>            : 
<span class="lineNum">    1572 </span>            :                       /* We can end up splitting loads to multi-word pseudos
<span class="lineNum">    1573 </span>            :                          into separate loads to machine word size pseudos.
<span class="lineNum">    1574 </span>            :                          When this happens, we first had one load that can
<span class="lineNum">    1575 </span>            :                          throw, and after resolve_simple_move we'll have a
<span class="lineNum">    1576 </span>            :                          bunch of loads (at least two).  All those loads may
<span class="lineNum">    1577 </span>            :                          trap if we can have non-call exceptions, so they
<span class="lineNum">    1578 </span>            :                          all will end the current basic block.  We split the
<span class="lineNum">    1579 </span>            :                          block after the outer loop over all insns, but we
<span class="lineNum">    1580 </span>            :                          make sure here that we will be able to split the
<span class="lineNum">    1581 </span>            :                          basic block and still produce the correct control
<span class="lineNum">    1582 </span>            :                          flow graph for it.  */
<span class="lineNum">    1583 </span><span class="lineCov">     861516 :                       gcc_assert (!cfi</span>
<span class="lineNum">    1584 </span>            :                                   || (cfun-&gt;can_throw_non_call_exceptions
<span class="lineNum">    1585 </span>            :                                       &amp;&amp; can_throw_internal (insn)));
<span class="lineNum">    1586 </span>            : 
<span class="lineNum">    1587 </span><span class="lineCov">     861516 :                       insn = resolve_simple_move (set, insn);</span>
<span class="lineNum">    1588 </span><span class="lineCov">     861516 :                       if (insn != orig_insn)</span>
<span class="lineNum">    1589 </span>            :                         {
<span class="lineNum">    1590 </span><span class="lineCov">     439927 :                           recog_memoized (insn);</span>
<span class="lineNum">    1591 </span><span class="lineCov">     439927 :                           extract_insn (insn);</span>
<span class="lineNum">    1592 </span>            : 
<span class="lineNum">    1593 </span><span class="lineCov">     439927 :                           if (cfi)</span>
<span class="lineNum">    1594 </span><span class="lineCov">       6762 :                             bitmap_set_bit (sub_blocks, bb-&gt;index);</span>
<span class="lineNum">    1595 </span>            :                         }
<span class="lineNum">    1596 </span>            :                     }
<span class="lineNum">    1597 </span>            :                   else
<span class="lineNum">    1598 </span>            :                     {
<span class="lineNum">    1599 </span><span class="lineCov">   13605772 :                       rtx_insn *decomposed_shift;</span>
<span class="lineNum">    1600 </span>            : 
<span class="lineNum">    1601 </span><span class="lineCov">   13605772 :                       decomposed_shift = resolve_shift_zext (insn);</span>
<span class="lineNum">    1602 </span><span class="lineCov">   13605772 :                       if (decomposed_shift != NULL_RTX)</span>
<span class="lineNum">    1603 </span>            :                         {
<span class="lineNum">    1604 </span><span class="lineCov">      11752 :                           insn = decomposed_shift;</span>
<span class="lineNum">    1605 </span><span class="lineCov">      11752 :                           recog_memoized (insn);</span>
<span class="lineNum">    1606 </span><span class="lineCov">      11752 :                           extract_insn (insn);</span>
<span class="lineNum">    1607 </span>            :                         }
<span class="lineNum">    1608 </span>            :                     }
<span class="lineNum">    1609 </span>            : 
<span class="lineNum">    1610 </span><span class="lineCov">   45711207 :                   for (i = recog_data.n_operands - 1; i &gt;= 0; --i)</span>
<span class="lineNum">    1611 </span><span class="lineCov">   31243919 :                     resolve_subreg_use (recog_data.operand_loc[i], insn);</span>
<span class="lineNum">    1612 </span>            : 
<span class="lineNum">    1613 </span><span class="lineCov">   14467288 :                   resolve_reg_notes (insn);</span>
<span class="lineNum">    1614 </span>            : 
<span class="lineNum">    1615 </span><span class="lineCov">   14467288 :                   if (num_validated_changes () &gt; 0)</span>
<span class="lineNum">    1616 </span>            :                     {
<span class="lineNum">    1617 </span><span class="lineCov">     754337 :                       for (i = recog_data.n_dups - 1; i &gt;= 0; --i)</span>
<span class="lineNum">    1618 </span>            :                         {
<span class="lineNum">    1619 </span><span class="lineCov">        317 :                           rtx *pl = recog_data.dup_loc[i];</span>
<span class="lineNum">    1620 </span><span class="lineCov">        317 :                           int dup_num = recog_data.dup_num[i];</span>
<span class="lineNum">    1621 </span><span class="lineCov">        317 :                           rtx *px = recog_data.operand_loc[dup_num];</span>
<span class="lineNum">    1622 </span>            : 
<span class="lineNum">    1623 </span><span class="lineCov">        317 :                           validate_unshare_change (insn, pl, *px, 1);</span>
<span class="lineNum">    1624 </span>            :                         }
<span class="lineNum">    1625 </span>            : 
<span class="lineNum">    1626 </span><span class="lineCov">     754020 :                       i = apply_change_group ();</span>
<span class="lineNum">    1627 </span><span class="lineCov">     754020 :                       gcc_assert (i);</span>
<span class="lineNum">    1628 </span>            :                     }
<span class="lineNum">    1629 </span>            :                 }
<span class="lineNum">    1630 </span>            :             }
<span class="lineNum">    1631 </span>            :         }
<span class="lineNum">    1632 </span>            : 
<span class="lineNum">    1633 </span>            :       /* If we had insns to split that caused control flow insns in the middle
<span class="lineNum">    1634 </span>            :          of a basic block, split those blocks now.  Note that we only handle
<span class="lineNum">    1635 </span>            :          the case where splitting a load has caused multiple possibly trapping
<span class="lineNum">    1636 </span>            :          loads to appear.  */
<span class="lineNum">    1637 </span><span class="lineCov">     248913 :       EXECUTE_IF_SET_IN_BITMAP (sub_blocks, 0, i, sbi)</span>
<span class="lineNum">    1638 </span>            :         {
<span class="lineNum">    1639 </span><span class="lineCov">       3381 :           rtx_insn *insn, *end;</span>
<span class="lineNum">    1640 </span><span class="lineCov">       3381 :           edge fallthru;</span>
<span class="lineNum">    1641 </span>            : 
<span class="lineNum">    1642 </span><span class="lineCov">       3381 :           bb = BASIC_BLOCK_FOR_FN (cfun, i);</span>
<span class="lineNum">    1643 </span><span class="lineCov">       3381 :           insn = BB_HEAD (bb);</span>
<span class="lineNum">    1644 </span><span class="lineCov">       3381 :           end = BB_END (bb);</span>
<span class="lineNum">    1645 </span>            : 
<span class="lineNum">    1646 </span><span class="lineCov">      19985 :           while (insn != end)</span>
<span class="lineNum">    1647 </span>            :             {
<span class="lineNum">    1648 </span><span class="lineCov">      16604 :               if (control_flow_insn_p (insn))</span>
<span class="lineNum">    1649 </span>            :                 {
<span class="lineNum">    1650 </span>            :                   /* Split the block after insn.  There will be a fallthru
<span class="lineNum">    1651 </span>            :                      edge, which is OK so we keep it.  We have to create the
<span class="lineNum">    1652 </span>            :                      exception edges ourselves.  */
<span class="lineNum">    1653 </span><span class="lineCov">       3381 :                   fallthru = split_block (bb, insn);</span>
<span class="lineNum">    1654 </span><span class="lineCov">       3381 :                   rtl_make_eh_edge (NULL, bb, BB_END (bb));</span>
<span class="lineNum">    1655 </span><span class="lineCov">       3381 :                   bb = fallthru-&gt;dest;</span>
<span class="lineNum">    1656 </span><span class="lineCov">       3381 :                   insn = BB_HEAD (bb);</span>
<span class="lineNum">    1657 </span>            :                 }
<span class="lineNum">    1658 </span>            :               else
<span class="lineNum">    1659 </span><span class="lineCov">      26446 :                 insn = NEXT_INSN (insn);</span>
<span class="lineNum">    1660 </span>            :             }
<span class="lineNum">    1661 </span>            :         }
<span class="lineNum">    1662 </span>            :     }
<span class="lineNum">    1663 </span>            : 
<span class="lineNum">    1664 </span>            :   {
<span class="lineNum">    1665 </span>            :     unsigned int i;
<span class="lineNum">    1666 </span>            :     bitmap b;
<span class="lineNum">    1667 </span>            : 
<span class="lineNum">    1668 </span><span class="lineCov">   30557080 :     FOR_EACH_VEC_ELT (reg_copy_graph, i, b)</span>
<span class="lineNum">    1669 </span><span class="lineCov">   30368820 :       if (b)</span>
<span class="lineNum">    1670 </span><span class="lineCov">     169511 :         BITMAP_FREE (b);</span>
<span class="lineNum">    1671 </span>            :   }
<span class="lineNum">    1672 </span>            : 
<span class="lineNum">    1673 </span><span class="lineCov">     188260 :   reg_copy_graph.release ();</span>
<span class="lineNum">    1674 </span>            : 
<span class="lineNum">    1675 </span><span class="lineCov">     188260 :   BITMAP_FREE (decomposable_context);</span>
<span class="lineNum">    1676 </span><span class="lineCov">     188260 :   BITMAP_FREE (non_decomposable_context);</span>
<span class="lineNum">    1677 </span><span class="lineCov">     188260 :   BITMAP_FREE (subreg_context);</span>
<span class="lineNum">    1678 </span>            : }
<span class="lineNum">    1679 </span>            : 
<span class="lineNum">    1680 </span>            : /* Implement first lower subreg pass.  */
<span class="lineNum">    1681 </span>            : 
<span class="lineNum">    1682 </span>            : namespace {
<span class="lineNum">    1683 </span>            : 
<span class="lineNum">    1684 </span>            : const pass_data pass_data_lower_subreg =
<span class="lineNum">    1685 </span>            : {
<span class="lineNum">    1686 </span>            :   RTL_PASS, /* type */
<span class="lineNum">    1687 </span>            :   &quot;subreg1&quot;, /* name */
<span class="lineNum">    1688 </span>            :   OPTGROUP_NONE, /* optinfo_flags */
<span class="lineNum">    1689 </span>            :   TV_LOWER_SUBREG, /* tv_id */
<span class="lineNum">    1690 </span>            :   0, /* properties_required */
<span class="lineNum">    1691 </span>            :   0, /* properties_provided */
<span class="lineNum">    1692 </span>            :   0, /* properties_destroyed */
<span class="lineNum">    1693 </span>            :   0, /* todo_flags_start */
<span class="lineNum">    1694 </span>            :   0, /* todo_flags_finish */
<span class="lineNum">    1695 </span>            : };
<span class="lineNum">    1696 </span>            : 
<span class="lineNum">    1697 </span>            : class pass_lower_subreg : public rtl_opt_pass
<span class="lineNum">    1698 </span>            : {
<span class="lineNum">    1699 </span>            : public:
<span class="lineNum">    1700 </span>            :   pass_lower_subreg (gcc::context *ctxt)
<span class="lineNum">    1701 </span><span class="lineCov">     340624 :     : rtl_opt_pass (pass_data_lower_subreg, ctxt)</span>
<span class="lineNum">    1702 </span>            :   {}
<a name="1703"><span class="lineNum">    1703 </span>            : </a>
<a name="1704"><span class="lineNum">    1704 </span>            :   /* opt_pass methods: */</a>
<span class="lineNum">    1705 </span><span class="lineCov">     832594 :   virtual bool gate (function *) { return flag_split_wide_types != 0; }</span>
<span class="lineNum">    1706 </span><span class="lineCov">     622455 :   virtual unsigned int execute (function *)</span>
<span class="lineNum">    1707 </span>            :     {
<span class="lineNum">    1708 </span><span class="lineCov">     622455 :       decompose_multiword_subregs (false);</span>
<span class="lineNum">    1709 </span><span class="lineCov">     622455 :       return 0;</span>
<span class="lineNum">    1710 </span>            :     }
<span class="lineNum">    1711 </span>            : 
<span class="lineNum">    1712 </span>            : }; // class pass_lower_subreg
<span class="lineNum">    1713 </span>            : 
<span class="lineNum">    1714 </span>            : } // anon namespace
<a name="1715"><span class="lineNum">    1715 </span>            : </a>
<span class="lineNum">    1716 </span>            : rtl_opt_pass *
<span class="lineNum">    1717 </span><span class="lineCov">     170312 : make_pass_lower_subreg (gcc::context *ctxt)</span>
<span class="lineNum">    1718 </span>            : {
<span class="lineNum">    1719 </span><span class="lineCov">     170312 :   return new pass_lower_subreg (ctxt);</span>
<span class="lineNum">    1720 </span>            : }
<span class="lineNum">    1721 </span>            : 
<span class="lineNum">    1722 </span>            : /* Implement second lower subreg pass.  */
<span class="lineNum">    1723 </span>            : 
<span class="lineNum">    1724 </span>            : namespace {
<span class="lineNum">    1725 </span>            : 
<span class="lineNum">    1726 </span>            : const pass_data pass_data_lower_subreg2 =
<span class="lineNum">    1727 </span>            : {
<span class="lineNum">    1728 </span>            :   RTL_PASS, /* type */
<span class="lineNum">    1729 </span>            :   &quot;subreg2&quot;, /* name */
<span class="lineNum">    1730 </span>            :   OPTGROUP_NONE, /* optinfo_flags */
<span class="lineNum">    1731 </span>            :   TV_LOWER_SUBREG, /* tv_id */
<span class="lineNum">    1732 </span>            :   0, /* properties_required */
<span class="lineNum">    1733 </span>            :   0, /* properties_provided */
<span class="lineNum">    1734 </span>            :   0, /* properties_destroyed */
<span class="lineNum">    1735 </span>            :   0, /* todo_flags_start */
<span class="lineNum">    1736 </span>            :   TODO_df_finish, /* todo_flags_finish */
<span class="lineNum">    1737 </span>            : };
<span class="lineNum">    1738 </span>            : 
<span class="lineNum">    1739 </span>            : class pass_lower_subreg2 : public rtl_opt_pass
<span class="lineNum">    1740 </span>            : {
<span class="lineNum">    1741 </span>            : public:
<span class="lineNum">    1742 </span>            :   pass_lower_subreg2 (gcc::context *ctxt)
<span class="lineNum">    1743 </span><span class="lineCov">     340624 :     : rtl_opt_pass (pass_data_lower_subreg2, ctxt)</span>
<span class="lineNum">    1744 </span>            :   {}
<a name="1745"><span class="lineNum">    1745 </span>            : </a>
<a name="1746"><span class="lineNum">    1746 </span>            :   /* opt_pass methods: */</a>
<span class="lineNum">    1747 </span><span class="lineCov">     832594 :   virtual bool gate (function *) { return flag_split_wide_types != 0; }</span>
<span class="lineNum">    1748 </span><span class="lineCov">     622456 :   virtual unsigned int execute (function *)</span>
<span class="lineNum">    1749 </span>            :     {
<span class="lineNum">    1750 </span><span class="lineCov">     622456 :       decompose_multiword_subregs (true);</span>
<span class="lineNum">    1751 </span><span class="lineCov">     622456 :       return 0;</span>
<span class="lineNum">    1752 </span>            :     }
<span class="lineNum">    1753 </span>            : 
<span class="lineNum">    1754 </span>            : }; // class pass_lower_subreg2
<span class="lineNum">    1755 </span>            : 
<span class="lineNum">    1756 </span>            : } // anon namespace
<a name="1757"><span class="lineNum">    1757 </span>            : </a>
<span class="lineNum">    1758 </span>            : rtl_opt_pass *
<span class="lineNum">    1759 </span><span class="lineCov">     170312 : make_pass_lower_subreg2 (gcc::context *ctxt)</span>
<span class="lineNum">    1760 </span>            : {
<span class="lineNum">    1761 </span><span class="lineCov">     170312 :   return new pass_lower_subreg2 (ctxt);</span>
<span class="lineNum">    1762 </span>            : }
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.0</a></td></tr>
  </table>
  <br>
<h3>LCOV profile is generated on x86_64 machine using following configure options: configure --disable-bootstrap --enable-coverage=opt --enable-languages=c,c++,fortran,go,jit,lto --enable-host-shared. GCC test suite is run with the built compiler.</h3></body></html>
