<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - gcc.info - gcc/opt-suggestions.c</title>
  <link rel="stylesheet" type="text/css" href="../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../index.html">top level</a> - <a href="index.html">gcc</a> - opt-suggestions.c<span style="font-size: 80%;"> (source / <a href="opt-suggestions.c.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">gcc.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">138</td>
            <td class="headerCovTableEntry">138</td>
            <td class="headerCovTableEntryHi">100.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2018-09-22 10:58:49</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">14</td>
            <td class="headerCovTableEntry">14</td>
            <td class="headerCovTableEntryHi">100.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /* Provide option suggestion for --complete option and a misspelled</a>
<span class="lineNum">       2 </span>            :    used by a user.
<span class="lineNum">       3 </span>            :    Copyright (C) 2016-2018 Free Software Foundation, Inc.
<span class="lineNum">       4 </span>            : 
<span class="lineNum">       5 </span>            : This file is part of GCC.
<span class="lineNum">       6 </span>            : 
<span class="lineNum">       7 </span>            : GCC is free software; you can redistribute it and/or modify it under
<span class="lineNum">       8 </span>            : the terms of the GNU General Public License as published by the Free
<span class="lineNum">       9 </span>            : Software Foundation; either version 3, or (at your option) any later
<span class="lineNum">      10 </span>            : version.
<span class="lineNum">      11 </span>            : 
<span class="lineNum">      12 </span>            : GCC is distributed in the hope that it will be useful, but WITHOUT ANY
<span class="lineNum">      13 </span>            : WARRANTY; without even the implied warranty of MERCHANTABILITY or
<span class="lineNum">      14 </span>            : FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
<span class="lineNum">      15 </span>            : for more details.
<span class="lineNum">      16 </span>            : 
<span class="lineNum">      17 </span>            : You should have received a copy of the GNU General Public License
<span class="lineNum">      18 </span>            : along with GCC; see the file COPYING3.  If not see
<span class="lineNum">      19 </span>            : &lt;http://www.gnu.org/licenses/&gt;.  */
<span class="lineNum">      20 </span>            : 
<span class="lineNum">      21 </span>            : #include &quot;config.h&quot;
<span class="lineNum">      22 </span>            : #include &quot;system.h&quot;
<span class="lineNum">      23 </span>            : #include &quot;coretypes.h&quot;
<span class="lineNum">      24 </span>            : #include &quot;tm.h&quot;
<span class="lineNum">      25 </span>            : #include &quot;opts.h&quot;
<span class="lineNum">      26 </span>            : #include &quot;params.h&quot;
<span class="lineNum">      27 </span>            : #include &quot;spellcheck.h&quot;
<span class="lineNum">      28 </span>            : #include &quot;opt-suggestions.h&quot;
<span class="lineNum">      29 </span>            : #include &quot;common/common-target.h&quot;
<a name="30"><span class="lineNum">      30 </span>            : #include &quot;selftest.h&quot;</a>
<span class="lineNum">      31 </span>            : 
<span class="lineNum">      32 </span><span class="lineCov">     343070 : option_proposer::~option_proposer ()</span>
<span class="lineNum">      33 </span>            : {
<span class="lineNum">      34 </span><span class="lineCov">     171535 :   delete m_option_suggestions;</span>
<span class="lineNum">      35 </span><span class="lineCov">     171535 : }</span>
<a name="36"><span class="lineNum">      36 </span>            : </a>
<span class="lineNum">      37 </span>            : const char *
<span class="lineNum">      38 </span><span class="lineCov">        321 : option_proposer::suggest_option (const char *bad_opt)</span>
<span class="lineNum">      39 </span>            : {
<span class="lineNum">      40 </span>            :   /* Lazily populate m_option_suggestions.  */
<span class="lineNum">      41 </span><span class="lineCov">        321 :   if (!m_option_suggestions)</span>
<span class="lineNum">      42 </span><span class="lineCov">        316 :     build_option_suggestions (NULL);</span>
<span class="lineNum">      43 </span><span class="lineCov">        321 :   gcc_assert (m_option_suggestions);</span>
<span class="lineNum">      44 </span>            : 
<span class="lineNum">      45 </span>            :   /* &quot;m_option_suggestions&quot; is now populated.  Use it.  */
<span class="lineNum">      46 </span><span class="lineCov">        321 :   return find_closest_string</span>
<span class="lineNum">      47 </span><span class="lineCov">        321 :     (bad_opt,</span>
<span class="lineNum">      48 </span><span class="lineCov">        321 :      (auto_vec &lt;const char *&gt; *) m_option_suggestions);</span>
<span class="lineNum">      49 </span>            : }
<span class="lineNum">      50 </span>            : 
<span class="lineNum">      51 </span>            : /* Populate RESULTS with valid completions of options that begin
<span class="lineNum">      52 </span>            :    with OPTION_PREFIX.  */
<span class="lineNum">      53 </span>            : 
<span class="lineNum">      54 </span>            : void
<span class="lineNum">      55 </span><span class="lineCov">        101 : option_proposer::get_completions (const char *option_prefix,</span>
<span class="lineNum">      56 </span>            :                                   auto_string_vec &amp;results)
<span class="lineNum">      57 </span>            : {
<span class="lineNum">      58 </span>            :   /* Bail out for an invalid input.  */
<span class="lineNum">      59 </span><span class="lineCov">        101 :   if (option_prefix == NULL || option_prefix[0] == '\0')</span>
<span class="lineNum">      60 </span>            :     return;
<span class="lineNum">      61 </span>            : 
<span class="lineNum">      62 </span>            :   /* Option suggestions are built without first leading dash character.  */
<span class="lineNum">      63 </span><span class="lineCov">         99 :   if (option_prefix[0] == '-')</span>
<span class="lineNum">      64 </span><span class="lineCov">         97 :     option_prefix++;</span>
<span class="lineNum">      65 </span>            : 
<span class="lineNum">      66 </span><span class="lineCov">         99 :   size_t length = strlen (option_prefix);</span>
<span class="lineNum">      67 </span>            : 
<span class="lineNum">      68 </span>            :   /* Handle OPTION_PREFIX starting with &quot;-param&quot;.  */
<span class="lineNum">      69 </span><span class="lineCov">         99 :   const char *prefix = &quot;-param&quot;;</span>
<span class="lineNum">      70 </span><span class="lineCov">         99 :   if (length &gt;= strlen (prefix)</span>
<span class="lineNum">      71 </span><span class="lineCov">        186 :       &amp;&amp; strstr (option_prefix, prefix) == option_prefix)</span>
<span class="lineNum">      72 </span>            :     {
<span class="lineNum">      73 </span>            :       /* We support both '-param-xyz=123' and '-param xyz=123' */
<span class="lineNum">      74 </span><span class="lineCov">         40 :       option_prefix += strlen (prefix);</span>
<span class="lineNum">      75 </span><span class="lineCov">         40 :       char separator = option_prefix[0];</span>
<span class="lineNum">      76 </span><span class="lineCov">         40 :       option_prefix++;</span>
<span class="lineNum">      77 </span><span class="lineCov">         40 :       if (separator == ' ' || separator == '=')</span>
<span class="lineNum">      78 </span><span class="lineCov">         40 :         find_param_completions (separator, option_prefix, results);</span>
<span class="lineNum">      79 </span>            :     }
<span class="lineNum">      80 </span>            :   else
<span class="lineNum">      81 </span>            :     {
<span class="lineNum">      82 </span>            :       /* Lazily populate m_option_suggestions.  */
<span class="lineNum">      83 </span><span class="lineCov">         59 :       if (!m_option_suggestions)</span>
<span class="lineNum">      84 </span><span class="lineCov">          4 :         build_option_suggestions (option_prefix);</span>
<span class="lineNum">      85 </span><span class="lineCov">         59 :       gcc_assert (m_option_suggestions);</span>
<span class="lineNum">      86 </span>            : 
<span class="lineNum">      87 </span><span class="lineCov">     607346 :       for (unsigned i = 0; i &lt; m_option_suggestions-&gt;length (); i++)</span>
<span class="lineNum">      88 </span>            :         {
<span class="lineNum">      89 </span><span class="lineCov">     303614 :           char *candidate = (*m_option_suggestions)[i];</span>
<span class="lineNum">      90 </span><span class="lineCov">     303614 :           if (strlen (candidate) &gt;= length</span>
<span class="lineNum">      91 </span><span class="lineCov">     405500 :               &amp;&amp; strstr (candidate, option_prefix) == candidate)</span>
<span class="lineNum">      92 </span><span class="lineCov">       5357 :             results.safe_push (concat (&quot;-&quot;, candidate, NULL));</span>
<span class="lineNum">      93 </span>            :         }
<span class="lineNum">      94 </span>            :     }
<span class="lineNum">      95 </span>            : }
<span class="lineNum">      96 </span>            : 
<span class="lineNum">      97 </span>            : /* Print on stdout a list of valid options that begin with OPTION_PREFIX,
<span class="lineNum">      98 </span>            :    one per line, suitable for use by Bash completion.
<span class="lineNum">      99 </span>            : 
<span class="lineNum">     100 </span>            :    Implementation of the &quot;-completion=&quot; option.  */
<span class="lineNum">     101 </span>            : 
<span class="lineNum">     102 </span>            : void
<span class="lineNum">     103 </span><span class="lineCov">          4 : option_proposer::suggest_completion (const char *option_prefix)</span>
<span class="lineNum">     104 </span>            : {
<span class="lineNum">     105 </span><span class="lineCov">          8 :   auto_string_vec results;</span>
<span class="lineNum">     106 </span><span class="lineCov">          4 :   get_completions (option_prefix, results);</span>
<span class="lineNum">     107 </span><span class="lineCov">         42 :   for (unsigned i = 0; i &lt; results.length (); i++)</span>
<span class="lineNum">     108 </span><span class="lineCov">         17 :     printf (&quot;%s\n&quot;, results[i]);</span>
<span class="lineNum">     109 </span><span class="lineCov">          4 : }</span>
<span class="lineNum">     110 </span>            : 
<span class="lineNum">     111 </span>            : void
<span class="lineNum">     112 </span><span class="lineCov">        320 : option_proposer::build_option_suggestions (const char *prefix)</span>
<span class="lineNum">     113 </span>            : {
<span class="lineNum">     114 </span><span class="lineCov">        320 :   gcc_assert (m_option_suggestions == NULL);</span>
<span class="lineNum">     115 </span><span class="lineCov">        320 :   m_option_suggestions = new auto_string_vec ();</span>
<span class="lineNum">     116 </span>            : 
<span class="lineNum">     117 </span>            :   /* We build a vec of m_option_suggestions, using add_misspelling_candidates
<span class="lineNum">     118 </span>            :      to add copies of strings, without a leading dash.  */
<span class="lineNum">     119 </span>            : 
<span class="lineNum">     120 </span><span class="lineCov">     482240 :   for (unsigned int i = 0; i &lt; cl_options_count; i++)</span>
<span class="lineNum">     121 </span>            :     {
<span class="lineNum">     122 </span><span class="lineCov">     481920 :       const struct cl_option *option = &amp;cl_options[i];</span>
<span class="lineNum">     123 </span><span class="lineCov">     481920 :       const char *opt_text = option-&gt;opt_text;</span>
<span class="lineNum">     124 </span><span class="lineCov">     481920 :       switch (i)</span>
<span class="lineNum">     125 </span>            :         {
<span class="lineNum">     126 </span><span class="lineCov">     481280 :         default:</span>
<span class="lineNum">     127 </span><span class="lineCov">     481280 :           if (option-&gt;var_type == CLVC_ENUM)</span>
<span class="lineNum">     128 </span>            :             {
<span class="lineNum">     129 </span><span class="lineCov">      13440 :               const struct cl_enum *e = &amp;cl_enums[option-&gt;var_enum];</span>
<span class="lineNum">     130 </span><span class="lineCov">      58560 :               for (unsigned j = 0; e-&gt;values[j].arg != NULL; j++)</span>
<span class="lineNum">     131 </span>            :                 {
<span class="lineNum">     132 </span><span class="lineCov">      45120 :                   char *with_arg = concat (opt_text, e-&gt;values[j].arg, NULL);</span>
<span class="lineNum">     133 </span><span class="lineCov">      45120 :                   add_misspelling_candidates (m_option_suggestions, option,</span>
<span class="lineNum">     134 </span>            :                                               with_arg);
<span class="lineNum">     135 </span><span class="lineCov">      45120 :                   free (with_arg);</span>
<span class="lineNum">     136 </span>            :                 }
<span class="lineNum">     137 </span>            :             }
<span class="lineNum">     138 </span>            :           else
<span class="lineNum">     139 </span>            :             {
<span class="lineNum">     140 </span><span class="lineCov">     467840 :               if (option-&gt;flags &amp; CL_TARGET)</span>
<span class="lineNum">     141 </span>            :                 {
<span class="lineNum">     142 </span><span class="lineCov">      53120 :                   vec&lt;const char *&gt; option_values</span>
<span class="lineNum">     143 </span><span class="lineCov">      53120 :                     = targetm_common.get_valid_option_values (i, prefix);</span>
<span class="lineNum">     144 </span><span class="lineCov">      53120 :                   if (!option_values.is_empty ())</span>
<span class="lineNum">     145 </span>            :                     {
<span class="lineNum">     146 </span><span class="lineCov">      79360 :                       for (unsigned j = 0; j &lt; option_values.length (); j++)</span>
<span class="lineNum">     147 </span>            :                         {
<span class="lineNum">     148 </span><span class="lineCov">      78080 :                           char *with_arg = concat (opt_text, option_values[j],</span>
<span class="lineNum">     149 </span>            :                                                    NULL);
<span class="lineNum">     150 </span><span class="lineCov">      39040 :                           add_misspelling_candidates (m_option_suggestions, option,</span>
<span class="lineNum">     151 </span>            :                                                       with_arg);
<span class="lineNum">     152 </span><span class="lineCov">      39040 :                           free (with_arg);</span>
<span class="lineNum">     153 </span>            :                         }
<span class="lineNum">     154 </span>            :                     }
<span class="lineNum">     155 </span>            :                 }
<span class="lineNum">     156 </span>            :               else
<span class="lineNum">     157 </span><span class="lineCov">     414720 :                 add_misspelling_candidates (m_option_suggestions, option,</span>
<span class="lineNum">     158 </span>            :                                             opt_text);
<span class="lineNum">     159 </span>            :             }
<span class="lineNum">     160 </span>            :           break;
<span class="lineNum">     161 </span>            : 
<span class="lineNum">     162 </span>            :         case OPT_fsanitize_:
<span class="lineNum">     163 </span>            :         case OPT_fsanitize_recover_:
<span class="lineNum">     164 </span>            :           /* -fsanitize= and -fsanitize-recover= can take
<span class="lineNum">     165 </span>            :              a comma-separated list of arguments.  Given that combinations
<span class="lineNum">     166 </span>            :              are supported, we can't add all potential candidates to the
<span class="lineNum">     167 </span>            :              vec, but if we at least add them individually without commas,
<span class="lineNum">     168 </span>            :              we should do a better job e.g. correcting
<span class="lineNum">     169 </span>            :                &quot;-sanitize=address&quot;
<span class="lineNum">     170 </span>            :              to
<span class="lineNum">     171 </span>            :                &quot;-fsanitize=address&quot;
<span class="lineNum">     172 </span>            :              rather than to &quot;-Wframe-address&quot; (PR driver/69265).  */
<span class="lineNum">     173 </span>            :           {
<span class="lineNum">     174 </span><span class="lineCov">      19840 :             for (int j = 0; sanitizer_opts[j].name != NULL; ++j)</span>
<span class="lineNum">     175 </span>            :               {
<span class="lineNum">     176 </span><span class="lineCov">      19200 :                 struct cl_option optb;</span>
<span class="lineNum">     177 </span>            :                 /* -fsanitize=all is not valid, only -fno-sanitize=all.
<span class="lineNum">     178 </span>            :                    So don't register the positive misspelling candidates
<span class="lineNum">     179 </span>            :                    for it.  */
<span class="lineNum">     180 </span><span class="lineCov">      19200 :                 if (sanitizer_opts[j].flag == ~0U &amp;&amp; i == OPT_fsanitize_)</span>
<span class="lineNum">     181 </span>            :                   {
<span class="lineNum">     182 </span><span class="lineCov">        320 :                     optb = *option;</span>
<span class="lineNum">     183 </span><span class="lineCov">        320 :                     optb.opt_text = opt_text = &quot;-fno-sanitize=&quot;;</span>
<span class="lineNum">     184 </span><span class="lineCov">        320 :                     optb.cl_reject_negative = true;</span>
<span class="lineNum">     185 </span><span class="lineCov">        320 :                     option = &amp;optb;</span>
<span class="lineNum">     186 </span>            :                   }
<span class="lineNum">     187 </span>            :                 /* Get one arg at a time e.g. &quot;-fsanitize=address&quot;.  */
<span class="lineNum">     188 </span><span class="lineCov">      19200 :                 char *with_arg = concat (opt_text,</span>
<span class="lineNum">     189 </span>            :                                          sanitizer_opts[j].name,
<span class="lineNum">     190 </span>            :                                          NULL);
<span class="lineNum">     191 </span>            :                 /* Add with_arg and all of its variant spellings e.g.
<span class="lineNum">     192 </span>            :                    &quot;-fno-sanitize=address&quot; to candidates (albeit without
<span class="lineNum">     193 </span>            :                    leading dashes).  */
<span class="lineNum">     194 </span><span class="lineCov">      19200 :                 add_misspelling_candidates (m_option_suggestions, option,</span>
<span class="lineNum">     195 </span>            :                                             with_arg);
<span class="lineNum">     196 </span><span class="lineCov">      19200 :                 free (with_arg);</span>
<span class="lineNum">     197 </span><span class="lineCov">        640 :               }</span>
<span class="lineNum">     198 </span>            :           }
<span class="lineNum">     199 </span>            :           break;
<span class="lineNum">     200 </span>            :         }
<span class="lineNum">     201 </span>            :     }
<span class="lineNum">     202 </span><span class="lineCov">        320 : }</span>
<span class="lineNum">     203 </span>            : 
<span class="lineNum">     204 </span>            : /* Find parameter completions for --param format with SEPARATOR.
<span class="lineNum">     205 </span>            :    Again, save the completions into results.  */
<a name="206"><span class="lineNum">     206 </span>            : </a>
<span class="lineNum">     207 </span>            : void
<span class="lineNum">     208 </span><span class="lineCov">         40 : option_proposer::find_param_completions (const char separator,</span>
<span class="lineNum">     209 </span>            :                                          const char *param_prefix,
<span class="lineNum">     210 </span>            :                                          auto_string_vec &amp;results)
<span class="lineNum">     211 </span>            : {
<span class="lineNum">     212 </span><span class="lineCov">         40 :   char separator_str[] = {separator, '\0'};</span>
<span class="lineNum">     213 </span><span class="lineCov">         40 :   size_t length = strlen (param_prefix);</span>
<span class="lineNum">     214 </span><span class="lineCov">       8440 :   for (unsigned i = 0; i &lt; get_num_compiler_params (); ++i)</span>
<span class="lineNum">     215 </span>            :     {
<span class="lineNum">     216 </span><span class="lineCov">       8400 :       const char *candidate = compiler_params[i].option;</span>
<span class="lineNum">     217 </span><span class="lineCov">       8400 :       if (strlen (candidate) &gt;= length</span>
<span class="lineNum">     218 </span><span class="lineCov">       9832 :           &amp;&amp; strstr (candidate, param_prefix) == candidate)</span>
<span class="lineNum">     219 </span><span class="lineCov">        466 :         results.safe_push (concat (&quot;--param&quot;, separator_str, candidate, NULL));</span>
<span class="lineNum">     220 </span>            :     }
<span class="lineNum">     221 </span><span class="lineCov">         40 : }</span>
<span class="lineNum">     222 </span>            : 
<span class="lineNum">     223 </span>            : #if CHECKING_P
<span class="lineNum">     224 </span>            : 
<span class="lineNum">     225 </span>            : namespace selftest {
<span class="lineNum">     226 </span>            : 
<span class="lineNum">     227 </span>            : /* Verify that PROPOSER generates sane auto-completion suggestions
<span class="lineNum">     228 </span>            :    for OPTION_PREFIX.  */
<span class="lineNum">     229 </span>            : 
<span class="lineNum">     230 </span>            : static void
<span class="lineNum">     231 </span><span class="lineCov">         78 : verify_autocompletions (option_proposer &amp;proposer, const char *option_prefix)</span>
<span class="lineNum">     232 </span>            : {
<span class="lineNum">     233 </span><span class="lineCov">        156 :   auto_string_vec suggestions;</span>
<span class="lineNum">     234 </span><span class="lineCov">         78 :   proposer.get_completions (option_prefix, suggestions);</span>
<span class="lineNum">     235 </span>            : 
<span class="lineNum">     236 </span>            :   /* There must be at least one suggestion, and every suggestion must
<span class="lineNum">     237 </span>            :      indeed begin with OPTION_PREFIX.  */
<span class="lineNum">     238 </span>            : 
<span class="lineNum">     239 </span><span class="lineCov">         78 :   ASSERT_GT (suggestions.length (), 0);</span>
<span class="lineNum">     240 </span>            : 
<span class="lineNum">     241 </span><span class="lineCov">        322 :   for (unsigned i = 0; i &lt; suggestions.length (); i++)</span>
<span class="lineNum">     242 </span><span class="lineCov">         83 :     ASSERT_STR_STARTSWITH (suggestions[i], option_prefix);</span>
<span class="lineNum">     243 </span><span class="lineCov">         78 : }</span>
<span class="lineNum">     244 </span>            : 
<span class="lineNum">     245 </span>            : /* Verify that valid options are auto-completed correctly.  */
<a name="246"><span class="lineNum">     246 </span>            : </a>
<span class="lineNum">     247 </span>            : static void
<span class="lineNum">     248 </span><span class="lineCov">          1 : test_completion_valid_options (option_proposer &amp;proposer)</span>
<span class="lineNum">     249 </span>            : {
<span class="lineNum">     250 </span><span class="lineCov">          1 :   const char *option_prefixes[] =</span>
<span class="lineNum">     251 </span>            :   {
<span class="lineNum">     252 </span>            :     &quot;-fno-var-tracking-assignments-toggle&quot;,
<span class="lineNum">     253 </span>            :     &quot;-fpredictive-commoning&quot;,
<span class="lineNum">     254 </span>            :     &quot;--param=stack-clash-protection-guard-size&quot;,
<span class="lineNum">     255 </span>            :     &quot;--param=max-predicted-iterations&quot;,
<span class="lineNum">     256 </span>            :     &quot;-ftree-loop-distribute-patterns&quot;,
<span class="lineNum">     257 </span>            :     &quot;-fno-var-tracking&quot;,
<span class="lineNum">     258 </span>            :     &quot;-Walloc-zero&quot;,
<span class="lineNum">     259 </span>            :     &quot;--param=ipa-cp-value-list-size&quot;,
<span class="lineNum">     260 </span>            :     &quot;-Wsync-nand&quot;,
<span class="lineNum">     261 </span>            :     &quot;-Wno-attributes&quot;,
<span class="lineNum">     262 </span>            :     &quot;--param=tracer-dynamic-coverage-feedback&quot;,
<span class="lineNum">     263 </span>            :     &quot;-Wno-format-contains-nul&quot;,
<span class="lineNum">     264 </span>            :     &quot;-Wnamespaces&quot;,
<span class="lineNum">     265 </span>            :     &quot;-fisolate-erroneous-paths-attribute&quot;,
<span class="lineNum">     266 </span>            :     &quot;-Wno-underflow&quot;,
<span class="lineNum">     267 </span>            :     &quot;-Wtarget-lifetime&quot;,
<span class="lineNum">     268 </span>            :     &quot;--param=asan-globals&quot;,
<span class="lineNum">     269 </span>            :     &quot;-Wno-empty-body&quot;,
<span class="lineNum">     270 </span>            :     &quot;-Wno-odr&quot;,
<span class="lineNum">     271 </span>            :     &quot;-Wformat-zero-length&quot;,
<span class="lineNum">     272 </span>            :     &quot;-Wstringop-truncation&quot;,
<span class="lineNum">     273 </span>            :     &quot;-fno-ipa-vrp&quot;,
<span class="lineNum">     274 </span>            :     &quot;-fmath-errno&quot;,
<span class="lineNum">     275 </span>            :     &quot;-Warray-temporaries&quot;,
<span class="lineNum">     276 </span>            :     &quot;-Wno-unused-label&quot;,
<span class="lineNum">     277 </span>            :     &quot;-Wreturn-local-addr&quot;,
<span class="lineNum">     278 </span>            :     &quot;--param=sms-dfa-history&quot;,
<span class="lineNum">     279 </span>            :     &quot;--param=asan-instrument-reads&quot;,
<span class="lineNum">     280 </span>            :     &quot;-Wreturn-type&quot;,
<span class="lineNum">     281 </span>            :     &quot;-Wc++17-compat&quot;,
<span class="lineNum">     282 </span>            :     &quot;-Wno-effc++&quot;,
<span class="lineNum">     283 </span>            :     &quot;--param=max-fields-for-field-sensitive&quot;,
<span class="lineNum">     284 </span>            :     &quot;-fisolate-erroneous-paths-dereference&quot;,
<span class="lineNum">     285 </span>            :     &quot;-fno-defer-pop&quot;,
<span class="lineNum">     286 </span>            :     &quot;-Wcast-align=strict&quot;,
<span class="lineNum">     287 </span>            :     &quot;-foptimize-strlen&quot;,
<span class="lineNum">     288 </span>            :     &quot;-Wpacked-not-aligned&quot;,
<span class="lineNum">     289 </span>            :     &quot;-funroll-loops&quot;,
<span class="lineNum">     290 </span>            :     &quot;-fif-conversion2&quot;,
<span class="lineNum">     291 </span>            :     &quot;-Wdesignated-init&quot;,
<span class="lineNum">     292 </span>            :     &quot;--param=max-iterations-computation-cost&quot;,
<span class="lineNum">     293 </span>            :     &quot;-Wmultiple-inheritance&quot;,
<span class="lineNum">     294 </span>            :     &quot;-fno-sel-sched-reschedule-pipelined&quot;,
<span class="lineNum">     295 </span>            :     &quot;-Wassign-intercept&quot;,
<span class="lineNum">     296 </span>            :     &quot;-Wno-format-security&quot;,
<span class="lineNum">     297 </span>            :     &quot;-fno-sched-stalled-insns&quot;,
<span class="lineNum">     298 </span>            :     &quot;-fbtr-bb-exclusive&quot;,
<span class="lineNum">     299 </span>            :     &quot;-fno-tree-tail-merge&quot;,
<span class="lineNum">     300 </span>            :     &quot;-Wlong-long&quot;,
<span class="lineNum">     301 </span>            :     &quot;-Wno-unused-but-set-parameter&quot;,
<span class="lineNum">     302 </span>            :     NULL
<span class="lineNum">     303 </span>            :   };
<span class="lineNum">     304 </span>            : 
<span class="lineNum">     305 </span><span class="lineCov">         51 :   for (const char **ptr = option_prefixes; *ptr != NULL; ptr++)</span>
<span class="lineNum">     306 </span><span class="lineCov">         50 :     verify_autocompletions (proposer, *ptr);</span>
<span class="lineNum">     307 </span><span class="lineCov">          1 : }</span>
<span class="lineNum">     308 </span>            : 
<span class="lineNum">     309 </span>            : /* Verify that valid parameters are auto-completed correctly,
<span class="lineNum">     310 </span>            :    both with the &quot;--param=PARAM&quot; form and the &quot;--param PARAM&quot; form.  */
<a name="311"><span class="lineNum">     311 </span>            : </a>
<span class="lineNum">     312 </span>            : static void
<span class="lineNum">     313 </span><span class="lineCov">          1 : test_completion_valid_params (option_proposer &amp;proposer)</span>
<span class="lineNum">     314 </span>            : {
<span class="lineNum">     315 </span><span class="lineCov">          1 :   const char *option_prefixes[] =</span>
<span class="lineNum">     316 </span>            :   {
<span class="lineNum">     317 </span>            :     &quot;--param=sched-state-edge-prob-cutoff&quot;,
<span class="lineNum">     318 </span>            :     &quot;--param=iv-consider-all-candidates-bound&quot;,
<span class="lineNum">     319 </span>            :     &quot;--param=align-threshold&quot;,
<span class="lineNum">     320 </span>            :     &quot;--param=prefetch-min-insn-to-mem-ratio&quot;,
<span class="lineNum">     321 </span>            :     &quot;--param=max-unrolled-insns&quot;,
<span class="lineNum">     322 </span>            :     &quot;--param=max-early-inliner-iterations&quot;,
<span class="lineNum">     323 </span>            :     &quot;--param=max-vartrack-reverse-op-size&quot;,
<span class="lineNum">     324 </span>            :     &quot;--param=ipa-cp-loop-hint-bonus&quot;,
<span class="lineNum">     325 </span>            :     &quot;--param=tracer-min-branch-ratio&quot;,
<span class="lineNum">     326 </span>            :     &quot;--param=graphite-max-arrays-per-scop&quot;,
<span class="lineNum">     327 </span>            :     &quot;--param=sink-frequency-threshold&quot;,
<span class="lineNum">     328 </span>            :     &quot;--param=max-cse-path-length&quot;,
<span class="lineNum">     329 </span>            :     &quot;--param=sra-max-scalarization-size-Osize&quot;,
<span class="lineNum">     330 </span>            :     &quot;--param=prefetch-latency&quot;,
<span class="lineNum">     331 </span>            :     &quot;--param=dse-max-object-size&quot;,
<span class="lineNum">     332 </span>            :     &quot;--param=asan-globals&quot;,
<span class="lineNum">     333 </span>            :     &quot;--param=max-vartrack-size&quot;,
<span class="lineNum">     334 </span>            :     &quot;--param=case-values-threshold&quot;,
<span class="lineNum">     335 </span>            :     &quot;--param=max-slsr-cand-scan&quot;,
<span class="lineNum">     336 </span>            :     &quot;--param=min-insn-to-prefetch-ratio&quot;,
<span class="lineNum">     337 </span>            :     &quot;--param=tracer-min-branch-probability&quot;,
<span class="lineNum">     338 </span>            :     &quot;--param sink-frequency-threshold&quot;,
<span class="lineNum">     339 </span>            :     &quot;--param max-cse-path-length&quot;,
<span class="lineNum">     340 </span>            :     &quot;--param sra-max-scalarization-size-Osize&quot;,
<span class="lineNum">     341 </span>            :     &quot;--param prefetch-latency&quot;,
<span class="lineNum">     342 </span>            :     &quot;--param dse-max-object-size&quot;,
<span class="lineNum">     343 </span>            :     &quot;--param asan-globals&quot;,
<span class="lineNum">     344 </span>            :     &quot;--param max-vartrack-size&quot;,
<span class="lineNum">     345 </span>            :     NULL
<span class="lineNum">     346 </span>            :   };
<span class="lineNum">     347 </span>            : 
<span class="lineNum">     348 </span><span class="lineCov">         29 :   for (const char **ptr = option_prefixes; *ptr != NULL; ptr++)</span>
<span class="lineNum">     349 </span><span class="lineCov">         28 :     verify_autocompletions (proposer, *ptr);</span>
<span class="lineNum">     350 </span><span class="lineCov">          1 : }</span>
<span class="lineNum">     351 </span>            : 
<span class="lineNum">     352 </span>            : /* Return true when EXPECTED is one of completions for OPTION_PREFIX string.  */
<span class="lineNum">     353 </span>            : 
<span class="lineNum">     354 </span>            : static bool
<span class="lineNum">     355 </span><span class="lineCov">          8 : in_completion_p (option_proposer &amp;proposer, const char *option_prefix,</span>
<span class="lineNum">     356 </span>            :                  const char *expected)
<span class="lineNum">     357 </span>            : {
<span class="lineNum">     358 </span><span class="lineCov">         16 :   auto_string_vec suggestions;</span>
<span class="lineNum">     359 </span><span class="lineCov">          8 :   proposer.get_completions (option_prefix, suggestions);</span>
<span class="lineNum">     360 </span>            : 
<span class="lineNum">     361 </span><span class="lineCov">        696 :   for (unsigned i = 0; i &lt; suggestions.length (); i++)</span>
<span class="lineNum">     362 </span>            :     {
<span class="lineNum">     363 </span><span class="lineCov">        346 :       char *r = suggestions[i];</span>
<span class="lineNum">     364 </span><span class="lineCov">        346 :       if (strcmp (r, expected) == 0)</span>
<span class="lineNum">     365 </span>            :         return true;
<span class="lineNum">     366 </span>            :     }
<span class="lineNum">     367 </span>            : 
<span class="lineNum">     368 </span>            :   return false;
<span class="lineNum">     369 </span>            : }
<span class="lineNum">     370 </span>            : 
<span class="lineNum">     371 </span>            : /* Return true when PROPOSER does not find any partial completion
<span class="lineNum">     372 </span>            :    for OPTION_PREFIX.  */
<span class="lineNum">     373 </span>            : 
<span class="lineNum">     374 </span>            : static bool
<span class="lineNum">     375 </span><span class="lineCov">         11 : empty_completion_p (option_proposer &amp;proposer, const char *option_prefix)</span>
<span class="lineNum">     376 </span>            : {
<span class="lineNum">     377 </span><span class="lineCov">         22 :   auto_string_vec suggestions;</span>
<span class="lineNum">     378 </span><span class="lineCov">         11 :   proposer.get_completions (option_prefix, suggestions);</span>
<span class="lineNum">     379 </span><span class="lineCov">         11 :   return suggestions.is_empty ();</span>
<span class="lineNum">     380 </span>            : }
<span class="lineNum">     381 </span>            : 
<span class="lineNum">     382 </span>            : /* Verify autocompletions of partially-complete options.  */
<a name="383"><span class="lineNum">     383 </span>            : </a>
<span class="lineNum">     384 </span>            : static void
<span class="lineNum">     385 </span><span class="lineCov">          1 : test_completion_partial_match (option_proposer &amp;proposer)</span>
<span class="lineNum">     386 </span>            : {
<span class="lineNum">     387 </span><span class="lineCov">          1 :   ASSERT_TRUE (in_completion_p (proposer, &quot;-fsani&quot;, &quot;-fsanitize=address&quot;));</span>
<span class="lineNum">     388 </span><span class="lineCov">          1 :   ASSERT_TRUE (in_completion_p (proposer, &quot;-fsani&quot;,</span>
<span class="lineNum">     389 </span>            :                                 &quot;-fsanitize-address-use-after-scope&quot;));
<span class="lineNum">     390 </span><span class="lineCov">          1 :   ASSERT_TRUE (in_completion_p (proposer, &quot;-fipa-icf&quot;, &quot;-fipa-icf-functions&quot;));</span>
<span class="lineNum">     391 </span><span class="lineCov">          1 :   ASSERT_TRUE (in_completion_p (proposer, &quot;-fipa-icf&quot;, &quot;-fipa-icf&quot;));</span>
<span class="lineNum">     392 </span><span class="lineCov">          1 :   ASSERT_TRUE (in_completion_p (proposer, &quot;--param=&quot;,</span>
<span class="lineNum">     393 </span>            :                                 &quot;--param=max-vartrack-reverse-op-size&quot;));
<span class="lineNum">     394 </span><span class="lineCov">          1 :   ASSERT_TRUE (in_completion_p (proposer, &quot;--param &quot;,</span>
<span class="lineNum">     395 </span>            :                                 &quot;--param max-vartrack-reverse-op-size&quot;));
<span class="lineNum">     396 </span>            : 
<span class="lineNum">     397 </span><span class="lineCov">          1 :   ASSERT_FALSE (in_completion_p (proposer, &quot;-fipa-icf&quot;, &quot;-fipa&quot;));</span>
<span class="lineNum">     398 </span><span class="lineCov">          1 :   ASSERT_FALSE (in_completion_p (proposer, &quot;-fipa-icf-functions&quot;, &quot;-fipa-icf&quot;));</span>
<span class="lineNum">     399 </span>            : 
<span class="lineNum">     400 </span><span class="lineCov">          1 :   ASSERT_FALSE (empty_completion_p (proposer, &quot;-&quot;));</span>
<span class="lineNum">     401 </span><span class="lineCov">          1 :   ASSERT_FALSE (empty_completion_p (proposer, &quot;-fipa&quot;));</span>
<span class="lineNum">     402 </span><span class="lineCov">          1 :   ASSERT_FALSE (empty_completion_p (proposer, &quot;--par&quot;));</span>
<span class="lineNum">     403 </span><span class="lineCov">          1 : }</span>
<span class="lineNum">     404 </span>            : 
<span class="lineNum">     405 </span>            : /* Verify that autocompletion does not return any match for garbage inputs.  */
<a name="406"><span class="lineNum">     406 </span>            : </a>
<span class="lineNum">     407 </span>            : static void
<span class="lineNum">     408 </span><span class="lineCov">          1 : test_completion_garbage (option_proposer &amp;proposer)</span>
<span class="lineNum">     409 </span>            : {
<span class="lineNum">     410 </span><span class="lineCov">          1 :   ASSERT_TRUE (empty_completion_p (proposer, NULL));</span>
<span class="lineNum">     411 </span><span class="lineCov">          1 :   ASSERT_TRUE (empty_completion_p (proposer, &quot;&quot;));</span>
<span class="lineNum">     412 </span><span class="lineCov">          1 :   ASSERT_TRUE (empty_completion_p (proposer, &quot;- &quot;));</span>
<span class="lineNum">     413 </span><span class="lineCov">          1 :   ASSERT_TRUE (empty_completion_p (proposer, &quot;123456789&quot;));</span>
<span class="lineNum">     414 </span><span class="lineCov">          1 :   ASSERT_TRUE (empty_completion_p (proposer, &quot;---------&quot;));</span>
<span class="lineNum">     415 </span><span class="lineCov">          1 :   ASSERT_TRUE (empty_completion_p (proposer, &quot;#########&quot;));</span>
<span class="lineNum">     416 </span><span class="lineCov">          1 :   ASSERT_TRUE (empty_completion_p (proposer, &quot;- - - - - -&quot;));</span>
<span class="lineNum">     417 </span><span class="lineCov">          1 :   ASSERT_TRUE (empty_completion_p (proposer, &quot;-fsanitize=address2&quot;));</span>
<span class="lineNum">     418 </span><span class="lineCov">          1 : }</span>
<span class="lineNum">     419 </span>            : 
<span class="lineNum">     420 </span>            : /* Run all of the selftests within this file.  */
<a name="421"><span class="lineNum">     421 </span>            : </a>
<span class="lineNum">     422 </span>            : void
<span class="lineNum">     423 </span><span class="lineCov">          1 : opt_proposer_c_tests ()</span>
<span class="lineNum">     424 </span>            : {
<span class="lineNum">     425 </span><span class="lineCov">          2 :   option_proposer proposer;</span>
<span class="lineNum">     426 </span>            : 
<span class="lineNum">     427 </span><span class="lineCov">          1 :   test_completion_valid_options (proposer);</span>
<span class="lineNum">     428 </span><span class="lineCov">          1 :   test_completion_valid_params (proposer);</span>
<span class="lineNum">     429 </span><span class="lineCov">          1 :   test_completion_partial_match (proposer);</span>
<span class="lineNum">     430 </span><span class="lineCov">          1 :   test_completion_garbage (proposer);</span>
<span class="lineNum">     431 </span><span class="lineCov">          1 : }</span>
<span class="lineNum">     432 </span>            : 
<span class="lineNum">     433 </span>            : } // namespace selftest
<span class="lineNum">     434 </span>            : 
<span class="lineNum">     435 </span>            : #endif /* #if CHECKING_P */
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.0</a></td></tr>
  </table>
  <br>
<h3>LCOV profile is generated on x86_64 machine using following configure options: configure --disable-bootstrap --enable-coverage=opt --enable-languages=c,c++,fortran,go,jit,lto --enable-host-shared. GCC test suite is run with the built compiler.</h3></body></html>
