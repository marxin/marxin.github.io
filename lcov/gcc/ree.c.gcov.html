<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - gcc.info - gcc/ree.c</title>
  <link rel="stylesheet" type="text/css" href="../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../index.html">top level</a> - <a href="index.html">gcc</a> - ree.c<span style="font-size: 80%;"> (source / <a href="ree.c.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">gcc.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">414</td>
            <td class="headerCovTableEntry">435</td>
            <td class="headerCovTableEntryHi">95.2 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2018-09-22 10:58:49</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">16</td>
            <td class="headerCovTableEntry">18</td>
            <td class="headerCovTableEntryMed">88.9 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /* Redundant Extension Elimination pass for the GNU compiler.</a>
<span class="lineNum">       2 </span>            :    Copyright (C) 2010-2018 Free Software Foundation, Inc.
<span class="lineNum">       3 </span>            :    Contributed by Ilya Enkovich (ilya.enkovich@intel.com)
<span class="lineNum">       4 </span>            : 
<span class="lineNum">       5 </span>            :    Based on the Redundant Zero-extension elimination pass contributed by
<span class="lineNum">       6 </span>            :    Sriraman Tallam (tmsriram@google.com) and Silvius Rus (rus@google.com).
<span class="lineNum">       7 </span>            : 
<span class="lineNum">       8 </span>            : This file is part of GCC.
<span class="lineNum">       9 </span>            : 
<span class="lineNum">      10 </span>            : GCC is free software; you can redistribute it and/or modify it under
<span class="lineNum">      11 </span>            : the terms of the GNU General Public License as published by the Free
<span class="lineNum">      12 </span>            : Software Foundation; either version 3, or (at your option) any later
<span class="lineNum">      13 </span>            : version.
<span class="lineNum">      14 </span>            : 
<span class="lineNum">      15 </span>            : GCC is distributed in the hope that it will be useful, but WITHOUT ANY
<span class="lineNum">      16 </span>            : WARRANTY; without even the implied warranty of MERCHANTABILITY or
<span class="lineNum">      17 </span>            : FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
<span class="lineNum">      18 </span>            : for more details.
<span class="lineNum">      19 </span>            : 
<span class="lineNum">      20 </span>            : You should have received a copy of the GNU General Public License
<span class="lineNum">      21 </span>            : along with GCC; see the file COPYING3.  If not see
<span class="lineNum">      22 </span>            : &lt;http://www.gnu.org/licenses/&gt;.  */
<span class="lineNum">      23 </span>            : 
<span class="lineNum">      24 </span>            : 
<span class="lineNum">      25 </span>            : /* Problem Description :
<span class="lineNum">      26 </span>            :    --------------------
<span class="lineNum">      27 </span>            :    This pass is intended to remove redundant extension instructions.
<span class="lineNum">      28 </span>            :    Such instructions appear for different reasons.  We expect some of
<span class="lineNum">      29 </span>            :    them due to implicit zero-extension in 64-bit registers after writing
<span class="lineNum">      30 </span>            :    to their lower 32-bit half (e.g. for the x86-64 architecture).
<span class="lineNum">      31 </span>            :    Another possible reason is a type cast which follows a load (for
<span class="lineNum">      32 </span>            :    instance a register restore) and which can be combined into a single
<span class="lineNum">      33 </span>            :    instruction, and for which earlier local passes, e.g. the combiner,
<span class="lineNum">      34 </span>            :    weren't able to optimize.
<span class="lineNum">      35 </span>            : 
<span class="lineNum">      36 </span>            :    How does this pass work  ?
<span class="lineNum">      37 </span>            :    --------------------------
<span class="lineNum">      38 </span>            : 
<span class="lineNum">      39 </span>            :    This pass is run after register allocation.  Hence, all registers that
<span class="lineNum">      40 </span>            :    this pass deals with are hard registers.  This pass first looks for an
<span class="lineNum">      41 </span>            :    extension instruction that could possibly be redundant.  Such extension
<span class="lineNum">      42 </span>            :    instructions show up in RTL with the pattern  :
<span class="lineNum">      43 </span>            :    (set (reg:&lt;SWI248&gt; x) (any_extend:&lt;SWI248&gt; (reg:&lt;SWI124&gt; x))),
<span class="lineNum">      44 </span>            :    where x can be any hard register.
<span class="lineNum">      45 </span>            :    Now, this pass tries to eliminate this instruction by merging the
<span class="lineNum">      46 </span>            :    extension with the definitions of register x.  For instance, if
<span class="lineNum">      47 </span>            :    one of the definitions of register x was  :
<span class="lineNum">      48 </span>            :    (set (reg:SI x) (plus:SI (reg:SI z1) (reg:SI z2))),
<span class="lineNum">      49 </span>            :    followed by extension  :
<span class="lineNum">      50 </span>            :    (set (reg:DI x) (zero_extend:DI (reg:SI x)))
<span class="lineNum">      51 </span>            :    then the combination converts this into :
<span class="lineNum">      52 </span>            :    (set (reg:DI x) (zero_extend:DI (plus:SI (reg:SI z1) (reg:SI z2)))).
<span class="lineNum">      53 </span>            :    If all the merged definitions are recognizable assembly instructions,
<span class="lineNum">      54 </span>            :    the extension is effectively eliminated.
<span class="lineNum">      55 </span>            : 
<span class="lineNum">      56 </span>            :    For example, for the x86-64 architecture, implicit zero-extensions
<span class="lineNum">      57 </span>            :    are captured with appropriate patterns in the i386.md file.  Hence,
<span class="lineNum">      58 </span>            :    these merged definition can be matched to a single assembly instruction.
<span class="lineNum">      59 </span>            :    The original extension instruction is then deleted if all the
<span class="lineNum">      60 </span>            :    definitions can be merged.
<span class="lineNum">      61 </span>            : 
<span class="lineNum">      62 </span>            :    However, there are cases where the definition instruction cannot be
<span class="lineNum">      63 </span>            :    merged with an extension.  Examples are CALL instructions.  In such
<span class="lineNum">      64 </span>            :    cases, the original extension is not redundant and this pass does
<span class="lineNum">      65 </span>            :    not delete it.
<span class="lineNum">      66 </span>            : 
<span class="lineNum">      67 </span>            :    Handling conditional moves :
<span class="lineNum">      68 </span>            :    ----------------------------
<span class="lineNum">      69 </span>            : 
<span class="lineNum">      70 </span>            :    Architectures like x86-64 support conditional moves whose semantics for
<span class="lineNum">      71 </span>            :    extension differ from the other instructions.  For instance, the
<span class="lineNum">      72 </span>            :    instruction *cmov ebx, eax*
<span class="lineNum">      73 </span>            :    zero-extends eax onto rax only when the move from ebx to eax happens.
<span class="lineNum">      74 </span>            :    Otherwise, eax may not be zero-extended.  Consider conditional moves as
<span class="lineNum">      75 </span>            :    RTL instructions of the form
<span class="lineNum">      76 </span>            :    (set (reg:SI x) (if_then_else (cond) (reg:SI y) (reg:SI z))).
<span class="lineNum">      77 </span>            :    This pass tries to merge an extension with a conditional move by
<span class="lineNum">      78 </span>            :    actually merging the definitions of y and z with an extension and then
<span class="lineNum">      79 </span>            :    converting the conditional move into :
<span class="lineNum">      80 </span>            :    (set (reg:DI x) (if_then_else (cond) (reg:DI y) (reg:DI z))).
<span class="lineNum">      81 </span>            :    Since registers y and z are extended, register x will also be extended
<span class="lineNum">      82 </span>            :    after the conditional move.  Note that this step has to be done
<span class="lineNum">      83 </span>            :    transitively since the definition of a conditional copy can be
<span class="lineNum">      84 </span>            :    another conditional copy.
<span class="lineNum">      85 </span>            : 
<span class="lineNum">      86 </span>            :    Motivating Example I :
<span class="lineNum">      87 </span>            :    ---------------------
<span class="lineNum">      88 </span>            :    For this program :
<span class="lineNum">      89 </span>            :    **********************************************
<span class="lineNum">      90 </span>            :    bad_code.c
<span class="lineNum">      91 </span>            : 
<span class="lineNum">      92 </span>            :    int mask[1000];
<span class="lineNum">      93 </span>            : 
<span class="lineNum">      94 </span>            :    int foo(unsigned x)
<span class="lineNum">      95 </span>            :    {
<span class="lineNum">      96 </span>            :      if (x &lt; 10)
<span class="lineNum">      97 </span>            :        x = x * 45;
<span class="lineNum">      98 </span>            :      else
<span class="lineNum">      99 </span>            :        x = x * 78;
<span class="lineNum">     100 </span>            :      return mask[x];
<span class="lineNum">     101 </span>            :    }
<span class="lineNum">     102 </span>            :    **********************************************
<span class="lineNum">     103 </span>            : 
<span class="lineNum">     104 </span>            :    $ gcc -O2 bad_code.c
<span class="lineNum">     105 </span>            :      ........
<span class="lineNum">     106 </span>            :      400315:       b8 4e 00 00 00          mov    $0x4e,%eax
<span class="lineNum">     107 </span>            :      40031a:       0f af f8                imul   %eax,%edi
<span class="lineNum">     108 </span>            :      40031d:       89 ff                   mov    %edi,%edi - useless extension
<span class="lineNum">     109 </span>            :      40031f:       8b 04 bd 60 19 40 00    mov    0x401960(,%rdi,4),%eax
<span class="lineNum">     110 </span>            :      400326:       c3                      retq
<span class="lineNum">     111 </span>            :      ......
<span class="lineNum">     112 </span>            :      400330:       ba 2d 00 00 00          mov    $0x2d,%edx
<span class="lineNum">     113 </span>            :      400335:       0f af fa                imul   %edx,%edi
<span class="lineNum">     114 </span>            :      400338:       89 ff                   mov    %edi,%edi - useless extension
<span class="lineNum">     115 </span>            :      40033a:       8b 04 bd 60 19 40 00    mov    0x401960(,%rdi,4),%eax
<span class="lineNum">     116 </span>            :      400341:       c3                      retq
<span class="lineNum">     117 </span>            : 
<span class="lineNum">     118 </span>            :    $ gcc -O2 -free bad_code.c
<span class="lineNum">     119 </span>            :      ......
<span class="lineNum">     120 </span>            :      400315:       6b ff 4e                imul   $0x4e,%edi,%edi
<span class="lineNum">     121 </span>            :      400318:       8b 04 bd 40 19 40 00    mov    0x401940(,%rdi,4),%eax
<span class="lineNum">     122 </span>            :      40031f:       c3                      retq
<span class="lineNum">     123 </span>            :      400320:       6b ff 2d                imul   $0x2d,%edi,%edi
<span class="lineNum">     124 </span>            :      400323:       8b 04 bd 40 19 40 00    mov    0x401940(,%rdi,4),%eax
<span class="lineNum">     125 </span>            :      40032a:       c3                      retq
<span class="lineNum">     126 </span>            : 
<span class="lineNum">     127 </span>            :    Motivating Example II :
<span class="lineNum">     128 </span>            :    ---------------------
<span class="lineNum">     129 </span>            : 
<span class="lineNum">     130 </span>            :    Here is an example with a conditional move.
<span class="lineNum">     131 </span>            : 
<span class="lineNum">     132 </span>            :    For this program :
<span class="lineNum">     133 </span>            :    **********************************************
<span class="lineNum">     134 </span>            : 
<span class="lineNum">     135 </span>            :    unsigned long long foo(unsigned x , unsigned y)
<span class="lineNum">     136 </span>            :    {
<span class="lineNum">     137 </span>            :      unsigned z;
<span class="lineNum">     138 </span>            :      if (x &gt; 100)
<span class="lineNum">     139 </span>            :        z = x + y;
<span class="lineNum">     140 </span>            :      else
<span class="lineNum">     141 </span>            :        z = x - y;
<span class="lineNum">     142 </span>            :      return (unsigned long long)(z);
<span class="lineNum">     143 </span>            :    }
<span class="lineNum">     144 </span>            : 
<span class="lineNum">     145 </span>            :    $ gcc -O2 bad_code.c
<span class="lineNum">     146 </span>            :      ............
<span class="lineNum">     147 </span>            :      400360:       8d 14 3e                lea    (%rsi,%rdi,1),%edx
<span class="lineNum">     148 </span>            :      400363:       89 f8                   mov    %edi,%eax
<span class="lineNum">     149 </span>            :      400365:       29 f0                   sub    %esi,%eax
<span class="lineNum">     150 </span>            :      400367:       83 ff 65                cmp    $0x65,%edi
<span class="lineNum">     151 </span>            :      40036a:       0f 43 c2                cmovae %edx,%eax
<span class="lineNum">     152 </span>            :      40036d:       89 c0                   mov    %eax,%eax - useless extension
<span class="lineNum">     153 </span>            :      40036f:       c3                      retq
<span class="lineNum">     154 </span>            : 
<span class="lineNum">     155 </span>            :    $ gcc -O2 -free bad_code.c
<span class="lineNum">     156 </span>            :      .............
<span class="lineNum">     157 </span>            :      400360:       89 fa                   mov    %edi,%edx
<span class="lineNum">     158 </span>            :      400362:       8d 04 3e                lea    (%rsi,%rdi,1),%eax
<span class="lineNum">     159 </span>            :      400365:       29 f2                   sub    %esi,%edx
<span class="lineNum">     160 </span>            :      400367:       83 ff 65                cmp    $0x65,%edi
<span class="lineNum">     161 </span>            :      40036a:       89 d6                   mov    %edx,%esi
<span class="lineNum">     162 </span>            :      40036c:       48 0f 42 c6             cmovb  %rsi,%rax
<span class="lineNum">     163 </span>            :      400370:       c3                      retq
<span class="lineNum">     164 </span>            : 
<span class="lineNum">     165 </span>            :   Motivating Example III :
<span class="lineNum">     166 </span>            :   ---------------------
<span class="lineNum">     167 </span>            : 
<span class="lineNum">     168 </span>            :   Here is an example with a type cast.
<span class="lineNum">     169 </span>            : 
<span class="lineNum">     170 </span>            :   For this program :
<span class="lineNum">     171 </span>            :   **********************************************
<span class="lineNum">     172 </span>            : 
<span class="lineNum">     173 </span>            :   void test(int size, unsigned char *in, unsigned char *out)
<span class="lineNum">     174 </span>            :   {
<span class="lineNum">     175 </span>            :     int i;
<span class="lineNum">     176 </span>            :     unsigned char xr, xg, xy=0;
<span class="lineNum">     177 </span>            : 
<span class="lineNum">     178 </span>            :     for (i = 0; i &lt; size; i++) {
<span class="lineNum">     179 </span>            :       xr = *in++;
<span class="lineNum">     180 </span>            :       xg = *in++;
<span class="lineNum">     181 </span>            :       xy = (unsigned char) ((19595*xr + 38470*xg) &gt;&gt; 16);
<span class="lineNum">     182 </span>            :       *out++ = xy;
<span class="lineNum">     183 </span>            :     }
<span class="lineNum">     184 </span>            :   }
<span class="lineNum">     185 </span>            : 
<span class="lineNum">     186 </span>            :   $ gcc -O2 bad_code.c
<span class="lineNum">     187 </span>            :     ............
<span class="lineNum">     188 </span>            :     10:   0f b6 0e                movzbl (%rsi),%ecx
<span class="lineNum">     189 </span>            :     13:   0f b6 46 01             movzbl 0x1(%rsi),%eax
<span class="lineNum">     190 </span>            :     17:   48 83 c6 02             add    $0x2,%rsi
<span class="lineNum">     191 </span>            :     1b:   0f b6 c9                movzbl %cl,%ecx - useless extension
<span class="lineNum">     192 </span>            :     1e:   0f b6 c0                movzbl %al,%eax - useless extension
<span class="lineNum">     193 </span>            :     21:   69 c9 8b 4c 00 00       imul   $0x4c8b,%ecx,%ecx
<span class="lineNum">     194 </span>            :     27:   69 c0 46 96 00 00       imul   $0x9646,%eax,%eax
<span class="lineNum">     195 </span>            : 
<span class="lineNum">     196 </span>            :    $ gcc -O2 -free bad_code.c
<span class="lineNum">     197 </span>            :      .............
<span class="lineNum">     198 </span>            :     10:   0f b6 0e                movzbl (%rsi),%ecx
<span class="lineNum">     199 </span>            :     13:   0f b6 46 01             movzbl 0x1(%rsi),%eax
<span class="lineNum">     200 </span>            :     17:   48 83 c6 02             add    $0x2,%rsi
<span class="lineNum">     201 </span>            :     1b:   69 c9 8b 4c 00 00       imul   $0x4c8b,%ecx,%ecx
<span class="lineNum">     202 </span>            :     21:   69 c0 46 96 00 00       imul   $0x9646,%eax,%eax
<span class="lineNum">     203 </span>            : 
<span class="lineNum">     204 </span>            :    Usefulness :
<span class="lineNum">     205 </span>            :    ----------
<span class="lineNum">     206 </span>            : 
<span class="lineNum">     207 </span>            :    The original redundant zero-extension elimination pass reported reduction
<span class="lineNum">     208 </span>            :    of the dynamic instruction count of a compression benchmark by 2.8% and
<span class="lineNum">     209 </span>            :    improvement of its run time by about 1%.
<span class="lineNum">     210 </span>            : 
<span class="lineNum">     211 </span>            :    The additional performance gain with the enhanced pass is mostly expected
<span class="lineNum">     212 </span>            :    on in-order architectures where redundancy cannot be compensated by out of
<span class="lineNum">     213 </span>            :    order execution.  Measurements showed up to 10% performance gain (reduced
<span class="lineNum">     214 </span>            :    run time) on EEMBC 2.0 benchmarks on Atom processor with geomean performance
<span class="lineNum">     215 </span>            :    gain 1%.  */
<span class="lineNum">     216 </span>            : 
<span class="lineNum">     217 </span>            : 
<span class="lineNum">     218 </span>            : #include &quot;config.h&quot;
<span class="lineNum">     219 </span>            : #include &quot;system.h&quot;
<span class="lineNum">     220 </span>            : #include &quot;coretypes.h&quot;
<span class="lineNum">     221 </span>            : #include &quot;backend.h&quot;
<span class="lineNum">     222 </span>            : #include &quot;target.h&quot;
<span class="lineNum">     223 </span>            : #include &quot;rtl.h&quot;
<span class="lineNum">     224 </span>            : #include &quot;tree.h&quot;
<span class="lineNum">     225 </span>            : #include &quot;df.h&quot;
<span class="lineNum">     226 </span>            : #include &quot;memmodel.h&quot;
<span class="lineNum">     227 </span>            : #include &quot;tm_p.h&quot;
<span class="lineNum">     228 </span>            : #include &quot;optabs.h&quot;
<span class="lineNum">     229 </span>            : #include &quot;regs.h&quot;
<span class="lineNum">     230 </span>            : #include &quot;emit-rtl.h&quot;
<span class="lineNum">     231 </span>            : #include &quot;recog.h&quot;
<span class="lineNum">     232 </span>            : #include &quot;cfgrtl.h&quot;
<span class="lineNum">     233 </span>            : #include &quot;expr.h&quot;
<span class="lineNum">     234 </span>            : #include &quot;tree-pass.h&quot;
<span class="lineNum">     235 </span>            : 
<span class="lineNum">     236 </span>            : /* This structure represents a candidate for elimination.  */
<span class="lineNum">     237 </span>            : 
<span class="lineNum">     238 </span>            : struct ext_cand
<span class="lineNum">     239 </span>            : {
<span class="lineNum">     240 </span>            :   /* The expression.  */
<span class="lineNum">     241 </span>            :   const_rtx expr;
<span class="lineNum">     242 </span>            : 
<span class="lineNum">     243 </span>            :   /* The kind of extension.  */
<span class="lineNum">     244 </span>            :   enum rtx_code code;
<span class="lineNum">     245 </span>            : 
<span class="lineNum">     246 </span>            :   /* The destination mode.  */
<span class="lineNum">     247 </span>            :   machine_mode mode;
<span class="lineNum">     248 </span>            : 
<span class="lineNum">     249 </span>            :   /* The instruction where it lives.  */
<span class="lineNum">     250 </span>            :   rtx_insn *insn;
<span class="lineNum">     251 </span>            : };
<span class="lineNum">     252 </span>            : 
<span class="lineNum">     253 </span>            : 
<span class="lineNum">     254 </span>            : static int max_insn_uid;
<span class="lineNum">     255 </span>            : 
<span class="lineNum">     256 </span>            : /* Update or remove REG_EQUAL or REG_EQUIV notes for INSN.  */
<a name="257"><span class="lineNum">     257 </span>            : </a>
<span class="lineNum">     258 </span>            : static bool
<span class="lineNum">     259 </span><span class="lineCov">     134777 : update_reg_equal_equiv_notes (rtx_insn *insn, machine_mode new_mode,</span>
<span class="lineNum">     260 </span>            :                               machine_mode old_mode, enum rtx_code code)
<span class="lineNum">     261 </span>            : {
<span class="lineNum">     262 </span><span class="lineCov">     134777 :   rtx *loc = &amp;REG_NOTES (insn);</span>
<span class="lineNum">     263 </span><span class="lineCov">     141986 :   while (*loc)</span>
<span class="lineNum">     264 </span>            :     {
<span class="lineNum">     265 </span><span class="lineCov">       7209 :       enum reg_note kind = REG_NOTE_KIND (*loc);</span>
<span class="lineNum">     266 </span><span class="lineCov">       7209 :       if (kind == REG_EQUAL || kind == REG_EQUIV)</span>
<span class="lineNum">     267 </span>            :         {
<span class="lineNum">     268 </span><span class="lineCov">       7136 :           rtx orig_src = XEXP (*loc, 0);</span>
<span class="lineNum">     269 </span>            :           /* Update equivalency constants.  Recall that RTL constants are
<span class="lineNum">     270 </span>            :              sign-extended.  */
<span class="lineNum">     271 </span><span class="lineCov">       7136 :           if (GET_CODE (orig_src) == CONST_INT</span>
<span class="lineNum">     272 </span><span class="lineCov">       7136 :               &amp;&amp; HWI_COMPUTABLE_MODE_P (new_mode))</span>
<span class="lineNum">     273 </span>            :             {
<span class="lineNum">     274 </span><span class="lineCov">       3399 :               if (INTVAL (orig_src) &gt;= 0 || code == SIGN_EXTEND)</span>
<span class="lineNum">     275 </span>            :                 /* Nothing needed.  */;
<span class="lineNum">     276 </span>            :               else
<span class="lineNum">     277 </span>            :                 {
<span class="lineNum">     278 </span>            :                   /* Zero-extend the negative constant by masking out the
<span class="lineNum">     279 </span>            :                      bits outside the source mode.  */
<span class="lineNum">     280 </span><span class="lineCov">         41 :                   rtx new_const_int</span>
<span class="lineNum">     281 </span><span class="lineCov">         41 :                     = gen_int_mode (INTVAL (orig_src)</span>
<span class="lineNum">     282 </span><span class="lineCov">         41 :                                     &amp; GET_MODE_MASK (old_mode),</span>
<span class="lineNum">     283 </span>            :                                     new_mode);
<span class="lineNum">     284 </span><span class="lineCov">         41 :                   if (!validate_change (insn, &amp;XEXP (*loc, 0),</span>
<span class="lineNum">     285 </span>            :                                         new_const_int, true))
<span class="lineNum">     286 </span>            :                     return false;
<span class="lineNum">     287 </span>            :                 }
<span class="lineNum">     288 </span><span class="lineCov">       3399 :               loc = &amp;XEXP (*loc, 1);</span>
<span class="lineNum">     289 </span>            :             }
<span class="lineNum">     290 </span>            :           /* Drop all other notes, they assume a wrong mode.  */
<span class="lineNum">     291 </span><span class="lineCov">       3737 :           else if (!validate_change (insn, loc, XEXP (*loc, 1), true))</span>
<span class="lineNum">     292 </span>            :             return false;
<span class="lineNum">     293 </span>            :         }
<span class="lineNum">     294 </span>            :       else
<span class="lineNum">     295 </span><span class="lineCov">         73 :         loc = &amp;XEXP (*loc, 1);</span>
<span class="lineNum">     296 </span>            :     }
<span class="lineNum">     297 </span>            :   return true;
<span class="lineNum">     298 </span>            : }
<span class="lineNum">     299 </span>            : 
<span class="lineNum">     300 </span>            : /* Given a insn (CURR_INSN), an extension candidate for removal (CAND)
<span class="lineNum">     301 </span>            :    and a pointer to the SET rtx (ORIG_SET) that needs to be modified,
<span class="lineNum">     302 </span>            :    this code modifies the SET rtx to a new SET rtx that extends the
<span class="lineNum">     303 </span>            :    right hand expression into a register on the left hand side.  Note
<span class="lineNum">     304 </span>            :    that multiple assumptions are made about the nature of the set that
<span class="lineNum">     305 </span>            :    needs to be true for this to work and is called from merge_def_and_ext.
<span class="lineNum">     306 </span>            : 
<span class="lineNum">     307 </span>            :    Original :
<span class="lineNum">     308 </span>            :    (set (reg a) (expression))
<span class="lineNum">     309 </span>            : 
<span class="lineNum">     310 </span>            :    Transform :
<span class="lineNum">     311 </span>            :    (set (reg a) (any_extend (expression)))
<span class="lineNum">     312 </span>            : 
<span class="lineNum">     313 </span>            :    Special Cases :
<span class="lineNum">     314 </span>            :    If the expression is a constant or another extension, then directly
<span class="lineNum">     315 </span>            :    assign it to the register.  */
<a name="316"><span class="lineNum">     316 </span>            : </a>
<span class="lineNum">     317 </span>            : static bool
<span class="lineNum">     318 </span><span class="lineCov">     145608 : combine_set_extension (ext_cand *cand, rtx_insn *curr_insn, rtx *orig_set)</span>
<span class="lineNum">     319 </span>            : {
<span class="lineNum">     320 </span><span class="lineCov">     145608 :   rtx orig_src = SET_SRC (*orig_set);</span>
<span class="lineNum">     321 </span><span class="lineCov">     145608 :   machine_mode orig_mode = GET_MODE (SET_DEST (*orig_set));</span>
<span class="lineNum">     322 </span><span class="lineCov">     145608 :   rtx new_set;</span>
<span class="lineNum">     323 </span><span class="lineCov">     145608 :   rtx cand_pat = PATTERN (cand-&gt;insn);</span>
<span class="lineNum">     324 </span>            : 
<span class="lineNum">     325 </span>            :   /* If the extension's source/destination registers are not the same
<span class="lineNum">     326 </span>            :      then we need to change the original load to reference the destination
<span class="lineNum">     327 </span>            :      of the extension.  Then we need to emit a copy from that destination
<span class="lineNum">     328 </span>            :      to the original destination of the load.  */
<span class="lineNum">     329 </span><span class="lineCov">     145608 :   rtx new_reg;</span>
<span class="lineNum">     330 </span><span class="lineCov">     145608 :   bool copy_needed</span>
<span class="lineNum">     331 </span><span class="lineCov">     291216 :     = (REGNO (SET_DEST (cand_pat)) != REGNO (XEXP (SET_SRC (cand_pat), 0)));</span>
<span class="lineNum">     332 </span><span class="lineCov">     145608 :   if (copy_needed)</span>
<span class="lineNum">     333 </span><span class="lineCov">      52808 :     new_reg = gen_rtx_REG (cand-&gt;mode, REGNO (SET_DEST (cand_pat)));</span>
<span class="lineNum">     334 </span>            :   else
<span class="lineNum">     335 </span><span class="lineCov">     238408 :     new_reg = gen_rtx_REG (cand-&gt;mode, REGNO (SET_DEST (*orig_set)));</span>
<span class="lineNum">     336 </span>            : 
<span class="lineNum">     337 </span>            :   /* Merge constants by directly moving the constant into the register under
<span class="lineNum">     338 </span>            :      some conditions.  Recall that RTL constants are sign-extended.  */
<span class="lineNum">     339 </span><span class="lineCov">     145608 :   if (GET_CODE (orig_src) == CONST_INT</span>
<span class="lineNum">     340 </span><span class="lineCov">     145608 :       &amp;&amp; HWI_COMPUTABLE_MODE_P (cand-&gt;mode))</span>
<span class="lineNum">     341 </span>            :     {
<span class="lineNum">     342 </span><span class="lineCov">       7202 :       if (INTVAL (orig_src) &gt;= 0 || cand-&gt;code == SIGN_EXTEND)</span>
<span class="lineNum">     343 </span><span class="lineCov">       7132 :         new_set = gen_rtx_SET (new_reg, orig_src);</span>
<span class="lineNum">     344 </span>            :       else
<span class="lineNum">     345 </span>            :         {
<span class="lineNum">     346 </span>            :           /* Zero-extend the negative constant by masking out the bits outside
<span class="lineNum">     347 </span>            :              the source mode.  */
<span class="lineNum">     348 </span><span class="lineCov">         70 :           rtx new_const_int</span>
<span class="lineNum">     349 </span><span class="lineCov">         70 :             = gen_int_mode (INTVAL (orig_src) &amp; GET_MODE_MASK (orig_mode),</span>
<span class="lineNum">     350 </span><span class="lineCov">         70 :                             GET_MODE (new_reg));</span>
<span class="lineNum">     351 </span><span class="lineCov">         70 :           new_set = gen_rtx_SET (new_reg, new_const_int);</span>
<span class="lineNum">     352 </span>            :         }
<span class="lineNum">     353 </span>            :     }
<span class="lineNum">     354 </span><span class="lineCov">     138406 :   else if (GET_MODE (orig_src) == VOIDmode)</span>
<span class="lineNum">     355 </span>            :     {
<span class="lineNum">     356 </span>            :       /* This is mostly due to a call insn that should not be optimized.  */
<span class="lineNum">     357 </span>            :       return false;
<span class="lineNum">     358 </span>            :     }
<span class="lineNum">     359 </span><span class="lineCov">     127210 :   else if (GET_CODE (orig_src) == cand-&gt;code)</span>
<span class="lineNum">     360 </span>            :     {
<span class="lineNum">     361 </span>            :       /* Here is a sequence of two extensions.  Try to merge them.  */
<span class="lineNum">     362 </span><span class="lineCov">        572 :       rtx temp_extension</span>
<span class="lineNum">     363 </span><span class="lineCov">        572 :         = gen_rtx_fmt_e (cand-&gt;code, cand-&gt;mode, XEXP (orig_src, 0));</span>
<span class="lineNum">     364 </span><span class="lineCov">        572 :       rtx simplified_temp_extension = simplify_rtx (temp_extension);</span>
<span class="lineNum">     365 </span><span class="lineCov">        572 :       if (simplified_temp_extension)</span>
<span class="lineNum">     366 </span><span class="lineNoCov">          0 :         temp_extension = simplified_temp_extension;</span>
<span class="lineNum">     367 </span><span class="lineCov">        572 :       new_set = gen_rtx_SET (new_reg, temp_extension);</span>
<span class="lineNum">     368 </span>            :     }
<span class="lineNum">     369 </span><span class="lineCov">     126638 :   else if (GET_CODE (orig_src) == IF_THEN_ELSE)</span>
<span class="lineNum">     370 </span>            :     {
<span class="lineNum">     371 </span>            :       /* Only IF_THEN_ELSE of phi-type copies are combined.  Otherwise,
<span class="lineNum">     372 </span>            :          in general, IF_THEN_ELSE should not be combined.  */
<span class="lineNum">     373 </span>            :       return false;
<span class="lineNum">     374 </span>            :     }
<span class="lineNum">     375 </span>            :   else
<span class="lineNum">     376 </span>            :     {
<span class="lineNum">     377 </span>            :       /* This is the normal case.  */
<span class="lineNum">     378 </span><span class="lineCov">     126509 :       rtx temp_extension</span>
<span class="lineNum">     379 </span><span class="lineCov">     126509 :         = gen_rtx_fmt_e (cand-&gt;code, cand-&gt;mode, orig_src);</span>
<span class="lineNum">     380 </span><span class="lineCov">     126509 :       rtx simplified_temp_extension = simplify_rtx (temp_extension);</span>
<span class="lineNum">     381 </span><span class="lineCov">     126509 :       if (simplified_temp_extension)</span>
<span class="lineNum">     382 </span><span class="lineCov">        366 :         temp_extension = simplified_temp_extension;</span>
<span class="lineNum">     383 </span><span class="lineCov">     126509 :       new_set = gen_rtx_SET (new_reg, temp_extension);</span>
<span class="lineNum">     384 </span>            :     }
<span class="lineNum">     385 </span>            : 
<span class="lineNum">     386 </span>            :   /* This change is a part of a group of changes.  Hence,
<span class="lineNum">     387 </span>            :      validate_change will not try to commit the change.  */
<span class="lineNum">     388 </span><span class="lineCov">     134283 :   if (validate_change (curr_insn, orig_set, new_set, true)</span>
<span class="lineNum">     389 </span><span class="lineCov">     134283 :       &amp;&amp; update_reg_equal_equiv_notes (curr_insn, cand-&gt;mode, orig_mode,</span>
<span class="lineNum">     390 </span>            :                                        cand-&gt;code))
<span class="lineNum">     391 </span>            :     {
<span class="lineNum">     392 </span><span class="lineCov">     134283 :       if (dump_file)</span>
<span class="lineNum">     393 </span>            :         {
<span class="lineNum">     394 </span><span class="lineCov">         57 :           fprintf (dump_file,</span>
<span class="lineNum">     395 </span>            :                    &quot;Tentatively merged extension with definition %s:\n&quot;,
<span class="lineNum">     396 </span>            :                    (copy_needed) ? &quot;(copy needed)&quot; : &quot;&quot;);
<span class="lineNum">     397 </span><span class="lineCov">         29 :           print_rtl_single (dump_file, curr_insn);</span>
<span class="lineNum">     398 </span>            :         }
<span class="lineNum">     399 </span><span class="lineCov">     134283 :       return true;</span>
<span class="lineNum">     400 </span>            :     }
<span class="lineNum">     401 </span>            : 
<span class="lineNum">     402 </span>            :   return false;
<span class="lineNum">     403 </span>            : }
<span class="lineNum">     404 </span>            : 
<span class="lineNum">     405 </span>            : /* Treat if_then_else insns, where the operands of both branches
<span class="lineNum">     406 </span>            :    are registers, as copies.  For instance,
<span class="lineNum">     407 </span>            :    Original :
<span class="lineNum">     408 </span>            :    (set (reg:SI a) (if_then_else (cond) (reg:SI b) (reg:SI c)))
<span class="lineNum">     409 </span>            :    Transformed :
<span class="lineNum">     410 </span>            :    (set (reg:DI a) (if_then_else (cond) (reg:DI b) (reg:DI c)))
<span class="lineNum">     411 </span>            :    DEF_INSN is the if_then_else insn.  */
<a name="412"><span class="lineNum">     412 </span>            : </a>
<span class="lineNum">     413 </span>            : static bool
<span class="lineNum">     414 </span><span class="lineCov">        520 : transform_ifelse (ext_cand *cand, rtx_insn *def_insn)</span>
<span class="lineNum">     415 </span>            : {
<span class="lineNum">     416 </span><span class="lineCov">        520 :   rtx set_insn = PATTERN (def_insn);</span>
<span class="lineNum">     417 </span><span class="lineCov">        520 :   rtx srcreg, dstreg, srcreg2;</span>
<span class="lineNum">     418 </span><span class="lineCov">        520 :   rtx map_srcreg, map_dstreg, map_srcreg2;</span>
<span class="lineNum">     419 </span><span class="lineCov">        520 :   rtx ifexpr;</span>
<span class="lineNum">     420 </span><span class="lineCov">        520 :   rtx cond;</span>
<span class="lineNum">     421 </span><span class="lineCov">        520 :   rtx new_set;</span>
<span class="lineNum">     422 </span>            : 
<span class="lineNum">     423 </span><span class="lineCov">        520 :   gcc_assert (GET_CODE (set_insn) == SET);</span>
<span class="lineNum">     424 </span>            : 
<span class="lineNum">     425 </span><span class="lineCov">        520 :   cond = XEXP (SET_SRC (set_insn), 0);</span>
<span class="lineNum">     426 </span><span class="lineCov">        520 :   dstreg = SET_DEST (set_insn);</span>
<span class="lineNum">     427 </span><span class="lineCov">        520 :   srcreg = XEXP (SET_SRC (set_insn), 1);</span>
<span class="lineNum">     428 </span><span class="lineCov">        520 :   srcreg2 = XEXP (SET_SRC (set_insn), 2);</span>
<span class="lineNum">     429 </span>            :   /* If the conditional move already has the right or wider mode,
<span class="lineNum">     430 </span>            :      there is nothing to do.  */
<span class="lineNum">     431 </span><span class="lineCov">        520 :   if (GET_MODE_UNIT_SIZE (GET_MODE (dstreg))</span>
<span class="lineNum">     432 </span><span class="lineCov">       1040 :       &gt;= GET_MODE_UNIT_SIZE (cand-&gt;mode))</span>
<span class="lineNum">     433 </span>            :     return true;
<span class="lineNum">     434 </span>            : 
<span class="lineNum">     435 </span><span class="lineCov">        988 :   map_srcreg = gen_rtx_REG (cand-&gt;mode, REGNO (srcreg));</span>
<span class="lineNum">     436 </span><span class="lineCov">        988 :   map_srcreg2 = gen_rtx_REG (cand-&gt;mode, REGNO (srcreg2));</span>
<span class="lineNum">     437 </span><span class="lineCov">        988 :   map_dstreg = gen_rtx_REG (cand-&gt;mode, REGNO (dstreg));</span>
<span class="lineNum">     438 </span><span class="lineCov">        494 :   ifexpr = gen_rtx_IF_THEN_ELSE (cand-&gt;mode, cond, map_srcreg, map_srcreg2);</span>
<span class="lineNum">     439 </span><span class="lineCov">        494 :   new_set = gen_rtx_SET (map_dstreg, ifexpr);</span>
<span class="lineNum">     440 </span>            : 
<span class="lineNum">     441 </span><span class="lineCov">        988 :   if (validate_change (def_insn, &amp;PATTERN (def_insn), new_set, true)</span>
<span class="lineNum">     442 </span><span class="lineCov">        494 :       &amp;&amp; update_reg_equal_equiv_notes (def_insn, cand-&gt;mode, GET_MODE (dstreg),</span>
<span class="lineNum">     443 </span>            :                                        cand-&gt;code))
<span class="lineNum">     444 </span>            :     {
<span class="lineNum">     445 </span><span class="lineCov">        494 :       if (dump_file)</span>
<span class="lineNum">     446 </span>            :         {
<span class="lineNum">     447 </span><span class="lineNoCov">          0 :           fprintf (dump_file,</span>
<span class="lineNum">     448 </span>            :                    &quot;Mode of conditional move instruction extended:\n&quot;);
<span class="lineNum">     449 </span><span class="lineNoCov">          0 :           print_rtl_single (dump_file, def_insn);</span>
<span class="lineNum">     450 </span>            :         }
<span class="lineNum">     451 </span><span class="lineCov">        494 :       return true;</span>
<span class="lineNum">     452 </span>            :     }
<span class="lineNum">     453 </span>            : 
<span class="lineNum">     454 </span>            :   return false;
<span class="lineNum">     455 </span>            : }
<span class="lineNum">     456 </span>            : 
<span class="lineNum">     457 </span>            : /* Get all the reaching definitions of an instruction.  The definitions are
<span class="lineNum">     458 </span>            :    desired for REG used in INSN.  Return the definition list or NULL if a
<span class="lineNum">     459 </span>            :    definition is missing.  If DEST is non-NULL, additionally push the INSN
<span class="lineNum">     460 </span>            :    of the definitions onto DEST.  */
<a name="461"><span class="lineNum">     461 </span>            : </a>
<span class="lineNum">     462 </span>            : static struct df_link *
<span class="lineNum">     463 </span><span class="lineCov">     433925 : get_defs (rtx_insn *insn, rtx reg, vec&lt;rtx_insn *&gt; *dest)</span>
<span class="lineNum">     464 </span>            : {
<span class="lineNum">     465 </span><span class="lineCov">     433925 :   df_ref use;</span>
<span class="lineNum">     466 </span><span class="lineCov">     433925 :   struct df_link *ref_chain, *ref_link;</span>
<span class="lineNum">     467 </span>            : 
<span class="lineNum">     468 </span><span class="lineCov">     437558 :   FOR_EACH_INSN_USE (use, insn)</span>
<span class="lineNum">     469 </span>            :     {
<span class="lineNum">     470 </span><span class="lineCov">     437558 :       if (GET_CODE (DF_REF_REG (use)) == SUBREG)</span>
<span class="lineNum">     471 </span>            :         return NULL;
<span class="lineNum">     472 </span><span class="lineCov">    1312674 :       if (REGNO (DF_REF_REG (use)) == REGNO (reg))</span>
<span class="lineNum">     473 </span>            :         break;
<span class="lineNum">     474 </span>            :     }
<span class="lineNum">     475 </span>            : 
<span class="lineNum">     476 </span><span class="lineCov">     433925 :   gcc_assert (use != NULL);</span>
<span class="lineNum">     477 </span>            : 
<span class="lineNum">     478 </span><span class="lineCov">     433925 :   ref_chain = DF_REF_CHAIN (use);</span>
<span class="lineNum">     479 </span>            : 
<span class="lineNum">     480 </span><span class="lineCov">     954770 :   for (ref_link = ref_chain; ref_link; ref_link = ref_link-&gt;next)</span>
<span class="lineNum">     481 </span>            :     {
<span class="lineNum">     482 </span>            :       /* Problem getting some definition for this instruction.  */
<span class="lineNum">     483 </span><span class="lineCov">     539272 :       if (ref_link-&gt;ref == NULL)</span>
<span class="lineNum">     484 </span>            :         return NULL;
<span class="lineNum">     485 </span><span class="lineCov">     539272 :       if (DF_REF_INSN_INFO (ref_link-&gt;ref) == NULL)</span>
<span class="lineNum">     486 </span>            :         return NULL;
<span class="lineNum">     487 </span>            :       /* As global regs are assumed to be defined at each function call
<span class="lineNum">     488 </span>            :          dataflow can report a call_insn as being a definition of REG.
<span class="lineNum">     489 </span>            :          But we can't do anything with that in this pass so proceed only
<span class="lineNum">     490 </span>            :          if the instruction really sets REG in a way that can be deduced
<span class="lineNum">     491 </span>            :          from the RTL structure.  */
<span class="lineNum">     492 </span><span class="lineCov">     520845 :       if (global_regs[REGNO (reg)]</span>
<span class="lineNum">     493 </span><span class="lineCov">     520845 :           &amp;&amp; !set_of (reg, DF_REF_INSN (ref_link-&gt;ref)))</span>
<span class="lineNum">     494 </span>            :         return NULL;
<span class="lineNum">     495 </span>            :     }
<span class="lineNum">     496 </span>            : 
<span class="lineNum">     497 </span><span class="lineCov">     415498 :   if (dest)</span>
<span class="lineNum">     498 </span><span class="lineCov">     469760 :     for (ref_link = ref_chain; ref_link; ref_link = ref_link-&gt;next)</span>
<span class="lineNum">     499 </span><span class="lineCov">     261171 :       dest-&gt;safe_push (DF_REF_INSN (ref_link-&gt;ref));</span>
<span class="lineNum">     500 </span>            : 
<span class="lineNum">     501 </span>            :   return ref_chain;
<span class="lineNum">     502 </span>            : }
<span class="lineNum">     503 </span>            : 
<span class="lineNum">     504 </span>            : /* Get all the reaching uses of an instruction.  The uses are desired for REG
<span class="lineNum">     505 </span>            :    set in INSN.  Return use list or NULL if a use is missing or irregular.  */
<a name="506"><span class="lineNum">     506 </span>            : </a>
<span class="lineNum">     507 </span>            : static struct df_link *
<span class="lineNum">     508 </span><span class="lineNoCov">          0 : get_uses (rtx_insn *insn, rtx reg)</span>
<span class="lineNum">     509 </span>            : {
<span class="lineNum">     510 </span><span class="lineNoCov">          0 :   df_ref def;</span>
<span class="lineNum">     511 </span><span class="lineNoCov">          0 :   struct df_link *ref_chain, *ref_link;</span>
<span class="lineNum">     512 </span>            : 
<span class="lineNum">     513 </span><span class="lineNoCov">          0 :   FOR_EACH_INSN_DEF (def, insn)</span>
<span class="lineNum">     514 </span><span class="lineNoCov">          0 :     if (REGNO (DF_REF_REG (def)) == REGNO (reg))</span>
<span class="lineNum">     515 </span>            :       break;
<span class="lineNum">     516 </span>            : 
<span class="lineNum">     517 </span><span class="lineNoCov">          0 :   gcc_assert (def != NULL);</span>
<span class="lineNum">     518 </span>            : 
<span class="lineNum">     519 </span><span class="lineNoCov">          0 :   ref_chain = DF_REF_CHAIN (def);</span>
<span class="lineNum">     520 </span>            : 
<span class="lineNum">     521 </span><span class="lineNoCov">          0 :   for (ref_link = ref_chain; ref_link; ref_link = ref_link-&gt;next)</span>
<span class="lineNum">     522 </span>            :     {
<span class="lineNum">     523 </span>            :       /* Problem getting some use for this instruction.  */
<span class="lineNum">     524 </span><span class="lineNoCov">          0 :       if (ref_link-&gt;ref == NULL)</span>
<span class="lineNum">     525 </span>            :         return NULL;
<span class="lineNum">     526 </span><span class="lineNoCov">          0 :       if (DF_REF_CLASS (ref_link-&gt;ref) != DF_REF_REGULAR)</span>
<span class="lineNum">     527 </span>            :         return NULL;
<span class="lineNum">     528 </span>            :     }
<span class="lineNum">     529 </span>            : 
<span class="lineNum">     530 </span>            :   return ref_chain;
<span class="lineNum">     531 </span>            : }
<span class="lineNum">     532 </span>            : 
<span class="lineNum">     533 </span>            : /* Return true if INSN is
<span class="lineNum">     534 </span>            :      (SET (reg REGNO (def_reg)) (if_then_else (cond) (REG x1) (REG x2)))
<span class="lineNum">     535 </span>            :    and store x1 and x2 in REG_1 and REG_2.  */
<a name="536"><span class="lineNum">     536 </span>            : </a>
<span class="lineNum">     537 </span>            : static bool
<span class="lineNum">     538 </span><span class="lineCov">     260904 : is_cond_copy_insn (rtx_insn *insn, rtx *reg1, rtx *reg2)</span>
<span class="lineNum">     539 </span>            : {
<span class="lineNum">     540 </span><span class="lineCov">     260904 :   rtx expr = single_set (insn);</span>
<span class="lineNum">     541 </span>            : 
<span class="lineNum">     542 </span><span class="lineCov">     260904 :   if (expr != NULL_RTX</span>
<span class="lineNum">     543 </span><span class="lineCov">     255080 :       &amp;&amp; GET_CODE (expr) == SET</span>
<span class="lineNum">     544 </span><span class="lineCov">     255080 :       &amp;&amp; GET_CODE (SET_DEST (expr)) == REG</span>
<span class="lineNum">     545 </span><span class="lineCov">     254712 :       &amp;&amp; GET_CODE (SET_SRC (expr))  == IF_THEN_ELSE</span>
<span class="lineNum">     546 </span><span class="lineCov">       2561 :       &amp;&amp; GET_CODE (XEXP (SET_SRC (expr), 1)) == REG</span>
<span class="lineNum">     547 </span><span class="lineCov">       2489 :       &amp;&amp; GET_CODE (XEXP (SET_SRC (expr), 2)) == REG)</span>
<span class="lineNum">     548 </span>            :     {
<span class="lineNum">     549 </span><span class="lineCov">       2228 :       *reg1 = XEXP (SET_SRC (expr), 1);</span>
<span class="lineNum">     550 </span><span class="lineCov">       2228 :       *reg2 = XEXP (SET_SRC (expr), 2);</span>
<span class="lineNum">     551 </span><span class="lineCov">       2228 :       return true;</span>
<span class="lineNum">     552 </span>            :     }
<span class="lineNum">     553 </span>            : 
<span class="lineNum">     554 </span>            :   return false;
<span class="lineNum">     555 </span>            : }
<span class="lineNum">     556 </span>            : 
<span class="lineNum">     557 </span>            : enum ext_modified_kind
<span class="lineNum">     558 </span>            : {
<span class="lineNum">     559 </span>            :   /* The insn hasn't been modified by ree pass yet.  */
<span class="lineNum">     560 </span>            :   EXT_MODIFIED_NONE,
<span class="lineNum">     561 </span>            :   /* Changed into zero extension.  */
<span class="lineNum">     562 </span>            :   EXT_MODIFIED_ZEXT,
<span class="lineNum">     563 </span>            :   /* Changed into sign extension.  */
<span class="lineNum">     564 </span>            :   EXT_MODIFIED_SEXT
<span class="lineNum">     565 </span>            : };
<span class="lineNum">     566 </span>            : 
<span class="lineNum">     567 </span>            : struct ATTRIBUTE_PACKED ext_modified
<span class="lineNum">     568 </span>            : {
<span class="lineNum">     569 </span>            :   /* Mode from which ree has zero or sign extended the destination.  */
<span class="lineNum">     570 </span>            :   ENUM_BITFIELD(machine_mode) mode : 8;
<span class="lineNum">     571 </span>            : 
<span class="lineNum">     572 </span>            :   /* Kind of modification of the insn.  */
<span class="lineNum">     573 </span>            :   ENUM_BITFIELD(ext_modified_kind) kind : 2;
<span class="lineNum">     574 </span>            : 
<span class="lineNum">     575 </span>            :   unsigned int do_not_reextend : 1;
<span class="lineNum">     576 </span>            : 
<span class="lineNum">     577 </span>            :   /* True if the insn is scheduled to be deleted.  */
<span class="lineNum">     578 </span>            :   unsigned int deleted : 1;
<span class="lineNum">     579 </span>            : };
<span class="lineNum">     580 </span>            : 
<span class="lineNum">     581 </span>            : /* Vectors used by combine_reaching_defs and its helpers.  */
<span class="lineNum">     582 </span><span class="lineCov">    1751538 : struct ext_state</span>
<span class="lineNum">     583 </span>            : {
<span class="lineNum">     584 </span>            :   /* In order to avoid constant alloc/free, we keep these
<span class="lineNum">     585 </span>            :      4 vectors live through the entire find_and_remove_re and just
<span class="lineNum">     586 </span>            :      truncate them each time.  */
<span class="lineNum">     587 </span>            :   auto_vec&lt;rtx_insn *&gt; defs_list;
<span class="lineNum">     588 </span>            :   auto_vec&lt;rtx_insn *&gt; copies_list;
<span class="lineNum">     589 </span>            :   auto_vec&lt;rtx_insn *&gt; modified_list;
<span class="lineNum">     590 </span>            :   auto_vec&lt;rtx_insn *&gt; work_list;
<span class="lineNum">     591 </span>            : 
<span class="lineNum">     592 </span>            :   /* For instructions that have been successfully modified, this is
<span class="lineNum">     593 </span>            :      the original mode from which the insn is extending and
<span class="lineNum">     594 </span>            :      kind of extension.  */
<span class="lineNum">     595 </span>            :   struct ext_modified *modified;
<span class="lineNum">     596 </span>            : };
<span class="lineNum">     597 </span>            : 
<span class="lineNum">     598 </span>            : /* Reaching Definitions of the extended register could be conditional copies
<span class="lineNum">     599 </span>            :    or regular definitions.  This function separates the two types into two
<span class="lineNum">     600 </span>            :    lists, STATE-&gt;DEFS_LIST and STATE-&gt;COPIES_LIST.  This is necessary because,
<span class="lineNum">     601 </span>            :    if a reaching definition is a conditional copy, merging the extension with
<span class="lineNum">     602 </span>            :    this definition is wrong.  Conditional copies are merged by transitively
<span class="lineNum">     603 </span>            :    merging their definitions.  The defs_list is populated with all the reaching
<span class="lineNum">     604 </span>            :    definitions of the extension instruction (EXTEND_INSN) which must be merged
<span class="lineNum">     605 </span>            :    with an extension.  The copies_list contains all the conditional moves that
<span class="lineNum">     606 </span>            :    will later be extended into a wider mode conditional move if all the merges
<span class="lineNum">     607 </span>            :    are successful.  The function returns false upon failure, true upon
<span class="lineNum">     608 </span>            :    success.  */
<span class="lineNum">     609 </span>            : 
<span class="lineNum">     610 </span>            : static bool
<span class="lineNum">     611 </span><span class="lineCov">     204385 : make_defs_and_copies_lists (rtx_insn *extend_insn, const_rtx set_pat,</span>
<span class="lineNum">     612 </span>            :                             ext_state *state)
<span class="lineNum">     613 </span>            : {
<span class="lineNum">     614 </span><span class="lineCov">     204385 :   rtx src_reg = XEXP (SET_SRC (set_pat), 0);</span>
<span class="lineNum">     615 </span><span class="lineCov">     204385 :   bool *is_insn_visited;</span>
<span class="lineNum">     616 </span><span class="lineCov">     204385 :   bool ret = true;</span>
<span class="lineNum">     617 </span>            : 
<span class="lineNum">     618 </span><span class="lineCov">     204385 :   state-&gt;work_list.truncate (0);</span>
<span class="lineNum">     619 </span>            : 
<span class="lineNum">     620 </span>            :   /* Initialize the work list.  */
<span class="lineNum">     621 </span><span class="lineCov">     204385 :   if (!get_defs (extend_insn, src_reg, &amp;state-&gt;work_list))</span>
<span class="lineNum">     622 </span>            :     return false;
<span class="lineNum">     623 </span>            : 
<span class="lineNum">     624 </span><span class="lineCov">     204385 :   is_insn_visited = XCNEWVEC (bool, max_insn_uid);</span>
<span class="lineNum">     625 </span>            : 
<span class="lineNum">     626 </span>            :   /* Perform transitive closure for conditional copies.  */
<span class="lineNum">     627 </span><span class="lineCov">     465417 :   while (!state-&gt;work_list.is_empty ())</span>
<span class="lineNum">     628 </span>            :     {
<span class="lineNum">     629 </span><span class="lineCov">     261161 :       rtx_insn *def_insn = state-&gt;work_list.pop ();</span>
<span class="lineNum">     630 </span><span class="lineCov">     261161 :       rtx reg1, reg2;</span>
<span class="lineNum">     631 </span>            : 
<span class="lineNum">     632 </span><span class="lineCov">     261161 :       gcc_assert (INSN_UID (def_insn) &lt; max_insn_uid);</span>
<span class="lineNum">     633 </span>            : 
<span class="lineNum">     634 </span><span class="lineCov">     522322 :       if (is_insn_visited[INSN_UID (def_insn)])</span>
<span class="lineNum">     635 </span><span class="lineCov">        257 :         continue;</span>
<span class="lineNum">     636 </span><span class="lineCov">     260904 :       is_insn_visited[INSN_UID (def_insn)] = true;</span>
<span class="lineNum">     637 </span>            : 
<span class="lineNum">     638 </span><span class="lineCov">     260904 :       if (is_cond_copy_insn (def_insn, &amp;reg1, &amp;reg2))</span>
<span class="lineNum">     639 </span>            :         {
<span class="lineNum">     640 </span>            :           /* Push it onto the copy list first.  */
<span class="lineNum">     641 </span><span class="lineCov">       2228 :           state-&gt;copies_list.safe_push (def_insn);</span>
<span class="lineNum">     642 </span>            : 
<span class="lineNum">     643 </span>            :           /* Now perform the transitive closure.  */
<span class="lineNum">     644 </span><span class="lineCov">       2228 :           if (!get_defs (def_insn, reg1, &amp;state-&gt;work_list)</span>
<span class="lineNum">     645 </span><span class="lineCov">       2228 :               || !get_defs (def_insn, reg2, &amp;state-&gt;work_list))</span>
<span class="lineNum">     646 </span>            :             {
<span class="lineNum">     647 </span><span class="lineCov">        129 :               ret = false;</span>
<span class="lineNum">     648 </span><span class="lineCov">        129 :               break;</span>
<span class="lineNum">     649 </span>            :             }
<span class="lineNum">     650 </span>            :         }
<span class="lineNum">     651 </span>            :       else
<span class="lineNum">     652 </span><span class="lineCov">     258676 :         state-&gt;defs_list.safe_push (def_insn);</span>
<span class="lineNum">     653 </span>            :     }
<span class="lineNum">     654 </span>            : 
<span class="lineNum">     655 </span><span class="lineCov">     204385 :   XDELETEVEC (is_insn_visited);</span>
<span class="lineNum">     656 </span>            : 
<span class="lineNum">     657 </span><span class="lineCov">     204385 :   return ret;</span>
<span class="lineNum">     658 </span>            : }
<span class="lineNum">     659 </span>            : 
<span class="lineNum">     660 </span>            : /* If DEF_INSN has single SET expression, possibly buried inside
<span class="lineNum">     661 </span>            :    a PARALLEL, return the address of the SET expression, else
<span class="lineNum">     662 </span>            :    return NULL.  This is similar to single_set, except that
<a name="663"><span class="lineNum">     663 </span>            :    single_set allows multiple SETs when all but one is dead.  */</a>
<span class="lineNum">     664 </span>            : static rtx *
<span class="lineNum">     665 </span><span class="lineCov">     229646 : get_sub_rtx (rtx_insn *def_insn)</span>
<span class="lineNum">     666 </span>            : {
<span class="lineNum">     667 </span><span class="lineCov">     229646 :   enum rtx_code code = GET_CODE (PATTERN (def_insn));</span>
<span class="lineNum">     668 </span><span class="lineCov">     229646 :   rtx *sub_rtx = NULL;</span>
<span class="lineNum">     669 </span>            : 
<span class="lineNum">     670 </span><span class="lineCov">     229646 :   if (code == PARALLEL)</span>
<span class="lineNum">     671 </span>            :     {
<span class="lineNum">     672 </span><span class="lineCov">     251990 :       for (int i = 0; i &lt; XVECLEN (PATTERN (def_insn), 0); i++)</span>
<span class="lineNum">     673 </span>            :         {
<span class="lineNum">     674 </span><span class="lineCov">     127767 :           rtx s_expr = XVECEXP (PATTERN (def_insn), 0, i);</span>
<span class="lineNum">     675 </span><span class="lineCov">     127767 :           if (GET_CODE (s_expr) != SET)</span>
<span class="lineNum">     676 </span>            :             continue;
<span class="lineNum">     677 </span>            : 
<span class="lineNum">     678 </span><span class="lineCov">      67162 :           if (sub_rtx == NULL)</span>
<span class="lineNum">     679 </span><span class="lineCov">     127590 :             sub_rtx = &amp;XVECEXP (PATTERN (def_insn), 0, i);</span>
<span class="lineNum">     680 </span>            :           else
<span class="lineNum">     681 </span>            :             {
<span class="lineNum">     682 </span>            :               /* PARALLEL with multiple SETs.  */
<span class="lineNum">     683 </span>            :               return NULL;
<span class="lineNum">     684 </span>            :             }
<span class="lineNum">     685 </span>            :         }
<span class="lineNum">     686 </span>            :     }
<span class="lineNum">     687 </span><span class="lineCov">     165851 :   else if (code == SET)</span>
<span class="lineNum">     688 </span><span class="lineCov">     331702 :     sub_rtx = &amp;PATTERN (def_insn);</span>
<span class="lineNum">     689 </span>            :   else
<span class="lineNum">     690 </span>            :     {
<span class="lineNum">     691 </span>            :       /* It is not a PARALLEL or a SET, what could it be ? */
<span class="lineNum">     692 </span>            :       return NULL;
<span class="lineNum">     693 </span>            :     }
<span class="lineNum">     694 </span>            : 
<span class="lineNum">     695 </span><span class="lineCov">     226279 :   gcc_assert (sub_rtx != NULL);</span>
<span class="lineNum">     696 </span>            :   return sub_rtx;
<span class="lineNum">     697 </span>            : }
<span class="lineNum">     698 </span>            : 
<span class="lineNum">     699 </span>            : /* Merge the DEF_INSN with an extension.  Calls combine_set_extension
<span class="lineNum">     700 </span>            :    on the SET pattern.  */
<a name="701"><span class="lineNum">     701 </span>            : </a>
<span class="lineNum">     702 </span>            : static bool
<span class="lineNum">     703 </span><span class="lineCov">     172252 : merge_def_and_ext (ext_cand *cand, rtx_insn *def_insn, ext_state *state)</span>
<span class="lineNum">     704 </span>            : {
<span class="lineNum">     705 </span><span class="lineCov">     172252 :   machine_mode ext_src_mode;</span>
<span class="lineNum">     706 </span><span class="lineCov">     172252 :   rtx *sub_rtx;</span>
<span class="lineNum">     707 </span>            : 
<span class="lineNum">     708 </span><span class="lineCov">     172252 :   ext_src_mode = GET_MODE (XEXP (SET_SRC (cand-&gt;expr), 0));</span>
<span class="lineNum">     709 </span><span class="lineCov">     172252 :   sub_rtx = get_sub_rtx (def_insn);</span>
<span class="lineNum">     710 </span>            : 
<span class="lineNum">     711 </span><span class="lineCov">     172252 :   if (sub_rtx == NULL)</span>
<span class="lineNum">     712 </span>            :     return false;
<span class="lineNum">     713 </span>            : 
<span class="lineNum">     714 </span><span class="lineCov">     169568 :   if (REG_P (SET_DEST (*sub_rtx))</span>
<span class="lineNum">     715 </span><span class="lineCov">     169568 :       &amp;&amp; (GET_MODE (SET_DEST (*sub_rtx)) == ext_src_mode</span>
<span class="lineNum">     716 </span><span class="lineCov">      48418 :           || ((state-&gt;modified[INSN_UID (def_insn)].kind</span>
<span class="lineNum">     717 </span><span class="lineCov">      24209 :                == (cand-&gt;code == ZERO_EXTEND</span>
<span class="lineNum">     718 </span><span class="lineCov">      24209 :                    ? EXT_MODIFIED_ZEXT : EXT_MODIFIED_SEXT))</span>
<span class="lineNum">     719 </span><span class="lineCov">       3264 :               &amp;&amp; state-&gt;modified[INSN_UID (def_insn)].mode</span>
<span class="lineNum">     720 </span>            :                  == ext_src_mode)))
<span class="lineNum">     721 </span>            :     {
<span class="lineNum">     722 </span><span class="lineCov">     146845 :       if (GET_MODE_UNIT_SIZE (GET_MODE (SET_DEST (*sub_rtx)))</span>
<span class="lineNum">     723 </span><span class="lineCov">     293690 :           &gt;= GET_MODE_UNIT_SIZE (cand-&gt;mode))</span>
<span class="lineNum">     724 </span>            :         return true;
<span class="lineNum">     725 </span>            :       /* If def_insn is already scheduled to be deleted, don't attempt
<span class="lineNum">     726 </span>            :          to modify it.  */
<span class="lineNum">     727 </span><span class="lineCov">     145621 :       if (state-&gt;modified[INSN_UID (def_insn)].deleted)</span>
<span class="lineNum">     728 </span>            :         return false;
<span class="lineNum">     729 </span><span class="lineCov">     145608 :       if (combine_set_extension (cand, def_insn, sub_rtx))</span>
<span class="lineNum">     730 </span>            :         {
<span class="lineNum">     731 </span><span class="lineCov">     134283 :           if (state-&gt;modified[INSN_UID (def_insn)].kind == EXT_MODIFIED_NONE)</span>
<span class="lineNum">     732 </span><span class="lineCov">     267774 :             state-&gt;modified[INSN_UID (def_insn)].mode = ext_src_mode;</span>
<span class="lineNum">     733 </span><span class="lineCov">     134283 :           return true;</span>
<span class="lineNum">     734 </span>            :         }
<span class="lineNum">     735 </span>            :     }
<span class="lineNum">     736 </span>            : 
<span class="lineNum">     737 </span>            :   return false;
<span class="lineNum">     738 </span>            : }
<span class="lineNum">     739 </span>            : 
<span class="lineNum">     740 </span>            : /* Given SRC, which should be one or more extensions of a REG, strip
<span class="lineNum">     741 </span>            :    away the extensions and return the REG.  */
<a name="742"><span class="lineNum">     742 </span>            : </a>
<span class="lineNum">     743 </span>            : static inline rtx
<span class="lineNum">     744 </span><span class="lineCov">     242665 : get_extended_src_reg (rtx src)</span>
<span class="lineNum">     745 </span>            : {
<span class="lineNum">     746 </span><span class="lineCov">     485330 :   while (GET_CODE (src) == SIGN_EXTEND || GET_CODE (src) == ZERO_EXTEND)</span>
<span class="lineNum">     747 </span><span class="lineCov">     242665 :     src = XEXP (src, 0);</span>
<span class="lineNum">     748 </span><span class="lineCov">     242665 :   gcc_assert (REG_P (src));</span>
<span class="lineNum">     749 </span><span class="lineCov">     242665 :   return src;</span>
<span class="lineNum">     750 </span>            : }
<span class="lineNum">     751 </span>            : 
<span class="lineNum">     752 </span>            : /* This function goes through all reaching defs of the source
<span class="lineNum">     753 </span>            :    of the candidate for elimination (CAND) and tries to combine
<span class="lineNum">     754 </span>            :    the extension with the definition instruction.  The changes
<span class="lineNum">     755 </span>            :    are made as a group so that even if one definition cannot be
<span class="lineNum">     756 </span>            :    merged, all reaching definitions end up not being merged.
<span class="lineNum">     757 </span>            :    When a conditional copy is encountered, merging is attempted
<span class="lineNum">     758 </span>            :    transitively on its definitions.  It returns true upon success
<span class="lineNum">     759 </span>            :    and false upon failure.  */
<span class="lineNum">     760 </span>            : 
<span class="lineNum">     761 </span>            : static bool
<span class="lineNum">     762 </span><span class="lineCov">     204385 : combine_reaching_defs (ext_cand *cand, const_rtx set_pat, ext_state *state)</span>
<span class="lineNum">     763 </span>            : {
<span class="lineNum">     764 </span><span class="lineCov">     204385 :   rtx_insn *def_insn;</span>
<span class="lineNum">     765 </span><span class="lineCov">     204385 :   bool merge_successful = true;</span>
<span class="lineNum">     766 </span><span class="lineCov">     204385 :   int i;</span>
<span class="lineNum">     767 </span><span class="lineCov">     204385 :   int defs_ix;</span>
<span class="lineNum">     768 </span><span class="lineCov">     204385 :   bool outcome;</span>
<span class="lineNum">     769 </span>            : 
<span class="lineNum">     770 </span><span class="lineCov">     204385 :   state-&gt;defs_list.truncate (0);</span>
<span class="lineNum">     771 </span><span class="lineCov">     204385 :   state-&gt;copies_list.truncate (0);</span>
<span class="lineNum">     772 </span>            : 
<span class="lineNum">     773 </span><span class="lineCov">     204385 :   outcome = make_defs_and_copies_lists (cand-&gt;insn, set_pat, state);</span>
<span class="lineNum">     774 </span>            : 
<span class="lineNum">     775 </span><span class="lineCov">     204385 :   if (!outcome)</span>
<span class="lineNum">     776 </span>            :     return false;
<span class="lineNum">     777 </span>            : 
<span class="lineNum">     778 </span>            :   /* If the destination operand of the extension is a different
<span class="lineNum">     779 </span>            :      register than the source operand, then additional restrictions
<span class="lineNum">     780 </span>            :      are needed.  Note we have to handle cases where we have nested
<span class="lineNum">     781 </span>            :      extensions in the source operand.  */
<span class="lineNum">     782 </span><span class="lineCov">     204256 :   bool copy_needed</span>
<span class="lineNum">     783 </span><span class="lineCov">     408512 :     = (REGNO (SET_DEST (PATTERN (cand-&gt;insn)))</span>
<span class="lineNum">     784 </span><span class="lineCov">     408512 :        != REGNO (get_extended_src_reg (SET_SRC (PATTERN (cand-&gt;insn)))));</span>
<span class="lineNum">     785 </span><span class="lineCov">     204256 :   if (copy_needed)</span>
<span class="lineNum">     786 </span>            :     {
<span class="lineNum">     787 </span>            :       /* Considering transformation of
<span class="lineNum">     788 </span>            :          (set (reg1) (expression))
<span class="lineNum">     789 </span>            :          ...
<span class="lineNum">     790 </span>            :          (set (reg2) (any_extend (reg1)))
<span class="lineNum">     791 </span>            : 
<span class="lineNum">     792 </span>            :          into
<span class="lineNum">     793 </span>            : 
<span class="lineNum">     794 </span>            :          (set (reg2) (any_extend (expression)))
<span class="lineNum">     795 </span>            :          (set (reg1) (reg2))
<span class="lineNum">     796 </span>            :          ...  */
<span class="lineNum">     797 </span>            : 
<span class="lineNum">     798 </span>            :       /* In theory we could handle more than one reaching def, it
<span class="lineNum">     799 </span>            :          just makes the code to update the insn stream more complex.  */
<span class="lineNum">     800 </span><span class="lineCov">      81989 :       if (state-&gt;defs_list.length () != 1)</span>
<span class="lineNum">     801 </span><span class="lineCov">      43616 :         return false;</span>
<span class="lineNum">     802 </span>            : 
<span class="lineNum">     803 </span>            :       /* We don't have the structure described above if there are
<span class="lineNum">     804 </span>            :          conditional moves in between the def and the candidate,
<span class="lineNum">     805 </span>            :          and we will not handle them correctly.  See PR68194.  */
<span class="lineNum">     806 </span><span class="lineCov">      63376 :       if (state-&gt;copies_list.length () &gt; 0)</span>
<span class="lineNum">     807 </span>            :         return false;
<span class="lineNum">     808 </span>            : 
<span class="lineNum">     809 </span>            :       /* We require the candidate not already be modified.  It may,
<span class="lineNum">     810 </span>            :          for example have been changed from a (sign_extend (reg))
<span class="lineNum">     811 </span>            :          into (zero_extend (sign_extend (reg))).
<span class="lineNum">     812 </span>            : 
<span class="lineNum">     813 </span>            :          Handling that case shouldn't be terribly difficult, but the code
<span class="lineNum">     814 </span>            :          here and the code to emit copies would need auditing.  Until
<span class="lineNum">     815 </span>            :          we see a need, this is the safe thing to do.  */
<span class="lineNum">     816 </span><span class="lineCov">      63363 :       if (state-&gt;modified[INSN_UID (cand-&gt;insn)].kind != EXT_MODIFIED_NONE)</span>
<span class="lineNum">     817 </span>            :         return false;
<span class="lineNum">     818 </span>            : 
<span class="lineNum">     819 </span><span class="lineCov">      63360 :       machine_mode dst_mode = GET_MODE (SET_DEST (PATTERN (cand-&gt;insn)));</span>
<span class="lineNum">     820 </span><span class="lineCov">      63360 :       rtx src_reg = get_extended_src_reg (SET_SRC (PATTERN (cand-&gt;insn)));</span>
<span class="lineNum">     821 </span>            : 
<span class="lineNum">     822 </span>            :       /* Ensure we can use the src_reg in dst_mode (needed for
<span class="lineNum">     823 </span>            :          the (set (reg1) (reg2)) insn mentioned above).  */
<span class="lineNum">     824 </span><span class="lineCov">     126720 :       if (!targetm.hard_regno_mode_ok (REGNO (src_reg), dst_mode))</span>
<span class="lineNum">     825 </span>            :         return false;
<span class="lineNum">     826 </span>            : 
<span class="lineNum">     827 </span>            :       /* Ensure the number of hard registers of the copy match.  */
<span class="lineNum">     828 </span><span class="lineCov">     190056 :       if (hard_regno_nregs (REGNO (src_reg), dst_mode) != REG_NREGS (src_reg))</span>
<span class="lineNum">     829 </span>            :         return false;
<span class="lineNum">     830 </span>            : 
<span class="lineNum">     831 </span>            :       /* There's only one reaching def.  */
<span class="lineNum">     832 </span><span class="lineCov">      63352 :       rtx_insn *def_insn = state-&gt;defs_list[0];</span>
<span class="lineNum">     833 </span>            : 
<span class="lineNum">     834 </span>            :       /* The defining statement must not have been modified either.  */
<span class="lineNum">     835 </span><span class="lineCov">      63352 :       if (state-&gt;modified[INSN_UID (def_insn)].kind != EXT_MODIFIED_NONE)</span>
<span class="lineNum">     836 </span>            :         return false;
<span class="lineNum">     837 </span>            : 
<span class="lineNum">     838 </span>            :       /* The defining statement and candidate insn must be in the same block.
<span class="lineNum">     839 </span>            :          This is merely to keep the test for safety and updating the insn
<span class="lineNum">     840 </span>            :          stream simple.  Also ensure that within the block the candidate
<span class="lineNum">     841 </span>            :          follows the defining insn.  */
<span class="lineNum">     842 </span><span class="lineCov">      61704 :       basic_block bb = BLOCK_FOR_INSN (cand-&gt;insn);</span>
<span class="lineNum">     843 </span><span class="lineCov">      61704 :       if (bb != BLOCK_FOR_INSN (def_insn)</span>
<span class="lineNum">     844 </span><span class="lineCov">      61704 :           || DF_INSN_LUID (def_insn) &gt; DF_INSN_LUID (cand-&gt;insn))</span>
<span class="lineNum">     845 </span>            :         return false;
<span class="lineNum">     846 </span>            : 
<span class="lineNum">     847 </span>            :       /* If there is an overlap between the destination of DEF_INSN and
<span class="lineNum">     848 </span>            :          CAND-&gt;insn, then this transformation is not safe.  Note we have
<span class="lineNum">     849 </span>            :          to test in the widened mode.  */
<span class="lineNum">     850 </span><span class="lineCov">      43035 :       rtx *dest_sub_rtx = get_sub_rtx (def_insn);</span>
<span class="lineNum">     851 </span><span class="lineCov">      43035 :       if (dest_sub_rtx == NULL</span>
<span class="lineNum">     852 </span><span class="lineCov">      42352 :           || !REG_P (SET_DEST (*dest_sub_rtx)))</span>
<span class="lineNum">     853 </span>            :         return false;
<span class="lineNum">     854 </span>            : 
<span class="lineNum">     855 </span><span class="lineCov">     127005 :       rtx tmp_reg = gen_rtx_REG (GET_MODE (SET_DEST (PATTERN (cand-&gt;insn))),</span>
<span class="lineNum">     856 </span>            :                                  REGNO (SET_DEST (*dest_sub_rtx)));
<span class="lineNum">     857 </span><span class="lineCov">      84670 :       if (reg_overlap_mentioned_p (tmp_reg, SET_DEST (PATTERN (cand-&gt;insn))))</span>
<span class="lineNum">     858 </span>            :         return false;
<span class="lineNum">     859 </span>            : 
<span class="lineNum">     860 </span>            :       /* On RISC machines we must make sure that changing the mode of SRC_REG
<span class="lineNum">     861 </span>            :          as destination register will not affect its reaching uses, which may
<span class="lineNum">     862 </span>            :          read its value in a larger mode because DEF_INSN implicitly sets it
<span class="lineNum">     863 </span>            :          in word mode.  */
<span class="lineNum">     864 </span><span class="lineCov">      42335 :       poly_int64 prec</span>
<span class="lineNum">     865 </span><span class="lineCov">      84670 :         = GET_MODE_PRECISION (GET_MODE (SET_DEST (*dest_sub_rtx)));</span>
<span class="lineNum">     866 </span><span class="lineCov">      42335 :       if (WORD_REGISTER_OPERATIONS &amp;&amp; known_lt (prec, BITS_PER_WORD))</span>
<span class="lineNum">     867 </span>            :         {
<span class="lineNum">     868 </span>            :           struct df_link *uses = get_uses (def_insn, src_reg);
<span class="lineNum">     869 </span>            :           if (!uses)
<span class="lineNum">     870 </span>            :             return false;
<span class="lineNum">     871 </span>            : 
<span class="lineNum">     872 </span>            :           for (df_link *use = uses; use; use = use-&gt;next)
<span class="lineNum">     873 </span>            :             if (paradoxical_subreg_p (GET_MODE (*DF_REF_LOC (use-&gt;ref)),
<span class="lineNum">     874 </span>            :                                       GET_MODE (SET_DEST (*dest_sub_rtx))))
<span class="lineNum">     875 </span>            :               return false;
<span class="lineNum">     876 </span>            :         }
<span class="lineNum">     877 </span>            : 
<span class="lineNum">     878 </span>            :       /* The destination register of the extension insn must not be
<span class="lineNum">     879 </span>            :          used or set between the def_insn and cand-&gt;insn exclusive.  */
<span class="lineNum">     880 </span><span class="lineCov">      42335 :       if (reg_used_between_p (SET_DEST (PATTERN (cand-&gt;insn)),</span>
<span class="lineNum">     881 </span><span class="lineCov">      42335 :                               def_insn, cand-&gt;insn)</span>
<span class="lineNum">     882 </span><span class="lineCov">      42335 :           || reg_set_between_p (SET_DEST (PATTERN (cand-&gt;insn)),</span>
<span class="lineNum">     883 </span><span class="lineCov">      39011 :                                 def_insn, cand-&gt;insn))</span>
<span class="lineNum">     884 </span><span class="lineCov">       3926 :         return false;</span>
<span class="lineNum">     885 </span>            : 
<span class="lineNum">     886 </span>            :       /* We must be able to copy between the two registers.   Generate,
<span class="lineNum">     887 </span>            :          recognize and verify constraints of the copy.  Also fail if this
<span class="lineNum">     888 </span>            :          generated more than one insn.
<span class="lineNum">     889 </span>            : 
<span class="lineNum">     890 </span>            :          This generates garbage since we throw away the insn when we're
<span class="lineNum">     891 </span>            :          done, only to recreate it later if this test was successful. 
<span class="lineNum">     892 </span>            : 
<span class="lineNum">     893 </span>            :          Make sure to get the mode from the extension (cand-&gt;insn).  This
<span class="lineNum">     894 </span>            :          is different than in the code to emit the copy as we have not
<span class="lineNum">     895 </span>            :          modified the defining insn yet.  */
<span class="lineNum">     896 </span><span class="lineCov">      38409 :       start_sequence ();</span>
<span class="lineNum">     897 </span><span class="lineCov">      38409 :       rtx pat = PATTERN (cand-&gt;insn);</span>
<span class="lineNum">     898 </span><span class="lineCov">      76818 :       rtx new_dst = gen_rtx_REG (GET_MODE (SET_DEST (pat)),</span>
<span class="lineNum">     899 </span><span class="lineCov">      38409 :                                  REGNO (get_extended_src_reg (SET_SRC (pat))));</span>
<span class="lineNum">     900 </span><span class="lineCov">      38409 :       rtx new_src = gen_rtx_REG (GET_MODE (SET_DEST (pat)),</span>
<span class="lineNum">     901 </span><span class="lineCov">      38409 :                                  REGNO (SET_DEST (pat)));</span>
<span class="lineNum">     902 </span><span class="lineCov">      38409 :       emit_move_insn (new_dst, new_src);</span>
<span class="lineNum">     903 </span>            : 
<span class="lineNum">     904 </span><span class="lineCov">      38409 :       rtx_insn *insn = get_insns ();</span>
<span class="lineNum">     905 </span><span class="lineCov">      38409 :       end_sequence ();</span>
<span class="lineNum">     906 </span><span class="lineCov">      38409 :       if (NEXT_INSN (insn))</span>
<span class="lineNum">     907 </span>            :         return false;
<span class="lineNum">     908 </span><span class="lineCov">      76818 :       if (recog_memoized (insn) == -1)</span>
<span class="lineNum">     909 </span>            :         return false;
<span class="lineNum">     910 </span><span class="lineCov">      38409 :       extract_insn (insn);</span>
<span class="lineNum">     911 </span><span class="lineCov">      38409 :       if (!constrain_operands (1, get_preferred_alternatives (insn, bb)))</span>
<span class="lineNum">     912 </span>            :         return false;
<span class="lineNum">     913 </span>            : 
<span class="lineNum">     914 </span><span class="lineCov">      38373 :       while (REG_P (SET_SRC (*dest_sub_rtx))</span>
<span class="lineNum">     915 </span><span class="lineCov">      38373 :              &amp;&amp; (REGNO (SET_SRC (*dest_sub_rtx)) == REGNO (SET_DEST (pat))))</span>
<span class="lineNum">     916 </span>            :         {
<span class="lineNum">     917 </span>            :           /* Considering transformation of
<span class="lineNum">     918 </span>            :              (set (reg2) (expression))
<span class="lineNum">     919 </span>            :              ...
<span class="lineNum">     920 </span>            :              (set (reg1) (reg2))
<span class="lineNum">     921 </span>            :              ...
<span class="lineNum">     922 </span>            :              (set (reg2) (any_extend (reg1)))
<span class="lineNum">     923 </span>            : 
<span class="lineNum">     924 </span>            :              into
<span class="lineNum">     925 </span>            : 
<span class="lineNum">     926 </span>            :              (set (reg2) (any_extend (expression)))
<span class="lineNum">     927 </span>            :              (set (reg1) (reg2))
<span class="lineNum">     928 </span>            :              ...  */
<span class="lineNum">     929 </span><span class="lineCov">        771 :           struct df_link *defs</span>
<span class="lineNum">     930 </span><span class="lineCov">        771 :             = get_defs (def_insn, SET_SRC (*dest_sub_rtx), NULL);</span>
<span class="lineNum">     931 </span><span class="lineCov">        771 :           if (defs == NULL || defs-&gt;next)</span>
<span class="lineNum">     932 </span>            :             break;
<span class="lineNum">     933 </span>            : 
<span class="lineNum">     934 </span>            :           /* There is only one reaching def.  */
<span class="lineNum">     935 </span><span class="lineCov">        655 :           rtx_insn *def_insn2 = DF_REF_INSN (defs-&gt;ref);</span>
<span class="lineNum">     936 </span>            : 
<span class="lineNum">     937 </span>            :           /* The defining statement must not have been modified either.  */
<span class="lineNum">     938 </span><span class="lineCov">        655 :           if (state-&gt;modified[INSN_UID (def_insn2)].kind != EXT_MODIFIED_NONE)</span>
<span class="lineNum">     939 </span>            :             break;
<span class="lineNum">     940 </span>            : 
<span class="lineNum">     941 </span>            :           /* The def_insn2 and candidate insn must be in the same
<span class="lineNum">     942 </span>            :              block and def_insn follows def_insn2.  */
<span class="lineNum">     943 </span><span class="lineCov">        654 :           if (bb != BLOCK_FOR_INSN (def_insn2)</span>
<span class="lineNum">     944 </span><span class="lineCov">        654 :               || DF_INSN_LUID (def_insn2) &gt; DF_INSN_LUID (def_insn))</span>
<span class="lineNum">     945 </span>            :             break;
<span class="lineNum">     946 </span>            : 
<span class="lineNum">     947 </span><span class="lineCov">        512 :           rtx *dest_sub_rtx2 = get_sub_rtx (def_insn2);</span>
<span class="lineNum">     948 </span><span class="lineCov">        512 :           if (dest_sub_rtx2 == NULL</span>
<span class="lineNum">     949 </span><span class="lineCov">        512 :               || !REG_P (SET_DEST (*dest_sub_rtx2)))</span>
<span class="lineNum">     950 </span>            :             break;
<span class="lineNum">     951 </span>            : 
<span class="lineNum">     952 </span>            :           /* On RISC machines we must make sure that changing the mode of
<span class="lineNum">     953 </span>            :              SRC_REG as destination register will not affect its reaching
<span class="lineNum">     954 </span>            :              uses, which may read its value in a larger mode because DEF_INSN
<span class="lineNum">     955 </span>            :              implicitly sets it in word mode.  */
<span class="lineNum">     956 </span><span class="lineCov">        506 :           if (WORD_REGISTER_OPERATIONS &amp;&amp; known_lt (prec, BITS_PER_WORD))</span>
<span class="lineNum">     957 </span>            :             {
<span class="lineNum">     958 </span>            :               struct df_link *uses = get_uses (def_insn2, SET_DEST (pat));
<span class="lineNum">     959 </span>            :               if (!uses)
<span class="lineNum">     960 </span>            :                 break;
<span class="lineNum">     961 </span>            : 
<span class="lineNum">     962 </span>            :               df_link *use;
<span class="lineNum">     963 </span>            :               rtx dest2 = SET_DEST (*dest_sub_rtx2);
<span class="lineNum">     964 </span>            :               for (use = uses; use; use = use-&gt;next)
<span class="lineNum">     965 </span>            :                 if (paradoxical_subreg_p (GET_MODE (*DF_REF_LOC (use-&gt;ref)),
<span class="lineNum">     966 </span>            :                                           GET_MODE (dest2)))
<span class="lineNum">     967 </span>            :                   break;
<span class="lineNum">     968 </span>            :               if (use)
<span class="lineNum">     969 </span>            :                 break;
<span class="lineNum">     970 </span>            :             }
<span class="lineNum">     971 </span>            : 
<span class="lineNum">     972 </span>            :           /* The destination register of the extension insn must not be
<span class="lineNum">     973 </span>            :              used or set between the def_insn2 and def_insn exclusive.
<span class="lineNum">     974 </span>            :              Likewise for the other reg, i.e. check both reg1 and reg2
<span class="lineNum">     975 </span>            :              in the above comment.  */
<span class="lineNum">     976 </span><span class="lineCov">       1012 :           if (reg_used_between_p (SET_DEST (PATTERN (cand-&gt;insn)),</span>
<span class="lineNum">     977 </span>            :                                   def_insn2, def_insn)
<span class="lineNum">     978 </span><span class="lineCov">        990 :               || reg_set_between_p (SET_DEST (PATTERN (cand-&gt;insn)),</span>
<span class="lineNum">     979 </span>            :                                     def_insn2, def_insn)
<span class="lineNum">     980 </span><span class="lineCov">        495 :               || reg_used_between_p (src_reg, def_insn2, def_insn)</span>
<span class="lineNum">     981 </span><span class="lineCov">        984 :               || reg_set_between_p (src_reg, def_insn2, def_insn))</span>
<span class="lineNum">     982 </span>            :             break;
<span class="lineNum">     983 </span>            : 
<span class="lineNum">     984 </span><span class="lineCov">        476 :           state-&gt;defs_list[0] = def_insn2;</span>
<span class="lineNum">     985 </span><span class="lineCov">        476 :           break;</span>
<span class="lineNum">     986 </span>            :         }
<span class="lineNum">     987 </span>            :     }
<span class="lineNum">     988 </span>            : 
<span class="lineNum">     989 </span>            :   /* If cand-&gt;insn has been already modified, update cand-&gt;mode to a wider
<span class="lineNum">     990 </span>            :      mode if possible, or punt.  */
<span class="lineNum">     991 </span><span class="lineCov">     160640 :   if (state-&gt;modified[INSN_UID (cand-&gt;insn)].kind != EXT_MODIFIED_NONE)</span>
<span class="lineNum">     992 </span>            :     {
<span class="lineNum">     993 </span><span class="lineCov">         57 :       machine_mode mode;</span>
<span class="lineNum">     994 </span><span class="lineCov">         57 :       rtx set;</span>
<span class="lineNum">     995 </span>            : 
<span class="lineNum">     996 </span><span class="lineCov">         57 :       if (state-&gt;modified[INSN_UID (cand-&gt;insn)].kind</span>
<span class="lineNum">     997 </span><span class="lineCov">         57 :           != (cand-&gt;code == ZERO_EXTEND</span>
<span class="lineNum">     998 </span><span class="lineCov">         57 :               ? EXT_MODIFIED_ZEXT : EXT_MODIFIED_SEXT)</span>
<span class="lineNum">     999 </span><span class="lineCov">         12 :           || state-&gt;modified[INSN_UID (cand-&gt;insn)].mode != cand-&gt;mode</span>
<span class="lineNum">    1000 </span><span class="lineCov">         63 :           || (set = single_set (cand-&gt;insn)) == NULL_RTX)</span>
<span class="lineNum">    1001 </span><span class="lineCov">         51 :         return false;</span>
<span class="lineNum">    1002 </span><span class="lineCov">          6 :       mode = GET_MODE (SET_DEST (set));</span>
<span class="lineNum">    1003 </span><span class="lineCov">         18 :       gcc_assert (GET_MODE_UNIT_SIZE (mode)</span>
<span class="lineNum">    1004 </span>            :                   &gt;= GET_MODE_UNIT_SIZE (cand-&gt;mode));
<span class="lineNum">    1005 </span><span class="lineCov">          6 :       cand-&gt;mode = mode;</span>
<span class="lineNum">    1006 </span>            :     }
<span class="lineNum">    1007 </span>            : 
<span class="lineNum">    1008 </span><span class="lineCov">     160589 :   merge_successful = true;</span>
<span class="lineNum">    1009 </span>            : 
<span class="lineNum">    1010 </span>            :   /* Go through the defs vector and try to merge all the definitions
<span class="lineNum">    1011 </span>            :      in this vector.  */
<span class="lineNum">    1012 </span><span class="lineCov">     160589 :   state-&gt;modified_list.truncate (0);</span>
<span class="lineNum">    1013 </span><span class="lineCov">     419940 :   FOR_EACH_VEC_ELT (state-&gt;defs_list, defs_ix, def_insn)</span>
<span class="lineNum">    1014 </span>            :     {
<span class="lineNum">    1015 </span><span class="lineCov">     172252 :       if (merge_def_and_ext (cand, def_insn, state))</span>
<span class="lineNum">    1016 </span><span class="lineCov">     135507 :         state-&gt;modified_list.safe_push (def_insn);</span>
<span class="lineNum">    1017 </span>            :       else
<span class="lineNum">    1018 </span>            :         {
<span class="lineNum">    1019 </span>            :           merge_successful = false;
<span class="lineNum">    1020 </span>            :           break;
<span class="lineNum">    1021 </span>            :         }
<span class="lineNum">    1022 </span>            :     }
<span class="lineNum">    1023 </span>            : 
<span class="lineNum">    1024 </span>            :   /* Now go through the conditional copies vector and try to merge all
<span class="lineNum">    1025 </span>            :      the copies in this vector.  */
<span class="lineNum">    1026 </span><span class="lineCov">     160589 :   if (merge_successful)</span>
<span class="lineNum">    1027 </span>            :     {
<span class="lineNum">    1028 </span><span class="lineCov">     126637 :       FOR_EACH_VEC_ELT (state-&gt;copies_list, i, def_insn)</span>
<span class="lineNum">    1029 </span>            :         {
<span class="lineNum">    1030 </span><span class="lineCov">        520 :           if (transform_ifelse (cand, def_insn))</span>
<span class="lineNum">    1031 </span><span class="lineCov">        520 :             state-&gt;modified_list.safe_push (def_insn);</span>
<span class="lineNum">    1032 </span>            :           else
<span class="lineNum">    1033 </span>            :             {
<span class="lineNum">    1034 </span>            :               merge_successful = false;
<span class="lineNum">    1035 </span>            :               break;
<span class="lineNum">    1036 </span>            :             }
<span class="lineNum">    1037 </span>            :         }
<span class="lineNum">    1038 </span>            :     }
<span class="lineNum">    1039 </span>            : 
<span class="lineNum">    1040 </span><span class="lineCov">     160589 :   if (merge_successful)</span>
<span class="lineNum">    1041 </span>            :     {
<span class="lineNum">    1042 </span>            :       /* Commit the changes here if possible
<span class="lineNum">    1043 </span>            :          FIXME: It's an all-or-nothing scenario.  Even if only one definition
<span class="lineNum">    1044 </span>            :          cannot be merged, we entirely give up.  In the future, we should allow
<span class="lineNum">    1045 </span>            :          extensions to be partially eliminated along those paths where the
<span class="lineNum">    1046 </span>            :          definitions could be merged.  */
<span class="lineNum">    1047 </span><span class="lineCov">     123844 :       if (apply_change_group ())</span>
<span class="lineNum">    1048 </span>            :         {
<span class="lineNum">    1049 </span><span class="lineCov">      52408 :           if (dump_file)</span>
<span class="lineNum">    1050 </span><span class="lineCov">         21 :             fprintf (dump_file, &quot;All merges were successful.\n&quot;);</span>
<span class="lineNum">    1051 </span>            : 
<span class="lineNum">    1052 </span><span class="lineCov">     111992 :           FOR_EACH_VEC_ELT (state-&gt;modified_list, i, def_insn)</span>
<span class="lineNum">    1053 </span>            :             {
<span class="lineNum">    1054 </span><span class="lineCov">      59584 :               ext_modified *modified = &amp;state-&gt;modified[INSN_UID (def_insn)];</span>
<span class="lineNum">    1055 </span><span class="lineCov">      59584 :               if (modified-&gt;kind == EXT_MODIFIED_NONE)</span>
<span class="lineNum">    1056 </span><span class="lineCov">      89219 :                 modified-&gt;kind = (cand-&gt;code == ZERO_EXTEND ? EXT_MODIFIED_ZEXT</span>
<span class="lineNum">    1057 </span>            :                                                             : EXT_MODIFIED_SEXT);
<span class="lineNum">    1058 </span>            : 
<span class="lineNum">    1059 </span><span class="lineCov">      59584 :               if (copy_needed)</span>
<span class="lineNum">    1060 </span><span class="lineCov">      13847 :                 modified-&gt;do_not_reextend = 1;</span>
<span class="lineNum">    1061 </span>            :             }
<span class="lineNum">    1062 </span>            :           return true;
<span class="lineNum">    1063 </span>            :         }
<span class="lineNum">    1064 </span>            :       else
<span class="lineNum">    1065 </span>            :         {
<span class="lineNum">    1066 </span>            :           /* Changes need not be cancelled explicitly as apply_change_group
<span class="lineNum">    1067 </span>            :              does it.  Print list of definitions in the dump_file for debug
<span class="lineNum">    1068 </span>            :              purposes.  This extension cannot be deleted.  */
<span class="lineNum">    1069 </span><span class="lineCov">      71436 :           if (dump_file)</span>
<span class="lineNum">    1070 </span>            :             {
<span class="lineNum">    1071 </span><span class="lineCov">          8 :               fprintf (dump_file,</span>
<span class="lineNum">    1072 </span>            :                        &quot;Merge cancelled, non-mergeable definitions:\n&quot;);
<span class="lineNum">    1073 </span><span class="lineCov">         16 :               FOR_EACH_VEC_ELT (state-&gt;modified_list, i, def_insn)</span>
<span class="lineNum">    1074 </span><span class="lineCov">          8 :                 print_rtl_single (dump_file, def_insn);</span>
<span class="lineNum">    1075 </span>            :             }
<span class="lineNum">    1076 </span>            :         }
<span class="lineNum">    1077 </span>            :     }
<span class="lineNum">    1078 </span>            :   else
<span class="lineNum">    1079 </span>            :     {
<span class="lineNum">    1080 </span>            :       /* Cancel any changes that have been made so far.  */
<span class="lineNum">    1081 </span><span class="lineCov">      36745 :       cancel_changes (0);</span>
<span class="lineNum">    1082 </span>            :     }
<span class="lineNum">    1083 </span>            : 
<span class="lineNum">    1084 </span>            :   return false;
<span class="lineNum">    1085 </span>            : }
<span class="lineNum">    1086 </span>            : 
<span class="lineNum">    1087 </span>            : /* Add an extension pattern that could be eliminated.  */
<span class="lineNum">    1088 </span>            : 
<span class="lineNum">    1089 </span>            : static void
<span class="lineNum">    1090 </span><span class="lineCov">   29059883 : add_removable_extension (const_rtx expr, rtx_insn *insn,</span>
<span class="lineNum">    1091 </span>            :                          vec&lt;ext_cand&gt; *insn_list,
<span class="lineNum">    1092 </span>            :                          unsigned *def_map,
<span class="lineNum">    1093 </span>            :                          bitmap init_regs)
<span class="lineNum">    1094 </span>            : {
<span class="lineNum">    1095 </span><span class="lineCov">   29059883 :   enum rtx_code code;</span>
<span class="lineNum">    1096 </span><span class="lineCov">   29059883 :   machine_mode mode;</span>
<span class="lineNum">    1097 </span><span class="lineCov">   29059883 :   unsigned int idx;</span>
<span class="lineNum">    1098 </span><span class="lineCov">   29059883 :   rtx src, dest;</span>
<span class="lineNum">    1099 </span>            : 
<span class="lineNum">    1100 </span>            :   /* We are looking for SET (REG N) (ANY_EXTEND (REG N)).  */
<span class="lineNum">    1101 </span><span class="lineCov">   29059883 :   if (GET_CODE (expr) != SET)</span>
<span class="lineNum">    1102 </span>            :     return;
<span class="lineNum">    1103 </span>            : 
<span class="lineNum">    1104 </span><span class="lineCov">   29059883 :   src = SET_SRC (expr);</span>
<span class="lineNum">    1105 </span><span class="lineCov">   29059883 :   code = GET_CODE (src);</span>
<span class="lineNum">    1106 </span><span class="lineCov">   29059883 :   dest = SET_DEST (expr);</span>
<span class="lineNum">    1107 </span><span class="lineCov">   29059883 :   mode = GET_MODE (dest);</span>
<span class="lineNum">    1108 </span>            : 
<span class="lineNum">    1109 </span><span class="lineCov">   29059883 :   if (REG_P (dest)</span>
<span class="lineNum">    1110 </span><span class="lineCov">   18963292 :       &amp;&amp; (code == SIGN_EXTEND || code == ZERO_EXTEND)</span>
<span class="lineNum">    1111 </span><span class="lineCov">     336782 :       &amp;&amp; REG_P (XEXP (src, 0)))</span>
<span class="lineNum">    1112 </span>            :     {
<span class="lineNum">    1113 </span><span class="lineCov">     236620 :       rtx reg = XEXP (src, 0);</span>
<span class="lineNum">    1114 </span><span class="lineCov">     236620 :       struct df_link *defs, *def;</span>
<span class="lineNum">    1115 </span><span class="lineCov">     236620 :       ext_cand *cand;</span>
<span class="lineNum">    1116 </span>            : 
<span class="lineNum">    1117 </span>            :       /* Zero-extension of an undefined value is partly defined (it's
<span class="lineNum">    1118 </span>            :          completely undefined for sign-extension, though).  So if there exists
<span class="lineNum">    1119 </span>            :          a path from the entry to this zero-extension that leaves this register
<span class="lineNum">    1120 </span>            :          uninitialized, removing the extension could change the behavior of
<span class="lineNum">    1121 </span>            :          correct programs.  So first, check it is not the case.  */
<span class="lineNum">    1122 </span><span class="lineCov">     236620 :       if (code == ZERO_EXTEND &amp;&amp; !bitmap_bit_p (init_regs, REGNO (reg)))</span>
<span class="lineNum">    1123 </span>            :         {
<span class="lineNum">    1124 </span><span class="lineCov">      12184 :           if (dump_file)</span>
<span class="lineNum">    1125 </span>            :             {
<span class="lineNum">    1126 </span><span class="lineNoCov">          0 :               fprintf (dump_file, &quot;Cannot eliminate extension:\n&quot;);</span>
<span class="lineNum">    1127 </span><span class="lineNoCov">          0 :               print_rtl_single (dump_file, insn);</span>
<span class="lineNum">    1128 </span><span class="lineNoCov">          0 :               fprintf (dump_file, &quot; because it can operate on uninitialized&quot;</span>
<span class="lineNum">    1129 </span>            :                                   &quot; data\n&quot;);
<span class="lineNum">    1130 </span>            :             }
<span class="lineNum">    1131 </span><span class="lineCov">      32235 :           return;</span>
<span class="lineNum">    1132 </span>            :         }
<span class="lineNum">    1133 </span>            : 
<span class="lineNum">    1134 </span>            :       /* Second, make sure we can get all the reaching definitions.  */
<span class="lineNum">    1135 </span><span class="lineCov">     224436 :       defs = get_defs (insn, reg, NULL);</span>
<span class="lineNum">    1136 </span><span class="lineCov">     224436 :       if (!defs)</span>
<span class="lineNum">    1137 </span>            :         {
<span class="lineNum">    1138 </span><span class="lineCov">      18208 :           if (dump_file)</span>
<span class="lineNum">    1139 </span>            :             {
<span class="lineNum">    1140 </span><span class="lineCov">         10 :               fprintf (dump_file, &quot;Cannot eliminate extension:\n&quot;);</span>
<span class="lineNum">    1141 </span><span class="lineCov">         10 :               print_rtl_single (dump_file, insn);</span>
<span class="lineNum">    1142 </span><span class="lineCov">         10 :               fprintf (dump_file, &quot; because of missing definition(s)\n&quot;);</span>
<span class="lineNum">    1143 </span>            :             }
<span class="lineNum">    1144 </span><span class="lineCov">      18208 :           return;</span>
<span class="lineNum">    1145 </span>            :         }
<span class="lineNum">    1146 </span>            : 
<span class="lineNum">    1147 </span>            :       /* Third, make sure the reaching definitions don't feed another and
<span class="lineNum">    1148 </span>            :          different extension.  FIXME: this obviously can be improved.  */
<span class="lineNum">    1149 </span><span class="lineCov">     462957 :       for (def = defs; def; def = def-&gt;next)</span>
<span class="lineNum">    1150 </span><span class="lineCov">     258572 :         if ((idx = def_map[INSN_UID (DF_REF_INSN (def-&gt;ref))])</span>
<span class="lineNum">    1151 </span><span class="lineCov">      24420 :             &amp;&amp; idx != -1U</span>
<span class="lineNum">    1152 </span><span class="lineCov">      24406 :             &amp;&amp; (cand = &amp;(*insn_list)[idx - 1])</span>
<span class="lineNum">    1153 </span><span class="lineCov">     282978 :             &amp;&amp; cand-&gt;code != code)</span>
<span class="lineNum">    1154 </span>            :           {
<span class="lineNum">    1155 </span><span class="lineCov">       1762 :             if (dump_file)</span>
<span class="lineNum">    1156 </span>            :               {
<span class="lineNum">    1157 </span><span class="lineCov">          1 :                 fprintf (dump_file, &quot;Cannot eliminate extension:\n&quot;);</span>
<span class="lineNum">    1158 </span><span class="lineCov">          1 :                 print_rtl_single (dump_file, insn);</span>
<span class="lineNum">    1159 </span><span class="lineCov">          1 :                 fprintf (dump_file, &quot; because of other extension\n&quot;);</span>
<span class="lineNum">    1160 </span>            :               }
<span class="lineNum">    1161 </span><span class="lineCov">       1762 :             return;</span>
<span class="lineNum">    1162 </span>            :           }
<span class="lineNum">    1163 </span>            :         /* For vector mode extensions, ensure that all uses of the
<span class="lineNum">    1164 </span>            :            XEXP (src, 0) register are in insn or debug insns, as unlike
<span class="lineNum">    1165 </span>            :            integral extensions lowpart subreg of the sign/zero extended
<span class="lineNum">    1166 </span>            :            register are not equal to the original register, so we have
<span class="lineNum">    1167 </span>            :            to change all uses or none and the current code isn't able
<span class="lineNum">    1168 </span>            :            to change them all at once in one transaction.  */
<span class="lineNum">    1169 </span><span class="lineCov">     256810 :         else if (VECTOR_MODE_P (GET_MODE (XEXP (src, 0))))</span>
<span class="lineNum">    1170 </span>            :           {
<span class="lineNum">    1171 </span><span class="lineCov">        271 :             if (idx == 0)</span>
<span class="lineNum">    1172 </span>            :               {
<span class="lineNum">    1173 </span><span class="lineCov">        257 :                 struct df_link *ref_chain, *ref_link;</span>
<span class="lineNum">    1174 </span>            : 
<span class="lineNum">    1175 </span><span class="lineCov">        257 :                 ref_chain = DF_REF_CHAIN (def-&gt;ref);</span>
<span class="lineNum">    1176 </span><span class="lineCov">        483 :                 for (ref_link = ref_chain; ref_link; ref_link = ref_link-&gt;next)</span>
<span class="lineNum">    1177 </span>            :                   {
<span class="lineNum">    1178 </span><span class="lineCov">        293 :                     if (ref_link-&gt;ref == NULL</span>
<span class="lineNum">    1179 </span><span class="lineCov">        293 :                         || DF_REF_INSN_INFO (ref_link-&gt;ref) == NULL)</span>
<span class="lineNum">    1180 </span>            :                       {
<span class="lineNum">    1181 </span>            :                         idx = -1U;
<span class="lineNum">    1182 </span><span class="lineCov">         67 :                         break;</span>
<span class="lineNum">    1183 </span>            :                       }
<span class="lineNum">    1184 </span><span class="lineCov">        293 :                     rtx_insn *use_insn = DF_REF_INSN (ref_link-&gt;ref);</span>
<span class="lineNum">    1185 </span><span class="lineCov">        293 :                     if (use_insn != insn &amp;&amp; !DEBUG_INSN_P (use_insn))</span>
<span class="lineNum">    1186 </span>            :                       {
<span class="lineNum">    1187 </span>            :                         idx = -1U;
<span class="lineNum">    1188 </span>            :                         break;
<span class="lineNum">    1189 </span>            :                       }
<span class="lineNum">    1190 </span>            :                   }
<span class="lineNum">    1191 </span><span class="lineCov">         67 :                 if (idx == -1U)</span>
<span class="lineNum">    1192 </span><span class="lineCov">        134 :                   def_map[INSN_UID (DF_REF_INSN (def-&gt;ref))] = idx;</span>
<span class="lineNum">    1193 </span>            :               }
<span class="lineNum">    1194 </span><span class="lineCov">        271 :             if (idx == -1U)</span>
<span class="lineNum">    1195 </span>            :               {
<span class="lineNum">    1196 </span><span class="lineCov">         81 :                 if (dump_file)</span>
<span class="lineNum">    1197 </span>            :                   {
<span class="lineNum">    1198 </span><span class="lineNoCov">          0 :                     fprintf (dump_file, &quot;Cannot eliminate extension:\n&quot;);</span>
<span class="lineNum">    1199 </span><span class="lineNoCov">          0 :                     print_rtl_single (dump_file, insn);</span>
<span class="lineNum">    1200 </span><span class="lineNoCov">          0 :                     fprintf (dump_file,</span>
<span class="lineNum">    1201 </span>            :                              &quot; because some vector uses aren't extension\n&quot;);
<span class="lineNum">    1202 </span>            :                   }
<span class="lineNum">    1203 </span><span class="lineCov">         81 :                 return;</span>
<span class="lineNum">    1204 </span>            :               }
<span class="lineNum">    1205 </span>            :           }
<span class="lineNum">    1206 </span>            : 
<span class="lineNum">    1207 </span>            :       /* Fourth, if the extended version occupies more registers than the
<span class="lineNum">    1208 </span>            :          original and the source of the extension is the same hard register
<span class="lineNum">    1209 </span>            :          as the destination of the extension, then we can not eliminate
<span class="lineNum">    1210 </span>            :          the extension without deep analysis, so just punt.
<span class="lineNum">    1211 </span>            : 
<span class="lineNum">    1212 </span>            :          We allow this when the registers are different because the
<span class="lineNum">    1213 </span>            :          code in combine_reaching_defs will handle that case correctly.  */
<span class="lineNum">    1214 </span><span class="lineCov">     408770 :       if (hard_regno_nregs (REGNO (dest), mode) != REG_NREGS (reg)</span>
<span class="lineNum">    1215 </span><span class="lineCov">     204385 :           &amp;&amp; reg_overlap_mentioned_p (dest, reg))</span>
<span class="lineNum">    1216 </span>            :         return;
<span class="lineNum">    1217 </span>            : 
<span class="lineNum">    1218 </span>            :       /* Then add the candidate to the list and insert the reaching definitions
<span class="lineNum">    1219 </span>            :          into the definition map.  */
<span class="lineNum">    1220 </span><span class="lineCov">     204385 :       ext_cand e = {expr, code, mode, insn};</span>
<span class="lineNum">    1221 </span><span class="lineCov">     204385 :       insn_list-&gt;safe_push (e);</span>
<span class="lineNum">    1222 </span><span class="lineCov">     204385 :       idx = insn_list-&gt;length ();</span>
<span class="lineNum">    1223 </span>            : 
<span class="lineNum">    1224 </span><span class="lineCov">     461103 :       for (def = defs; def; def = def-&gt;next)</span>
<span class="lineNum">    1225 </span><span class="lineCov">     256718 :         def_map[INSN_UID (DF_REF_INSN (def-&gt;ref))] = idx;</span>
<span class="lineNum">    1226 </span>            :     }
<span class="lineNum">    1227 </span>            : }
<span class="lineNum">    1228 </span>            : 
<span class="lineNum">    1229 </span>            : /* Traverse the instruction stream looking for extensions and return the
<span class="lineNum">    1230 </span>            :    list of candidates.  */
<a name="1231"><span class="lineNum">    1231 </span>            : </a>
<span class="lineNum">    1232 </span>            : static vec&lt;ext_cand&gt;
<span class="lineNum">    1233 </span><span class="lineCov">     583846 : find_removable_extensions (void)</span>
<span class="lineNum">    1234 </span>            : {
<span class="lineNum">    1235 </span><span class="lineCov">     583846 :   vec&lt;ext_cand&gt; insn_list = vNULL;</span>
<span class="lineNum">    1236 </span><span class="lineCov">     583846 :   basic_block bb;</span>
<span class="lineNum">    1237 </span><span class="lineCov">     583846 :   rtx_insn *insn;</span>
<span class="lineNum">    1238 </span><span class="lineCov">     583846 :   rtx set;</span>
<span class="lineNum">    1239 </span><span class="lineCov">     583846 :   unsigned *def_map = XCNEWVEC (unsigned, max_insn_uid);</span>
<span class="lineNum">    1240 </span><span class="lineCov">     583846 :   bitmap_head init, kill, gen, tmp;</span>
<span class="lineNum">    1241 </span>            : 
<span class="lineNum">    1242 </span><span class="lineCov">     583846 :   bitmap_initialize (&amp;init, NULL);</span>
<span class="lineNum">    1243 </span><span class="lineCov">     583846 :   bitmap_initialize (&amp;kill, NULL);</span>
<span class="lineNum">    1244 </span><span class="lineCov">     583846 :   bitmap_initialize (&amp;gen, NULL);</span>
<span class="lineNum">    1245 </span><span class="lineCov">     583846 :   bitmap_initialize (&amp;tmp, NULL);</span>
<span class="lineNum">    1246 </span>            : 
<span class="lineNum">    1247 </span><span class="lineCov">    6294227 :   FOR_EACH_BB_FN (bb, cfun)</span>
<span class="lineNum">    1248 </span>            :     {
<span class="lineNum">    1249 </span><span class="lineCov">   11420762 :       bitmap_copy (&amp;init, DF_MIR_IN (bb));</span>
<span class="lineNum">    1250 </span><span class="lineCov">    5710381 :       bitmap_clear (&amp;kill);</span>
<span class="lineNum">    1251 </span><span class="lineCov">    5710381 :       bitmap_clear (&amp;gen);</span>
<span class="lineNum">    1252 </span>            : 
<span class="lineNum">    1253 </span><span class="lineCov">  146329449 :       FOR_BB_INSNS (bb, insn)</span>
<span class="lineNum">    1254 </span>            :         {
<span class="lineNum">    1255 </span><span class="lineCov">   70309534 :           if (NONDEBUG_INSN_P (insn))</span>
<span class="lineNum">    1256 </span>            :             {
<span class="lineNum">    1257 </span><span class="lineCov">   31605355 :               set = single_set (insn);</span>
<span class="lineNum">    1258 </span><span class="lineCov">   31605355 :               if (set != NULL_RTX)</span>
<span class="lineNum">    1259 </span><span class="lineCov">   29059883 :                 add_removable_extension (set, insn, &amp;insn_list, def_map,</span>
<span class="lineNum">    1260 </span>            :                                          &amp;init);
<span class="lineNum">    1261 </span><span class="lineCov">   31605355 :               df_mir_simulate_one_insn (bb, insn, &amp;kill, &amp;gen);</span>
<span class="lineNum">    1262 </span><span class="lineCov">   31605355 :               bitmap_ior_and_compl (&amp;tmp, &amp;gen, &amp;init, &amp;kill);</span>
<span class="lineNum">    1263 </span><span class="lineCov">   31605355 :               bitmap_copy (&amp;init, &amp;tmp);</span>
<span class="lineNum">    1264 </span>            :             }
<span class="lineNum">    1265 </span>            :         }
<span class="lineNum">    1266 </span>            :     }
<span class="lineNum">    1267 </span>            : 
<span class="lineNum">    1268 </span><span class="lineCov">     583846 :   XDELETEVEC (def_map);</span>
<span class="lineNum">    1269 </span>            : 
<span class="lineNum">    1270 </span><span class="lineCov">     583846 :   return insn_list;</span>
<span class="lineNum">    1271 </span>            : }
<span class="lineNum">    1272 </span>            : 
<span class="lineNum">    1273 </span>            : /* This is the main function that checks the insn stream for redundant
<span class="lineNum">    1274 </span>            :    extensions and tries to remove them if possible.  */
<span class="lineNum">    1275 </span>            : 
<span class="lineNum">    1276 </span>            : static void
<span class="lineNum">    1277 </span><span class="lineCov">     583846 : find_and_remove_re (void)</span>
<span class="lineNum">    1278 </span>            : {
<span class="lineNum">    1279 </span><span class="lineCov">     583846 :   ext_cand *curr_cand;</span>
<span class="lineNum">    1280 </span><span class="lineCov">     583846 :   rtx_insn *curr_insn = NULL;</span>
<span class="lineNum">    1281 </span><span class="lineCov">     583846 :   int num_re_opportunities = 0, num_realized = 0, i;</span>
<span class="lineNum">    1282 </span><span class="lineCov">     583846 :   vec&lt;ext_cand&gt; reinsn_list;</span>
<span class="lineNum">    1283 </span><span class="lineCov">     583846 :   auto_vec&lt;rtx_insn *&gt; reinsn_del_list;</span>
<span class="lineNum">    1284 </span><span class="lineCov">    1167692 :   auto_vec&lt;rtx_insn *&gt; reinsn_copy_list;</span>
<span class="lineNum">    1285 </span>            : 
<span class="lineNum">    1286 </span>            :   /* Construct DU chain to get all reaching definitions of each
<span class="lineNum">    1287 </span>            :      extension instruction.  */
<span class="lineNum">    1288 </span><span class="lineCov">     583846 :   df_set_flags (DF_RD_PRUNE_DEAD_DEFS);</span>
<span class="lineNum">    1289 </span><span class="lineCov">     583846 :   df_chain_add_problem (DF_UD_CHAIN + DF_DU_CHAIN);</span>
<span class="lineNum">    1290 </span><span class="lineCov">     583846 :   df_mir_add_problem ();</span>
<span class="lineNum">    1291 </span><span class="lineCov">     583846 :   df_analyze ();</span>
<span class="lineNum">    1292 </span><span class="lineCov">     583846 :   df_set_flags (DF_DEFER_INSN_RESCAN);</span>
<span class="lineNum">    1293 </span>            : 
<span class="lineNum">    1294 </span><span class="lineCov">     583846 :   max_insn_uid = get_max_uid ();</span>
<span class="lineNum">    1295 </span><span class="lineCov">     583846 :   reinsn_list = find_removable_extensions ();</span>
<span class="lineNum">    1296 </span>            : 
<span class="lineNum">    1297 </span><span class="lineCov">    1167692 :   ext_state state;</span>
<span class="lineNum">    1298 </span><span class="lineCov">     583846 :   if (reinsn_list.is_empty ())</span>
<span class="lineNum">    1299 </span><span class="lineCov">     518770 :     state.modified = NULL;</span>
<span class="lineNum">    1300 </span>            :   else
<span class="lineNum">    1301 </span><span class="lineCov">      65076 :     state.modified = XCNEWVEC (struct ext_modified, max_insn_uid);</span>
<span class="lineNum">    1302 </span>            : 
<span class="lineNum">    1303 </span><span class="lineCov">     788231 :   FOR_EACH_VEC_ELT (reinsn_list, i, curr_cand)</span>
<span class="lineNum">    1304 </span>            :     {
<span class="lineNum">    1305 </span><span class="lineCov">     204385 :       num_re_opportunities++;</span>
<span class="lineNum">    1306 </span>            : 
<span class="lineNum">    1307 </span>            :       /* Try to combine the extension with the definition.  */
<span class="lineNum">    1308 </span><span class="lineCov">     204385 :       if (dump_file)</span>
<span class="lineNum">    1309 </span>            :         {
<span class="lineNum">    1310 </span><span class="lineCov">         33 :           fprintf (dump_file, &quot;Trying to eliminate extension:\n&quot;);</span>
<span class="lineNum">    1311 </span><span class="lineCov">         33 :           print_rtl_single (dump_file, curr_cand-&gt;insn);</span>
<span class="lineNum">    1312 </span>            :         }
<span class="lineNum">    1313 </span>            : 
<span class="lineNum">    1314 </span><span class="lineCov">     204385 :       if (combine_reaching_defs (curr_cand, curr_cand-&gt;expr, &amp;state))</span>
<span class="lineNum">    1315 </span>            :         {
<span class="lineNum">    1316 </span><span class="lineCov">      52408 :           if (dump_file)</span>
<span class="lineNum">    1317 </span><span class="lineCov">         21 :             fprintf (dump_file, &quot;Eliminated the extension.\n&quot;);</span>
<span class="lineNum">    1318 </span><span class="lineCov">      52408 :           num_realized++;</span>
<span class="lineNum">    1319 </span>            :           /* If the RHS of the current candidate is not (extend (reg)), then
<span class="lineNum">    1320 </span>            :              we do not allow the optimization of extensions where
<span class="lineNum">    1321 </span>            :              the source and destination registers do not match.  Thus
<span class="lineNum">    1322 </span>            :              checking REG_P here is correct.  */
<span class="lineNum">    1323 </span><span class="lineCov">      52408 :           if (REG_P (XEXP (SET_SRC (PATTERN (curr_cand-&gt;insn)), 0))</span>
<span class="lineNum">    1324 </span><span class="lineCov">      52408 :               &amp;&amp; (REGNO (SET_DEST (PATTERN (curr_cand-&gt;insn)))</span>
<span class="lineNum">    1325 </span><span class="lineCov">     104816 :                   != REGNO (XEXP (SET_SRC (PATTERN (curr_cand-&gt;insn)), 0))))</span>
<span class="lineNum">    1326 </span>            :             {
<span class="lineNum">    1327 </span><span class="lineCov">      13847 :               reinsn_copy_list.safe_push (curr_cand-&gt;insn);</span>
<span class="lineNum">    1328 </span><span class="lineCov">      13847 :               reinsn_copy_list.safe_push (state.defs_list[0]);</span>
<span class="lineNum">    1329 </span>            :             }
<span class="lineNum">    1330 </span><span class="lineCov">      52408 :           reinsn_del_list.safe_push (curr_cand-&gt;insn);</span>
<span class="lineNum">    1331 </span><span class="lineCov">      52408 :           state.modified[INSN_UID (curr_cand-&gt;insn)].deleted = 1;</span>
<span class="lineNum">    1332 </span>            :         }
<span class="lineNum">    1333 </span>            :     }
<span class="lineNum">    1334 </span>            : 
<span class="lineNum">    1335 </span>            :   /* The copy list contains pairs of insns which describe copies we
<span class="lineNum">    1336 </span>            :      need to insert into the INSN stream.
<span class="lineNum">    1337 </span>            : 
<span class="lineNum">    1338 </span>            :      The first insn in each pair is the extension insn, from which
<span class="lineNum">    1339 </span>            :      we derive the source and destination of the copy.
<span class="lineNum">    1340 </span>            : 
<span class="lineNum">    1341 </span>            :      The second insn in each pair is the memory reference where the
<span class="lineNum">    1342 </span>            :      extension will ultimately happen.  We emit the new copy
<span class="lineNum">    1343 </span>            :      immediately after this insn.
<span class="lineNum">    1344 </span>            : 
<span class="lineNum">    1345 </span>            :      It may first appear that the arguments for the copy are reversed.
<span class="lineNum">    1346 </span>            :      Remember that the memory reference will be changed to refer to the
<span class="lineNum">    1347 </span>            :      destination of the extention.  So we're actually emitting a copy
<span class="lineNum">    1348 </span>            :      from the new destination to the old destination.  */
<span class="lineNum">    1349 </span><span class="lineCov">     619534 :   for (unsigned int i = 0; i &lt; reinsn_copy_list.length (); i += 2)</span>
<span class="lineNum">    1350 </span>            :     {
<span class="lineNum">    1351 </span><span class="lineCov">      13847 :       rtx_insn *curr_insn = reinsn_copy_list[i];</span>
<span class="lineNum">    1352 </span><span class="lineCov">      13847 :       rtx_insn *def_insn = reinsn_copy_list[i + 1];</span>
<span class="lineNum">    1353 </span>            : 
<span class="lineNum">    1354 </span>            :       /* Use the mode of the destination of the defining insn
<span class="lineNum">    1355 </span>            :          for the mode of the copy.  This is necessary if the
<span class="lineNum">    1356 </span>            :          defining insn was used to eliminate a second extension
<span class="lineNum">    1357 </span>            :          that was wider than the first.  */
<span class="lineNum">    1358 </span><span class="lineCov">      13847 :       rtx sub_rtx = *get_sub_rtx (def_insn);</span>
<span class="lineNum">    1359 </span><span class="lineCov">      13847 :       rtx pat = PATTERN (curr_insn);</span>
<span class="lineNum">    1360 </span><span class="lineCov">      13847 :       rtx new_dst = gen_rtx_REG (GET_MODE (SET_DEST (sub_rtx)),</span>
<span class="lineNum">    1361 </span><span class="lineCov">      13847 :                                  REGNO (XEXP (SET_SRC (pat), 0)));</span>
<span class="lineNum">    1362 </span><span class="lineCov">      13847 :       rtx new_src = gen_rtx_REG (GET_MODE (SET_DEST (sub_rtx)),</span>
<span class="lineNum">    1363 </span><span class="lineCov">      13847 :                                  REGNO (SET_DEST (pat)));</span>
<span class="lineNum">    1364 </span><span class="lineCov">      13847 :       rtx set = gen_rtx_SET (new_dst, new_src);</span>
<span class="lineNum">    1365 </span><span class="lineCov">      13847 :       emit_insn_after (set, def_insn);</span>
<span class="lineNum">    1366 </span>            :     }
<span class="lineNum">    1367 </span>            : 
<span class="lineNum">    1368 </span>            :   /* Delete all useless extensions here in one sweep.  */
<span class="lineNum">    1369 </span><span class="lineCov">     636254 :   FOR_EACH_VEC_ELT (reinsn_del_list, i, curr_insn)</span>
<span class="lineNum">    1370 </span><span class="lineCov">      52408 :     delete_insn (curr_insn);</span>
<span class="lineNum">    1371 </span>            : 
<span class="lineNum">    1372 </span><span class="lineCov">     583846 :   reinsn_list.release ();</span>
<span class="lineNum">    1373 </span><span class="lineCov">     583846 :   XDELETEVEC (state.modified);</span>
<span class="lineNum">    1374 </span>            : 
<span class="lineNum">    1375 </span><span class="lineCov">     583846 :   if (dump_file &amp;&amp; num_re_opportunities &gt; 0)</span>
<span class="lineNum">    1376 </span><span class="lineCov">         17 :     fprintf (dump_file, &quot;Elimination opportunities = %d realized = %d\n&quot;,</span>
<span class="lineNum">    1377 </span>            :              num_re_opportunities, num_realized);
<span class="lineNum">    1378 </span><span class="lineCov">     583846 : }</span>
<span class="lineNum">    1379 </span>            : 
<span class="lineNum">    1380 </span>            : /* Find and remove redundant extensions.  */
<a name="1381"><span class="lineNum">    1381 </span>            : </a>
<span class="lineNum">    1382 </span>            : static unsigned int
<span class="lineNum">    1383 </span><span class="lineNoCov">          0 : rest_of_handle_ree (void)</span>
<span class="lineNum">    1384 </span>            : {
<span class="lineNum">    1385 </span><span class="lineNoCov">          0 :   find_and_remove_re ();</span>
<span class="lineNum">    1386 </span><span class="lineCov">     583846 :   return 0;</span>
<span class="lineNum">    1387 </span>            : }
<span class="lineNum">    1388 </span>            : 
<span class="lineNum">    1389 </span>            : namespace {
<span class="lineNum">    1390 </span>            : 
<span class="lineNum">    1391 </span>            : const pass_data pass_data_ree =
<span class="lineNum">    1392 </span>            : {
<span class="lineNum">    1393 </span>            :   RTL_PASS, /* type */
<span class="lineNum">    1394 </span>            :   &quot;ree&quot;, /* name */
<span class="lineNum">    1395 </span>            :   OPTGROUP_NONE, /* optinfo_flags */
<span class="lineNum">    1396 </span>            :   TV_REE, /* tv_id */
<span class="lineNum">    1397 </span>            :   0, /* properties_required */
<span class="lineNum">    1398 </span>            :   0, /* properties_provided */
<span class="lineNum">    1399 </span>            :   0, /* properties_destroyed */
<span class="lineNum">    1400 </span>            :   0, /* todo_flags_start */
<span class="lineNum">    1401 </span>            :   TODO_df_finish, /* todo_flags_finish */
<span class="lineNum">    1402 </span>            : };
<span class="lineNum">    1403 </span>            : 
<span class="lineNum">    1404 </span>            : class pass_ree : public rtl_opt_pass
<span class="lineNum">    1405 </span>            : {
<span class="lineNum">    1406 </span>            : public:
<span class="lineNum">    1407 </span>            :   pass_ree (gcc::context *ctxt)
<span class="lineNum">    1408 </span><span class="lineCov">     340624 :     : rtl_opt_pass (pass_data_ree, ctxt)</span>
<span class="lineNum">    1409 </span>            :   {}
<a name="1410"><span class="lineNum">    1410 </span>            : </a>
<a name="1411"><span class="lineNum">    1411 </span>            :   /* opt_pass methods: */</a>
<span class="lineNum">    1412 </span><span class="lineCov">     832594 :   virtual bool gate (function *) { return (optimize &gt; 0 &amp;&amp; flag_ree); }</span>
<span class="lineNum">    1413 </span><span class="lineCov">     583846 :   virtual unsigned int execute (function *) { return rest_of_handle_ree (); }</span>
<span class="lineNum">    1414 </span>            : 
<span class="lineNum">    1415 </span>            : }; // class pass_ree
<span class="lineNum">    1416 </span>            : 
<span class="lineNum">    1417 </span>            : } // anon namespace
<a name="1418"><span class="lineNum">    1418 </span>            : </a>
<span class="lineNum">    1419 </span>            : rtl_opt_pass *
<span class="lineNum">    1420 </span><span class="lineCov">     170312 : make_pass_ree (gcc::context *ctxt)</span>
<span class="lineNum">    1421 </span>            : {
<span class="lineNum">    1422 </span><span class="lineCov">     170312 :   return new pass_ree (ctxt);</span>
<span class="lineNum">    1423 </span>            : }
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.0</a></td></tr>
  </table>
  <br>
<h3>LCOV profile is generated on x86_64 machine using following configure options: configure --disable-bootstrap --enable-coverage=opt --enable-languages=c,c++,fortran,go,jit,lto --enable-host-shared. GCC test suite is run with the built compiler.</h3></body></html>
