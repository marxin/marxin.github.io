<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - gcc.info - gcc/tree-sra.c</title>
  <link rel="stylesheet" type="text/css" href="../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../index.html">top level</a> - <a href="index.html">gcc</a> - tree-sra.c<span style="font-size: 80%;"> (source / <a href="tree-sra.c.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">gcc.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">2384</td>
            <td class="headerCovTableEntry">2508</td>
            <td class="headerCovTableEntryHi">95.1 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2018-09-22 10:58:49</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">105</td>
            <td class="headerCovTableEntry">121</td>
            <td class="headerCovTableEntryMed">86.8 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /* Scalar Replacement of Aggregates (SRA) converts some structure</a>
<span class="lineNum">       2 </span>            :    references into scalar references, exposing them to the scalar
<span class="lineNum">       3 </span>            :    optimizers.
<span class="lineNum">       4 </span>            :    Copyright (C) 2008-2018 Free Software Foundation, Inc.
<span class="lineNum">       5 </span>            :    Contributed by Martin Jambor &lt;mjambor@suse.cz&gt;
<span class="lineNum">       6 </span>            : 
<span class="lineNum">       7 </span>            : This file is part of GCC.
<span class="lineNum">       8 </span>            : 
<span class="lineNum">       9 </span>            : GCC is free software; you can redistribute it and/or modify it under
<span class="lineNum">      10 </span>            : the terms of the GNU General Public License as published by the Free
<span class="lineNum">      11 </span>            : Software Foundation; either version 3, or (at your option) any later
<span class="lineNum">      12 </span>            : version.
<span class="lineNum">      13 </span>            : 
<span class="lineNum">      14 </span>            : GCC is distributed in the hope that it will be useful, but WITHOUT ANY
<span class="lineNum">      15 </span>            : WARRANTY; without even the implied warranty of MERCHANTABILITY or
<span class="lineNum">      16 </span>            : FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
<span class="lineNum">      17 </span>            : for more details.
<span class="lineNum">      18 </span>            : 
<span class="lineNum">      19 </span>            : You should have received a copy of the GNU General Public License
<span class="lineNum">      20 </span>            : along with GCC; see the file COPYING3.  If not see
<span class="lineNum">      21 </span>            : &lt;http://www.gnu.org/licenses/&gt;.  */
<span class="lineNum">      22 </span>            : 
<span class="lineNum">      23 </span>            : /* This file implements Scalar Reduction of Aggregates (SRA).  SRA is run
<span class="lineNum">      24 </span>            :    twice, once in the early stages of compilation (early SRA) and once in the
<span class="lineNum">      25 </span>            :    late stages (late SRA).  The aim of both is to turn references to scalar
<span class="lineNum">      26 </span>            :    parts of aggregates into uses of independent scalar variables.
<span class="lineNum">      27 </span>            : 
<span class="lineNum">      28 </span>            :    The two passes are nearly identical, the only difference is that early SRA
<span class="lineNum">      29 </span>            :    does not scalarize unions which are used as the result in a GIMPLE_RETURN
<span class="lineNum">      30 </span>            :    statement because together with inlining this can lead to weird type
<span class="lineNum">      31 </span>            :    conversions.
<span class="lineNum">      32 </span>            : 
<span class="lineNum">      33 </span>            :    Both passes operate in four stages:
<span class="lineNum">      34 </span>            : 
<span class="lineNum">      35 </span>            :    1. The declarations that have properties which make them candidates for
<span class="lineNum">      36 </span>            :       scalarization are identified in function find_var_candidates().  The
<span class="lineNum">      37 </span>            :       candidates are stored in candidate_bitmap.
<span class="lineNum">      38 </span>            : 
<span class="lineNum">      39 </span>            :    2. The function body is scanned.  In the process, declarations which are
<span class="lineNum">      40 </span>            :       used in a manner that prevent their scalarization are removed from the
<span class="lineNum">      41 </span>            :       candidate bitmap.  More importantly, for every access into an aggregate,
<span class="lineNum">      42 </span>            :       an access structure (struct access) is created by create_access() and
<span class="lineNum">      43 </span>            :       stored in a vector associated with the aggregate.  Among other
<span class="lineNum">      44 </span>            :       information, the aggregate declaration, the offset and size of the access
<span class="lineNum">      45 </span>            :       and its type are stored in the structure.
<span class="lineNum">      46 </span>            : 
<span class="lineNum">      47 </span>            :       On a related note, assign_link structures are created for every assign
<span class="lineNum">      48 </span>            :       statement between candidate aggregates and attached to the related
<span class="lineNum">      49 </span>            :       accesses.
<span class="lineNum">      50 </span>            : 
<span class="lineNum">      51 </span>            :    3. The vectors of accesses are analyzed.  They are first sorted according to
<span class="lineNum">      52 </span>            :       their offset and size and then scanned for partially overlapping accesses
<span class="lineNum">      53 </span>            :       (i.e. those which overlap but one is not entirely within another).  Such
<span class="lineNum">      54 </span>            :       an access disqualifies the whole aggregate from being scalarized.
<span class="lineNum">      55 </span>            : 
<span class="lineNum">      56 </span>            :       If there is no such inhibiting overlap, a representative access structure
<span class="lineNum">      57 </span>            :       is chosen for every unique combination of offset and size.  Afterwards,
<span class="lineNum">      58 </span>            :       the pass builds a set of trees from these structures, in which children
<span class="lineNum">      59 </span>            :       of an access are within their parent (in terms of offset and size).
<span class="lineNum">      60 </span>            : 
<span class="lineNum">      61 </span>            :       Then accesses  are propagated  whenever possible (i.e.  in cases  when it
<span class="lineNum">      62 </span>            :       does not create a partially overlapping access) across assign_links from
<span class="lineNum">      63 </span>            :       the right hand side to the left hand side.
<span class="lineNum">      64 </span>            : 
<span class="lineNum">      65 </span>            :       Then the set of trees for each declaration is traversed again and those
<span class="lineNum">      66 </span>            :       accesses which should be replaced by a scalar are identified.
<span class="lineNum">      67 </span>            : 
<span class="lineNum">      68 </span>            :    4. The function is traversed again, and for every reference into an
<span class="lineNum">      69 </span>            :       aggregate that has some component which is about to be scalarized,
<span class="lineNum">      70 </span>            :       statements are amended and new statements are created as necessary.
<span class="lineNum">      71 </span>            :       Finally, if a parameter got scalarized, the scalar replacements are
<span class="lineNum">      72 </span>            :       initialized with values from respective parameter aggregates.  */
<span class="lineNum">      73 </span>            : 
<span class="lineNum">      74 </span>            : #include &quot;config.h&quot;
<span class="lineNum">      75 </span>            : #include &quot;system.h&quot;
<span class="lineNum">      76 </span>            : #include &quot;coretypes.h&quot;
<span class="lineNum">      77 </span>            : #include &quot;backend.h&quot;
<span class="lineNum">      78 </span>            : #include &quot;target.h&quot;
<span class="lineNum">      79 </span>            : #include &quot;rtl.h&quot;
<span class="lineNum">      80 </span>            : #include &quot;tree.h&quot;
<span class="lineNum">      81 </span>            : #include &quot;gimple.h&quot;
<span class="lineNum">      82 </span>            : #include &quot;predict.h&quot;
<span class="lineNum">      83 </span>            : #include &quot;alloc-pool.h&quot;
<span class="lineNum">      84 </span>            : #include &quot;tree-pass.h&quot;
<span class="lineNum">      85 </span>            : #include &quot;ssa.h&quot;
<span class="lineNum">      86 </span>            : #include &quot;cgraph.h&quot;
<span class="lineNum">      87 </span>            : #include &quot;gimple-pretty-print.h&quot;
<span class="lineNum">      88 </span>            : #include &quot;alias.h&quot;
<span class="lineNum">      89 </span>            : #include &quot;fold-const.h&quot;
<span class="lineNum">      90 </span>            : #include &quot;tree-eh.h&quot;
<span class="lineNum">      91 </span>            : #include &quot;stor-layout.h&quot;
<span class="lineNum">      92 </span>            : #include &quot;gimplify.h&quot;
<span class="lineNum">      93 </span>            : #include &quot;gimple-iterator.h&quot;
<span class="lineNum">      94 </span>            : #include &quot;gimplify-me.h&quot;
<span class="lineNum">      95 </span>            : #include &quot;gimple-walk.h&quot;
<span class="lineNum">      96 </span>            : #include &quot;tree-cfg.h&quot;
<span class="lineNum">      97 </span>            : #include &quot;tree-dfa.h&quot;
<span class="lineNum">      98 </span>            : #include &quot;tree-ssa.h&quot;
<span class="lineNum">      99 </span>            : #include &quot;symbol-summary.h&quot;
<span class="lineNum">     100 </span>            : #include &quot;ipa-param-manipulation.h&quot;
<span class="lineNum">     101 </span>            : #include &quot;ipa-prop.h&quot;
<span class="lineNum">     102 </span>            : #include &quot;params.h&quot;
<span class="lineNum">     103 </span>            : #include &quot;dbgcnt.h&quot;
<span class="lineNum">     104 </span>            : #include &quot;tree-inline.h&quot;
<span class="lineNum">     105 </span>            : #include &quot;ipa-fnsummary.h&quot;
<span class="lineNum">     106 </span>            : #include &quot;ipa-utils.h&quot;
<span class="lineNum">     107 </span>            : #include &quot;builtins.h&quot;
<span class="lineNum">     108 </span>            : 
<span class="lineNum">     109 </span>            : /* Enumeration of all aggregate reductions we can do.  */
<span class="lineNum">     110 </span>            : enum sra_mode { SRA_MODE_EARLY_IPA,   /* early call regularization */
<span class="lineNum">     111 </span>            :                 SRA_MODE_EARLY_INTRA, /* early intraprocedural SRA */
<span class="lineNum">     112 </span>            :                 SRA_MODE_INTRA };     /* late intraprocedural SRA */
<span class="lineNum">     113 </span>            : 
<span class="lineNum">     114 </span>            : /* Global variable describing which aggregate reduction we are performing at
<span class="lineNum">     115 </span>            :    the moment.  */
<span class="lineNum">     116 </span>            : static enum sra_mode sra_mode;
<span class="lineNum">     117 </span>            : 
<span class="lineNum">     118 </span>            : struct assign_link;
<span class="lineNum">     119 </span>            : 
<span class="lineNum">     120 </span>            : /* ACCESS represents each access to an aggregate variable (as a whole or a
<span class="lineNum">     121 </span>            :    part).  It can also represent a group of accesses that refer to exactly the
<span class="lineNum">     122 </span>            :    same fragment of an aggregate (i.e. those that have exactly the same offset
<span class="lineNum">     123 </span>            :    and size).  Such representatives for a single aggregate, once determined,
<span class="lineNum">     124 </span>            :    are linked in a linked list and have the group fields set.
<span class="lineNum">     125 </span>            : 
<span class="lineNum">     126 </span>            :    Moreover, when doing intraprocedural SRA, a tree is built from those
<span class="lineNum">     127 </span>            :    representatives (by the means of first_child and next_sibling pointers), in
<span class="lineNum">     128 </span>            :    which all items in a subtree are &quot;within&quot; the root, i.e. their offset is
<span class="lineNum">     129 </span>            :    greater or equal to offset of the root and offset+size is smaller or equal
<span class="lineNum">     130 </span>            :    to offset+size of the root.  Children of an access are sorted by offset.
<span class="lineNum">     131 </span>            : 
<span class="lineNum">     132 </span>            :    Note that accesses to parts of vector and complex number types always
<span class="lineNum">     133 </span>            :    represented by an access to the whole complex number or a vector.  It is a
<span class="lineNum">     134 </span>            :    duty of the modifying functions to replace them appropriately.  */
<span class="lineNum">     135 </span>            : 
<span class="lineNum">     136 </span>            : struct access
<span class="lineNum">     137 </span>            : {
<span class="lineNum">     138 </span>            :   /* Values returned by  `get_ref_base_and_extent' for each component reference
<span class="lineNum">     139 </span>            :      If EXPR isn't a component reference  just set `BASE = EXPR', `OFFSET = 0',
<span class="lineNum">     140 </span>            :      `SIZE = TREE_SIZE (TREE_TYPE (expr))'.  */
<span class="lineNum">     141 </span>            :   HOST_WIDE_INT offset;
<span class="lineNum">     142 </span>            :   HOST_WIDE_INT size;
<span class="lineNum">     143 </span>            :   tree base;
<span class="lineNum">     144 </span>            : 
<span class="lineNum">     145 </span>            :   /* Expression.  It is context dependent so do not use it to create new
<span class="lineNum">     146 </span>            :      expressions to access the original aggregate.  See PR 42154 for a
<span class="lineNum">     147 </span>            :      testcase.  */
<span class="lineNum">     148 </span>            :   tree expr;
<span class="lineNum">     149 </span>            :   /* Type.  */
<span class="lineNum">     150 </span>            :   tree type;
<span class="lineNum">     151 </span>            : 
<span class="lineNum">     152 </span>            :   /* The statement this access belongs to.  */
<span class="lineNum">     153 </span>            :   gimple *stmt;
<span class="lineNum">     154 </span>            : 
<span class="lineNum">     155 </span>            :   /* Next group representative for this aggregate. */
<span class="lineNum">     156 </span>            :   struct access *next_grp;
<span class="lineNum">     157 </span>            : 
<span class="lineNum">     158 </span>            :   /* Pointer to the group representative.  Pointer to itself if the struct is
<span class="lineNum">     159 </span>            :      the representative.  */
<span class="lineNum">     160 </span>            :   struct access *group_representative;
<span class="lineNum">     161 </span>            : 
<span class="lineNum">     162 </span>            :   /* After access tree has been constructed, this points to the parent of the
<span class="lineNum">     163 </span>            :      current access, if there is one.  NULL for roots.  */
<span class="lineNum">     164 </span>            :   struct access *parent;
<span class="lineNum">     165 </span>            : 
<span class="lineNum">     166 </span>            :   /* If this access has any children (in terms of the definition above), this
<span class="lineNum">     167 </span>            :      points to the first one.  */
<span class="lineNum">     168 </span>            :   struct access *first_child;
<span class="lineNum">     169 </span>            : 
<span class="lineNum">     170 </span>            :   /* In intraprocedural SRA, pointer to the next sibling in the access tree as
<span class="lineNum">     171 </span>            :      described above.  In IPA-SRA this is a pointer to the next access
<span class="lineNum">     172 </span>            :      belonging to the same group (having the same representative).  */
<span class="lineNum">     173 </span>            :   struct access *next_sibling;
<span class="lineNum">     174 </span>            : 
<span class="lineNum">     175 </span>            :   /* Pointers to the first and last element in the linked list of assign
<span class="lineNum">     176 </span>            :      links.  */
<span class="lineNum">     177 </span>            :   struct assign_link *first_link, *last_link;
<span class="lineNum">     178 </span>            : 
<span class="lineNum">     179 </span>            :   /* Pointer to the next access in the work queue.  */
<span class="lineNum">     180 </span>            :   struct access *next_queued;
<span class="lineNum">     181 </span>            : 
<span class="lineNum">     182 </span>            :   /* Replacement variable for this access &quot;region.&quot;  Never to be accessed
<span class="lineNum">     183 </span>            :      directly, always only by the means of get_access_replacement() and only
<span class="lineNum">     184 </span>            :      when grp_to_be_replaced flag is set.  */
<span class="lineNum">     185 </span>            :   tree replacement_decl;
<span class="lineNum">     186 </span>            : 
<span class="lineNum">     187 </span>            :   /* Is this access an access to a non-addressable field? */
<span class="lineNum">     188 </span>            :   unsigned non_addressable : 1;
<span class="lineNum">     189 </span>            : 
<span class="lineNum">     190 </span>            :   /* Is this access made in reverse storage order? */
<span class="lineNum">     191 </span>            :   unsigned reverse : 1;
<span class="lineNum">     192 </span>            : 
<span class="lineNum">     193 </span>            :   /* Is this particular access write access? */
<span class="lineNum">     194 </span>            :   unsigned write : 1;
<span class="lineNum">     195 </span>            : 
<span class="lineNum">     196 </span>            :   /* Is this access currently in the work queue?  */
<span class="lineNum">     197 </span>            :   unsigned grp_queued : 1;
<span class="lineNum">     198 </span>            : 
<span class="lineNum">     199 </span>            :   /* Does this group contain a write access?  This flag is propagated down the
<span class="lineNum">     200 </span>            :      access tree.  */
<span class="lineNum">     201 </span>            :   unsigned grp_write : 1;
<span class="lineNum">     202 </span>            : 
<span class="lineNum">     203 </span>            :   /* Does this group contain a read access?  This flag is propagated down the
<span class="lineNum">     204 </span>            :      access tree.  */
<span class="lineNum">     205 </span>            :   unsigned grp_read : 1;
<span class="lineNum">     206 </span>            : 
<span class="lineNum">     207 </span>            :   /* Does this group contain a read access that comes from an assignment
<span class="lineNum">     208 </span>            :      statement?  This flag is propagated down the access tree.  */
<span class="lineNum">     209 </span>            :   unsigned grp_assignment_read : 1;
<span class="lineNum">     210 </span>            : 
<span class="lineNum">     211 </span>            :   /* Does this group contain a write access that comes from an assignment
<span class="lineNum">     212 </span>            :      statement?  This flag is propagated down the access tree.  */
<span class="lineNum">     213 </span>            :   unsigned grp_assignment_write : 1;
<span class="lineNum">     214 </span>            : 
<span class="lineNum">     215 </span>            :   /* Does this group contain a read access through a scalar type?  This flag is
<span class="lineNum">     216 </span>            :      not propagated in the access tree in any direction.  */
<span class="lineNum">     217 </span>            :   unsigned grp_scalar_read : 1;
<span class="lineNum">     218 </span>            : 
<span class="lineNum">     219 </span>            :   /* Does this group contain a write access through a scalar type?  This flag
<span class="lineNum">     220 </span>            :      is not propagated in the access tree in any direction.  */
<span class="lineNum">     221 </span>            :   unsigned grp_scalar_write : 1;
<span class="lineNum">     222 </span>            : 
<span class="lineNum">     223 </span>            :   /* Is this access an artificial one created to scalarize some record
<span class="lineNum">     224 </span>            :      entirely? */
<span class="lineNum">     225 </span>            :   unsigned grp_total_scalarization : 1;
<span class="lineNum">     226 </span>            : 
<span class="lineNum">     227 </span>            :   /* Other passes of the analysis use this bit to make function
<span class="lineNum">     228 </span>            :      analyze_access_subtree create scalar replacements for this group if
<span class="lineNum">     229 </span>            :      possible.  */
<span class="lineNum">     230 </span>            :   unsigned grp_hint : 1;
<span class="lineNum">     231 </span>            : 
<span class="lineNum">     232 </span>            :   /* Is the subtree rooted in this access fully covered by scalar
<span class="lineNum">     233 </span>            :      replacements?  */
<span class="lineNum">     234 </span>            :   unsigned grp_covered : 1;
<span class="lineNum">     235 </span>            : 
<span class="lineNum">     236 </span>            :   /* If set to true, this access and all below it in an access tree must not be
<span class="lineNum">     237 </span>            :      scalarized.  */
<span class="lineNum">     238 </span>            :   unsigned grp_unscalarizable_region : 1;
<span class="lineNum">     239 </span>            : 
<span class="lineNum">     240 </span>            :   /* Whether data have been written to parts of the aggregate covered by this
<span class="lineNum">     241 </span>            :      access which is not to be scalarized.  This flag is propagated up in the
<span class="lineNum">     242 </span>            :      access tree.  */
<span class="lineNum">     243 </span>            :   unsigned grp_unscalarized_data : 1;
<span class="lineNum">     244 </span>            : 
<span class="lineNum">     245 </span>            :   /* Does this access and/or group contain a write access through a
<span class="lineNum">     246 </span>            :      BIT_FIELD_REF?  */
<span class="lineNum">     247 </span>            :   unsigned grp_partial_lhs : 1;
<span class="lineNum">     248 </span>            : 
<span class="lineNum">     249 </span>            :   /* Set when a scalar replacement should be created for this variable.  */
<span class="lineNum">     250 </span>            :   unsigned grp_to_be_replaced : 1;
<span class="lineNum">     251 </span>            : 
<span class="lineNum">     252 </span>            :   /* Set when we want a replacement for the sole purpose of having it in
<span class="lineNum">     253 </span>            :      generated debug statements.  */
<span class="lineNum">     254 </span>            :   unsigned grp_to_be_debug_replaced : 1;
<span class="lineNum">     255 </span>            : 
<span class="lineNum">     256 </span>            :   /* Should TREE_NO_WARNING of a replacement be set?  */
<span class="lineNum">     257 </span>            :   unsigned grp_no_warning : 1;
<span class="lineNum">     258 </span>            : 
<span class="lineNum">     259 </span>            :   /* Is it possible that the group refers to data which might be (directly or
<span class="lineNum">     260 </span>            :      otherwise) modified?  */
<span class="lineNum">     261 </span>            :   unsigned grp_maybe_modified : 1;
<span class="lineNum">     262 </span>            : 
<span class="lineNum">     263 </span>            :   /* Set when this is a representative of a pointer to scalar (i.e. by
<span class="lineNum">     264 </span>            :      reference) parameter which we consider for turning into a plain scalar
<span class="lineNum">     265 </span>            :      (i.e. a by value parameter).  */
<span class="lineNum">     266 </span>            :   unsigned grp_scalar_ptr : 1;
<span class="lineNum">     267 </span>            : 
<span class="lineNum">     268 </span>            :   /* Set when we discover that this pointer is not safe to dereference in the
<span class="lineNum">     269 </span>            :      caller.  */
<span class="lineNum">     270 </span>            :   unsigned grp_not_necessarilly_dereferenced : 1;
<span class="lineNum">     271 </span>            : };
<span class="lineNum">     272 </span>            : 
<span class="lineNum">     273 </span>            : typedef struct access *access_p;
<span class="lineNum">     274 </span>            : 
<span class="lineNum">     275 </span>            : 
<span class="lineNum">     276 </span>            : /* Alloc pool for allocating access structures.  */
<span class="lineNum">     277 </span>            : static object_allocator&lt;struct access&gt; access_pool (&quot;SRA accesses&quot;);
<span class="lineNum">     278 </span>            : 
<span class="lineNum">     279 </span>            : /* A structure linking lhs and rhs accesses from an aggregate assignment.  They
<span class="lineNum">     280 </span>            :    are used to propagate subaccesses from rhs to lhs as long as they don't
<span class="lineNum">     281 </span>            :    conflict with what is already there.  */
<span class="lineNum">     282 </span>            : struct assign_link
<span class="lineNum">     283 </span>            : {
<span class="lineNum">     284 </span>            :   struct access *lacc, *racc;
<span class="lineNum">     285 </span>            :   struct assign_link *next;
<span class="lineNum">     286 </span>            : };
<span class="lineNum">     287 </span>            : 
<span class="lineNum">     288 </span>            : /* Alloc pool for allocating assign link structures.  */
<span class="lineNum">     289 </span>            : static object_allocator&lt;assign_link&gt; assign_link_pool (&quot;SRA links&quot;);
<span class="lineNum">     290 </span>            : 
<span class="lineNum">     291 </span>            : /* Base (tree) -&gt; Vector (vec&lt;access_p&gt; *) map.  */
<span class="lineNum">     292 </span>            : static hash_map&lt;tree, auto_vec&lt;access_p&gt; &gt; *base_access_vec;
<span class="lineNum">     293 </span>            : 
<span class="lineNum">     294 </span>            : /* Candidate hash table helpers.  */
<span class="lineNum">     295 </span>            : 
<span class="lineNum">     296 </span>            : struct uid_decl_hasher : nofree_ptr_hash &lt;tree_node&gt;
<span class="lineNum">     297 </span>            : {
<span class="lineNum">     298 </span>            :   static inline hashval_t hash (const tree_node *);
<span class="lineNum">     299 </span>            :   static inline bool equal (const tree_node *, const tree_node *);
<span class="lineNum">     300 </span>            : };
<span class="lineNum">     301 </span>            : 
<span class="lineNum">     302 </span>            : /* Hash a tree in a uid_decl_map.  */
<a name="303"><span class="lineNum">     303 </span>            : </a>
<span class="lineNum">     304 </span>            : inline hashval_t
<span class="lineNum">     305 </span><span class="lineNoCov">          0 : uid_decl_hasher::hash (const tree_node *item)</span>
<span class="lineNum">     306 </span>            : {
<span class="lineNum">     307 </span><span class="lineCov">     843639 :   return item-&gt;decl_minimal.uid;</span>
<span class="lineNum">     308 </span>            : }
<span class="lineNum">     309 </span>            : 
<span class="lineNum">     310 </span>            : /* Return true if the DECL_UID in both trees are equal.  */
<a name="311"><span class="lineNum">     311 </span>            : </a>
<span class="lineNum">     312 </span>            : inline bool
<span class="lineNum">     313 </span><span class="lineNoCov">          0 : uid_decl_hasher::equal (const tree_node *a, const tree_node *b)</span>
<span class="lineNum">     314 </span>            : {
<span class="lineNum">     315 </span><span class="lineCov">   10493297 :   return (a-&gt;decl_minimal.uid == b-&gt;decl_minimal.uid);</span>
<span class="lineNum">     316 </span>            : }
<span class="lineNum">     317 </span>            : 
<span class="lineNum">     318 </span>            : /* Set of candidates.  */
<span class="lineNum">     319 </span>            : static bitmap candidate_bitmap;
<span class="lineNum">     320 </span>            : static hash_table&lt;uid_decl_hasher&gt; *candidates;
<span class="lineNum">     321 </span>            : 
<span class="lineNum">     322 </span>            : /* For a candidate UID return the candidates decl.  */
<span class="lineNum">     323 </span>            : 
<span class="lineNum">     324 </span>            : static inline tree
<span class="lineNum">     325 </span>            : candidate (unsigned uid)
<span class="lineNum">     326 </span>            : {
<span class="lineNum">     327 </span><span class="lineCov">    6436350 :  tree_node t;</span>
<span class="lineNum">     328 </span><span class="lineCov">    6436350 :  t.decl_minimal.uid = uid;</span>
<span class="lineNum">     329 </span><span class="lineCov">   12872700 :  return candidates-&gt;find_with_hash (&amp;t, static_cast &lt;hashval_t&gt; (uid));</span>
<span class="lineNum">     330 </span>            : }
<span class="lineNum">     331 </span>            : 
<span class="lineNum">     332 </span>            : /* Bitmap of candidates which we should try to entirely scalarize away and
<span class="lineNum">     333 </span>            :    those which cannot be (because they are and need be used as a whole).  */
<span class="lineNum">     334 </span>            : static bitmap should_scalarize_away_bitmap, cannot_scalarize_away_bitmap;
<span class="lineNum">     335 </span>            : 
<span class="lineNum">     336 </span>            : /* Bitmap of candidates in the constant pool, which cannot be scalarized
<span class="lineNum">     337 </span>            :    because this would produce non-constant expressions (e.g. Ada).  */
<span class="lineNum">     338 </span>            : static bitmap disqualified_constants;
<span class="lineNum">     339 </span>            : 
<span class="lineNum">     340 </span>            : /* Obstack for creation of fancy names.  */
<span class="lineNum">     341 </span>            : static struct obstack name_obstack;
<span class="lineNum">     342 </span>            : 
<span class="lineNum">     343 </span>            : /* Head of a linked list of accesses that need to have its subaccesses
<span class="lineNum">     344 </span>            :    propagated to their assignment counterparts. */
<span class="lineNum">     345 </span>            : static struct access *work_queue_head;
<span class="lineNum">     346 </span>            : 
<span class="lineNum">     347 </span>            : /* Number of parameters of the analyzed function when doing early ipa SRA.  */
<span class="lineNum">     348 </span>            : static int func_param_count;
<span class="lineNum">     349 </span>            : 
<span class="lineNum">     350 </span>            : /* scan_function sets the following to true if it encounters a call to
<span class="lineNum">     351 </span>            :    __builtin_apply_args.  */
<span class="lineNum">     352 </span>            : static bool encountered_apply_args;
<span class="lineNum">     353 </span>            : 
<span class="lineNum">     354 </span>            : /* Set by scan_function when it finds a recursive call.  */
<span class="lineNum">     355 </span>            : static bool encountered_recursive_call;
<span class="lineNum">     356 </span>            : 
<span class="lineNum">     357 </span>            : /* Set by scan_function when it finds a recursive call with less actual
<span class="lineNum">     358 </span>            :    arguments than formal parameters..  */
<span class="lineNum">     359 </span>            : static bool encountered_unchangable_recursive_call;
<span class="lineNum">     360 </span>            : 
<span class="lineNum">     361 </span>            : /* This is a table in which for each basic block and parameter there is a
<span class="lineNum">     362 </span>            :    distance (offset + size) in that parameter which is dereferenced and
<span class="lineNum">     363 </span>            :    accessed in that BB.  */
<span class="lineNum">     364 </span>            : static HOST_WIDE_INT *bb_dereferences;
<span class="lineNum">     365 </span>            : /* Bitmap of BBs that can cause the function to &quot;stop&quot; progressing by
<span class="lineNum">     366 </span>            :    returning, throwing externally, looping infinitely or calling a function
<span class="lineNum">     367 </span>            :    which might abort etc.. */
<span class="lineNum">     368 </span>            : static bitmap final_bbs;
<span class="lineNum">     369 </span>            : 
<span class="lineNum">     370 </span>            : /* Representative of no accesses at all. */
<span class="lineNum">     371 </span>            : static struct access  no_accesses_representant;
<span class="lineNum">     372 </span>            : 
<span class="lineNum">     373 </span>            : /* Predicate to test the special value.  */
<span class="lineNum">     374 </span>            : 
<span class="lineNum">     375 </span>            : static inline bool
<span class="lineNum">     376 </span>            : no_accesses_p (struct access *access)
<span class="lineNum">     377 </span>            : {
<span class="lineNum">     378 </span><span class="lineCov">    1394455 :   return access == &amp;no_accesses_representant;</span>
<span class="lineNum">     379 </span>            : }
<span class="lineNum">     380 </span>            : 
<span class="lineNum">     381 </span>            : /* Dump contents of ACCESS to file F in a human friendly way.  If GRP is true,
<span class="lineNum">     382 </span>            :    representative fields are dumped, otherwise those which only describe the
<span class="lineNum">     383 </span>            :    individual access are.  */
<span class="lineNum">     384 </span>            : 
<span class="lineNum">     385 </span>            : static struct
<span class="lineNum">     386 </span>            : {
<span class="lineNum">     387 </span>            :   /* Number of processed aggregates is readily available in
<span class="lineNum">     388 </span>            :      analyze_all_variable_accesses and so is not stored here.  */
<span class="lineNum">     389 </span>            : 
<span class="lineNum">     390 </span>            :   /* Number of created scalar replacements.  */
<span class="lineNum">     391 </span>            :   int replacements;
<span class="lineNum">     392 </span>            : 
<span class="lineNum">     393 </span>            :   /* Number of times sra_modify_expr or sra_modify_assign themselves changed an
<span class="lineNum">     394 </span>            :      expression.  */
<span class="lineNum">     395 </span>            :   int exprs;
<span class="lineNum">     396 </span>            : 
<span class="lineNum">     397 </span>            :   /* Number of statements created by generate_subtree_copies.  */
<span class="lineNum">     398 </span>            :   int subtree_copies;
<span class="lineNum">     399 </span>            : 
<span class="lineNum">     400 </span>            :   /* Number of statements created by load_assign_lhs_subreplacements.  */
<span class="lineNum">     401 </span>            :   int subreplacements;
<span class="lineNum">     402 </span>            : 
<span class="lineNum">     403 </span>            :   /* Number of times sra_modify_assign has deleted a statement.  */
<span class="lineNum">     404 </span>            :   int deleted;
<span class="lineNum">     405 </span>            : 
<span class="lineNum">     406 </span>            :   /* Number of times sra_modify_assign has to deal with subaccesses of LHS and
<span class="lineNum">     407 </span>            :      RHS reparately due to type conversions or nonexistent matching
<span class="lineNum">     408 </span>            :      references.  */
<span class="lineNum">     409 </span>            :   int separate_lhs_rhs_handling;
<span class="lineNum">     410 </span>            : 
<span class="lineNum">     411 </span>            :   /* Number of parameters that were removed because they were unused.  */
<span class="lineNum">     412 </span>            :   int deleted_unused_parameters;
<span class="lineNum">     413 </span>            : 
<span class="lineNum">     414 </span>            :   /* Number of scalars passed as parameters by reference that have been
<span class="lineNum">     415 </span>            :      converted to be passed by value.  */
<span class="lineNum">     416 </span>            :   int scalar_by_ref_to_by_val;
<span class="lineNum">     417 </span>            : 
<span class="lineNum">     418 </span>            :   /* Number of aggregate parameters that were replaced by one or more of their
<span class="lineNum">     419 </span>            :      components.  */
<span class="lineNum">     420 </span>            :   int aggregate_params_reduced;
<span class="lineNum">     421 </span>            : 
<span class="lineNum">     422 </span>            :   /* Numbber of components created when splitting aggregate parameters.  */
<span class="lineNum">     423 </span>            :   int param_reductions_created;
<span class="lineNum">     424 </span>            : } sra_stats;
<a name="425"><span class="lineNum">     425 </span>            : </a>
<span class="lineNum">     426 </span>            : static void
<span class="lineNum">     427 </span><span class="lineCov">         46 : dump_access (FILE *f, struct access *access, bool grp)</span>
<span class="lineNum">     428 </span>            : {
<span class="lineNum">     429 </span><span class="lineCov">         46 :   fprintf (f, &quot;access { &quot;);</span>
<span class="lineNum">     430 </span><span class="lineCov">         46 :   fprintf (f, &quot;base = (%d)'&quot;, DECL_UID (access-&gt;base));</span>
<span class="lineNum">     431 </span><span class="lineCov">         46 :   print_generic_expr (f, access-&gt;base);</span>
<span class="lineNum">     432 </span><span class="lineCov">         46 :   fprintf (f, &quot;', offset = &quot; HOST_WIDE_INT_PRINT_DEC, access-&gt;offset);</span>
<span class="lineNum">     433 </span><span class="lineCov">         46 :   fprintf (f, &quot;, size = &quot; HOST_WIDE_INT_PRINT_DEC, access-&gt;size);</span>
<span class="lineNum">     434 </span><span class="lineCov">         46 :   fprintf (f, &quot;, expr = &quot;);</span>
<span class="lineNum">     435 </span><span class="lineCov">         46 :   print_generic_expr (f, access-&gt;expr);</span>
<span class="lineNum">     436 </span><span class="lineCov">         46 :   fprintf (f, &quot;, type = &quot;);</span>
<span class="lineNum">     437 </span><span class="lineCov">         46 :   print_generic_expr (f, access-&gt;type);</span>
<span class="lineNum">     438 </span><span class="lineCov">        138 :   fprintf (f, &quot;, non_addressable = %d, reverse = %d&quot;,</span>
<span class="lineNum">     439 </span><span class="lineCov">         46 :            access-&gt;non_addressable, access-&gt;reverse);</span>
<span class="lineNum">     440 </span><span class="lineCov">         46 :   if (grp)</span>
<span class="lineNum">     441 </span><span class="lineCov">        782 :     fprintf (f, &quot;, grp_read = %d, grp_write = %d, grp_assignment_read = %d, &quot;</span>
<span class="lineNum">     442 </span>            :              &quot;grp_assignment_write = %d, grp_scalar_read = %d, &quot;
<span class="lineNum">     443 </span>            :              &quot;grp_scalar_write = %d, grp_total_scalarization = %d, &quot;
<span class="lineNum">     444 </span>            :              &quot;grp_hint = %d, grp_covered = %d, &quot;
<span class="lineNum">     445 </span>            :              &quot;grp_unscalarizable_region = %d, grp_unscalarized_data = %d, &quot;
<span class="lineNum">     446 </span>            :              &quot;grp_partial_lhs = %d, grp_to_be_replaced = %d, &quot;
<span class="lineNum">     447 </span>            :              &quot;grp_to_be_debug_replaced = %d, grp_maybe_modified = %d, &quot;
<span class="lineNum">     448 </span>            :              &quot;grp_not_necessarilly_dereferenced = %d\n&quot;,
<span class="lineNum">     449 </span><span class="lineCov">        138 :              access-&gt;grp_read, access-&gt;grp_write, access-&gt;grp_assignment_read,</span>
<span class="lineNum">     450 </span><span class="lineCov">         92 :              access-&gt;grp_assignment_write, access-&gt;grp_scalar_read,</span>
<span class="lineNum">     451 </span><span class="lineCov">         92 :              access-&gt;grp_scalar_write, access-&gt;grp_total_scalarization,</span>
<span class="lineNum">     452 </span><span class="lineCov">         92 :              access-&gt;grp_hint, access-&gt;grp_covered,</span>
<span class="lineNum">     453 </span><span class="lineCov">         92 :              access-&gt;grp_unscalarizable_region, access-&gt;grp_unscalarized_data,</span>
<span class="lineNum">     454 </span><span class="lineCov">         92 :              access-&gt;grp_partial_lhs, access-&gt;grp_to_be_replaced,</span>
<span class="lineNum">     455 </span><span class="lineCov">         92 :              access-&gt;grp_to_be_debug_replaced, access-&gt;grp_maybe_modified,</span>
<span class="lineNum">     456 </span><span class="lineCov">         46 :              access-&gt;grp_not_necessarilly_dereferenced);</span>
<span class="lineNum">     457 </span>            :   else
<span class="lineNum">     458 </span><span class="lineNoCov">          0 :     fprintf (f, &quot;, write = %d, grp_total_scalarization = %d, &quot;</span>
<span class="lineNum">     459 </span>            :              &quot;grp_partial_lhs = %d\n&quot;,
<span class="lineNum">     460 </span><span class="lineNoCov">          0 :              access-&gt;write, access-&gt;grp_total_scalarization,</span>
<span class="lineNum">     461 </span><span class="lineNoCov">          0 :              access-&gt;grp_partial_lhs);</span>
<span class="lineNum">     462 </span><span class="lineCov">         46 : }</span>
<span class="lineNum">     463 </span>            : 
<span class="lineNum">     464 </span>            : /* Dump a subtree rooted in ACCESS to file F, indent by LEVEL.  */
<a name="465"><span class="lineNum">     465 </span>            : </a>
<span class="lineNum">     466 </span>            : static void
<span class="lineNum">     467 </span><span class="lineCov">         14 : dump_access_tree_1 (FILE *f, struct access *access, int level)</span>
<span class="lineNum">     468 </span>            : {
<span class="lineNum">     469 </span><span class="lineCov">         36 :   do</span>
<span class="lineNum">     470 </span>            :     {
<span class="lineNum">     471 </span><span class="lineCov">         36 :       int i;</span>
<span class="lineNum">     472 </span>            : 
<span class="lineNum">     473 </span><span class="lineCov">         64 :       for (i = 0; i &lt; level; i++)</span>
<span class="lineNum">     474 </span><span class="lineCov">         28 :         fputs (&quot;* &quot;, f);</span>
<span class="lineNum">     475 </span>            : 
<span class="lineNum">     476 </span><span class="lineCov">         36 :       dump_access (f, access, true);</span>
<span class="lineNum">     477 </span>            : 
<span class="lineNum">     478 </span><span class="lineCov">         36 :       if (access-&gt;first_child)</span>
<span class="lineNum">     479 </span><span class="lineCov">          6 :         dump_access_tree_1 (f, access-&gt;first_child, level + 1);</span>
<span class="lineNum">     480 </span>            : 
<span class="lineNum">     481 </span><span class="lineCov">         36 :       access = access-&gt;next_sibling;</span>
<span class="lineNum">     482 </span>            :     }
<span class="lineNum">     483 </span><span class="lineCov">         36 :   while (access);</span>
<span class="lineNum">     484 </span><span class="lineCov">         14 : }</span>
<span class="lineNum">     485 </span>            : 
<span class="lineNum">     486 </span>            : /* Dump all access trees for a variable, given the pointer to the first root in
<span class="lineNum">     487 </span>            :    ACCESS.  */
<a name="488"><span class="lineNum">     488 </span>            : </a>
<span class="lineNum">     489 </span>            : static void
<span class="lineNum">     490 </span><span class="lineNoCov">          0 : dump_access_tree (FILE *f, struct access *access)</span>
<span class="lineNum">     491 </span>            : {
<span class="lineNum">     492 </span><span class="lineCov">         15 :   for (; access; access = access-&gt;next_grp)</span>
<span class="lineNum">     493 </span><span class="lineCov">          8 :     dump_access_tree_1 (f, access, 0);</span>
<span class="lineNum">     494 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     495 </span>            : 
<span class="lineNum">     496 </span>            : /* Return true iff ACC is non-NULL and has subaccesses.  */
<span class="lineNum">     497 </span>            : 
<span class="lineNum">     498 </span>            : static inline bool
<span class="lineNum">     499 </span>            : access_has_children_p (struct access *acc)
<span class="lineNum">     500 </span>            : {
<span class="lineNum">     501 </span><span class="lineCov">    4211024 :   return acc &amp;&amp; acc-&gt;first_child;</span>
<span class="lineNum">     502 </span>            : }
<span class="lineNum">     503 </span>            : 
<span class="lineNum">     504 </span>            : /* Return true iff ACC is (partly) covered by at least one replacement.  */
<a name="505"><span class="lineNum">     505 </span>            : </a>
<span class="lineNum">     506 </span>            : static bool
<span class="lineNum">     507 </span><span class="lineCov">        565 : access_has_replacements_p (struct access *acc)</span>
<span class="lineNum">     508 </span>            : {
<span class="lineNum">     509 </span><span class="lineCov">        565 :   struct access *child;</span>
<span class="lineNum">     510 </span><span class="lineCov">        565 :   if (acc-&gt;grp_to_be_replaced)</span>
<span class="lineNum">     511 </span>            :     return true;
<span class="lineNum">     512 </span><span class="lineCov">        508 :   for (child = acc-&gt;first_child; child; child = child-&gt;next_sibling)</span>
<span class="lineNum">     513 </span><span class="lineCov">         69 :     if (access_has_replacements_p (child))</span>
<span class="lineNum">     514 </span>            :       return true;
<span class="lineNum">     515 </span>            :   return false;
<span class="lineNum">     516 </span>            : }
<span class="lineNum">     517 </span>            : 
<span class="lineNum">     518 </span>            : /* Return a vector of pointers to accesses for the variable given in BASE or
<span class="lineNum">     519 </span>            :    NULL if there is none.  */
<a name="520"><span class="lineNum">     520 </span>            : </a>
<span class="lineNum">     521 </span>            : static vec&lt;access_p&gt; *
<span class="lineNum">     522 </span><span class="lineNoCov">          0 : get_base_access_vector (tree base)</span>
<span class="lineNum">     523 </span>            : {
<span class="lineNum">     524 </span><span class="lineNoCov">          0 :   return base_access_vec-&gt;get (base);</span>
<span class="lineNum">     525 </span>            : }
<span class="lineNum">     526 </span>            : 
<span class="lineNum">     527 </span>            : /* Find an access with required OFFSET and SIZE in a subtree of accesses rooted
<span class="lineNum">     528 </span>            :    in ACCESS.  Return NULL if it cannot be found.  */
<a name="529"><span class="lineNum">     529 </span>            : </a>
<span class="lineNum">     530 </span>            : static struct access *
<span class="lineNum">     531 </span><span class="lineNoCov">          0 : find_access_in_subtree (struct access *access, HOST_WIDE_INT offset,</span>
<span class="lineNum">     532 </span>            :                         HOST_WIDE_INT size)
<span class="lineNum">     533 </span>            : {
<span class="lineNum">     534 </span><span class="lineCov">    8401388 :   while (access &amp;&amp; (access-&gt;offset != offset || access-&gt;size != size))</span>
<span class="lineNum">     535 </span>            :     {
<span class="lineNum">     536 </span><span class="lineCov">    2781909 :       struct access *child = access-&gt;first_child;</span>
<span class="lineNum">     537 </span>            : 
<span class="lineNum">     538 </span><span class="lineCov">    5471923 :       while (child &amp;&amp; (child-&gt;offset + child-&gt;size &lt;= offset))</span>
<span class="lineNum">     539 </span><span class="lineCov">    2690014 :         child = child-&gt;next_sibling;</span>
<span class="lineNum">     540 </span>            :       access = child;
<span class="lineNum">     541 </span>            :     }
<span class="lineNum">     542 </span>            : 
<span class="lineNum">     543 </span><span class="lineCov">     901963 :   return access;</span>
<span class="lineNum">     544 </span>            : }
<span class="lineNum">     545 </span>            : 
<span class="lineNum">     546 </span>            : /* Return the first group representative for DECL or NULL if none exists.  */
<a name="547"><span class="lineNum">     547 </span>            : </a>
<span class="lineNum">     548 </span>            : static struct access *
<span class="lineNum">     549 </span><span class="lineCov">    7006347 : get_first_repr_for_decl (tree base)</span>
<span class="lineNum">     550 </span>            : {
<span class="lineNum">     551 </span><span class="lineCov">    7006347 :   vec&lt;access_p&gt; *access_vec;</span>
<span class="lineNum">     552 </span>            : 
<span class="lineNum">     553 </span><span class="lineCov">    7006347 :   access_vec = get_base_access_vector (base);</span>
<span class="lineNum">     554 </span><span class="lineCov">    7006347 :   if (!access_vec)</span>
<span class="lineNum">     555 </span><span class="lineNoCov">          0 :     return NULL;</span>
<span class="lineNum">     556 </span>            : 
<span class="lineNum">     557 </span><span class="lineCov">    7006347 :   return (*access_vec)[0];</span>
<span class="lineNum">     558 </span>            : }
<span class="lineNum">     559 </span>            : 
<span class="lineNum">     560 </span>            : /* Find an access representative for the variable BASE and given OFFSET and
<span class="lineNum">     561 </span>            :    SIZE.  Requires that access trees have already been built.  Return NULL if
<span class="lineNum">     562 </span>            :    it cannot be found.  */
<a name="563"><span class="lineNum">     563 </span>            : </a>
<span class="lineNum">     564 </span>            : static struct access *
<span class="lineNum">     565 </span><span class="lineCov">    4717553 : get_var_base_offset_size_access (tree base, HOST_WIDE_INT offset,</span>
<span class="lineNum">     566 </span>            :                                  HOST_WIDE_INT size)
<span class="lineNum">     567 </span>            : {
<span class="lineNum">     568 </span><span class="lineCov">    4717553 :   struct access *access;</span>
<span class="lineNum">     569 </span>            : 
<span class="lineNum">     570 </span><span class="lineCov">    4717553 :   access = get_first_repr_for_decl (base);</span>
<span class="lineNum">     571 </span><span class="lineCov">    5812608 :   while (access &amp;&amp; (access-&gt;offset + access-&gt;size &lt;= offset))</span>
<span class="lineNum">     572 </span><span class="lineCov">    1095055 :     access = access-&gt;next_grp;</span>
<span class="lineNum">     573 </span><span class="lineCov">    4717553 :   if (!access)</span>
<span class="lineNum">     574 </span>            :     return NULL;
<span class="lineNum">     575 </span>            : 
<span class="lineNum">     576 </span>            :   return find_access_in_subtree (access, offset, size);
<span class="lineNum">     577 </span>            : }
<span class="lineNum">     578 </span>            : 
<a name="579"><span class="lineNum">     579 </span>            : /* Add LINK to the linked list of assign links of RACC.  */</a>
<span class="lineNum">     580 </span>            : static void
<span class="lineNum">     581 </span><span class="lineCov">     709245 : add_link_to_rhs (struct access *racc, struct assign_link *link)</span>
<span class="lineNum">     582 </span>            : {
<span class="lineNum">     583 </span><span class="lineCov">     709245 :   gcc_assert (link-&gt;racc == racc);</span>
<span class="lineNum">     584 </span>            : 
<span class="lineNum">     585 </span><span class="lineCov">     709245 :   if (!racc-&gt;first_link)</span>
<span class="lineNum">     586 </span>            :     {
<span class="lineNum">     587 </span><span class="lineCov">     709245 :       gcc_assert (!racc-&gt;last_link);</span>
<span class="lineNum">     588 </span><span class="lineCov">     709245 :       racc-&gt;first_link = link;</span>
<span class="lineNum">     589 </span>            :     }
<span class="lineNum">     590 </span>            :   else
<span class="lineNum">     591 </span><span class="lineNoCov">          0 :     racc-&gt;last_link-&gt;next = link;</span>
<span class="lineNum">     592 </span>            : 
<span class="lineNum">     593 </span><span class="lineCov">     709245 :   racc-&gt;last_link = link;</span>
<span class="lineNum">     594 </span><span class="lineCov">     709245 :   link-&gt;next = NULL;</span>
<span class="lineNum">     595 </span><span class="lineCov">     709245 : }</span>
<span class="lineNum">     596 </span>            : 
<span class="lineNum">     597 </span>            : /* Move all link structures in their linked list in OLD_RACC to the linked list
<a name="598"><span class="lineNum">     598 </span>            :    in NEW_RACC.  */</a>
<span class="lineNum">     599 </span>            : static void
<span class="lineNum">     600 </span><span class="lineCov">    3672134 : relink_to_new_repr (struct access *new_racc, struct access *old_racc)</span>
<span class="lineNum">     601 </span>            : {
<span class="lineNum">     602 </span><span class="lineCov">    3672134 :   if (!old_racc-&gt;first_link)</span>
<span class="lineNum">     603 </span>            :     {
<span class="lineNum">     604 </span><span class="lineCov">    3185545 :       gcc_assert (!old_racc-&gt;last_link);</span>
<span class="lineNum">     605 </span>            :       return;
<span class="lineNum">     606 </span>            :     }
<span class="lineNum">     607 </span>            : 
<span class="lineNum">     608 </span><span class="lineCov">     486589 :   if (new_racc-&gt;first_link)</span>
<span class="lineNum">     609 </span>            :     {
<span class="lineNum">     610 </span><span class="lineCov">      84977 :       gcc_assert (!new_racc-&gt;last_link-&gt;next);</span>
<span class="lineNum">     611 </span><span class="lineCov">      84977 :       gcc_assert (!old_racc-&gt;last_link || !old_racc-&gt;last_link-&gt;next);</span>
<span class="lineNum">     612 </span>            : 
<span class="lineNum">     613 </span><span class="lineCov">      84977 :       new_racc-&gt;last_link-&gt;next = old_racc-&gt;first_link;</span>
<span class="lineNum">     614 </span><span class="lineCov">      84977 :       new_racc-&gt;last_link = old_racc-&gt;last_link;</span>
<span class="lineNum">     615 </span>            :     }
<span class="lineNum">     616 </span>            :   else
<span class="lineNum">     617 </span>            :     {
<span class="lineNum">     618 </span><span class="lineCov">     401612 :       gcc_assert (!new_racc-&gt;last_link);</span>
<span class="lineNum">     619 </span>            : 
<span class="lineNum">     620 </span><span class="lineCov">     401612 :       new_racc-&gt;first_link = old_racc-&gt;first_link;</span>
<span class="lineNum">     621 </span><span class="lineCov">     401612 :       new_racc-&gt;last_link = old_racc-&gt;last_link;</span>
<span class="lineNum">     622 </span>            :     }
<span class="lineNum">     623 </span><span class="lineCov">     486589 :   old_racc-&gt;first_link = old_racc-&gt;last_link = NULL;</span>
<span class="lineNum">     624 </span>            : }
<span class="lineNum">     625 </span>            : 
<span class="lineNum">     626 </span>            : /* Add ACCESS to the work queue (which is actually a stack).  */
<a name="627"><span class="lineNum">     627 </span>            : </a>
<span class="lineNum">     628 </span>            : static void
<span class="lineNum">     629 </span><span class="lineCov">    2617274 : add_access_to_work_queue (struct access *access)</span>
<span class="lineNum">     630 </span>            : {
<span class="lineNum">     631 </span><span class="lineCov">    2617274 :   if (access-&gt;first_link &amp;&amp; !access-&gt;grp_queued)</span>
<span class="lineNum">     632 </span>            :     {
<span class="lineNum">     633 </span><span class="lineCov">     900642 :       gcc_assert (!access-&gt;next_queued);</span>
<span class="lineNum">     634 </span><span class="lineCov">     900642 :       access-&gt;next_queued = work_queue_head;</span>
<span class="lineNum">     635 </span><span class="lineCov">     900642 :       access-&gt;grp_queued = 1;</span>
<span class="lineNum">     636 </span><span class="lineCov">     900642 :       work_queue_head = access;</span>
<span class="lineNum">     637 </span>            :     }
<span class="lineNum">     638 </span><span class="lineCov">    2617274 : }</span>
<span class="lineNum">     639 </span>            : 
<span class="lineNum">     640 </span>            : /* Pop an access from the work queue, and return it, assuming there is one.  */
<a name="641"><span class="lineNum">     641 </span>            : </a>
<span class="lineNum">     642 </span>            : static struct access *
<span class="lineNum">     643 </span><span class="lineNoCov">          0 : pop_access_from_work_queue (void)</span>
<span class="lineNum">     644 </span>            : {
<span class="lineNum">     645 </span><span class="lineCov">     900642 :   struct access *access = work_queue_head;</span>
<span class="lineNum">     646 </span>            : 
<span class="lineNum">     647 </span><span class="lineCov">     900642 :   work_queue_head = access-&gt;next_queued;</span>
<span class="lineNum">     648 </span><span class="lineCov">     900642 :   access-&gt;next_queued = NULL;</span>
<span class="lineNum">     649 </span><span class="lineCov">     900642 :   access-&gt;grp_queued = 0;</span>
<span class="lineNum">     650 </span><span class="lineCov">     900642 :   return access;</span>
<span class="lineNum">     651 </span>            : }
<span class="lineNum">     652 </span>            : 
<span class="lineNum">     653 </span>            : 
<span class="lineNum">     654 </span>            : /* Allocate necessary structures.  */
<a name="655"><span class="lineNum">     655 </span>            : </a>
<span class="lineNum">     656 </span>            : static void
<span class="lineNum">     657 </span><span class="lineCov">    2617353 : sra_initialize (void)</span>
<span class="lineNum">     658 </span>            : {
<span class="lineNum">     659 </span><span class="lineCov">    2617353 :   candidate_bitmap = BITMAP_ALLOC (NULL);</span>
<span class="lineNum">     660 </span><span class="lineCov">    5234706 :   candidates = new hash_table&lt;uid_decl_hasher&gt;</span>
<span class="lineNum">     661 </span><span class="lineCov">    4893381 :     (vec_safe_length (cfun-&gt;local_decls) / 2);</span>
<span class="lineNum">     662 </span><span class="lineCov">    2617353 :   should_scalarize_away_bitmap = BITMAP_ALLOC (NULL);</span>
<span class="lineNum">     663 </span><span class="lineCov">    2617353 :   cannot_scalarize_away_bitmap = BITMAP_ALLOC (NULL);</span>
<span class="lineNum">     664 </span><span class="lineCov">    2617353 :   disqualified_constants = BITMAP_ALLOC (NULL);</span>
<span class="lineNum">     665 </span><span class="lineCov">    2617353 :   gcc_obstack_init (&amp;name_obstack);</span>
<span class="lineNum">     666 </span><span class="lineCov">    2617353 :   base_access_vec = new hash_map&lt;tree, auto_vec&lt;access_p&gt; &gt;;</span>
<span class="lineNum">     667 </span><span class="lineCov">    2617353 :   memset (&amp;sra_stats, 0, sizeof (sra_stats));</span>
<span class="lineNum">     668 </span><span class="lineCov">    2617353 :   encountered_apply_args = false;</span>
<span class="lineNum">     669 </span><span class="lineCov">    2617353 :   encountered_recursive_call = false;</span>
<span class="lineNum">     670 </span><span class="lineCov">    2617353 :   encountered_unchangable_recursive_call = false;</span>
<span class="lineNum">     671 </span><span class="lineCov">    2617353 : }</span>
<span class="lineNum">     672 </span>            : 
<span class="lineNum">     673 </span>            : /* Deallocate all general structures.  */
<a name="674"><span class="lineNum">     674 </span>            : </a>
<span class="lineNum">     675 </span>            : static void
<span class="lineNum">     676 </span><span class="lineCov">    2617353 : sra_deinitialize (void)</span>
<span class="lineNum">     677 </span>            : {
<span class="lineNum">     678 </span><span class="lineCov">    2617353 :   BITMAP_FREE (candidate_bitmap);</span>
<span class="lineNum">     679 </span><span class="lineCov">    2617353 :   delete candidates;</span>
<span class="lineNum">     680 </span><span class="lineCov">    2617353 :   candidates = NULL;</span>
<span class="lineNum">     681 </span><span class="lineCov">    2617353 :   BITMAP_FREE (should_scalarize_away_bitmap);</span>
<span class="lineNum">     682 </span><span class="lineCov">    2617353 :   BITMAP_FREE (cannot_scalarize_away_bitmap);</span>
<span class="lineNum">     683 </span><span class="lineCov">    2617353 :   BITMAP_FREE (disqualified_constants);</span>
<span class="lineNum">     684 </span><span class="lineCov">    2617353 :   access_pool.release ();</span>
<span class="lineNum">     685 </span><span class="lineCov">    2617353 :   assign_link_pool.release ();</span>
<span class="lineNum">     686 </span><span class="lineCov">    2617353 :   obstack_free (&amp;name_obstack, NULL);</span>
<span class="lineNum">     687 </span>            : 
<span class="lineNum">     688 </span><span class="lineCov">    2617353 :   delete base_access_vec;</span>
<span class="lineNum">     689 </span><span class="lineCov">    2617353 : }</span>
<span class="lineNum">     690 </span>            : 
<a name="691"><span class="lineNum">     691 </span>            : /* Return true if DECL is a VAR_DECL in the constant pool, false otherwise.  */</a>
<span class="lineNum">     692 </span>            : 
<span class="lineNum">     693 </span><span class="lineNoCov">          0 : static bool constant_decl_p (tree decl)</span>
<span class="lineNum">     694 </span>            : {
<span class="lineNum">     695 </span><span class="lineCov">   32579400 :   return VAR_P (decl) &amp;&amp; DECL_IN_CONSTANT_POOL (decl);</span>
<span class="lineNum">     696 </span>            : }
<span class="lineNum">     697 </span>            : 
<span class="lineNum">     698 </span>            : /* Remove DECL from candidates for SRA and write REASON to the dump file if
<span class="lineNum">     699 </span>            :    there is one.  */
<a name="700"><span class="lineNum">     700 </span>            : </a>
<span class="lineNum">     701 </span>            : static void
<span class="lineNum">     702 </span><span class="lineCov">    1338982 : disqualify_candidate (tree decl, const char *reason)</span>
<span class="lineNum">     703 </span>            : {
<span class="lineNum">     704 </span><span class="lineCov">    1338982 :   if (bitmap_clear_bit (candidate_bitmap, DECL_UID (decl)))</span>
<span class="lineNum">     705 </span><span class="lineCov">    1329531 :     candidates-&gt;remove_elt_with_hash (decl, DECL_UID (decl));</span>
<span class="lineNum">     706 </span><span class="lineCov">    1338982 :   if (constant_decl_p (decl))</span>
<span class="lineNum">     707 </span><span class="lineCov">       1791 :     bitmap_set_bit (disqualified_constants, DECL_UID (decl));</span>
<span class="lineNum">     708 </span>            : 
<span class="lineNum">     709 </span><span class="lineCov">    1338982 :   if (dump_file &amp;&amp; (dump_flags &amp; TDF_DETAILS))</span>
<span class="lineNum">     710 </span>            :     {
<span class="lineNum">     711 </span><span class="lineCov">          8 :       fprintf (dump_file, &quot;! Disqualifying &quot;);</span>
<span class="lineNum">     712 </span><span class="lineCov">          8 :       print_generic_expr (dump_file, decl);</span>
<span class="lineNum">     713 </span><span class="lineCov">          8 :       fprintf (dump_file, &quot; - %s\n&quot;, reason);</span>
<span class="lineNum">     714 </span>            :     }
<span class="lineNum">     715 </span><span class="lineCov">    1338982 : }</span>
<span class="lineNum">     716 </span>            : 
<span class="lineNum">     717 </span>            : /* Return true iff the type contains a field or an element which does not allow
<span class="lineNum">     718 </span>            :    scalarization.  */
<a name="719"><span class="lineNum">     719 </span>            : </a>
<span class="lineNum">     720 </span>            : static bool
<span class="lineNum">     721 </span><span class="lineCov">    3572335 : type_internals_preclude_sra_p (tree type, const char **msg)</span>
<span class="lineNum">     722 </span>            : {
<span class="lineNum">     723 </span><span class="lineCov">    3572335 :   tree fld;</span>
<span class="lineNum">     724 </span><span class="lineCov">    3572335 :   tree et;</span>
<span class="lineNum">     725 </span>            : 
<span class="lineNum">     726 </span><span class="lineCov">    3572335 :   switch (TREE_CODE (type))</span>
<span class="lineNum">     727 </span>            :     {
<span class="lineNum">     728 </span><span class="lineCov">    3394551 :     case RECORD_TYPE:</span>
<span class="lineNum">     729 </span><span class="lineCov">    3394551 :     case UNION_TYPE:</span>
<span class="lineNum">     730 </span><span class="lineCov">    3394551 :     case QUAL_UNION_TYPE:</span>
<span class="lineNum">     731 </span><span class="lineCov">   49761403 :       for (fld = TYPE_FIELDS (type); fld; fld = DECL_CHAIN (fld))</span>
<span class="lineNum">     732 </span><span class="lineCov">   46316304 :         if (TREE_CODE (fld) == FIELD_DECL)</span>
<span class="lineNum">     733 </span>            :           {
<span class="lineNum">     734 </span><span class="lineCov">    6928058 :             tree ft = TREE_TYPE (fld);</span>
<span class="lineNum">     735 </span>            : 
<span class="lineNum">     736 </span><span class="lineCov">    6928058 :             if (TREE_THIS_VOLATILE (fld))</span>
<span class="lineNum">     737 </span>            :               {
<span class="lineNum">     738 </span><span class="lineCov">        357 :                 *msg = &quot;volatile structure field&quot;;</span>
<span class="lineNum">     739 </span><span class="lineCov">        357 :                 return true;</span>
<span class="lineNum">     740 </span>            :               }
<span class="lineNum">     741 </span><span class="lineCov">   13855402 :             if (!DECL_FIELD_OFFSET (fld))</span>
<span class="lineNum">     742 </span>            :               {
<span class="lineNum">     743 </span><span class="lineNoCov">          0 :                 *msg = &quot;no structure field offset&quot;;</span>
<span class="lineNum">     744 </span><span class="lineNoCov">          0 :                 return true;</span>
<span class="lineNum">     745 </span>            :               }
<span class="lineNum">     746 </span><span class="lineCov">    6927701 :             if (!DECL_SIZE (fld))</span>
<span class="lineNum">     747 </span>            :               {
<span class="lineNum">     748 </span><span class="lineCov">        221 :                 *msg = &quot;zero structure field size&quot;;</span>
<span class="lineNum">     749 </span><span class="lineCov">        221 :                 return true;</span>
<span class="lineNum">     750 </span>            :               }
<span class="lineNum">     751 </span><span class="lineCov">   13854960 :             if (!tree_fits_uhwi_p (DECL_FIELD_OFFSET (fld)))</span>
<span class="lineNum">     752 </span>            :               {
<span class="lineNum">     753 </span><span class="lineNoCov">          0 :                 *msg = &quot;structure field offset not fixed&quot;;</span>
<span class="lineNum">     754 </span><span class="lineNoCov">          0 :                 return true;</span>
<span class="lineNum">     755 </span>            :               }
<span class="lineNum">     756 </span><span class="lineCov">   13854960 :             if (!tree_fits_uhwi_p (DECL_SIZE (fld)))</span>
<span class="lineNum">     757 </span>            :               {
<span class="lineNum">     758 </span><span class="lineNoCov">          0 :                 *msg = &quot;structure field size not fixed&quot;;</span>
<span class="lineNum">     759 </span><span class="lineNoCov">          0 :                 return true;</span>
<span class="lineNum">     760 </span>            :               }
<span class="lineNum">     761 </span><span class="lineCov">    6927480 :             if (!tree_fits_shwi_p (bit_position (fld)))</span>
<span class="lineNum">     762 </span>            :               {
<span class="lineNum">     763 </span><span class="lineNoCov">          0 :                 *msg = &quot;structure field size too big&quot;;</span>
<span class="lineNum">     764 </span><span class="lineNoCov">          0 :                 return true;</span>
<span class="lineNum">     765 </span>            :               }
<span class="lineNum">     766 </span><span class="lineCov">    6927480 :             if (AGGREGATE_TYPE_P (ft)</span>
<span class="lineNum">     767 </span><span class="lineCov">    6927480 :                     &amp;&amp; int_bit_position (fld) % BITS_PER_UNIT != 0)</span>
<span class="lineNum">     768 </span>            :               {
<span class="lineNum">     769 </span><span class="lineNoCov">          0 :                 *msg = &quot;structure field is bit field&quot;;</span>
<span class="lineNum">     770 </span><span class="lineNoCov">          0 :                 return true;</span>
<span class="lineNum">     771 </span>            :               }
<span class="lineNum">     772 </span>            : 
<span class="lineNum">     773 </span><span class="lineCov">    6927480 :             if (AGGREGATE_TYPE_P (ft) &amp;&amp; type_internals_preclude_sra_p (ft, msg))</span>
<span class="lineNum">     774 </span>            :               return true;
<span class="lineNum">     775 </span><span class="lineCov">    3393550 :           }</span>
<span class="lineNum">     776 </span>            : 
<span class="lineNum">     777 </span>            :       return false;
<span class="lineNum">     778 </span>            : 
<span class="lineNum">     779 </span><span class="lineCov">     177784 :     case ARRAY_TYPE:</span>
<span class="lineNum">     780 </span><span class="lineCov">     177784 :       et = TREE_TYPE (type);</span>
<span class="lineNum">     781 </span>            : 
<span class="lineNum">     782 </span><span class="lineCov">     177784 :       if (TYPE_VOLATILE (et))</span>
<span class="lineNum">     783 </span>            :         {
<span class="lineNum">     784 </span><span class="lineNoCov">          0 :           *msg = &quot;element type is volatile&quot;;</span>
<span class="lineNum">     785 </span><span class="lineNoCov">          0 :           return true;</span>
<span class="lineNum">     786 </span>            :         }
<span class="lineNum">     787 </span>            : 
<span class="lineNum">     788 </span><span class="lineCov">     177784 :       if (AGGREGATE_TYPE_P (et) &amp;&amp; type_internals_preclude_sra_p (et, msg))</span>
<span class="lineNum">     789 </span><span class="lineCov">          6 :         return true;</span>
<span class="lineNum">     790 </span>            : 
<span class="lineNum">     791 </span>            :       return false;
<span class="lineNum">     792 </span>            : 
<span class="lineNum">     793 </span>            :     default:
<span class="lineNum">     794 </span>            :       return false;
<span class="lineNum">     795 </span>            :     }
<span class="lineNum">     796 </span>            : }
<span class="lineNum">     797 </span>            : 
<span class="lineNum">     798 </span>            : /* If T is an SSA_NAME, return NULL if it is not a default def or return its
<span class="lineNum">     799 </span>            :    base variable if it is.  Return T if it is not an SSA_NAME.  */
<a name="800"><span class="lineNum">     800 </span>            : </a>
<span class="lineNum">     801 </span>            : static tree
<span class="lineNum">     802 </span><span class="lineNoCov">          0 : get_ssa_base_param (tree t)</span>
<span class="lineNum">     803 </span>            : {
<span class="lineNum">     804 </span><span class="lineNoCov">          0 :   if (TREE_CODE (t) == SSA_NAME)</span>
<span class="lineNum">     805 </span>            :     {
<span class="lineNum">     806 </span><span class="lineCov">     664568 :       if (SSA_NAME_IS_DEFAULT_DEF (t))</span>
<span class="lineNum">     807 </span><span class="lineCov">     464804 :         return SSA_NAME_VAR (t);</span>
<span class="lineNum">     808 </span>            :       else
<span class="lineNum">     809 </span>            :         return NULL_TREE;
<span class="lineNum">     810 </span>            :     }
<span class="lineNum">     811 </span>            :   return t;
<span class="lineNum">     812 </span>            : }
<span class="lineNum">     813 </span>            : 
<span class="lineNum">     814 </span>            : /* Mark a dereference of BASE of distance DIST in a basic block tht STMT
<span class="lineNum">     815 </span>            :    belongs to, unless the BB has already been marked as a potentially
<span class="lineNum">     816 </span>            :    final.  */
<a name="817"><span class="lineNum">     817 </span>            : </a>
<span class="lineNum">     818 </span>            : static void
<span class="lineNum">     819 </span><span class="lineCov">     155302 : mark_parm_dereference (tree base, HOST_WIDE_INT dist, gimple *stmt)</span>
<span class="lineNum">     820 </span>            : {
<span class="lineNum">     821 </span><span class="lineCov">     155302 :   basic_block bb = gimple_bb (stmt);</span>
<span class="lineNum">     822 </span><span class="lineCov">     155302 :   int idx, parm_index = 0;</span>
<span class="lineNum">     823 </span><span class="lineCov">     155302 :   tree parm;</span>
<span class="lineNum">     824 </span>            : 
<span class="lineNum">     825 </span><span class="lineCov">     155302 :   if (bitmap_bit_p (final_bbs, bb-&gt;index))</span>
<span class="lineNum">     826 </span>            :     return;
<span class="lineNum">     827 </span>            : 
<span class="lineNum">     828 </span><span class="lineCov">     147343 :   for (parm = DECL_ARGUMENTS (current_function_decl);</span>
<span class="lineNum">     829 </span><span class="lineCov">     213739 :        parm &amp;&amp; parm != base;</span>
<span class="lineNum">     830 </span><span class="lineCov">      66396 :        parm = DECL_CHAIN (parm))</span>
<span class="lineNum">     831 </span><span class="lineCov">      66396 :     parm_index++;</span>
<span class="lineNum">     832 </span>            : 
<span class="lineNum">     833 </span><span class="lineCov">     147343 :   gcc_assert (parm_index &lt; func_param_count);</span>
<span class="lineNum">     834 </span>            : 
<span class="lineNum">     835 </span><span class="lineCov">     147343 :   idx = bb-&gt;index * func_param_count + parm_index;</span>
<span class="lineNum">     836 </span><span class="lineCov">     147343 :   if (bb_dereferences[idx] &lt; dist)</span>
<span class="lineNum">     837 </span><span class="lineCov">     127297 :     bb_dereferences[idx] = dist;</span>
<span class="lineNum">     838 </span>            : }
<span class="lineNum">     839 </span>            : 
<span class="lineNum">     840 </span>            : /* Allocate an access structure for BASE, OFFSET and SIZE, clear it, fill in
<span class="lineNum">     841 </span>            :    the three fields.  Also add it to the vector of accesses corresponding to
<span class="lineNum">     842 </span>            :    the base.  Finally, return the new access.  */
<a name="843"><span class="lineNum">     843 </span>            : </a>
<span class="lineNum">     844 </span>            : static struct access *
<span class="lineNum">     845 </span><span class="lineCov">    9906710 : create_access_1 (tree base, HOST_WIDE_INT offset, HOST_WIDE_INT size)</span>
<span class="lineNum">     846 </span>            : {
<span class="lineNum">     847 </span><span class="lineCov">    9906710 :   struct access *access = access_pool.allocate ();</span>
<span class="lineNum">     848 </span>            : 
<span class="lineNum">     849 </span><span class="lineCov">    9906710 :   memset (access, 0, sizeof (struct access));</span>
<span class="lineNum">     850 </span><span class="lineCov">    9906710 :   access-&gt;base = base;</span>
<span class="lineNum">     851 </span><span class="lineCov">    9906710 :   access-&gt;offset = offset;</span>
<span class="lineNum">     852 </span><span class="lineCov">    9906710 :   access-&gt;size = size;</span>
<span class="lineNum">     853 </span>            : 
<span class="lineNum">     854 </span><span class="lineCov">   19813420 :   base_access_vec-&gt;get_or_insert (base).safe_push (access);</span>
<span class="lineNum">     855 </span>            : 
<span class="lineNum">     856 </span><span class="lineCov">    9906710 :   return access;</span>
<span class="lineNum">     857 </span>            : }
<span class="lineNum">     858 </span>            : 
<span class="lineNum">     859 </span>            : static bool maybe_add_sra_candidate (tree);
<span class="lineNum">     860 </span>            : 
<span class="lineNum">     861 </span>            : /* Create and insert access for EXPR. Return created access, or NULL if it is
<span class="lineNum">     862 </span>            :    not possible.  Also scan for uses of constant pool as we go along and add
<span class="lineNum">     863 </span>            :    to candidates.  */
<a name="864"><span class="lineNum">     864 </span>            : </a>
<span class="lineNum">     865 </span>            : static struct access *
<span class="lineNum">     866 </span><span class="lineCov">   13366009 : create_access (tree expr, gimple *stmt, bool write)</span>
<span class="lineNum">     867 </span>            : {
<span class="lineNum">     868 </span><span class="lineCov">   13366009 :   struct access *access;</span>
<span class="lineNum">     869 </span><span class="lineCov">   40098027 :   poly_int64 poffset, psize, pmax_size;</span>
<span class="lineNum">     870 </span><span class="lineCov">   13366009 :   HOST_WIDE_INT offset, size, max_size;</span>
<span class="lineNum">     871 </span><span class="lineCov">   13366009 :   tree base = expr;</span>
<span class="lineNum">     872 </span><span class="lineCov">   13366009 :   bool reverse, ptr, unscalarizable_region = false;</span>
<span class="lineNum">     873 </span>            : 
<span class="lineNum">     874 </span><span class="lineCov">   13366009 :   base = get_ref_base_and_extent (expr, &amp;poffset, &amp;psize, &amp;pmax_size,</span>
<span class="lineNum">     875 </span>            :                                   &amp;reverse);
<span class="lineNum">     876 </span><span class="lineCov">   13366009 :   if (!poffset.is_constant (&amp;offset)</span>
<span class="lineNum">     877 </span><span class="lineCov">   13366009 :       || !psize.is_constant (&amp;size)</span>
<span class="lineNum">     878 </span><span class="lineCov">   13366009 :       || !pmax_size.is_constant (&amp;max_size))</span>
<span class="lineNum">     879 </span>            :     {
<span class="lineNum">     880 </span>            :       disqualify_candidate (base, &quot;Encountered a polynomial-sized access.&quot;);
<span class="lineNum">     881 </span>            :       return NULL;
<span class="lineNum">     882 </span>            :     }
<span class="lineNum">     883 </span>            : 
<span class="lineNum">     884 </span><span class="lineCov">   13366009 :   if (sra_mode == SRA_MODE_EARLY_IPA</span>
<span class="lineNum">     885 </span><span class="lineCov">     697468 :       &amp;&amp; TREE_CODE (base) == MEM_REF)</span>
<span class="lineNum">     886 </span>            :     {
<span class="lineNum">     887 </span><span class="lineCov">     332216 :       base = get_ssa_base_param (TREE_OPERAND (base, 0));</span>
<span class="lineNum">     888 </span><span class="lineCov">     232380 :       if (!base)</span>
<span class="lineNum">     889 </span>            :         return NULL;
<span class="lineNum">     890 </span>            :       ptr = true;
<span class="lineNum">     891 </span>            :     }
<span class="lineNum">     892 </span>            :   else
<span class="lineNum">     893 </span>            :     ptr = false;
<span class="lineNum">     894 </span>            : 
<span class="lineNum">     895 </span>            :   /* For constant-pool entries, check we can substitute the constant value.  */
<span class="lineNum">     896 </span><span class="lineCov">   13266173 :   if (constant_decl_p (base)</span>
<span class="lineNum">     897 </span><span class="lineCov">       1844 :       &amp;&amp; (sra_mode == SRA_MODE_EARLY_INTRA || sra_mode == SRA_MODE_INTRA))</span>
<span class="lineNum">     898 </span>            :     {
<span class="lineNum">     899 </span><span class="lineCov">       1844 :       gcc_assert (!bitmap_bit_p (disqualified_constants, DECL_UID (base)));</span>
<span class="lineNum">     900 </span><span class="lineCov">       1844 :       if (expr != base</span>
<span class="lineNum">     901 </span><span class="lineCov">          1 :           &amp;&amp; !is_gimple_reg_type (TREE_TYPE (expr))</span>
<span class="lineNum">     902 </span><span class="lineCov">       1844 :           &amp;&amp; dump_file &amp;&amp; (dump_flags &amp; TDF_DETAILS))</span>
<span class="lineNum">     903 </span>            :         {
<span class="lineNum">     904 </span>            :           /* This occurs in Ada with accesses to ARRAY_RANGE_REFs,
<span class="lineNum">     905 </span>            :              and elements of multidimensional arrays (which are
<span class="lineNum">     906 </span>            :              multi-element arrays in their own right).  */
<span class="lineNum">     907 </span><span class="lineNoCov">          0 :           fprintf (dump_file, &quot;Allowing non-reg-type load of part&quot;</span>
<span class="lineNum">     908 </span>            :                               &quot; of constant-pool entry: &quot;);
<span class="lineNum">     909 </span><span class="lineNoCov">          0 :           print_generic_expr (dump_file, expr);</span>
<span class="lineNum">     910 </span>            :         }
<span class="lineNum">     911 </span><span class="lineCov">       1844 :       maybe_add_sra_candidate (base);</span>
<span class="lineNum">     912 </span>            :     }
<span class="lineNum">     913 </span>            : 
<span class="lineNum">     914 </span><span class="lineCov">   13266173 :   if (!DECL_P (base) || !bitmap_bit_p (candidate_bitmap, DECL_UID (base)))</span>
<span class="lineNum">     915 </span><span class="lineCov">    5542036 :     return NULL;</span>
<span class="lineNum">     916 </span>            : 
<span class="lineNum">     917 </span><span class="lineCov">    7724137 :   if (sra_mode == SRA_MODE_EARLY_IPA)</span>
<span class="lineNum">     918 </span>            :     {
<span class="lineNum">     919 </span><span class="lineCov">     235701 :       if (size &lt; 0 || size != max_size)</span>
<span class="lineNum">     920 </span>            :         {
<span class="lineNum">     921 </span><span class="lineCov">       2734 :           disqualify_candidate (base, &quot;Encountered a variable sized access.&quot;);</span>
<span class="lineNum">     922 </span><span class="lineCov">       2734 :           return NULL;</span>
<span class="lineNum">     923 </span>            :         }
<span class="lineNum">     924 </span><span class="lineCov">     232967 :       if (TREE_CODE (expr) == COMPONENT_REF</span>
<span class="lineNum">     925 </span><span class="lineCov">     232967 :           &amp;&amp; DECL_BIT_FIELD (TREE_OPERAND (expr, 1)))</span>
<span class="lineNum">     926 </span>            :         {
<span class="lineNum">     927 </span><span class="lineCov">         99 :           disqualify_candidate (base, &quot;Encountered a bit-field access.&quot;);</span>
<span class="lineNum">     928 </span><span class="lineCov">         99 :           return NULL;</span>
<span class="lineNum">     929 </span>            :         }
<span class="lineNum">     930 </span><span class="lineCov">     232868 :       gcc_checking_assert ((offset % BITS_PER_UNIT) == 0);</span>
<span class="lineNum">     931 </span>            : 
<span class="lineNum">     932 </span><span class="lineCov">     232868 :       if (ptr)</span>
<span class="lineNum">     933 </span><span class="lineCov">     155302 :         mark_parm_dereference (base, offset + size, stmt);</span>
<span class="lineNum">     934 </span>            :     }
<span class="lineNum">     935 </span>            :   else
<span class="lineNum">     936 </span>            :     {
<span class="lineNum">     937 </span><span class="lineCov">    7488436 :       if (size != max_size)</span>
<span class="lineNum">     938 </span>            :         {
<span class="lineNum">     939 </span><span class="lineCov">     218804 :           size = max_size;</span>
<span class="lineNum">     940 </span><span class="lineCov">     218804 :           unscalarizable_region = true;</span>
<span class="lineNum">     941 </span>            :         }
<span class="lineNum">     942 </span><span class="lineCov">    7488436 :       if (size &lt; 0)</span>
<span class="lineNum">     943 </span>            :         {
<span class="lineNum">     944 </span><span class="lineCov">         16 :           disqualify_candidate (base, &quot;Encountered an unconstrained access.&quot;);</span>
<span class="lineNum">     945 </span><span class="lineCov">         16 :           return NULL;</span>
<span class="lineNum">     946 </span>            :         }
<span class="lineNum">     947 </span>            :     }
<span class="lineNum">     948 </span>            : 
<span class="lineNum">     949 </span><span class="lineCov">    7721288 :   access = create_access_1 (base, offset, size);</span>
<span class="lineNum">     950 </span><span class="lineCov">    7721288 :   access-&gt;expr = expr;</span>
<span class="lineNum">     951 </span><span class="lineCov">    7721288 :   access-&gt;type = TREE_TYPE (expr);</span>
<span class="lineNum">     952 </span><span class="lineCov">    7721288 :   access-&gt;write = write;</span>
<span class="lineNum">     953 </span><span class="lineCov">    7721288 :   access-&gt;grp_unscalarizable_region = unscalarizable_region;</span>
<span class="lineNum">     954 </span><span class="lineCov">    7721288 :   access-&gt;stmt = stmt;</span>
<span class="lineNum">     955 </span><span class="lineCov">    7721288 :   access-&gt;reverse = reverse;</span>
<span class="lineNum">     956 </span>            : 
<span class="lineNum">     957 </span><span class="lineCov">    7721288 :   if (TREE_CODE (expr) == COMPONENT_REF</span>
<span class="lineNum">     958 </span><span class="lineCov">    7721288 :       &amp;&amp; DECL_NONADDRESSABLE_P (TREE_OPERAND (expr, 1)))</span>
<span class="lineNum">     959 </span><span class="lineCov">      11280 :     access-&gt;non_addressable = 1;</span>
<span class="lineNum">     960 </span>            : 
<span class="lineNum">     961 </span>            :   return access;
<span class="lineNum">     962 </span>            : }
<span class="lineNum">     963 </span>            : 
<span class="lineNum">     964 </span>            : 
<span class="lineNum">     965 </span>            : /* Return true iff TYPE is scalarizable - i.e. a RECORD_TYPE or fixed-length
<span class="lineNum">     966 </span>            :    ARRAY_TYPE with fields that are either of gimple register types (excluding
<span class="lineNum">     967 </span>            :    bit-fields) or (recursively) scalarizable types.  CONST_DECL must be true if
<span class="lineNum">     968 </span>            :    we are considering a decl from constant pool.  If it is false, char arrays
<span class="lineNum">     969 </span>            :    will be refused.  */
<a name="970"><span class="lineNum">     970 </span>            : </a>
<span class="lineNum">     971 </span>            : static bool
<span class="lineNum">     972 </span><span class="lineCov">     944663 : scalarizable_type_p (tree type, bool const_decl)</span>
<span class="lineNum">     973 </span>            : {
<span class="lineNum">     974 </span><span class="lineCov">    1889326 :   gcc_assert (!is_gimple_reg_type (type));</span>
<span class="lineNum">     975 </span><span class="lineCov">     944663 :   if (type_contains_placeholder_p (type))</span>
<span class="lineNum">     976 </span>            :     return false;
<span class="lineNum">     977 </span>            : 
<span class="lineNum">     978 </span><span class="lineCov">     944663 :   switch (TREE_CODE (type))</span>
<span class="lineNum">     979 </span>            :   {
<span class="lineNum">     980 </span><span class="lineCov">     922697 :   case RECORD_TYPE:</span>
<span class="lineNum">     981 </span><span class="lineCov">   10228934 :     for (tree fld = TYPE_FIELDS (type); fld; fld = DECL_CHAIN (fld))</span>
<span class="lineNum">     982 </span><span class="lineCov">    9317936 :       if (TREE_CODE (fld) == FIELD_DECL)</span>
<span class="lineNum">     983 </span>            :         {
<span class="lineNum">     984 </span><span class="lineCov">    1901103 :           tree ft = TREE_TYPE (fld);</span>
<span class="lineNum">     985 </span>            : 
<span class="lineNum">     986 </span><span class="lineCov">    3802206 :           if (DECL_BIT_FIELD (fld))</span>
<span class="lineNum">     987 </span>            :             return false;
<span class="lineNum">     988 </span>            : 
<span class="lineNum">     989 </span><span class="lineCov">    1898053 :           if (!is_gimple_reg_type (ft)</span>
<span class="lineNum">     990 </span><span class="lineCov">    1898053 :               &amp;&amp; !scalarizable_type_p (ft, const_decl))</span>
<span class="lineNum">     991 </span>            :             return false;
<span class="lineNum">     992 </span>            :         }
<span class="lineNum">     993 </span>            : 
<span class="lineNum">     994 </span>            :     return true;
<span class="lineNum">     995 </span>            : 
<span class="lineNum">     996 </span><span class="lineCov">      16129 :   case ARRAY_TYPE:</span>
<span class="lineNum">     997 </span><span class="lineCov">      16129 :     {</span>
<span class="lineNum">     998 </span><span class="lineCov">      16129 :       HOST_WIDE_INT min_elem_size;</span>
<span class="lineNum">     999 </span><span class="lineCov">      16129 :       if (const_decl)</span>
<span class="lineNum">    1000 </span>            :         min_elem_size = 0;
<span class="lineNum">    1001 </span>            :       else
<span class="lineNum">    1002 </span><span class="lineCov">      14286 :         min_elem_size = BITS_PER_UNIT;</span>
<span class="lineNum">    1003 </span>            : 
<span class="lineNum">    1004 </span><span class="lineCov">      16129 :       if (TYPE_DOMAIN (type) == NULL_TREE</span>
<span class="lineNum">    1005 </span><span class="lineCov">      16129 :           || !tree_fits_shwi_p (TYPE_SIZE (type))</span>
<span class="lineNum">    1006 </span><span class="lineCov">      16129 :           || !tree_fits_shwi_p (TYPE_SIZE (TREE_TYPE (type)))</span>
<span class="lineNum">    1007 </span><span class="lineCov">      48387 :           || (tree_to_shwi (TYPE_SIZE (TREE_TYPE (type))) &lt;= min_elem_size)</span>
<span class="lineNum">    1008 </span><span class="lineCov">      27876 :           || !tree_fits_shwi_p (TYPE_MIN_VALUE (TYPE_DOMAIN (type))))</span>
<span class="lineNum">    1009 </span><span class="lineCov">       4382 :         return false;</span>
<span class="lineNum">    1010 </span><span class="lineCov">      11747 :       if (tree_to_shwi (TYPE_SIZE (type)) == 0</span>
<span class="lineNum">    1011 </span><span class="lineCov">      11747 :           &amp;&amp; TYPE_MAX_VALUE (TYPE_DOMAIN (type)) == NULL_TREE)</span>
<span class="lineNum">    1012 </span>            :         /* Zero-element array, should not prevent scalarization.  */
<span class="lineNum">    1013 </span>            :         ;
<span class="lineNum">    1014 </span><span class="lineCov">      11746 :       else if ((tree_to_shwi (TYPE_SIZE (type)) &lt;= 0)</span>
<span class="lineNum">    1015 </span><span class="lineCov">      11746 :                || !tree_fits_shwi_p (TYPE_MAX_VALUE (TYPE_DOMAIN (type))))</span>
<span class="lineNum">    1016 </span>            :         /* Variable-length array, do not allow scalarization.  */
<span class="lineNum">    1017 </span>            :         return false;
<span class="lineNum">    1018 </span>            : 
<span class="lineNum">    1019 </span><span class="lineCov">      11741 :       tree elem = TREE_TYPE (type);</span>
<span class="lineNum">    1020 </span><span class="lineCov">      11741 :       if (!is_gimple_reg_type (elem)</span>
<span class="lineNum">    1021 </span><span class="lineCov">      11741 :           &amp;&amp; !scalarizable_type_p (elem, const_decl))</span>
<span class="lineNum">    1022 </span><span class="lineCov">        320 :         return false;</span>
<span class="lineNum">    1023 </span>            :       return true;
<span class="lineNum">    1024 </span>            :     }
<span class="lineNum">    1025 </span>            :   default:
<span class="lineNum">    1026 </span>            :     return false;
<span class="lineNum">    1027 </span>            :   }
<span class="lineNum">    1028 </span>            : }
<span class="lineNum">    1029 </span>            : 
<span class="lineNum">    1030 </span>            : static void scalarize_elem (tree, HOST_WIDE_INT, HOST_WIDE_INT, bool, tree, tree);
<span class="lineNum">    1031 </span>            : 
<span class="lineNum">    1032 </span>            : /* Create total_scalarization accesses for all scalar fields of a member
<span class="lineNum">    1033 </span>            :    of type DECL_TYPE conforming to scalarizable_type_p.  BASE
<span class="lineNum">    1034 </span>            :    must be the top-most VAR_DECL representing the variable; within that,
<span class="lineNum">    1035 </span>            :    OFFSET locates the member and REF must be the memory reference expression for
<span class="lineNum">    1036 </span>            :    the member.  */
<a name="1037"><span class="lineNum">    1037 </span>            : </a>
<span class="lineNum">    1038 </span>            : static void
<span class="lineNum">    1039 </span><span class="lineCov">     886291 : completely_scalarize (tree base, tree decl_type, HOST_WIDE_INT offset, tree ref)</span>
<span class="lineNum">    1040 </span>            : {
<span class="lineNum">    1041 </span><span class="lineCov">     886291 :   switch (TREE_CODE (decl_type))</span>
<span class="lineNum">    1042 </span>            :     {
<span class="lineNum">    1043 </span><span class="lineCov">     879603 :     case RECORD_TYPE:</span>
<span class="lineNum">    1044 </span><span class="lineCov">    9973961 :       for (tree fld = TYPE_FIELDS (decl_type); fld; fld = DECL_CHAIN (fld))</span>
<span class="lineNum">    1045 </span><span class="lineCov">    9094358 :         if (TREE_CODE (fld) == FIELD_DECL)</span>
<span class="lineNum">    1046 </span>            :           {
<span class="lineNum">    1047 </span><span class="lineCov">    1762813 :             HOST_WIDE_INT pos = offset + int_bit_position (fld);</span>
<span class="lineNum">    1048 </span><span class="lineCov">    1762813 :             tree ft = TREE_TYPE (fld);</span>
<span class="lineNum">    1049 </span><span class="lineCov">    1762813 :             tree nref = build3 (COMPONENT_REF, ft, ref, fld, NULL_TREE);</span>
<span class="lineNum">    1050 </span>            : 
<span class="lineNum">    1051 </span><span class="lineCov">    1762813 :             scalarize_elem (base, pos, tree_to_uhwi (DECL_SIZE (fld)),</span>
<span class="lineNum">    1052 </span><span class="lineCov">    1762813 :                             TYPE_REVERSE_STORAGE_ORDER (decl_type),</span>
<span class="lineNum">    1053 </span><span class="lineCov">    1762813 :                             nref, ft);</span>
<span class="lineNum">    1054 </span>            :           }
<span class="lineNum">    1055 </span>            :       break;
<span class="lineNum">    1056 </span><span class="lineCov">       6688 :     case ARRAY_TYPE:</span>
<span class="lineNum">    1057 </span><span class="lineCov">       6688 :       {</span>
<span class="lineNum">    1058 </span><span class="lineCov">       6688 :         tree elemtype = TREE_TYPE (decl_type);</span>
<span class="lineNum">    1059 </span><span class="lineCov">       6688 :         tree elem_size = TYPE_SIZE (elemtype);</span>
<span class="lineNum">    1060 </span><span class="lineCov">       6688 :         gcc_assert (elem_size &amp;&amp; tree_fits_shwi_p (elem_size));</span>
<span class="lineNum">    1061 </span><span class="lineCov">       6688 :         HOST_WIDE_INT el_size = tree_to_shwi (elem_size);</span>
<span class="lineNum">    1062 </span><span class="lineCov">       6688 :         gcc_assert (el_size &gt; 0);</span>
<span class="lineNum">    1063 </span>            : 
<span class="lineNum">    1064 </span><span class="lineCov">       6688 :         tree minidx = TYPE_MIN_VALUE (TYPE_DOMAIN (decl_type));</span>
<span class="lineNum">    1065 </span><span class="lineCov">       6688 :         gcc_assert (TREE_CODE (minidx) == INTEGER_CST);</span>
<span class="lineNum">    1066 </span><span class="lineCov">      13376 :         tree maxidx = TYPE_MAX_VALUE (TYPE_DOMAIN (decl_type));</span>
<span class="lineNum">    1067 </span>            :         /* Skip (some) zero-length arrays; others have MAXIDX == MINIDX - 1.  */
<span class="lineNum">    1068 </span><span class="lineCov">       6688 :         if (maxidx)</span>
<span class="lineNum">    1069 </span>            :           {
<span class="lineNum">    1070 </span><span class="lineCov">       6687 :             gcc_assert (TREE_CODE (maxidx) == INTEGER_CST);</span>
<span class="lineNum">    1071 </span><span class="lineCov">       6687 :             tree domain = TYPE_DOMAIN (decl_type);</span>
<span class="lineNum">    1072 </span>            :             /* MINIDX and MAXIDX are inclusive, and must be interpreted in
<span class="lineNum">    1073 </span>            :                DOMAIN (e.g. signed int, whereas min/max may be size_int).  */
<span class="lineNum">    1074 </span><span class="lineCov">       6687 :             offset_int idx = wi::to_offset (minidx);</span>
<span class="lineNum">    1075 </span><span class="lineCov">       6687 :             offset_int max = wi::to_offset (maxidx);</span>
<span class="lineNum">    1076 </span><span class="lineCov">       6687 :             if (!TYPE_UNSIGNED (domain))</span>
<span class="lineNum">    1077 </span>            :               {
<span class="lineNum">    1078 </span><span class="lineCov">      13374 :                 idx = wi::sext (idx, TYPE_PRECISION (domain));</span>
<span class="lineNum">    1079 </span><span class="lineCov">       6687 :                 max = wi::sext (max, TYPE_PRECISION (domain));</span>
<span class="lineNum">    1080 </span>            :               }
<span class="lineNum">    1081 </span><span class="lineCov">      22189 :             for (int el_off = offset; idx &lt;= max; ++idx)</span>
<span class="lineNum">    1082 </span>            :               {
<span class="lineNum">    1083 </span><span class="lineCov">      31004 :                 tree nref = build4 (ARRAY_REF, elemtype,</span>
<span class="lineNum">    1084 </span>            :                                     ref,
<span class="lineNum">    1085 </span>            :                                     wide_int_to_tree (domain, idx),
<span class="lineNum">    1086 </span>            :                                     NULL_TREE, NULL_TREE);
<span class="lineNum">    1087 </span><span class="lineCov">      31004 :                 scalarize_elem (base, el_off, el_size,</span>
<span class="lineNum">    1088 </span><span class="lineCov">      15502 :                                 TYPE_REVERSE_STORAGE_ORDER (decl_type),</span>
<span class="lineNum">    1089 </span><span class="lineCov">      15502 :                                 nref, elemtype);</span>
<span class="lineNum">    1090 </span><span class="lineCov">      15502 :                 el_off += el_size;</span>
<span class="lineNum">    1091 </span>            :               }
<span class="lineNum">    1092 </span>            :           }
<span class="lineNum">    1093 </span>            :       }
<span class="lineNum">    1094 </span>            :       break;
<span class="lineNum">    1095 </span><span class="lineNoCov">          0 :     default:</span>
<span class="lineNum">    1096 </span><span class="lineNoCov">          0 :       gcc_unreachable ();</span>
<span class="lineNum">    1097 </span>            :     }
<span class="lineNum">    1098 </span><span class="lineCov">     886291 : }</span>
<span class="lineNum">    1099 </span>            : 
<span class="lineNum">    1100 </span>            : /* Create total_scalarization accesses for a member of type TYPE, which must
<span class="lineNum">    1101 </span>            :    satisfy either is_gimple_reg_type or scalarizable_type_p.  BASE must be the
<span class="lineNum">    1102 </span>            :    top-most VAR_DECL representing the variable; within that, POS and SIZE locate
<span class="lineNum">    1103 </span>            :    the member, REVERSE gives its torage order. and REF must be the reference
<span class="lineNum">    1104 </span>            :    expression for it.  */
<a name="1105"><span class="lineNum">    1105 </span>            : </a>
<span class="lineNum">    1106 </span>            : static void
<span class="lineNum">    1107 </span><span class="lineCov">    1778315 : scalarize_elem (tree base, HOST_WIDE_INT pos, HOST_WIDE_INT size, bool reverse,</span>
<span class="lineNum">    1108 </span>            :                 tree ref, tree type)
<span class="lineNum">    1109 </span>            : {
<span class="lineNum">    1110 </span><span class="lineCov">    3556630 :   if (is_gimple_reg_type (type))</span>
<span class="lineNum">    1111 </span>            :   {
<span class="lineNum">    1112 </span><span class="lineCov">    1538723 :     struct access *access = create_access_1 (base, pos, size);</span>
<span class="lineNum">    1113 </span><span class="lineCov">    1538723 :     access-&gt;expr = ref;</span>
<span class="lineNum">    1114 </span><span class="lineCov">    1538723 :     access-&gt;type = type;</span>
<span class="lineNum">    1115 </span><span class="lineCov">    1538723 :     access-&gt;grp_total_scalarization = 1;</span>
<span class="lineNum">    1116 </span><span class="lineCov">    1538723 :     access-&gt;reverse = reverse;</span>
<span class="lineNum">    1117 </span>            :     /* Accesses for intraprocedural SRA can have their stmt NULL.  */
<span class="lineNum">    1118 </span>            :   }
<span class="lineNum">    1119 </span>            :   else
<span class="lineNum">    1120 </span><span class="lineCov">     239592 :     completely_scalarize (base, type, pos, ref);</span>
<span class="lineNum">    1121 </span><span class="lineCov">    1778315 : }</span>
<span class="lineNum">    1122 </span>            : 
<span class="lineNum">    1123 </span>            : /* Create a total_scalarization access for VAR as a whole.  VAR must be of a
<span class="lineNum">    1124 </span>            :    RECORD_TYPE or ARRAY_TYPE conforming to scalarizable_type_p.  */
<a name="1125"><span class="lineNum">    1125 </span>            : </a>
<span class="lineNum">    1126 </span>            : static void
<span class="lineNum">    1127 </span><span class="lineCov">     646699 : create_total_scalarization_access (tree var)</span>
<span class="lineNum">    1128 </span>            : {
<span class="lineNum">    1129 </span><span class="lineCov">     646699 :   HOST_WIDE_INT size = tree_to_uhwi (DECL_SIZE (var));</span>
<span class="lineNum">    1130 </span><span class="lineCov">     646699 :   struct access *access;</span>
<span class="lineNum">    1131 </span>            : 
<span class="lineNum">    1132 </span><span class="lineCov">     646699 :   access = create_access_1 (var, 0, size);</span>
<span class="lineNum">    1133 </span><span class="lineCov">     646699 :   access-&gt;expr = var;</span>
<span class="lineNum">    1134 </span><span class="lineCov">     646699 :   access-&gt;type = TREE_TYPE (var);</span>
<span class="lineNum">    1135 </span><span class="lineCov">     646699 :   access-&gt;grp_total_scalarization = 1;</span>
<span class="lineNum">    1136 </span><span class="lineCov">     646699 : }</span>
<span class="lineNum">    1137 </span>            : 
<span class="lineNum">    1138 </span>            : /* Return true if REF has an VIEW_CONVERT_EXPR somewhere in it.  */
<a name="1139"><span class="lineNum">    1139 </span>            : </a>
<span class="lineNum">    1140 </span>            : static inline bool
<span class="lineNum">    1141 </span><span class="lineCov">   33650945 : contains_view_convert_expr_p (const_tree ref)</span>
<span class="lineNum">    1142 </span>            : {
<span class="lineNum">    1143 </span><span class="lineCov">   43163987 :   while (handled_component_p (ref))</span>
<span class="lineNum">    1144 </span>            :     {
<span class="lineNum">    1145 </span><span class="lineCov">    9513075 :       if (TREE_CODE (ref) == VIEW_CONVERT_EXPR)</span>
<span class="lineNum">    1146 </span>            :         return true;
<span class="lineNum">    1147 </span><span class="lineCov">    9513042 :       ref = TREE_OPERAND (ref, 0);</span>
<span class="lineNum">    1148 </span>            :     }
<span class="lineNum">    1149 </span>            : 
<span class="lineNum">    1150 </span>            :   return false;
<span class="lineNum">    1151 </span>            : }
<span class="lineNum">    1152 </span>            : 
<span class="lineNum">    1153 </span>            : /* Return true if REF contains a VIEW_CONVERT_EXPR or a MEM_REF that performs
<span class="lineNum">    1154 </span>            :    type conversion or a COMPONENT_REF with a bit-field field declaration.  */
<a name="1155"><span class="lineNum">    1155 </span>            : </a>
<span class="lineNum">    1156 </span>            : static bool
<span class="lineNum">    1157 </span><span class="lineCov">    3261092 : contains_vce_or_bfcref_p (const_tree ref)</span>
<span class="lineNum">    1158 </span>            : {
<span class="lineNum">    1159 </span><span class="lineCov">    3995699 :   while (handled_component_p (ref))</span>
<span class="lineNum">    1160 </span>            :     {
<span class="lineNum">    1161 </span><span class="lineCov">     991419 :       if (TREE_CODE (ref) == VIEW_CONVERT_EXPR</span>
<span class="lineNum">    1162 </span><span class="lineCov">     991419 :           || (TREE_CODE (ref) == COMPONENT_REF</span>
<span class="lineNum">    1163 </span><span class="lineCov">     610188 :               &amp;&amp; DECL_BIT_FIELD (TREE_OPERAND (ref, 1))))</span>
<span class="lineNum">    1164 </span>            :         return true;
<span class="lineNum">    1165 </span><span class="lineCov">     734607 :       ref = TREE_OPERAND (ref, 0);</span>
<span class="lineNum">    1166 </span>            :     }
<span class="lineNum">    1167 </span>            : 
<span class="lineNum">    1168 </span><span class="lineCov">    3004280 :   if (TREE_CODE (ref) != MEM_REF</span>
<span class="lineNum">    1169 </span><span class="lineCov">    3004280 :       || TREE_CODE (TREE_OPERAND (ref, 0)) != ADDR_EXPR)</span>
<span class="lineNum">    1170 </span>            :     return false;
<span class="lineNum">    1171 </span>            : 
<span class="lineNum">    1172 </span><span class="lineCov">      40796 :   tree mem = TREE_OPERAND (TREE_OPERAND (ref, 0), 0);</span>
<span class="lineNum">    1173 </span><span class="lineCov">      40796 :   if (TYPE_MAIN_VARIANT (TREE_TYPE (ref))</span>
<span class="lineNum">    1174 </span><span class="lineCov">      40796 :       != TYPE_MAIN_VARIANT (TREE_TYPE (mem)))</span>
<span class="lineNum">    1175 </span><span class="lineCov">      27075 :     return true;</span>
<span class="lineNum">    1176 </span>            : 
<span class="lineNum">    1177 </span>            :   return false;
<span class="lineNum">    1178 </span>            : }
<span class="lineNum">    1179 </span>            : 
<span class="lineNum">    1180 </span>            : /* Search the given tree for a declaration by skipping handled components and
<span class="lineNum">    1181 </span>            :    exclude it from the candidates.  */
<a name="1182"><span class="lineNum">    1182 </span>            : </a>
<span class="lineNum">    1183 </span>            : static void
<span class="lineNum">    1184 </span><span class="lineCov">      10248 : disqualify_base_of_expr (tree t, const char *reason)</span>
<span class="lineNum">    1185 </span>            : {
<span class="lineNum">    1186 </span><span class="lineCov">      10248 :   t = get_base_address (t);</span>
<span class="lineNum">    1187 </span><span class="lineCov">      10248 :   if (sra_mode == SRA_MODE_EARLY_IPA</span>
<span class="lineNum">    1188 </span><span class="lineCov">        372 :       &amp;&amp; TREE_CODE (t) == MEM_REF)</span>
<span class="lineNum">    1189 </span><span class="lineCov">        137 :     t = get_ssa_base_param (TREE_OPERAND (t, 0));</span>
<span class="lineNum">    1190 </span>            : 
<span class="lineNum">    1191 </span><span class="lineCov">      10202 :   if (t &amp;&amp; DECL_P (t))</span>
<span class="lineNum">    1192 </span><span class="lineCov">       8814 :     disqualify_candidate (t, reason);</span>
<span class="lineNum">    1193 </span><span class="lineCov">      10248 : }</span>
<span class="lineNum">    1194 </span>            : 
<span class="lineNum">    1195 </span>            : /* Scan expression EXPR and create access structures for all accesses to
<span class="lineNum">    1196 </span>            :    candidates for scalarization.  Return the created access or NULL if none is
<span class="lineNum">    1197 </span>            :    created.  */
<a name="1198"><span class="lineNum">    1198 </span>            : </a>
<span class="lineNum">    1199 </span>            : static struct access *
<span class="lineNum">    1200 </span><span class="lineCov">   33650945 : build_access_from_expr_1 (tree expr, gimple *stmt, bool write)</span>
<span class="lineNum">    1201 </span>            : {
<span class="lineNum">    1202 </span><span class="lineCov">   33650945 :   struct access *ret = NULL;</span>
<span class="lineNum">    1203 </span><span class="lineCov">   33650945 :   bool partial_ref;</span>
<span class="lineNum">    1204 </span>            : 
<span class="lineNum">    1205 </span><span class="lineCov">   33650945 :   if (TREE_CODE (expr) == BIT_FIELD_REF</span>
<span class="lineNum">    1206 </span><span class="lineCov">   33637572 :       || TREE_CODE (expr) == IMAGPART_EXPR</span>
<span class="lineNum">    1207 </span><span class="lineCov">   33633111 :       || TREE_CODE (expr) == REALPART_EXPR)</span>
<span class="lineNum">    1208 </span>            :     {
<span class="lineNum">    1209 </span><span class="lineCov">      23053 :       expr = TREE_OPERAND (expr, 0);</span>
<span class="lineNum">    1210 </span><span class="lineCov">      23053 :       partial_ref = true;</span>
<span class="lineNum">    1211 </span>            :     }
<span class="lineNum">    1212 </span>            :   else
<span class="lineNum">    1213 </span>            :     partial_ref = false;
<span class="lineNum">    1214 </span>            : 
<span class="lineNum">    1215 </span><span class="lineCov">   33650945 :   if (storage_order_barrier_p (expr))</span>
<span class="lineNum">    1216 </span>            :     {
<span class="lineNum">    1217 </span><span class="lineNoCov">          0 :       disqualify_base_of_expr (expr, &quot;storage order barrier.&quot;);</span>
<span class="lineNum">    1218 </span><span class="lineNoCov">          0 :       return NULL;</span>
<span class="lineNum">    1219 </span>            :     }
<span class="lineNum">    1220 </span>            : 
<span class="lineNum">    1221 </span>            :   /* We need to dive through V_C_Es in order to get the size of its parameter
<span class="lineNum">    1222 </span>            :      and not the result type.  Ada produces such statements.  We are also
<span class="lineNum">    1223 </span>            :      capable of handling the topmost V_C_E but not any of those buried in other
<span class="lineNum">    1224 </span>            :      handled components.  */
<span class="lineNum">    1225 </span><span class="lineCov">   33650945 :   if (TREE_CODE (expr) == VIEW_CONVERT_EXPR)</span>
<span class="lineNum">    1226 </span><span class="lineCov">     252655 :     expr = TREE_OPERAND (expr, 0);</span>
<span class="lineNum">    1227 </span>            : 
<span class="lineNum">    1228 </span><span class="lineCov">   33650945 :   if (contains_view_convert_expr_p (expr))</span>
<span class="lineNum">    1229 </span>            :     {
<span class="lineNum">    1230 </span><span class="lineCov">         33 :       disqualify_base_of_expr (expr, &quot;V_C_E under a different handled &quot;</span>
<span class="lineNum">    1231 </span>            :                                &quot;component.&quot;);
<span class="lineNum">    1232 </span><span class="lineCov">         33 :       return NULL;</span>
<span class="lineNum">    1233 </span>            :     }
<span class="lineNum">    1234 </span><span class="lineCov">   33650912 :   if (TREE_THIS_VOLATILE (expr))</span>
<span class="lineNum">    1235 </span>            :     {
<span class="lineNum">    1236 </span><span class="lineCov">      10191 :       disqualify_base_of_expr (expr, &quot;part of a volatile reference.&quot;);</span>
<span class="lineNum">    1237 </span><span class="lineCov">      10191 :       return NULL;</span>
<span class="lineNum">    1238 </span>            :     }
<span class="lineNum">    1239 </span>            : 
<span class="lineNum">    1240 </span><span class="lineCov">   33640721 :   switch (TREE_CODE (expr))</span>
<span class="lineNum">    1241 </span>            :     {
<span class="lineNum">    1242 </span><span class="lineCov">    3370994 :     case MEM_REF:</span>
<span class="lineNum">    1243 </span><span class="lineCov">    3370994 :       if (TREE_CODE (TREE_OPERAND (expr, 0)) != ADDR_EXPR</span>
<span class="lineNum">    1244 </span><span class="lineCov">    3370994 :           &amp;&amp; sra_mode != SRA_MODE_EARLY_IPA)</span>
<span class="lineNum">    1245 </span>            :         return NULL;
<span class="lineNum">    1246 </span>            :       /* fall through */
<span class="lineNum">    1247 </span><span class="lineCov">   13366009 :     case VAR_DECL:</span>
<span class="lineNum">    1248 </span><span class="lineCov">   13366009 :     case PARM_DECL:</span>
<span class="lineNum">    1249 </span><span class="lineCov">   13366009 :     case RESULT_DECL:</span>
<span class="lineNum">    1250 </span><span class="lineCov">   13366009 :     case COMPONENT_REF:</span>
<span class="lineNum">    1251 </span><span class="lineCov">   13366009 :     case ARRAY_REF:</span>
<span class="lineNum">    1252 </span><span class="lineCov">   13366009 :     case ARRAY_RANGE_REF:</span>
<span class="lineNum">    1253 </span><span class="lineCov">   13366009 :       ret = create_access (expr, stmt, write);</span>
<span class="lineNum">    1254 </span><span class="lineCov">   13366009 :       break;</span>
<span class="lineNum">    1255 </span>            : 
<span class="lineNum">    1256 </span>            :     default:
<span class="lineNum">    1257 </span>            :       break;
<span class="lineNum">    1258 </span>            :     }
<span class="lineNum">    1259 </span>            : 
<span class="lineNum">    1260 </span><span class="lineCov">   32421079 :   if (write &amp;&amp; partial_ref &amp;&amp; ret)</span>
<span class="lineNum">    1261 </span><span class="lineCov">       1360 :     ret-&gt;grp_partial_lhs = 1;</span>
<span class="lineNum">    1262 </span>            : 
<span class="lineNum">    1263 </span>            :   return ret;
<span class="lineNum">    1264 </span>            : }
<span class="lineNum">    1265 </span>            : 
<span class="lineNum">    1266 </span>            : /* Scan expression EXPR and create access structures for all accesses to
<span class="lineNum">    1267 </span>            :    candidates for scalarization.  Return true if any access has been inserted.
<span class="lineNum">    1268 </span>            :    STMT must be the statement from which the expression is taken, WRITE must be
<span class="lineNum">    1269 </span>            :    true if the expression is a store and false otherwise. */
<a name="1270"><span class="lineNum">    1270 </span>            : </a>
<span class="lineNum">    1271 </span>            : static bool
<span class="lineNum">    1272 </span><span class="lineCov">    8590511 : build_access_from_expr (tree expr, gimple *stmt, bool write)</span>
<span class="lineNum">    1273 </span>            : {
<span class="lineNum">    1274 </span><span class="lineCov">    8590511 :   struct access *access;</span>
<span class="lineNum">    1275 </span>            : 
<span class="lineNum">    1276 </span><span class="lineCov">    8590511 :   access = build_access_from_expr_1 (expr, stmt, write);</span>
<span class="lineNum">    1277 </span><span class="lineCov">    8590511 :   if (access)</span>
<span class="lineNum">    1278 </span>            :     {
<span class="lineNum">    1279 </span>            :       /* This means the aggregate is accesses as a whole in a way other than an
<span class="lineNum">    1280 </span>            :          assign statement and thus cannot be removed even if we had a scalar
<span class="lineNum">    1281 </span>            :          replacement for everything.  */
<span class="lineNum">    1282 </span><span class="lineCov">    1298428 :       if (cannot_scalarize_away_bitmap)</span>
<span class="lineNum">    1283 </span><span class="lineCov">    1298428 :         bitmap_set_bit (cannot_scalarize_away_bitmap, DECL_UID (access-&gt;base));</span>
<span class="lineNum">    1284 </span><span class="lineCov">    1298428 :       return true;</span>
<span class="lineNum">    1285 </span>            :     }
<span class="lineNum">    1286 </span>            :   return false;
<span class="lineNum">    1287 </span>            : }
<span class="lineNum">    1288 </span>            : 
<span class="lineNum">    1289 </span>            : /* Return the single non-EH successor edge of BB or NULL if there is none or
<span class="lineNum">    1290 </span>            :    more than one.  */
<a name="1291"><span class="lineNum">    1291 </span>            : </a>
<span class="lineNum">    1292 </span>            : static edge
<span class="lineNum">    1293 </span><span class="lineCov">    1041550 : single_non_eh_succ (basic_block bb)</span>
<span class="lineNum">    1294 </span>            : {
<span class="lineNum">    1295 </span><span class="lineCov">    1041550 :   edge e, res = NULL;</span>
<span class="lineNum">    1296 </span><span class="lineCov">    1041550 :   edge_iterator ei;</span>
<span class="lineNum">    1297 </span>            : 
<span class="lineNum">    1298 </span><span class="lineCov">    4165432 :   FOR_EACH_EDGE (e, ei, bb-&gt;succs)</span>
<span class="lineNum">    1299 </span><span class="lineCov">    2082349 :     if (!(e-&gt;flags &amp; EDGE_EH))</span>
<span class="lineNum">    1300 </span>            :       {
<span class="lineNum">    1301 </span><span class="lineCov">    1041560 :         if (res)</span>
<span class="lineNum">    1302 </span>            :           return NULL;
<span class="lineNum">    1303 </span>            :         res = e;
<span class="lineNum">    1304 </span>            :       }
<span class="lineNum">    1305 </span>            : 
<span class="lineNum">    1306 </span>            :   return res;
<span class="lineNum">    1307 </span>            : }
<span class="lineNum">    1308 </span>            : 
<span class="lineNum">    1309 </span>            : /* Disqualify LHS and RHS for scalarization if STMT has to terminate its BB and
<span class="lineNum">    1310 </span>            :    there is no alternative spot where to put statements SRA might need to
<span class="lineNum">    1311 </span>            :    generate after it.  The spot we are looking for is an edge leading to a
<span class="lineNum">    1312 </span>            :    single non-EH successor, if it exists and is indeed single.  RHS may be
<span class="lineNum">    1313 </span>            :    NULL, in that case ignore it.  */
<a name="1314"><span class="lineNum">    1314 </span>            : </a>
<span class="lineNum">    1315 </span>            : static bool
<span class="lineNum">    1316 </span><span class="lineCov">   14067701 : disqualify_if_bad_bb_terminating_stmt (gimple *stmt, tree lhs, tree rhs)</span>
<span class="lineNum">    1317 </span>            : {
<span class="lineNum">    1318 </span><span class="lineCov">   14067701 :   if ((sra_mode == SRA_MODE_EARLY_INTRA || sra_mode == SRA_MODE_INTRA)</span>
<span class="lineNum">    1319 </span><span class="lineCov">   14067701 :       &amp;&amp; stmt_ends_bb_p (stmt))</span>
<span class="lineNum">    1320 </span>            :     {
<span class="lineNum">    1321 </span><span class="lineCov">    1952724 :       if (single_non_eh_succ (gimple_bb (stmt)))</span>
<span class="lineNum">    1322 </span>            :         return false;
<span class="lineNum">    1323 </span>            : 
<span class="lineNum">    1324 </span><span class="lineCov">         24 :       disqualify_base_of_expr (lhs, &quot;LHS of a throwing stmt.&quot;);</span>
<span class="lineNum">    1325 </span><span class="lineCov">         24 :       if (rhs)</span>
<span class="lineNum">    1326 </span><span class="lineNoCov">          0 :         disqualify_base_of_expr (rhs, &quot;RHS of a throwing stmt.&quot;);</span>
<span class="lineNum">    1327 </span><span class="lineCov">         24 :       return true;</span>
<span class="lineNum">    1328 </span>            :     }
<span class="lineNum">    1329 </span>            :   return false;
<span class="lineNum">    1330 </span>            : }
<span class="lineNum">    1331 </span>            : 
<span class="lineNum">    1332 </span>            : /* Return true if the nature of BASE is such that it contains data even if
<span class="lineNum">    1333 </span>            :    there is no write to it in the function.  */
<a name="1334"><span class="lineNum">    1334 </span>            : </a>
<span class="lineNum">    1335 </span>            : static bool
<span class="lineNum">    1336 </span><span class="lineNoCov">          0 : comes_initialized_p (tree base)</span>
<span class="lineNum">    1337 </span>            : {
<span class="lineNum">    1338 </span><span class="lineCov">    1872773 :   return TREE_CODE (base) == PARM_DECL || constant_decl_p (base);</span>
<span class="lineNum">    1339 </span>            : }
<span class="lineNum">    1340 </span>            : 
<span class="lineNum">    1341 </span>            : /* Scan expressions occurring in STMT, create access structures for all accesses
<span class="lineNum">    1342 </span>            :    to candidates for scalarization and remove those candidates which occur in
<span class="lineNum">    1343 </span>            :    statements or expressions that prevent them from being split apart.  Return
<span class="lineNum">    1344 </span>            :    true if any access has been inserted.  */
<a name="1345"><span class="lineNum">    1345 </span>            : </a>
<span class="lineNum">    1346 </span>            : static bool
<span class="lineNum">    1347 </span><span class="lineCov">   18689084 : build_accesses_from_assign (gimple *stmt)</span>
<span class="lineNum">    1348 </span>            : {
<span class="lineNum">    1349 </span><span class="lineCov">   18689084 :   tree lhs, rhs;</span>
<span class="lineNum">    1350 </span><span class="lineCov">   18689084 :   struct access *lacc, *racc;</span>
<span class="lineNum">    1351 </span>            : 
<span class="lineNum">    1352 </span><span class="lineCov">   18689084 :   if (!gimple_assign_single_p (stmt)</span>
<span class="lineNum">    1353 </span>            :       /* Scope clobbers don't influence scalarization.  */
<span class="lineNum">    1354 </span><span class="lineCov">   14271679 :       || gimple_clobber_p (stmt))</span>
<span class="lineNum">    1355 </span>            :     return false;
<span class="lineNum">    1356 </span>            : 
<span class="lineNum">    1357 </span><span class="lineCov">   12530217 :   lhs = gimple_assign_lhs (stmt);</span>
<span class="lineNum">    1358 </span><span class="lineCov">   12530217 :   rhs = gimple_assign_rhs1 (stmt);</span>
<span class="lineNum">    1359 </span>            : 
<span class="lineNum">    1360 </span><span class="lineCov">   12530217 :   if (disqualify_if_bad_bb_terminating_stmt (stmt, lhs, rhs))</span>
<span class="lineNum">    1361 </span>            :     return false;
<span class="lineNum">    1362 </span>            : 
<span class="lineNum">    1363 </span><span class="lineCov">   12530217 :   racc = build_access_from_expr_1 (rhs, stmt, false);</span>
<span class="lineNum">    1364 </span><span class="lineCov">   12530217 :   lacc = build_access_from_expr_1 (lhs, stmt, true);</span>
<span class="lineNum">    1365 </span>            : 
<span class="lineNum">    1366 </span><span class="lineCov">   12530217 :   if (lacc)</span>
<span class="lineNum">    1367 </span>            :     {
<span class="lineNum">    1368 </span><span class="lineCov">    3454761 :       lacc-&gt;grp_assignment_write = 1;</span>
<span class="lineNum">    1369 </span><span class="lineCov">    3454761 :       if (storage_order_barrier_p (rhs))</span>
<span class="lineNum">    1370 </span><span class="lineNoCov">          0 :         lacc-&gt;grp_unscalarizable_region = 1;</span>
<span class="lineNum">    1371 </span>            :     }
<span class="lineNum">    1372 </span>            : 
<span class="lineNum">    1373 </span><span class="lineCov">   12530217 :   if (racc)</span>
<span class="lineNum">    1374 </span>            :     {
<span class="lineNum">    1375 </span><span class="lineCov">    2968099 :       racc-&gt;grp_assignment_read = 1;</span>
<span class="lineNum">    1376 </span><span class="lineCov">    5936198 :       if (should_scalarize_away_bitmap &amp;&amp; !gimple_has_volatile_ops (stmt)</span>
<span class="lineNum">    1377 </span><span class="lineCov">    8904037 :           &amp;&amp; !is_gimple_reg_type (racc-&gt;type))</span>
<span class="lineNum">    1378 </span>            :         {
<span class="lineNum">    1379 </span><span class="lineCov">    1135373 :           if (contains_vce_or_bfcref_p (rhs))</span>
<span class="lineNum">    1380 </span><span class="lineCov">     297036 :             bitmap_set_bit (cannot_scalarize_away_bitmap,</span>
<span class="lineNum">    1381 </span><span class="lineCov">     148518 :                             DECL_UID (racc-&gt;base));</span>
<span class="lineNum">    1382 </span>            :           else
<span class="lineNum">    1383 </span><span class="lineCov">    1973710 :             bitmap_set_bit (should_scalarize_away_bitmap,</span>
<span class="lineNum">    1384 </span><span class="lineCov">     986855 :                             DECL_UID (racc-&gt;base));</span>
<span class="lineNum">    1385 </span>            :         }
<span class="lineNum">    1386 </span><span class="lineCov">    2968099 :       if (storage_order_barrier_p (lhs))</span>
<span class="lineNum">    1387 </span><span class="lineNoCov">          0 :         racc-&gt;grp_unscalarizable_region = 1;</span>
<span class="lineNum">    1388 </span>            :     }
<span class="lineNum">    1389 </span>            : 
<span class="lineNum">    1390 </span><span class="lineCov">   12530217 :   if (lacc &amp;&amp; racc</span>
<span class="lineNum">    1391 </span><span class="lineCov">     839649 :       &amp;&amp; (sra_mode == SRA_MODE_EARLY_INTRA || sra_mode == SRA_MODE_INTRA)</span>
<span class="lineNum">    1392 </span><span class="lineCov">     837353 :       &amp;&amp; !lacc-&gt;grp_unscalarizable_region</span>
<span class="lineNum">    1393 </span><span class="lineCov">     836975 :       &amp;&amp; !racc-&gt;grp_unscalarizable_region</span>
<span class="lineNum">    1394 </span><span class="lineCov">     836483 :       &amp;&amp; AGGREGATE_TYPE_P (TREE_TYPE (lhs))</span>
<span class="lineNum">    1395 </span><span class="lineCov">     836483 :       &amp;&amp; lacc-&gt;size == racc-&gt;size</span>
<span class="lineNum">    1396 </span><span class="lineCov">   13366700 :       &amp;&amp; useless_type_conversion_p (lacc-&gt;type, racc-&gt;type))</span>
<span class="lineNum">    1397 </span>            :     {
<span class="lineNum">    1398 </span><span class="lineCov">     709245 :       struct assign_link *link;</span>
<span class="lineNum">    1399 </span>            : 
<span class="lineNum">    1400 </span><span class="lineCov">     709245 :       link = assign_link_pool.allocate ();</span>
<span class="lineNum">    1401 </span><span class="lineCov">     709245 :       memset (link, 0, sizeof (struct assign_link));</span>
<span class="lineNum">    1402 </span>            : 
<span class="lineNum">    1403 </span><span class="lineCov">     709245 :       link-&gt;lacc = lacc;</span>
<span class="lineNum">    1404 </span><span class="lineCov">     709245 :       link-&gt;racc = racc;</span>
<span class="lineNum">    1405 </span><span class="lineCov">     709245 :       add_link_to_rhs (racc, link);</span>
<span class="lineNum">    1406 </span><span class="lineCov">     709245 :       add_access_to_work_queue (racc);</span>
<span class="lineNum">    1407 </span>            : 
<span class="lineNum">    1408 </span>            :       /* Let's delay marking the areas as written until propagation of accesses
<span class="lineNum">    1409 </span>            :          across link, unless the nature of rhs tells us that its data comes
<span class="lineNum">    1410 </span>            :          from elsewhere.  */
<span class="lineNum">    1411 </span><span class="lineCov">     709245 :       if (!comes_initialized_p (racc-&gt;base))</span>
<span class="lineNum">    1412 </span><span class="lineCov">     651405 :         lacc-&gt;write = false;</span>
<span class="lineNum">    1413 </span>            :     }
<span class="lineNum">    1414 </span>            : 
<span class="lineNum">    1415 </span><span class="lineCov">   12530217 :   return lacc || racc;</span>
<span class="lineNum">    1416 </span>            : }
<span class="lineNum">    1417 </span>            : 
<span class="lineNum">    1418 </span>            : /* Callback of walk_stmt_load_store_addr_ops visit_addr used to determine
<span class="lineNum">    1419 </span>            :    GIMPLE_ASM operands with memory constrains which cannot be scalarized.  */
<a name="1420"><span class="lineNum">    1420 </span>            : </a>
<span class="lineNum">    1421 </span>            : static bool
<span class="lineNum">    1422 </span><span class="lineCov">        693 : asm_visit_addr (gimple *, tree op, tree, void *)</span>
<span class="lineNum">    1423 </span>            : {
<span class="lineNum">    1424 </span><span class="lineCov">        693 :   op = get_base_address (op);</span>
<span class="lineNum">    1425 </span><span class="lineCov">        693 :   if (op</span>
<span class="lineNum">    1426 </span><span class="lineCov">        693 :       &amp;&amp; DECL_P (op))</span>
<span class="lineNum">    1427 </span><span class="lineCov">        651 :     disqualify_candidate (op, &quot;Non-scalarizable GIMPLE_ASM operand.&quot;);</span>
<span class="lineNum">    1428 </span>            : 
<span class="lineNum">    1429 </span><span class="lineCov">        693 :   return false;</span>
<span class="lineNum">    1430 </span>            : }
<span class="lineNum">    1431 </span>            : 
<span class="lineNum">    1432 </span>            : /* Return true iff callsite CALL has at least as many actual arguments as there
<span class="lineNum">    1433 </span>            :    are formal parameters of the function currently processed by IPA-SRA and
<span class="lineNum">    1434 </span>            :    that their types match.  */
<a name="1435"><span class="lineNum">    1435 </span>            : </a>
<span class="lineNum">    1436 </span>            : static inline bool
<span class="lineNum">    1437 </span><span class="lineCov">     557823 : callsite_arguments_match_p (gimple *call)</span>
<span class="lineNum">    1438 </span>            : {
<span class="lineNum">    1439 </span><span class="lineCov">     557823 :   if (gimple_call_num_args (call) &lt; (unsigned) func_param_count)</span>
<span class="lineNum">    1440 </span>            :     return false;
<span class="lineNum">    1441 </span>            : 
<span class="lineNum">    1442 </span><span class="lineCov">     557822 :   tree parm;</span>
<span class="lineNum">    1443 </span><span class="lineCov">     557822 :   int i;</span>
<span class="lineNum">    1444 </span><span class="lineCov">     557822 :   for (parm = DECL_ARGUMENTS (current_function_decl), i = 0;</span>
<span class="lineNum">    1445 </span><span class="lineCov">    1590747 :        parm;</span>
<span class="lineNum">    1446 </span><span class="lineCov">    1032925 :        parm = DECL_CHAIN (parm), i++)</span>
<span class="lineNum">    1447 </span>            :     {
<span class="lineNum">    1448 </span><span class="lineCov">    1037435 :       tree arg = gimple_call_arg (call, i);</span>
<span class="lineNum">    1449 </span><span class="lineCov">    1037435 :       if (!useless_type_conversion_p (TREE_TYPE (parm), TREE_TYPE (arg)))</span>
<span class="lineNum">    1450 </span>            :         return false;
<span class="lineNum">    1451 </span>            :     }
<span class="lineNum">    1452 </span>            :   return true;
<span class="lineNum">    1453 </span>            : }
<span class="lineNum">    1454 </span>            : 
<span class="lineNum">    1455 </span>            : /* Scan function and look for interesting expressions and create access
<span class="lineNum">    1456 </span>            :    structures for them.  Return true iff any access is created.  */
<a name="1457"><span class="lineNum">    1457 </span>            : </a>
<span class="lineNum">    1458 </span>            : static bool
<span class="lineNum">    1459 </span><span class="lineCov">     653979 : scan_function (void)</span>
<span class="lineNum">    1460 </span>            : {
<span class="lineNum">    1461 </span><span class="lineCov">     653979 :   basic_block bb;</span>
<span class="lineNum">    1462 </span><span class="lineCov">     653979 :   bool ret = false;</span>
<span class="lineNum">    1463 </span>            : 
<span class="lineNum">    1464 </span><span class="lineCov">    8291779 :   FOR_EACH_BB_FN (bb, cfun)</span>
<span class="lineNum">    1465 </span>            :     {
<span class="lineNum">    1466 </span><span class="lineCov">    7637800 :       gimple_stmt_iterator gsi;</span>
<span class="lineNum">    1467 </span><span class="lineCov">   81918633 :       for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&amp;gsi))</span>
<span class="lineNum">    1468 </span>            :         {
<span class="lineNum">    1469 </span><span class="lineCov">   66643033 :           gimple *stmt = gsi_stmt (gsi);</span>
<span class="lineNum">    1470 </span><span class="lineCov">   66643033 :           tree t;</span>
<span class="lineNum">    1471 </span><span class="lineCov">   66643033 :           unsigned i;</span>
<span class="lineNum">    1472 </span>            : 
<span class="lineNum">    1473 </span><span class="lineCov">   66643033 :           if (final_bbs &amp;&amp; stmt_can_throw_external (stmt))</span>
<span class="lineNum">    1474 </span><span class="lineCov">      74672 :             bitmap_set_bit (final_bbs, bb-&gt;index);</span>
<span class="lineNum">    1475 </span><span class="lineCov">  133286066 :           switch (gimple_code (stmt))</span>
<span class="lineNum">    1476 </span>            :             {
<span class="lineNum">    1477 </span><span class="lineCov">     648011 :             case GIMPLE_RETURN:</span>
<span class="lineNum">    1478 </span><span class="lineCov">     648011 :               t = gimple_return_retval (as_a &lt;greturn *&gt; (stmt));</span>
<span class="lineNum">    1479 </span><span class="lineCov">     648011 :               if (t != NULL_TREE)</span>
<span class="lineNum">    1480 </span><span class="lineCov">     368221 :                 ret |= build_access_from_expr (t, stmt, false);</span>
<span class="lineNum">    1481 </span><span class="lineCov">     648011 :               if (final_bbs)</span>
<span class="lineNum">    1482 </span><span class="lineCov">     245971 :                 bitmap_set_bit (final_bbs, bb-&gt;index);</span>
<span class="lineNum">    1483 </span>            :               break;
<span class="lineNum">    1484 </span>            : 
<span class="lineNum">    1485 </span><span class="lineCov">   18689084 :             case GIMPLE_ASSIGN:</span>
<span class="lineNum">    1486 </span><span class="lineCov">   18689084 :               ret |= build_accesses_from_assign (stmt);</span>
<span class="lineNum">    1487 </span><span class="lineCov">   18689084 :               break;</span>
<span class="lineNum">    1488 </span>            : 
<span class="lineNum">    1489 </span>            :             case GIMPLE_CALL:
<span class="lineNum">    1490 </span><span class="lineCov">   10237575 :               for (i = 0; i &lt; gimple_call_num_args (stmt); i++)</span>
<span class="lineNum">    1491 </span><span class="lineCov">    6673845 :                 ret |= build_access_from_expr (gimple_call_arg (stmt, i),</span>
<span class="lineNum">    1492 </span>            :                                                stmt, false);
<span class="lineNum">    1493 </span>            : 
<span class="lineNum">    1494 </span><span class="lineCov">    3563730 :               if (sra_mode == SRA_MODE_EARLY_IPA)</span>
<span class="lineNum">    1495 </span>            :                 {
<span class="lineNum">    1496 </span><span class="lineCov">     174775 :                   tree dest = gimple_call_fndecl (stmt);</span>
<span class="lineNum">    1497 </span><span class="lineCov">     174775 :                   int flags = gimple_call_flags (stmt);</span>
<span class="lineNum">    1498 </span>            : 
<span class="lineNum">    1499 </span><span class="lineCov">     174775 :                   if (dest)</span>
<span class="lineNum">    1500 </span>            :                     {
<span class="lineNum">    1501 </span><span class="lineCov">     165591 :                       if (fndecl_built_in_p (dest, BUILT_IN_APPLY_ARGS))</span>
<span class="lineNum">    1502 </span><span class="lineNoCov">          0 :                         encountered_apply_args = true;</span>
<span class="lineNum">    1503 </span><span class="lineCov">     165591 :                       if (recursive_call_p (current_function_decl, dest))</span>
<span class="lineNum">    1504 </span>            :                         {
<span class="lineNum">    1505 </span><span class="lineCov">        440 :                           encountered_recursive_call = true;</span>
<span class="lineNum">    1506 </span><span class="lineCov">        440 :                           if (!callsite_arguments_match_p (stmt))</span>
<span class="lineNum">    1507 </span><span class="lineNoCov">          0 :                             encountered_unchangable_recursive_call = true;</span>
<span class="lineNum">    1508 </span>            :                         }
<span class="lineNum">    1509 </span>            :                     }
<span class="lineNum">    1510 </span>            : 
<span class="lineNum">    1511 </span><span class="lineCov">     349550 :                   if (final_bbs</span>
<span class="lineNum">    1512 </span><span class="lineCov">     174775 :                       &amp;&amp; (flags &amp; (ECF_CONST | ECF_PURE)) == 0)</span>
<span class="lineNum">    1513 </span><span class="lineCov">     164377 :                     bitmap_set_bit (final_bbs, bb-&gt;index);</span>
<span class="lineNum">    1514 </span>            :                 }
<span class="lineNum">    1515 </span>            : 
<span class="lineNum">    1516 </span><span class="lineCov">    3563730 :               t = gimple_call_lhs (stmt);</span>
<span class="lineNum">    1517 </span><span class="lineCov">    3563730 :               if (t &amp;&amp; !disqualify_if_bad_bb_terminating_stmt (stmt, t, NULL))</span>
<span class="lineNum">    1518 </span><span class="lineCov">    1537460 :                 ret |= build_access_from_expr (t, stmt, true);</span>
<span class="lineNum">    1519 </span>            :               break;
<span class="lineNum">    1520 </span>            : 
<span class="lineNum">    1521 </span><span class="lineCov">       5610 :             case GIMPLE_ASM:</span>
<span class="lineNum">    1522 </span><span class="lineCov">       5610 :               {</span>
<span class="lineNum">    1523 </span><span class="lineCov">       5610 :                 gasm *asm_stmt = as_a &lt;gasm *&gt; (stmt);</span>
<span class="lineNum">    1524 </span><span class="lineCov">       5610 :                 walk_stmt_load_store_addr_ops (asm_stmt, NULL, NULL, NULL,</span>
<span class="lineNum">    1525 </span>            :                                                asm_visit_addr);
<span class="lineNum">    1526 </span><span class="lineCov">       5610 :                 if (final_bbs)</span>
<span class="lineNum">    1527 </span><span class="lineCov">        127 :                   bitmap_set_bit (final_bbs, bb-&gt;index);</span>
<span class="lineNum">    1528 </span>            : 
<span class="lineNum">    1529 </span><span class="lineCov">      24646 :                 for (i = 0; i &lt; gimple_asm_ninputs (asm_stmt); i++)</span>
<span class="lineNum">    1530 </span>            :                   {
<span class="lineNum">    1531 </span><span class="lineCov">      13426 :                     t = TREE_VALUE (gimple_asm_input_op (asm_stmt, i));</span>
<span class="lineNum">    1532 </span><span class="lineCov">       6713 :                     ret |= build_access_from_expr (t, asm_stmt, false);</span>
<span class="lineNum">    1533 </span>            :                   }
<span class="lineNum">    1534 </span><span class="lineCov">      19764 :                 for (i = 0; i &lt; gimple_asm_noutputs (asm_stmt); i++)</span>
<span class="lineNum">    1535 </span>            :                   {
<span class="lineNum">    1536 </span><span class="lineCov">       8544 :                     t = TREE_VALUE (gimple_asm_output_op (asm_stmt, i));</span>
<span class="lineNum">    1537 </span><span class="lineCov">       4272 :                     ret |= build_access_from_expr (t, asm_stmt, true);</span>
<span class="lineNum">    1538 </span><span class="lineCov">       5610 :                   }</span>
<span class="lineNum">    1539 </span>            :               }
<span class="lineNum">    1540 </span>            :               break;
<span class="lineNum">    1541 </span>            : 
<span class="lineNum">    1542 </span>            :             default:
<span class="lineNum">    1543 </span>            :               break;
<span class="lineNum">    1544 </span>            :             }
<span class="lineNum">    1545 </span>            :         }
<span class="lineNum">    1546 </span>            :     }
<span class="lineNum">    1547 </span>            : 
<span class="lineNum">    1548 </span><span class="lineCov">     653979 :   return ret;</span>
<span class="lineNum">    1549 </span>            : }
<span class="lineNum">    1550 </span>            : 
<span class="lineNum">    1551 </span>            : /* Helper of QSORT function. There are pointers to accesses in the array.  An
<span class="lineNum">    1552 </span>            :    access is considered smaller than another if it has smaller offset or if the
<span class="lineNum">    1553 </span>            :    offsets are the same but is size is bigger. */
<a name="1554"><span class="lineNum">    1554 </span>            : </a>
<span class="lineNum">    1555 </span>            : static int
<span class="lineNum">    1556 </span><span class="lineCov">   79844999 : compare_access_positions (const void *a, const void *b)</span>
<span class="lineNum">    1557 </span>            : {
<span class="lineNum">    1558 </span><span class="lineCov">   79844999 :   const access_p *fp1 = (const access_p *) a;</span>
<span class="lineNum">    1559 </span><span class="lineCov">   79844999 :   const access_p *fp2 = (const access_p *) b;</span>
<span class="lineNum">    1560 </span><span class="lineCov">   79844999 :   const access_p f1 = *fp1;</span>
<span class="lineNum">    1561 </span><span class="lineCov">   79844999 :   const access_p f2 = *fp2;</span>
<span class="lineNum">    1562 </span>            : 
<span class="lineNum">    1563 </span><span class="lineCov">   79844999 :   if (f1-&gt;offset != f2-&gt;offset)</span>
<span class="lineNum">    1564 </span><span class="lineCov">   67845408 :     return f1-&gt;offset &lt; f2-&gt;offset ? -1 : 1;</span>
<span class="lineNum">    1565 </span>            : 
<span class="lineNum">    1566 </span><span class="lineCov">   34248970 :   if (f1-&gt;size == f2-&gt;size)</span>
<span class="lineNum">    1567 </span>            :     {
<span class="lineNum">    1568 </span><span class="lineCov">   21451997 :       if (f1-&gt;type == f2-&gt;type)</span>
<span class="lineNum">    1569 </span>            :         return 0;
<span class="lineNum">    1570 </span>            :       /* Put any non-aggregate type before any aggregate type.  */
<span class="lineNum">    1571 </span><span class="lineCov">    3101657 :       else if (!is_gimple_reg_type (f1-&gt;type)</span>
<span class="lineNum">    1572 </span><span class="lineCov">    3101657 :           &amp;&amp; is_gimple_reg_type (f2-&gt;type))</span>
<span class="lineNum">    1573 </span>            :         return 1;
<span class="lineNum">    1574 </span><span class="lineCov">    2096867 :       else if (is_gimple_reg_type (f1-&gt;type)</span>
<span class="lineNum">    1575 </span><span class="lineCov">    2096867 :                &amp;&amp; !is_gimple_reg_type (f2-&gt;type))</span>
<span class="lineNum">    1576 </span>            :         return -1;
<span class="lineNum">    1577 </span>            :       /* Put any complex or vector type before any other scalar type.  */
<span class="lineNum">    1578 </span><span class="lineCov">    1127222 :       else if (TREE_CODE (f1-&gt;type) != COMPLEX_TYPE</span>
<span class="lineNum">    1579 </span><span class="lineCov">     563611 :                &amp;&amp; TREE_CODE (f1-&gt;type) != VECTOR_TYPE</span>
<span class="lineNum">    1580 </span><span class="lineCov">    1060688 :                &amp;&amp; (TREE_CODE (f2-&gt;type) == COMPLEX_TYPE</span>
<span class="lineNum">    1581 </span><span class="lineCov">     530344 :                    || TREE_CODE (f2-&gt;type) == VECTOR_TYPE))</span>
<span class="lineNum">    1582 </span>            :         return 1;
<span class="lineNum">    1583 </span><span class="lineCov">     540666 :       else if ((TREE_CODE (f1-&gt;type) == COMPLEX_TYPE</span>
<span class="lineNum">    1584 </span>            :                 || TREE_CODE (f1-&gt;type) == VECTOR_TYPE)
<span class="lineNum">    1585 </span><span class="lineCov">      33267 :                &amp;&amp; TREE_CODE (f2-&gt;type) != COMPLEX_TYPE</span>
<span class="lineNum">    1586 </span><span class="lineCov">      31682 :                &amp;&amp; TREE_CODE (f2-&gt;type) != VECTOR_TYPE)</span>
<span class="lineNum">    1587 </span>            :         return -1;
<span class="lineNum">    1588 </span>            :       /* Put any integral type before any non-integral type.  When splicing, we
<span class="lineNum">    1589 </span>            :          make sure that those with insufficient precision and occupying the
<span class="lineNum">    1590 </span>            :          same space are not scalarized.  */
<span class="lineNum">    1591 </span><span class="lineCov">     509128 :       else if (INTEGRAL_TYPE_P (f1-&gt;type)</span>
<span class="lineNum">    1592 </span><span class="lineCov">     120759 :                &amp;&amp; !INTEGRAL_TYPE_P (f2-&gt;type))</span>
<span class="lineNum">    1593 </span>            :         return -1;
<span class="lineNum">    1594 </span><span class="lineCov">     499546 :       else if (!INTEGRAL_TYPE_P (f1-&gt;type)</span>
<span class="lineNum">    1595 </span><span class="lineCov">     388369 :                &amp;&amp; INTEGRAL_TYPE_P (f2-&gt;type))</span>
<span class="lineNum">    1596 </span>            :         return 1;
<span class="lineNum">    1597 </span>            :       /* Put the integral type with the bigger precision first.  */
<span class="lineNum">    1598 </span><span class="lineCov">     492573 :       else if (INTEGRAL_TYPE_P (f1-&gt;type)</span>
<span class="lineNum">    1599 </span><span class="lineCov">     111177 :                &amp;&amp; INTEGRAL_TYPE_P (f2-&gt;type)</span>
<span class="lineNum">    1600 </span><span class="lineCov">     603750 :                &amp;&amp; (TYPE_PRECISION (f2-&gt;type) != TYPE_PRECISION (f1-&gt;type)))</span>
<span class="lineNum">    1601 </span><span class="lineCov">      65670 :         return TYPE_PRECISION (f2-&gt;type) - TYPE_PRECISION (f1-&gt;type);</span>
<span class="lineNum">    1602 </span>            :       /* Stabilize the sort.  */
<span class="lineNum">    1603 </span><span class="lineCov">     470683 :       return TYPE_UID (f1-&gt;type) - TYPE_UID (f2-&gt;type);</span>
<span class="lineNum">    1604 </span>            :     }
<span class="lineNum">    1605 </span>            : 
<span class="lineNum">    1606 </span>            :   /* We want the bigger accesses first, thus the opposite operator in the next
<span class="lineNum">    1607 </span>            :      line: */
<span class="lineNum">    1608 </span><span class="lineCov">   12796973 :   return f1-&gt;size &gt; f2-&gt;size ? -1 : 1;</span>
<span class="lineNum">    1609 </span>            : }
<span class="lineNum">    1610 </span>            : 
<span class="lineNum">    1611 </span>            : 
<span class="lineNum">    1612 </span>            : /* Append a name of the declaration to the name obstack.  A helper function for
<span class="lineNum">    1613 </span>            :    make_fancy_name.  */
<a name="1614"><span class="lineNum">    1614 </span>            : </a>
<span class="lineNum">    1615 </span>            : static void
<span class="lineNum">    1616 </span><span class="lineCov">     956831 : make_fancy_decl_name (tree decl)</span>
<span class="lineNum">    1617 </span>            : {
<span class="lineNum">    1618 </span><span class="lineCov">     956831 :   char buffer[32];</span>
<span class="lineNum">    1619 </span>            : 
<span class="lineNum">    1620 </span><span class="lineCov">     956831 :   tree name = DECL_NAME (decl);</span>
<span class="lineNum">    1621 </span><span class="lineCov">     956831 :   if (name)</span>
<span class="lineNum">    1622 </span><span class="lineCov">     947812 :     obstack_grow (&amp;name_obstack, IDENTIFIER_POINTER (name),</span>
<span class="lineNum">    1623 </span>            :                   IDENTIFIER_LENGTH (name));
<span class="lineNum">    1624 </span>            :   else
<span class="lineNum">    1625 </span>            :     {
<span class="lineNum">    1626 </span><span class="lineCov">       9019 :       sprintf (buffer, &quot;D%u&quot;, DECL_UID (decl));</span>
<span class="lineNum">    1627 </span><span class="lineCov">       9019 :       obstack_grow (&amp;name_obstack, buffer, strlen (buffer));</span>
<span class="lineNum">    1628 </span>            :     }
<span class="lineNum">    1629 </span><span class="lineCov">     956831 : }</span>
<span class="lineNum">    1630 </span>            : 
<span class="lineNum">    1631 </span>            : /* Helper for make_fancy_name.  */
<a name="1632"><span class="lineNum">    1632 </span>            : </a>
<span class="lineNum">    1633 </span>            : static void
<span class="lineNum">    1634 </span><span class="lineCov">    1305909 : make_fancy_name_1 (tree expr)</span>
<span class="lineNum">    1635 </span>            : {
<span class="lineNum">    1636 </span><span class="lineCov">    1305909 :   char buffer[32];</span>
<span class="lineNum">    1637 </span><span class="lineCov">    1305909 :   tree index;</span>
<span class="lineNum">    1638 </span>            : 
<span class="lineNum">    1639 </span><span class="lineCov">    1305909 :   if (DECL_P (expr))</span>
<span class="lineNum">    1640 </span>            :     {
<span class="lineNum">    1641 </span><span class="lineCov">     525298 :       make_fancy_decl_name (expr);</span>
<span class="lineNum">    1642 </span><span class="lineCov">     525298 :       return;</span>
<span class="lineNum">    1643 </span>            :     }
<span class="lineNum">    1644 </span>            : 
<span class="lineNum">    1645 </span><span class="lineCov">     780611 :   switch (TREE_CODE (expr))</span>
<span class="lineNum">    1646 </span>            :     {
<span class="lineNum">    1647 </span><span class="lineCov">     431533 :     case COMPONENT_REF:</span>
<span class="lineNum">    1648 </span><span class="lineCov">     431533 :       make_fancy_name_1 (TREE_OPERAND (expr, 0));</span>
<span class="lineNum">    1649 </span><span class="lineCov">     431533 :       obstack_1grow (&amp;name_obstack, '$');</span>
<span class="lineNum">    1650 </span><span class="lineCov">     431533 :       make_fancy_decl_name (TREE_OPERAND (expr, 1));</span>
<span class="lineNum">    1651 </span><span class="lineCov">     431533 :       break;</span>
<span class="lineNum">    1652 </span>            : 
<span class="lineNum">    1653 </span><span class="lineCov">      29838 :     case ARRAY_REF:</span>
<span class="lineNum">    1654 </span><span class="lineCov">      29838 :       make_fancy_name_1 (TREE_OPERAND (expr, 0));</span>
<span class="lineNum">    1655 </span><span class="lineCov">      29838 :       obstack_1grow (&amp;name_obstack, '$');</span>
<span class="lineNum">    1656 </span>            :       /* Arrays with only one element may not have a constant as their
<span class="lineNum">    1657 </span>            :          index. */
<span class="lineNum">    1658 </span><span class="lineCov">      29838 :       index = TREE_OPERAND (expr, 1);</span>
<span class="lineNum">    1659 </span><span class="lineCov">      29838 :       if (TREE_CODE (index) != INTEGER_CST)</span>
<span class="lineNum">    1660 </span>            :         break;
<span class="lineNum">    1661 </span><span class="lineCov">      29779 :       sprintf (buffer, HOST_WIDE_INT_PRINT_DEC, TREE_INT_CST_LOW (index));</span>
<span class="lineNum">    1662 </span><span class="lineCov">      29779 :       obstack_grow (&amp;name_obstack, buffer, strlen (buffer));</span>
<span class="lineNum">    1663 </span><span class="lineCov">      29779 :       break;</span>
<span class="lineNum">    1664 </span>            : 
<span class="lineNum">    1665 </span><span class="lineCov">     159620 :     case ADDR_EXPR:</span>
<span class="lineNum">    1666 </span><span class="lineCov">     159620 :       make_fancy_name_1 (TREE_OPERAND (expr, 0));</span>
<span class="lineNum">    1667 </span><span class="lineCov">     159620 :       break;</span>
<span class="lineNum">    1668 </span>            : 
<span class="lineNum">    1669 </span><span class="lineCov">     159620 :     case MEM_REF:</span>
<span class="lineNum">    1670 </span><span class="lineCov">     159620 :       make_fancy_name_1 (TREE_OPERAND (expr, 0));</span>
<span class="lineNum">    1671 </span><span class="lineCov">     159620 :       if (!integer_zerop (TREE_OPERAND (expr, 1)))</span>
<span class="lineNum">    1672 </span>            :         {
<span class="lineNum">    1673 </span><span class="lineCov">      51062 :           obstack_1grow (&amp;name_obstack, '$');</span>
<span class="lineNum">    1674 </span><span class="lineCov">     102124 :           sprintf (buffer, HOST_WIDE_INT_PRINT_DEC,</span>
<span class="lineNum">    1675 </span><span class="lineCov">      51062 :                    TREE_INT_CST_LOW (TREE_OPERAND (expr, 1)));</span>
<span class="lineNum">    1676 </span><span class="lineCov">      51062 :           obstack_grow (&amp;name_obstack, buffer, strlen (buffer));</span>
<span class="lineNum">    1677 </span>            :         }
<span class="lineNum">    1678 </span>            :       break;
<span class="lineNum">    1679 </span>            : 
<span class="lineNum">    1680 </span><span class="lineNoCov">          0 :     case BIT_FIELD_REF:</span>
<span class="lineNum">    1681 </span><span class="lineNoCov">          0 :     case REALPART_EXPR:</span>
<span class="lineNum">    1682 </span><span class="lineNoCov">          0 :     case IMAGPART_EXPR:</span>
<span class="lineNum">    1683 </span><span class="lineNoCov">          0 :       gcc_unreachable ();       /* we treat these as scalars.  */</span>
<span class="lineNum">    1684 </span>            :       break;
<span class="lineNum">    1685 </span>            :     default:
<span class="lineNum">    1686 </span>            :       break;
<span class="lineNum">    1687 </span>            :     }
<span class="lineNum">    1688 </span>            : }
<span class="lineNum">    1689 </span>            : 
<span class="lineNum">    1690 </span>            : /* Create a human readable name for replacement variable of ACCESS.  */
<a name="1691"><span class="lineNum">    1691 </span>            : </a>
<span class="lineNum">    1692 </span>            : static char *
<span class="lineNum">    1693 </span><span class="lineCov">     525298 : make_fancy_name (tree expr)</span>
<span class="lineNum">    1694 </span>            : {
<span class="lineNum">    1695 </span><span class="lineCov">     525298 :   make_fancy_name_1 (expr);</span>
<span class="lineNum">    1696 </span><span class="lineCov">     525298 :   obstack_1grow (&amp;name_obstack, '\0');</span>
<span class="lineNum">    1697 </span><span class="lineCov">     525298 :   return XOBFINISH (&amp;name_obstack, char *);</span>
<span class="lineNum">    1698 </span>            : }
<span class="lineNum">    1699 </span>            : 
<span class="lineNum">    1700 </span>            : /* Construct a MEM_REF that would reference a part of aggregate BASE of type
<span class="lineNum">    1701 </span>            :    EXP_TYPE at the given OFFSET and with storage order REVERSE.  If BASE is
<span class="lineNum">    1702 </span>            :    something for which get_addr_base_and_unit_offset returns NULL, gsi must
<span class="lineNum">    1703 </span>            :    be non-NULL and is used to insert new statements either before or below
<span class="lineNum">    1704 </span>            :    the current one as specified by INSERT_AFTER.  This function is not capable
<span class="lineNum">    1705 </span>            :    of handling bitfields.  */
<a name="1706"><span class="lineNum">    1706 </span>            : </a>
<span class="lineNum">    1707 </span>            : tree
<span class="lineNum">    1708 </span><span class="lineCov">    2064378 : build_ref_for_offset (location_t loc, tree base, poly_int64 offset,</span>
<span class="lineNum">    1709 </span>            :                       bool reverse, tree exp_type, gimple_stmt_iterator *gsi,
<span class="lineNum">    1710 </span>            :                       bool insert_after)
<span class="lineNum">    1711 </span>            : {
<span class="lineNum">    1712 </span><span class="lineCov">    2064378 :   tree prev_base = base;</span>
<span class="lineNum">    1713 </span><span class="lineCov">    2064378 :   tree off;</span>
<span class="lineNum">    1714 </span><span class="lineCov">    2064378 :   tree mem_ref;</span>
<span class="lineNum">    1715 </span><span class="lineCov">    2064378 :   poly_int64 base_offset;</span>
<span class="lineNum">    1716 </span><span class="lineCov">    2064378 :   unsigned HOST_WIDE_INT misalign;</span>
<span class="lineNum">    1717 </span><span class="lineCov">    2064378 :   unsigned int align;</span>
<span class="lineNum">    1718 </span>            : 
<span class="lineNum">    1719 </span>            :   /* Preserve address-space information.  */
<span class="lineNum">    1720 </span><span class="lineCov">    2064378 :   addr_space_t as = TYPE_ADDR_SPACE (TREE_TYPE (base));</span>
<span class="lineNum">    1721 </span><span class="lineCov">    2064378 :   if (as != TYPE_ADDR_SPACE (exp_type))</span>
<span class="lineNum">    1722 </span><span class="lineCov">          2 :     exp_type = build_qualified_type (exp_type,</span>
<span class="lineNum">    1723 </span><span class="lineCov">          5 :                                      TYPE_QUALS (exp_type)</span>
<span class="lineNum">    1724 </span><span class="lineCov">          1 :                                      | ENCODE_QUAL_ADDR_SPACE (as));</span>
<span class="lineNum">    1725 </span>            : 
<span class="lineNum">    1726 </span><span class="lineCov">    2064378 :   poly_int64 byte_offset = exact_div (offset, BITS_PER_UNIT);</span>
<span class="lineNum">    1727 </span><span class="lineCov">    2064378 :   get_object_alignment_1 (base, &amp;align, &amp;misalign);</span>
<span class="lineNum">    1728 </span><span class="lineCov">    2064378 :   base = get_addr_base_and_unit_offset (base, &amp;base_offset);</span>
<span class="lineNum">    1729 </span>            : 
<span class="lineNum">    1730 </span>            :   /* get_addr_base_and_unit_offset returns NULL for references with a variable
<span class="lineNum">    1731 </span>            :      offset such as array[var_index].  */
<span class="lineNum">    1732 </span><span class="lineCov">    2064378 :   if (!base)</span>
<span class="lineNum">    1733 </span>            :     {
<span class="lineNum">    1734 </span><span class="lineCov">      10098 :       gassign *stmt;</span>
<span class="lineNum">    1735 </span><span class="lineCov">      10098 :       tree tmp, addr;</span>
<span class="lineNum">    1736 </span>            : 
<span class="lineNum">    1737 </span><span class="lineCov">      10098 :       gcc_checking_assert (gsi);</span>
<span class="lineNum">    1738 </span><span class="lineCov">      10098 :       tmp = make_ssa_name (build_pointer_type (TREE_TYPE (prev_base)));</span>
<span class="lineNum">    1739 </span><span class="lineCov">      10098 :       addr = build_fold_addr_expr (unshare_expr (prev_base));</span>
<span class="lineNum">    1740 </span><span class="lineCov">      10098 :       STRIP_USELESS_TYPE_CONVERSION (addr);</span>
<span class="lineNum">    1741 </span><span class="lineCov">      10098 :       stmt = gimple_build_assign (tmp, addr);</span>
<span class="lineNum">    1742 </span><span class="lineCov">      10098 :       gimple_set_location (stmt, loc);</span>
<span class="lineNum">    1743 </span><span class="lineCov">      10098 :       if (insert_after)</span>
<span class="lineNum">    1744 </span><span class="lineCov">       3243 :         gsi_insert_after (gsi, stmt, GSI_NEW_STMT);</span>
<span class="lineNum">    1745 </span>            :       else
<span class="lineNum">    1746 </span><span class="lineCov">       6855 :         gsi_insert_before (gsi, stmt, GSI_SAME_STMT);</span>
<span class="lineNum">    1747 </span>            : 
<span class="lineNum">    1748 </span><span class="lineCov">      10098 :       off = build_int_cst (reference_alias_ptr_type (prev_base), byte_offset);</span>
<span class="lineNum">    1749 </span><span class="lineCov">      10098 :       base = tmp;</span>
<span class="lineNum">    1750 </span>            :     }
<span class="lineNum">    1751 </span><span class="lineCov">    2054280 :   else if (TREE_CODE (base) == MEM_REF)</span>
<span class="lineNum">    1752 </span>            :     {
<span class="lineNum">    1753 </span><span class="lineCov">     180905 :       off = build_int_cst (TREE_TYPE (TREE_OPERAND (base, 1)),</span>
<span class="lineNum">    1754 </span>            :                            base_offset + byte_offset);
<span class="lineNum">    1755 </span><span class="lineCov">     180905 :       off = int_const_binop (PLUS_EXPR, TREE_OPERAND (base, 1), off);</span>
<span class="lineNum">    1756 </span><span class="lineCov">     180905 :       base = unshare_expr (TREE_OPERAND (base, 0));</span>
<span class="lineNum">    1757 </span>            :     }
<span class="lineNum">    1758 </span>            :   else
<span class="lineNum">    1759 </span>            :     {
<span class="lineNum">    1760 </span><span class="lineCov">    1873375 :       off = build_int_cst (reference_alias_ptr_type (prev_base),</span>
<span class="lineNum">    1761 </span>            :                            base_offset + byte_offset);
<span class="lineNum">    1762 </span><span class="lineCov">    1873375 :       base = build_fold_addr_expr (unshare_expr (base));</span>
<span class="lineNum">    1763 </span>            :     }
<span class="lineNum">    1764 </span>            : 
<span class="lineNum">    1765 </span><span class="lineCov">    4128756 :   unsigned int align_bound = known_alignment (misalign + offset);</span>
<span class="lineNum">    1766 </span><span class="lineCov">    2064378 :   if (align_bound != 0)</span>
<span class="lineNum">    1767 </span><span class="lineCov">    1574298 :     align = MIN (align, align_bound);</span>
<span class="lineNum">    1768 </span><span class="lineCov">    2064378 :   if (align != TYPE_ALIGN (exp_type))</span>
<span class="lineNum">    1769 </span><span class="lineCov">     370653 :     exp_type = build_aligned_type (exp_type, align);</span>
<span class="lineNum">    1770 </span>            : 
<span class="lineNum">    1771 </span><span class="lineCov">    2064378 :   mem_ref = fold_build2_loc (loc, MEM_REF, exp_type, base, off);</span>
<span class="lineNum">    1772 </span><span class="lineCov">    2064378 :   REF_REVERSE_STORAGE_ORDER (mem_ref) = reverse;</span>
<span class="lineNum">    1773 </span><span class="lineCov">    2064378 :   if (TREE_THIS_VOLATILE (prev_base))</span>
<span class="lineNum">    1774 </span><span class="lineCov">          6 :     TREE_THIS_VOLATILE (mem_ref) = 1;</span>
<span class="lineNum">    1775 </span><span class="lineCov">    2064378 :   if (TREE_SIDE_EFFECTS (prev_base))</span>
<span class="lineNum">    1776 </span><span class="lineCov">          6 :     TREE_SIDE_EFFECTS (mem_ref) = 1;</span>
<span class="lineNum">    1777 </span><span class="lineCov">    2064378 :   return mem_ref;</span>
<span class="lineNum">    1778 </span>            : }
<span class="lineNum">    1779 </span>            : 
<span class="lineNum">    1780 </span>            : /* Construct a memory reference to a part of an aggregate BASE at the given
<span class="lineNum">    1781 </span>            :    OFFSET and of the same type as MODEL.  In case this is a reference to a
<span class="lineNum">    1782 </span>            :    bit-field, the function will replicate the last component_ref of model's
<span class="lineNum">    1783 </span>            :    expr to access it.  GSI and INSERT_AFTER have the same meaning as in
<span class="lineNum">    1784 </span>            :    build_ref_for_offset.  */
<a name="1785"><span class="lineNum">    1785 </span>            : </a>
<span class="lineNum">    1786 </span>            : static tree
<span class="lineNum">    1787 </span><span class="lineCov">    2023440 : build_ref_for_model (location_t loc, tree base, HOST_WIDE_INT offset,</span>
<span class="lineNum">    1788 </span>            :                      struct access *model, gimple_stmt_iterator *gsi,
<span class="lineNum">    1789 </span>            :                      bool insert_after)
<span class="lineNum">    1790 </span>            : {
<span class="lineNum">    1791 </span><span class="lineCov">    2023440 :   if (TREE_CODE (model-&gt;expr) == COMPONENT_REF</span>
<span class="lineNum">    1792 </span><span class="lineCov">    2023440 :       &amp;&amp; DECL_BIT_FIELD (TREE_OPERAND (model-&gt;expr, 1)))</span>
<span class="lineNum">    1793 </span>            :     {
<span class="lineNum">    1794 </span>            :       /* This access represents a bit-field.  */
<span class="lineNum">    1795 </span><span class="lineCov">       6709 :       tree t, exp_type, fld = TREE_OPERAND (model-&gt;expr, 1);</span>
<span class="lineNum">    1796 </span>            : 
<span class="lineNum">    1797 </span><span class="lineCov">       6709 :       offset -= int_bit_position (fld);</span>
<span class="lineNum">    1798 </span><span class="lineCov">       6709 :       exp_type = TREE_TYPE (TREE_OPERAND (model-&gt;expr, 0));</span>
<span class="lineNum">    1799 </span><span class="lineCov">       6709 :       t = build_ref_for_offset (loc, base, offset, model-&gt;reverse, exp_type,</span>
<span class="lineNum">    1800 </span><span class="lineCov">       6709 :                                 gsi, insert_after);</span>
<span class="lineNum">    1801 </span>            :       /* The flag will be set on the record type.  */
<span class="lineNum">    1802 </span><span class="lineCov">       6709 :       REF_REVERSE_STORAGE_ORDER (t) = 0;</span>
<span class="lineNum">    1803 </span><span class="lineCov">       6709 :       return fold_build3_loc (loc, COMPONENT_REF, TREE_TYPE (fld), t, fld,</span>
<span class="lineNum">    1804 </span>            :                               NULL_TREE);
<span class="lineNum">    1805 </span>            :     }
<span class="lineNum">    1806 </span>            :   else
<span class="lineNum">    1807 </span><span class="lineCov">    2016731 :     return</span>
<span class="lineNum">    1808 </span><span class="lineCov">    2016731 :       build_ref_for_offset (loc, base, offset, model-&gt;reverse, model-&gt;type,</span>
<span class="lineNum">    1809 </span><span class="lineCov">    2016731 :                             gsi, insert_after);</span>
<span class="lineNum">    1810 </span>            : }
<span class="lineNum">    1811 </span>            : 
<span class="lineNum">    1812 </span>            : /* Attempt to build a memory reference that we could but into a gimple
<span class="lineNum">    1813 </span>            :    debug_bind statement.  Similar to build_ref_for_model but punts if it has to
<span class="lineNum">    1814 </span>            :    create statements and return s NULL instead.  This function also ignores
<span class="lineNum">    1815 </span>            :    alignment issues and so its results should never end up in non-debug
<span class="lineNum">    1816 </span>            :    statements.  */
<a name="1817"><span class="lineNum">    1817 </span>            : </a>
<span class="lineNum">    1818 </span>            : static tree
<span class="lineNum">    1819 </span><span class="lineCov">        958 : build_debug_ref_for_model (location_t loc, tree base, HOST_WIDE_INT offset,</span>
<span class="lineNum">    1820 </span>            :                            struct access *model)
<span class="lineNum">    1821 </span>            : {
<span class="lineNum">    1822 </span><span class="lineCov">        958 :   poly_int64 base_offset;</span>
<span class="lineNum">    1823 </span><span class="lineCov">        958 :   tree off;</span>
<span class="lineNum">    1824 </span>            : 
<span class="lineNum">    1825 </span><span class="lineCov">        958 :   if (TREE_CODE (model-&gt;expr) == COMPONENT_REF</span>
<span class="lineNum">    1826 </span><span class="lineCov">        958 :       &amp;&amp; DECL_BIT_FIELD (TREE_OPERAND (model-&gt;expr, 1)))</span>
<span class="lineNum">    1827 </span>            :     return NULL_TREE;
<span class="lineNum">    1828 </span>            : 
<span class="lineNum">    1829 </span><span class="lineCov">        958 :   base = get_addr_base_and_unit_offset (base, &amp;base_offset);</span>
<span class="lineNum">    1830 </span><span class="lineCov">        958 :   if (!base)</span>
<span class="lineNum">    1831 </span>            :     return NULL_TREE;
<span class="lineNum">    1832 </span><span class="lineCov">        958 :   if (TREE_CODE (base) == MEM_REF)</span>
<span class="lineNum">    1833 </span>            :     {
<span class="lineNum">    1834 </span><span class="lineCov">        280 :       off = build_int_cst (TREE_TYPE (TREE_OPERAND (base, 1)),</span>
<span class="lineNum">    1835 </span><span class="lineCov">        280 :                            base_offset + offset / BITS_PER_UNIT);</span>
<span class="lineNum">    1836 </span><span class="lineCov">        280 :       off = int_const_binop (PLUS_EXPR, TREE_OPERAND (base, 1), off);</span>
<span class="lineNum">    1837 </span><span class="lineCov">        280 :       base = unshare_expr (TREE_OPERAND (base, 0));</span>
<span class="lineNum">    1838 </span>            :     }
<span class="lineNum">    1839 </span>            :   else
<span class="lineNum">    1840 </span>            :     {
<span class="lineNum">    1841 </span><span class="lineCov">        678 :       off = build_int_cst (reference_alias_ptr_type (base),</span>
<span class="lineNum">    1842 </span><span class="lineCov">        678 :                            base_offset + offset / BITS_PER_UNIT);</span>
<span class="lineNum">    1843 </span><span class="lineCov">        678 :       base = build_fold_addr_expr (unshare_expr (base));</span>
<span class="lineNum">    1844 </span>            :     }
<span class="lineNum">    1845 </span>            : 
<span class="lineNum">    1846 </span><span class="lineCov">        958 :   return fold_build2_loc (loc, MEM_REF, model-&gt;type, base, off);</span>
<span class="lineNum">    1847 </span>            : }
<span class="lineNum">    1848 </span>            : 
<span class="lineNum">    1849 </span>            : /* Construct a memory reference consisting of component_refs and array_refs to
<span class="lineNum">    1850 </span>            :    a part of an aggregate *RES (which is of type TYPE).  The requested part
<span class="lineNum">    1851 </span>            :    should have type EXP_TYPE at be the given OFFSET.  This function might not
<span class="lineNum">    1852 </span>            :    succeed, it returns true when it does and only then *RES points to something
<span class="lineNum">    1853 </span>            :    meaningful.  This function should be used only to build expressions that we
<span class="lineNum">    1854 </span>            :    might need to present to user (e.g. in warnings).  In all other situations,
<span class="lineNum">    1855 </span>            :    build_ref_for_model or build_ref_for_offset should be used instead.  */
<a name="1856"><span class="lineNum">    1856 </span>            : </a>
<span class="lineNum">    1857 </span>            : static bool
<span class="lineNum">    1858 </span><span class="lineCov">     493438 : build_user_friendly_ref_for_offset (tree *res, tree type, HOST_WIDE_INT offset,</span>
<span class="lineNum">    1859 </span>            :                                     tree exp_type)
<span class="lineNum">    1860 </span>            : {
<span class="lineNum">    1861 </span><span class="lineCov">     525727 :   while (1)</span>
<span class="lineNum">    1862 </span>            :     {
<span class="lineNum">    1863 </span><span class="lineCov">     525727 :       tree fld;</span>
<span class="lineNum">    1864 </span><span class="lineCov">     525727 :       tree tr_size, index, minidx;</span>
<span class="lineNum">    1865 </span><span class="lineCov">     525727 :       HOST_WIDE_INT el_size;</span>
<span class="lineNum">    1866 </span>            : 
<span class="lineNum">    1867 </span><span class="lineCov">     525727 :       if (offset == 0 &amp;&amp; exp_type</span>
<span class="lineNum">    1868 </span><span class="lineCov">     525727 :           &amp;&amp; types_compatible_p (exp_type, type))</span>
<span class="lineNum">    1869 </span><span class="lineCov">     493438 :         return true;</span>
<span class="lineNum">    1870 </span>            : 
<span class="lineNum">    1871 </span><span class="lineCov">     304924 :       switch (TREE_CODE (type))</span>
<span class="lineNum">    1872 </span>            :         {
<span class="lineNum">    1873 </span><span class="lineCov">     270914 :         case UNION_TYPE:</span>
<span class="lineNum">    1874 </span><span class="lineCov">     270914 :         case QUAL_UNION_TYPE:</span>
<span class="lineNum">    1875 </span><span class="lineCov">     270914 :         case RECORD_TYPE:</span>
<span class="lineNum">    1876 </span><span class="lineCov">    1823006 :           for (fld = TYPE_FIELDS (type); fld; fld = DECL_CHAIN (fld))</span>
<span class="lineNum">    1877 </span>            :             {
<span class="lineNum">    1878 </span><span class="lineCov">    1820040 :               HOST_WIDE_INT pos, size;</span>
<span class="lineNum">    1879 </span><span class="lineCov">    1820040 :               tree tr_pos, expr, *expr_ptr;</span>
<span class="lineNum">    1880 </span>            : 
<span class="lineNum">    1881 </span><span class="lineCov">    1820040 :               if (TREE_CODE (fld) != FIELD_DECL)</span>
<span class="lineNum">    1882 </span><span class="lineCov">    1549017 :                 continue;</span>
<span class="lineNum">    1883 </span>            : 
<span class="lineNum">    1884 </span><span class="lineCov">     473930 :               tr_pos = bit_position (fld);</span>
<span class="lineNum">    1885 </span><span class="lineCov">     473930 :               if (!tr_pos || !tree_fits_uhwi_p (tr_pos))</span>
<span class="lineNum">    1886 </span>            :                 continue;
<span class="lineNum">    1887 </span><span class="lineCov">     473930 :               pos = tree_to_uhwi (tr_pos);</span>
<span class="lineNum">    1888 </span><span class="lineCov">     473930 :               gcc_assert (TREE_CODE (type) == RECORD_TYPE || pos == 0);</span>
<span class="lineNum">    1889 </span><span class="lineCov">     473930 :               tr_size = DECL_SIZE (fld);</span>
<span class="lineNum">    1890 </span><span class="lineCov">     473930 :               if (!tr_size || !tree_fits_uhwi_p (tr_size))</span>
<span class="lineNum">    1891 </span>            :                 continue;
<span class="lineNum">    1892 </span><span class="lineCov">     473930 :               size = tree_to_uhwi (tr_size);</span>
<span class="lineNum">    1893 </span><span class="lineCov">     473930 :               if (size == 0)</span>
<span class="lineNum">    1894 </span>            :                 {
<span class="lineNum">    1895 </span><span class="lineCov">        564 :                   if (pos != offset)</span>
<span class="lineNum">    1896 </span>            :                     continue;
<span class="lineNum">    1897 </span>            :                 }
<span class="lineNum">    1898 </span><span class="lineCov">     473366 :               else if (pos &gt; offset || (pos + size) &lt;= offset)</span>
<span class="lineNum">    1899 </span>            :                 continue;
<span class="lineNum">    1900 </span>            : 
<span class="lineNum">    1901 </span><span class="lineCov">     271023 :               expr = build3 (COMPONENT_REF, TREE_TYPE (fld), *res, fld,</span>
<span class="lineNum">    1902 </span>            :                              NULL_TREE);
<span class="lineNum">    1903 </span><span class="lineCov">     271023 :               expr_ptr = &amp;expr;</span>
<span class="lineNum">    1904 </span><span class="lineCov">     271023 :               if (build_user_friendly_ref_for_offset (expr_ptr, TREE_TYPE (fld),</span>
<span class="lineNum">    1905 </span>            :                                                       offset - pos, exp_type))
<span class="lineNum">    1906 </span>            :                 {
<span class="lineNum">    1907 </span><span class="lineCov">     269025 :                   *res = expr;</span>
<span class="lineNum">    1908 </span><span class="lineCov">     269025 :                   return true;</span>
<span class="lineNum">    1909 </span>            :                 }
<span class="lineNum">    1910 </span><span class="lineCov">       1889 :             }</span>
<span class="lineNum">    1911 </span>            :           return false;
<span class="lineNum">    1912 </span>            : 
<span class="lineNum">    1913 </span><span class="lineCov">      32289 :         case ARRAY_TYPE:</span>
<span class="lineNum">    1914 </span><span class="lineCov">      32289 :           tr_size = TYPE_SIZE (TREE_TYPE (type));</span>
<span class="lineNum">    1915 </span><span class="lineCov">      32289 :           if (!tr_size || !tree_fits_uhwi_p (tr_size))</span>
<span class="lineNum">    1916 </span>            :             return false;
<span class="lineNum">    1917 </span><span class="lineCov">      32289 :           el_size = tree_to_uhwi (tr_size);</span>
<span class="lineNum">    1918 </span>            : 
<span class="lineNum">    1919 </span><span class="lineCov">      32289 :           minidx = TYPE_MIN_VALUE (TYPE_DOMAIN (type));</span>
<span class="lineNum">    1920 </span><span class="lineCov">      32289 :           if (TREE_CODE (minidx) != INTEGER_CST || el_size == 0)</span>
<span class="lineNum">    1921 </span>            :             return false;
<span class="lineNum">    1922 </span><span class="lineCov">      96867 :           index = build_int_cst (TYPE_DOMAIN (type), offset / el_size);</span>
<span class="lineNum">    1923 </span><span class="lineCov">      32289 :           if (!integer_zerop (minidx))</span>
<span class="lineNum">    1924 </span><span class="lineCov">        547 :             index = int_const_binop (PLUS_EXPR, index, minidx);</span>
<span class="lineNum">    1925 </span><span class="lineCov">      32289 :           *res = build4 (ARRAY_REF, TREE_TYPE (type), *res, index,</span>
<span class="lineNum">    1926 </span>            :                          NULL_TREE, NULL_TREE);
<span class="lineNum">    1927 </span><span class="lineCov">      32289 :           offset = offset % el_size;</span>
<span class="lineNum">    1928 </span><span class="lineCov">      32289 :           type = TREE_TYPE (type);</span>
<span class="lineNum">    1929 </span><span class="lineCov">      32289 :           break;</span>
<span class="lineNum">    1930 </span>            : 
<span class="lineNum">    1931 </span><span class="lineCov">       1721 :         default:</span>
<span class="lineNum">    1932 </span><span class="lineCov">       1721 :           if (offset != 0)</span>
<span class="lineNum">    1933 </span>            :             return false;
<span class="lineNum">    1934 </span>            : 
<span class="lineNum">    1935 </span><span class="lineCov">       1721 :           if (exp_type)</span>
<span class="lineNum">    1936 </span>            :             return false;
<span class="lineNum">    1937 </span>            :           else
<span class="lineNum">    1938 </span><span class="lineNoCov">          0 :             return true;</span>
<span class="lineNum">    1939 </span>            :         }
<span class="lineNum">    1940 </span>            :     }
<span class="lineNum">    1941 </span>            : }
<span class="lineNum">    1942 </span>            : 
<span class="lineNum">    1943 </span>            : /* Return true iff TYPE is stdarg va_list type.  */
<a name="1944"><span class="lineNum">    1944 </span>            : </a>
<span class="lineNum">    1945 </span>            : static inline bool
<span class="lineNum">    1946 </span><span class="lineCov">    2350297 : is_va_list_type (tree type)</span>
<span class="lineNum">    1947 </span>            : {
<span class="lineNum">    1948 </span><span class="lineCov">    2350297 :   return TYPE_MAIN_VARIANT (type) == TYPE_MAIN_VARIANT (va_list_type_node);</span>
<span class="lineNum">    1949 </span>            : }
<span class="lineNum">    1950 </span>            : 
<span class="lineNum">    1951 </span>            : /* Print message to dump file why a variable was rejected. */
<a name="1952"><span class="lineNum">    1952 </span>            : </a>
<span class="lineNum">    1953 </span>            : static void
<span class="lineNum">    1954 </span><span class="lineCov">    9582722 : reject (tree var, const char *msg)</span>
<span class="lineNum">    1955 </span>            : {
<span class="lineNum">    1956 </span><span class="lineCov">    9582722 :   if (dump_file &amp;&amp; (dump_flags &amp; TDF_DETAILS))</span>
<span class="lineNum">    1957 </span>            :     {
<span class="lineNum">    1958 </span><span class="lineCov">         26 :       fprintf (dump_file, &quot;Rejected (%d): %s: &quot;, DECL_UID (var), msg);</span>
<span class="lineNum">    1959 </span><span class="lineCov">         26 :       print_generic_expr (dump_file, var);</span>
<span class="lineNum">    1960 </span><span class="lineCov">         26 :       fprintf (dump_file, &quot;\n&quot;);</span>
<span class="lineNum">    1961 </span>            :     }
<span class="lineNum">    1962 </span><span class="lineCov">    9582722 : }</span>
<span class="lineNum">    1963 </span>            : 
<span class="lineNum">    1964 </span>            : /* Return true if VAR is a candidate for SRA.  */
<a name="1965"><span class="lineNum">    1965 </span>            : </a>
<span class="lineNum">    1966 </span>            : static bool
<span class="lineNum">    1967 </span><span class="lineCov">   12018744 : maybe_add_sra_candidate (tree var)</span>
<span class="lineNum">    1968 </span>            : {
<span class="lineNum">    1969 </span><span class="lineCov">   12018744 :   tree type = TREE_TYPE (var);</span>
<span class="lineNum">    1970 </span><span class="lineCov">   12018744 :   const char *msg;</span>
<span class="lineNum">    1971 </span><span class="lineCov">   12018744 :   tree_node **slot;</span>
<span class="lineNum">    1972 </span>            : 
<span class="lineNum">    1973 </span><span class="lineCov">   12018744 :   if (!AGGREGATE_TYPE_P (type)) </span>
<span class="lineNum">    1974 </span>            :     {
<span class="lineNum">    1975 </span><span class="lineCov">    8535575 :       reject (var, &quot;not aggregate&quot;);</span>
<span class="lineNum">    1976 </span><span class="lineCov">    8535575 :       return false;</span>
<span class="lineNum">    1977 </span>            :     }
<span class="lineNum">    1978 </span>            :   /* Allow constant-pool entries (that &quot;need to live in memory&quot;)
<span class="lineNum">    1979 </span>            :      unless we are doing IPA SRA.  */
<span class="lineNum">    1980 </span><span class="lineCov">    3483169 :   if (needs_to_live_in_memory (var)</span>
<span class="lineNum">    1981 </span><span class="lineCov">    3483169 :       &amp;&amp; (sra_mode == SRA_MODE_EARLY_IPA || !constant_decl_p (var)))</span>
<span class="lineNum">    1982 </span>            :     {
<span class="lineNum">    1983 </span><span class="lineCov">    1046143 :       reject (var, &quot;needs to live in memory&quot;);</span>
<span class="lineNum">    1984 </span><span class="lineCov">    1046143 :       return false;</span>
<span class="lineNum">    1985 </span>            :     }
<span class="lineNum">    1986 </span><span class="lineCov">    2437026 :   if (TREE_THIS_VOLATILE (var))</span>
<span class="lineNum">    1987 </span>            :     {
<span class="lineNum">    1988 </span><span class="lineCov">        417 :       reject (var, &quot;is volatile&quot;);</span>
<span class="lineNum">    1989 </span><span class="lineCov">        417 :       return false;</span>
<span class="lineNum">    1990 </span>            :     }
<span class="lineNum">    1991 </span><span class="lineCov">    2436609 :   if (!COMPLETE_TYPE_P (type))</span>
<span class="lineNum">    1992 </span>            :     {
<span class="lineNum">    1993 </span><span class="lineNoCov">          0 :       reject (var, &quot;has incomplete type&quot;);</span>
<span class="lineNum">    1994 </span><span class="lineNoCov">          0 :       return false;</span>
<span class="lineNum">    1995 </span>            :     }
<span class="lineNum">    1996 </span><span class="lineCov">    4873218 :   if (!tree_fits_uhwi_p (TYPE_SIZE (type)))</span>
<span class="lineNum">    1997 </span>            :     {
<span class="lineNum">    1998 </span><span class="lineCov">         35 :       reject (var, &quot;type size not fixed&quot;);</span>
<span class="lineNum">    1999 </span><span class="lineCov">         35 :       return false;</span>
<span class="lineNum">    2000 </span>            :     }
<span class="lineNum">    2001 </span><span class="lineCov">    4873148 :   if (tree_to_uhwi (TYPE_SIZE (type)) == 0)</span>
<span class="lineNum">    2002 </span>            :     {
<span class="lineNum">    2003 </span><span class="lineCov">        358 :       reject (var, &quot;type size is zero&quot;);</span>
<span class="lineNum">    2004 </span><span class="lineCov">        358 :       return false;</span>
<span class="lineNum">    2005 </span>            :     }
<span class="lineNum">    2006 </span><span class="lineCov">    2436216 :   if (type_internals_preclude_sra_p (type, &amp;msg))</span>
<span class="lineNum">    2007 </span>            :     {
<span class="lineNum">    2008 </span><span class="lineCov">        194 :       reject (var, msg);</span>
<span class="lineNum">    2009 </span><span class="lineCov">        194 :       return false;</span>
<span class="lineNum">    2010 </span>            :     }
<span class="lineNum">    2011 </span><span class="lineCov">    2436022 :   if (/* Fix for PR 41089.  tree-stdarg.c needs to have va_lists intact but</span>
<span class="lineNum">    2012 </span>            :          we also want to schedule it rather late.  Thus we ignore it in
<span class="lineNum">    2013 </span>            :          the early pass. */
<span class="lineNum">    2014 </span><span class="lineCov">    2436022 :       (sra_mode == SRA_MODE_EARLY_INTRA</span>
<span class="lineNum">    2015 </span><span class="lineCov">    2436022 :        &amp;&amp; is_va_list_type (type)))</span>
<span class="lineNum">    2016 </span>            :     {
<span class="lineNum">    2017 </span><span class="lineNoCov">          0 :       reject (var, &quot;is va_list&quot;);</span>
<span class="lineNum">    2018 </span><span class="lineNoCov">          0 :       return false;</span>
<span class="lineNum">    2019 </span>            :     }
<span class="lineNum">    2020 </span>            : 
<span class="lineNum">    2021 </span><span class="lineCov">    2436022 :   bitmap_set_bit (candidate_bitmap, DECL_UID (var));</span>
<span class="lineNum">    2022 </span><span class="lineCov">    2436022 :   slot = candidates-&gt;find_slot_with_hash (var, DECL_UID (var), INSERT);</span>
<span class="lineNum">    2023 </span><span class="lineCov">    2436022 :   *slot = var;</span>
<span class="lineNum">    2024 </span>            : 
<span class="lineNum">    2025 </span><span class="lineCov">    2436022 :   if (dump_file &amp;&amp; (dump_flags &amp; TDF_DETAILS))</span>
<span class="lineNum">    2026 </span>            :     {
<span class="lineNum">    2027 </span><span class="lineCov">         12 :       fprintf (dump_file, &quot;Candidate (%d): &quot;, DECL_UID (var));</span>
<span class="lineNum">    2028 </span><span class="lineCov">         12 :       print_generic_expr (dump_file, var);</span>
<span class="lineNum">    2029 </span><span class="lineCov">         12 :       fprintf (dump_file, &quot;\n&quot;);</span>
<span class="lineNum">    2030 </span>            :     }
<span class="lineNum">    2031 </span>            : 
<span class="lineNum">    2032 </span>            :   return true;
<span class="lineNum">    2033 </span>            : }
<span class="lineNum">    2034 </span>            : 
<span class="lineNum">    2035 </span>            : /* The very first phase of intraprocedural SRA.  It marks in candidate_bitmap
<span class="lineNum">    2036 </span>            :    those with type which is suitable for scalarization.  */
<a name="2037"><span class="lineNum">    2037 </span>            : </a>
<span class="lineNum">    2038 </span>            : static bool
<span class="lineNum">    2039 </span><span class="lineCov">    2027696 : find_var_candidates (void)</span>
<span class="lineNum">    2040 </span>            : {
<span class="lineNum">    2041 </span><span class="lineCov">    2027696 :   tree var, parm;</span>
<span class="lineNum">    2042 </span><span class="lineCov">    2027696 :   unsigned int i;</span>
<span class="lineNum">    2043 </span><span class="lineCov">    2027696 :   bool ret = false;</span>
<span class="lineNum">    2044 </span>            : 
<span class="lineNum">    2045 </span><span class="lineCov">    2027696 :   for (parm = DECL_ARGUMENTS (current_function_decl);</span>
<span class="lineNum">    2046 </span><span class="lineCov">    6459766 :        parm;</span>
<span class="lineNum">    2047 </span><span class="lineCov">    4432070 :        parm = DECL_CHAIN (parm))</span>
<span class="lineNum">    2048 </span><span class="lineCov">    4432070 :     ret |= maybe_add_sra_candidate (parm);</span>
<span class="lineNum">    2049 </span>            : 
<span class="lineNum">    2050 </span><span class="lineCov">   11362591 :   FOR_EACH_LOCAL_DECL (cfun, i, var)</span>
<span class="lineNum">    2051 </span>            :     {
<span class="lineNum">    2052 </span><span class="lineCov">    7584830 :       if (!VAR_P (var))</span>
<span class="lineNum">    2053 </span>            :         continue;
<span class="lineNum">    2054 </span>            : 
<span class="lineNum">    2055 </span><span class="lineCov">    7584830 :       ret |= maybe_add_sra_candidate (var);</span>
<span class="lineNum">    2056 </span>            :     }
<span class="lineNum">    2057 </span>            : 
<span class="lineNum">    2058 </span><span class="lineCov">    2027696 :   return ret;</span>
<span class="lineNum">    2059 </span>            : }
<span class="lineNum">    2060 </span>            : 
<span class="lineNum">    2061 </span>            : /* Sort all accesses for the given variable, check for partial overlaps and
<span class="lineNum">    2062 </span>            :    return NULL if there are any.  If there are none, pick a representative for
<span class="lineNum">    2063 </span>            :    each combination of offset and size and create a linked list out of them.
<span class="lineNum">    2064 </span>            :    Return the pointer to the first representative and make sure it is the first
<span class="lineNum">    2065 </span>            :    one in the vector of accesses.  */
<a name="2066"><span class="lineNum">    2066 </span>            : </a>
<span class="lineNum">    2067 </span>            : static struct access *
<span class="lineNum">    2068 </span><span class="lineCov">    2379485 : sort_and_splice_var_accesses (tree var)</span>
<span class="lineNum">    2069 </span>            : {
<span class="lineNum">    2070 </span><span class="lineCov">    2379485 :   int i, j, access_count;</span>
<span class="lineNum">    2071 </span><span class="lineCov">    2379485 :   struct access *res, **prev_acc_ptr = &amp;res;</span>
<span class="lineNum">    2072 </span><span class="lineCov">    2379485 :   vec&lt;access_p&gt; *access_vec;</span>
<span class="lineNum">    2073 </span><span class="lineCov">    2379485 :   bool first = true;</span>
<span class="lineNum">    2074 </span><span class="lineCov">    2379485 :   HOST_WIDE_INT low = -1, high = 0;</span>
<span class="lineNum">    2075 </span>            : 
<span class="lineNum">    2076 </span><span class="lineCov">    2379485 :   access_vec = get_base_access_vector (var);</span>
<span class="lineNum">    2077 </span><span class="lineCov">    2379485 :   if (!access_vec)</span>
<span class="lineNum">    2078 </span><span class="lineCov">      89239 :     return NULL;</span>
<span class="lineNum">    2079 </span><span class="lineCov">    2290246 :   access_count = access_vec-&gt;length ();</span>
<span class="lineNum">    2080 </span>            : 
<span class="lineNum">    2081 </span>            :   /* Sort by &lt;OFFSET, SIZE&gt;.  */
<span class="lineNum">    2082 </span><span class="lineCov">    2290246 :   access_vec-&gt;qsort (compare_access_positions);</span>
<span class="lineNum">    2083 </span>            : 
<span class="lineNum">    2084 </span>            :   i = 0;
<span class="lineNum">    2085 </span><span class="lineCov">    8283010 :   while (i &lt; access_count)</span>
<span class="lineNum">    2086 </span>            :     {
<span class="lineNum">    2087 </span><span class="lineCov">    5993237 :       struct access *access = (*access_vec)[i];</span>
<span class="lineNum">    2088 </span><span class="lineCov">    5993237 :       bool grp_write = access-&gt;write;</span>
<span class="lineNum">    2089 </span><span class="lineCov">    5993237 :       bool grp_read = !access-&gt;write;</span>
<span class="lineNum">    2090 </span><span class="lineCov">    5993237 :       bool grp_scalar_write = access-&gt;write</span>
<span class="lineNum">    2091 </span><span class="lineCov">    5993237 :         &amp;&amp; is_gimple_reg_type (access-&gt;type);</span>
<span class="lineNum">    2092 </span><span class="lineCov">    5993237 :       bool grp_scalar_read = !access-&gt;write</span>
<span class="lineNum">    2093 </span><span class="lineCov">    5993237 :         &amp;&amp; is_gimple_reg_type (access-&gt;type);</span>
<span class="lineNum">    2094 </span><span class="lineCov">    5993237 :       bool grp_assignment_read = access-&gt;grp_assignment_read;</span>
<span class="lineNum">    2095 </span><span class="lineCov">    5993237 :       bool grp_assignment_write = access-&gt;grp_assignment_write;</span>
<span class="lineNum">    2096 </span><span class="lineCov">    5993237 :       bool multiple_scalar_reads = false;</span>
<span class="lineNum">    2097 </span><span class="lineCov">    5993237 :       bool total_scalarization = access-&gt;grp_total_scalarization;</span>
<span class="lineNum">    2098 </span><span class="lineCov">    5993237 :       bool grp_partial_lhs = access-&gt;grp_partial_lhs;</span>
<span class="lineNum">    2099 </span><span class="lineCov">    5993237 :       bool first_scalar = is_gimple_reg_type (access-&gt;type);</span>
<span class="lineNum">    2100 </span><span class="lineCov">    5993237 :       bool unscalarizable_region = access-&gt;grp_unscalarizable_region;</span>
<span class="lineNum">    2101 </span><span class="lineCov">    5993237 :       bool bf_non_full_precision</span>
<span class="lineNum">    2102 </span><span class="lineCov">    5993237 :         = (INTEGRAL_TYPE_P (access-&gt;type)</span>
<span class="lineNum">    2103 </span><span class="lineCov">    1754232 :            &amp;&amp; TYPE_PRECISION (access-&gt;type) != access-&gt;size</span>
<span class="lineNum">    2104 </span><span class="lineCov">     105728 :            &amp;&amp; TREE_CODE (access-&gt;expr) == COMPONENT_REF</span>
<span class="lineNum">    2105 </span><span class="lineCov">    6035622 :            &amp;&amp; DECL_BIT_FIELD (TREE_OPERAND (access-&gt;expr, 1)));</span>
<span class="lineNum">    2106 </span>            : 
<span class="lineNum">    2107 </span><span class="lineCov">    5993237 :       if (first || access-&gt;offset &gt;= high)</span>
<span class="lineNum">    2108 </span>            :         {
<span class="lineNum">    2109 </span><span class="lineCov">    2474611 :           first = false;</span>
<span class="lineNum">    2110 </span><span class="lineCov">    2474611 :           low = access-&gt;offset;</span>
<span class="lineNum">    2111 </span><span class="lineCov">    2474611 :           high = access-&gt;offset + access-&gt;size;</span>
<span class="lineNum">    2112 </span>            :         }
<span class="lineNum">    2113 </span><span class="lineCov">    3518626 :       else if (access-&gt;offset &gt; low &amp;&amp; access-&gt;offset + access-&gt;size &gt; high)</span>
<span class="lineNum">    2114 </span>            :         return NULL;
<span class="lineNum">    2115 </span>            :       else
<span class="lineNum">    2116 </span><span class="lineCov">    3518153 :         gcc_assert (access-&gt;offset &gt;= low</span>
<span class="lineNum">    2117 </span>            :                     &amp;&amp; access-&gt;offset + access-&gt;size &lt;= high);
<span class="lineNum">    2118 </span>            : 
<span class="lineNum">    2119 </span><span class="lineCov">    5992764 :       j = i + 1;</span>
<span class="lineNum">    2120 </span><span class="lineCov">    9664898 :       while (j &lt; access_count)</span>
<span class="lineNum">    2121 </span>            :         {
<span class="lineNum">    2122 </span><span class="lineCov">    7375125 :           struct access *ac2 = (*access_vec)[j];</span>
<span class="lineNum">    2123 </span><span class="lineCov">    7375125 :           if (ac2-&gt;offset != access-&gt;offset || ac2-&gt;size != access-&gt;size)</span>
<span class="lineNum">    2124 </span>            :             break;
<span class="lineNum">    2125 </span><span class="lineCov">    3672134 :           if (ac2-&gt;write)</span>
<span class="lineNum">    2126 </span>            :             {
<span class="lineNum">    2127 </span><span class="lineCov">     379080 :               grp_write = true;</span>
<span class="lineNum">    2128 </span><span class="lineCov">     379080 :               grp_scalar_write = (grp_scalar_write</span>
<span class="lineNum">    2129 </span><span class="lineCov">     379080 :                                   || is_gimple_reg_type (ac2-&gt;type));</span>
<span class="lineNum">    2130 </span>            :             }
<span class="lineNum">    2131 </span>            :           else
<span class="lineNum">    2132 </span>            :             {
<span class="lineNum">    2133 </span><span class="lineCov">    3293054 :               grp_read = true;</span>
<span class="lineNum">    2134 </span><span class="lineCov">    6586108 :               if (is_gimple_reg_type (ac2-&gt;type))</span>
<span class="lineNum">    2135 </span>            :                 {
<span class="lineNum">    2136 </span><span class="lineCov">    1319781 :                   if (grp_scalar_read)</span>
<span class="lineNum">    2137 </span>            :                     multiple_scalar_reads = true;
<span class="lineNum">    2138 </span>            :                   else
<span class="lineNum">    2139 </span><span class="lineCov">     668302 :                     grp_scalar_read = true;</span>
<span class="lineNum">    2140 </span>            :                 }
<span class="lineNum">    2141 </span>            :             }
<span class="lineNum">    2142 </span><span class="lineCov">    3672134 :           grp_assignment_read |= ac2-&gt;grp_assignment_read;</span>
<span class="lineNum">    2143 </span><span class="lineCov">    3672134 :           grp_assignment_write |= ac2-&gt;grp_assignment_write;</span>
<span class="lineNum">    2144 </span><span class="lineCov">    3672134 :           grp_partial_lhs |= ac2-&gt;grp_partial_lhs;</span>
<span class="lineNum">    2145 </span><span class="lineCov">    3672134 :           unscalarizable_region |= ac2-&gt;grp_unscalarizable_region;</span>
<span class="lineNum">    2146 </span><span class="lineCov">    3672134 :           total_scalarization |= ac2-&gt;grp_total_scalarization;</span>
<span class="lineNum">    2147 </span><span class="lineCov">    3672134 :           relink_to_new_repr (access, ac2);</span>
<span class="lineNum">    2148 </span>            : 
<span class="lineNum">    2149 </span>            :           /* If there are both aggregate-type and scalar-type accesses with
<span class="lineNum">    2150 </span>            :              this combination of size and offset, the comparison function
<span class="lineNum">    2151 </span>            :              should have put the scalars first.  */
<span class="lineNum">    2152 </span><span class="lineCov">    3672134 :           gcc_assert (first_scalar || !is_gimple_reg_type (ac2-&gt;type));</span>
<span class="lineNum">    2153 </span>            :           /* It also prefers integral types to non-integral.  However, when the
<span class="lineNum">    2154 </span>            :              precision of the selected type does not span the entire area and
<span class="lineNum">    2155 </span>            :              should also be used for a non-integer (i.e. float), we must not
<span class="lineNum">    2156 </span>            :              let that happen.  Normally analyze_access_subtree expands the type
<span class="lineNum">    2157 </span>            :              to cover the entire area but for bit-fields it doesn't.  */
<span class="lineNum">    2158 </span><span class="lineCov">    3672134 :           if (bf_non_full_precision &amp;&amp; !INTEGRAL_TYPE_P (ac2-&gt;type))</span>
<span class="lineNum">    2159 </span>            :             {
<span class="lineNum">    2160 </span><span class="lineNoCov">          0 :               if (dump_file &amp;&amp; (dump_flags &amp; TDF_DETAILS))</span>
<span class="lineNum">    2161 </span>            :                 {
<span class="lineNum">    2162 </span><span class="lineNoCov">          0 :                   fprintf (dump_file, &quot;Cannot scalarize the following access &quot;</span>
<span class="lineNum">    2163 </span>            :                            &quot;because insufficient precision integer type was &quot;
<span class="lineNum">    2164 </span>            :                            &quot;selected.\n  &quot;);
<span class="lineNum">    2165 </span><span class="lineNoCov">          0 :                   dump_access (dump_file, access, false);</span>
<span class="lineNum">    2166 </span>            :                 }
<span class="lineNum">    2167 </span>            :               unscalarizable_region = true;
<span class="lineNum">    2168 </span>            :             }
<span class="lineNum">    2169 </span><span class="lineCov">    3672134 :           ac2-&gt;group_representative = access;</span>
<span class="lineNum">    2170 </span><span class="lineCov">    3672134 :           j++;</span>
<span class="lineNum">    2171 </span>            :         }
<span class="lineNum">    2172 </span>            : 
<span class="lineNum">    2173 </span><span class="lineCov">    5992764 :       i = j;</span>
<span class="lineNum">    2174 </span>            : 
<span class="lineNum">    2175 </span><span class="lineCov">    5992764 :       access-&gt;group_representative = access;</span>
<span class="lineNum">    2176 </span><span class="lineCov">    5992764 :       access-&gt;grp_write = grp_write;</span>
<span class="lineNum">    2177 </span><span class="lineCov">    5992764 :       access-&gt;grp_read = grp_read;</span>
<span class="lineNum">    2178 </span><span class="lineCov">    5992764 :       access-&gt;grp_scalar_read = grp_scalar_read;</span>
<span class="lineNum">    2179 </span><span class="lineCov">    5992764 :       access-&gt;grp_scalar_write = grp_scalar_write;</span>
<span class="lineNum">    2180 </span><span class="lineCov">    5992764 :       access-&gt;grp_assignment_read = grp_assignment_read;</span>
<span class="lineNum">    2181 </span><span class="lineCov">    5992764 :       access-&gt;grp_assignment_write = grp_assignment_write;</span>
<span class="lineNum">    2182 </span><span class="lineCov">   11985528 :       access-&gt;grp_hint = total_scalarization</span>
<span class="lineNum">    2183 </span><span class="lineCov">    5992764 :         || (multiple_scalar_reads &amp;&amp; !constant_decl_p (var));</span>
<span class="lineNum">    2184 </span><span class="lineCov">    5992764 :       access-&gt;grp_total_scalarization = total_scalarization;</span>
<span class="lineNum">    2185 </span><span class="lineCov">    5992764 :       access-&gt;grp_partial_lhs = grp_partial_lhs;</span>
<span class="lineNum">    2186 </span><span class="lineCov">    5992764 :       access-&gt;grp_unscalarizable_region = unscalarizable_region;</span>
<span class="lineNum">    2187 </span>            : 
<span class="lineNum">    2188 </span><span class="lineCov">    5992764 :       *prev_acc_ptr = access;</span>
<span class="lineNum">    2189 </span><span class="lineCov">    5992764 :       prev_acc_ptr = &amp;access-&gt;next_grp;</span>
<span class="lineNum">    2190 </span>            :     }
<span class="lineNum">    2191 </span>            : 
<span class="lineNum">    2192 </span><span class="lineCov">    2289773 :   gcc_assert (res == (*access_vec)[0]);</span>
<span class="lineNum">    2193 </span>            :   return res;
<span class="lineNum">    2194 </span>            : }
<span class="lineNum">    2195 </span>            : 
<span class="lineNum">    2196 </span>            : /* Create a variable for the given ACCESS which determines the type, name and a
<span class="lineNum">    2197 </span>            :    few other properties.  Return the variable declaration and store it also to
<span class="lineNum">    2198 </span>            :    ACCESS-&gt;replacement.  */
<a name="2199"><span class="lineNum">    2199 </span>            : </a>
<span class="lineNum">    2200 </span>            : static tree
<span class="lineNum">    2201 </span><span class="lineCov">    2410884 : create_access_replacement (struct access *access)</span>
<span class="lineNum">    2202 </span>            : {
<span class="lineNum">    2203 </span><span class="lineCov">    2410884 :   tree repl;</span>
<span class="lineNum">    2204 </span>            : 
<span class="lineNum">    2205 </span><span class="lineCov">    2410884 :   if (access-&gt;grp_to_be_debug_replaced)</span>
<span class="lineNum">    2206 </span>            :     {
<span class="lineNum">    2207 </span><span class="lineCov">      79743 :       repl = create_tmp_var_raw (access-&gt;type);</span>
<span class="lineNum">    2208 </span><span class="lineCov">      79743 :       DECL_CONTEXT (repl) = current_function_decl;</span>
<span class="lineNum">    2209 </span>            :     }
<span class="lineNum">    2210 </span>            :   else
<span class="lineNum">    2211 </span>            :     /* Drop any special alignment on the type if it's not on the main
<span class="lineNum">    2212 </span>            :        variant.  This avoids issues with weirdo ABIs like AAPCS.  */
<span class="lineNum">    2213 </span><span class="lineCov">    2331141 :     repl = create_tmp_var (build_qualified_type</span>
<span class="lineNum">    2214 </span><span class="lineCov">    2331141 :                              (TYPE_MAIN_VARIANT (access-&gt;type),</span>
<span class="lineNum">    2215 </span><span class="lineCov">    2331141 :                               TYPE_QUALS (access-&gt;type)), &quot;SR&quot;);</span>
<span class="lineNum">    2216 </span><span class="lineCov">    4821768 :   if (TREE_CODE (access-&gt;type) == COMPLEX_TYPE</span>
<span class="lineNum">    2217 </span><span class="lineCov">    2410884 :       || TREE_CODE (access-&gt;type) == VECTOR_TYPE)</span>
<span class="lineNum">    2218 </span>            :     {
<span class="lineNum">    2219 </span><span class="lineCov">       2293 :       if (!access-&gt;grp_partial_lhs)</span>
<span class="lineNum">    2220 </span><span class="lineCov">       1935 :         DECL_GIMPLE_REG_P (repl) = 1;</span>
<span class="lineNum">    2221 </span>            :     }
<span class="lineNum">    2222 </span><span class="lineCov">    2408591 :   else if (access-&gt;grp_partial_lhs</span>
<span class="lineNum">    2223 </span><span class="lineCov">    2408591 :            &amp;&amp; is_gimple_reg_type (access-&gt;type))</span>
<span class="lineNum">    2224 </span><span class="lineNoCov">          0 :     TREE_ADDRESSABLE (repl) = 1;</span>
<span class="lineNum">    2225 </span>            : 
<span class="lineNum">    2226 </span><span class="lineCov">    2410884 :   DECL_SOURCE_LOCATION (repl) = DECL_SOURCE_LOCATION (access-&gt;base);</span>
<span class="lineNum">    2227 </span><span class="lineCov">    2410884 :   DECL_ARTIFICIAL (repl) = 1;</span>
<span class="lineNum">    2228 </span><span class="lineCov">    2410884 :   DECL_IGNORED_P (repl) = DECL_IGNORED_P (access-&gt;base);</span>
<span class="lineNum">    2229 </span>            : 
<span class="lineNum">    2230 </span><span class="lineCov">    2410884 :   if (DECL_NAME (access-&gt;base)</span>
<span class="lineNum">    2231 </span><span class="lineCov">    1957546 :       &amp;&amp; !DECL_IGNORED_P (access-&gt;base)</span>
<span class="lineNum">    2232 </span><span class="lineCov">    3472852 :       &amp;&amp; !DECL_ARTIFICIAL (access-&gt;base))</span>
<span class="lineNum">    2233 </span>            :     {
<span class="lineNum">    2234 </span><span class="lineCov">     525262 :       char *pretty_name = make_fancy_name (access-&gt;expr);</span>
<span class="lineNum">    2235 </span><span class="lineCov">     525262 :       tree debug_expr = unshare_expr_without_location (access-&gt;expr), d;</span>
<span class="lineNum">    2236 </span><span class="lineCov">     525262 :       bool fail = false;</span>
<span class="lineNum">    2237 </span>            : 
<span class="lineNum">    2238 </span><span class="lineCov">     525262 :       DECL_NAME (repl) = get_identifier (pretty_name);</span>
<span class="lineNum">    2239 </span><span class="lineCov">     525262 :       DECL_NAMELESS (repl) = 1;</span>
<span class="lineNum">    2240 </span><span class="lineCov">     525262 :       obstack_free (&amp;name_obstack, pretty_name);</span>
<span class="lineNum">    2241 </span>            : 
<span class="lineNum">    2242 </span>            :       /* Get rid of any SSA_NAMEs embedded in debug_expr,
<span class="lineNum">    2243 </span>            :          as DECL_DEBUG_EXPR isn't considered when looking for still
<span class="lineNum">    2244 </span>            :          used SSA_NAMEs and thus they could be freed.  All debug info
<span class="lineNum">    2245 </span>            :          generation cares is whether something is constant or variable
<span class="lineNum">    2246 </span>            :          and that get_ref_base_and_extent works properly on the
<span class="lineNum">    2247 </span>            :          expression.  It cannot handle accesses at a non-constant offset
<span class="lineNum">    2248 </span>            :          though, so just give up in those cases.  */
<span class="lineNum">    2249 </span><span class="lineCov">     620987 :       for (d = debug_expr;</span>
<span class="lineNum">    2250 </span><span class="lineCov">    1146249 :            !fail &amp;&amp; (handled_component_p (d) || TREE_CODE (d) == MEM_REF);</span>
<span class="lineNum">    2251 </span><span class="lineCov">     620987 :            d = TREE_OPERAND (d, 0))</span>
<span class="lineNum">    2252 </span><span class="lineCov">     620987 :         switch (TREE_CODE (d))</span>
<span class="lineNum">    2253 </span>            :           {
<span class="lineNum">    2254 </span><span class="lineCov">      29838 :           case ARRAY_REF:</span>
<span class="lineNum">    2255 </span><span class="lineCov">      29838 :           case ARRAY_RANGE_REF:</span>
<span class="lineNum">    2256 </span><span class="lineCov">      29838 :             if (TREE_OPERAND (d, 1)</span>
<span class="lineNum">    2257 </span><span class="lineCov">      29838 :                 &amp;&amp; TREE_CODE (TREE_OPERAND (d, 1)) != INTEGER_CST)</span>
<span class="lineNum">    2258 </span>            :               fail = true;
<span class="lineNum">    2259 </span><span class="lineCov">      29838 :             if (TREE_OPERAND (d, 3)</span>
<span class="lineNum">    2260 </span><span class="lineCov">      29838 :                 &amp;&amp; TREE_CODE (TREE_OPERAND (d, 3)) != INTEGER_CST)</span>
<span class="lineNum">    2261 </span>            :               fail = true;
<span class="lineNum">    2262 </span>            :             /* FALLTHRU */
<span class="lineNum">    2263 </span><span class="lineCov">     461369 :           case COMPONENT_REF:</span>
<span class="lineNum">    2264 </span><span class="lineCov">     461369 :             if (TREE_OPERAND (d, 2)</span>
<span class="lineNum">    2265 </span><span class="lineCov">     461369 :                 &amp;&amp; TREE_CODE (TREE_OPERAND (d, 2)) != INTEGER_CST)</span>
<span class="lineNum">    2266 </span>            :               fail = true;
<span class="lineNum">    2267 </span>            :             break;
<span class="lineNum">    2268 </span><span class="lineCov">     159618 :           case MEM_REF:</span>
<span class="lineNum">    2269 </span><span class="lineCov">     159618 :             if (TREE_CODE (TREE_OPERAND (d, 0)) != ADDR_EXPR)</span>
<span class="lineNum">    2270 </span>            :               fail = true;
<span class="lineNum">    2271 </span>            :             else
<span class="lineNum">    2272 </span><span class="lineCov">     159618 :               d = TREE_OPERAND (d, 0);</span>
<span class="lineNum">    2273 </span>            :             break;
<span class="lineNum">    2274 </span>            :           default:
<span class="lineNum">    2275 </span>            :             break;
<span class="lineNum">    2276 </span>            :           }
<span class="lineNum">    2277 </span><span class="lineCov">     525262 :       if (!fail)</span>
<span class="lineNum">    2278 </span>            :         {
<span class="lineNum">    2279 </span><span class="lineCov">     525203 :           SET_DECL_DEBUG_EXPR (repl, debug_expr);</span>
<span class="lineNum">    2280 </span><span class="lineCov">     525203 :           DECL_HAS_DEBUG_EXPR_P (repl) = 1;</span>
<span class="lineNum">    2281 </span>            :         }
<span class="lineNum">    2282 </span><span class="lineCov">     525262 :       if (access-&gt;grp_no_warning)</span>
<span class="lineNum">    2283 </span><span class="lineCov">         75 :         TREE_NO_WARNING (repl) = 1;</span>
<span class="lineNum">    2284 </span>            :       else
<span class="lineNum">    2285 </span><span class="lineCov">     525187 :         TREE_NO_WARNING (repl) = TREE_NO_WARNING (access-&gt;base);</span>
<span class="lineNum">    2286 </span>            :     }
<span class="lineNum">    2287 </span>            :   else
<span class="lineNum">    2288 </span><span class="lineCov">    1885622 :     TREE_NO_WARNING (repl) = 1;</span>
<span class="lineNum">    2289 </span>            : 
<span class="lineNum">    2290 </span><span class="lineCov">    2410884 :   if (dump_file)</span>
<span class="lineNum">    2291 </span>            :     {
<span class="lineNum">    2292 </span><span class="lineCov">         54 :       if (access-&gt;grp_to_be_debug_replaced)</span>
<span class="lineNum">    2293 </span>            :         {
<span class="lineNum">    2294 </span><span class="lineCov">          4 :           fprintf (dump_file, &quot;Created a debug-only replacement for &quot;);</span>
<span class="lineNum">    2295 </span><span class="lineCov">          4 :           print_generic_expr (dump_file, access-&gt;base);</span>
<span class="lineNum">    2296 </span><span class="lineCov">         12 :           fprintf (dump_file, &quot; offset: %u, size: %u\n&quot;,</span>
<span class="lineNum">    2297 </span><span class="lineCov">          4 :                    (unsigned) access-&gt;offset, (unsigned) access-&gt;size);</span>
<span class="lineNum">    2298 </span>            :         }
<span class="lineNum">    2299 </span>            :       else
<span class="lineNum">    2300 </span>            :         {
<span class="lineNum">    2301 </span><span class="lineCov">         50 :           fprintf (dump_file, &quot;Created a replacement for &quot;);</span>
<span class="lineNum">    2302 </span><span class="lineCov">         50 :           print_generic_expr (dump_file, access-&gt;base);</span>
<span class="lineNum">    2303 </span><span class="lineCov">        150 :           fprintf (dump_file, &quot; offset: %u, size: %u: &quot;,</span>
<span class="lineNum">    2304 </span><span class="lineCov">         50 :                    (unsigned) access-&gt;offset, (unsigned) access-&gt;size);</span>
<span class="lineNum">    2305 </span><span class="lineCov">         50 :           print_generic_expr (dump_file, repl);</span>
<span class="lineNum">    2306 </span><span class="lineCov">         50 :           fprintf (dump_file, &quot;\n&quot;);</span>
<span class="lineNum">    2307 </span>            :         }
<span class="lineNum">    2308 </span>            :     }
<span class="lineNum">    2309 </span><span class="lineCov">    2410884 :   sra_stats.replacements++;</span>
<span class="lineNum">    2310 </span>            : 
<span class="lineNum">    2311 </span><span class="lineCov">    2410884 :   return repl;</span>
<span class="lineNum">    2312 </span>            : }
<span class="lineNum">    2313 </span>            : 
<span class="lineNum">    2314 </span>            : /* Return ACCESS scalar replacement, which must exist.  */
<a name="2315"><span class="lineNum">    2315 </span>            : </a>
<span class="lineNum">    2316 </span>            : static inline tree
<span class="lineNum">    2317 </span><span class="lineNoCov">          0 : get_access_replacement (struct access *access)</span>
<span class="lineNum">    2318 </span>            : {
<span class="lineNum">    2319 </span><span class="lineNoCov">          0 :   gcc_checking_assert (access-&gt;replacement_decl);</span>
<span class="lineNum">    2320 </span><span class="lineCov">    7271191 :   return access-&gt;replacement_decl;</span>
<span class="lineNum">    2321 </span>            : }
<span class="lineNum">    2322 </span>            : 
<span class="lineNum">    2323 </span>            : 
<span class="lineNum">    2324 </span>            : /* Build a subtree of accesses rooted in *ACCESS, and move the pointer in the
<span class="lineNum">    2325 </span>            :    linked list along the way.  Stop when *ACCESS is NULL or the access pointed
<span class="lineNum">    2326 </span>            :    to it is not &quot;within&quot; the root.  Return false iff some accesses partially
<span class="lineNum">    2327 </span>            :    overlap.  */
<a name="2328"><span class="lineNum">    2328 </span>            : </a>
<span class="lineNum">    2329 </span>            : static bool
<span class="lineNum">    2330 </span><span class="lineCov">    5988555 : build_access_subtree (struct access **access)</span>
<span class="lineNum">    2331 </span>            : {
<span class="lineNum">    2332 </span><span class="lineCov">    5988555 :   struct access *root = *access, *last_child = NULL;</span>
<span class="lineNum">    2333 </span><span class="lineCov">    5988555 :   HOST_WIDE_INT limit = root-&gt;offset + root-&gt;size;</span>
<span class="lineNum">    2334 </span>            : 
<span class="lineNum">    2335 </span><span class="lineCov">    5988555 :   *access = (*access)-&gt;next_grp;</span>
<span class="lineNum">    2336 </span><span class="lineCov">    9501923 :   while  (*access &amp;&amp; (*access)-&gt;offset + (*access)-&gt;size &lt;= limit)</span>
<span class="lineNum">    2337 </span>            :     {
<span class="lineNum">    2338 </span><span class="lineCov">    3514426 :       if (!last_child)</span>
<span class="lineNum">    2339 </span><span class="lineCov">    1485630 :         root-&gt;first_child = *access;</span>
<span class="lineNum">    2340 </span>            :       else
<span class="lineNum">    2341 </span><span class="lineCov">    2028796 :         last_child-&gt;next_sibling = *access;</span>
<span class="lineNum">    2342 </span><span class="lineCov">    3514426 :       last_child = *access;</span>
<span class="lineNum">    2343 </span><span class="lineCov">    3514426 :       (*access)-&gt;parent = root;</span>
<span class="lineNum">    2344 </span><span class="lineCov">    3514426 :       (*access)-&gt;grp_write |= root-&gt;grp_write;</span>
<span class="lineNum">    2345 </span>            : 
<span class="lineNum">    2346 </span><span class="lineCov">    3514426 :       if (!build_access_subtree (access))</span>
<span class="lineNum">    2347 </span>            :         return false;
<span class="lineNum">    2348 </span>            :     }
<span class="lineNum">    2349 </span>            : 
<span class="lineNum">    2350 </span><span class="lineCov">    5987497 :   if (*access &amp;&amp; (*access)-&gt;offset &lt; limit)</span>
<span class="lineNum">    2351 </span><span class="lineCov">        979 :     return false;</span>
<span class="lineNum">    2352 </span>            : 
<span class="lineNum">    2353 </span>            :   return true;
<span class="lineNum">    2354 </span>            : }
<span class="lineNum">    2355 </span>            : 
<span class="lineNum">    2356 </span>            : /* Build a tree of access representatives, ACCESS is the pointer to the first
<span class="lineNum">    2357 </span>            :    one, others are linked in a list by the next_grp field.  Return false iff
<span class="lineNum">    2358 </span>            :    some accesses partially overlap.  */
<a name="2359"><span class="lineNum">    2359 </span>            : </a>
<span class="lineNum">    2360 </span>            : static bool
<span class="lineNum">    2361 </span><span class="lineNoCov">          0 : build_access_trees (struct access *access)</span>
<span class="lineNum">    2362 </span>            : {
<span class="lineNum">    2363 </span><span class="lineCov">    4762923 :   while (access)</span>
<span class="lineNum">    2364 </span>            :     {
<span class="lineNum">    2365 </span><span class="lineCov">    2474129 :       struct access *root = access;</span>
<span class="lineNum">    2366 </span>            : 
<span class="lineNum">    2367 </span><span class="lineCov">    2474129 :       if (!build_access_subtree (&amp;access))</span>
<span class="lineNum">    2368 </span>            :         return false;
<span class="lineNum">    2369 </span><span class="lineCov">    2473150 :       root-&gt;next_grp = access;</span>
<span class="lineNum">    2370 </span>            :     }
<span class="lineNum">    2371 </span>            :   return true;
<span class="lineNum">    2372 </span>            : }
<span class="lineNum">    2373 </span>            : 
<span class="lineNum">    2374 </span>            : /* Return true if expr contains some ARRAY_REFs into a variable bounded
<span class="lineNum">    2375 </span>            :    array.  */
<a name="2376"><span class="lineNum">    2376 </span>            : </a>
<span class="lineNum">    2377 </span>            : static bool
<span class="lineNum">    2378 </span><span class="lineCov">    6013105 : expr_with_var_bounded_array_refs_p (tree expr)</span>
<span class="lineNum">    2379 </span>            : {
<span class="lineNum">    2380 </span><span class="lineCov">   10246663 :   while (handled_component_p (expr))</span>
<span class="lineNum">    2381 </span>            :     {
<span class="lineNum">    2382 </span><span class="lineCov">    4233558 :       if (TREE_CODE (expr) == ARRAY_REF</span>
<span class="lineNum">    2383 </span><span class="lineCov">    4233558 :           &amp;&amp; !tree_fits_shwi_p (array_ref_low_bound (expr)))</span>
<span class="lineNum">    2384 </span>            :         return true;
<span class="lineNum">    2385 </span><span class="lineCov">    4233558 :       expr = TREE_OPERAND (expr, 0);</span>
<span class="lineNum">    2386 </span>            :     }
<span class="lineNum">    2387 </span>            :   return false;
<span class="lineNum">    2388 </span>            : }
<span class="lineNum">    2389 </span>            : 
<span class="lineNum">    2390 </span>            : /* Analyze the subtree of accesses rooted in ROOT, scheduling replacements when
<span class="lineNum">    2391 </span>            :    both seeming beneficial and when ALLOW_REPLACEMENTS allows it.  Also set all
<span class="lineNum">    2392 </span>            :    sorts of access flags appropriately along the way, notably always set
<span class="lineNum">    2393 </span>            :    grp_read and grp_assign_read according to MARK_READ and grp_write when
<span class="lineNum">    2394 </span>            :    MARK_WRITE is true.
<span class="lineNum">    2395 </span>            : 
<span class="lineNum">    2396 </span>            :    Creating a replacement for a scalar access is considered beneficial if its
<span class="lineNum">    2397 </span>            :    grp_hint is set (this means we are either attempting total scalarization or
<span class="lineNum">    2398 </span>            :    there is more than one direct read access) or according to the following
<span class="lineNum">    2399 </span>            :    table:
<span class="lineNum">    2400 </span>            : 
<span class="lineNum">    2401 </span>            :    Access written to through a scalar type (once or more times)
<span class="lineNum">    2402 </span>            :    |
<span class="lineNum">    2403 </span>            :    |    Written to in an assignment statement
<span class="lineNum">    2404 </span>            :    |    |
<span class="lineNum">    2405 </span>            :    |    |       Access read as scalar _once_
<span class="lineNum">    2406 </span>            :    |    |       |
<span class="lineNum">    2407 </span>            :    |    |       |       Read in an assignment statement
<span class="lineNum">    2408 </span>            :    |    |       |       |
<span class="lineNum">    2409 </span>            :    |    |       |       |       Scalarize       Comment
<span class="lineNum">    2410 </span>            : -----------------------------------------------------------------------------
<span class="lineNum">    2411 </span>            :    0    0       0       0                       No access for the scalar
<span class="lineNum">    2412 </span>            :    0    0       0       1                       No access for the scalar
<span class="lineNum">    2413 </span>            :    0    0       1       0       No              Single read - won't help
<span class="lineNum">    2414 </span>            :    0    0       1       1       No              The same case
<span class="lineNum">    2415 </span>            :    0    1       0       0                       No access for the scalar
<span class="lineNum">    2416 </span>            :    0    1       0       1                       No access for the scalar
<span class="lineNum">    2417 </span>            :    0    1       1       0       Yes             s = *g; return s.i;
<span class="lineNum">    2418 </span>            :    0    1       1       1       Yes             The same case as above
<span class="lineNum">    2419 </span>            :    1    0       0       0       No              Won't help
<span class="lineNum">    2420 </span>            :    1    0       0       1       Yes             s.i = 1; *g = s;
<span class="lineNum">    2421 </span>            :    1    0       1       0       Yes             s.i = 5; g = s.i;
<span class="lineNum">    2422 </span>            :    1    0       1       1       Yes             The same case as above
<span class="lineNum">    2423 </span>            :    1    1       0       0       No              Won't help.
<span class="lineNum">    2424 </span>            :    1    1       0       1       Yes             s.i = 1; *g = s;
<span class="lineNum">    2425 </span>            :    1    1       1       0       Yes             s = *g; return s.i;
<span class="lineNum">    2426 </span>            :    1    1       1       1       Yes             Any of the above yeses  */
<a name="2427"><span class="lineNum">    2427 </span>            : </a>
<span class="lineNum">    2428 </span>            : static bool
<span class="lineNum">    2429 </span><span class="lineCov">    6166804 : analyze_access_subtree (struct access *root, struct access *parent,</span>
<span class="lineNum">    2430 </span>            :                         bool allow_replacements)
<span class="lineNum">    2431 </span>            : {
<span class="lineNum">    2432 </span><span class="lineCov">    6166804 :   struct access *child;</span>
<span class="lineNum">    2433 </span><span class="lineCov">    6166804 :   HOST_WIDE_INT limit = root-&gt;offset + root-&gt;size;</span>
<span class="lineNum">    2434 </span><span class="lineCov">    6166804 :   HOST_WIDE_INT covered_to = root-&gt;offset;</span>
<span class="lineNum">    2435 </span><span class="lineCov">    6166804 :   bool scalar = is_gimple_reg_type (root-&gt;type);</span>
<span class="lineNum">    2436 </span><span class="lineCov">    6166804 :   bool hole = false, sth_created = false;</span>
<span class="lineNum">    2437 </span>            : 
<span class="lineNum">    2438 </span><span class="lineCov">    6166804 :   if (parent)</span>
<span class="lineNum">    2439 </span>            :     {
<span class="lineNum">    2440 </span><span class="lineCov">    3693654 :       if (parent-&gt;grp_read)</span>
<span class="lineNum">    2441 </span><span class="lineCov">    3175258 :         root-&gt;grp_read = 1;</span>
<span class="lineNum">    2442 </span><span class="lineCov">    3693654 :       if (parent-&gt;grp_assignment_read)</span>
<span class="lineNum">    2443 </span><span class="lineCov">    1696598 :         root-&gt;grp_assignment_read = 1;</span>
<span class="lineNum">    2444 </span><span class="lineCov">    3693654 :       if (parent-&gt;grp_write)</span>
<span class="lineNum">    2445 </span><span class="lineCov">    1720006 :         root-&gt;grp_write = 1;</span>
<span class="lineNum">    2446 </span><span class="lineCov">    3693654 :       if (parent-&gt;grp_assignment_write)</span>
<span class="lineNum">    2447 </span><span class="lineCov">    1852469 :         root-&gt;grp_assignment_write = 1;</span>
<span class="lineNum">    2448 </span><span class="lineCov">    3693654 :       if (parent-&gt;grp_total_scalarization)</span>
<span class="lineNum">    2449 </span><span class="lineCov">    1548090 :         root-&gt;grp_total_scalarization = 1;</span>
<span class="lineNum">    2450 </span>            :     }
<span class="lineNum">    2451 </span>            : 
<span class="lineNum">    2452 </span><span class="lineCov">    6166804 :   if (root-&gt;grp_unscalarizable_region)</span>
<span class="lineNum">    2453 </span>            :     allow_replacements = false;
<span class="lineNum">    2454 </span>            : 
<span class="lineNum">    2455 </span><span class="lineCov">    6095372 :   if (allow_replacements &amp;&amp; expr_with_var_bounded_array_refs_p (root-&gt;expr))</span>
<span class="lineNum">    2456 </span>            :     allow_replacements = false;
<span class="lineNum">    2457 </span>            : 
<span class="lineNum">    2458 </span><span class="lineCov">    9860458 :   for (child = root-&gt;first_child; child; child = child-&gt;next_sibling)</span>
<span class="lineNum">    2459 </span>            :     {
<span class="lineNum">    2460 </span><span class="lineCov">    3693654 :       hole |= covered_to &lt; child-&gt;offset;</span>
<span class="lineNum">    2461 </span><span class="lineCov">   11080962 :       sth_created |= analyze_access_subtree (child, root,</span>
<span class="lineNum">    2462 </span><span class="lineCov">    3693654 :                                              allow_replacements &amp;&amp; !scalar);</span>
<span class="lineNum">    2463 </span>            : 
<span class="lineNum">    2464 </span><span class="lineCov">    3693654 :       root-&gt;grp_unscalarized_data |= child-&gt;grp_unscalarized_data;</span>
<span class="lineNum">    2465 </span><span class="lineCov">    3693654 :       root-&gt;grp_total_scalarization &amp;= child-&gt;grp_total_scalarization;</span>
<span class="lineNum">    2466 </span><span class="lineCov">    3693654 :       if (child-&gt;grp_covered)</span>
<span class="lineNum">    2467 </span><span class="lineCov">    2151137 :         covered_to += child-&gt;size;</span>
<span class="lineNum">    2468 </span>            :       else
<span class="lineNum">    2469 </span>            :         hole = true;
<span class="lineNum">    2470 </span>            :     }
<span class="lineNum">    2471 </span>            : 
<span class="lineNum">    2472 </span><span class="lineCov">    6166804 :   if (allow_replacements &amp;&amp; scalar &amp;&amp; !root-&gt;first_child</span>
<span class="lineNum">    2473 </span><span class="lineCov">    3961198 :       &amp;&amp; (root-&gt;grp_hint</span>
<span class="lineNum">    2474 </span><span class="lineCov">    2142494 :           || ((root-&gt;grp_scalar_read || root-&gt;grp_assignment_read)</span>
<span class="lineNum">    2475 </span><span class="lineCov">    4681542 :               &amp;&amp; (root-&gt;grp_scalar_write || root-&gt;grp_assignment_write))))</span>
<span class="lineNum">    2476 </span>            :     {
<span class="lineNum">    2477 </span>            :       /* Always create access replacements that cover the whole access.
<span class="lineNum">    2478 </span>            :          For integral types this means the precision has to match.
<span class="lineNum">    2479 </span>            :          Avoid assumptions based on the integral type kind, too.  */
<span class="lineNum">    2480 </span><span class="lineCov">    2330708 :       if (INTEGRAL_TYPE_P (root-&gt;type)</span>
<span class="lineNum">    2481 </span><span class="lineCov">     918470 :           &amp;&amp; (TREE_CODE (root-&gt;type) != INTEGER_TYPE</span>
<span class="lineNum">    2482 </span><span class="lineCov">     877808 :               || TYPE_PRECISION (root-&gt;type) != root-&gt;size)</span>
<span class="lineNum">    2483 </span>            :           /* But leave bitfield accesses alone.  */
<span class="lineNum">    2484 </span><span class="lineCov">    2371370 :           &amp;&amp; (TREE_CODE (root-&gt;expr) != COMPONENT_REF</span>
<span class="lineNum">    2485 </span><span class="lineCov">      39936 :               || !DECL_BIT_FIELD (TREE_OPERAND (root-&gt;expr, 1))))</span>
<span class="lineNum">    2486 </span>            :         {
<span class="lineNum">    2487 </span><span class="lineCov">      40547 :           tree rt = root-&gt;type;</span>
<span class="lineNum">    2488 </span><span class="lineCov">      40547 :           gcc_assert ((root-&gt;offset % BITS_PER_UNIT) == 0</span>
<span class="lineNum">    2489 </span>            :                       &amp;&amp; (root-&gt;size % BITS_PER_UNIT) == 0);
<span class="lineNum">    2490 </span><span class="lineCov">     121641 :           root-&gt;type = build_nonstandard_integer_type (root-&gt;size,</span>
<span class="lineNum">    2491 </span><span class="lineCov">      40547 :                                                        TYPE_UNSIGNED (rt));</span>
<span class="lineNum">    2492 </span><span class="lineCov">      40547 :           root-&gt;expr = build_ref_for_offset (UNKNOWN_LOCATION, root-&gt;base,</span>
<span class="lineNum">    2493 </span><span class="lineCov">      40547 :                                              root-&gt;offset, root-&gt;reverse,</span>
<span class="lineNum">    2494 </span><span class="lineCov">      40547 :                                              root-&gt;type, NULL, false);</span>
<span class="lineNum">    2495 </span>            : 
<span class="lineNum">    2496 </span><span class="lineCov">      40547 :           if (dump_file &amp;&amp; (dump_flags &amp; TDF_DETAILS))</span>
<span class="lineNum">    2497 </span>            :             {
<span class="lineNum">    2498 </span><span class="lineNoCov">          0 :               fprintf (dump_file, &quot;Changing the type of a replacement for &quot;);</span>
<span class="lineNum">    2499 </span><span class="lineNoCov">          0 :               print_generic_expr (dump_file, root-&gt;base);</span>
<span class="lineNum">    2500 </span><span class="lineNoCov">          0 :               fprintf (dump_file, &quot; offset: %u, size: %u &quot;,</span>
<span class="lineNum">    2501 </span><span class="lineNoCov">          0 :                        (unsigned) root-&gt;offset, (unsigned) root-&gt;size);</span>
<span class="lineNum">    2502 </span><span class="lineNoCov">          0 :               fprintf (dump_file, &quot; to an integer.\n&quot;);</span>
<span class="lineNum">    2503 </span>            :             }
<span class="lineNum">    2504 </span>            :         }
<span class="lineNum">    2505 </span>            : 
<span class="lineNum">    2506 </span><span class="lineCov">    2330708 :       root-&gt;grp_to_be_replaced = 1;</span>
<span class="lineNum">    2507 </span><span class="lineCov">    2330708 :       root-&gt;replacement_decl = create_access_replacement (root);</span>
<span class="lineNum">    2508 </span><span class="lineCov">    2330708 :       sth_created = true;</span>
<span class="lineNum">    2509 </span><span class="lineCov">    2330708 :       hole = false;</span>
<span class="lineNum">    2510 </span>            :     }
<span class="lineNum">    2511 </span>            :   else
<span class="lineNum">    2512 </span>            :     {
<span class="lineNum">    2513 </span><span class="lineCov">    3836096 :       if (allow_replacements</span>
<span class="lineNum">    2514 </span><span class="lineCov">    1634765 :           &amp;&amp; scalar &amp;&amp; !root-&gt;first_child</span>
<span class="lineNum">    2515 </span><span class="lineCov">    1630490 :           &amp;&amp; (root-&gt;grp_scalar_write || root-&gt;grp_assignment_write)</span>
<span class="lineNum">    2516 </span><span class="lineCov">    5258246 :           &amp;&amp; !bitmap_bit_p (cannot_scalarize_away_bitmap,</span>
<span class="lineNum">    2517 </span><span class="lineCov">    1422150 :                             DECL_UID (root-&gt;base)))</span>
<span class="lineNum">    2518 </span>            :         {
<span class="lineNum">    2519 </span><span class="lineCov">     186371 :           gcc_checking_assert (!root-&gt;grp_scalar_read</span>
<span class="lineNum">    2520 </span>            :                                &amp;&amp; !root-&gt;grp_assignment_read);
<span class="lineNum">    2521 </span><span class="lineCov">     186371 :           sth_created = true;</span>
<span class="lineNum">    2522 </span><span class="lineCov">     186371 :           if (MAY_HAVE_DEBUG_BIND_STMTS)</span>
<span class="lineNum">    2523 </span>            :             {
<span class="lineNum">    2524 </span><span class="lineCov">      79743 :               root-&gt;grp_to_be_debug_replaced = 1;</span>
<span class="lineNum">    2525 </span><span class="lineCov">      79743 :               root-&gt;replacement_decl = create_access_replacement (root);</span>
<span class="lineNum">    2526 </span>            :             }
<span class="lineNum">    2527 </span>            :         }
<span class="lineNum">    2528 </span>            : 
<span class="lineNum">    2529 </span><span class="lineCov">    3836096 :       if (covered_to &lt; limit)</span>
<span class="lineNum">    2530 </span><span class="lineCov">    3094183 :         hole = true;</span>
<span class="lineNum">    2531 </span><span class="lineCov">    3836096 :       if (scalar || !allow_replacements)</span>
<span class="lineNum">    2532 </span><span class="lineCov">    1788464 :         root-&gt;grp_total_scalarization = 0;</span>
<span class="lineNum">    2533 </span>            :     }
<span class="lineNum">    2534 </span>            : 
<span class="lineNum">    2535 </span><span class="lineCov">    6166804 :   if (!hole || root-&gt;grp_total_scalarization)</span>
<span class="lineNum">    2536 </span><span class="lineCov">    3124523 :     root-&gt;grp_covered = 1;</span>
<span class="lineNum">    2537 </span><span class="lineCov">    3042281 :   else if (root-&gt;grp_write || comes_initialized_p (root-&gt;base))</span>
<span class="lineNum">    2538 </span><span class="lineCov">    2502231 :     root-&gt;grp_unscalarized_data = 1; /* not covered and written to */</span>
<span class="lineNum">    2539 </span><span class="lineCov">    6166804 :   return sth_created;</span>
<span class="lineNum">    2540 </span>            : }
<span class="lineNum">    2541 </span>            : 
<span class="lineNum">    2542 </span>            : /* Analyze all access trees linked by next_grp by the means of
<a name="2543"><span class="lineNum">    2543 </span>            :    analyze_access_subtree.  */</a>
<span class="lineNum">    2544 </span>            : static bool
<span class="lineNum">    2545 </span><span class="lineNoCov">          0 : analyze_access_trees (struct access *access)</span>
<span class="lineNum">    2546 </span>            : {
<span class="lineNum">    2547 </span><span class="lineNoCov">          0 :   bool ret = false;</span>
<span class="lineNum">    2548 </span>            : 
<span class="lineNum">    2549 </span><span class="lineCov">    4761944 :   while (access)</span>
<span class="lineNum">    2550 </span>            :     {
<span class="lineNum">    2551 </span><span class="lineCov">    2473150 :       if (analyze_access_subtree (access, NULL, true))</span>
<span class="lineNum">    2552 </span><span class="lineCov">    1207176 :         ret = true;</span>
<span class="lineNum">    2553 </span><span class="lineCov">    2473150 :       access = access-&gt;next_grp;</span>
<span class="lineNum">    2554 </span>            :     }
<span class="lineNum">    2555 </span>            : 
<span class="lineNum">    2556 </span><span class="lineCov">    2288794 :   return ret;</span>
<span class="lineNum">    2557 </span>            : }
<span class="lineNum">    2558 </span>            : 
<span class="lineNum">    2559 </span>            : /* Return true iff a potential new child of LACC at offset OFFSET and with size
<span class="lineNum">    2560 </span>            :    SIZE would conflict with an already existing one.  If exactly such a child
<span class="lineNum">    2561 </span>            :    already exists in LACC, store a pointer to it in EXACT_MATCH.  */
<a name="2562"><span class="lineNum">    2562 </span>            : </a>
<span class="lineNum">    2563 </span>            : static bool
<span class="lineNum">    2564 </span><span class="lineNoCov">          0 : child_would_conflict_in_lacc (struct access *lacc, HOST_WIDE_INT norm_offset,</span>
<span class="lineNum">    2565 </span>            :                               HOST_WIDE_INT size, struct access **exact_match)
<span class="lineNum">    2566 </span>            : {
<span class="lineNum">    2567 </span><span class="lineCov">    2666512 :   struct access *child;</span>
<span class="lineNum">    2568 </span>            : 
<span class="lineNum">    2569 </span><span class="lineCov">    5011248 :   for (child = lacc-&gt;first_child; child; child = child-&gt;next_sibling)</span>
<span class="lineNum">    2570 </span>            :     {
<span class="lineNum">    2571 </span><span class="lineCov">    4830131 :       if (child-&gt;offset == norm_offset &amp;&amp; child-&gt;size == size)</span>
<span class="lineNum">    2572 </span>            :         {
<span class="lineNum">    2573 </span><span class="lineNoCov">          0 :           *exact_match = child;</span>
<span class="lineNum">    2574 </span><span class="lineNoCov">          0 :           return true;</span>
<span class="lineNum">    2575 </span>            :         }
<span class="lineNum">    2576 </span>            : 
<span class="lineNum">    2577 </span><span class="lineCov">    2390955 :       if (child-&gt;offset &lt; norm_offset + size</span>
<span class="lineNum">    2578 </span><span class="lineCov">    2377143 :           &amp;&amp; child-&gt;offset + child-&gt;size &gt; norm_offset)</span>
<span class="lineNum">    2579 </span>            :         return true;
<span class="lineNum">    2580 </span>            :     }
<span class="lineNum">    2581 </span>            : 
<span class="lineNum">    2582 </span>            :   return false;
<span class="lineNum">    2583 </span>            : }
<span class="lineNum">    2584 </span>            : 
<span class="lineNum">    2585 </span>            : /* Create a new child access of PARENT, with all properties just like MODEL
<span class="lineNum">    2586 </span>            :    except for its offset and with its grp_write false and grp_read true.
<span class="lineNum">    2587 </span>            :    Return the new access or NULL if it cannot be created.  Note that this
<span class="lineNum">    2588 </span>            :    access is created long after all splicing and sorting, it's not located in
<span class="lineNum">    2589 </span>            :    any access vector and is automatically a representative of its group.  Set
<span class="lineNum">    2590 </span>            :    the gpr_write flag of the new accesss if SET_GRP_WRITE is true.  */
<a name="2591"><span class="lineNum">    2591 </span>            : </a>
<span class="lineNum">    2592 </span>            : static struct access *
<span class="lineNum">    2593 </span><span class="lineCov">     180745 : create_artificial_child_access (struct access *parent, struct access *model,</span>
<span class="lineNum">    2594 </span>            :                                 HOST_WIDE_INT new_offset,
<span class="lineNum">    2595 </span>            :                                 bool set_grp_write)
<span class="lineNum">    2596 </span>            : {
<span class="lineNum">    2597 </span><span class="lineCov">     180745 :   struct access **child;</span>
<span class="lineNum">    2598 </span><span class="lineCov">     180745 :   tree expr = parent-&gt;base;</span>
<span class="lineNum">    2599 </span>            : 
<span class="lineNum">    2600 </span><span class="lineCov">     180745 :   gcc_assert (!model-&gt;grp_unscalarizable_region);</span>
<span class="lineNum">    2601 </span>            : 
<span class="lineNum">    2602 </span><span class="lineCov">     180745 :   struct access *access = access_pool.allocate ();</span>
<span class="lineNum">    2603 </span><span class="lineCov">     180745 :   memset (access, 0, sizeof (struct access));</span>
<span class="lineNum">    2604 </span><span class="lineCov">     180745 :   if (!build_user_friendly_ref_for_offset (&amp;expr, TREE_TYPE (expr), new_offset,</span>
<span class="lineNum">    2605 </span>            :                                            model-&gt;type))
<span class="lineNum">    2606 </span>            :     {
<span class="lineNum">    2607 </span><span class="lineCov">       1598 :       access-&gt;grp_no_warning = true;</span>
<span class="lineNum">    2608 </span><span class="lineCov">       1598 :       expr = build_ref_for_model (EXPR_LOCATION (parent-&gt;base), parent-&gt;base,</span>
<span class="lineNum">    2609 </span>            :                                   new_offset, model, NULL, false);
<span class="lineNum">    2610 </span>            :     }
<span class="lineNum">    2611 </span>            : 
<span class="lineNum">    2612 </span><span class="lineCov">     180745 :   access-&gt;base = parent-&gt;base;</span>
<span class="lineNum">    2613 </span><span class="lineCov">     180745 :   access-&gt;expr = expr;</span>
<span class="lineNum">    2614 </span><span class="lineCov">     180745 :   access-&gt;offset = new_offset;</span>
<span class="lineNum">    2615 </span><span class="lineCov">     180745 :   access-&gt;size = model-&gt;size;</span>
<span class="lineNum">    2616 </span><span class="lineCov">     180745 :   access-&gt;type = model-&gt;type;</span>
<span class="lineNum">    2617 </span><span class="lineCov">     180745 :   access-&gt;grp_write = set_grp_write;</span>
<span class="lineNum">    2618 </span><span class="lineCov">     180745 :   access-&gt;grp_read = false;</span>
<span class="lineNum">    2619 </span><span class="lineCov">     180745 :   access-&gt;reverse = model-&gt;reverse;</span>
<span class="lineNum">    2620 </span>            : 
<span class="lineNum">    2621 </span><span class="lineCov">     180745 :   child = &amp;parent-&gt;first_child;</span>
<span class="lineNum">    2622 </span><span class="lineCov">     354569 :   while (*child &amp;&amp; (*child)-&gt;offset &lt; new_offset)</span>
<span class="lineNum">    2623 </span><span class="lineCov">     173824 :     child = &amp;(*child)-&gt;next_sibling;</span>
<span class="lineNum">    2624 </span>            : 
<span class="lineNum">    2625 </span><span class="lineCov">     180745 :   access-&gt;next_sibling = *child;</span>
<span class="lineNum">    2626 </span><span class="lineCov">     180745 :   *child = access;</span>
<span class="lineNum">    2627 </span>            : 
<span class="lineNum">    2628 </span><span class="lineCov">     180745 :   return access;</span>
<span class="lineNum">    2629 </span>            : }
<span class="lineNum">    2630 </span>            : 
<span class="lineNum">    2631 </span>            : 
<span class="lineNum">    2632 </span>            : /* Beginning with ACCESS, traverse its whole access subtree and mark all
<span class="lineNum">    2633 </span>            :    sub-trees as written to.  If any of them has not been marked so previously
<span class="lineNum">    2634 </span>            :    and has assignment links leading from it, re-enqueue it.  */
<a name="2635"><span class="lineNum">    2635 </span>            : </a>
<span class="lineNum">    2636 </span>            : static void
<span class="lineNum">    2637 </span><span class="lineCov">    1119259 : subtree_mark_written_and_enqueue (struct access *access)</span>
<span class="lineNum">    2638 </span>            : {
<span class="lineNum">    2639 </span><span class="lineCov">    1119259 :   if (access-&gt;grp_write)</span>
<span class="lineNum">    2640 </span>            :     return;
<span class="lineNum">    2641 </span><span class="lineCov">    1077994 :   access-&gt;grp_write = true;</span>
<span class="lineNum">    2642 </span><span class="lineCov">    1077994 :   add_access_to_work_queue (access);</span>
<span class="lineNum">    2643 </span>            : 
<span class="lineNum">    2644 </span><span class="lineCov">    1077994 :   struct access *child;</span>
<span class="lineNum">    2645 </span><span class="lineCov">    1568028 :   for (child = access-&gt;first_child; child; child = child-&gt;next_sibling)</span>
<span class="lineNum">    2646 </span><span class="lineCov">     490034 :     subtree_mark_written_and_enqueue (child);</span>
<span class="lineNum">    2647 </span>            : }
<span class="lineNum">    2648 </span>            : 
<span class="lineNum">    2649 </span>            : /* Propagate subaccesses and grp_write flags of RACC across an assignment link
<span class="lineNum">    2650 </span>            :    to LACC.  Enqueue sub-accesses as necessary so that the write flag is
<span class="lineNum">    2651 </span>            :    propagated transitively.  Return true if anything changed.  Additionally, if
<span class="lineNum">    2652 </span>            :    RACC is a scalar access but LACC is not, change the type of the latter, if
<span class="lineNum">    2653 </span>            :    possible.  */
<a name="2654"><span class="lineNum">    2654 </span>            : </a>
<span class="lineNum">    2655 </span>            : static bool
<span class="lineNum">    2656 </span><span class="lineCov">    1743912 : propagate_subaccesses_across_link (struct access *lacc, struct access *racc)</span>
<span class="lineNum">    2657 </span>            : {
<span class="lineNum">    2658 </span><span class="lineCov">    1743912 :   struct access *rchild;</span>
<span class="lineNum">    2659 </span><span class="lineCov">    1743912 :   HOST_WIDE_INT norm_delta = lacc-&gt;offset - racc-&gt;offset;</span>
<span class="lineNum">    2660 </span><span class="lineCov">    1743912 :   bool ret = false;</span>
<span class="lineNum">    2661 </span>            : 
<span class="lineNum">    2662 </span>            :   /* IF the LHS is still not marked as being written to, we only need to do so
<span class="lineNum">    2663 </span>            :      if the RHS at this level actually was.  */
<span class="lineNum">    2664 </span><span class="lineCov">    1743912 :   if (!lacc-&gt;grp_write)</span>
<span class="lineNum">    2665 </span>            :     {
<span class="lineNum">    2666 </span><span class="lineCov">     679388 :       gcc_checking_assert (!comes_initialized_p (racc-&gt;base));</span>
<span class="lineNum">    2667 </span><span class="lineCov">     679388 :       if (racc-&gt;grp_write)</span>
<span class="lineNum">    2668 </span>            :         {
<span class="lineNum">    2669 </span><span class="lineCov">     325070 :           subtree_mark_written_and_enqueue (lacc);</span>
<span class="lineNum">    2670 </span><span class="lineCov">     325070 :           ret = true;</span>
<span class="lineNum">    2671 </span>            :         }
<span class="lineNum">    2672 </span>            :     }
<span class="lineNum">    2673 </span>            : 
<span class="lineNum">    2674 </span><span class="lineCov">    1743912 :   if (is_gimple_reg_type (lacc-&gt;type)</span>
<span class="lineNum">    2675 </span><span class="lineCov">    1310151 :       || lacc-&gt;grp_unscalarizable_region</span>
<span class="lineNum">    2676 </span><span class="lineCov">    3053589 :       || racc-&gt;grp_unscalarizable_region)</span>
<span class="lineNum">    2677 </span>            :     {
<span class="lineNum">    2678 </span><span class="lineCov">     434648 :       if (!lacc-&gt;grp_write)</span>
<span class="lineNum">    2679 </span>            :         {
<span class="lineNum">    2680 </span><span class="lineCov">      84266 :           ret = true;</span>
<span class="lineNum">    2681 </span><span class="lineCov">      84266 :           subtree_mark_written_and_enqueue (lacc);</span>
<span class="lineNum">    2682 </span>            :         }
<span class="lineNum">    2683 </span><span class="lineCov">     434648 :       return ret;</span>
<span class="lineNum">    2684 </span>            :     }
<span class="lineNum">    2685 </span>            : 
<span class="lineNum">    2686 </span><span class="lineCov">    2618528 :   if (is_gimple_reg_type (racc-&gt;type))</span>
<span class="lineNum">    2687 </span>            :     {
<span class="lineNum">    2688 </span><span class="lineCov">      41937 :       if (!lacc-&gt;grp_write)</span>
<span class="lineNum">    2689 </span>            :         {
<span class="lineNum">    2690 </span><span class="lineCov">       6945 :           ret = true;</span>
<span class="lineNum">    2691 </span><span class="lineCov">       6945 :           subtree_mark_written_and_enqueue (lacc);</span>
<span class="lineNum">    2692 </span>            :         }
<span class="lineNum">    2693 </span><span class="lineCov">      41937 :       if (!lacc-&gt;first_child &amp;&amp; !racc-&gt;first_child)</span>
<span class="lineNum">    2694 </span>            :         {
<span class="lineNum">    2695 </span><span class="lineCov">      41670 :           tree t = lacc-&gt;base;</span>
<span class="lineNum">    2696 </span>            : 
<span class="lineNum">    2697 </span><span class="lineCov">      41670 :           lacc-&gt;type = racc-&gt;type;</span>
<span class="lineNum">    2698 </span><span class="lineCov">      41670 :           if (build_user_friendly_ref_for_offset (&amp;t, TREE_TYPE (t),</span>
<span class="lineNum">    2699 </span>            :                                                   lacc-&gt;offset, racc-&gt;type))
<span class="lineNum">    2700 </span><span class="lineCov">      41656 :             lacc-&gt;expr = t;</span>
<span class="lineNum">    2701 </span>            :           else
<span class="lineNum">    2702 </span>            :             {
<span class="lineNum">    2703 </span><span class="lineCov">         14 :               lacc-&gt;expr = build_ref_for_model (EXPR_LOCATION (lacc-&gt;base),</span>
<span class="lineNum">    2704 </span>            :                                                 lacc-&gt;base, lacc-&gt;offset,
<span class="lineNum">    2705 </span>            :                                                 racc, NULL, false);
<span class="lineNum">    2706 </span><span class="lineCov">         14 :               lacc-&gt;grp_no_warning = true;</span>
<span class="lineNum">    2707 </span>            :             }
<span class="lineNum">    2708 </span>            :         }
<span class="lineNum">    2709 </span><span class="lineCov">      41937 :       return ret;</span>
<span class="lineNum">    2710 </span>            :     }
<span class="lineNum">    2711 </span>            : 
<span class="lineNum">    2712 </span><span class="lineCov">    3933839 :   for (rchild = racc-&gt;first_child; rchild; rchild = rchild-&gt;next_sibling)</span>
<span class="lineNum">    2713 </span>            :     {
<span class="lineNum">    2714 </span><span class="lineCov">    2666512 :       struct access *new_acc = NULL;</span>
<span class="lineNum">    2715 </span><span class="lineCov">    2666512 :       HOST_WIDE_INT norm_offset = rchild-&gt;offset + norm_delta;</span>
<span class="lineNum">    2716 </span>            : 
<span class="lineNum">    2717 </span><span class="lineCov">    5333024 :       if (child_would_conflict_in_lacc (lacc, norm_offset, rchild-&gt;size,</span>
<span class="lineNum">    2718 </span>            :                                         &amp;new_acc))
<span class="lineNum">    2719 </span>            :         {
<span class="lineNum">    2720 </span><span class="lineCov">    2485395 :           if (new_acc)</span>
<span class="lineNum">    2721 </span>            :             {
<span class="lineNum">    2722 </span><span class="lineCov">    2439176 :               if (!new_acc-&gt;grp_write &amp;&amp; rchild-&gt;grp_write)</span>
<span class="lineNum">    2723 </span>            :                 {
<span class="lineNum">    2724 </span><span class="lineCov">     210973 :                   gcc_assert (!lacc-&gt;grp_write);</span>
<span class="lineNum">    2725 </span><span class="lineCov">     210973 :                   subtree_mark_written_and_enqueue (new_acc);</span>
<span class="lineNum">    2726 </span><span class="lineCov">     210973 :                   ret = true;</span>
<span class="lineNum">    2727 </span>            :                 }
<span class="lineNum">    2728 </span>            : 
<span class="lineNum">    2729 </span><span class="lineCov">    2439176 :               rchild-&gt;grp_hint = 1;</span>
<span class="lineNum">    2730 </span><span class="lineCov">    2439176 :               new_acc-&gt;grp_hint |= new_acc-&gt;grp_read;</span>
<span class="lineNum">    2731 </span><span class="lineCov">    2439176 :               if (rchild-&gt;first_child)</span>
<span class="lineNum">    2732 </span><span class="lineCov">       2496 :                 ret |= propagate_subaccesses_across_link (new_acc, rchild);</span>
<span class="lineNum">    2733 </span>            :             }
<span class="lineNum">    2734 </span>            :           else
<span class="lineNum">    2735 </span>            :             {
<span class="lineNum">    2736 </span><span class="lineCov">      46219 :               if (!lacc-&gt;grp_write)</span>
<span class="lineNum">    2737 </span>            :                 {
<span class="lineNum">    2738 </span><span class="lineCov">       1887 :                   ret = true;</span>
<span class="lineNum">    2739 </span><span class="lineCov">       1887 :                   subtree_mark_written_and_enqueue (lacc);</span>
<span class="lineNum">    2740 </span>            :                 }
<span class="lineNum">    2741 </span>            :             }
<span class="lineNum">    2742 </span><span class="lineCov">    2485395 :           continue;</span>
<span class="lineNum">    2743 </span>            :         }
<span class="lineNum">    2744 </span>            : 
<span class="lineNum">    2745 </span><span class="lineCov">     181117 :       if (rchild-&gt;grp_unscalarizable_region)</span>
<span class="lineNum">    2746 </span>            :         {
<span class="lineNum">    2747 </span><span class="lineCov">        372 :           if (rchild-&gt;grp_write &amp;&amp; !lacc-&gt;grp_write)</span>
<span class="lineNum">    2748 </span>            :             {
<span class="lineNum">    2749 </span><span class="lineCov">         45 :               ret = true;</span>
<span class="lineNum">    2750 </span><span class="lineCov">         45 :               subtree_mark_written_and_enqueue (lacc);</span>
<span class="lineNum">    2751 </span>            :             }
<span class="lineNum">    2752 </span><span class="lineCov">        372 :           continue;</span>
<span class="lineNum">    2753 </span>            :         }
<span class="lineNum">    2754 </span>            : 
<span class="lineNum">    2755 </span><span class="lineCov">     180745 :       rchild-&gt;grp_hint = 1;</span>
<span class="lineNum">    2756 </span><span class="lineCov">     180745 :       new_acc = create_artificial_child_access (lacc, rchild, norm_offset,</span>
<span class="lineNum">    2757 </span>            :                                                 lacc-&gt;grp_write
<span class="lineNum">    2758 </span><span class="lineCov">     180745 :                                                 || rchild-&gt;grp_write);</span>
<span class="lineNum">    2759 </span><span class="lineCov">     180745 :       gcc_checking_assert (new_acc);</span>
<span class="lineNum">    2760 </span><span class="lineCov">     180745 :       if (racc-&gt;first_child)</span>
<span class="lineNum">    2761 </span><span class="lineCov">     180745 :         propagate_subaccesses_across_link (new_acc, rchild);</span>
<span class="lineNum">    2762 </span>            : 
<span class="lineNum">    2763 </span><span class="lineCov">     180745 :       add_access_to_work_queue (lacc);</span>
<span class="lineNum">    2764 </span><span class="lineCov">     180745 :       ret = true;</span>
<span class="lineNum">    2765 </span>            :     }
<span class="lineNum">    2766 </span>            : 
<span class="lineNum">    2767 </span>            :   return ret;
<span class="lineNum">    2768 </span>            : }
<span class="lineNum">    2769 </span>            : 
<span class="lineNum">    2770 </span>            : /* Propagate all subaccesses across assignment links.  */
<a name="2771"><span class="lineNum">    2771 </span>            : </a>
<span class="lineNum">    2772 </span>            : static void
<span class="lineNum">    2773 </span><span class="lineCov">     370685 : propagate_all_subaccesses (void)</span>
<span class="lineNum">    2774 </span>            : {
<span class="lineNum">    2775 </span><span class="lineCov">    1271327 :   while (work_queue_head)</span>
<span class="lineNum">    2776 </span>            :     {
<span class="lineNum">    2777 </span><span class="lineCov">    1801284 :       struct access *racc = pop_access_from_work_queue ();</span>
<span class="lineNum">    2778 </span><span class="lineCov">     900642 :       struct assign_link *link;</span>
<span class="lineNum">    2779 </span>            : 
<span class="lineNum">    2780 </span><span class="lineCov">     900642 :       if (racc-&gt;group_representative)</span>
<span class="lineNum">    2781 </span><span class="lineCov">     900641 :         racc= racc-&gt;group_representative;</span>
<span class="lineNum">    2782 </span><span class="lineCov">     900642 :       gcc_assert (racc-&gt;first_link);</span>
<span class="lineNum">    2783 </span>            : 
<span class="lineNum">    2784 </span><span class="lineCov">    2461592 :       for (link = racc-&gt;first_link; link; link = link-&gt;next)</span>
<span class="lineNum">    2785 </span>            :         {
<span class="lineNum">    2786 </span><span class="lineCov">    1560950 :           struct access *lacc = link-&gt;lacc;</span>
<span class="lineNum">    2787 </span>            : 
<span class="lineNum">    2788 </span><span class="lineCov">    1560950 :           if (!bitmap_bit_p (candidate_bitmap, DECL_UID (lacc-&gt;base)))</span>
<span class="lineNum">    2789 </span>            :             continue;
<span class="lineNum">    2790 </span><span class="lineCov">    1560710 :           lacc = lacc-&gt;group_representative;</span>
<span class="lineNum">    2791 </span>            : 
<span class="lineNum">    2792 </span><span class="lineCov">    1560710 :           bool reque_parents = false;</span>
<span class="lineNum">    2793 </span><span class="lineCov">    1560710 :           if (!bitmap_bit_p (candidate_bitmap, DECL_UID (racc-&gt;base)))</span>
<span class="lineNum">    2794 </span>            :             {
<span class="lineNum">    2795 </span><span class="lineCov">         39 :               if (!lacc-&gt;grp_write)</span>
<span class="lineNum">    2796 </span>            :                 {
<span class="lineNum">    2797 </span><span class="lineCov">         39 :                   subtree_mark_written_and_enqueue (lacc);</span>
<span class="lineNum">    2798 </span><span class="lineCov">         39 :                   reque_parents = true;</span>
<span class="lineNum">    2799 </span>            :                 }
<span class="lineNum">    2800 </span>            :             }
<span class="lineNum">    2801 </span><span class="lineCov">    1560671 :           else if (propagate_subaccesses_across_link (lacc, racc))</span>
<span class="lineNum">    2802 </span>            :             reque_parents = true;
<span class="lineNum">    2803 </span>            : 
<span class="lineNum">    2804 </span><span class="lineCov">         39 :           if (reque_parents)</span>
<span class="lineNum">    2805 </span><span class="lineCov">     649290 :             do</span>
<span class="lineNum">    2806 </span>            :               {
<span class="lineNum">    2807 </span><span class="lineCov">     649290 :                 add_access_to_work_queue (lacc);</span>
<span class="lineNum">    2808 </span><span class="lineCov">     649290 :                 lacc = lacc-&gt;parent;</span>
<span class="lineNum">    2809 </span>            :               }
<span class="lineNum">    2810 </span><span class="lineCov">     649290 :             while (lacc);</span>
<span class="lineNum">    2811 </span>            :         }
<span class="lineNum">    2812 </span>            :     }
<span class="lineNum">    2813 </span><span class="lineCov">     370685 : }</span>
<span class="lineNum">    2814 </span>            : 
<span class="lineNum">    2815 </span>            : /* Go through all accesses collected throughout the (intraprocedural) analysis
<span class="lineNum">    2816 </span>            :    stage, exclude overlapping ones, identify representatives and build trees
<span class="lineNum">    2817 </span>            :    out of them, making decisions about scalarization on the way.  Return true
<span class="lineNum">    2818 </span>            :    iff there are any to-be-scalarized variables after this stage. */
<a name="2819"><span class="lineNum">    2819 </span>            : </a>
<span class="lineNum">    2820 </span>            : static bool
<span class="lineNum">    2821 </span><span class="lineCov">     370685 : analyze_all_variable_accesses (void)</span>
<span class="lineNum">    2822 </span>            : {
<span class="lineNum">    2823 </span><span class="lineCov">     370685 :   int res = 0;</span>
<span class="lineNum">    2824 </span><span class="lineCov">     370685 :   bitmap tmp = BITMAP_ALLOC (NULL);</span>
<span class="lineNum">    2825 </span><span class="lineCov">     370685 :   bitmap_iterator bi;</span>
<span class="lineNum">    2826 </span><span class="lineCov">     370685 :   unsigned i;</span>
<span class="lineNum">    2827 </span><span class="lineCov">     370685 :   bool optimize_speed_p = !optimize_function_for_size_p (cfun);</span>
<span class="lineNum">    2828 </span>            : 
<span class="lineNum">    2829 </span><span class="lineCov">     741370 :   enum compiler_param param = optimize_speed_p</span>
<span class="lineNum">    2830 </span><span class="lineCov">     370685 :                         ? PARAM_SRA_MAX_SCALARIZATION_SIZE_SPEED</span>
<span class="lineNum">    2831 </span>            :                         : PARAM_SRA_MAX_SCALARIZATION_SIZE_SIZE;
<span class="lineNum">    2832 </span>            : 
<span class="lineNum">    2833 </span>            :   /* If the user didn't set PARAM_SRA_MAX_SCALARIZATION_SIZE_&lt;...&gt;,
<span class="lineNum">    2834 </span>            :      fall back to a target default.  */
<span class="lineNum">    2835 </span><span class="lineCov">     370685 :   unsigned HOST_WIDE_INT max_scalarization_size</span>
<span class="lineNum">    2836 </span><span class="lineCov">     370685 :     = global_options_set.x_param_values[param]</span>
<span class="lineNum">    2837 </span><span class="lineCov">     370685 :       ? PARAM_VALUE (param)</span>
<span class="lineNum">    2838 </span><span class="lineCov">     453385 :       : get_move_ratio (optimize_speed_p) * UNITS_PER_WORD;</span>
<span class="lineNum">    2839 </span>            : 
<span class="lineNum">    2840 </span><span class="lineCov">     370685 :   max_scalarization_size *= BITS_PER_UNIT;</span>
<span class="lineNum">    2841 </span>            : 
<span class="lineNum">    2842 </span><span class="lineCov">    2750170 :   EXECUTE_IF_SET_IN_BITMAP (candidate_bitmap, 0, i, bi)</span>
<span class="lineNum">    2843 </span><span class="lineCov">    2379485 :     if (bitmap_bit_p (should_scalarize_away_bitmap, i)</span>
<span class="lineNum">    2844 </span><span class="lineCov">    2379485 :         &amp;&amp; !bitmap_bit_p (cannot_scalarize_away_bitmap, i))</span>
<span class="lineNum">    2845 </span>            :       {
<span class="lineNum">    2846 </span><span class="lineCov">     715254 :         tree var = candidate (i);</span>
<span class="lineNum">    2847 </span>            : 
<span class="lineNum">    2848 </span><span class="lineCov">    1381764 :         if (VAR_P (var) &amp;&amp; scalarizable_type_p (TREE_TYPE (var),</span>
<span class="lineNum">    2849 </span><span class="lineCov">    1331217 :                                                 constant_decl_p (var)))</span>
<span class="lineNum">    2850 </span>            :           {
<span class="lineNum">    2851 </span><span class="lineCov">     653235 :             if (tree_to_uhwi (TYPE_SIZE (TREE_TYPE (var)))</span>
<span class="lineNum">    2852 </span>            :                 &lt;= max_scalarization_size)
<span class="lineNum">    2853 </span>            :               {
<span class="lineNum">    2854 </span><span class="lineCov">     646699 :                 create_total_scalarization_access (var);</span>
<span class="lineNum">    2855 </span><span class="lineCov">     646699 :                 completely_scalarize (var, TREE_TYPE (var), 0, var);</span>
<span class="lineNum">    2856 </span><span class="lineCov">     646699 :                 statistics_counter_event (cfun,</span>
<span class="lineNum">    2857 </span>            :                                           &quot;Totally-scalarized aggregates&quot;, 1);
<span class="lineNum">    2858 </span><span class="lineCov">     646699 :                 if (dump_file &amp;&amp; (dump_flags &amp; TDF_DETAILS))</span>
<span class="lineNum">    2859 </span>            :                   {
<span class="lineNum">    2860 </span><span class="lineCov">          3 :                     fprintf (dump_file, &quot;Will attempt to totally scalarize &quot;);</span>
<span class="lineNum">    2861 </span><span class="lineCov">          3 :                     print_generic_expr (dump_file, var);</span>
<span class="lineNum">    2862 </span><span class="lineCov">          3 :                     fprintf (dump_file, &quot; (UID: %u): \n&quot;, DECL_UID (var));</span>
<span class="lineNum">    2863 </span>            :                   }
<span class="lineNum">    2864 </span>            :               }
<span class="lineNum">    2865 </span><span class="lineCov">       6536 :             else if (dump_file &amp;&amp; (dump_flags &amp; TDF_DETAILS))</span>
<span class="lineNum">    2866 </span>            :               {
<span class="lineNum">    2867 </span><span class="lineNoCov">          0 :                 fprintf (dump_file, &quot;Too big to totally scalarize: &quot;);</span>
<span class="lineNum">    2868 </span><span class="lineNoCov">          0 :                 print_generic_expr (dump_file, var);</span>
<span class="lineNum">    2869 </span><span class="lineNoCov">          0 :                 fprintf (dump_file, &quot; (UID: %u)\n&quot;, DECL_UID (var));</span>
<span class="lineNum">    2870 </span>            :               }
<span class="lineNum">    2871 </span>            :           }
<span class="lineNum">    2872 </span>            :       }
<span class="lineNum">    2873 </span>            : 
<span class="lineNum">    2874 </span><span class="lineCov">     370685 :   bitmap_copy (tmp, candidate_bitmap);</span>
<span class="lineNum">    2875 </span><span class="lineCov">    2750170 :   EXECUTE_IF_SET_IN_BITMAP (tmp, 0, i, bi)</span>
<span class="lineNum">    2876 </span>            :     {
<span class="lineNum">    2877 </span><span class="lineCov">    2379485 :       tree var = candidate (i);</span>
<span class="lineNum">    2878 </span><span class="lineCov">    2379485 :       struct access *access;</span>
<span class="lineNum">    2879 </span>            : 
<span class="lineNum">    2880 </span><span class="lineCov">    2379485 :       access = sort_and_splice_var_accesses (var);</span>
<span class="lineNum">    2881 </span><span class="lineCov">    4669258 :       if (!access || !build_access_trees (access))</span>
<span class="lineNum">    2882 </span><span class="lineCov">      90691 :         disqualify_candidate (var,</span>
<span class="lineNum">    2883 </span>            :                               &quot;No or inhibitingly overlapping accesses.&quot;);
<span class="lineNum">    2884 </span>            :     }
<span class="lineNum">    2885 </span>            : 
<span class="lineNum">    2886 </span><span class="lineCov">     370685 :   propagate_all_subaccesses ();</span>
<span class="lineNum">    2887 </span>            : 
<span class="lineNum">    2888 </span><span class="lineCov">     370685 :   bitmap_copy (tmp, candidate_bitmap);</span>
<span class="lineNum">    2889 </span><span class="lineCov">    2659479 :   EXECUTE_IF_SET_IN_BITMAP (tmp, 0, i, bi)</span>
<span class="lineNum">    2890 </span>            :     {
<span class="lineNum">    2891 </span><span class="lineCov">    2288794 :       tree var = candidate (i);</span>
<span class="lineNum">    2892 </span><span class="lineCov">    2288794 :       struct access *access = get_first_repr_for_decl (var);</span>
<span class="lineNum">    2893 </span>            : 
<span class="lineNum">    2894 </span><span class="lineCov">    4577588 :       if (analyze_access_trees (access))</span>
<span class="lineNum">    2895 </span>            :         {
<span class="lineNum">    2896 </span><span class="lineCov">    1052817 :           res++;</span>
<span class="lineNum">    2897 </span><span class="lineCov">    1052817 :           if (dump_file &amp;&amp; (dump_flags &amp; TDF_DETAILS))</span>
<span class="lineNum">    2898 </span>            :             {
<span class="lineNum">    2899 </span><span class="lineCov">          7 :               fprintf (dump_file, &quot;\nAccess trees for &quot;);</span>
<span class="lineNum">    2900 </span><span class="lineCov">          7 :               print_generic_expr (dump_file, var);</span>
<span class="lineNum">    2901 </span><span class="lineCov">          7 :               fprintf (dump_file, &quot; (UID: %u): \n&quot;, DECL_UID (var));</span>
<span class="lineNum">    2902 </span><span class="lineCov">          7 :               dump_access_tree (dump_file, access);</span>
<span class="lineNum">    2903 </span><span class="lineCov">          7 :               fprintf (dump_file, &quot;\n&quot;);</span>
<span class="lineNum">    2904 </span>            :             }
<span class="lineNum">    2905 </span>            :         }
<span class="lineNum">    2906 </span>            :       else
<span class="lineNum">    2907 </span><span class="lineCov">    1235977 :         disqualify_candidate (var, &quot;No scalar replacements to be created.&quot;);</span>
<span class="lineNum">    2908 </span>            :     }
<span class="lineNum">    2909 </span>            : 
<span class="lineNum">    2910 </span><span class="lineCov">     370685 :   BITMAP_FREE (tmp);</span>
<span class="lineNum">    2911 </span>            : 
<span class="lineNum">    2912 </span><span class="lineCov">     370685 :   if (res)</span>
<span class="lineNum">    2913 </span>            :     {
<span class="lineNum">    2914 </span><span class="lineCov">     219159 :       statistics_counter_event (cfun, &quot;Scalarized aggregates&quot;, res);</span>
<span class="lineNum">    2915 </span><span class="lineCov">     219159 :       return true;</span>
<span class="lineNum">    2916 </span>            :     }
<span class="lineNum">    2917 </span>            :   else
<span class="lineNum">    2918 </span>            :     return false;
<span class="lineNum">    2919 </span>            : }
<span class="lineNum">    2920 </span>            : 
<span class="lineNum">    2921 </span>            : /* Generate statements copying scalar replacements of accesses within a subtree
<span class="lineNum">    2922 </span>            :    into or out of AGG.  ACCESS, all its children, siblings and their children
<span class="lineNum">    2923 </span>            :    are to be processed.  AGG is an aggregate type expression (can be a
<span class="lineNum">    2924 </span>            :    declaration but does not have to be, it can for example also be a mem_ref or
<span class="lineNum">    2925 </span>            :    a series of handled components).  TOP_OFFSET is the offset of the processed
<span class="lineNum">    2926 </span>            :    subtree which has to be subtracted from offsets of individual accesses to
<span class="lineNum">    2927 </span>            :    get corresponding offsets for AGG.  If CHUNK_SIZE is non-null, copy only
<span class="lineNum">    2928 </span>            :    replacements in the interval &lt;start_offset, start_offset + chunk_size&gt;,
<span class="lineNum">    2929 </span>            :    otherwise copy all.  GSI is a statement iterator used to place the new
<span class="lineNum">    2930 </span>            :    statements.  WRITE should be true when the statements should write from AGG
<span class="lineNum">    2931 </span>            :    to the replacement and false if vice versa.  if INSERT_AFTER is true, new
<span class="lineNum">    2932 </span>            :    statements will be added after the current statement in GSI, they will be
<span class="lineNum">    2933 </span>            :    added before the statement otherwise.  */
<a name="2934"><span class="lineNum">    2934 </span>            : </a>
<span class="lineNum">    2935 </span>            : static void
<span class="lineNum">    2936 </span><span class="lineCov">     901398 : generate_subtree_copies (struct access *access, tree agg,</span>
<span class="lineNum">    2937 </span>            :                          HOST_WIDE_INT top_offset,
<span class="lineNum">    2938 </span>            :                          HOST_WIDE_INT start_offset, HOST_WIDE_INT chunk_size,
<span class="lineNum">    2939 </span>            :                          gimple_stmt_iterator *gsi, bool write,
<span class="lineNum">    2940 </span>            :                          bool insert_after, location_t loc)
<span class="lineNum">    2941 </span>            : {
<span class="lineNum">    2942 </span>            :   /* Never write anything into constant pool decls.  See PR70602.  */
<span class="lineNum">    2943 </span><span class="lineCov">     901398 :   if (!write &amp;&amp; constant_decl_p (agg))</span>
<span class="lineNum">    2944 </span>            :     return;
<span class="lineNum">    2945 </span><span class="lineCov">    2137872 :   do</span>
<span class="lineNum">    2946 </span>            :     {
<span class="lineNum">    2947 </span><span class="lineCov">    2137872 :       if (chunk_size &amp;&amp; access-&gt;offset &gt;= start_offset + chunk_size)</span>
<span class="lineNum">    2948 </span>            :         return;
<span class="lineNum">    2949 </span>            : 
<span class="lineNum">    2950 </span><span class="lineCov">    4271872 :       if (access-&gt;grp_to_be_replaced</span>
<span class="lineNum">    2951 </span><span class="lineCov">    1921661 :           &amp;&amp; (chunk_size == 0</span>
<span class="lineNum">    2952 </span><span class="lineCov">    2139015 :               || access-&gt;offset + access-&gt;size &gt; start_offset))</span>
<span class="lineNum">    2953 </span>            :         {
<span class="lineNum">    2954 </span><span class="lineCov">    1920599 :           tree expr, repl = get_access_replacement (access);</span>
<span class="lineNum">    2955 </span><span class="lineCov">    1920599 :           gassign *stmt;</span>
<span class="lineNum">    2956 </span>            : 
<span class="lineNum">    2957 </span><span class="lineCov">    1920599 :           expr = build_ref_for_model (loc, agg, access-&gt;offset - top_offset,</span>
<span class="lineNum">    2958 </span>            :                                       access, gsi, insert_after);
<span class="lineNum">    2959 </span>            : 
<span class="lineNum">    2960 </span><span class="lineCov">    1920599 :           if (write)</span>
<span class="lineNum">    2961 </span>            :             {
<span class="lineNum">    2962 </span><span class="lineCov">     857457 :               if (access-&gt;grp_partial_lhs)</span>
<span class="lineNum">    2963 </span><span class="lineNoCov">          0 :                 expr = force_gimple_operand_gsi (gsi, expr, true, NULL_TREE,</span>
<span class="lineNum">    2964 </span><span class="lineNoCov">          0 :                                                  !insert_after,</span>
<span class="lineNum">    2965 </span>            :                                                  insert_after ? GSI_NEW_STMT
<span class="lineNum">    2966 </span>            :                                                  : GSI_SAME_STMT);
<span class="lineNum">    2967 </span><span class="lineCov">     857457 :               stmt = gimple_build_assign (repl, expr);</span>
<span class="lineNum">    2968 </span>            :             }
<span class="lineNum">    2969 </span>            :           else
<span class="lineNum">    2970 </span>            :             {
<span class="lineNum">    2971 </span><span class="lineCov">    1063142 :               TREE_NO_WARNING (repl) = 1;</span>
<span class="lineNum">    2972 </span><span class="lineCov">    1063142 :               if (access-&gt;grp_partial_lhs)</span>
<span class="lineNum">    2973 </span><span class="lineCov">         54 :                 repl = force_gimple_operand_gsi (gsi, repl, true, NULL_TREE,</span>
<span class="lineNum">    2974 </span><span class="lineCov">         54 :                                                  !insert_after,</span>
<span class="lineNum">    2975 </span>            :                                                  insert_after ? GSI_NEW_STMT
<span class="lineNum">    2976 </span>            :                                                  : GSI_SAME_STMT);
<span class="lineNum">    2977 </span><span class="lineCov">    1063142 :               stmt = gimple_build_assign (expr, repl);</span>
<span class="lineNum">    2978 </span>            :             }
<span class="lineNum">    2979 </span><span class="lineCov">    1920599 :           gimple_set_location (stmt, loc);</span>
<span class="lineNum">    2980 </span>            : 
<span class="lineNum">    2981 </span><span class="lineCov">    1920599 :           if (insert_after)</span>
<span class="lineNum">    2982 </span><span class="lineCov">     857457 :             gsi_insert_after (gsi, stmt, GSI_NEW_STMT);</span>
<span class="lineNum">    2983 </span>            :           else
<span class="lineNum">    2984 </span><span class="lineCov">    1063142 :             gsi_insert_before (gsi, stmt, GSI_SAME_STMT);</span>
<span class="lineNum">    2985 </span><span class="lineCov">    1920599 :           update_stmt (stmt);</span>
<span class="lineNum">    2986 </span><span class="lineCov">    1920599 :           sra_stats.subtree_copies++;</span>
<span class="lineNum">    2987 </span>            :         }
<span class="lineNum">    2988 </span><span class="lineCov">     215337 :       else if (write</span>
<span class="lineNum">    2989 </span><span class="lineCov">      80027 :                &amp;&amp; access-&gt;grp_to_be_debug_replaced</span>
<span class="lineNum">    2990 </span><span class="lineCov">        955 :                &amp;&amp; (chunk_size == 0</span>
<span class="lineNum">    2991 </span><span class="lineNoCov">          0 :                    || access-&gt;offset + access-&gt;size &gt; start_offset))</span>
<span class="lineNum">    2992 </span>            :         {
<span class="lineNum">    2993 </span><span class="lineCov">        955 :           gdebug *ds;</span>
<span class="lineNum">    2994 </span><span class="lineCov">       2865 :           tree drhs = build_debug_ref_for_model (loc, agg,</span>
<span class="lineNum">    2995 </span><span class="lineCov">        955 :                                                  access-&gt;offset - top_offset,</span>
<span class="lineNum">    2996 </span>            :                                                  access);
<span class="lineNum">    2997 </span><span class="lineCov">       1910 :           ds = gimple_build_debug_bind (get_access_replacement (access),</span>
<span class="lineNum">    2998 </span>            :                                         drhs, gsi_stmt (*gsi));
<span class="lineNum">    2999 </span><span class="lineCov">        955 :           if (insert_after)</span>
<span class="lineNum">    3000 </span><span class="lineCov">        955 :             gsi_insert_after (gsi, ds, GSI_NEW_STMT);</span>
<span class="lineNum">    3001 </span>            :           else
<span class="lineNum">    3002 </span><span class="lineNoCov">          0 :             gsi_insert_before (gsi, ds, GSI_SAME_STMT);</span>
<span class="lineNum">    3003 </span>            :         }
<span class="lineNum">    3004 </span>            : 
<span class="lineNum">    3005 </span><span class="lineCov">    2135936 :       if (access-&gt;first_child)</span>
<span class="lineNum">    3006 </span><span class="lineCov">     167200 :         generate_subtree_copies (access-&gt;first_child, agg, top_offset,</span>
<span class="lineNum">    3007 </span>            :                                  start_offset, chunk_size, gsi,
<span class="lineNum">    3008 </span>            :                                  write, insert_after, loc);
<span class="lineNum">    3009 </span>            : 
<span class="lineNum">    3010 </span><span class="lineCov">    2135936 :       access = access-&gt;next_sibling;</span>
<span class="lineNum">    3011 </span>            :     }
<span class="lineNum">    3012 </span><span class="lineCov">    2135936 :   while (access);</span>
<span class="lineNum">    3013 </span>            : }
<span class="lineNum">    3014 </span>            : 
<span class="lineNum">    3015 </span>            : /* Assign zero to all scalar replacements in an access subtree.  ACCESS is the
<span class="lineNum">    3016 </span>            :    root of the subtree to be processed.  GSI is the statement iterator used
<span class="lineNum">    3017 </span>            :    for inserting statements which are added after the current statement if
<span class="lineNum">    3018 </span>            :    INSERT_AFTER is true or before it otherwise.  */
<a name="3019"><span class="lineNum">    3019 </span>            : </a>
<span class="lineNum">    3020 </span>            : static void
<span class="lineNum">    3021 </span><span class="lineCov">     323375 : init_subtree_with_zero (struct access *access, gimple_stmt_iterator *gsi,</span>
<span class="lineNum">    3022 </span>            :                         bool insert_after, location_t loc)
<span class="lineNum">    3023 </span>            : 
<span class="lineNum">    3024 </span>            : {
<span class="lineNum">    3025 </span><span class="lineCov">     323375 :   struct access *child;</span>
<span class="lineNum">    3026 </span>            : 
<span class="lineNum">    3027 </span><span class="lineCov">     323375 :   if (access-&gt;grp_to_be_replaced)</span>
<span class="lineNum">    3028 </span>            :     {
<span class="lineNum">    3029 </span><span class="lineCov">     178168 :       gassign *stmt;</span>
<span class="lineNum">    3030 </span>            : 
<span class="lineNum">    3031 </span><span class="lineCov">     178168 :       stmt = gimple_build_assign (get_access_replacement (access),</span>
<span class="lineNum">    3032 </span>            :                                   build_zero_cst (access-&gt;type));
<span class="lineNum">    3033 </span><span class="lineCov">     178168 :       if (insert_after)</span>
<span class="lineNum">    3034 </span><span class="lineCov">      18047 :         gsi_insert_after (gsi, stmt, GSI_NEW_STMT);</span>
<span class="lineNum">    3035 </span>            :       else
<span class="lineNum">    3036 </span><span class="lineCov">     160121 :         gsi_insert_before (gsi, stmt, GSI_SAME_STMT);</span>
<span class="lineNum">    3037 </span><span class="lineCov">     178168 :       update_stmt (stmt);</span>
<span class="lineNum">    3038 </span><span class="lineCov">     178168 :       gimple_set_location (stmt, loc);</span>
<span class="lineNum">    3039 </span>            :     }
<span class="lineNum">    3040 </span><span class="lineCov">     145207 :   else if (access-&gt;grp_to_be_debug_replaced)</span>
<span class="lineNum">    3041 </span>            :     {
<span class="lineNum">    3042 </span><span class="lineCov">      11078 :       gdebug *ds</span>
<span class="lineNum">    3043 </span><span class="lineCov">      22156 :         = gimple_build_debug_bind (get_access_replacement (access),</span>
<span class="lineNum">    3044 </span>            :                                    build_zero_cst (access-&gt;type),
<span class="lineNum">    3045 </span>            :                                    gsi_stmt (*gsi));
<span class="lineNum">    3046 </span><span class="lineCov">      11078 :       if (insert_after)</span>
<span class="lineNum">    3047 </span><span class="lineCov">      11078 :         gsi_insert_after (gsi, ds, GSI_NEW_STMT);</span>
<span class="lineNum">    3048 </span>            :       else
<span class="lineNum">    3049 </span><span class="lineNoCov">          0 :         gsi_insert_before (gsi, ds, GSI_SAME_STMT);</span>
<span class="lineNum">    3050 </span>            :     }
<span class="lineNum">    3051 </span>            : 
<span class="lineNum">    3052 </span><span class="lineCov">     566149 :   for (child = access-&gt;first_child; child; child = child-&gt;next_sibling)</span>
<span class="lineNum">    3053 </span><span class="lineCov">     242774 :     init_subtree_with_zero (child, gsi, insert_after, loc);</span>
<span class="lineNum">    3054 </span><span class="lineCov">     323375 : }</span>
<span class="lineNum">    3055 </span>            : 
<span class="lineNum">    3056 </span>            : /* Clobber all scalar replacements in an access subtree.  ACCESS is the
<span class="lineNum">    3057 </span>            :    root of the subtree to be processed.  GSI is the statement iterator used
<span class="lineNum">    3058 </span>            :    for inserting statements which are added after the current statement if
<span class="lineNum">    3059 </span>            :    INSERT_AFTER is true or before it otherwise.  */
<a name="3060"><span class="lineNum">    3060 </span>            : </a>
<span class="lineNum">    3061 </span>            : static void
<span class="lineNum">    3062 </span><span class="lineCov">    1331352 : clobber_subtree (struct access *access, gimple_stmt_iterator *gsi,</span>
<span class="lineNum">    3063 </span>            :                 bool insert_after, location_t loc)
<span class="lineNum">    3064 </span>            : 
<span class="lineNum">    3065 </span>            : {
<span class="lineNum">    3066 </span><span class="lineCov">    1331352 :   struct access *child;</span>
<span class="lineNum">    3067 </span>            : 
<span class="lineNum">    3068 </span><span class="lineCov">    1331352 :   if (access-&gt;grp_to_be_replaced)</span>
<span class="lineNum">    3069 </span>            :     {
<span class="lineNum">    3070 </span><span class="lineCov">     935580 :       tree rep = get_access_replacement (access);</span>
<span class="lineNum">    3071 </span><span class="lineCov">     935580 :       tree clobber = build_constructor (access-&gt;type, NULL);</span>
<span class="lineNum">    3072 </span><span class="lineCov">     935580 :       TREE_THIS_VOLATILE (clobber) = 1;</span>
<span class="lineNum">    3073 </span><span class="lineCov">     935580 :       gimple *stmt = gimple_build_assign (rep, clobber);</span>
<span class="lineNum">    3074 </span>            : 
<span class="lineNum">    3075 </span><span class="lineCov">     935580 :       if (insert_after)</span>
<span class="lineNum">    3076 </span><span class="lineCov">     123053 :         gsi_insert_after (gsi, stmt, GSI_NEW_STMT);</span>
<span class="lineNum">    3077 </span>            :       else
<span class="lineNum">    3078 </span><span class="lineCov">     812527 :         gsi_insert_before (gsi, stmt, GSI_SAME_STMT);</span>
<span class="lineNum">    3079 </span><span class="lineCov">     935580 :       update_stmt (stmt);</span>
<span class="lineNum">    3080 </span><span class="lineCov">    1871160 :       gimple_set_location (stmt, loc);</span>
<span class="lineNum">    3081 </span>            :     }
<span class="lineNum">    3082 </span>            : 
<span class="lineNum">    3083 </span><span class="lineCov">    2130836 :   for (child = access-&gt;first_child; child; child = child-&gt;next_sibling)</span>
<span class="lineNum">    3084 </span><span class="lineCov">     799484 :     clobber_subtree (child, gsi, insert_after, loc);</span>
<span class="lineNum">    3085 </span><span class="lineCov">    1331352 : }</span>
<span class="lineNum">    3086 </span>            : 
<span class="lineNum">    3087 </span>            : /* Search for an access representative for the given expression EXPR and
<span class="lineNum">    3088 </span>            :    return it or NULL if it cannot be found.  */
<a name="3089"><span class="lineNum">    3089 </span>            : </a>
<span class="lineNum">    3090 </span>            : static struct access *
<span class="lineNum">    3091 </span><span class="lineCov">   24607441 : get_access_for_expr (tree expr)</span>
<span class="lineNum">    3092 </span>            : {
<span class="lineNum">    3093 </span><span class="lineCov">   73822323 :   poly_int64 poffset, psize, pmax_size;</span>
<span class="lineNum">    3094 </span><span class="lineCov">   24607441 :   HOST_WIDE_INT offset, max_size;</span>
<span class="lineNum">    3095 </span><span class="lineCov">   24607441 :   tree base;</span>
<span class="lineNum">    3096 </span><span class="lineCov">   24607441 :   bool reverse;</span>
<span class="lineNum">    3097 </span>            : 
<span class="lineNum">    3098 </span>            :   /* FIXME: This should not be necessary but Ada produces V_C_Es with a type of
<span class="lineNum">    3099 </span>            :      a different size than the size of its argument and we need the latter
<span class="lineNum">    3100 </span>            :      one.  */
<span class="lineNum">    3101 </span><span class="lineCov">   24607441 :   if (TREE_CODE (expr) == VIEW_CONVERT_EXPR)</span>
<span class="lineNum">    3102 </span><span class="lineCov">     216137 :     expr = TREE_OPERAND (expr, 0);</span>
<span class="lineNum">    3103 </span>            : 
<span class="lineNum">    3104 </span><span class="lineCov">   24607441 :   base = get_ref_base_and_extent (expr, &amp;poffset, &amp;psize, &amp;pmax_size,</span>
<span class="lineNum">    3105 </span>            :                                   &amp;reverse);
<span class="lineNum">    3106 </span><span class="lineCov">   49140014 :   if (!known_size_p (pmax_size)</span>
<span class="lineNum">    3107 </span><span class="lineCov">   24532573 :       || !pmax_size.is_constant (&amp;max_size)</span>
<span class="lineNum">    3108 </span><span class="lineCov">   24532573 :       || !poffset.is_constant (&amp;offset)</span>
<span class="lineNum">    3109 </span><span class="lineCov">   24607441 :       || !DECL_P (base))</span>
<span class="lineNum">    3110 </span>            :     return NULL;
<span class="lineNum">    3111 </span>            : 
<span class="lineNum">    3112 </span><span class="lineCov">   10037017 :   if (!bitmap_bit_p (candidate_bitmap, DECL_UID (base)))</span>
<span class="lineNum">    3113 </span>            :     return NULL;
<span class="lineNum">    3114 </span>            : 
<span class="lineNum">    3115 </span><span class="lineCov">    4717553 :   return get_var_base_offset_size_access (base, offset, max_size);</span>
<span class="lineNum">    3116 </span>            : }
<span class="lineNum">    3117 </span>            : 
<span class="lineNum">    3118 </span>            : /* Replace the expression EXPR with a scalar replacement if there is one and
<span class="lineNum">    3119 </span>            :    generate other statements to do type conversion or subtree copying if
<span class="lineNum">    3120 </span>            :    necessary.  GSI is used to place newly created statements, WRITE is true if
<span class="lineNum">    3121 </span>            :    the expression is being written to (it is on a LHS of a statement or output
<span class="lineNum">    3122 </span>            :    in an assembly statement).  */
<a name="3123"><span class="lineNum">    3123 </span>            : </a>
<span class="lineNum">    3124 </span>            : static bool
<span class="lineNum">    3125 </span><span class="lineCov">    5720766 : sra_modify_expr (tree *expr, gimple_stmt_iterator *gsi, bool write)</span>
<span class="lineNum">    3126 </span>            : {
<span class="lineNum">    3127 </span><span class="lineCov">    5720766 :   location_t loc;</span>
<span class="lineNum">    3128 </span><span class="lineCov">    5720766 :   struct access *access;</span>
<span class="lineNum">    3129 </span><span class="lineCov">    5720766 :   tree type, bfr, orig_expr;</span>
<span class="lineNum">    3130 </span>            : 
<span class="lineNum">    3131 </span><span class="lineCov">    5720766 :   if (TREE_CODE (*expr) == BIT_FIELD_REF)</span>
<span class="lineNum">    3132 </span>            :     {
<span class="lineNum">    3133 </span><span class="lineCov">       5552 :       bfr = *expr;</span>
<span class="lineNum">    3134 </span><span class="lineCov">       5552 :       expr = &amp;TREE_OPERAND (*expr, 0);</span>
<span class="lineNum">    3135 </span>            :     }
<span class="lineNum">    3136 </span>            :   else
<span class="lineNum">    3137 </span>            :     bfr = NULL_TREE;
<span class="lineNum">    3138 </span>            : 
<span class="lineNum">    3139 </span><span class="lineCov">    5720766 :   if (TREE_CODE (*expr) == REALPART_EXPR || TREE_CODE (*expr) == IMAGPART_EXPR)</span>
<span class="lineNum">    3140 </span><span class="lineCov">       3742 :     expr = &amp;TREE_OPERAND (*expr, 0);</span>
<span class="lineNum">    3141 </span><span class="lineCov">    5720766 :   access = get_access_for_expr (*expr);</span>
<span class="lineNum">    3142 </span><span class="lineCov">    5720766 :   if (!access)</span>
<span class="lineNum">    3143 </span>            :     return false;
<span class="lineNum">    3144 </span><span class="lineCov">     111859 :   type = TREE_TYPE (*expr);</span>
<span class="lineNum">    3145 </span><span class="lineCov">     111859 :   orig_expr = *expr;</span>
<span class="lineNum">    3146 </span>            : 
<span class="lineNum">    3147 </span><span class="lineCov">     223718 :   loc = gimple_location (gsi_stmt (*gsi));</span>
<span class="lineNum">    3148 </span><span class="lineCov">     111859 :   gimple_stmt_iterator alt_gsi = gsi_none ();</span>
<span class="lineNum">    3149 </span><span class="lineCov">     111859 :   if (write &amp;&amp; stmt_ends_bb_p (gsi_stmt (*gsi)))</span>
<span class="lineNum">    3150 </span>            :     {
<span class="lineNum">    3151 </span><span class="lineCov">      34518 :       alt_gsi = gsi_start_edge (single_non_eh_succ (gsi_bb (*gsi)));</span>
<span class="lineNum">    3152 </span><span class="lineCov">      17259 :       gsi = &amp;alt_gsi;</span>
<span class="lineNum">    3153 </span>            :     }
<span class="lineNum">    3154 </span>            : 
<span class="lineNum">    3155 </span><span class="lineCov">     111859 :   if (access-&gt;grp_to_be_replaced)</span>
<span class="lineNum">    3156 </span>            :     {
<span class="lineNum">    3157 </span><span class="lineCov">      11089 :       tree repl = get_access_replacement (access);</span>
<span class="lineNum">    3158 </span>            :       /* If we replace a non-register typed access simply use the original
<span class="lineNum">    3159 </span>            :          access expression to extract the scalar component afterwards.
<span class="lineNum">    3160 </span>            :          This happens if scalarizing a function return value or parameter
<span class="lineNum">    3161 </span>            :          like in gcc.c-torture/execute/20041124-1.c, 20050316-1.c and
<span class="lineNum">    3162 </span>            :          gcc.c-torture/compile/20011217-1.c.
<span class="lineNum">    3163 </span>            : 
<span class="lineNum">    3164 </span>            :          We also want to use this when accessing a complex or vector which can
<span class="lineNum">    3165 </span>            :          be accessed as a different type too, potentially creating a need for
<span class="lineNum">    3166 </span>            :          type conversion (see PR42196) and when scalarized unions are involved
<span class="lineNum">    3167 </span>            :          in assembler statements (see PR42398).  */
<span class="lineNum">    3168 </span><span class="lineCov">      11089 :       if (!useless_type_conversion_p (type, access-&gt;type))</span>
<span class="lineNum">    3169 </span>            :         {
<span class="lineNum">    3170 </span><span class="lineCov">       9445 :           tree ref;</span>
<span class="lineNum">    3171 </span>            : 
<span class="lineNum">    3172 </span><span class="lineCov">       9445 :           ref = build_ref_for_model (loc, orig_expr, 0, access, gsi, false);</span>
<span class="lineNum">    3173 </span>            : 
<span class="lineNum">    3174 </span><span class="lineCov">       9445 :           if (write)</span>
<span class="lineNum">    3175 </span>            :             {
<span class="lineNum">    3176 </span><span class="lineCov">       2918 :               gassign *stmt;</span>
<span class="lineNum">    3177 </span>            : 
<span class="lineNum">    3178 </span><span class="lineCov">       2918 :               if (access-&gt;grp_partial_lhs)</span>
<span class="lineNum">    3179 </span><span class="lineCov">          6 :                 ref = force_gimple_operand_gsi (gsi, ref, true, NULL_TREE,</span>
<span class="lineNum">    3180 </span>            :                                                  false, GSI_NEW_STMT);
<span class="lineNum">    3181 </span><span class="lineCov">       2918 :               stmt = gimple_build_assign (repl, ref);</span>
<span class="lineNum">    3182 </span><span class="lineCov">       2918 :               gimple_set_location (stmt, loc);</span>
<span class="lineNum">    3183 </span><span class="lineCov">       2918 :               gsi_insert_after (gsi, stmt, GSI_NEW_STMT);</span>
<span class="lineNum">    3184 </span>            :             }
<span class="lineNum">    3185 </span>            :           else
<span class="lineNum">    3186 </span>            :             {
<span class="lineNum">    3187 </span><span class="lineCov">       6527 :               gassign *stmt;</span>
<span class="lineNum">    3188 </span>            : 
<span class="lineNum">    3189 </span><span class="lineCov">       6527 :               if (access-&gt;grp_partial_lhs)</span>
<span class="lineNum">    3190 </span><span class="lineCov">          6 :                 repl = force_gimple_operand_gsi (gsi, repl, true, NULL_TREE,</span>
<span class="lineNum">    3191 </span>            :                                                  true, GSI_SAME_STMT);
<span class="lineNum">    3192 </span><span class="lineCov">       6527 :               stmt = gimple_build_assign (ref, repl);</span>
<span class="lineNum">    3193 </span><span class="lineCov">       6527 :               gimple_set_location (stmt, loc);</span>
<span class="lineNum">    3194 </span><span class="lineCov">       6527 :               gsi_insert_before (gsi, stmt, GSI_SAME_STMT);</span>
<span class="lineNum">    3195 </span>            :             }
<span class="lineNum">    3196 </span>            :         }
<span class="lineNum">    3197 </span>            :       else
<span class="lineNum">    3198 </span><span class="lineCov">       1644 :         *expr = repl;</span>
<span class="lineNum">    3199 </span><span class="lineCov">      11089 :       sra_stats.exprs++;</span>
<span class="lineNum">    3200 </span>            :     }
<span class="lineNum">    3201 </span><span class="lineCov">     100770 :   else if (write &amp;&amp; access-&gt;grp_to_be_debug_replaced)</span>
<span class="lineNum">    3202 </span>            :     {
<span class="lineNum">    3203 </span><span class="lineCov">         56 :       gdebug *ds = gimple_build_debug_bind (get_access_replacement (access),</span>
<span class="lineNum">    3204 </span>            :                                             NULL_TREE,
<span class="lineNum">    3205 </span>            :                                             gsi_stmt (*gsi));
<span class="lineNum">    3206 </span><span class="lineCov">         28 :       gsi_insert_after (gsi, ds, GSI_NEW_STMT);</span>
<span class="lineNum">    3207 </span>            :     }
<span class="lineNum">    3208 </span>            : 
<span class="lineNum">    3209 </span><span class="lineCov">     111859 :   if (access-&gt;first_child)</span>
<span class="lineNum">    3210 </span>            :     {
<span class="lineNum">    3211 </span><span class="lineCov">      97081 :       HOST_WIDE_INT start_offset, chunk_size;</span>
<span class="lineNum">    3212 </span><span class="lineCov">      97081 :       if (bfr</span>
<span class="lineNum">    3213 </span><span class="lineCov">       2810 :           &amp;&amp; tree_fits_uhwi_p (TREE_OPERAND (bfr, 1))</span>
<span class="lineNum">    3214 </span><span class="lineCov">      99891 :           &amp;&amp; tree_fits_uhwi_p (TREE_OPERAND (bfr, 2)))</span>
<span class="lineNum">    3215 </span>            :         {
<span class="lineNum">    3216 </span><span class="lineCov">       2810 :           chunk_size = tree_to_uhwi (TREE_OPERAND (bfr, 1));</span>
<span class="lineNum">    3217 </span><span class="lineCov">       5620 :           start_offset = access-&gt;offset</span>
<span class="lineNum">    3218 </span><span class="lineCov">       2810 :             + tree_to_uhwi (TREE_OPERAND (bfr, 2));</span>
<span class="lineNum">    3219 </span>            :         }
<span class="lineNum">    3220 </span>            :       else
<span class="lineNum">    3221 </span>            :         start_offset = chunk_size = 0;
<span class="lineNum">    3222 </span>            : 
<span class="lineNum">    3223 </span><span class="lineCov">      97081 :       generate_subtree_copies (access-&gt;first_child, orig_expr, access-&gt;offset,</span>
<span class="lineNum">    3224 </span>            :                                start_offset, chunk_size, gsi, write, write,
<span class="lineNum">    3225 </span>            :                                loc);
<span class="lineNum">    3226 </span>            :     }
<span class="lineNum">    3227 </span>            :   return true;
<span class="lineNum">    3228 </span>            : }
<span class="lineNum">    3229 </span>            : 
<span class="lineNum">    3230 </span>            : /* Where scalar replacements of the RHS have been written to when a replacement
<span class="lineNum">    3231 </span>            :    of a LHS of an assigments cannot be direclty loaded from a replacement of
<span class="lineNum">    3232 </span>            :    the RHS. */
<span class="lineNum">    3233 </span>            : enum unscalarized_data_handling { SRA_UDH_NONE,  /* Nothing done so far. */
<span class="lineNum">    3234 </span>            :                                   SRA_UDH_RIGHT, /* Data flushed to the RHS. */
<span class="lineNum">    3235 </span>            :                                   SRA_UDH_LEFT }; /* Data flushed to the LHS. */
<span class="lineNum">    3236 </span>            : 
<span class="lineNum">    3237 </span>            : struct subreplacement_assignment_data
<span class="lineNum">    3238 </span>            : {
<span class="lineNum">    3239 </span>            :   /* Offset of the access representing the lhs of the assignment.  */
<span class="lineNum">    3240 </span>            :   HOST_WIDE_INT left_offset;
<span class="lineNum">    3241 </span>            : 
<span class="lineNum">    3242 </span>            :   /* LHS and RHS of the original assignment.  */
<span class="lineNum">    3243 </span>            :   tree assignment_lhs, assignment_rhs;
<span class="lineNum">    3244 </span>            : 
<span class="lineNum">    3245 </span>            :   /* Access representing the rhs of the whole assignment.  */
<span class="lineNum">    3246 </span>            :   struct access *top_racc;
<span class="lineNum">    3247 </span>            : 
<span class="lineNum">    3248 </span>            :   /* Stmt iterator used for statement insertions after the original assignment.
<span class="lineNum">    3249 </span>            :    It points to the main GSI used to traverse a BB during function body
<span class="lineNum">    3250 </span>            :    modification.  */
<span class="lineNum">    3251 </span>            :   gimple_stmt_iterator *new_gsi;
<span class="lineNum">    3252 </span>            : 
<span class="lineNum">    3253 </span>            :   /* Stmt iterator used for statement insertions before the original
<span class="lineNum">    3254 </span>            :    assignment.  Keeps on pointing to the original statement.  */
<span class="lineNum">    3255 </span>            :   gimple_stmt_iterator old_gsi;
<span class="lineNum">    3256 </span>            : 
<span class="lineNum">    3257 </span>            :   /* Location of the assignment.   */
<span class="lineNum">    3258 </span>            :   location_t loc;
<span class="lineNum">    3259 </span>            : 
<span class="lineNum">    3260 </span>            :   /* Keeps the information whether we have needed to refresh replacements of
<span class="lineNum">    3261 </span>            :    the LHS and from which side of the assignments this takes place.  */
<span class="lineNum">    3262 </span>            :   enum unscalarized_data_handling refreshed;
<span class="lineNum">    3263 </span>            : };
<span class="lineNum">    3264 </span>            : 
<span class="lineNum">    3265 </span>            : /* Store all replacements in the access tree rooted in TOP_RACC either to their
<span class="lineNum">    3266 </span>            :    base aggregate if there are unscalarized data or directly to LHS of the
<span class="lineNum">    3267 </span>            :    statement that is pointed to by GSI otherwise.  */
<a name="3268"><span class="lineNum">    3268 </span>            : </a>
<span class="lineNum">    3269 </span>            : static void
<span class="lineNum">    3270 </span><span class="lineCov">      40291 : handle_unscalarized_data_in_subtree (struct subreplacement_assignment_data *sad)</span>
<span class="lineNum">    3271 </span>            : {
<span class="lineNum">    3272 </span><span class="lineCov">      40291 :   tree src;</span>
<span class="lineNum">    3273 </span><span class="lineCov">      40291 :   if (sad-&gt;top_racc-&gt;grp_unscalarized_data)</span>
<span class="lineNum">    3274 </span>            :     {
<span class="lineNum">    3275 </span><span class="lineCov">       9295 :       src = sad-&gt;assignment_rhs;</span>
<span class="lineNum">    3276 </span><span class="lineCov">       9295 :       sad-&gt;refreshed = SRA_UDH_RIGHT;</span>
<span class="lineNum">    3277 </span>            :     }
<span class="lineNum">    3278 </span>            :   else
<span class="lineNum">    3279 </span>            :     {
<span class="lineNum">    3280 </span><span class="lineCov">      30996 :       src = sad-&gt;assignment_lhs;</span>
<span class="lineNum">    3281 </span><span class="lineCov">      30996 :       sad-&gt;refreshed = SRA_UDH_LEFT;</span>
<span class="lineNum">    3282 </span>            :     }
<span class="lineNum">    3283 </span><span class="lineCov">      40291 :   generate_subtree_copies (sad-&gt;top_racc-&gt;first_child, src,</span>
<span class="lineNum">    3284 </span>            :                            sad-&gt;top_racc-&gt;offset, 0, 0,
<span class="lineNum">    3285 </span>            :                            &amp;sad-&gt;old_gsi, false, false, sad-&gt;loc);
<span class="lineNum">    3286 </span><span class="lineCov">      40291 : }</span>
<span class="lineNum">    3287 </span>            : 
<span class="lineNum">    3288 </span>            : /* Try to generate statements to load all sub-replacements in an access subtree
<span class="lineNum">    3289 </span>            :    formed by children of LACC from scalar replacements in the SAD-&gt;top_racc
<span class="lineNum">    3290 </span>            :    subtree.  If that is not possible, refresh the SAD-&gt;top_racc base aggregate
<span class="lineNum">    3291 </span>            :    and load the accesses from it.  */
<a name="3292"><span class="lineNum">    3292 </span>            : </a>
<span class="lineNum">    3293 </span>            : static void
<span class="lineNum">    3294 </span><span class="lineCov">     389086 : load_assign_lhs_subreplacements (struct access *lacc,</span>
<span class="lineNum">    3295 </span>            :                                  struct subreplacement_assignment_data *sad)
<span class="lineNum">    3296 </span>            : {
<span class="lineNum">    3297 </span><span class="lineCov">    1305973 :   for (lacc = lacc-&gt;first_child; lacc; lacc = lacc-&gt;next_sibling)</span>
<span class="lineNum">    3298 </span>            :     {
<span class="lineNum">    3299 </span><span class="lineCov">     916887 :       HOST_WIDE_INT offset;</span>
<span class="lineNum">    3300 </span><span class="lineCov">     916887 :       offset = lacc-&gt;offset - sad-&gt;left_offset + sad-&gt;top_racc-&gt;offset;</span>
<span class="lineNum">    3301 </span>            : 
<span class="lineNum">    3302 </span><span class="lineCov">     916887 :       if (lacc-&gt;grp_to_be_replaced)</span>
<span class="lineNum">    3303 </span>            :         {
<span class="lineNum">    3304 </span><span class="lineCov">     863558 :           struct access *racc;</span>
<span class="lineNum">    3305 </span><span class="lineCov">     863558 :           gassign *stmt;</span>
<span class="lineNum">    3306 </span><span class="lineCov">     863558 :           tree rhs;</span>
<span class="lineNum">    3307 </span>            : 
<span class="lineNum">    3308 </span><span class="lineCov">     863558 :           racc = find_access_in_subtree (sad-&gt;top_racc, offset, lacc-&gt;size);</span>
<span class="lineNum">    3309 </span><span class="lineCov">     863558 :           if (racc &amp;&amp; racc-&gt;grp_to_be_replaced)</span>
<span class="lineNum">    3310 </span>            :             {
<span class="lineNum">    3311 </span><span class="lineCov">     855967 :               rhs = get_access_replacement (racc);</span>
<span class="lineNum">    3312 </span><span class="lineCov">     855967 :               if (!useless_type_conversion_p (lacc-&gt;type, racc-&gt;type))</span>
<span class="lineNum">    3313 </span><span class="lineCov">          7 :                 rhs = fold_build1_loc (sad-&gt;loc, VIEW_CONVERT_EXPR,</span>
<span class="lineNum">    3314 </span>            :                                        lacc-&gt;type, rhs);
<span class="lineNum">    3315 </span>            : 
<span class="lineNum">    3316 </span><span class="lineCov">     855967 :               if (racc-&gt;grp_partial_lhs &amp;&amp; lacc-&gt;grp_partial_lhs)</span>
<span class="lineNum">    3317 </span><span class="lineNoCov">          0 :                 rhs = force_gimple_operand_gsi (&amp;sad-&gt;old_gsi, rhs, true,</span>
<span class="lineNum">    3318 </span>            :                                                 NULL_TREE, true, GSI_SAME_STMT);
<span class="lineNum">    3319 </span>            :             }
<span class="lineNum">    3320 </span>            :           else
<span class="lineNum">    3321 </span>            :             {
<span class="lineNum">    3322 </span>            :               /* No suitable access on the right hand side, need to load from
<span class="lineNum">    3323 </span>            :                  the aggregate.  See if we have to update it first... */
<span class="lineNum">    3324 </span><span class="lineCov">       7591 :               if (sad-&gt;refreshed == SRA_UDH_NONE)</span>
<span class="lineNum">    3325 </span><span class="lineCov">       5198 :                 handle_unscalarized_data_in_subtree (sad);</span>
<span class="lineNum">    3326 </span>            : 
<span class="lineNum">    3327 </span><span class="lineCov">       7591 :               if (sad-&gt;refreshed == SRA_UDH_LEFT)</span>
<span class="lineNum">    3328 </span><span class="lineCov">        192 :                 rhs = build_ref_for_model (sad-&gt;loc, sad-&gt;assignment_lhs,</span>
<span class="lineNum">    3329 </span><span class="lineCov">         96 :                                            lacc-&gt;offset - sad-&gt;left_offset,</span>
<span class="lineNum">    3330 </span>            :                                            lacc, sad-&gt;new_gsi, true);
<span class="lineNum">    3331 </span>            :               else
<span class="lineNum">    3332 </span><span class="lineCov">      14990 :                 rhs = build_ref_for_model (sad-&gt;loc, sad-&gt;assignment_rhs,</span>
<span class="lineNum">    3333 </span><span class="lineCov">       7495 :                                            lacc-&gt;offset - sad-&gt;left_offset,</span>
<span class="lineNum">    3334 </span>            :                                            lacc, sad-&gt;new_gsi, true);
<span class="lineNum">    3335 </span><span class="lineCov">       7591 :               if (lacc-&gt;grp_partial_lhs)</span>
<span class="lineNum">    3336 </span><span class="lineCov">          1 :                 rhs = force_gimple_operand_gsi (sad-&gt;new_gsi,</span>
<span class="lineNum">    3337 </span>            :                                                 rhs, true, NULL_TREE,
<span class="lineNum">    3338 </span>            :                                                 false, GSI_NEW_STMT);
<span class="lineNum">    3339 </span>            :             }
<span class="lineNum">    3340 </span>            : 
<span class="lineNum">    3341 </span><span class="lineCov">     863558 :           stmt = gimple_build_assign (get_access_replacement (lacc), rhs);</span>
<span class="lineNum">    3342 </span><span class="lineCov">     863558 :           gsi_insert_after (sad-&gt;new_gsi, stmt, GSI_NEW_STMT);</span>
<span class="lineNum">    3343 </span><span class="lineCov">     863558 :           gimple_set_location (stmt, sad-&gt;loc);</span>
<span class="lineNum">    3344 </span><span class="lineCov">     863558 :           update_stmt (stmt);</span>
<span class="lineNum">    3345 </span><span class="lineCov">     863558 :           sra_stats.subreplacements++;</span>
<span class="lineNum">    3346 </span>            :         }
<span class="lineNum">    3347 </span>            :       else
<span class="lineNum">    3348 </span>            :         {
<span class="lineNum">    3349 </span><span class="lineCov">      53329 :           if (sad-&gt;refreshed == SRA_UDH_NONE</span>
<span class="lineNum">    3350 </span><span class="lineCov">       2323 :               &amp;&amp; lacc-&gt;grp_read &amp;&amp; !lacc-&gt;grp_covered)</span>
<span class="lineNum">    3351 </span><span class="lineNoCov">          0 :             handle_unscalarized_data_in_subtree (sad);</span>
<span class="lineNum">    3352 </span>            : 
<span class="lineNum">    3353 </span><span class="lineCov">      53329 :           if (lacc &amp;&amp; lacc-&gt;grp_to_be_debug_replaced)</span>
<span class="lineNum">    3354 </span>            :             {
<span class="lineNum">    3355 </span><span class="lineCov">      38405 :               gdebug *ds;</span>
<span class="lineNum">    3356 </span><span class="lineCov">      38405 :               tree drhs;</span>
<span class="lineNum">    3357 </span><span class="lineCov">      38405 :               struct access *racc = find_access_in_subtree (sad-&gt;top_racc,</span>
<span class="lineNum">    3358 </span>            :                                                             offset,
<span class="lineNum">    3359 </span>            :                                                             lacc-&gt;size);
<span class="lineNum">    3360 </span>            : 
<span class="lineNum">    3361 </span><span class="lineCov">      38405 :               if (racc &amp;&amp; racc-&gt;grp_to_be_replaced)</span>
<span class="lineNum">    3362 </span>            :                 {
<span class="lineNum">    3363 </span><span class="lineCov">      38403 :                   if (racc-&gt;grp_write || constant_decl_p (racc-&gt;base))</span>
<span class="lineNum">    3364 </span><span class="lineCov">      37554 :                     drhs = get_access_replacement (racc);</span>
<span class="lineNum">    3365 </span>            :                   else
<span class="lineNum">    3366 </span>            :                     drhs = NULL;
<span class="lineNum">    3367 </span>            :                 }
<span class="lineNum">    3368 </span><span class="lineCov">          2 :               else if (sad-&gt;refreshed == SRA_UDH_LEFT)</span>
<span class="lineNum">    3369 </span><span class="lineNoCov">          0 :                 drhs = build_debug_ref_for_model (sad-&gt;loc, lacc-&gt;base,</span>
<span class="lineNum">    3370 </span>            :                                                   lacc-&gt;offset, lacc);
<span class="lineNum">    3371 </span><span class="lineCov">          2 :               else if (sad-&gt;refreshed == SRA_UDH_RIGHT)</span>
<span class="lineNum">    3372 </span><span class="lineCov">          2 :                 drhs = build_debug_ref_for_model (sad-&gt;loc, sad-&gt;top_racc-&gt;base,</span>
<span class="lineNum">    3373 </span>            :                                                   offset, lacc);
<span class="lineNum">    3374 </span>            :               else
<span class="lineNum">    3375 </span>            :                 drhs = NULL_TREE;
<span class="lineNum">    3376 </span><span class="lineCov">      37556 :               if (drhs</span>
<span class="lineNum">    3377 </span><span class="lineCov">      37556 :                   &amp;&amp; !useless_type_conversion_p (lacc-&gt;type, TREE_TYPE (drhs)))</span>
<span class="lineNum">    3378 </span><span class="lineCov">        328 :                 drhs = fold_build1_loc (sad-&gt;loc, VIEW_CONVERT_EXPR,</span>
<span class="lineNum">    3379 </span>            :                                         lacc-&gt;type, drhs);
<span class="lineNum">    3380 </span><span class="lineCov">      76810 :               ds = gimple_build_debug_bind (get_access_replacement (lacc),</span>
<span class="lineNum">    3381 </span>            :                                             drhs, gsi_stmt (sad-&gt;old_gsi));
<span class="lineNum">    3382 </span><span class="lineCov">      38405 :               gsi_insert_after (sad-&gt;new_gsi, ds, GSI_NEW_STMT);</span>
<span class="lineNum">    3383 </span>            :             }
<span class="lineNum">    3384 </span>            :         }
<span class="lineNum">    3385 </span>            : 
<span class="lineNum">    3386 </span><span class="lineCov">     916887 :       if (lacc-&gt;first_child)</span>
<span class="lineNum">    3387 </span><span class="lineCov">       3333 :         load_assign_lhs_subreplacements (lacc, sad);</span>
<span class="lineNum">    3388 </span>            :     }
<span class="lineNum">    3389 </span><span class="lineCov">     389086 : }</span>
<span class="lineNum">    3390 </span>            : 
<span class="lineNum">    3391 </span>            : /* Result code for SRA assignment modification.  */
<span class="lineNum">    3392 </span>            : enum assignment_mod_result { SRA_AM_NONE,       /* nothing done for the stmt */
<span class="lineNum">    3393 </span>            :                              SRA_AM_MODIFIED,  /* stmt changed but not
<span class="lineNum">    3394 </span>            :                                                   removed */
<span class="lineNum">    3395 </span>            :                              SRA_AM_REMOVED };  /* stmt eliminated */
<span class="lineNum">    3396 </span>            : 
<span class="lineNum">    3397 </span>            : /* Modify assignments with a CONSTRUCTOR on their RHS.  STMT contains a pointer
<span class="lineNum">    3398 </span>            :    to the assignment and GSI is the statement iterator pointing at it.  Returns
<span class="lineNum">    3399 </span>            :    the same values as sra_modify_assign.  */
<a name="3400"><span class="lineNum">    3400 </span>            : </a>
<span class="lineNum">    3401 </span>            : static enum assignment_mod_result
<span class="lineNum">    3402 </span><span class="lineCov">    1343551 : sra_modify_constructor_assign (gimple *stmt, gimple_stmt_iterator *gsi)</span>
<span class="lineNum">    3403 </span>            : {
<span class="lineNum">    3404 </span><span class="lineCov">    1343551 :   tree lhs = gimple_assign_lhs (stmt);</span>
<span class="lineNum">    3405 </span><span class="lineCov">    1343551 :   struct access *acc = get_access_for_expr (lhs);</span>
<span class="lineNum">    3406 </span><span class="lineCov">    1343551 :   if (!acc)</span>
<span class="lineNum">    3407 </span>            :     return SRA_AM_NONE;
<span class="lineNum">    3408 </span><span class="lineCov">     612469 :   location_t loc = gimple_location (stmt);</span>
<span class="lineNum">    3409 </span>            : 
<span class="lineNum">    3410 </span><span class="lineCov">     612469 :   if (gimple_clobber_p (stmt))</span>
<span class="lineNum">    3411 </span>            :     {
<span class="lineNum">    3412 </span>            :       /* Clobber the replacement variable.  */
<span class="lineNum">    3413 </span><span class="lineCov">     531868 :       clobber_subtree (acc, gsi, !acc-&gt;grp_covered, loc);</span>
<span class="lineNum">    3414 </span>            :       /* Remove clobbers of fully scalarized variables, they are dead.  */
<span class="lineNum">    3415 </span><span class="lineCov">     531868 :       if (acc-&gt;grp_covered)</span>
<span class="lineNum">    3416 </span>            :         {
<span class="lineNum">    3417 </span><span class="lineCov">     449797 :           unlink_stmt_vdef (stmt);</span>
<span class="lineNum">    3418 </span><span class="lineCov">     449797 :           gsi_remove (gsi, true);</span>
<span class="lineNum">    3419 </span><span class="lineCov">     449797 :           release_defs (stmt);</span>
<span class="lineNum">    3420 </span><span class="lineCov">     449797 :           return SRA_AM_REMOVED;</span>
<span class="lineNum">    3421 </span>            :         }
<span class="lineNum">    3422 </span>            :       else
<span class="lineNum">    3423 </span>            :         return SRA_AM_MODIFIED;
<span class="lineNum">    3424 </span>            :     }
<span class="lineNum">    3425 </span>            : 
<span class="lineNum">    3426 </span><span class="lineCov">      80601 :   if (CONSTRUCTOR_NELTS (gimple_assign_rhs1 (stmt)) &gt; 0)</span>
<span class="lineNum">    3427 </span>            :     {
<span class="lineNum">    3428 </span>            :       /* I have never seen this code path trigger but if it can happen the
<span class="lineNum">    3429 </span>            :          following should handle it gracefully.  */
<span class="lineNum">    3430 </span><span class="lineNoCov">          0 :       if (access_has_children_p (acc))</span>
<span class="lineNum">    3431 </span><span class="lineNoCov">          0 :         generate_subtree_copies (acc-&gt;first_child, lhs, acc-&gt;offset, 0, 0, gsi,</span>
<span class="lineNum">    3432 </span>            :                                  true, true, loc);
<span class="lineNum">    3433 </span><span class="lineNoCov">          0 :       return SRA_AM_MODIFIED;</span>
<span class="lineNum">    3434 </span>            :     }
<span class="lineNum">    3435 </span>            : 
<span class="lineNum">    3436 </span><span class="lineCov">      80601 :   if (acc-&gt;grp_covered)</span>
<span class="lineNum">    3437 </span>            :     {
<span class="lineNum">    3438 </span><span class="lineCov">      56310 :       init_subtree_with_zero (acc, gsi, false, loc);</span>
<span class="lineNum">    3439 </span><span class="lineCov">      56310 :       unlink_stmt_vdef (stmt);</span>
<span class="lineNum">    3440 </span><span class="lineCov">      56310 :       gsi_remove (gsi, true);</span>
<span class="lineNum">    3441 </span><span class="lineCov">      56310 :       release_defs (stmt);</span>
<span class="lineNum">    3442 </span><span class="lineCov">      56310 :       return SRA_AM_REMOVED;</span>
<span class="lineNum">    3443 </span>            :     }
<span class="lineNum">    3444 </span>            :   else
<span class="lineNum">    3445 </span>            :     {
<span class="lineNum">    3446 </span><span class="lineCov">      24291 :       init_subtree_with_zero (acc, gsi, true, loc);</span>
<span class="lineNum">    3447 </span><span class="lineCov">      24291 :       return SRA_AM_MODIFIED;</span>
<span class="lineNum">    3448 </span>            :     }
<span class="lineNum">    3449 </span>            : }
<span class="lineNum">    3450 </span>            : 
<span class="lineNum">    3451 </span>            : /* Create and return a new suitable default definition SSA_NAME for RACC which
<span class="lineNum">    3452 </span>            :    is an access describing an uninitialized part of an aggregate that is being
<span class="lineNum">    3453 </span>            :    loaded.  */
<a name="3454"><span class="lineNum">    3454 </span>            : </a>
<span class="lineNum">    3455 </span>            : static tree
<span class="lineNum">    3456 </span><span class="lineCov">        433 : get_repl_default_def_ssa_name (struct access *racc)</span>
<span class="lineNum">    3457 </span>            : {
<span class="lineNum">    3458 </span><span class="lineCov">        433 :   gcc_checking_assert (!racc-&gt;grp_to_be_replaced</span>
<span class="lineNum">    3459 </span>            :                        &amp;&amp; !racc-&gt;grp_to_be_debug_replaced);
<span class="lineNum">    3460 </span><span class="lineCov">        433 :   if (!racc-&gt;replacement_decl)</span>
<span class="lineNum">    3461 </span><span class="lineCov">        433 :     racc-&gt;replacement_decl = create_access_replacement (racc);</span>
<span class="lineNum">    3462 </span><span class="lineCov">        433 :   return get_or_create_ssa_default_def (cfun, racc-&gt;replacement_decl);</span>
<span class="lineNum">    3463 </span>            : }
<span class="lineNum">    3464 </span>            : 
<span class="lineNum">    3465 </span>            : /* Examine both sides of the assignment statement pointed to by STMT, replace
<span class="lineNum">    3466 </span>            :    them with a scalare replacement if there is one and generate copying of
<span class="lineNum">    3467 </span>            :    replacements if scalarized aggregates have been used in the assignment.  GSI
<span class="lineNum">    3468 </span>            :    is used to hold generated statements for type conversions and subtree
<span class="lineNum">    3469 </span>            :    copying.  */
<a name="3470"><span class="lineNum">    3470 </span>            : </a>
<span class="lineNum">    3471 </span>            : static enum assignment_mod_result
<span class="lineNum">    3472 </span><span class="lineCov">   12563825 : sra_modify_assign (gimple *stmt, gimple_stmt_iterator *gsi)</span>
<span class="lineNum">    3473 </span>            : {
<span class="lineNum">    3474 </span><span class="lineCov">   12563825 :   struct access *lacc, *racc;</span>
<span class="lineNum">    3475 </span><span class="lineCov">   12563825 :   tree lhs, rhs;</span>
<span class="lineNum">    3476 </span><span class="lineCov">   12563825 :   bool modify_this_stmt = false;</span>
<span class="lineNum">    3477 </span><span class="lineCov">   12563825 :   bool force_gimple_rhs = false;</span>
<span class="lineNum">    3478 </span><span class="lineCov">   12563825 :   location_t loc;</span>
<span class="lineNum">    3479 </span><span class="lineCov">   12563825 :   gimple_stmt_iterator orig_gsi = *gsi;</span>
<span class="lineNum">    3480 </span>            : 
<span class="lineNum">    3481 </span><span class="lineCov">   12563825 :   if (!gimple_assign_single_p (stmt))</span>
<span class="lineNum">    3482 </span>            :     return SRA_AM_NONE;
<span class="lineNum">    3483 </span><span class="lineCov">   10124407 :   lhs = gimple_assign_lhs (stmt);</span>
<span class="lineNum">    3484 </span><span class="lineCov">   10124407 :   rhs = gimple_assign_rhs1 (stmt);</span>
<span class="lineNum">    3485 </span>            : 
<span class="lineNum">    3486 </span><span class="lineCov">   10124407 :   if (TREE_CODE (rhs) == CONSTRUCTOR)</span>
<span class="lineNum">    3487 </span><span class="lineCov">    1343551 :     return sra_modify_constructor_assign (stmt, gsi);</span>
<span class="lineNum">    3488 </span>            : 
<span class="lineNum">    3489 </span><span class="lineCov">    8780856 :   if (TREE_CODE (rhs) == REALPART_EXPR || TREE_CODE (lhs) == REALPART_EXPR</span>
<span class="lineNum">    3490 </span><span class="lineCov">    8779080 :       || TREE_CODE (rhs) == IMAGPART_EXPR || TREE_CODE (lhs) == IMAGPART_EXPR</span>
<span class="lineNum">    3491 </span><span class="lineCov">    8777114 :       || TREE_CODE (rhs) == BIT_FIELD_REF || TREE_CODE (lhs) == BIT_FIELD_REF)</span>
<span class="lineNum">    3492 </span>            :     {
<span class="lineNum">    3493 </span><span class="lineCov">      18588 :       modify_this_stmt = sra_modify_expr (gimple_assign_rhs1_ptr (stmt),</span>
<span class="lineNum">    3494 </span>            :                                           gsi, false);
<span class="lineNum">    3495 </span><span class="lineCov">       9294 :       modify_this_stmt |= sra_modify_expr (gimple_assign_lhs_ptr (stmt),</span>
<span class="lineNum">    3496 </span>            :                                            gsi, true);
<span class="lineNum">    3497 </span><span class="lineCov">      14136 :       return modify_this_stmt ? SRA_AM_MODIFIED : SRA_AM_NONE;</span>
<span class="lineNum">    3498 </span>            :     }
<span class="lineNum">    3499 </span>            : 
<span class="lineNum">    3500 </span><span class="lineCov">    8771562 :   lacc = get_access_for_expr (lhs);</span>
<span class="lineNum">    3501 </span><span class="lineCov">    8771562 :   racc = get_access_for_expr (rhs);</span>
<span class="lineNum">    3502 </span><span class="lineCov">    8771562 :   if (!lacc &amp;&amp; !racc)</span>
<span class="lineNum">    3503 </span>            :     return SRA_AM_NONE;
<span class="lineNum">    3504 </span>            :   /* Avoid modifying initializations of constant-pool replacements.  */
<span class="lineNum">    3505 </span><span class="lineCov">    3427331 :   if (racc &amp;&amp; (racc-&gt;replacement_decl == lhs))</span>
<span class="lineNum">    3506 </span>            :     return SRA_AM_NONE;
<span class="lineNum">    3507 </span>            : 
<span class="lineNum">    3508 </span><span class="lineCov">    3426937 :   loc = gimple_location (stmt);</span>
<span class="lineNum">    3509 </span><span class="lineCov">    3426937 :   if (lacc &amp;&amp; lacc-&gt;grp_to_be_replaced)</span>
<span class="lineNum">    3510 </span>            :     {
<span class="lineNum">    3511 </span><span class="lineCov">     989484 :       lhs = get_access_replacement (lacc);</span>
<span class="lineNum">    3512 </span><span class="lineCov">     989484 :       gimple_assign_set_lhs (stmt, lhs);</span>
<span class="lineNum">    3513 </span><span class="lineCov">     989484 :       modify_this_stmt = true;</span>
<span class="lineNum">    3514 </span><span class="lineCov">     989484 :       if (lacc-&gt;grp_partial_lhs)</span>
<span class="lineNum">    3515 </span><span class="lineCov">         56 :         force_gimple_rhs = true;</span>
<span class="lineNum">    3516 </span><span class="lineCov">     989484 :       sra_stats.exprs++;</span>
<span class="lineNum">    3517 </span>            :     }
<span class="lineNum">    3518 </span>            : 
<span class="lineNum">    3519 </span><span class="lineCov">    3426937 :   if (racc &amp;&amp; racc-&gt;grp_to_be_replaced)</span>
<span class="lineNum">    3520 </span>            :     {
<span class="lineNum">    3521 </span><span class="lineCov">    1422002 :       rhs = get_access_replacement (racc);</span>
<span class="lineNum">    3522 </span><span class="lineCov">    1422002 :       modify_this_stmt = true;</span>
<span class="lineNum">    3523 </span><span class="lineCov">    1422002 :       if (racc-&gt;grp_partial_lhs)</span>
<span class="lineNum">    3524 </span><span class="lineCov">        271 :         force_gimple_rhs = true;</span>
<span class="lineNum">    3525 </span><span class="lineCov">    1422002 :       sra_stats.exprs++;</span>
<span class="lineNum">    3526 </span>            :     }
<span class="lineNum">    3527 </span><span class="lineCov">    2004935 :   else if (racc</span>
<span class="lineNum">    3528 </span>            :            &amp;&amp; !racc-&gt;grp_unscalarized_data
<span class="lineNum">    3529 </span><span class="lineCov">     671289 :            &amp;&amp; !racc-&gt;grp_unscalarizable_region</span>
<span class="lineNum">    3530 </span><span class="lineCov">     632981 :            &amp;&amp; TREE_CODE (lhs) == SSA_NAME</span>
<span class="lineNum">    3531 </span><span class="lineCov">    2005431 :            &amp;&amp; !access_has_replacements_p (racc))</span>
<span class="lineNum">    3532 </span>            :     {
<span class="lineNum">    3533 </span><span class="lineCov">        433 :       rhs = get_repl_default_def_ssa_name (racc);</span>
<span class="lineNum">    3534 </span><span class="lineCov">        433 :       modify_this_stmt = true;</span>
<span class="lineNum">    3535 </span><span class="lineCov">        433 :       sra_stats.exprs++;</span>
<span class="lineNum">    3536 </span>            :     }
<span class="lineNum">    3537 </span>            : 
<span class="lineNum">    3538 </span><span class="lineCov">    3426937 :   if (modify_this_stmt)</span>
<span class="lineNum">    3539 </span>            :     {
<span class="lineNum">    3540 </span><span class="lineCov">    2317812 :       if (!useless_type_conversion_p (TREE_TYPE (lhs), TREE_TYPE (rhs)))</span>
<span class="lineNum">    3541 </span>            :         {
<span class="lineNum">    3542 </span>            :           /* If we can avoid creating a VIEW_CONVERT_EXPR do so.
<span class="lineNum">    3543 </span>            :              ???  This should move to fold_stmt which we simply should
<span class="lineNum">    3544 </span>            :              call after building a VIEW_CONVERT_EXPR here.  */
<span class="lineNum">    3545 </span><span class="lineCov">     360253 :           if (AGGREGATE_TYPE_P (TREE_TYPE (lhs))</span>
<span class="lineNum">    3546 </span><span class="lineCov">     171165 :               &amp;&amp; !contains_bitfld_component_ref_p (lhs))</span>
<span class="lineNum">    3547 </span>            :             {
<span class="lineNum">    3548 </span><span class="lineCov">      51092 :               lhs = build_ref_for_model (loc, lhs, 0, racc, gsi, false);</span>
<span class="lineNum">    3549 </span><span class="lineCov">      51092 :               gimple_assign_set_lhs (stmt, lhs);</span>
<span class="lineNum">    3550 </span>            :             }
<span class="lineNum">    3551 </span><span class="lineCov">     206971 :           else if (AGGREGATE_TYPE_P (TREE_TYPE (rhs))</span>
<span class="lineNum">    3552 </span><span class="lineCov">     102434 :                    &amp;&amp; !contains_vce_or_bfcref_p (rhs))</span>
<span class="lineNum">    3553 </span><span class="lineCov">      33101 :             rhs = build_ref_for_model (loc, rhs, 0, lacc, gsi, false);</span>
<span class="lineNum">    3554 </span>            : 
<span class="lineNum">    3555 </span><span class="lineCov">     120107 :           if (!useless_type_conversion_p (TREE_TYPE (lhs), TREE_TYPE (rhs)))</span>
<span class="lineNum">    3556 </span>            :             {
<span class="lineNum">    3557 </span><span class="lineCov">      35914 :               rhs = fold_build1_loc (loc, VIEW_CONVERT_EXPR, TREE_TYPE (lhs),</span>
<span class="lineNum">    3558 </span>            :                                      rhs);
<span class="lineNum">    3559 </span><span class="lineCov">      35914 :               if (is_gimple_reg_type (TREE_TYPE (lhs))</span>
<span class="lineNum">    3560 </span><span class="lineCov">      35914 :                   &amp;&amp; TREE_CODE (lhs) != SSA_NAME)</span>
<span class="lineNum">    3561 </span>            :                 force_gimple_rhs = true;
<span class="lineNum">    3562 </span>            :             }
<span class="lineNum">    3563 </span>            :         }
<span class="lineNum">    3564 </span>            :     }
<span class="lineNum">    3565 </span>            : 
<span class="lineNum">    3566 </span><span class="lineCov">    3426937 :   if (lacc &amp;&amp; lacc-&gt;grp_to_be_debug_replaced)</span>
<span class="lineNum">    3567 </span>            :     {
<span class="lineNum">    3568 </span><span class="lineCov">      43884 :       tree dlhs = get_access_replacement (lacc);</span>
<span class="lineNum">    3569 </span><span class="lineCov">      43884 :       tree drhs = unshare_expr (rhs);</span>
<span class="lineNum">    3570 </span><span class="lineCov">      43884 :       if (!useless_type_conversion_p (TREE_TYPE (dlhs), TREE_TYPE (drhs)))</span>
<span class="lineNum">    3571 </span>            :         {
<span class="lineNum">    3572 </span><span class="lineCov">          6 :           if (AGGREGATE_TYPE_P (TREE_TYPE (drhs))</span>
<span class="lineNum">    3573 </span><span class="lineCov">          3 :               &amp;&amp; !contains_vce_or_bfcref_p (drhs))</span>
<span class="lineNum">    3574 </span><span class="lineCov">          1 :             drhs = build_debug_ref_for_model (loc, drhs, 0, lacc);</span>
<span class="lineNum">    3575 </span><span class="lineCov">          2 :           if (drhs</span>
<span class="lineNum">    3576 </span><span class="lineCov">          4 :               &amp;&amp; !useless_type_conversion_p (TREE_TYPE (dlhs),</span>
<span class="lineNum">    3577 </span><span class="lineCov">          2 :                                              TREE_TYPE (drhs)))</span>
<span class="lineNum">    3578 </span><span class="lineCov">          2 :             drhs = fold_build1_loc (loc, VIEW_CONVERT_EXPR,</span>
<span class="lineNum">    3579 </span><span class="lineCov">          1 :                                     TREE_TYPE (dlhs), drhs);</span>
<span class="lineNum">    3580 </span>            :         }
<span class="lineNum">    3581 </span><span class="lineCov">      43884 :       gdebug *ds = gimple_build_debug_bind (dlhs, drhs, stmt);</span>
<span class="lineNum">    3582 </span><span class="lineCov">      43884 :       gsi_insert_before (gsi, ds, GSI_SAME_STMT);</span>
<span class="lineNum">    3583 </span>            :     }
<span class="lineNum">    3584 </span>            : 
<span class="lineNum">    3585 </span>            :   /* From this point on, the function deals with assignments in between
<span class="lineNum">    3586 </span>            :      aggregates when at least one has scalar reductions of some of its
<span class="lineNum">    3587 </span>            :      components.  There are three possible scenarios: Both the LHS and RHS have
<span class="lineNum">    3588 </span>            :      to-be-scalarized components, 2) only the RHS has or 3) only the LHS has.
<span class="lineNum">    3589 </span>            : 
<span class="lineNum">    3590 </span>            :      In the first case, we would like to load the LHS components from RHS
<span class="lineNum">    3591 </span>            :      components whenever possible.  If that is not possible, we would like to
<span class="lineNum">    3592 </span>            :      read it directly from the RHS (after updating it by storing in it its own
<span class="lineNum">    3593 </span>            :      components).  If there are some necessary unscalarized data in the LHS,
<span class="lineNum">    3594 </span>            :      those will be loaded by the original assignment too.  If neither of these
<span class="lineNum">    3595 </span>            :      cases happen, the original statement can be removed.  Most of this is done
<span class="lineNum">    3596 </span>            :      by load_assign_lhs_subreplacements.
<span class="lineNum">    3597 </span>            : 
<span class="lineNum">    3598 </span>            :      In the second case, we would like to store all RHS scalarized components
<span class="lineNum">    3599 </span>            :      directly into LHS and if they cover the aggregate completely, remove the
<span class="lineNum">    3600 </span>            :      statement too.  In the third case, we want the LHS components to be loaded
<span class="lineNum">    3601 </span>            :      directly from the RHS (DSE will remove the original statement if it
<span class="lineNum">    3602 </span>            :      becomes redundant).
<span class="lineNum">    3603 </span>            : 
<span class="lineNum">    3604 </span>            :      This is a bit complex but manageable when types match and when unions do
<span class="lineNum">    3605 </span>            :      not cause confusion in a way that we cannot really load a component of LHS
<span class="lineNum">    3606 </span>            :      from the RHS or vice versa (the access representing this level can have
<span class="lineNum">    3607 </span>            :      subaccesses that are accessible only through a different union field at a
<span class="lineNum">    3608 </span>            :      higher level - different from the one used in the examined expression).
<span class="lineNum">    3609 </span>            :      Unions are fun.
<span class="lineNum">    3610 </span>            : 
<span class="lineNum">    3611 </span>            :      Therefore, I specially handle a fourth case, happening when there is a
<span class="lineNum">    3612 </span>            :      specific type cast or it is impossible to locate a scalarized subaccess on
<span class="lineNum">    3613 </span>            :      the other side of the expression.  If that happens, I simply &quot;refresh&quot; the
<span class="lineNum">    3614 </span>            :      RHS by storing in it is scalarized components leave the original statement
<span class="lineNum">    3615 </span>            :      there to do the copying and then load the scalar replacements of the LHS.
<span class="lineNum">    3616 </span>            :      This is what the first branch does.  */
<span class="lineNum">    3617 </span>            : 
<span class="lineNum">    3618 </span><span class="lineCov">    3426937 :   if (modify_this_stmt</span>
<span class="lineNum">    3619 </span><span class="lineCov">    2218250 :       || gimple_has_volatile_ops (stmt)</span>
<span class="lineNum">    3620 </span><span class="lineCov">    1108994 :       || contains_vce_or_bfcref_p (rhs)</span>
<span class="lineNum">    3621 </span><span class="lineCov">     983268 :       || contains_vce_or_bfcref_p (lhs)</span>
<span class="lineNum">    3622 </span><span class="lineCov">    4400917 :       || stmt_ends_bb_p (stmt))</span>
<span class="lineNum">    3623 </span>            :     {
<span class="lineNum">    3624 </span>            :       /* No need to copy into a constant-pool, it comes pre-initialized.  */
<span class="lineNum">    3625 </span><span class="lineCov">    2512417 :       if (access_has_children_p (racc) &amp;&amp; !constant_decl_p (racc-&gt;base))</span>
<span class="lineNum">    3626 </span><span class="lineCov">      10575 :         generate_subtree_copies (racc-&gt;first_child, rhs, racc-&gt;offset, 0, 0,</span>
<span class="lineNum">    3627 </span>            :                                  gsi, false, false, loc);
<span class="lineNum">    3628 </span><span class="lineCov">    2501842 :       if (access_has_children_p (lacc))</span>
<span class="lineNum">    3629 </span>            :         {
<span class="lineNum">    3630 </span><span class="lineCov">     163813 :           gimple_stmt_iterator alt_gsi = gsi_none ();</span>
<span class="lineNum">    3631 </span><span class="lineCov">     163813 :           if (stmt_ends_bb_p (stmt))</span>
<span class="lineNum">    3632 </span>            :             {
<span class="lineNum">    3633 </span><span class="lineCov">      95858 :               alt_gsi = gsi_start_edge (single_non_eh_succ (gsi_bb (*gsi)));</span>
<span class="lineNum">    3634 </span><span class="lineCov">      47929 :               gsi = &amp;alt_gsi;</span>
<span class="lineNum">    3635 </span>            :             }
<span class="lineNum">    3636 </span><span class="lineCov">     163813 :           generate_subtree_copies (lacc-&gt;first_child, lhs, lacc-&gt;offset, 0, 0,</span>
<span class="lineNum">    3637 </span>            :                                    gsi, true, true, loc);
<span class="lineNum">    3638 </span>            :         }
<span class="lineNum">    3639 </span><span class="lineCov">    2501842 :       sra_stats.separate_lhs_rhs_handling++;</span>
<span class="lineNum">    3640 </span>            : 
<span class="lineNum">    3641 </span>            :       /* This gimplification must be done after generate_subtree_copies,
<span class="lineNum">    3642 </span>            :          lest we insert the subtree copies in the middle of the gimplified
<span class="lineNum">    3643 </span>            :          sequence.  */
<span class="lineNum">    3644 </span><span class="lineCov">    2501842 :       if (force_gimple_rhs)</span>
<span class="lineNum">    3645 </span><span class="lineCov">      18579 :         rhs = force_gimple_operand_gsi (&amp;orig_gsi, rhs, true, NULL_TREE,</span>
<span class="lineNum">    3646 </span>            :                                         true, GSI_SAME_STMT);
<span class="lineNum">    3647 </span><span class="lineCov">    2501842 :       if (gimple_assign_rhs1 (stmt) != rhs)</span>
<span class="lineNum">    3648 </span>            :         {
<span class="lineNum">    3649 </span><span class="lineCov">    1473766 :           modify_this_stmt = true;</span>
<span class="lineNum">    3650 </span><span class="lineCov">    1473766 :           gimple_assign_set_rhs_from_tree (&amp;orig_gsi, rhs);</span>
<span class="lineNum">    3651 </span><span class="lineCov">    2947532 :           gcc_assert (stmt == gsi_stmt (orig_gsi));</span>
<span class="lineNum">    3652 </span>            :         }
<span class="lineNum">    3653 </span>            : 
<span class="lineNum">    3654 </span><span class="lineCov">    2685872 :       return modify_this_stmt ? SRA_AM_MODIFIED : SRA_AM_NONE;</span>
<span class="lineNum">    3655 </span>            :     }
<span class="lineNum">    3656 </span>            :   else
<span class="lineNum">    3657 </span>            :     {
<span class="lineNum">    3658 </span><span class="lineCov">     925095 :       if (access_has_children_p (lacc)</span>
<span class="lineNum">    3659 </span><span class="lineCov">     508865 :           &amp;&amp; access_has_children_p (racc)</span>
<span class="lineNum">    3660 </span>            :           /* When an access represents an unscalarizable region, it usually
<span class="lineNum">    3661 </span>            :              represents accesses with variable offset and thus must not be used
<span class="lineNum">    3662 </span>            :              to generate new memory accesses.  */
<span class="lineNum">    3663 </span><span class="lineCov">     385762 :           &amp;&amp; !lacc-&gt;grp_unscalarizable_region</span>
<span class="lineNum">    3664 </span><span class="lineCov">     385759 :           &amp;&amp; !racc-&gt;grp_unscalarizable_region)</span>
<span class="lineNum">    3665 </span>            :         {
<span class="lineNum">    3666 </span><span class="lineCov">     385753 :           struct subreplacement_assignment_data sad;</span>
<span class="lineNum">    3667 </span>            : 
<span class="lineNum">    3668 </span><span class="lineCov">     385753 :           sad.left_offset = lacc-&gt;offset;</span>
<span class="lineNum">    3669 </span><span class="lineCov">     385753 :           sad.assignment_lhs = lhs;</span>
<span class="lineNum">    3670 </span><span class="lineCov">     385753 :           sad.assignment_rhs = rhs;</span>
<span class="lineNum">    3671 </span><span class="lineCov">     385753 :           sad.top_racc = racc;</span>
<span class="lineNum">    3672 </span><span class="lineCov">     385753 :           sad.old_gsi = *gsi;</span>
<span class="lineNum">    3673 </span><span class="lineCov">     385753 :           sad.new_gsi = gsi;</span>
<span class="lineNum">    3674 </span><span class="lineCov">     385753 :           sad.loc = gimple_location (stmt);</span>
<span class="lineNum">    3675 </span><span class="lineCov">     385753 :           sad.refreshed = SRA_UDH_NONE;</span>
<span class="lineNum">    3676 </span>            : 
<span class="lineNum">    3677 </span><span class="lineCov">     385753 :           if (lacc-&gt;grp_read &amp;&amp; !lacc-&gt;grp_covered)</span>
<span class="lineNum">    3678 </span><span class="lineCov">      35093 :             handle_unscalarized_data_in_subtree (&amp;sad);</span>
<span class="lineNum">    3679 </span>            : 
<span class="lineNum">    3680 </span><span class="lineCov">     385753 :           load_assign_lhs_subreplacements (lacc, &amp;sad);</span>
<span class="lineNum">    3681 </span><span class="lineCov">     385753 :           if (sad.refreshed != SRA_UDH_RIGHT)</span>
<span class="lineNum">    3682 </span>            :             {
<span class="lineNum">    3683 </span><span class="lineCov">     376458 :               gsi_next (gsi);</span>
<span class="lineNum">    3684 </span><span class="lineCov">     376458 :               unlink_stmt_vdef (stmt);</span>
<span class="lineNum">    3685 </span><span class="lineCov">     376458 :               gsi_remove (&amp;sad.old_gsi, true);</span>
<span class="lineNum">    3686 </span><span class="lineCov">     376458 :               release_defs (stmt);</span>
<span class="lineNum">    3687 </span><span class="lineCov">     376458 :               sra_stats.deleted++;</span>
<span class="lineNum">    3688 </span><span class="lineCov">     376458 :               return SRA_AM_REMOVED;</span>
<span class="lineNum">    3689 </span>            :             }
<span class="lineNum">    3690 </span>            :         }
<span class="lineNum">    3691 </span>            :       else
<span class="lineNum">    3692 </span>            :         {
<span class="lineNum">    3693 </span><span class="lineCov">     539342 :           if (access_has_children_p (racc)</span>
<span class="lineNum">    3694 </span><span class="lineCov">     257591 :               &amp;&amp; !racc-&gt;grp_unscalarized_data</span>
<span class="lineNum">    3695 </span><span class="lineCov">     247277 :               &amp;&amp; TREE_CODE (lhs) != SSA_NAME)</span>
<span class="lineNum">    3696 </span>            :             {
<span class="lineNum">    3697 </span><span class="lineCov">     247266 :               if (dump_file)</span>
<span class="lineNum">    3698 </span>            :                 {
<span class="lineNum">    3699 </span><span class="lineCov">          1 :                   fprintf (dump_file, &quot;Removing load: &quot;);</span>
<span class="lineNum">    3700 </span><span class="lineCov">          1 :                   print_gimple_stmt (dump_file, stmt, 0);</span>
<span class="lineNum">    3701 </span>            :                 }
<span class="lineNum">    3702 </span><span class="lineCov">     247266 :               generate_subtree_copies (racc-&gt;first_child, lhs,</span>
<span class="lineNum">    3703 </span>            :                                        racc-&gt;offset, 0, 0, gsi,
<span class="lineNum">    3704 </span>            :                                        false, false, loc);
<span class="lineNum">    3705 </span><span class="lineCov">     494532 :               gcc_assert (stmt == gsi_stmt (*gsi));</span>
<span class="lineNum">    3706 </span><span class="lineCov">     247266 :               unlink_stmt_vdef (stmt);</span>
<span class="lineNum">    3707 </span><span class="lineCov">     247266 :               gsi_remove (gsi, true);</span>
<span class="lineNum">    3708 </span><span class="lineCov">     247266 :               release_defs (stmt);</span>
<span class="lineNum">    3709 </span><span class="lineCov">     247266 :               sra_stats.deleted++;</span>
<span class="lineNum">    3710 </span><span class="lineCov">     247266 :               return SRA_AM_REMOVED;</span>
<span class="lineNum">    3711 </span>            :             }
<span class="lineNum">    3712 </span>            :           /* Restore the aggregate RHS from its components so the
<span class="lineNum">    3713 </span>            :              prevailing aggregate copy does the right thing.  */
<span class="lineNum">    3714 </span><span class="lineCov">     292076 :           if (access_has_children_p (racc))</span>
<span class="lineNum">    3715 </span><span class="lineCov">      10325 :             generate_subtree_copies (racc-&gt;first_child, rhs, racc-&gt;offset, 0, 0,</span>
<span class="lineNum">    3716 </span>            :                                      gsi, false, false, loc);
<span class="lineNum">    3717 </span>            :           /* Re-load the components of the aggregate copy destination.
<span class="lineNum">    3718 </span>            :              But use the RHS aggregate to load from to expose more
<span class="lineNum">    3719 </span>            :              optimization opportunities.  */
<span class="lineNum">    3720 </span><span class="lineCov">     292076 :           if (access_has_children_p (lacc))</span>
<span class="lineNum">    3721 </span><span class="lineCov">     123109 :             generate_subtree_copies (lacc-&gt;first_child, rhs, lacc-&gt;offset,</span>
<span class="lineNum">    3722 </span>            :                                      0, 0, gsi, true, true, loc);
<span class="lineNum">    3723 </span>            :         }
<span class="lineNum">    3724 </span>            : 
<span class="lineNum">    3725 </span><span class="lineCov">     301371 :       return SRA_AM_NONE;</span>
<span class="lineNum">    3726 </span>            :     }
<span class="lineNum">    3727 </span>            : }
<span class="lineNum">    3728 </span>            : 
<span class="lineNum">    3729 </span>            : /* Set any scalar replacements of values in the constant pool to the initial
<span class="lineNum">    3730 </span>            :    value of the constant.  (Constant-pool decls like *.LC0 have effectively
<span class="lineNum">    3731 </span>            :    been initialized before the program starts, we must do the same for their
<span class="lineNum">    3732 </span>            :    replacements.)  Thus, we output statements like 'SR.1 = *.LC0[0];' into
<span class="lineNum">    3733 </span>            :    the function's entry block.  */
<a name="3734"><span class="lineNum">    3734 </span>            : </a>
<span class="lineNum">    3735 </span>            : static void
<span class="lineNum">    3736 </span><span class="lineCov">     219159 : initialize_constant_pool_replacements (void)</span>
<span class="lineNum">    3737 </span>            : {
<span class="lineNum">    3738 </span><span class="lineCov">     219159 :   gimple_seq seq = NULL;</span>
<span class="lineNum">    3739 </span><span class="lineCov">     219159 :   gimple_stmt_iterator gsi = gsi_start (seq);</span>
<span class="lineNum">    3740 </span><span class="lineCov">     219159 :   bitmap_iterator bi;</span>
<span class="lineNum">    3741 </span><span class="lineCov">     219159 :   unsigned i;</span>
<span class="lineNum">    3742 </span>            : 
<span class="lineNum">    3743 </span><span class="lineCov">    1271976 :   EXECUTE_IF_SET_IN_BITMAP (candidate_bitmap, 0, i, bi)</span>
<span class="lineNum">    3744 </span>            :     {
<span class="lineNum">    3745 </span><span class="lineCov">    1052817 :       tree var = candidate (i);</span>
<span class="lineNum">    3746 </span><span class="lineCov">    1052817 :       if (!constant_decl_p (var))</span>
<span class="lineNum">    3747 </span>            :         continue;
<span class="lineNum">    3748 </span><span class="lineCov">         12 :       vec&lt;access_p&gt; *access_vec = get_base_access_vector (var);</span>
<span class="lineNum">    3749 </span><span class="lineCov">         12 :       if (!access_vec)</span>
<span class="lineNum">    3750 </span><span class="lineNoCov">          0 :         continue;</span>
<span class="lineNum">    3751 </span><span class="lineCov">        860 :       for (unsigned i = 0; i &lt; access_vec-&gt;length (); i++)</span>
<span class="lineNum">    3752 </span>            :         {
<span class="lineNum">    3753 </span><span class="lineCov">        418 :           struct access *access = (*access_vec)[i];</span>
<span class="lineNum">    3754 </span><span class="lineCov">        418 :           if (!access-&gt;replacement_decl)</span>
<span class="lineNum">    3755 </span>            :             continue;
<span class="lineNum">    3756 </span><span class="lineCov">        394 :           gassign *stmt</span>
<span class="lineNum">    3757 </span><span class="lineCov">        394 :             = gimple_build_assign (get_access_replacement (access),</span>
<span class="lineNum">    3758 </span>            :                                    unshare_expr (access-&gt;expr));
<span class="lineNum">    3759 </span><span class="lineCov">        394 :           if (dump_file &amp;&amp; (dump_flags &amp; TDF_DETAILS))</span>
<span class="lineNum">    3760 </span>            :             {
<span class="lineNum">    3761 </span><span class="lineNoCov">          0 :               fprintf (dump_file, &quot;Generating constant initializer: &quot;);</span>
<span class="lineNum">    3762 </span><span class="lineNoCov">          0 :               print_gimple_stmt (dump_file, stmt, 0);</span>
<span class="lineNum">    3763 </span><span class="lineNoCov">          0 :               fprintf (dump_file, &quot;\n&quot;);</span>
<span class="lineNum">    3764 </span>            :             }
<span class="lineNum">    3765 </span><span class="lineCov">        394 :           gsi_insert_after (&amp;gsi, stmt, GSI_NEW_STMT);</span>
<span class="lineNum">    3766 </span><span class="lineCov">        394 :           update_stmt (stmt);</span>
<span class="lineNum">    3767 </span>            :         }
<span class="lineNum">    3768 </span>            :     }
<span class="lineNum">    3769 </span>            : 
<span class="lineNum">    3770 </span><span class="lineCov">     219159 :   seq = gsi_seq (gsi);</span>
<span class="lineNum">    3771 </span><span class="lineCov">     219159 :   if (seq)</span>
<span class="lineNum">    3772 </span><span class="lineCov">          6 :     gsi_insert_seq_on_edge_immediate (</span>
<span class="lineNum">    3773 </span><span class="lineCov">          6 :       single_succ_edge (ENTRY_BLOCK_PTR_FOR_FN (cfun)), seq);</span>
<span class="lineNum">    3774 </span><span class="lineCov">     219159 : }</span>
<span class="lineNum">    3775 </span>            : 
<span class="lineNum">    3776 </span>            : /* Traverse the function body and all modifications as decided in
<span class="lineNum">    3777 </span>            :    analyze_all_variable_accesses.  Return true iff the CFG has been
<span class="lineNum">    3778 </span>            :    changed.  */
<a name="3779"><span class="lineNum">    3779 </span>            : </a>
<span class="lineNum">    3780 </span>            : static bool
<span class="lineNum">    3781 </span><span class="lineCov">     219159 : sra_modify_function_body (void)</span>
<span class="lineNum">    3782 </span>            : {
<span class="lineNum">    3783 </span><span class="lineCov">     219159 :   bool cfg_changed = false;</span>
<span class="lineNum">    3784 </span><span class="lineCov">     219159 :   basic_block bb;</span>
<span class="lineNum">    3785 </span>            : 
<span class="lineNum">    3786 </span><span class="lineCov">     219159 :   initialize_constant_pool_replacements ();</span>
<span class="lineNum">    3787 </span>            : 
<span class="lineNum">    3788 </span><span class="lineCov">    5187135 :   FOR_EACH_BB_FN (bb, cfun)</span>
<span class="lineNum">    3789 </span>            :     {
<span class="lineNum">    3790 </span><span class="lineCov">    4967976 :       gimple_stmt_iterator gsi = gsi_start_bb (bb);</span>
<span class="lineNum">    3791 </span><span class="lineCov">   85446296 :       while (!gsi_end_p (gsi))</span>
<span class="lineNum">    3792 </span>            :         {
<span class="lineNum">    3793 </span><span class="lineCov">   37755172 :           gimple *stmt = gsi_stmt (gsi);</span>
<span class="lineNum">    3794 </span><span class="lineCov">   37755172 :           enum assignment_mod_result assign_result;</span>
<span class="lineNum">    3795 </span><span class="lineCov">   37755172 :           bool modified = false, deleted = false;</span>
<span class="lineNum">    3796 </span><span class="lineCov">   37755172 :           tree *t;</span>
<span class="lineNum">    3797 </span><span class="lineCov">   37755172 :           unsigned i;</span>
<span class="lineNum">    3798 </span>            : 
<span class="lineNum">    3799 </span><span class="lineCov">   75510344 :           switch (gimple_code (stmt))</span>
<span class="lineNum">    3800 </span>            :             {
<span class="lineNum">    3801 </span><span class="lineCov">     217910 :             case GIMPLE_RETURN:</span>
<span class="lineNum">    3802 </span><span class="lineCov">     217910 :               t = gimple_return_retval_ptr (as_a &lt;greturn *&gt; (stmt));</span>
<span class="lineNum">    3803 </span><span class="lineCov">     217910 :               if (*t != NULL_TREE)</span>
<span class="lineNum">    3804 </span><span class="lineCov">     142410 :                 modified |= sra_modify_expr (t, &amp;gsi, false);</span>
<span class="lineNum">    3805 </span>            :               break;
<span class="lineNum">    3806 </span>            : 
<span class="lineNum">    3807 </span><span class="lineCov">   12563825 :             case GIMPLE_ASSIGN:</span>
<span class="lineNum">    3808 </span><span class="lineCov">   12563825 :               assign_result = sra_modify_assign (stmt, &amp;gsi);</span>
<span class="lineNum">    3809 </span><span class="lineCov">   12563825 :               modified |= assign_result == SRA_AM_MODIFIED;</span>
<span class="lineNum">    3810 </span><span class="lineCov">   12563825 :               deleted = assign_result == SRA_AM_REMOVED;</span>
<span class="lineNum">    3811 </span><span class="lineCov">   12563825 :               break;</span>
<span class="lineNum">    3812 </span>            : 
<span class="lineNum">    3813 </span>            :             case GIMPLE_CALL:
<span class="lineNum">    3814 </span>            :               /* Operands must be processed before the lhs.  */
<span class="lineNum">    3815 </span><span class="lineCov">    6838989 :               for (i = 0; i &lt; gimple_call_num_args (stmt); i++)</span>
<span class="lineNum">    3816 </span>            :                 {
<span class="lineNum">    3817 </span><span class="lineCov">    4465578 :                   t = gimple_call_arg_ptr (stmt, i);</span>
<span class="lineNum">    3818 </span><span class="lineCov">    4465578 :                   modified |= sra_modify_expr (t, &amp;gsi, false);</span>
<span class="lineNum">    3819 </span>            :                 }
<span class="lineNum">    3820 </span>            : 
<span class="lineNum">    3821 </span><span class="lineCov">    2373411 :               if (gimple_call_lhs (stmt))</span>
<span class="lineNum">    3822 </span>            :                 {
<span class="lineNum">    3823 </span><span class="lineCov">    1092098 :                   t = gimple_call_lhs_ptr (stmt);</span>
<span class="lineNum">    3824 </span><span class="lineCov">    1092098 :                   modified |= sra_modify_expr (t, &amp;gsi, true);</span>
<span class="lineNum">    3825 </span>            :                 }
<span class="lineNum">    3826 </span>            :               break;
<span class="lineNum">    3827 </span>            : 
<span class="lineNum">    3828 </span><span class="lineCov">       3108 :             case GIMPLE_ASM:</span>
<span class="lineNum">    3829 </span><span class="lineCov">       3108 :               {</span>
<span class="lineNum">    3830 </span><span class="lineCov">       3108 :                 gasm *asm_stmt = as_a &lt;gasm *&gt; (stmt);</span>
<span class="lineNum">    3831 </span><span class="lineCov">       8746 :                 for (i = 0; i &lt; gimple_asm_ninputs (asm_stmt); i++)</span>
<span class="lineNum">    3832 </span>            :                   {
<span class="lineNum">    3833 </span><span class="lineCov">       2530 :                     t = &amp;TREE_VALUE (gimple_asm_input_op (asm_stmt, i));</span>
<span class="lineNum">    3834 </span><span class="lineCov">       1265 :                     modified |= sra_modify_expr (t, &amp;gsi, false);</span>
<span class="lineNum">    3835 </span>            :                   }
<span class="lineNum">    3836 </span><span class="lineCov">       7870 :                 for (i = 0; i &lt; gimple_asm_noutputs (asm_stmt); i++)</span>
<span class="lineNum">    3837 </span>            :                   {
<span class="lineNum">    3838 </span><span class="lineCov">       1654 :                     t = &amp;TREE_VALUE (gimple_asm_output_op (asm_stmt, i));</span>
<span class="lineNum">    3839 </span><span class="lineCov">        827 :                     modified |= sra_modify_expr (t, &amp;gsi, true);</span>
<span class="lineNum">    3840 </span><span class="lineCov">       3108 :                   }</span>
<span class="lineNum">    3841 </span>            :               }
<span class="lineNum">    3842 </span>            :               break;
<span class="lineNum">    3843 </span>            : 
<span class="lineNum">    3844 </span>            :             default:
<span class="lineNum">    3845 </span>            :               break;
<span class="lineNum">    3846 </span>            :             }
<span class="lineNum">    3847 </span>            : 
<span class="lineNum">    3848 </span><span class="lineCov">   15082754 :           if (modified)</span>
<span class="lineNum">    3849 </span>            :             {
<span class="lineNum">    3850 </span><span class="lineCov">    2524090 :               update_stmt (stmt);</span>
<span class="lineNum">    3851 </span><span class="lineCov">    2524090 :               if (maybe_clean_eh_stmt (stmt)</span>
<span class="lineNum">    3852 </span><span class="lineCov">    2524090 :                   &amp;&amp; gimple_purge_dead_eh_edges (gimple_bb (stmt)))</span>
<span class="lineNum">    3853 </span>            :                 cfg_changed = true;
<span class="lineNum">    3854 </span>            :             }
<span class="lineNum">    3855 </span><span class="lineCov">   37755172 :           if (!deleted)</span>
<span class="lineNum">    3856 </span><span class="lineCov">   36625341 :             gsi_next (&amp;gsi);</span>
<span class="lineNum">    3857 </span>            :         }
<span class="lineNum">    3858 </span>            :     }
<span class="lineNum">    3859 </span>            : 
<span class="lineNum">    3860 </span><span class="lineCov">     219159 :   gsi_commit_edge_inserts ();</span>
<span class="lineNum">    3861 </span><span class="lineCov">     219159 :   return cfg_changed;</span>
<span class="lineNum">    3862 </span>            : }
<span class="lineNum">    3863 </span>            : 
<span class="lineNum">    3864 </span>            : /* Generate statements initializing scalar replacements of parts of function
<span class="lineNum">    3865 </span>            :    parameters.  */
<a name="3866"><span class="lineNum">    3866 </span>            : </a>
<span class="lineNum">    3867 </span>            : static void
<span class="lineNum">    3868 </span><span class="lineCov">     219159 : initialize_parameter_reductions (void)</span>
<span class="lineNum">    3869 </span>            : {
<span class="lineNum">    3870 </span><span class="lineCov">     219159 :   gimple_stmt_iterator gsi;</span>
<span class="lineNum">    3871 </span><span class="lineCov">     219159 :   gimple_seq seq = NULL;</span>
<span class="lineNum">    3872 </span><span class="lineCov">     219159 :   tree parm;</span>
<span class="lineNum">    3873 </span>            : 
<span class="lineNum">    3874 </span><span class="lineCov">     219159 :   gsi = gsi_start (seq);</span>
<span class="lineNum">    3875 </span><span class="lineCov">     219159 :   for (parm = DECL_ARGUMENTS (current_function_decl);</span>
<span class="lineNum">    3876 </span><span class="lineCov">     634156 :        parm;</span>
<span class="lineNum">    3877 </span><span class="lineCov">     414997 :        parm = DECL_CHAIN (parm))</span>
<span class="lineNum">    3878 </span>            :     {
<span class="lineNum">    3879 </span><span class="lineCov">     414997 :       vec&lt;access_p&gt; *access_vec;</span>
<span class="lineNum">    3880 </span><span class="lineCov">     414997 :       struct access *access;</span>
<span class="lineNum">    3881 </span>            : 
<span class="lineNum">    3882 </span><span class="lineCov">     414997 :       if (!bitmap_bit_p (candidate_bitmap, DECL_UID (parm)))</span>
<span class="lineNum">    3883 </span>            :         continue;
<span class="lineNum">    3884 </span><span class="lineCov">      30764 :       access_vec = get_base_access_vector (parm);</span>
<span class="lineNum">    3885 </span><span class="lineCov">      30764 :       if (!access_vec)</span>
<span class="lineNum">    3886 </span><span class="lineNoCov">          0 :         continue;</span>
<span class="lineNum">    3887 </span>            : 
<span class="lineNum">    3888 </span><span class="lineCov">      30764 :       for (access = (*access_vec)[0];</span>
<span class="lineNum">    3889 </span><span class="lineCov">      72502 :            access;</span>
<span class="lineNum">    3890 </span><span class="lineCov">      41738 :            access = access-&gt;next_grp)</span>
<span class="lineNum">    3891 </span><span class="lineCov">      41738 :         generate_subtree_copies (access, parm, 0, 0, 0, &amp;gsi, true, true,</span>
<span class="lineNum">    3892 </span><span class="lineCov">      41738 :                                  EXPR_LOCATION (parm));</span>
<span class="lineNum">    3893 </span>            :     }
<span class="lineNum">    3894 </span>            : 
<span class="lineNum">    3895 </span><span class="lineCov">     219159 :   seq = gsi_seq (gsi);</span>
<span class="lineNum">    3896 </span><span class="lineCov">     219159 :   if (seq)</span>
<span class="lineNum">    3897 </span><span class="lineCov">      25698 :     gsi_insert_seq_on_edge_immediate (single_succ_edge (ENTRY_BLOCK_PTR_FOR_FN (cfun)), seq);</span>
<span class="lineNum">    3898 </span><span class="lineCov">     219159 : }</span>
<span class="lineNum">    3899 </span>            : 
<span class="lineNum">    3900 </span>            : /* The &quot;main&quot; function of intraprocedural SRA passes.  Runs the analysis and if
<span class="lineNum">    3901 </span>            :    it reveals there are components of some aggregates to be scalarized, it runs
<a name="3902"><span class="lineNum">    3902 </span>            :    the required transformations.  */</a>
<span class="lineNum">    3903 </span>            : static unsigned int
<span class="lineNum">    3904 </span><span class="lineCov">    2027696 : perform_intra_sra (void)</span>
<span class="lineNum">    3905 </span>            : {
<span class="lineNum">    3906 </span><span class="lineCov">    2027696 :   int ret = 0;</span>
<span class="lineNum">    3907 </span><span class="lineCov">    2027696 :   sra_initialize ();</span>
<span class="lineNum">    3908 </span>            : 
<span class="lineNum">    3909 </span><span class="lineCov">    2027696 :   if (!find_var_candidates ())</span>
<span class="lineNum">    3910 </span>            :     goto out;
<span class="lineNum">    3911 </span>            : 
<span class="lineNum">    3912 </span><span class="lineCov">     406163 :   if (!scan_function ())</span>
<span class="lineNum">    3913 </span>            :     goto out;
<span class="lineNum">    3914 </span>            : 
<span class="lineNum">    3915 </span><span class="lineCov">     370685 :   if (!analyze_all_variable_accesses ())</span>
<span class="lineNum">    3916 </span>            :     goto out;
<span class="lineNum">    3917 </span>            : 
<span class="lineNum">    3918 </span><span class="lineCov">     219159 :   if (sra_modify_function_body ())</span>
<span class="lineNum">    3919 </span>            :     ret = TODO_update_ssa | TODO_cleanup_cfg;
<span class="lineNum">    3920 </span>            :   else
<span class="lineNum">    3921 </span><span class="lineCov">     219156 :     ret = TODO_update_ssa;</span>
<span class="lineNum">    3922 </span><span class="lineCov">     219159 :   initialize_parameter_reductions ();</span>
<span class="lineNum">    3923 </span>            : 
<span class="lineNum">    3924 </span><span class="lineCov">     219159 :   statistics_counter_event (cfun, &quot;Scalar replacements created&quot;,</span>
<span class="lineNum">    3925 </span>            :                             sra_stats.replacements);
<span class="lineNum">    3926 </span><span class="lineCov">     219159 :   statistics_counter_event (cfun, &quot;Modified expressions&quot;, sra_stats.exprs);</span>
<span class="lineNum">    3927 </span><span class="lineCov">     219159 :   statistics_counter_event (cfun, &quot;Subtree copy stmts&quot;,</span>
<span class="lineNum">    3928 </span>            :                             sra_stats.subtree_copies);
<span class="lineNum">    3929 </span><span class="lineCov">     219159 :   statistics_counter_event (cfun, &quot;Subreplacement stmts&quot;,</span>
<span class="lineNum">    3930 </span>            :                             sra_stats.subreplacements);
<span class="lineNum">    3931 </span><span class="lineCov">     219159 :   statistics_counter_event (cfun, &quot;Deleted stmts&quot;, sra_stats.deleted);</span>
<span class="lineNum">    3932 </span><span class="lineCov">     219159 :   statistics_counter_event (cfun, &quot;Separate LHS and RHS handling&quot;,</span>
<span class="lineNum">    3933 </span>            :                             sra_stats.separate_lhs_rhs_handling);
<span class="lineNum">    3934 </span>            : 
<span class="lineNum">    3935 </span><span class="lineCov">    2027696 :  out:</span>
<span class="lineNum">    3936 </span><span class="lineCov">    2027696 :   sra_deinitialize ();</span>
<span class="lineNum">    3937 </span><span class="lineCov">    2027696 :   return ret;</span>
<span class="lineNum">    3938 </span>            : }
<span class="lineNum">    3939 </span>            : 
<a name="3940"><span class="lineNum">    3940 </span>            : /* Perform early intraprocedural SRA.  */</a>
<span class="lineNum">    3941 </span>            : static unsigned int
<span class="lineNum">    3942 </span><span class="lineNoCov">          0 : early_intra_sra (void)</span>
<span class="lineNum">    3943 </span>            : {
<span class="lineNum">    3944 </span><span class="lineCov">    1407015 :   sra_mode = SRA_MODE_EARLY_INTRA;</span>
<span class="lineNum">    3945 </span><span class="lineNoCov">          0 :   return perform_intra_sra ();</span>
<span class="lineNum">    3946 </span>            : }
<span class="lineNum">    3947 </span>            : 
<a name="3948"><span class="lineNum">    3948 </span>            : /* Perform &quot;late&quot; intraprocedural SRA.  */</a>
<span class="lineNum">    3949 </span>            : static unsigned int
<span class="lineNum">    3950 </span><span class="lineNoCov">          0 : late_intra_sra (void)</span>
<span class="lineNum">    3951 </span>            : {
<span class="lineNum">    3952 </span><span class="lineCov">     620681 :   sra_mode = SRA_MODE_INTRA;</span>
<span class="lineNum">    3953 </span><span class="lineNoCov">          0 :   return perform_intra_sra ();</span>
<span class="lineNum">    3954 </span>            : }
<span class="lineNum">    3955 </span>            : 
<a name="3956"><span class="lineNum">    3956 </span>            : </a>
<span class="lineNum">    3957 </span>            : static bool
<span class="lineNum">    3958 </span><span class="lineNoCov">          0 : gate_intra_sra (void)</span>
<span class="lineNum">    3959 </span>            : {
<span class="lineNum">    3960 </span><span class="lineCov">    2027720 :   return flag_tree_sra != 0 &amp;&amp; dbg_cnt (tree_sra);</span>
<span class="lineNum">    3961 </span>            : }
<span class="lineNum">    3962 </span>            : 
<span class="lineNum">    3963 </span>            : 
<span class="lineNum">    3964 </span>            : namespace {
<span class="lineNum">    3965 </span>            : 
<span class="lineNum">    3966 </span>            : const pass_data pass_data_sra_early =
<span class="lineNum">    3967 </span>            : {
<span class="lineNum">    3968 </span>            :   GIMPLE_PASS, /* type */
<span class="lineNum">    3969 </span>            :   &quot;esra&quot;, /* name */
<span class="lineNum">    3970 </span>            :   OPTGROUP_NONE, /* optinfo_flags */
<span class="lineNum">    3971 </span>            :   TV_TREE_SRA, /* tv_id */
<span class="lineNum">    3972 </span>            :   ( PROP_cfg | PROP_ssa ), /* properties_required */
<span class="lineNum">    3973 </span>            :   0, /* properties_provided */
<span class="lineNum">    3974 </span>            :   0, /* properties_destroyed */
<span class="lineNum">    3975 </span>            :   0, /* todo_flags_start */
<span class="lineNum">    3976 </span>            :   TODO_update_ssa, /* todo_flags_finish */
<span class="lineNum">    3977 </span>            : };
<span class="lineNum">    3978 </span>            : 
<span class="lineNum">    3979 </span>            : class pass_sra_early : public gimple_opt_pass
<span class="lineNum">    3980 </span>            : {
<span class="lineNum">    3981 </span>            : public:
<span class="lineNum">    3982 </span>            :   pass_sra_early (gcc::context *ctxt)
<span class="lineNum">    3983 </span><span class="lineCov">     340624 :     : gimple_opt_pass (pass_data_sra_early, ctxt)</span>
<span class="lineNum">    3984 </span>            :   {}
<a name="3985"><span class="lineNum">    3985 </span>            : </a>
<a name="3986"><span class="lineNum">    3986 </span>            :   /* opt_pass methods: */</a>
<span class="lineNum">    3987 </span><span class="lineCov">    1409355 :   virtual bool gate (function *) { return gate_intra_sra (); }</span>
<span class="lineNum">    3988 </span><span class="lineCov">    1407015 :   virtual unsigned int execute (function *) { return early_intra_sra (); }</span>
<span class="lineNum">    3989 </span>            : 
<span class="lineNum">    3990 </span>            : }; // class pass_sra_early
<span class="lineNum">    3991 </span>            : 
<span class="lineNum">    3992 </span>            : } // anon namespace
<a name="3993"><span class="lineNum">    3993 </span>            : </a>
<span class="lineNum">    3994 </span>            : gimple_opt_pass *
<span class="lineNum">    3995 </span><span class="lineCov">     170312 : make_pass_sra_early (gcc::context *ctxt)</span>
<span class="lineNum">    3996 </span>            : {
<span class="lineNum">    3997 </span><span class="lineCov">     170312 :   return new pass_sra_early (ctxt);</span>
<span class="lineNum">    3998 </span>            : }
<span class="lineNum">    3999 </span>            : 
<span class="lineNum">    4000 </span>            : namespace {
<span class="lineNum">    4001 </span>            : 
<span class="lineNum">    4002 </span>            : const pass_data pass_data_sra =
<span class="lineNum">    4003 </span>            : {
<span class="lineNum">    4004 </span>            :   GIMPLE_PASS, /* type */
<span class="lineNum">    4005 </span>            :   &quot;sra&quot;, /* name */
<span class="lineNum">    4006 </span>            :   OPTGROUP_NONE, /* optinfo_flags */
<span class="lineNum">    4007 </span>            :   TV_TREE_SRA, /* tv_id */
<span class="lineNum">    4008 </span>            :   ( PROP_cfg | PROP_ssa ), /* properties_required */
<span class="lineNum">    4009 </span>            :   0, /* properties_provided */
<span class="lineNum">    4010 </span>            :   0, /* properties_destroyed */
<span class="lineNum">    4011 </span>            :   TODO_update_address_taken, /* todo_flags_start */
<span class="lineNum">    4012 </span>            :   TODO_update_ssa, /* todo_flags_finish */
<span class="lineNum">    4013 </span>            : };
<span class="lineNum">    4014 </span>            : 
<span class="lineNum">    4015 </span>            : class pass_sra : public gimple_opt_pass
<span class="lineNum">    4016 </span>            : {
<span class="lineNum">    4017 </span>            : public:
<span class="lineNum">    4018 </span>            :   pass_sra (gcc::context *ctxt)
<span class="lineNum">    4019 </span><span class="lineCov">     340624 :     : gimple_opt_pass (pass_data_sra, ctxt)</span>
<span class="lineNum">    4020 </span>            :   {}
<a name="4021"><span class="lineNum">    4021 </span>            : </a>
<a name="4022"><span class="lineNum">    4022 </span>            :   /* opt_pass methods: */</a>
<span class="lineNum">    4023 </span><span class="lineCov">     620946 :   virtual bool gate (function *) { return gate_intra_sra (); }</span>
<span class="lineNum">    4024 </span><span class="lineCov">     620681 :   virtual unsigned int execute (function *) { return late_intra_sra (); }</span>
<span class="lineNum">    4025 </span>            : 
<span class="lineNum">    4026 </span>            : }; // class pass_sra
<span class="lineNum">    4027 </span>            : 
<span class="lineNum">    4028 </span>            : } // anon namespace
<a name="4029"><span class="lineNum">    4029 </span>            : </a>
<span class="lineNum">    4030 </span>            : gimple_opt_pass *
<span class="lineNum">    4031 </span><span class="lineCov">     170312 : make_pass_sra (gcc::context *ctxt)</span>
<span class="lineNum">    4032 </span>            : {
<span class="lineNum">    4033 </span><span class="lineCov">     170312 :   return new pass_sra (ctxt);</span>
<span class="lineNum">    4034 </span>            : }
<span class="lineNum">    4035 </span>            : 
<span class="lineNum">    4036 </span>            : 
<span class="lineNum">    4037 </span>            : /* Return true iff PARM (which must be a parm_decl) is an unused scalar
<span class="lineNum">    4038 </span>            :    parameter.  */
<a name="4039"><span class="lineNum">    4039 </span>            : </a>
<span class="lineNum">    4040 </span>            : static bool
<span class="lineNum">    4041 </span><span class="lineCov">    1573648 : is_unused_scalar_param (tree parm)</span>
<span class="lineNum">    4042 </span>            : {
<span class="lineNum">    4043 </span><span class="lineCov">    1573648 :   tree name;</span>
<span class="lineNum">    4044 </span><span class="lineCov">    1573648 :   return (is_gimple_reg (parm)</span>
<span class="lineNum">    4045 </span><span class="lineCov">    1573648 :           &amp;&amp; (!(name = ssa_default_def (cfun, parm))</span>
<span class="lineNum">    4046 </span><span class="lineCov">    1271559 :               || has_zero_uses (name)));</span>
<span class="lineNum">    4047 </span>            : }
<span class="lineNum">    4048 </span>            : 
<span class="lineNum">    4049 </span>            : /* Scan immediate uses of a default definition SSA name of a parameter PARM and
<span class="lineNum">    4050 </span>            :    examine whether there are any direct or otherwise infeasible ones.  If so,
<span class="lineNum">    4051 </span>            :    return true, otherwise return false.  PARM must be a gimple register with a
<span class="lineNum">    4052 </span>            :    non-NULL default definition.  */
<a name="4053"><span class="lineNum">    4053 </span>            : </a>
<span class="lineNum">    4054 </span>            : static bool
<span class="lineNum">    4055 </span><span class="lineCov">     644962 : ptr_parm_has_direct_uses (tree parm)</span>
<span class="lineNum">    4056 </span>            : {
<span class="lineNum">    4057 </span><span class="lineCov">     644962 :   imm_use_iterator ui;</span>
<span class="lineNum">    4058 </span><span class="lineCov">     644962 :   gimple *stmt;</span>
<span class="lineNum">    4059 </span><span class="lineCov">     644962 :   tree name = ssa_default_def (cfun, parm);</span>
<span class="lineNum">    4060 </span><span class="lineCov">     644962 :   bool ret = false;</span>
<span class="lineNum">    4061 </span>            : 
<span class="lineNum">    4062 </span><span class="lineCov">    1125725 :   FOR_EACH_IMM_USE_STMT (stmt, ui, name)</span>
<span class="lineNum">    4063 </span>            :     {
<span class="lineNum">    4064 </span><span class="lineCov">    1010182 :       int uses_ok = 0;</span>
<span class="lineNum">    4065 </span><span class="lineCov">    1010182 :       use_operand_p use_p;</span>
<span class="lineNum">    4066 </span>            : 
<span class="lineNum">    4067 </span><span class="lineCov">    2020364 :       if (is_gimple_debug (stmt))</span>
<span class="lineNum">    4068 </span>            :         continue;
<span class="lineNum">    4069 </span>            : 
<span class="lineNum">    4070 </span>            :       /* Valid uses include dereferences on the lhs and the rhs.  */
<span class="lineNum">    4071 </span><span class="lineCov">     871753 :       if (gimple_has_lhs (stmt))</span>
<span class="lineNum">    4072 </span>            :         {
<span class="lineNum">    4073 </span><span class="lineCov">     520838 :           tree lhs = gimple_get_lhs (stmt);</span>
<span class="lineNum">    4074 </span><span class="lineCov">     629762 :           while (handled_component_p (lhs))</span>
<span class="lineNum">    4075 </span><span class="lineCov">     108924 :             lhs = TREE_OPERAND (lhs, 0);</span>
<span class="lineNum">    4076 </span><span class="lineCov">     520838 :           if (TREE_CODE (lhs) == MEM_REF</span>
<span class="lineNum">    4077 </span><span class="lineCov">     138493 :               &amp;&amp; TREE_OPERAND (lhs, 0) == name</span>
<span class="lineNum">    4078 </span><span class="lineCov">     118174 :               &amp;&amp; integer_zerop (TREE_OPERAND (lhs, 1))</span>
<span class="lineNum">    4079 </span><span class="lineCov">     106172 :               &amp;&amp; types_compatible_p (TREE_TYPE (lhs),</span>
<span class="lineNum">    4080 </span><span class="lineCov">     106172 :                                      TREE_TYPE (TREE_TYPE (name)))</span>
<span class="lineNum">    4081 </span><span class="lineCov">     602972 :               &amp;&amp; !TREE_THIS_VOLATILE (lhs))</span>
<span class="lineNum">    4082 </span>            :             uses_ok++;
<span class="lineNum">    4083 </span>            :         }
<span class="lineNum">    4084 </span><span class="lineCov">     737535 :       if (gimple_assign_single_p (stmt))</span>
<span class="lineNum">    4085 </span>            :         {
<span class="lineNum">    4086 </span><span class="lineCov">     852612 :           tree rhs = gimple_assign_rhs1 (stmt);</span>
<span class="lineNum">    4087 </span><span class="lineCov">     564057 :           while (handled_component_p (rhs))</span>
<span class="lineNum">    4088 </span><span class="lineCov">     137751 :             rhs = TREE_OPERAND (rhs, 0);</span>
<span class="lineNum">    4089 </span><span class="lineCov">     426306 :           if (TREE_CODE (rhs) == MEM_REF</span>
<span class="lineNum">    4090 </span><span class="lineCov">     217317 :               &amp;&amp; TREE_OPERAND (rhs, 0) == name</span>
<span class="lineNum">    4091 </span><span class="lineCov">     211695 :               &amp;&amp; integer_zerop (TREE_OPERAND (rhs, 1))</span>
<span class="lineNum">    4092 </span><span class="lineCov">     179282 :               &amp;&amp; types_compatible_p (TREE_TYPE (rhs),</span>
<span class="lineNum">    4093 </span><span class="lineCov">     179282 :                                      TREE_TYPE (TREE_TYPE (name)))</span>
<span class="lineNum">    4094 </span><span class="lineCov">     552014 :               &amp;&amp; !TREE_THIS_VOLATILE (rhs))</span>
<span class="lineNum">    4095 </span><span class="lineCov">     125692 :             uses_ok++;</span>
<span class="lineNum">    4096 </span>            :         }
<span class="lineNum">    4097 </span><span class="lineCov">     622458 :       else if (is_gimple_call (stmt))</span>
<span class="lineNum">    4098 </span>            :         {
<span class="lineNum">    4099 </span>            :           unsigned i;
<span class="lineNum">    4100 </span><span class="lineCov">     508879 :           for (i = 0; i &lt; gimple_call_num_args (stmt); ++i)</span>
<span class="lineNum">    4101 </span>            :             {
<span class="lineNum">    4102 </span><span class="lineCov">     374661 :               tree arg = gimple_call_arg (stmt, i);</span>
<span class="lineNum">    4103 </span><span class="lineCov">     375195 :               while (handled_component_p (arg))</span>
<span class="lineNum">    4104 </span><span class="lineCov">        534 :                 arg = TREE_OPERAND (arg, 0);</span>
<span class="lineNum">    4105 </span><span class="lineCov">     374661 :               if (TREE_CODE (arg) == MEM_REF</span>
<span class="lineNum">    4106 </span><span class="lineCov">        504 :                   &amp;&amp; TREE_OPERAND (arg, 0) == name</span>
<span class="lineNum">    4107 </span><span class="lineCov">        354 :                   &amp;&amp; integer_zerop (TREE_OPERAND (arg, 1))</span>
<span class="lineNum">    4108 </span><span class="lineCov">        354 :                   &amp;&amp; types_compatible_p (TREE_TYPE (arg),</span>
<span class="lineNum">    4109 </span><span class="lineCov">        354 :                                          TREE_TYPE (TREE_TYPE (name)))</span>
<span class="lineNum">    4110 </span><span class="lineCov">     375015 :                   &amp;&amp; !TREE_THIS_VOLATILE (arg))</span>
<span class="lineNum">    4111 </span><span class="lineCov">        354 :                 uses_ok++;</span>
<span class="lineNum">    4112 </span>            :             }
<span class="lineNum">    4113 </span>            :         }
<span class="lineNum">    4114 </span>            : 
<span class="lineNum">    4115 </span>            :       /* If the number of valid uses does not match the number of
<span class="lineNum">    4116 </span>            :          uses in this stmt there is an unhandled use.  */
<span class="lineNum">    4117 </span><span class="lineCov">    2962664 :       FOR_EACH_IMM_USE_ON_STMT (use_p, ui)</span>
<span class="lineNum">    4118 </span><span class="lineCov">     743797 :         --uses_ok;</span>
<span class="lineNum">    4119 </span>            : 
<span class="lineNum">    4120 </span><span class="lineCov">     737535 :       if (uses_ok != 0)</span>
<span class="lineNum">    4121 </span><span class="lineCov">     529419 :         ret = true;</span>
<span class="lineNum">    4122 </span>            : 
<span class="lineNum">    4123 </span><span class="lineCov">     529419 :       if (ret)</span>
<span class="lineNum">    4124 </span><span class="lineCov">     529419 :         BREAK_FROM_IMM_USE_STMT (ui);</span>
<span class="lineNum">    4125 </span>            :     }
<span class="lineNum">    4126 </span>            : 
<span class="lineNum">    4127 </span><span class="lineCov">     644962 :   return ret;</span>
<span class="lineNum">    4128 </span>            : }
<span class="lineNum">    4129 </span>            : 
<span class="lineNum">    4130 </span>            : /* Identify candidates for reduction for IPA-SRA based on their type and mark
<span class="lineNum">    4131 </span>            :    them in candidate_bitmap.  Note that these do not necessarily include
<span class="lineNum">    4132 </span>            :    parameter which are unused and thus can be removed.  Return true iff any
<span class="lineNum">    4133 </span>            :    such candidate has been found.  */
<a name="4134"><span class="lineNum">    4134 </span>            : </a>
<span class="lineNum">    4135 </span>            : static bool
<span class="lineNum">    4136 </span><span class="lineCov">     589657 : find_param_candidates (void)</span>
<span class="lineNum">    4137 </span>            : {
<span class="lineNum">    4138 </span><span class="lineCov">     589657 :   tree parm;</span>
<span class="lineNum">    4139 </span><span class="lineCov">     589657 :   int count = 0;</span>
<span class="lineNum">    4140 </span><span class="lineCov">     589657 :   bool ret = false;</span>
<span class="lineNum">    4141 </span><span class="lineCov">     589657 :   const char *msg;</span>
<span class="lineNum">    4142 </span>            : 
<span class="lineNum">    4143 </span><span class="lineCov">     589657 :   for (parm = DECL_ARGUMENTS (current_function_decl);</span>
<span class="lineNum">    4144 </span><span class="lineCov">    1634399 :        parm;</span>
<span class="lineNum">    4145 </span><span class="lineCov">    1044742 :        parm = DECL_CHAIN (parm))</span>
<span class="lineNum">    4146 </span>            :     {
<span class="lineNum">    4147 </span><span class="lineCov">    1044742 :       tree type = TREE_TYPE (parm);</span>
<span class="lineNum">    4148 </span><span class="lineCov">    1044742 :       tree_node **slot;</span>
<span class="lineNum">    4149 </span>            : 
<span class="lineNum">    4150 </span><span class="lineCov">    1044742 :       count++;</span>
<span class="lineNum">    4151 </span>            : 
<span class="lineNum">    4152 </span><span class="lineCov">    1044742 :       if (TREE_THIS_VOLATILE (parm)</span>
<span class="lineNum">    4153 </span><span class="lineCov">    1044742 :           || TREE_ADDRESSABLE (parm)</span>
<span class="lineNum">    4154 </span><span class="lineCov">    1044742 :           || (!is_gimple_reg_type (type) &amp;&amp; is_va_list_type (type)))</span>
<span class="lineNum">    4155 </span>            :         continue;
<span class="lineNum">    4156 </span>            : 
<span class="lineNum">    4157 </span><span class="lineCov">    1042538 :       if (is_unused_scalar_param (parm))</span>
<span class="lineNum">    4158 </span>            :         {
<span class="lineNum">    4159 </span>            :           ret = true;
<span class="lineNum">    4160 </span>            :           continue;
<span class="lineNum">    4161 </span>            :         }
<span class="lineNum">    4162 </span>            : 
<span class="lineNum">    4163 </span><span class="lineCov">     869002 :       if (POINTER_TYPE_P (type))</span>
<span class="lineNum">    4164 </span>            :         {
<span class="lineNum">    4165 </span><span class="lineCov">     648958 :           type = TREE_TYPE (type);</span>
<span class="lineNum">    4166 </span>            : 
<span class="lineNum">    4167 </span><span class="lineCov">     648958 :           if (TREE_CODE (type) == FUNCTION_TYPE</span>
<span class="lineNum">    4168 </span><span class="lineCov">     647255 :               || TYPE_VOLATILE (type)</span>
<span class="lineNum">    4169 </span><span class="lineCov">     645000 :               || (TREE_CODE (type) == ARRAY_TYPE</span>
<span class="lineNum">    4170 </span><span class="lineCov">       2904 :                   &amp;&amp; TYPE_NONALIASED_COMPONENT (type))</span>
<span class="lineNum">    4171 </span><span class="lineCov">     645000 :               || !is_gimple_reg (parm)</span>
<span class="lineNum">    4172 </span><span class="lineCov">     645000 :               || is_va_list_type (type)</span>
<span class="lineNum">    4173 </span><span class="lineCov">    1293920 :               || ptr_parm_has_direct_uses (parm))</span>
<span class="lineNum">    4174 </span><span class="lineCov">     533415 :             continue;</span>
<span class="lineNum">    4175 </span>            :         }
<span class="lineNum">    4176 </span><span class="lineCov">     220044 :       else if (!AGGREGATE_TYPE_P (type))</span>
<span class="lineNum">    4177 </span>            :         continue;
<span class="lineNum">    4178 </span>            : 
<span class="lineNum">    4179 </span><span class="lineCov">     195129 :       if (!COMPLETE_TYPE_P (type)</span>
<span class="lineNum">    4180 </span><span class="lineCov">     390258 :           || !tree_fits_uhwi_p (TYPE_SIZE (type))</span>
<span class="lineNum">    4181 </span><span class="lineCov">     390258 :           || tree_to_uhwi (TYPE_SIZE (type)) == 0</span>
<span class="lineNum">    4182 </span><span class="lineCov">     390247 :           || (AGGREGATE_TYPE_P (type)</span>
<span class="lineNum">    4183 </span><span class="lineCov">     161716 :               &amp;&amp; type_internals_preclude_sra_p (type, &amp;msg)))</span>
<span class="lineNum">    4184 </span><span class="lineCov">        395 :         continue;</span>
<span class="lineNum">    4185 </span>            : 
<span class="lineNum">    4186 </span><span class="lineCov">     194734 :       bitmap_set_bit (candidate_bitmap, DECL_UID (parm));</span>
<span class="lineNum">    4187 </span><span class="lineCov">     194734 :       slot = candidates-&gt;find_slot_with_hash (parm, DECL_UID (parm), INSERT);</span>
<span class="lineNum">    4188 </span><span class="lineCov">     194734 :       *slot = parm;</span>
<span class="lineNum">    4189 </span>            : 
<span class="lineNum">    4190 </span><span class="lineCov">     194734 :       ret = true;</span>
<span class="lineNum">    4191 </span><span class="lineCov">     194734 :       if (dump_file &amp;&amp; (dump_flags &amp; TDF_DETAILS))</span>
<span class="lineNum">    4192 </span>            :         {
<span class="lineNum">    4193 </span><span class="lineCov">          8 :           fprintf (dump_file, &quot;Candidate (%d): &quot;, DECL_UID (parm));</span>
<span class="lineNum">    4194 </span><span class="lineCov">          8 :           print_generic_expr (dump_file, parm);</span>
<span class="lineNum">    4195 </span><span class="lineCov">          8 :           fprintf (dump_file, &quot;\n&quot;);</span>
<span class="lineNum">    4196 </span>            :         }
<span class="lineNum">    4197 </span>            :     }
<span class="lineNum">    4198 </span>            : 
<span class="lineNum">    4199 </span><span class="lineCov">     589657 :   func_param_count = count;</span>
<span class="lineNum">    4200 </span><span class="lineCov">     589657 :   return ret;</span>
<span class="lineNum">    4201 </span>            : }
<span class="lineNum">    4202 </span>            : 
<span class="lineNum">    4203 </span>            : /* Callback of walk_aliased_vdefs, marks the access passed as DATA as
<span class="lineNum">    4204 </span>            :    maybe_modified. */
<a name="4205"><span class="lineNum">    4205 </span>            : </a>
<span class="lineNum">    4206 </span>            : static bool
<span class="lineNum">    4207 </span><span class="lineCov">       7035 : mark_maybe_modified (ao_ref *ao ATTRIBUTE_UNUSED, tree vdef ATTRIBUTE_UNUSED,</span>
<span class="lineNum">    4208 </span>            :                      void *data)
<span class="lineNum">    4209 </span>            : {
<span class="lineNum">    4210 </span><span class="lineCov">       7035 :   struct access *repr = (struct access *) data;</span>
<span class="lineNum">    4211 </span>            : 
<span class="lineNum">    4212 </span><span class="lineCov">       7035 :   repr-&gt;grp_maybe_modified = 1;</span>
<span class="lineNum">    4213 </span><span class="lineCov">       7035 :   return true;</span>
<span class="lineNum">    4214 </span>            : }
<span class="lineNum">    4215 </span>            : 
<span class="lineNum">    4216 </span>            : /* Analyze what representatives (in linked lists accessible from
<span class="lineNum">    4217 </span>            :    REPRESENTATIVES) can be modified by side effects of statements in the
<span class="lineNum">    4218 </span>            :    current function.  */
<a name="4219"><span class="lineNum">    4219 </span>            : </a>
<span class="lineNum">    4220 </span>            : static void
<span class="lineNum">    4221 </span><span class="lineCov">      72019 : analyze_modified_params (vec&lt;access_p&gt; representatives)</span>
<span class="lineNum">    4222 </span>            : {
<span class="lineNum">    4223 </span><span class="lineCov">      72019 :   int i;</span>
<span class="lineNum">    4224 </span>            : 
<span class="lineNum">    4225 </span><span class="lineCov">     196177 :   for (i = 0; i &lt; func_param_count; i++)</span>
<span class="lineNum">    4226 </span>            :     {
<span class="lineNum">    4227 </span><span class="lineCov">     124158 :       struct access *repr;</span>
<span class="lineNum">    4228 </span>            : 
<span class="lineNum">    4229 </span><span class="lineCov">     124158 :       for (repr = representatives[i];</span>
<span class="lineNum">    4230 </span><span class="lineCov">     237013 :            repr;</span>
<span class="lineNum">    4231 </span><span class="lineCov">     112855 :            repr = repr-&gt;next_grp)</span>
<span class="lineNum">    4232 </span>            :         {
<span class="lineNum">    4233 </span><span class="lineCov">     112855 :           struct access *access;</span>
<span class="lineNum">    4234 </span><span class="lineCov">     112855 :           bitmap visited;</span>
<span class="lineNum">    4235 </span><span class="lineCov">     112855 :           ao_ref ar;</span>
<span class="lineNum">    4236 </span>            : 
<span class="lineNum">    4237 </span><span class="lineCov">     112855 :           if (no_accesses_p (repr))</span>
<span class="lineNum">    4238 </span><span class="lineCov">      20379 :             continue;</span>
<span class="lineNum">    4239 </span><span class="lineCov">     182944 :           if (!POINTER_TYPE_P (TREE_TYPE (repr-&gt;base))</span>
<span class="lineNum">    4240 </span><span class="lineCov">     139350 :               || repr-&gt;grp_maybe_modified)</span>
<span class="lineNum">    4241 </span>            :             continue;
<span class="lineNum">    4242 </span>            : 
<span class="lineNum">    4243 </span><span class="lineCov">      92476 :           ao_ref_init (&amp;ar, repr-&gt;expr);</span>
<span class="lineNum">    4244 </span><span class="lineCov">      92476 :           visited = BITMAP_ALLOC (NULL);</span>
<span class="lineNum">    4245 </span><span class="lineCov">     182320 :           for (access = repr; access; access = access-&gt;next_sibling)</span>
<span class="lineNum">    4246 </span>            :             {
<span class="lineNum">    4247 </span>            :               /* All accesses are read ones, otherwise grp_maybe_modified would
<span class="lineNum">    4248 </span>            :                  be trivially set.  */
<span class="lineNum">    4249 </span><span class="lineCov">     188836 :               walk_aliased_vdefs (&amp;ar, gimple_vuse (access-&gt;stmt),</span>
<span class="lineNum">    4250 </span>            :                                   mark_maybe_modified, repr, &amp;visited);
<span class="lineNum">    4251 </span><span class="lineCov">      94418 :               if (repr-&gt;grp_maybe_modified)</span>
<span class="lineNum">    4252 </span>            :                 break;
<span class="lineNum">    4253 </span>            :             }
<span class="lineNum">    4254 </span><span class="lineCov">      92476 :           BITMAP_FREE (visited);</span>
<span class="lineNum">    4255 </span>            :         }
<span class="lineNum">    4256 </span>            :     }
<span class="lineNum">    4257 </span><span class="lineCov">      72019 : }</span>
<span class="lineNum">    4258 </span>            : 
<span class="lineNum">    4259 </span>            : /* Propagate distances in bb_dereferences in the opposite direction than the
<span class="lineNum">    4260 </span>            :    control flow edges, in each step storing the maximum of the current value
<span class="lineNum">    4261 </span>            :    and the minimum of all successors.  These steps are repeated until the table
<span class="lineNum">    4262 </span>            :    stabilizes.  Note that BBs which might terminate the functions (according to
<span class="lineNum">    4263 </span>            :    final_bbs bitmap) never updated in this way.  */
<a name="4264"><span class="lineNum">    4264 </span>            : </a>
<span class="lineNum">    4265 </span>            : static void
<span class="lineNum">    4266 </span><span class="lineCov">      72019 : propagate_dereference_distances (void)</span>
<span class="lineNum">    4267 </span>            : {
<span class="lineNum">    4268 </span><span class="lineCov">      72019 :   basic_block bb;</span>
<span class="lineNum">    4269 </span>            : 
<span class="lineNum">    4270 </span><span class="lineCov">     144038 :   auto_vec&lt;basic_block&gt; queue (last_basic_block_for_fn (cfun));</span>
<span class="lineNum">    4271 </span><span class="lineCov">      72019 :   queue.quick_push (ENTRY_BLOCK_PTR_FOR_FN (cfun));</span>
<span class="lineNum">    4272 </span><span class="lineCov">     214794 :   FOR_EACH_BB_FN (bb, cfun)</span>
<span class="lineNum">    4273 </span>            :     {
<span class="lineNum">    4274 </span><span class="lineCov">     142775 :       queue.quick_push (bb);</span>
<span class="lineNum">    4275 </span><span class="lineCov">     142775 :       bb-&gt;aux = bb;</span>
<span class="lineNum">    4276 </span>            :     }
<span class="lineNum">    4277 </span>            : 
<span class="lineNum">    4278 </span><span class="lineCov">     287450 :   while (!queue.is_empty ())</span>
<span class="lineNum">    4279 </span>            :     {
<span class="lineNum">    4280 </span><span class="lineCov">     215431 :       edge_iterator ei;</span>
<span class="lineNum">    4281 </span><span class="lineCov">     215431 :       edge e;</span>
<span class="lineNum">    4282 </span><span class="lineCov">     215431 :       bool change = false;</span>
<span class="lineNum">    4283 </span><span class="lineCov">     215431 :       int i;</span>
<span class="lineNum">    4284 </span>            : 
<span class="lineNum">    4285 </span><span class="lineCov">     215431 :       bb = queue.pop ();</span>
<span class="lineNum">    4286 </span><span class="lineCov">     215431 :       bb-&gt;aux = NULL;</span>
<span class="lineNum">    4287 </span>            : 
<span class="lineNum">    4288 </span><span class="lineCov">     215431 :       if (bitmap_bit_p (final_bbs, bb-&gt;index))</span>
<span class="lineNum">    4289 </span><span class="lineCov">      85237 :         continue;</span>
<span class="lineNum">    4290 </span>            : 
<span class="lineNum">    4291 </span><span class="lineCov">     412916 :       for (i = 0; i &lt; func_param_count; i++)</span>
<span class="lineNum">    4292 </span>            :         {
<span class="lineNum">    4293 </span><span class="lineCov">     282722 :           int idx = bb-&gt;index * func_param_count + i;</span>
<span class="lineNum">    4294 </span><span class="lineCov">     282722 :           bool first = true;</span>
<span class="lineNum">    4295 </span><span class="lineCov">     282722 :           HOST_WIDE_INT inh = 0;</span>
<span class="lineNum">    4296 </span>            : 
<span class="lineNum">    4297 </span><span class="lineCov">     928163 :           FOR_EACH_EDGE (e, ei, bb-&gt;succs)</span>
<span class="lineNum">    4298 </span>            :           {
<span class="lineNum">    4299 </span><span class="lineCov">     362719 :             int succ_idx = e-&gt;dest-&gt;index * func_param_count + i;</span>
<span class="lineNum">    4300 </span>            : 
<span class="lineNum">    4301 </span><span class="lineCov">     362719 :             if (e-&gt;src == EXIT_BLOCK_PTR_FOR_FN (cfun))</span>
<span class="lineNum">    4302 </span>            :               continue;
<span class="lineNum">    4303 </span>            : 
<span class="lineNum">    4304 </span><span class="lineCov">     362719 :             if (first)</span>
<span class="lineNum">    4305 </span>            :               {
<span class="lineNum">    4306 </span><span class="lineCov">     282470 :                 first = false;</span>
<span class="lineNum">    4307 </span><span class="lineCov">     282470 :                 inh = bb_dereferences [succ_idx];</span>
<span class="lineNum">    4308 </span>            :               }
<span class="lineNum">    4309 </span><span class="lineCov">      80249 :             else if (bb_dereferences [succ_idx] &lt; inh)</span>
<span class="lineNum">    4310 </span><span class="lineCov">       3272 :               inh = bb_dereferences [succ_idx];</span>
<span class="lineNum">    4311 </span>            :           }
<span class="lineNum">    4312 </span>            : 
<span class="lineNum">    4313 </span><span class="lineCov">     282722 :           if (!first &amp;&amp; bb_dereferences[idx] &lt; inh)</span>
<span class="lineNum">    4314 </span>            :             {
<span class="lineNum">    4315 </span><span class="lineCov">      87675 :               bb_dereferences[idx] = inh;</span>
<span class="lineNum">    4316 </span><span class="lineCov">      87675 :               change = true;</span>
<span class="lineNum">    4317 </span>            :             }
<span class="lineNum">    4318 </span>            :         }
<span class="lineNum">    4319 </span>            : 
<span class="lineNum">    4320 </span><span class="lineCov">     130194 :       if (change &amp;&amp; !bitmap_bit_p (final_bbs, bb-&gt;index))</span>
<span class="lineNum">    4321 </span><span class="lineCov">     147240 :         FOR_EACH_EDGE (e, ei, bb-&gt;preds)</span>
<span class="lineNum">    4322 </span>            :           {
<span class="lineNum">    4323 </span><span class="lineCov">       4888 :             if (e-&gt;src-&gt;aux)</span>
<span class="lineNum">    4324 </span>            :               continue;
<span class="lineNum">    4325 </span>            : 
<span class="lineNum">    4326 </span><span class="lineCov">        637 :             e-&gt;src-&gt;aux = e-&gt;src;</span>
<span class="lineNum">    4327 </span><span class="lineCov">        637 :             queue.quick_push (e-&gt;src);</span>
<span class="lineNum">    4328 </span>            :           }
<span class="lineNum">    4329 </span>            :     }
<span class="lineNum">    4330 </span><span class="lineCov">      72019 : }</span>
<span class="lineNum">    4331 </span>            : 
<span class="lineNum">    4332 </span>            : /* Dump a dereferences TABLE with heading STR to file F.  */
<a name="4333"><span class="lineNum">    4333 </span>            : </a>
<span class="lineNum">    4334 </span>            : static void
<span class="lineNum">    4335 </span><span class="lineCov">          8 : dump_dereferences_table (FILE *f, const char *str, HOST_WIDE_INT *table)</span>
<span class="lineNum">    4336 </span>            : {
<span class="lineNum">    4337 </span><span class="lineCov">          8 :   basic_block bb;</span>
<span class="lineNum">    4338 </span>            : 
<span class="lineNum">    4339 </span><span class="lineCov">          8 :   fprintf (dump_file, &quot;%s&quot;, str);</span>
<span class="lineNum">    4340 </span><span class="lineCov">         38 :   FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR_FOR_FN (cfun),</span>
<span class="lineNum">    4341 </span>            :                   EXIT_BLOCK_PTR_FOR_FN (cfun), next_bb)
<span class="lineNum">    4342 </span>            :     {
<span class="lineNum">    4343 </span><span class="lineCov">         30 :       fprintf (f, &quot;%4i  %i   &quot;, bb-&gt;index, bitmap_bit_p (final_bbs, bb-&gt;index));</span>
<span class="lineNum">    4344 </span><span class="lineCov">         30 :       if (bb != EXIT_BLOCK_PTR_FOR_FN (cfun))</span>
<span class="lineNum">    4345 </span>            :         {
<span class="lineNum">    4346 </span>            :           int i;
<span class="lineNum">    4347 </span><span class="lineCov">         72 :           for (i = 0; i &lt; func_param_count; i++)</span>
<span class="lineNum">    4348 </span>            :             {
<span class="lineNum">    4349 </span><span class="lineCov">         42 :               int idx = bb-&gt;index * func_param_count + i;</span>
<span class="lineNum">    4350 </span><span class="lineCov">         42 :               fprintf (f, &quot; %4&quot; HOST_WIDE_INT_PRINT &quot;d&quot;, table[idx]);</span>
<span class="lineNum">    4351 </span>            :             }
<span class="lineNum">    4352 </span>            :         }
<span class="lineNum">    4353 </span><span class="lineCov">         30 :       fprintf (f, &quot;\n&quot;);</span>
<span class="lineNum">    4354 </span>            :     }
<span class="lineNum">    4355 </span><span class="lineCov">          8 :   fprintf (dump_file, &quot;\n&quot;);</span>
<span class="lineNum">    4356 </span><span class="lineCov">          8 : }</span>
<span class="lineNum">    4357 </span>            : 
<span class="lineNum">    4358 </span>            : /* Determine what (parts of) parameters passed by reference that are not
<span class="lineNum">    4359 </span>            :    assigned to are not certainly dereferenced in this function and thus the
<span class="lineNum">    4360 </span>            :    dereferencing cannot be safely moved to the caller without potentially
<span class="lineNum">    4361 </span>            :    introducing a segfault.  Mark such REPRESENTATIVES as
<span class="lineNum">    4362 </span>            :    grp_not_necessarilly_dereferenced.
<span class="lineNum">    4363 </span>            : 
<span class="lineNum">    4364 </span>            :    The dereferenced maximum &quot;distance,&quot; i.e. the offset + size of the accessed
<span class="lineNum">    4365 </span>            :    part is calculated rather than simple booleans are calculated for each
<span class="lineNum">    4366 </span>            :    pointer parameter to handle cases when only a fraction of the whole
<span class="lineNum">    4367 </span>            :    aggregate is allocated (see testsuite/gcc.c-torture/execute/ipa-sra-2.c for
<span class="lineNum">    4368 </span>            :    an example).
<span class="lineNum">    4369 </span>            : 
<span class="lineNum">    4370 </span>            :    The maximum dereference distances for each pointer parameter and BB are
<span class="lineNum">    4371 </span>            :    already stored in bb_dereference.  This routine simply propagates these
<span class="lineNum">    4372 </span>            :    values upwards by propagate_dereference_distances and then compares the
<span class="lineNum">    4373 </span>            :    distances of individual parameters in the ENTRY BB to the equivalent
<span class="lineNum">    4374 </span>            :    distances of each representative of a (fraction of a) parameter.  */
<a name="4375"><span class="lineNum">    4375 </span>            : </a>
<span class="lineNum">    4376 </span>            : static void
<span class="lineNum">    4377 </span><span class="lineCov">      72019 : analyze_caller_dereference_legality (vec&lt;access_p&gt; representatives)</span>
<span class="lineNum">    4378 </span>            : {
<span class="lineNum">    4379 </span><span class="lineCov">      72019 :   int i;</span>
<span class="lineNum">    4380 </span>            : 
<span class="lineNum">    4381 </span><span class="lineCov">      72019 :   if (dump_file &amp;&amp; (dump_flags &amp; TDF_DETAILS))</span>
<span class="lineNum">    4382 </span><span class="lineCov">          4 :     dump_dereferences_table (dump_file,</span>
<span class="lineNum">    4383 </span>            :                              &quot;Dereference table before propagation:\n&quot;,
<span class="lineNum">    4384 </span>            :                              bb_dereferences);
<span class="lineNum">    4385 </span>            : 
<span class="lineNum">    4386 </span><span class="lineCov">      72019 :   propagate_dereference_distances ();</span>
<span class="lineNum">    4387 </span>            : 
<span class="lineNum">    4388 </span><span class="lineCov">      72019 :   if (dump_file &amp;&amp; (dump_flags &amp; TDF_DETAILS))</span>
<span class="lineNum">    4389 </span><span class="lineCov">          4 :     dump_dereferences_table (dump_file,</span>
<span class="lineNum">    4390 </span>            :                              &quot;Dereference table after propagation:\n&quot;,
<span class="lineNum">    4391 </span>            :                              bb_dereferences);
<span class="lineNum">    4392 </span>            : 
<span class="lineNum">    4393 </span><span class="lineCov">     196177 :   for (i = 0; i &lt; func_param_count; i++)</span>
<span class="lineNum">    4394 </span>            :     {
<span class="lineNum">    4395 </span><span class="lineCov">     124158 :       struct access *repr = representatives[i];</span>
<span class="lineNum">    4396 </span><span class="lineCov">     124158 :       int idx = ENTRY_BLOCK_PTR_FOR_FN (cfun)-&gt;index * func_param_count + i;</span>
<span class="lineNum">    4397 </span>            : 
<span class="lineNum">    4398 </span><span class="lineCov">     124158 :       if (!repr || no_accesses_p (repr))</span>
<span class="lineNum">    4399 </span>            :         continue;
<span class="lineNum">    4400 </span>            : 
<span class="lineNum">    4401 </span><span class="lineCov">     100682 :       do</span>
<span class="lineNum">    4402 </span>            :         {
<span class="lineNum">    4403 </span><span class="lineCov">     100682 :           if ((repr-&gt;offset + repr-&gt;size) &gt; bb_dereferences[idx])</span>
<span class="lineNum">    4404 </span><span class="lineCov">      11665 :             repr-&gt;grp_not_necessarilly_dereferenced = 1;</span>
<span class="lineNum">    4405 </span><span class="lineCov">     100682 :           repr = repr-&gt;next_grp;</span>
<span class="lineNum">    4406 </span>            :         }
<span class="lineNum">    4407 </span><span class="lineCov">     100682 :       while (repr);</span>
<span class="lineNum">    4408 </span>            :     }
<span class="lineNum">    4409 </span><span class="lineCov">      72019 : }</span>
<span class="lineNum">    4410 </span>            : 
<span class="lineNum">    4411 </span>            : /* Return the representative access for the parameter declaration PARM if it is
<span class="lineNum">    4412 </span>            :    a scalar passed by reference which is not written to and the pointer value
<span class="lineNum">    4413 </span>            :    is not used directly.  Thus, if it is legal to dereference it in the caller
<span class="lineNum">    4414 </span>            :    and we can rule out modifications through aliases, such parameter should be
<span class="lineNum">    4415 </span>            :    turned into one passed by value.  Return NULL otherwise.  */
<a name="4416"><span class="lineNum">    4416 </span>            : </a>
<span class="lineNum">    4417 </span>            : static struct access *
<span class="lineNum">    4418 </span><span class="lineCov">      33270 : unmodified_by_ref_scalar_representative (tree parm)</span>
<span class="lineNum">    4419 </span>            : {
<span class="lineNum">    4420 </span><span class="lineCov">      33270 :   int i, access_count;</span>
<span class="lineNum">    4421 </span><span class="lineCov">      33270 :   struct access *repr;</span>
<span class="lineNum">    4422 </span><span class="lineCov">      33270 :   vec&lt;access_p&gt; *access_vec;</span>
<span class="lineNum">    4423 </span>            : 
<span class="lineNum">    4424 </span><span class="lineCov">      33270 :   access_vec = get_base_access_vector (parm);</span>
<span class="lineNum">    4425 </span><span class="lineNoCov">          0 :   gcc_assert (access_vec);</span>
<span class="lineNum">    4426 </span><span class="lineCov">      33270 :   repr = (*access_vec)[0];</span>
<span class="lineNum">    4427 </span><span class="lineCov">      33270 :   if (repr-&gt;write)</span>
<span class="lineNum">    4428 </span>            :     return NULL;
<span class="lineNum">    4429 </span><span class="lineCov">      27998 :   repr-&gt;group_representative = repr;</span>
<span class="lineNum">    4430 </span>            : 
<span class="lineNum">    4431 </span><span class="lineCov">      27998 :   access_count = access_vec-&gt;length ();</span>
<span class="lineNum">    4432 </span><span class="lineCov">      28906 :   for (i = 1; i &lt; access_count; i++)</span>
<span class="lineNum">    4433 </span>            :     {
<span class="lineNum">    4434 </span><span class="lineCov">       6697 :       struct access *access = (*access_vec)[i];</span>
<span class="lineNum">    4435 </span><span class="lineCov">       6697 :       if (access-&gt;write)</span>
<span class="lineNum">    4436 </span>            :         return NULL;
<span class="lineNum">    4437 </span><span class="lineCov">        908 :       access-&gt;group_representative = repr;</span>
<span class="lineNum">    4438 </span><span class="lineCov">        908 :       access-&gt;next_sibling = repr-&gt;next_sibling;</span>
<span class="lineNum">    4439 </span><span class="lineCov">        908 :       repr-&gt;next_sibling = access;</span>
<span class="lineNum">    4440 </span>            :     }
<span class="lineNum">    4441 </span>            : 
<span class="lineNum">    4442 </span><span class="lineCov">      22209 :   repr-&gt;grp_read = 1;</span>
<span class="lineNum">    4443 </span><span class="lineCov">      22209 :   repr-&gt;grp_scalar_ptr = 1;</span>
<span class="lineNum">    4444 </span><span class="lineCov">      22209 :   return repr;</span>
<span class="lineNum">    4445 </span>            : }
<span class="lineNum">    4446 </span>            : 
<span class="lineNum">    4447 </span>            : /* Return true iff this ACCESS precludes IPA-SRA of the parameter it is
<span class="lineNum">    4448 </span>            :    associated with.  REQ_ALIGN is the minimum required alignment.  */
<a name="4449"><span class="lineNum">    4449 </span>            : </a>
<span class="lineNum">    4450 </span>            : static bool
<span class="lineNum">    4451 </span><span class="lineCov">     176535 : access_precludes_ipa_sra_p (struct access *access, unsigned int req_align)</span>
<span class="lineNum">    4452 </span>            : {
<span class="lineNum">    4453 </span><span class="lineCov">     176535 :   unsigned int exp_align;</span>
<span class="lineNum">    4454 </span>            :   /* Avoid issues such as the second simple testcase in PR 42025.  The problem
<span class="lineNum">    4455 </span>            :      is incompatible assign in a call statement (and possibly even in asm
<span class="lineNum">    4456 </span>            :      statements).  This can be relaxed by using a new temporary but only for
<span class="lineNum">    4457 </span>            :      non-TREE_ADDRESSABLE types and is probably not worth the complexity. (In
<span class="lineNum">    4458 </span>            :      intraprocedural SRA we deal with this by keeping the old aggregate around,
<span class="lineNum">    4459 </span>            :      something we cannot do in IPA-SRA.)  */
<span class="lineNum">    4460 </span><span class="lineCov">     176535 :   if (access-&gt;write</span>
<span class="lineNum">    4461 </span><span class="lineCov">      59276 :       &amp;&amp; (is_gimple_call (access-&gt;stmt)</span>
<span class="lineNum">    4462 </span><span class="lineCov">     235341 :           || gimple_code (access-&gt;stmt) == GIMPLE_ASM))</span>
<span class="lineNum">    4463 </span>            :     return true;
<span class="lineNum">    4464 </span>            : 
<span class="lineNum">    4465 </span><span class="lineCov">     176300 :   exp_align = get_object_alignment (access-&gt;expr);</span>
<span class="lineNum">    4466 </span><span class="lineCov">     176300 :   if (exp_align &lt; req_align)</span>
<span class="lineNum">    4467 </span><span class="lineCov">        131 :     return true;</span>
<span class="lineNum">    4468 </span>            : 
<span class="lineNum">    4469 </span>            :   return false;
<span class="lineNum">    4470 </span>            : }
<span class="lineNum">    4471 </span>            : 
<span class="lineNum">    4472 </span>            : 
<span class="lineNum">    4473 </span>            : /* Sort collected accesses for parameter PARM, identify representatives for
<span class="lineNum">    4474 </span>            :    each accessed region and link them together.  Return NULL if there are
<span class="lineNum">    4475 </span>            :    different but overlapping accesses, return the special ptr value meaning
<span class="lineNum">    4476 </span>            :    there are no accesses for this parameter if that is the case and return the
<span class="lineNum">    4477 </span>            :    first representative otherwise.  Set *RO_GRP if there is a group of accesses
<span class="lineNum">    4478 </span>            :    with only read (i.e. no write) accesses.  */
<a name="4479"><span class="lineNum">    4479 </span>            : </a>
<span class="lineNum">    4480 </span>            : static struct access *
<span class="lineNum">    4481 </span><span class="lineCov">     155288 : splice_param_accesses (tree parm, bool *ro_grp)</span>
<span class="lineNum">    4482 </span>            : {
<span class="lineNum">    4483 </span><span class="lineCov">     155288 :   int i, j, access_count, group_count;</span>
<span class="lineNum">    4484 </span><span class="lineCov">     155288 :   int total_size = 0;</span>
<span class="lineNum">    4485 </span><span class="lineCov">     155288 :   struct access *access, *res, **prev_acc_ptr = &amp;res;</span>
<span class="lineNum">    4486 </span><span class="lineCov">     155288 :   vec&lt;access_p&gt; *access_vec;</span>
<span class="lineNum">    4487 </span>            : 
<span class="lineNum">    4488 </span><span class="lineCov">     155288 :   access_vec = get_base_access_vector (parm);</span>
<span class="lineNum">    4489 </span><span class="lineCov">     155288 :   if (!access_vec)</span>
<span class="lineNum">    4490 </span><span class="lineCov">      27008 :     return &amp;no_accesses_representant;</span>
<span class="lineNum">    4491 </span><span class="lineCov">     128280 :   access_count = access_vec-&gt;length ();</span>
<span class="lineNum">    4492 </span>            : 
<span class="lineNum">    4493 </span><span class="lineCov">     128280 :   access_vec-&gt;qsort (compare_access_positions);</span>
<span class="lineNum">    4494 </span>            : 
<span class="lineNum">    4495 </span>            :   i = 0;
<span class="lineNum">    4496 </span>            :   total_size = 0;
<span class="lineNum">    4497 </span>            :   group_count = 0;
<span class="lineNum">    4498 </span><span class="lineCov">     282663 :   while (i &lt; access_count)</span>
<span class="lineNum">    4499 </span>            :     {
<span class="lineNum">    4500 </span><span class="lineCov">     157830 :       bool modification;</span>
<span class="lineNum">    4501 </span><span class="lineCov">     157830 :       tree a1_alias_type;</span>
<span class="lineNum">    4502 </span><span class="lineCov">     157830 :       access = (*access_vec)[i];</span>
<span class="lineNum">    4503 </span><span class="lineCov">     157830 :       modification = access-&gt;write;</span>
<span class="lineNum">    4504 </span><span class="lineCov">     157830 :       if (access_precludes_ipa_sra_p (access, TYPE_ALIGN (access-&gt;type)))</span>
<span class="lineNum">    4505 </span>            :         return NULL;
<span class="lineNum">    4506 </span><span class="lineCov">     157667 :       a1_alias_type = reference_alias_ptr_type (access-&gt;expr);</span>
<span class="lineNum">    4507 </span>            : 
<span class="lineNum">    4508 </span>            :       /* Access is about to become group representative unless we find some
<span class="lineNum">    4509 </span>            :          nasty overlap which would preclude us from breaking this parameter
<span class="lineNum">    4510 </span>            :          apart. */
<span class="lineNum">    4511 </span>            : 
<span class="lineNum">    4512 </span><span class="lineCov">     157667 :       j = i + 1;</span>
<span class="lineNum">    4513 </span><span class="lineCov">     175672 :       while (j &lt; access_count)</span>
<span class="lineNum">    4514 </span>            :         {
<span class="lineNum">    4515 </span><span class="lineCov">      50839 :           struct access *ac2 = (*access_vec)[j];</span>
<span class="lineNum">    4516 </span><span class="lineCov">      50839 :           if (ac2-&gt;offset != access-&gt;offset)</span>
<span class="lineNum">    4517 </span>            :             {
<span class="lineNum">    4518 </span>            :               /* All or nothing law for parameters. */
<span class="lineNum">    4519 </span><span class="lineCov">      30080 :               if (access-&gt;offset + access-&gt;size &gt; ac2-&gt;offset)</span>
<span class="lineNum">    4520 </span>            :                 return NULL;
<span class="lineNum">    4521 </span>            :               else
<span class="lineNum">    4522 </span>            :                 break;
<span class="lineNum">    4523 </span>            :             }
<span class="lineNum">    4524 </span><span class="lineCov">      20759 :           else if (ac2-&gt;size != access-&gt;size)</span>
<span class="lineNum">    4525 </span>            :             return NULL;
<span class="lineNum">    4526 </span>            : 
<span class="lineNum">    4527 </span><span class="lineCov">      18705 :           if (access_precludes_ipa_sra_p (ac2, TYPE_ALIGN (access-&gt;type))</span>
<span class="lineNum">    4528 </span><span class="lineCov">      18502 :               || (ac2-&gt;type != access-&gt;type</span>
<span class="lineNum">    4529 </span><span class="lineCov">       2876 :                   &amp;&amp; (TREE_ADDRESSABLE (ac2-&gt;type)</span>
<span class="lineNum">    4530 </span><span class="lineCov">       2876 :                       || TREE_ADDRESSABLE (access-&gt;type)))</span>
<span class="lineNum">    4531 </span><span class="lineCov">      37204 :               || (reference_alias_ptr_type (ac2-&gt;expr) != a1_alias_type))</span>
<span class="lineNum">    4532 </span><span class="lineCov">        700 :             return NULL;</span>
<span class="lineNum">    4533 </span>            : 
<span class="lineNum">    4534 </span><span class="lineCov">      18005 :           modification |= ac2-&gt;write;</span>
<span class="lineNum">    4535 </span><span class="lineCov">      18005 :           ac2-&gt;group_representative = access;</span>
<span class="lineNum">    4536 </span><span class="lineCov">      18005 :           ac2-&gt;next_sibling = access-&gt;next_sibling;</span>
<span class="lineNum">    4537 </span><span class="lineCov">      18005 :           access-&gt;next_sibling = ac2;</span>
<span class="lineNum">    4538 </span><span class="lineCov">      18005 :           j++;</span>
<span class="lineNum">    4539 </span>            :         }
<span class="lineNum">    4540 </span>            : 
<span class="lineNum">    4541 </span><span class="lineCov">     154383 :       group_count++;</span>
<span class="lineNum">    4542 </span><span class="lineCov">     154383 :       access-&gt;grp_maybe_modified = modification;</span>
<span class="lineNum">    4543 </span><span class="lineCov">     154383 :       if (!modification)</span>
<span class="lineNum">    4544 </span><span class="lineCov">     127505 :         *ro_grp = true;</span>
<span class="lineNum">    4545 </span><span class="lineCov">     154383 :       *prev_acc_ptr = access;</span>
<span class="lineNum">    4546 </span><span class="lineCov">     154383 :       prev_acc_ptr = &amp;access-&gt;next_grp;</span>
<span class="lineNum">    4547 </span><span class="lineCov">     154383 :       total_size += access-&gt;size;</span>
<span class="lineNum">    4548 </span><span class="lineCov">     154383 :       i = j;</span>
<span class="lineNum">    4549 </span>            :     }
<span class="lineNum">    4550 </span>            : 
<span class="lineNum">    4551 </span><span class="lineCov">     124833 :   gcc_assert (group_count &gt; 0);</span>
<span class="lineNum">    4552 </span><span class="lineCov">     124833 :   return res;</span>
<span class="lineNum">    4553 </span>            : }
<span class="lineNum">    4554 </span>            : 
<span class="lineNum">    4555 </span>            : /* Decide whether parameters with representative accesses given by REPR should
<span class="lineNum">    4556 </span>            :    be reduced into components.  */
<a name="4557"><span class="lineNum">    4557 </span>            : </a>
<span class="lineNum">    4558 </span>            : static int
<span class="lineNum">    4559 </span><span class="lineCov">     124833 : decide_one_param_reduction (struct access *repr)</span>
<span class="lineNum">    4560 </span>            : {
<span class="lineNum">    4561 </span><span class="lineCov">     124833 :   HOST_WIDE_INT total_size, cur_parm_size;</span>
<span class="lineNum">    4562 </span><span class="lineCov">     124833 :   bool by_ref;</span>
<span class="lineNum">    4563 </span><span class="lineCov">     124833 :   tree parm;</span>
<span class="lineNum">    4564 </span>            : 
<span class="lineNum">    4565 </span><span class="lineCov">     124833 :   parm = repr-&gt;base;</span>
<span class="lineNum">    4566 </span><span class="lineCov">     124833 :   cur_parm_size = tree_to_uhwi (TYPE_SIZE (TREE_TYPE (parm)));</span>
<span class="lineNum">    4567 </span><span class="lineCov">     124833 :   gcc_assert (cur_parm_size &gt; 0);</span>
<span class="lineNum">    4568 </span>            : 
<span class="lineNum">    4569 </span><span class="lineCov">     124833 :   if (POINTER_TYPE_P (TREE_TYPE (parm)))</span>
<span class="lineNum">    4570 </span>            :     by_ref = true;
<span class="lineNum">    4571 </span>            :   else
<span class="lineNum">    4572 </span>            :     by_ref = false;
<span class="lineNum">    4573 </span>            : 
<span class="lineNum">    4574 </span><span class="lineCov">     124833 :   if (dump_file)</span>
<span class="lineNum">    4575 </span>            :     {
<span class="lineNum">    4576 </span><span class="lineCov">          6 :       struct access *acc;</span>
<span class="lineNum">    4577 </span><span class="lineCov">          6 :       fprintf (dump_file, &quot;Evaluating PARAM group sizes for &quot;);</span>
<span class="lineNum">    4578 </span><span class="lineCov">          6 :       print_generic_expr (dump_file, parm);</span>
<span class="lineNum">    4579 </span><span class="lineCov">          6 :       fprintf (dump_file, &quot; (UID: %u): \n&quot;, DECL_UID (parm));</span>
<span class="lineNum">    4580 </span><span class="lineCov">         16 :       for (acc = repr; acc; acc = acc-&gt;next_grp)</span>
<span class="lineNum">    4581 </span><span class="lineCov">         10 :         dump_access (dump_file, acc, true);</span>
<span class="lineNum">    4582 </span>            :     }
<span class="lineNum">    4583 </span>            : 
<span class="lineNum">    4584 </span>            :   total_size = 0;
<span class="lineNum">    4585 </span>            :   int new_param_count = 0;
<span class="lineNum">    4586 </span>            : 
<span class="lineNum">    4587 </span><span class="lineCov">     275866 :   for (; repr; repr = repr-&gt;next_grp)</span>
<span class="lineNum">    4588 </span>            :     {
<span class="lineNum">    4589 </span><span class="lineCov">     154081 :       gcc_assert (parm == repr-&gt;base);</span>
<span class="lineNum">    4590 </span>            : 
<span class="lineNum">    4591 </span>            :       /* Taking the address of a non-addressable field is verboten.  */
<span class="lineNum">    4592 </span><span class="lineCov">     154081 :       if (by_ref &amp;&amp; repr-&gt;non_addressable)</span>
<span class="lineNum">    4593 </span>            :         return 0;
<span class="lineNum">    4594 </span>            : 
<span class="lineNum">    4595 </span>            :       /* Do not decompose a non-BLKmode param in a way that would
<span class="lineNum">    4596 </span>            :          create BLKmode params.  Especially for by-reference passing
<span class="lineNum">    4597 </span>            :          (thus, pointer-type param) this is hardly worthwhile.  */
<span class="lineNum">    4598 </span><span class="lineCov">     154071 :       if (DECL_MODE (parm) != BLKmode</span>
<span class="lineNum">    4599 </span><span class="lineCov">     154071 :           &amp;&amp; TYPE_MODE (repr-&gt;type) == BLKmode)</span>
<span class="lineNum">    4600 </span>            :         return 0;
<span class="lineNum">    4601 </span>            : 
<span class="lineNum">    4602 </span><span class="lineCov">     151033 :       if (!by_ref || (!repr-&gt;grp_maybe_modified</span>
<span class="lineNum">    4603 </span><span class="lineCov">      93735 :                       &amp;&amp; !repr-&gt;grp_not_necessarilly_dereferenced))</span>
<span class="lineNum">    4604 </span><span class="lineCov">     120384 :         total_size += repr-&gt;size;</span>
<span class="lineNum">    4605 </span>            :       else
<span class="lineNum">    4606 </span><span class="lineCov">      30649 :         total_size += cur_parm_size;</span>
<span class="lineNum">    4607 </span>            : 
<span class="lineNum">    4608 </span><span class="lineCov">     151033 :       new_param_count++;</span>
<span class="lineNum">    4609 </span>            :     }
<span class="lineNum">    4610 </span>            : 
<span class="lineNum">    4611 </span><span class="lineCov">     121785 :   gcc_assert (new_param_count &gt; 0);</span>
<span class="lineNum">    4612 </span>            : 
<span class="lineNum">    4613 </span><span class="lineCov">     121785 :   if (!by_ref)</span>
<span class="lineNum">    4614 </span>            :     {
<span class="lineNum">    4615 </span><span class="lineCov">      48279 :       if (total_size &gt;= cur_parm_size)</span>
<span class="lineNum">    4616 </span>            :         return 0;
<span class="lineNum">    4617 </span>            :     }
<span class="lineNum">    4618 </span>            :   else
<span class="lineNum">    4619 </span>            :     {
<span class="lineNum">    4620 </span><span class="lineCov">      73506 :       int parm_num_limit;</span>
<span class="lineNum">    4621 </span><span class="lineCov">      73506 :       if (optimize_function_for_size_p (cfun))</span>
<span class="lineNum">    4622 </span>            :         parm_num_limit = 1;
<span class="lineNum">    4623 </span>            :       else
<span class="lineNum">    4624 </span><span class="lineCov">      73128 :         parm_num_limit = PARAM_VALUE (PARAM_IPA_SRA_PTR_GROWTH_FACTOR);</span>
<span class="lineNum">    4625 </span>            : 
<span class="lineNum">    4626 </span><span class="lineCov">      73506 :       if (new_param_count &gt; parm_num_limit</span>
<span class="lineNum">    4627 </span><span class="lineCov">      68191 :           || total_size &gt; (parm_num_limit * cur_parm_size))</span>
<span class="lineNum">    4628 </span>            :         return 0;
<span class="lineNum">    4629 </span>            :     }
<span class="lineNum">    4630 </span>            : 
<span class="lineNum">    4631 </span><span class="lineCov">      72538 :   if (dump_file)</span>
<span class="lineNum">    4632 </span><span class="lineCov">          6 :     fprintf (dump_file, &quot;    ....will be split into %i components\n&quot;,</span>
<span class="lineNum">    4633 </span>            :              new_param_count);
<span class="lineNum">    4634 </span>            :   return new_param_count;
<span class="lineNum">    4635 </span>            : }
<span class="lineNum">    4636 </span>            : 
<span class="lineNum">    4637 </span>            : /* The order of the following enums is important, we need to do extra work for
<span class="lineNum">    4638 </span>            :    UNUSED_PARAMS, BY_VAL_ACCESSES and UNMODIF_BY_REF_ACCESSES.  */
<span class="lineNum">    4639 </span>            : enum ipa_splicing_result { NO_GOOD_ACCESS, UNUSED_PARAMS, BY_VAL_ACCESSES,
<span class="lineNum">    4640 </span>            :                           MODIF_BY_REF_ACCESSES, UNMODIF_BY_REF_ACCESSES };
<span class="lineNum">    4641 </span>            : 
<span class="lineNum">    4642 </span>            : /* Identify representatives of all accesses to all candidate parameters for
<span class="lineNum">    4643 </span>            :    IPA-SRA.  Return result based on what representatives have been found. */
<a name="4644"><span class="lineNum">    4644 </span>            : </a>
<span class="lineNum">    4645 </span>            : static enum ipa_splicing_result
<span class="lineNum">    4646 </span><span class="lineCov">     247816 : splice_all_param_accesses (vec&lt;access_p&gt; &amp;representatives)</span>
<span class="lineNum">    4647 </span>            : {
<span class="lineNum">    4648 </span><span class="lineCov">     247816 :   enum ipa_splicing_result result = NO_GOOD_ACCESS;</span>
<span class="lineNum">    4649 </span><span class="lineCov">     247816 :   tree parm;</span>
<span class="lineNum">    4650 </span><span class="lineCov">     247816 :   struct access *repr;</span>
<span class="lineNum">    4651 </span>            : 
<span class="lineNum">    4652 </span><span class="lineCov">     247816 :   representatives.create (func_param_count);</span>
<span class="lineNum">    4653 </span>            : 
<span class="lineNum">    4654 </span><span class="lineCov">     247816 :   for (parm = DECL_ARGUMENTS (current_function_decl);</span>
<span class="lineNum">    4655 </span><span class="lineCov">     778926 :        parm;</span>
<span class="lineNum">    4656 </span><span class="lineCov">     531110 :        parm = DECL_CHAIN (parm))</span>
<span class="lineNum">    4657 </span>            :     {
<span class="lineNum">    4658 </span><span class="lineCov">     531110 :       if (is_unused_scalar_param (parm))</span>
<span class="lineNum">    4659 </span>            :         {
<span class="lineNum">    4660 </span><span class="lineCov">     171758 :           representatives.quick_push (&amp;no_accesses_representant);</span>
<span class="lineNum">    4661 </span><span class="lineCov">     171758 :           if (result == NO_GOOD_ACCESS)</span>
<span class="lineNum">    4662 </span><span class="lineCov">     120452 :             result = UNUSED_PARAMS;</span>
<span class="lineNum">    4663 </span>            :         }
<span class="lineNum">    4664 </span><span class="lineCov">     728180 :       else if (POINTER_TYPE_P (TREE_TYPE (parm))</span>
<span class="lineNum">    4665 </span><span class="lineCov">     485820 :                &amp;&amp; is_gimple_reg_type (TREE_TYPE (TREE_TYPE (parm)))</span>
<span class="lineNum">    4666 </span><span class="lineCov">     439348 :                &amp;&amp; bitmap_bit_p (candidate_bitmap, DECL_UID (parm)))</span>
<span class="lineNum">    4667 </span>            :         {
<span class="lineNum">    4668 </span><span class="lineCov">      33270 :           repr = unmodified_by_ref_scalar_representative (parm);</span>
<span class="lineNum">    4669 </span><span class="lineCov">      33270 :           representatives.quick_push (repr);</span>
<span class="lineNum">    4670 </span><span class="lineCov">      33270 :           if (repr)</span>
<span class="lineNum">    4671 </span><span class="lineCov">      22209 :             result = UNMODIF_BY_REF_ACCESSES;</span>
<span class="lineNum">    4672 </span>            :         }
<span class="lineNum">    4673 </span><span class="lineCov">     326082 :       else if (bitmap_bit_p (candidate_bitmap, DECL_UID (parm)))</span>
<span class="lineNum">    4674 </span>            :         {
<span class="lineNum">    4675 </span><span class="lineCov">     155288 :           bool ro_grp = false;</span>
<span class="lineNum">    4676 </span><span class="lineCov">     155288 :           repr = splice_param_accesses (parm, &amp;ro_grp);</span>
<span class="lineNum">    4677 </span><span class="lineCov">     155288 :           representatives.quick_push (repr);</span>
<span class="lineNum">    4678 </span>            : 
<span class="lineNum">    4679 </span><span class="lineCov">     155288 :           if (repr &amp;&amp; !no_accesses_p (repr))</span>
<span class="lineNum">    4680 </span>            :             {
<span class="lineNum">    4681 </span><span class="lineCov">     124833 :               if (POINTER_TYPE_P (TREE_TYPE (parm)))</span>
<span class="lineNum">    4682 </span>            :                 {
<span class="lineNum">    4683 </span><span class="lineCov">      76551 :                   if (ro_grp)</span>
<span class="lineNum">    4684 </span>            :                     result = UNMODIF_BY_REF_ACCESSES;
<span class="lineNum">    4685 </span><span class="lineCov">      17495 :                   else if (result &lt; MODIF_BY_REF_ACCESSES)</span>
<span class="lineNum">    4686 </span><span class="lineCov">      16844 :                     result = MODIF_BY_REF_ACCESSES;</span>
<span class="lineNum">    4687 </span>            :                 }
<span class="lineNum">    4688 </span><span class="lineCov">      48282 :               else if (result &lt; BY_VAL_ACCESSES)</span>
<span class="lineNum">    4689 </span><span class="lineCov">      27385 :                 result = BY_VAL_ACCESSES;</span>
<span class="lineNum">    4690 </span>            :             }
<span class="lineNum">    4691 </span><span class="lineCov">      30455 :           else if (no_accesses_p (repr) &amp;&amp; (result == NO_GOOD_ACCESS))</span>
<span class="lineNum">    4692 </span>            :             result = UNUSED_PARAMS;
<span class="lineNum">    4693 </span>            :         }
<span class="lineNum">    4694 </span>            :       else
<span class="lineNum">    4695 </span><span class="lineCov">     170794 :         representatives.quick_push (NULL);</span>
<span class="lineNum">    4696 </span>            :     }
<span class="lineNum">    4697 </span>            : 
<span class="lineNum">    4698 </span><span class="lineCov">     247816 :   if (result == NO_GOOD_ACCESS)</span>
<span class="lineNum">    4699 </span>            :     {
<span class="lineNum">    4700 </span><span class="lineCov">       8657 :       representatives.release ();</span>
<span class="lineNum">    4701 </span><span class="lineCov">       8657 :       return NO_GOOD_ACCESS;</span>
<span class="lineNum">    4702 </span>            :     }
<span class="lineNum">    4703 </span>            : 
<span class="lineNum">    4704 </span>            :   return result;
<span class="lineNum">    4705 </span>            : }
<span class="lineNum">    4706 </span>            : 
<span class="lineNum">    4707 </span>            : /* Return the index of BASE in PARMS.  Abort if it is not found.  */
<a name="4708"><span class="lineNum">    4708 </span>            : </a>
<span class="lineNum">    4709 </span>            : static inline int
<span class="lineNum">    4710 </span><span class="lineCov">     451838 : get_param_index (tree base, vec&lt;tree&gt; parms)</span>
<span class="lineNum">    4711 </span>            : {
<span class="lineNum">    4712 </span><span class="lineCov">     451838 :   int i, len;</span>
<span class="lineNum">    4713 </span>            : 
<span class="lineNum">    4714 </span><span class="lineCov">     451838 :   len = parms.length ();</span>
<span class="lineNum">    4715 </span><span class="lineCov">     807244 :   for (i = 0; i &lt; len; i++)</span>
<span class="lineNum">    4716 </span><span class="lineCov">     807244 :     if (parms[i] == base)</span>
<span class="lineNum">    4717 </span><span class="lineCov">     451838 :       return i;</span>
<span class="lineNum">    4718 </span><span class="lineNoCov">          0 :   gcc_unreachable ();</span>
<span class="lineNum">    4719 </span>            : }
<span class="lineNum">    4720 </span>            : 
<span class="lineNum">    4721 </span>            : /* Convert the decisions made at the representative level into compact
<span class="lineNum">    4722 </span>            :    parameter adjustments.  REPRESENTATIVES are pointers to first
<span class="lineNum">    4723 </span>            :    representatives of each param accesses, ADJUSTMENTS_COUNT is the expected
<span class="lineNum">    4724 </span>            :    final number of adjustments.  */
<a name="4725"><span class="lineNum">    4725 </span>            : </a>
<span class="lineNum">    4726 </span>            : static ipa_parm_adjustment_vec
<span class="lineNum">    4727 </span><span class="lineCov">     213461 : turn_representatives_into_adjustments (vec&lt;access_p&gt; representatives,</span>
<span class="lineNum">    4728 </span>            :                                        int adjustments_count)
<span class="lineNum">    4729 </span>            : {
<span class="lineNum">    4730 </span><span class="lineCov">     213461 :   vec&lt;tree&gt; parms;</span>
<span class="lineNum">    4731 </span><span class="lineCov">     213461 :   ipa_parm_adjustment_vec adjustments;</span>
<span class="lineNum">    4732 </span><span class="lineCov">     213461 :   tree parm;</span>
<span class="lineNum">    4733 </span><span class="lineCov">     213461 :   int i;</span>
<span class="lineNum">    4734 </span>            : 
<span class="lineNum">    4735 </span><span class="lineCov">     213461 :   gcc_assert (adjustments_count &gt; 0);</span>
<span class="lineNum">    4736 </span><span class="lineCov">     213461 :   parms = ipa_get_vector_of_formal_parms (current_function_decl);</span>
<span class="lineNum">    4737 </span><span class="lineCov">     213461 :   adjustments.create (adjustments_count);</span>
<span class="lineNum">    4738 </span><span class="lineCov">     213461 :   parm = DECL_ARGUMENTS (current_function_decl);</span>
<span class="lineNum">    4739 </span><span class="lineCov">     665299 :   for (i = 0; i &lt; func_param_count; i++, parm = DECL_CHAIN (parm))</span>
<span class="lineNum">    4740 </span>            :     {
<span class="lineNum">    4741 </span><span class="lineCov">     451838 :       struct access *repr = representatives[i];</span>
<span class="lineNum">    4742 </span>            : 
<span class="lineNum">    4743 </span><span class="lineCov">     451838 :       if (!repr || no_accesses_p (repr))</span>
<span class="lineNum">    4744 </span>            :         {
<span class="lineNum">    4745 </span><span class="lineCov">     361607 :           struct ipa_parm_adjustment adj;</span>
<span class="lineNum">    4746 </span>            : 
<span class="lineNum">    4747 </span><span class="lineCov">     361607 :           memset (&amp;adj, 0, sizeof (adj));</span>
<span class="lineNum">    4748 </span><span class="lineCov">     361607 :           adj.base_index = get_param_index (parm, parms);</span>
<span class="lineNum">    4749 </span><span class="lineCov">     361607 :           adj.base = parm;</span>
<span class="lineNum">    4750 </span><span class="lineCov">     361607 :           if (!repr)</span>
<span class="lineNum">    4751 </span><span class="lineCov">     162841 :             adj.op = IPA_PARM_OP_COPY;</span>
<span class="lineNum">    4752 </span>            :           else
<span class="lineNum">    4753 </span><span class="lineCov">     198766 :             adj.op = IPA_PARM_OP_REMOVE;</span>
<span class="lineNum">    4754 </span><span class="lineCov">     361607 :           adj.arg_prefix = &quot;ISRA&quot;;</span>
<span class="lineNum">    4755 </span><span class="lineCov">     361607 :           adjustments.quick_push (adj);</span>
<span class="lineNum">    4756 </span>            :         }
<span class="lineNum">    4757 </span>            :       else
<span class="lineNum">    4758 </span>            :         {
<span class="lineNum">    4759 </span><span class="lineCov">      90231 :           struct ipa_parm_adjustment adj;</span>
<span class="lineNum">    4760 </span><span class="lineCov">      90231 :           int index = get_param_index (parm, parms);</span>
<span class="lineNum">    4761 </span>            : 
<span class="lineNum">    4762 </span><span class="lineCov">     192970 :           for (; repr; repr = repr-&gt;next_grp)</span>
<span class="lineNum">    4763 </span>            :             {
<span class="lineNum">    4764 </span><span class="lineCov">     102739 :               memset (&amp;adj, 0, sizeof (adj));</span>
<span class="lineNum">    4765 </span><span class="lineCov">     102739 :               gcc_assert (repr-&gt;base == parm);</span>
<span class="lineNum">    4766 </span><span class="lineCov">     102739 :               adj.base_index = index;</span>
<span class="lineNum">    4767 </span><span class="lineCov">     102739 :               adj.base = repr-&gt;base;</span>
<span class="lineNum">    4768 </span><span class="lineCov">     102739 :               adj.type = repr-&gt;type;</span>
<span class="lineNum">    4769 </span><span class="lineCov">     102739 :               adj.alias_ptr_type = reference_alias_ptr_type (repr-&gt;expr);</span>
<span class="lineNum">    4770 </span><span class="lineCov">     102739 :               adj.offset = repr-&gt;offset;</span>
<span class="lineNum">    4771 </span><span class="lineCov">     102739 :               adj.reverse = repr-&gt;reverse;</span>
<span class="lineNum">    4772 </span><span class="lineCov">     181715 :               adj.by_ref = (POINTER_TYPE_P (TREE_TYPE (repr-&gt;base))</span>
<span class="lineNum">    4773 </span><span class="lineCov">     102739 :                             &amp;&amp; (repr-&gt;grp_maybe_modified</span>
<span class="lineNum">    4774 </span><span class="lineCov">      93641 :                                 || repr-&gt;grp_not_necessarilly_dereferenced));</span>
<span class="lineNum">    4775 </span><span class="lineCov">     102739 :               adj.arg_prefix = &quot;ISRA&quot;;</span>
<span class="lineNum">    4776 </span><span class="lineCov">     102739 :               adjustments.quick_push (adj);</span>
<span class="lineNum">    4777 </span>            :             }
<span class="lineNum">    4778 </span>            :         }
<span class="lineNum">    4779 </span>            :     }
<span class="lineNum">    4780 </span><span class="lineCov">     213461 :   parms.release ();</span>
<span class="lineNum">    4781 </span><span class="lineCov">     213461 :   return adjustments;</span>
<span class="lineNum">    4782 </span>            : }
<span class="lineNum">    4783 </span>            : 
<span class="lineNum">    4784 </span>            : /* Analyze the collected accesses and produce a plan what to do with the
<span class="lineNum">    4785 </span>            :    parameters in the form of adjustments, NULL meaning nothing.  */
<a name="4786"><span class="lineNum">    4786 </span>            : </a>
<span class="lineNum">    4787 </span>            : static ipa_parm_adjustment_vec
<span class="lineNum">    4788 </span><span class="lineCov">     247816 : analyze_all_param_acesses (void)</span>
<span class="lineNum">    4789 </span>            : {
<span class="lineNum">    4790 </span><span class="lineCov">     247816 :   enum ipa_splicing_result repr_state;</span>
<span class="lineNum">    4791 </span><span class="lineCov">     247816 :   bool proceed = false;</span>
<span class="lineNum">    4792 </span><span class="lineCov">     247816 :   int i, adjustments_count = 0;</span>
<span class="lineNum">    4793 </span><span class="lineCov">     247816 :   vec&lt;access_p&gt; representatives;</span>
<span class="lineNum">    4794 </span><span class="lineCov">     247816 :   ipa_parm_adjustment_vec adjustments;</span>
<span class="lineNum">    4795 </span>            : 
<span class="lineNum">    4796 </span><span class="lineCov">     247816 :   repr_state = splice_all_param_accesses (representatives);</span>
<span class="lineNum">    4797 </span><span class="lineCov">     247816 :   if (repr_state == NO_GOOD_ACCESS)</span>
<span class="lineNum">    4798 </span><span class="lineCov">       8657 :     return ipa_parm_adjustment_vec ();</span>
<span class="lineNum">    4799 </span>            : 
<span class="lineNum">    4800 </span>            :   /* If there are any parameters passed by reference which are not modified
<span class="lineNum">    4801 </span>            :      directly, we need to check whether they can be modified indirectly.  */
<span class="lineNum">    4802 </span><span class="lineCov">     239159 :   if (repr_state == UNMODIF_BY_REF_ACCESSES)</span>
<span class="lineNum">    4803 </span>            :     {
<span class="lineNum">    4804 </span><span class="lineCov">      72019 :       analyze_caller_dereference_legality (representatives);</span>
<span class="lineNum">    4805 </span><span class="lineCov">      72019 :       analyze_modified_params (representatives);</span>
<span class="lineNum">    4806 </span>            :     }
<span class="lineNum">    4807 </span>            : 
<span class="lineNum">    4808 </span><span class="lineCov">     752394 :   for (i = 0; i &lt; func_param_count; i++)</span>
<span class="lineNum">    4809 </span>            :     {
<span class="lineNum">    4810 </span><span class="lineCov">     513235 :       struct access *repr = representatives[i];</span>
<span class="lineNum">    4811 </span>            : 
<span class="lineNum">    4812 </span><span class="lineCov">     513235 :       if (repr &amp;&amp; !no_accesses_p (repr))</span>
<span class="lineNum">    4813 </span>            :         {
<span class="lineNum">    4814 </span><span class="lineCov">     147042 :           if (repr-&gt;grp_scalar_ptr)</span>
<span class="lineNum">    4815 </span>            :             {
<span class="lineNum">    4816 </span><span class="lineCov">      22209 :               adjustments_count++;</span>
<span class="lineNum">    4817 </span><span class="lineCov">      44418 :               if (repr-&gt;grp_not_necessarilly_dereferenced</span>
<span class="lineNum">    4818 </span><span class="lineCov">      22209 :                   || repr-&gt;grp_maybe_modified)</span>
<span class="lineNum">    4819 </span><span class="lineCov">       9032 :                 representatives[i] = NULL;</span>
<span class="lineNum">    4820 </span>            :               else
<span class="lineNum">    4821 </span>            :                 {
<span class="lineNum">    4822 </span><span class="lineCov">      17693 :                   proceed = true;</span>
<span class="lineNum">    4823 </span><span class="lineCov">      17693 :                   sra_stats.scalar_by_ref_to_by_val++;</span>
<span class="lineNum">    4824 </span>            :                 }
<span class="lineNum">    4825 </span>            :             }
<span class="lineNum">    4826 </span>            :           else
<span class="lineNum">    4827 </span>            :             {
<span class="lineNum">    4828 </span><span class="lineCov">     124833 :               int new_components = decide_one_param_reduction (repr);</span>
<span class="lineNum">    4829 </span>            : 
<span class="lineNum">    4830 </span><span class="lineCov">     124833 :               if (new_components == 0)</span>
<span class="lineNum">    4831 </span>            :                 {
<span class="lineNum">    4832 </span><span class="lineCov">      52295 :                   representatives[i] = NULL;</span>
<span class="lineNum">    4833 </span><span class="lineCov">      52295 :                   adjustments_count++;</span>
<span class="lineNum">    4834 </span>            :                 }
<span class="lineNum">    4835 </span>            :               else
<span class="lineNum">    4836 </span>            :                 {
<span class="lineNum">    4837 </span><span class="lineCov">      72538 :                   adjustments_count += new_components;</span>
<span class="lineNum">    4838 </span><span class="lineCov">      72538 :                   sra_stats.aggregate_params_reduced++;</span>
<span class="lineNum">    4839 </span><span class="lineCov">      72538 :                   sra_stats.param_reductions_created += new_components;</span>
<span class="lineNum">    4840 </span><span class="lineCov">      72538 :                   proceed = true;</span>
<span class="lineNum">    4841 </span>            :                 }
<span class="lineNum">    4842 </span>            :             }
<span class="lineNum">    4843 </span>            :         }
<span class="lineNum">    4844 </span>            :       else
<span class="lineNum">    4845 </span>            :         {
<span class="lineNum">    4846 </span><span class="lineCov">     366193 :           if (no_accesses_p (repr))</span>
<span class="lineNum">    4847 </span>            :             {
<span class="lineNum">    4848 </span><span class="lineCov">     198766 :               proceed = true;</span>
<span class="lineNum">    4849 </span><span class="lineCov">     198766 :               sra_stats.deleted_unused_parameters++;</span>
<span class="lineNum">    4850 </span>            :             }
<span class="lineNum">    4851 </span><span class="lineCov">     366193 :           adjustments_count++;</span>
<span class="lineNum">    4852 </span>            :         }
<span class="lineNum">    4853 </span>            :     }
<span class="lineNum">    4854 </span>            : 
<span class="lineNum">    4855 </span><span class="lineCov">     239159 :   if (!proceed &amp;&amp; dump_file)</span>
<span class="lineNum">    4856 </span><span class="lineNoCov">          0 :     fprintf (dump_file, &quot;NOT proceeding to change params.\n&quot;);</span>
<span class="lineNum">    4857 </span>            : 
<span class="lineNum">    4858 </span><span class="lineCov">     239159 :   if (proceed)</span>
<span class="lineNum">    4859 </span><span class="lineCov">     213461 :     adjustments = turn_representatives_into_adjustments (representatives,</span>
<span class="lineNum">    4860 </span><span class="lineCov">     213461 :                                                          adjustments_count);</span>
<span class="lineNum">    4861 </span>            :   else
<span class="lineNum">    4862 </span>            :     adjustments = ipa_parm_adjustment_vec ();
<span class="lineNum">    4863 </span>            : 
<span class="lineNum">    4864 </span><span class="lineCov">     239159 :   representatives.release ();</span>
<span class="lineNum">    4865 </span><span class="lineCov">     239159 :   return adjustments;</span>
<span class="lineNum">    4866 </span>            : }
<span class="lineNum">    4867 </span>            : 
<span class="lineNum">    4868 </span>            : /* If a parameter replacement identified by ADJ does not yet exist in the form
<span class="lineNum">    4869 </span>            :    of declaration, create it and record it, otherwise return the previously
<span class="lineNum">    4870 </span>            :    created one.  */
<a name="4871"><span class="lineNum">    4871 </span>            : </a>
<span class="lineNum">    4872 </span>            : static tree
<span class="lineNum">    4873 </span><span class="lineCov">         59 : get_replaced_param_substitute (struct ipa_parm_adjustment *adj)</span>
<span class="lineNum">    4874 </span>            : {
<span class="lineNum">    4875 </span><span class="lineCov">         59 :   tree repl;</span>
<span class="lineNum">    4876 </span><span class="lineCov">         59 :   if (!adj-&gt;new_ssa_base)</span>
<span class="lineNum">    4877 </span>            :     {
<span class="lineNum">    4878 </span><span class="lineCov">         36 :       char *pretty_name = make_fancy_name (adj-&gt;base);</span>
<span class="lineNum">    4879 </span>            : 
<span class="lineNum">    4880 </span><span class="lineCov">         36 :       repl = create_tmp_reg (TREE_TYPE (adj-&gt;base), &quot;ISR&quot;);</span>
<span class="lineNum">    4881 </span><span class="lineCov">         36 :       DECL_NAME (repl) = get_identifier (pretty_name);</span>
<span class="lineNum">    4882 </span><span class="lineCov">         36 :       DECL_NAMELESS (repl) = 1;</span>
<span class="lineNum">    4883 </span><span class="lineCov">         36 :       obstack_free (&amp;name_obstack, pretty_name);</span>
<span class="lineNum">    4884 </span>            : 
<span class="lineNum">    4885 </span><span class="lineCov">         36 :       adj-&gt;new_ssa_base = repl;</span>
<span class="lineNum">    4886 </span>            :     }
<span class="lineNum">    4887 </span>            :   else
<span class="lineNum">    4888 </span>            :     repl = adj-&gt;new_ssa_base;
<span class="lineNum">    4889 </span><span class="lineCov">         59 :   return repl;</span>
<span class="lineNum">    4890 </span>            : }
<span class="lineNum">    4891 </span>            : 
<span class="lineNum">    4892 </span>            : /* Find the first adjustment for a particular parameter BASE in a vector of
<span class="lineNum">    4893 </span>            :    ADJUSTMENTS which is not a copy_param.  Return NULL if there is no such
<span class="lineNum">    4894 </span>            :    adjustment. */
<a name="4895"><span class="lineNum">    4895 </span>            : </a>
<span class="lineNum">    4896 </span>            : static struct ipa_parm_adjustment *
<span class="lineNum">    4897 </span><span class="lineCov">       8086 : get_adjustment_for_base (ipa_parm_adjustment_vec adjustments, tree base)</span>
<span class="lineNum">    4898 </span>            : {
<span class="lineNum">    4899 </span><span class="lineCov">       8086 :   int i, len;</span>
<span class="lineNum">    4900 </span>            : 
<span class="lineNum">    4901 </span><span class="lineCov">       8086 :   len = adjustments.length ();</span>
<span class="lineNum">    4902 </span><span class="lineCov">      38697 :   for (i = 0; i &lt; len; i++)</span>
<span class="lineNum">    4903 </span>            :     {
<span class="lineNum">    4904 </span><span class="lineCov">      30670 :       struct ipa_parm_adjustment *adj;</span>
<span class="lineNum">    4905 </span>            : 
<span class="lineNum">    4906 </span><span class="lineCov">      30670 :       adj = &amp;adjustments[i];</span>
<span class="lineNum">    4907 </span><span class="lineCov">      30670 :       if (adj-&gt;op != IPA_PARM_OP_COPY &amp;&amp; adj-&gt;base == base)</span>
<span class="lineNum">    4908 </span><span class="lineCov">         59 :         return adj;</span>
<span class="lineNum">    4909 </span>            :     }
<span class="lineNum">    4910 </span>            : 
<span class="lineNum">    4911 </span>            :   return NULL;
<span class="lineNum">    4912 </span>            : }
<span class="lineNum">    4913 </span>            : 
<span class="lineNum">    4914 </span>            : /* If OLD_NAME, which is being defined by statement STMT, is an SSA_NAME of a
<span class="lineNum">    4915 </span>            :    parameter which is to be removed because its value is not used, create a new
<span class="lineNum">    4916 </span>            :    SSA_NAME relating to a replacement VAR_DECL, replace all uses of the
<span class="lineNum">    4917 </span>            :    original with it and return it.  If there is no need to re-map, return NULL.
<span class="lineNum">    4918 </span>            :    ADJUSTMENTS is a pointer to a vector of IPA-SRA adjustments.  */
<a name="4919"><span class="lineNum">    4919 </span>            : </a>
<span class="lineNum">    4920 </span>            : static tree
<span class="lineNum">    4921 </span><span class="lineCov">     438996 : replace_removed_params_ssa_names (tree old_name, gimple *stmt,</span>
<span class="lineNum">    4922 </span>            :                                   ipa_parm_adjustment_vec adjustments)
<span class="lineNum">    4923 </span>            : {
<span class="lineNum">    4924 </span><span class="lineCov">     438996 :   struct ipa_parm_adjustment *adj;</span>
<span class="lineNum">    4925 </span><span class="lineCov">     438996 :   tree decl, repl, new_name;</span>
<span class="lineNum">    4926 </span>            : 
<span class="lineNum">    4927 </span><span class="lineCov">     438996 :   if (TREE_CODE (old_name) != SSA_NAME)</span>
<span class="lineNum">    4928 </span>            :     return NULL;
<span class="lineNum">    4929 </span>            : 
<span class="lineNum">    4930 </span><span class="lineCov">     877992 :   decl = SSA_NAME_VAR (old_name);</span>
<span class="lineNum">    4931 </span><span class="lineCov">     111447 :   if (decl == NULL_TREE</span>
<span class="lineNum">    4932 </span><span class="lineCov">     111447 :       || TREE_CODE (decl) != PARM_DECL)</span>
<span class="lineNum">    4933 </span>            :     return NULL;
<span class="lineNum">    4934 </span>            : 
<span class="lineNum">    4935 </span><span class="lineCov">       8086 :   adj = get_adjustment_for_base (adjustments, decl);</span>
<span class="lineNum">    4936 </span><span class="lineCov">       8086 :   if (!adj)</span>
<span class="lineNum">    4937 </span>            :     return NULL;
<span class="lineNum">    4938 </span>            : 
<span class="lineNum">    4939 </span><span class="lineCov">         59 :   repl = get_replaced_param_substitute (adj);</span>
<span class="lineNum">    4940 </span><span class="lineCov">         59 :   new_name = make_ssa_name (repl, stmt);</span>
<span class="lineNum">    4941 </span><span class="lineCov">        177 :   SSA_NAME_OCCURS_IN_ABNORMAL_PHI (new_name)</span>
<span class="lineNum">    4942 </span><span class="lineCov">         59 :     = SSA_NAME_OCCURS_IN_ABNORMAL_PHI (old_name);</span>
<span class="lineNum">    4943 </span>            : 
<span class="lineNum">    4944 </span><span class="lineCov">         59 :   if (dump_file)</span>
<span class="lineNum">    4945 </span>            :     {
<span class="lineNum">    4946 </span><span class="lineCov">          5 :       fprintf (dump_file, &quot;replacing an SSA name of a removed param &quot;);</span>
<span class="lineNum">    4947 </span><span class="lineCov">          5 :       print_generic_expr (dump_file, old_name);</span>
<span class="lineNum">    4948 </span><span class="lineCov">          5 :       fprintf (dump_file, &quot; with &quot;);</span>
<span class="lineNum">    4949 </span><span class="lineCov">          5 :       print_generic_expr (dump_file, new_name);</span>
<span class="lineNum">    4950 </span><span class="lineCov">          5 :       fprintf (dump_file, &quot;\n&quot;);</span>
<span class="lineNum">    4951 </span>            :     }
<span class="lineNum">    4952 </span>            : 
<span class="lineNum">    4953 </span><span class="lineCov">         59 :   replace_uses_by (old_name, new_name);</span>
<span class="lineNum">    4954 </span><span class="lineCov">         59 :   return new_name;</span>
<span class="lineNum">    4955 </span>            : }
<span class="lineNum">    4956 </span>            : 
<span class="lineNum">    4957 </span>            : /* If the statement STMT contains any expressions that need to replaced with a
<span class="lineNum">    4958 </span>            :    different one as noted by ADJUSTMENTS, do so.  Handle any potential type
<span class="lineNum">    4959 </span>            :    incompatibilities (GSI is used to accommodate conversion statements and must
<span class="lineNum">    4960 </span>            :    point to the statement).  Return true iff the statement was modified.  */
<a name="4961"><span class="lineNum">    4961 </span>            : </a>
<span class="lineNum">    4962 </span>            : static bool
<span class="lineNum">    4963 </span><span class="lineCov">     508034 : sra_ipa_modify_assign (gimple *stmt, gimple_stmt_iterator *gsi,</span>
<span class="lineNum">    4964 </span>            :                        ipa_parm_adjustment_vec adjustments)
<span class="lineNum">    4965 </span>            : {
<span class="lineNum">    4966 </span><span class="lineCov">     508034 :   tree *lhs_p, *rhs_p;</span>
<span class="lineNum">    4967 </span><span class="lineCov">     508034 :   bool any;</span>
<span class="lineNum">    4968 </span>            : 
<span class="lineNum">    4969 </span><span class="lineCov">     508034 :   if (!gimple_assign_single_p (stmt))</span>
<span class="lineNum">    4970 </span>            :     return false;
<span class="lineNum">    4971 </span>            : 
<span class="lineNum">    4972 </span><span class="lineCov">     376689 :   rhs_p = gimple_assign_rhs1_ptr (stmt);</span>
<span class="lineNum">    4973 </span><span class="lineCov">     376689 :   lhs_p = gimple_assign_lhs_ptr (stmt);</span>
<span class="lineNum">    4974 </span>            : 
<span class="lineNum">    4975 </span><span class="lineCov">     376689 :   any = ipa_modify_expr (rhs_p, false, adjustments);</span>
<span class="lineNum">    4976 </span><span class="lineCov">     376689 :   any |= ipa_modify_expr (lhs_p, false, adjustments);</span>
<span class="lineNum">    4977 </span><span class="lineCov">     376689 :   if (any)</span>
<span class="lineNum">    4978 </span>            :     {
<span class="lineNum">    4979 </span><span class="lineCov">     109743 :       tree new_rhs = NULL_TREE;</span>
<span class="lineNum">    4980 </span>            : 
<span class="lineNum">    4981 </span><span class="lineCov">     109743 :       if (!useless_type_conversion_p (TREE_TYPE (*lhs_p), TREE_TYPE (*rhs_p)))</span>
<span class="lineNum">    4982 </span>            :         {
<span class="lineNum">    4983 </span><span class="lineCov">         58 :           if (TREE_CODE (*rhs_p) == CONSTRUCTOR)</span>
<span class="lineNum">    4984 </span>            :             {
<span class="lineNum">    4985 </span>            :               /* V_C_Es of constructors can cause trouble (PR 42714).  */
<span class="lineNum">    4986 </span><span class="lineCov">         49 :               if (is_gimple_reg_type (TREE_TYPE (*lhs_p)))</span>
<span class="lineNum">    4987 </span><span class="lineCov">         98 :                 *rhs_p = build_zero_cst (TREE_TYPE (*lhs_p));</span>
<span class="lineNum">    4988 </span>            :               else
<span class="lineNum">    4989 </span><span class="lineNoCov">          0 :                 *rhs_p = build_constructor (TREE_TYPE (*lhs_p),</span>
<span class="lineNum">    4990 </span>            :                                             NULL);
<span class="lineNum">    4991 </span>            :             }
<span class="lineNum">    4992 </span>            :           else
<span class="lineNum">    4993 </span><span class="lineCov">          9 :             new_rhs = fold_build1_loc (gimple_location (stmt),</span>
<span class="lineNum">    4994 </span><span class="lineCov">          9 :                                        VIEW_CONVERT_EXPR, TREE_TYPE (*lhs_p),</span>
<span class="lineNum">    4995 </span>            :                                        *rhs_p);
<span class="lineNum">    4996 </span>            :         }
<span class="lineNum">    4997 </span><span class="lineCov">     109685 :       else if (REFERENCE_CLASS_P (*rhs_p)</span>
<span class="lineNum">    4998 </span><span class="lineCov">      10349 :                &amp;&amp; is_gimple_reg_type (TREE_TYPE (*lhs_p))</span>
<span class="lineNum">    4999 </span><span class="lineCov">     119890 :                &amp;&amp; !is_gimple_reg (*lhs_p))</span>
<span class="lineNum">    5000 </span>            :         /* This can happen when an assignment in between two single field
<span class="lineNum">    5001 </span>            :            structures is turned into an assignment in between two pointers to
<span class="lineNum">    5002 </span>            :            scalars (PR 42237).  */
<span class="lineNum">    5003 </span><span class="lineNoCov">          0 :         new_rhs = *rhs_p;</span>
<span class="lineNum">    5004 </span>            : 
<span class="lineNum">    5005 </span><span class="lineCov">         58 :       if (new_rhs)</span>
<span class="lineNum">    5006 </span>            :         {
<span class="lineNum">    5007 </span><span class="lineCov">          9 :           tree tmp = force_gimple_operand_gsi (gsi, new_rhs, true, NULL_TREE,</span>
<span class="lineNum">    5008 </span>            :                                                true, GSI_SAME_STMT);
<span class="lineNum">    5009 </span>            : 
<span class="lineNum">    5010 </span><span class="lineCov">          9 :           gimple_assign_set_rhs_from_tree (gsi, tmp);</span>
<span class="lineNum">    5011 </span>            :         }
<span class="lineNum">    5012 </span>            : 
<span class="lineNum">    5013 </span><span class="lineCov">     109743 :       return true;</span>
<span class="lineNum">    5014 </span>            :     }
<span class="lineNum">    5015 </span>            : 
<span class="lineNum">    5016 </span>            :   return false;
<span class="lineNum">    5017 </span>            : }
<span class="lineNum">    5018 </span>            : 
<span class="lineNum">    5019 </span>            : /* Traverse the function body and all modifications as described in
<span class="lineNum">    5020 </span>            :    ADJUSTMENTS.  Return true iff the CFG has been changed.  */
<a name="5021"><span class="lineNum">    5021 </span>            : </a>
<span class="lineNum">    5022 </span>            : bool
<span class="lineNum">    5023 </span><span class="lineCov">     213461 : ipa_sra_modify_function_body (ipa_parm_adjustment_vec adjustments)</span>
<span class="lineNum">    5024 </span>            : {
<span class="lineNum">    5025 </span><span class="lineCov">     213461 :   bool cfg_changed = false;</span>
<span class="lineNum">    5026 </span><span class="lineCov">     213461 :   basic_block bb;</span>
<span class="lineNum">    5027 </span>            : 
<span class="lineNum">    5028 </span><span class="lineCov">     827421 :   FOR_EACH_BB_FN (bb, cfun)</span>
<span class="lineNum">    5029 </span>            :     {
<span class="lineNum">    5030 </span><span class="lineCov">     613960 :       gimple_stmt_iterator gsi;</span>
<span class="lineNum">    5031 </span>            : 
<span class="lineNum">    5032 </span><span class="lineCov">     690638 :       for (gsi = gsi_start_phis (bb); !gsi_end_p (gsi); gsi_next (&amp;gsi))</span>
<span class="lineNum">    5033 </span>            :         {
<span class="lineNum">    5034 </span><span class="lineCov">     153356 :           gphi *phi = as_a &lt;gphi *&gt; (gsi_stmt (gsi));</span>
<span class="lineNum">    5035 </span><span class="lineCov">      76678 :           tree new_lhs, old_lhs = gimple_phi_result (phi);</span>
<span class="lineNum">    5036 </span><span class="lineCov">      76678 :           new_lhs = replace_removed_params_ssa_names (old_lhs, phi, adjustments);</span>
<span class="lineNum">    5037 </span><span class="lineCov">      76678 :           if (new_lhs)</span>
<span class="lineNum">    5038 </span>            :             {
<span class="lineNum">    5039 </span><span class="lineCov">         20 :               gimple_phi_set_result (phi, new_lhs);</span>
<span class="lineNum">    5040 </span><span class="lineCov">         20 :               release_ssa_name (old_lhs);</span>
<span class="lineNum">    5041 </span>            :             }
<span class="lineNum">    5042 </span>            :         }
<span class="lineNum">    5043 </span>            : 
<span class="lineNum">    5044 </span><span class="lineCov">    1227920 :       gsi = gsi_start_bb (bb);</span>
<span class="lineNum">    5045 </span><span class="lineCov">    5505922 :       while (!gsi_end_p (gsi))</span>
<span class="lineNum">    5046 </span>            :         {
<span class="lineNum">    5047 </span><span class="lineCov">    4278002 :           gimple *stmt = gsi_stmt (gsi);</span>
<span class="lineNum">    5048 </span><span class="lineCov">    4278002 :           bool modified = false;</span>
<span class="lineNum">    5049 </span><span class="lineCov">    4278002 :           tree *t;</span>
<span class="lineNum">    5050 </span><span class="lineCov">    4278002 :           unsigned i;</span>
<span class="lineNum">    5051 </span>            : 
<span class="lineNum">    5052 </span><span class="lineCov">    8556004 :           switch (gimple_code (stmt))</span>
<span class="lineNum">    5053 </span>            :             {
<span class="lineNum">    5054 </span><span class="lineCov">     211690 :             case GIMPLE_RETURN:</span>
<span class="lineNum">    5055 </span><span class="lineCov">     211690 :               t = gimple_return_retval_ptr (as_a &lt;greturn *&gt; (stmt));</span>
<span class="lineNum">    5056 </span><span class="lineCov">     211690 :               if (*t != NULL_TREE)</span>
<span class="lineNum">    5057 </span><span class="lineCov">     116805 :                 modified |= ipa_modify_expr (t, true, adjustments);</span>
<span class="lineNum">    5058 </span>            :               break;
<span class="lineNum">    5059 </span>            : 
<span class="lineNum">    5060 </span><span class="lineCov">     508034 :             case GIMPLE_ASSIGN:</span>
<span class="lineNum">    5061 </span><span class="lineCov">     508034 :               modified |= sra_ipa_modify_assign (stmt, &amp;gsi, adjustments);</span>
<span class="lineNum">    5062 </span><span class="lineCov">     508034 :               break;</span>
<span class="lineNum">    5063 </span>            : 
<span class="lineNum">    5064 </span>            :             case GIMPLE_CALL:
<span class="lineNum">    5065 </span>            :               /* Operands must be processed before the lhs.  */
<span class="lineNum">    5066 </span><span class="lineCov">     270101 :               for (i = 0; i &lt; gimple_call_num_args (stmt); i++)</span>
<span class="lineNum">    5067 </span>            :                 {
<span class="lineNum">    5068 </span><span class="lineCov">     162476 :                   t = gimple_call_arg_ptr (stmt, i);</span>
<span class="lineNum">    5069 </span><span class="lineCov">     162476 :                   modified |= ipa_modify_expr (t, true, adjustments);</span>
<span class="lineNum">    5070 </span>            :                 }
<span class="lineNum">    5071 </span>            : 
<span class="lineNum">    5072 </span><span class="lineCov">     107625 :               if (gimple_call_lhs (stmt))</span>
<span class="lineNum">    5073 </span>            :                 {
<span class="lineNum">    5074 </span><span class="lineCov">      37866 :                   t = gimple_call_lhs_ptr (stmt);</span>
<span class="lineNum">    5075 </span><span class="lineCov">      37866 :                   modified |= ipa_modify_expr (t, false, adjustments);</span>
<span class="lineNum">    5076 </span>            :                 }
<span class="lineNum">    5077 </span>            :               break;
<span class="lineNum">    5078 </span>            : 
<span class="lineNum">    5079 </span><span class="lineCov">        122 :             case GIMPLE_ASM:</span>
<span class="lineNum">    5080 </span><span class="lineCov">        122 :               {</span>
<span class="lineNum">    5081 </span><span class="lineCov">        122 :                 gasm *asm_stmt = as_a &lt;gasm *&gt; (stmt);</span>
<span class="lineNum">    5082 </span><span class="lineCov">        304 :                 for (i = 0; i &lt; gimple_asm_ninputs (asm_stmt); i++)</span>
<span class="lineNum">    5083 </span>            :                   {
<span class="lineNum">    5084 </span><span class="lineCov">         60 :                     t = &amp;TREE_VALUE (gimple_asm_input_op (asm_stmt, i));</span>
<span class="lineNum">    5085 </span><span class="lineCov">         30 :                     modified |= ipa_modify_expr (t, true, adjustments);</span>
<span class="lineNum">    5086 </span>            :                   }
<span class="lineNum">    5087 </span><span class="lineCov">        390 :                 for (i = 0; i &lt; gimple_asm_noutputs (asm_stmt); i++)</span>
<span class="lineNum">    5088 </span>            :                   {
<span class="lineNum">    5089 </span><span class="lineCov">        146 :                     t = &amp;TREE_VALUE (gimple_asm_output_op (asm_stmt, i));</span>
<span class="lineNum">    5090 </span><span class="lineCov">         73 :                     modified |= ipa_modify_expr (t, false, adjustments);</span>
<span class="lineNum">    5091 </span><span class="lineCov">        122 :                   }</span>
<span class="lineNum">    5092 </span>            :               }
<span class="lineNum">    5093 </span>            :               break;
<span class="lineNum">    5094 </span>            : 
<span class="lineNum">    5095 </span>            :             default:
<span class="lineNum">    5096 </span>            :               break;
<span class="lineNum">    5097 </span>            :             }
<span class="lineNum">    5098 </span>            : 
<span class="lineNum">    5099 </span><span class="lineCov">    4278002 :           def_operand_p defp;</span>
<span class="lineNum">    5100 </span><span class="lineCov">    4278002 :           ssa_op_iter iter;</span>
<span class="lineNum">    5101 </span><span class="lineCov">    4640320 :           FOR_EACH_SSA_DEF_OPERAND (defp, stmt, iter, SSA_OP_DEF)</span>
<span class="lineNum">    5102 </span>            :             {
<span class="lineNum">    5103 </span><span class="lineCov">     362318 :               tree old_def = DEF_FROM_PTR (defp);</span>
<span class="lineNum">    5104 </span><span class="lineCov">     362318 :               if (tree new_def = replace_removed_params_ssa_names (old_def, stmt,</span>
<span class="lineNum">    5105 </span><span class="lineCov">     362318 :                                                                    adjustments))</span>
<span class="lineNum">    5106 </span>            :                 {
<span class="lineNum">    5107 </span><span class="lineCov">         39 :                   SET_DEF (defp, new_def);</span>
<span class="lineNum">    5108 </span><span class="lineCov">         39 :                   release_ssa_name (old_def);</span>
<span class="lineNum">    5109 </span><span class="lineCov">         39 :                   modified = true;</span>
<span class="lineNum">    5110 </span>            :                 }
<span class="lineNum">    5111 </span>            :             }
<span class="lineNum">    5112 </span>            : 
<span class="lineNum">    5113 </span><span class="lineCov">    4278002 :           if (modified)</span>
<span class="lineNum">    5114 </span>            :             {
<span class="lineNum">    5115 </span><span class="lineCov">     109883 :               update_stmt (stmt);</span>
<span class="lineNum">    5116 </span><span class="lineCov">     109883 :               if (maybe_clean_eh_stmt (stmt)</span>
<span class="lineNum">    5117 </span><span class="lineCov">     109883 :                   &amp;&amp; gimple_purge_dead_eh_edges (gimple_bb (stmt)))</span>
<span class="lineNum">    5118 </span>            :                 cfg_changed = true;
<span class="lineNum">    5119 </span>            :             }
<span class="lineNum">    5120 </span><span class="lineCov">    4278002 :           gsi_next (&amp;gsi);</span>
<span class="lineNum">    5121 </span>            :         }
<span class="lineNum">    5122 </span>            :     }
<span class="lineNum">    5123 </span>            : 
<span class="lineNum">    5124 </span><span class="lineCov">     213461 :   return cfg_changed;</span>
<span class="lineNum">    5125 </span>            : }
<span class="lineNum">    5126 </span>            : 
<span class="lineNum">    5127 </span>            : /* Call gimple_debug_bind_reset_value on all debug statements describing
<span class="lineNum">    5128 </span>            :    gimple register parameters that are being removed or replaced.  */
<a name="5129"><span class="lineNum">    5129 </span>            : </a>
<span class="lineNum">    5130 </span>            : static void
<span class="lineNum">    5131 </span><span class="lineCov">     213461 : sra_ipa_reset_debug_stmts (ipa_parm_adjustment_vec adjustments)</span>
<span class="lineNum">    5132 </span>            : {
<span class="lineNum">    5133 </span><span class="lineCov">     213461 :   int i, len;</span>
<span class="lineNum">    5134 </span><span class="lineCov">     213461 :   gimple_stmt_iterator *gsip = NULL, gsi;</span>
<span class="lineNum">    5135 </span>            : 
<span class="lineNum">    5136 </span><span class="lineCov">     213461 :   if (MAY_HAVE_DEBUG_STMTS &amp;&amp; single_succ_p (ENTRY_BLOCK_PTR_FOR_FN (cfun)))</span>
<span class="lineNum">    5137 </span>            :     {
<span class="lineNum">    5138 </span><span class="lineCov">     204942 :       gsi = gsi_after_labels (single_succ (ENTRY_BLOCK_PTR_FOR_FN (cfun)));</span>
<span class="lineNum">    5139 </span><span class="lineCov">     204942 :       gsip = &amp;gsi;</span>
<span class="lineNum">    5140 </span>            :     }
<span class="lineNum">    5141 </span><span class="lineCov">     213461 :   len = adjustments.length ();</span>
<span class="lineNum">    5142 </span><span class="lineCov">     677807 :   for (i = 0; i &lt; len; i++)</span>
<span class="lineNum">    5143 </span>            :     {
<span class="lineNum">    5144 </span><span class="lineCov">     464346 :       struct ipa_parm_adjustment *adj;</span>
<span class="lineNum">    5145 </span><span class="lineCov">     464346 :       imm_use_iterator ui;</span>
<span class="lineNum">    5146 </span><span class="lineCov">     464346 :       gimple *stmt;</span>
<span class="lineNum">    5147 </span><span class="lineCov">     464346 :       gdebug *def_temp;</span>
<span class="lineNum">    5148 </span><span class="lineCov">     464346 :       tree name, vexpr, copy = NULL_TREE;</span>
<span class="lineNum">    5149 </span><span class="lineCov">     464346 :       use_operand_p use_p;</span>
<span class="lineNum">    5150 </span>            : 
<span class="lineNum">    5151 </span><span class="lineCov">     464346 :       adj = &amp;adjustments[i];</span>
<span class="lineNum">    5152 </span><span class="lineCov">     464346 :       if (adj-&gt;op == IPA_PARM_OP_COPY || !is_gimple_reg (adj-&gt;base))</span>
<span class="lineNum">    5153 </span><span class="lineCov">     196987 :         continue;</span>
<span class="lineNum">    5154 </span><span class="lineCov">     267359 :       name = ssa_default_def (cfun, adj-&gt;base);</span>
<span class="lineNum">    5155 </span><span class="lineCov">     267359 :       vexpr = NULL;</span>
<span class="lineNum">    5156 </span><span class="lineCov">     267359 :       if (name)</span>
<span class="lineNum">    5157 </span><span class="lineCov">     123851 :         FOR_EACH_IMM_USE_STMT (stmt, ui, name)</span>
<span class="lineNum">    5158 </span>            :           {
<span class="lineNum">    5159 </span><span class="lineCov">      28250 :             if (gimple_clobber_p (stmt))</span>
<span class="lineNum">    5160 </span>            :               {
<span class="lineNum">    5161 </span><span class="lineCov">       1960 :                 gimple_stmt_iterator cgsi = gsi_for_stmt (stmt);</span>
<span class="lineNum">    5162 </span><span class="lineCov">       1960 :                 unlink_stmt_vdef (stmt);</span>
<span class="lineNum">    5163 </span><span class="lineCov">       1960 :                 gsi_remove (&amp;cgsi, true);</span>
<span class="lineNum">    5164 </span><span class="lineCov">       1960 :                 release_defs (stmt);</span>
<span class="lineNum">    5165 </span><span class="lineCov">       1960 :                 continue;</span>
<span class="lineNum">    5166 </span>            :               }
<span class="lineNum">    5167 </span>            :             /* All other users must have been removed by
<span class="lineNum">    5168 </span>            :                ipa_sra_modify_function_body.  */
<span class="lineNum">    5169 </span><span class="lineCov">      52580 :             gcc_assert (is_gimple_debug (stmt));</span>
<span class="lineNum">    5170 </span><span class="lineCov">      26290 :             if (vexpr == NULL &amp;&amp; gsip != NULL)</span>
<span class="lineNum">    5171 </span>            :               {
<span class="lineNum">    5172 </span><span class="lineCov">      15385 :                 gcc_assert (TREE_CODE (adj-&gt;base) == PARM_DECL);</span>
<span class="lineNum">    5173 </span><span class="lineCov">      15385 :                 vexpr = make_node (DEBUG_EXPR_DECL);</span>
<span class="lineNum">    5174 </span><span class="lineCov">      15385 :                 def_temp = gimple_build_debug_source_bind (vexpr, adj-&gt;base,</span>
<span class="lineNum">    5175 </span>            :                                                            NULL);
<span class="lineNum">    5176 </span><span class="lineCov">      15385 :                 DECL_ARTIFICIAL (vexpr) = 1;</span>
<span class="lineNum">    5177 </span><span class="lineCov">      15385 :                 TREE_TYPE (vexpr) = TREE_TYPE (name);</span>
<span class="lineNum">    5178 </span><span class="lineCov">      15385 :                 SET_DECL_MODE (vexpr, DECL_MODE (adj-&gt;base));</span>
<span class="lineNum">    5179 </span><span class="lineCov">      15385 :                 gsi_insert_before (gsip, def_temp, GSI_SAME_STMT);</span>
<span class="lineNum">    5180 </span>            :               }
<span class="lineNum">    5181 </span><span class="lineCov">      26290 :             if (vexpr)</span>
<span class="lineNum">    5182 </span>            :               {
<span class="lineNum">    5183 </span><span class="lineCov">     157740 :                 FOR_EACH_IMM_USE_ON_STMT (use_p, ui)</span>
<span class="lineNum">    5184 </span><span class="lineCov">      26290 :                   SET_USE (use_p, vexpr);</span>
<span class="lineNum">    5185 </span>            :               }
<span class="lineNum">    5186 </span>            :             else
<span class="lineNum">    5187 </span><span class="lineNoCov">          0 :               gimple_debug_bind_reset_value (stmt);</span>
<span class="lineNum">    5188 </span><span class="lineCov">      26290 :             update_stmt (stmt);</span>
<span class="lineNum">    5189 </span>            :           }
<span class="lineNum">    5190 </span>            :       /* Create a VAR_DECL for debug info purposes.  */
<span class="lineNum">    5191 </span><span class="lineCov">     267359 :       if (!DECL_IGNORED_P (adj-&gt;base))</span>
<span class="lineNum">    5192 </span>            :         {
<span class="lineNum">    5193 </span><span class="lineCov">     267359 :           copy = build_decl (DECL_SOURCE_LOCATION (current_function_decl),</span>
<span class="lineNum">    5194 </span><span class="lineCov">     267359 :                              VAR_DECL, DECL_NAME (adj-&gt;base),</span>
<span class="lineNum">    5195 </span><span class="lineCov">     267359 :                              TREE_TYPE (adj-&gt;base));</span>
<span class="lineNum">    5196 </span><span class="lineCov">     267359 :           if (DECL_PT_UID_SET_P (adj-&gt;base))</span>
<span class="lineNum">    5197 </span><span class="lineNoCov">          0 :             SET_DECL_PT_UID (copy, DECL_PT_UID (adj-&gt;base));</span>
<span class="lineNum">    5198 </span><span class="lineCov">     267359 :           TREE_ADDRESSABLE (copy) = TREE_ADDRESSABLE (adj-&gt;base);</span>
<span class="lineNum">    5199 </span><span class="lineCov">     267359 :           TREE_READONLY (copy) = TREE_READONLY (adj-&gt;base);</span>
<span class="lineNum">    5200 </span><span class="lineCov">     267359 :           TREE_THIS_VOLATILE (copy) = TREE_THIS_VOLATILE (adj-&gt;base);</span>
<span class="lineNum">    5201 </span><span class="lineCov">     267359 :           DECL_GIMPLE_REG_P (copy) = DECL_GIMPLE_REG_P (adj-&gt;base);</span>
<span class="lineNum">    5202 </span><span class="lineCov">     267359 :           DECL_ARTIFICIAL (copy) = DECL_ARTIFICIAL (adj-&gt;base);</span>
<span class="lineNum">    5203 </span><span class="lineCov">     267359 :           DECL_IGNORED_P (copy) = DECL_IGNORED_P (adj-&gt;base);</span>
<span class="lineNum">    5204 </span><span class="lineCov">     267359 :           DECL_ABSTRACT_ORIGIN (copy) = DECL_ORIGIN (adj-&gt;base);</span>
<span class="lineNum">    5205 </span><span class="lineCov">     267359 :           DECL_SEEN_IN_BIND_EXPR_P (copy) = 1;</span>
<span class="lineNum">    5206 </span><span class="lineCov">     267359 :           SET_DECL_RTL (copy, 0);</span>
<span class="lineNum">    5207 </span><span class="lineCov">     267359 :           TREE_USED (copy) = 1;</span>
<span class="lineNum">    5208 </span><span class="lineCov">     267359 :           DECL_CONTEXT (copy) = current_function_decl;</span>
<span class="lineNum">    5209 </span><span class="lineCov">     267359 :           add_local_decl (cfun, copy);</span>
<span class="lineNum">    5210 </span><span class="lineCov">     267359 :           DECL_CHAIN (copy) =</span>
<span class="lineNum">    5211 </span><span class="lineCov">     267359 :             BLOCK_VARS (DECL_INITIAL (current_function_decl));</span>
<span class="lineNum">    5212 </span><span class="lineCov">     267359 :           BLOCK_VARS (DECL_INITIAL (current_function_decl)) = copy;</span>
<span class="lineNum">    5213 </span>            :         }
<span class="lineNum">    5214 </span><span class="lineCov">     267359 :       if (gsip != NULL &amp;&amp; copy &amp;&amp; target_for_debug_bind (adj-&gt;base))</span>
<span class="lineNum">    5215 </span>            :         {
<span class="lineNum">    5216 </span><span class="lineCov">     255584 :           gcc_assert (TREE_CODE (adj-&gt;base) == PARM_DECL);</span>
<span class="lineNum">    5217 </span><span class="lineCov">     255584 :           if (vexpr)</span>
<span class="lineNum">    5218 </span><span class="lineCov">      15385 :             def_temp = gimple_build_debug_bind (copy, vexpr, NULL);</span>
<span class="lineNum">    5219 </span>            :           else
<span class="lineNum">    5220 </span><span class="lineCov">     240199 :             def_temp = gimple_build_debug_source_bind (copy, adj-&gt;base,</span>
<span class="lineNum">    5221 </span>            :                                                        NULL);
<span class="lineNum">    5222 </span><span class="lineCov">     255584 :           gsi_insert_before (gsip, def_temp, GSI_SAME_STMT);</span>
<span class="lineNum">    5223 </span>            :         }
<span class="lineNum">    5224 </span>            :     }
<span class="lineNum">    5225 </span><span class="lineCov">     213461 : }</span>
<span class="lineNum">    5226 </span>            : 
<span class="lineNum">    5227 </span>            : /* Return false if all callers have at least as many actual arguments as there
<span class="lineNum">    5228 </span>            :    are formal parameters in the current function and that their types
<span class="lineNum">    5229 </span>            :    match.  */
<a name="5230"><span class="lineNum">    5230 </span>            : </a>
<span class="lineNum">    5231 </span>            : static bool
<span class="lineNum">    5232 </span><span class="lineCov">     262948 : some_callers_have_mismatched_arguments_p (struct cgraph_node *node,</span>
<span class="lineNum">    5233 </span>            :                                           void *data ATTRIBUTE_UNUSED)
<span class="lineNum">    5234 </span>            : {
<span class="lineNum">    5235 </span><span class="lineCov">     262948 :   struct cgraph_edge *cs;</span>
<span class="lineNum">    5236 </span><span class="lineCov">     815820 :   for (cs = node-&gt;callers; cs; cs = cs-&gt;next_caller)</span>
<span class="lineNum">    5237 </span><span class="lineCov">     557383 :     if (!cs-&gt;call_stmt || !callsite_arguments_match_p (cs-&gt;call_stmt))</span>
<span class="lineNum">    5238 </span><span class="lineCov">       4511 :       return true;</span>
<span class="lineNum">    5239 </span>            : 
<span class="lineNum">    5240 </span>            :   return false;
<span class="lineNum">    5241 </span>            : }
<span class="lineNum">    5242 </span>            : 
<span class="lineNum">    5243 </span>            : /* Return false if all callers have vuse attached to a call statement.  */
<a name="5244"><span class="lineNum">    5244 </span>            : </a>
<span class="lineNum">    5245 </span>            : static bool
<span class="lineNum">    5246 </span><span class="lineCov">     258297 : some_callers_have_no_vuse_p (struct cgraph_node *node,</span>
<span class="lineNum">    5247 </span>            :                              void *data ATTRIBUTE_UNUSED)
<span class="lineNum">    5248 </span>            : {
<span class="lineNum">    5249 </span><span class="lineCov">     258297 :   struct cgraph_edge *cs;</span>
<span class="lineNum">    5250 </span><span class="lineCov">     811163 :   for (cs = node-&gt;callers; cs; cs = cs-&gt;next_caller)</span>
<span class="lineNum">    5251 </span><span class="lineCov">    1105744 :     if (!cs-&gt;call_stmt || !gimple_vuse (cs-&gt;call_stmt))</span>
<span class="lineNum">    5252 </span>            :       return true;
<span class="lineNum">    5253 </span>            : 
<span class="lineNum">    5254 </span>            :   return false;
<span class="lineNum">    5255 </span>            : }
<span class="lineNum">    5256 </span>            : 
<span class="lineNum">    5257 </span>            : /* Convert all callers of NODE.  */
<a name="5258"><span class="lineNum">    5258 </span>            : </a>
<span class="lineNum">    5259 </span>            : static bool
<span class="lineNum">    5260 </span><span class="lineCov">     213461 : convert_callers_for_node (struct cgraph_node *node,</span>
<span class="lineNum">    5261 </span>            :                           void *data)
<span class="lineNum">    5262 </span>            : {
<span class="lineNum">    5263 </span><span class="lineCov">     213461 :   ipa_parm_adjustment_vec *adjustments = (ipa_parm_adjustment_vec *) data;</span>
<span class="lineNum">    5264 </span><span class="lineCov">     213461 :   bitmap recomputed_callers = BITMAP_ALLOC (NULL);</span>
<span class="lineNum">    5265 </span><span class="lineCov">     213461 :   struct cgraph_edge *cs;</span>
<span class="lineNum">    5266 </span>            : 
<span class="lineNum">    5267 </span><span class="lineCov">     698240 :   for (cs = node-&gt;callers; cs; cs = cs-&gt;next_caller)</span>
<span class="lineNum">    5268 </span>            :     {
<span class="lineNum">    5269 </span><span class="lineCov">     484779 :       push_cfun (DECL_STRUCT_FUNCTION (cs-&gt;caller-&gt;decl));</span>
<span class="lineNum">    5270 </span>            : 
<span class="lineNum">    5271 </span><span class="lineCov">     484779 :       if (dump_file)</span>
<span class="lineNum">    5272 </span><span class="lineCov">         12 :         fprintf (dump_file, &quot;Adjusting call %s -&gt; %s\n&quot;,</span>
<span class="lineNum">    5273 </span><span class="lineCov">         12 :                  cs-&gt;caller-&gt;dump_name (), cs-&gt;callee-&gt;dump_name ());</span>
<span class="lineNum">    5274 </span>            : 
<span class="lineNum">    5275 </span><span class="lineCov">     484779 :       ipa_modify_call_arguments (cs, cs-&gt;call_stmt, *adjustments);</span>
<span class="lineNum">    5276 </span>            : 
<span class="lineNum">    5277 </span><span class="lineCov">     484779 :       pop_cfun ();</span>
<span class="lineNum">    5278 </span>            :     }
<span class="lineNum">    5279 </span>            : 
<span class="lineNum">    5280 </span><span class="lineCov">     698240 :   for (cs = node-&gt;callers; cs; cs = cs-&gt;next_caller)</span>
<span class="lineNum">    5281 </span><span class="lineCov">     969558 :     if (bitmap_set_bit (recomputed_callers, cs-&gt;caller-&gt;get_uid ())</span>
<span class="lineNum">    5282 </span><span class="lineCov">     484779 :         &amp;&amp; gimple_in_ssa_p (DECL_STRUCT_FUNCTION (cs-&gt;caller-&gt;decl)))</span>
<span class="lineNum">    5283 </span><span class="lineCov">     379886 :       compute_fn_summary (cs-&gt;caller, true);</span>
<span class="lineNum">    5284 </span><span class="lineCov">     213461 :   BITMAP_FREE (recomputed_callers);</span>
<span class="lineNum">    5285 </span>            : 
<span class="lineNum">    5286 </span><span class="lineCov">     213461 :   return true;</span>
<span class="lineNum">    5287 </span>            : }
<span class="lineNum">    5288 </span>            : 
<span class="lineNum">    5289 </span>            : /* Convert all callers of NODE to pass parameters as given in ADJUSTMENTS.  */
<a name="5290"><span class="lineNum">    5290 </span>            : </a>
<span class="lineNum">    5291 </span>            : static void
<span class="lineNum">    5292 </span><span class="lineCov">     213461 : convert_callers (struct cgraph_node *node, tree old_decl,</span>
<span class="lineNum">    5293 </span>            :                  ipa_parm_adjustment_vec adjustments)
<span class="lineNum">    5294 </span>            : {
<span class="lineNum">    5295 </span><span class="lineCov">     213461 :   basic_block this_block;</span>
<span class="lineNum">    5296 </span>            : 
<span class="lineNum">    5297 </span><span class="lineCov">     213461 :   node-&gt;call_for_symbol_and_aliases (convert_callers_for_node,</span>
<span class="lineNum">    5298 </span>            :                                      &amp;adjustments, false);
<span class="lineNum">    5299 </span>            : 
<span class="lineNum">    5300 </span><span class="lineCov">     213461 :   if (!encountered_recursive_call)</span>
<span class="lineNum">    5301 </span>            :     return;
<span class="lineNum">    5302 </span>            : 
<span class="lineNum">    5303 </span><span class="lineCov">        434 :   FOR_EACH_BB_FN (this_block, cfun)</span>
<span class="lineNum">    5304 </span>            :     {
<span class="lineNum">    5305 </span><span class="lineCov">        394 :       gimple_stmt_iterator gsi;</span>
<span class="lineNum">    5306 </span>            : 
<span class="lineNum">    5307 </span><span class="lineCov">       2622 :       for (gsi = gsi_start_bb (this_block); !gsi_end_p (gsi); gsi_next (&amp;gsi))</span>
<span class="lineNum">    5308 </span>            :         {
<span class="lineNum">    5309 </span><span class="lineCov">       1834 :           gcall *stmt;</span>
<span class="lineNum">    5310 </span><span class="lineCov">       1834 :           tree call_fndecl;</span>
<span class="lineNum">    5311 </span><span class="lineCov">       3668 :           stmt = dyn_cast &lt;gcall *&gt; (gsi_stmt (gsi));</span>
<span class="lineNum">    5312 </span><span class="lineCov">         92 :           if (!stmt)</span>
<span class="lineNum">    5313 </span>            :             continue;
<span class="lineNum">    5314 </span><span class="lineCov">         92 :           call_fndecl = gimple_call_fndecl (stmt);</span>
<span class="lineNum">    5315 </span><span class="lineCov">         92 :           if (call_fndecl == old_decl)</span>
<span class="lineNum">    5316 </span>            :             {
<span class="lineNum">    5317 </span><span class="lineCov">         41 :               if (dump_file)</span>
<span class="lineNum">    5318 </span><span class="lineCov">          2 :                 fprintf (dump_file, &quot;Adjusting recursive call&quot;);</span>
<span class="lineNum">    5319 </span><span class="lineCov">         41 :               gimple_call_set_fndecl (stmt, node-&gt;decl);</span>
<span class="lineNum">    5320 </span><span class="lineCov">         41 :               ipa_modify_call_arguments (NULL, stmt, adjustments);</span>
<span class="lineNum">    5321 </span>            :             }
<span class="lineNum">    5322 </span>            :         }
<span class="lineNum">    5323 </span>            :     }
<span class="lineNum">    5324 </span>            : 
<span class="lineNum">    5325 </span>            :   return;
<span class="lineNum">    5326 </span>            : }
<span class="lineNum">    5327 </span>            : 
<span class="lineNum">    5328 </span>            : /* Perform all the modification required in IPA-SRA for NODE to have parameters
<span class="lineNum">    5329 </span>            :    as given in ADJUSTMENTS.  Return true iff the CFG has been changed.  */
<a name="5330"><span class="lineNum">    5330 </span>            : </a>
<span class="lineNum">    5331 </span>            : static bool
<span class="lineNum">    5332 </span><span class="lineCov">     213461 : modify_function (struct cgraph_node *node, ipa_parm_adjustment_vec adjustments)</span>
<span class="lineNum">    5333 </span>            : {
<span class="lineNum">    5334 </span><span class="lineCov">     213461 :   struct cgraph_node *new_node;</span>
<span class="lineNum">    5335 </span><span class="lineCov">     213461 :   bool cfg_changed;</span>
<span class="lineNum">    5336 </span>            : 
<span class="lineNum">    5337 </span><span class="lineCov">     213461 :   cgraph_edge::rebuild_edges ();</span>
<span class="lineNum">    5338 </span><span class="lineCov">     213461 :   free_dominance_info (CDI_DOMINATORS);</span>
<span class="lineNum">    5339 </span><span class="lineCov">     213461 :   pop_cfun ();</span>
<span class="lineNum">    5340 </span>            : 
<span class="lineNum">    5341 </span>            :   /* This must be done after rebuilding cgraph edges for node above.
<span class="lineNum">    5342 </span>            :      Otherwise any recursive calls to node that are recorded in
<span class="lineNum">    5343 </span>            :      redirect_callers will be corrupted.  */
<span class="lineNum">    5344 </span><span class="lineCov">     213461 :   vec&lt;cgraph_edge *&gt; redirect_callers = node-&gt;collect_callers ();</span>
<span class="lineNum">    5345 </span><span class="lineCov">     213461 :   new_node = node-&gt;create_version_clone_with_body (redirect_callers, NULL,</span>
<span class="lineNum">    5346 </span>            :                                                    NULL, false, NULL, NULL,
<span class="lineNum">    5347 </span>            :                                                    &quot;isra&quot;);
<span class="lineNum">    5348 </span><span class="lineCov">     213461 :   redirect_callers.release ();</span>
<span class="lineNum">    5349 </span>            : 
<span class="lineNum">    5350 </span><span class="lineCov">     213461 :   push_cfun (DECL_STRUCT_FUNCTION (new_node-&gt;decl));</span>
<span class="lineNum">    5351 </span><span class="lineCov">     213461 :   ipa_modify_formal_parameters (current_function_decl, adjustments);</span>
<span class="lineNum">    5352 </span><span class="lineCov">     213461 :   cfg_changed = ipa_sra_modify_function_body (adjustments);</span>
<span class="lineNum">    5353 </span><span class="lineCov">     213461 :   sra_ipa_reset_debug_stmts (adjustments);</span>
<span class="lineNum">    5354 </span><span class="lineCov">     213461 :   convert_callers (new_node, node-&gt;decl, adjustments);</span>
<span class="lineNum">    5355 </span><span class="lineCov">     213461 :   new_node-&gt;make_local ();</span>
<span class="lineNum">    5356 </span><span class="lineCov">     213461 :   return cfg_changed;</span>
<span class="lineNum">    5357 </span>            : }
<span class="lineNum">    5358 </span>            : 
<span class="lineNum">    5359 </span>            : /* Means of communication between ipa_sra_check_caller and
<span class="lineNum">    5360 </span>            :    ipa_sra_preliminary_function_checks.  */
<span class="lineNum">    5361 </span>            : 
<span class="lineNum">    5362 </span>            : struct ipa_sra_check_caller_data
<span class="lineNum">    5363 </span>            : {
<span class="lineNum">    5364 </span>            :   bool has_callers;
<span class="lineNum">    5365 </span>            :   bool bad_arg_alignment;
<span class="lineNum">    5366 </span>            :   bool has_thunk;
<span class="lineNum">    5367 </span>            : };
<span class="lineNum">    5368 </span>            : 
<span class="lineNum">    5369 </span>            : /* If NODE has a caller, mark that fact in DATA which is pointer to
<span class="lineNum">    5370 </span>            :    ipa_sra_check_caller_data.  Also check all aggregate arguments in all known
<span class="lineNum">    5371 </span>            :    calls if they are unit aligned and if not, set the appropriate flag in DATA
<span class="lineNum">    5372 </span>            :    too. */
<a name="5373"><span class="lineNum">    5373 </span>            : </a>
<span class="lineNum">    5374 </span>            : static bool
<span class="lineNum">    5375 </span><span class="lineCov">     614803 : ipa_sra_check_caller (struct cgraph_node *node, void *data)</span>
<span class="lineNum">    5376 </span>            : {
<span class="lineNum">    5377 </span><span class="lineCov">     614803 :   if (!node-&gt;callers)</span>
<span class="lineNum">    5378 </span>            :     return false;
<span class="lineNum">    5379 </span>            : 
<span class="lineNum">    5380 </span><span class="lineCov">     592857 :   struct ipa_sra_check_caller_data *iscc;</span>
<span class="lineNum">    5381 </span><span class="lineCov">     592857 :   iscc = (struct ipa_sra_check_caller_data *) data;</span>
<span class="lineNum">    5382 </span><span class="lineCov">     592857 :   iscc-&gt;has_callers = true;</span>
<span class="lineNum">    5383 </span>            : 
<span class="lineNum">    5384 </span><span class="lineCov">    2018120 :   for (cgraph_edge *cs = node-&gt;callers; cs; cs = cs-&gt;next_caller)</span>
<span class="lineNum">    5385 </span>            :     {
<span class="lineNum">    5386 </span><span class="lineCov">    1425263 :       if (cs-&gt;caller-&gt;thunk.thunk_p)</span>
<span class="lineNum">    5387 </span>            :         {
<span class="lineNum">    5388 </span><span class="lineNoCov">          0 :           iscc-&gt;has_thunk = true;</span>
<span class="lineNum">    5389 </span><span class="lineNoCov">          0 :           return true;</span>
<span class="lineNum">    5390 </span>            :         }
<span class="lineNum">    5391 </span><span class="lineCov">    1425263 :       gimple *call_stmt = cs-&gt;call_stmt;</span>
<span class="lineNum">    5392 </span><span class="lineCov">    1425263 :       unsigned count = gimple_call_num_args (call_stmt);</span>
<span class="lineNum">    5393 </span><span class="lineCov">    3768196 :       for (unsigned i = 0; i &lt; count; i++)</span>
<span class="lineNum">    5394 </span>            :         {
<span class="lineNum">    5395 </span><span class="lineCov">    2342933 :           tree arg = gimple_call_arg (call_stmt, i);</span>
<span class="lineNum">    5396 </span><span class="lineCov">    2342933 :           if (is_gimple_reg (arg))</span>
<span class="lineNum">    5397 </span><span class="lineCov">    1483194 :               continue;</span>
<span class="lineNum">    5398 </span>            : 
<span class="lineNum">    5399 </span><span class="lineCov">     859739 :           tree offset;</span>
<span class="lineNum">    5400 </span><span class="lineCov">    1719478 :           poly_int64 bitsize, bitpos;</span>
<span class="lineNum">    5401 </span><span class="lineCov">     859739 :           machine_mode mode;</span>
<span class="lineNum">    5402 </span><span class="lineCov">     859739 :           int unsignedp, reversep, volatilep = 0;</span>
<span class="lineNum">    5403 </span><span class="lineCov">     859739 :           get_inner_reference (arg, &amp;bitsize, &amp;bitpos, &amp;offset, &amp;mode,</span>
<span class="lineNum">    5404 </span>            :                                &amp;unsignedp, &amp;reversep, &amp;volatilep);
<span class="lineNum">    5405 </span><span class="lineCov">    1719478 :           if (!multiple_p (bitpos, BITS_PER_UNIT))</span>
<span class="lineNum">    5406 </span>            :             {
<span class="lineNum">    5407 </span><span class="lineNoCov">          0 :               iscc-&gt;bad_arg_alignment = true;</span>
<span class="lineNum">    5408 </span><span class="lineNoCov">          0 :               return true;</span>
<span class="lineNum">    5409 </span>            :             }
<span class="lineNum">    5410 </span>            :         }
<span class="lineNum">    5411 </span>            :     }
<span class="lineNum">    5412 </span>            : 
<span class="lineNum">    5413 </span>            :   return false;
<span class="lineNum">    5414 </span>            : }
<span class="lineNum">    5415 </span>            : 
<span class="lineNum">    5416 </span>            : /* Return false the function is apparently unsuitable for IPA-SRA based on it's
<span class="lineNum">    5417 </span>            :    attributes, return true otherwise.  NODE is the cgraph node of the current
<span class="lineNum">    5418 </span>            :    function.  */
<a name="5419"><span class="lineNum">    5419 </span>            : </a>
<span class="lineNum">    5420 </span>            : static bool
<span class="lineNum">    5421 </span><span class="lineCov">    1360123 : ipa_sra_preliminary_function_checks (struct cgraph_node *node)</span>
<span class="lineNum">    5422 </span>            : {
<span class="lineNum">    5423 </span><span class="lineCov">    1360123 :   if (!node-&gt;can_be_local_p ())</span>
<span class="lineNum">    5424 </span>            :     {
<span class="lineNum">    5425 </span><span class="lineCov">     676800 :       if (dump_file)</span>
<span class="lineNum">    5426 </span><span class="lineCov">         34 :         fprintf (dump_file, &quot;Function not local to this compilation unit.\n&quot;);</span>
<span class="lineNum">    5427 </span><span class="lineCov">     676800 :       return false;</span>
<span class="lineNum">    5428 </span>            :     }
<span class="lineNum">    5429 </span>            : 
<span class="lineNum">    5430 </span><span class="lineCov">     683323 :   if (!node-&gt;local.can_change_signature)</span>
<span class="lineNum">    5431 </span>            :     {
<span class="lineNum">    5432 </span><span class="lineCov">      19568 :       if (dump_file)</span>
<span class="lineNum">    5433 </span><span class="lineNoCov">          0 :         fprintf (dump_file, &quot;Function can not change signature.\n&quot;);</span>
<span class="lineNum">    5434 </span><span class="lineCov">      19568 :       return false;</span>
<span class="lineNum">    5435 </span>            :     }
<span class="lineNum">    5436 </span>            : 
<span class="lineNum">    5437 </span><span class="lineCov">     663755 :   if (!tree_versionable_function_p (node-&gt;decl))</span>
<span class="lineNum">    5438 </span>            :     {
<span class="lineNum">    5439 </span><span class="lineCov">        733 :       if (dump_file)</span>
<span class="lineNum">    5440 </span><span class="lineCov">          1 :         fprintf (dump_file, &quot;Function is not versionable.\n&quot;);</span>
<span class="lineNum">    5441 </span><span class="lineCov">        733 :       return false;</span>
<span class="lineNum">    5442 </span>            :     }
<span class="lineNum">    5443 </span>            : 
<span class="lineNum">    5444 </span><span class="lineCov">     663022 :   if (!opt_for_fn (node-&gt;decl, optimize)</span>
<span class="lineNum">    5445 </span><span class="lineCov">     663022 :       || !opt_for_fn (node-&gt;decl, flag_ipa_sra))</span>
<span class="lineNum">    5446 </span>            :     {
<span class="lineNum">    5447 </span><span class="lineNoCov">          0 :       if (dump_file)</span>
<span class="lineNum">    5448 </span><span class="lineNoCov">          0 :         fprintf (dump_file, &quot;Function not optimized.\n&quot;);</span>
<span class="lineNum">    5449 </span><span class="lineNoCov">          0 :       return false;</span>
<span class="lineNum">    5450 </span>            :     }
<span class="lineNum">    5451 </span>            : 
<span class="lineNum">    5452 </span><span class="lineCov">     663022 :   if (DECL_VIRTUAL_P (current_function_decl))</span>
<span class="lineNum">    5453 </span>            :     {
<span class="lineNum">    5454 </span><span class="lineCov">       2393 :       if (dump_file)</span>
<span class="lineNum">    5455 </span><span class="lineNoCov">          0 :         fprintf (dump_file, &quot;Function is a virtual method.\n&quot;);</span>
<span class="lineNum">    5456 </span><span class="lineCov">       2393 :       return false;</span>
<span class="lineNum">    5457 </span>            :     }
<span class="lineNum">    5458 </span>            : 
<span class="lineNum">    5459 </span><span class="lineCov">    1321258 :   if ((DECL_ONE_ONLY (node-&gt;decl) || DECL_EXTERNAL (node-&gt;decl))</span>
<span class="lineNum">    5460 </span><span class="lineCov">    1168916 :       &amp;&amp; ipa_fn_summaries-&gt;get (node)</span>
<span class="lineNum">    5461 </span><span class="lineCov">    1829545 :       &amp;&amp; ipa_fn_summaries-&gt;get (node)-&gt;size &gt;= MAX_INLINE_INSNS_AUTO)</span>
<span class="lineNum">    5462 </span>            :     {
<span class="lineNum">    5463 </span><span class="lineCov">      44441 :       if (dump_file)</span>
<span class="lineNum">    5464 </span><span class="lineNoCov">          0 :         fprintf (dump_file, &quot;Function too big to be made truly local.\n&quot;);</span>
<span class="lineNum">    5465 </span><span class="lineCov">      44441 :       return false;</span>
<span class="lineNum">    5466 </span>            :     }
<span class="lineNum">    5467 </span>            : 
<span class="lineNum">    5468 </span><span class="lineCov">     616188 :   if (cfun-&gt;stdarg)</span>
<span class="lineNum">    5469 </span>            :     {
<span class="lineNum">    5470 </span><span class="lineCov">        228 :       if (dump_file)</span>
<span class="lineNum">    5471 </span><span class="lineNoCov">          0 :         fprintf (dump_file, &quot;Function uses stdarg. \n&quot;);</span>
<span class="lineNum">    5472 </span><span class="lineCov">        228 :       return false;</span>
<span class="lineNum">    5473 </span>            :     }
<span class="lineNum">    5474 </span>            : 
<span class="lineNum">    5475 </span><span class="lineCov">     615960 :   if (TYPE_ATTRIBUTES (TREE_TYPE (node-&gt;decl)))</span>
<span class="lineNum">    5476 </span>            :     return false;
<span class="lineNum">    5477 </span>            : 
<span class="lineNum">    5478 </span><span class="lineCov">     615960 :   if (DECL_DISREGARD_INLINE_LIMITS (node-&gt;decl))</span>
<span class="lineNum">    5479 </span>            :     {
<span class="lineNum">    5480 </span><span class="lineCov">      16775 :       if (dump_file)</span>
<span class="lineNum">    5481 </span><span class="lineNoCov">          0 :         fprintf (dump_file, &quot;Always inline function will be inlined &quot;</span>
<span class="lineNum">    5482 </span>            :                  &quot;anyway. \n&quot;);
<span class="lineNum">    5483 </span><span class="lineCov">      16775 :       return false;</span>
<span class="lineNum">    5484 </span>            :     }
<span class="lineNum">    5485 </span>            : 
<span class="lineNum">    5486 </span><span class="lineCov">     599185 :   struct ipa_sra_check_caller_data iscc;</span>
<span class="lineNum">    5487 </span><span class="lineCov">     599185 :   memset (&amp;iscc, 0, sizeof(iscc));</span>
<span class="lineNum">    5488 </span><span class="lineCov">     599185 :   node-&gt;call_for_symbol_and_aliases (ipa_sra_check_caller, &amp;iscc, true);</span>
<span class="lineNum">    5489 </span><span class="lineCov">     599185 :   if (!iscc.has_callers)</span>
<span class="lineNum">    5490 </span>            :     {
<span class="lineNum">    5491 </span><span class="lineCov">       9528 :       if (dump_file)</span>
<span class="lineNum">    5492 </span><span class="lineNoCov">          0 :         fprintf (dump_file,</span>
<span class="lineNum">    5493 </span>            :                  &quot;Function has no callers in this compilation unit.\n&quot;);
<span class="lineNum">    5494 </span><span class="lineCov">       9528 :       return false;</span>
<span class="lineNum">    5495 </span>            :     }
<span class="lineNum">    5496 </span>            : 
<span class="lineNum">    5497 </span><span class="lineCov">     589657 :   if (iscc.bad_arg_alignment)</span>
<span class="lineNum">    5498 </span>            :     {
<span class="lineNum">    5499 </span><span class="lineNoCov">          0 :       if (dump_file)</span>
<span class="lineNum">    5500 </span><span class="lineNoCov">          0 :         fprintf (dump_file,</span>
<span class="lineNum">    5501 </span>            :                  &quot;A function call has an argument with non-unit alignment.\n&quot;);
<span class="lineNum">    5502 </span><span class="lineNoCov">          0 :       return false;</span>
<span class="lineNum">    5503 </span>            :     }
<span class="lineNum">    5504 </span>            : 
<span class="lineNum">    5505 </span><span class="lineCov">     589657 :   if (iscc.has_thunk)</span>
<span class="lineNum">    5506 </span>            :     {
<span class="lineNum">    5507 </span><span class="lineNoCov">          0 :       if (dump_file)</span>
<span class="lineNum">    5508 </span><span class="lineNoCov">          0 :         fprintf (dump_file,</span>
<span class="lineNum">    5509 </span>            :                  &quot;A has thunk.\n&quot;);
<span class="lineNum">    5510 </span><span class="lineNoCov">          0 :       return false;</span>
<span class="lineNum">    5511 </span>            :     }
<span class="lineNum">    5512 </span>            : 
<span class="lineNum">    5513 </span>            :   return true;
<span class="lineNum">    5514 </span>            : }
<span class="lineNum">    5515 </span>            : 
<span class="lineNum">    5516 </span>            : /* Perform early interprocedural SRA.  */
<a name="5517"><span class="lineNum">    5517 </span>            : </a>
<span class="lineNum">    5518 </span>            : static unsigned int
<span class="lineNum">    5519 </span><span class="lineCov">    1360123 : ipa_early_sra (void)</span>
<span class="lineNum">    5520 </span>            : {
<span class="lineNum">    5521 </span><span class="lineCov">    1360123 :   struct cgraph_node *node = cgraph_node::get (current_function_decl);</span>
<span class="lineNum">    5522 </span><span class="lineCov">    1360123 :   ipa_parm_adjustment_vec adjustments;</span>
<span class="lineNum">    5523 </span><span class="lineCov">    1360123 :   int ret = 0;</span>
<span class="lineNum">    5524 </span>            : 
<span class="lineNum">    5525 </span><span class="lineCov">    1360123 :   if (!ipa_sra_preliminary_function_checks (node))</span>
<span class="lineNum">    5526 </span>            :     return 0;
<span class="lineNum">    5527 </span>            : 
<span class="lineNum">    5528 </span><span class="lineCov">     589657 :   sra_initialize ();</span>
<span class="lineNum">    5529 </span><span class="lineCov">     589657 :   sra_mode = SRA_MODE_EARLY_IPA;</span>
<span class="lineNum">    5530 </span>            : 
<span class="lineNum">    5531 </span><span class="lineCov">     589657 :   if (!find_param_candidates ())</span>
<span class="lineNum">    5532 </span>            :     {
<span class="lineNum">    5533 </span><span class="lineCov">     337324 :       if (dump_file)</span>
<span class="lineNum">    5534 </span><span class="lineCov">          1 :         fprintf (dump_file, &quot;Function has no IPA-SRA candidates.\n&quot;);</span>
<span class="lineNum">    5535 </span><span class="lineCov">     337324 :       goto simple_out;</span>
<span class="lineNum">    5536 </span>            :     }
<span class="lineNum">    5537 </span>            : 
<span class="lineNum">    5538 </span><span class="lineCov">     252333 :   if (node-&gt;call_for_symbol_and_aliases</span>
<span class="lineNum">    5539 </span><span class="lineCov">     252333 :        (some_callers_have_mismatched_arguments_p, NULL, true))</span>
<span class="lineNum">    5540 </span>            :     {
<span class="lineNum">    5541 </span><span class="lineCov">       4511 :       if (dump_file)</span>
<span class="lineNum">    5542 </span><span class="lineNoCov">          0 :         fprintf (dump_file, &quot;There are callers with insufficient number of &quot;</span>
<span class="lineNum">    5543 </span>            :                  &quot;arguments or arguments with type mismatches.\n&quot;);
<span class="lineNum">    5544 </span><span class="lineCov">       4511 :       goto simple_out;</span>
<span class="lineNum">    5545 </span>            :     }
<span class="lineNum">    5546 </span>            : 
<span class="lineNum">    5547 </span><span class="lineCov">     247822 :   if (node-&gt;call_for_symbol_and_aliases</span>
<span class="lineNum">    5548 </span><span class="lineCov">     247822 :        (some_callers_have_no_vuse_p, NULL, true))</span>
<span class="lineNum">    5549 </span>            :     {
<span class="lineNum">    5550 </span><span class="lineCov">          6 :       if (dump_file)</span>
<span class="lineNum">    5551 </span><span class="lineNoCov">          0 :         fprintf (dump_file, &quot;There are callers with no VUSE attached &quot;</span>
<span class="lineNum">    5552 </span>            :                  &quot;to a call stmt.\n&quot;);
<span class="lineNum">    5553 </span><span class="lineCov">          6 :       goto simple_out;</span>
<span class="lineNum">    5554 </span>            :     }
<span class="lineNum">    5555 </span>            : 
<span class="lineNum">    5556 </span><span class="lineCov">     247816 :   bb_dereferences = XCNEWVEC (HOST_WIDE_INT,</span>
<span class="lineNum">    5557 </span>            :                                  func_param_count
<span class="lineNum">    5558 </span>            :                                  * last_basic_block_for_fn (cfun));
<span class="lineNum">    5559 </span><span class="lineCov">     247816 :   final_bbs = BITMAP_ALLOC (NULL);</span>
<span class="lineNum">    5560 </span>            : 
<span class="lineNum">    5561 </span><span class="lineCov">     247816 :   scan_function ();</span>
<span class="lineNum">    5562 </span><span class="lineCov">     247816 :   if (encountered_apply_args)</span>
<span class="lineNum">    5563 </span>            :     {
<span class="lineNum">    5564 </span><span class="lineNoCov">          0 :       if (dump_file)</span>
<span class="lineNum">    5565 </span><span class="lineNoCov">          0 :         fprintf (dump_file, &quot;Function calls  __builtin_apply_args().\n&quot;);</span>
<span class="lineNum">    5566 </span><span class="lineNoCov">          0 :       goto out;</span>
<span class="lineNum">    5567 </span>            :     }
<span class="lineNum">    5568 </span>            : 
<span class="lineNum">    5569 </span><span class="lineCov">     247816 :   if (encountered_unchangable_recursive_call)</span>
<span class="lineNum">    5570 </span>            :     {
<span class="lineNum">    5571 </span><span class="lineNoCov">          0 :       if (dump_file)</span>
<span class="lineNum">    5572 </span><span class="lineNoCov">          0 :         fprintf (dump_file, &quot;Function calls itself with insufficient &quot;</span>
<span class="lineNum">    5573 </span>            :                  &quot;number of arguments.\n&quot;);
<span class="lineNum">    5574 </span><span class="lineNoCov">          0 :       goto out;</span>
<span class="lineNum">    5575 </span>            :     }
<span class="lineNum">    5576 </span>            : 
<span class="lineNum">    5577 </span><span class="lineCov">     247816 :   adjustments = analyze_all_param_acesses ();</span>
<span class="lineNum">    5578 </span><span class="lineCov">     247816 :   if (!adjustments.exists ())</span>
<span class="lineNum">    5579 </span>            :     goto out;
<span class="lineNum">    5580 </span><span class="lineCov">     213461 :   if (dump_file)</span>
<span class="lineNum">    5581 </span><span class="lineCov">         10 :     ipa_dump_param_adjustments (dump_file, adjustments, current_function_decl);</span>
<span class="lineNum">    5582 </span>            : 
<span class="lineNum">    5583 </span><span class="lineCov">     213461 :   if (modify_function (node, adjustments))</span>
<span class="lineNum">    5584 </span>            :     ret = TODO_update_ssa | TODO_cleanup_cfg;
<span class="lineNum">    5585 </span>            :   else
<span class="lineNum">    5586 </span><span class="lineCov">     213391 :     ret = TODO_update_ssa;</span>
<span class="lineNum">    5587 </span><span class="lineCov">     213461 :   adjustments.release ();</span>
<span class="lineNum">    5588 </span>            : 
<span class="lineNum">    5589 </span><span class="lineCov">     213461 :   statistics_counter_event (cfun, &quot;Unused parameters deleted&quot;,</span>
<span class="lineNum">    5590 </span>            :                             sra_stats.deleted_unused_parameters);
<span class="lineNum">    5591 </span><span class="lineCov">     213461 :   statistics_counter_event (cfun, &quot;Scalar parameters converted to by-value&quot;,</span>
<span class="lineNum">    5592 </span>            :                             sra_stats.scalar_by_ref_to_by_val);
<span class="lineNum">    5593 </span><span class="lineCov">     213461 :   statistics_counter_event (cfun, &quot;Aggregate parameters broken up&quot;,</span>
<span class="lineNum">    5594 </span>            :                             sra_stats.aggregate_params_reduced);
<span class="lineNum">    5595 </span><span class="lineCov">     213461 :   statistics_counter_event (cfun, &quot;Aggregate parameter components created&quot;,</span>
<span class="lineNum">    5596 </span>            :                             sra_stats.param_reductions_created);
<span class="lineNum">    5597 </span>            : 
<span class="lineNum">    5598 </span><span class="lineCov">     247816 :  out:</span>
<span class="lineNum">    5599 </span><span class="lineCov">     247816 :   BITMAP_FREE (final_bbs);</span>
<span class="lineNum">    5600 </span><span class="lineCov">     247816 :   free (bb_dereferences);</span>
<span class="lineNum">    5601 </span><span class="lineCov">     589657 :  simple_out:</span>
<span class="lineNum">    5602 </span><span class="lineCov">     589657 :   sra_deinitialize ();</span>
<span class="lineNum">    5603 </span><span class="lineCov">     589657 :   return ret;</span>
<span class="lineNum">    5604 </span>            : }
<span class="lineNum">    5605 </span>            : 
<span class="lineNum">    5606 </span>            : namespace {
<span class="lineNum">    5607 </span>            : 
<span class="lineNum">    5608 </span>            : const pass_data pass_data_early_ipa_sra =
<span class="lineNum">    5609 </span>            : {
<span class="lineNum">    5610 </span>            :   GIMPLE_PASS, /* type */
<span class="lineNum">    5611 </span>            :   &quot;eipa_sra&quot;, /* name */
<span class="lineNum">    5612 </span>            :   OPTGROUP_NONE, /* optinfo_flags */
<span class="lineNum">    5613 </span>            :   TV_IPA_SRA, /* tv_id */
<span class="lineNum">    5614 </span>            :   0, /* properties_required */
<span class="lineNum">    5615 </span>            :   0, /* properties_provided */
<span class="lineNum">    5616 </span>            :   0, /* properties_destroyed */
<span class="lineNum">    5617 </span>            :   0, /* todo_flags_start */
<span class="lineNum">    5618 </span>            :   TODO_dump_symtab, /* todo_flags_finish */
<span class="lineNum">    5619 </span>            : };
<span class="lineNum">    5620 </span>            : 
<span class="lineNum">    5621 </span>            : class pass_early_ipa_sra : public gimple_opt_pass
<span class="lineNum">    5622 </span>            : {
<span class="lineNum">    5623 </span>            : public:
<span class="lineNum">    5624 </span>            :   pass_early_ipa_sra (gcc::context *ctxt)
<span class="lineNum">    5625 </span><span class="lineCov">     340624 :     : gimple_opt_pass (pass_data_early_ipa_sra, ctxt)</span>
<span class="lineNum">    5626 </span>            :   {}
<a name="5627"><span class="lineNum">    5627 </span>            : </a>
<a name="5628"><span class="lineNum">    5628 </span>            :   /* opt_pass methods: */</a>
<span class="lineNum">    5629 </span><span class="lineCov">    1409355 :   virtual bool gate (function *) { return flag_ipa_sra &amp;&amp; dbg_cnt (eipa_sra); }</span>
<span class="lineNum">    5630 </span><span class="lineCov">    1360123 :   virtual unsigned int execute (function *) { return ipa_early_sra (); }</span>
<span class="lineNum">    5631 </span>            : 
<span class="lineNum">    5632 </span>            : }; // class pass_early_ipa_sra
<span class="lineNum">    5633 </span>            : 
<span class="lineNum">    5634 </span>            : } // anon namespace
<a name="5635"><span class="lineNum">    5635 </span>            : </a>
<span class="lineNum">    5636 </span>            : gimple_opt_pass *
<span class="lineNum">    5637 </span><span class="lineCov">     170312 : make_pass_early_ipa_sra (gcc::context *ctxt)</span>
<span class="lineNum">    5638 </span>            : {
<span class="lineNum">    5639 </span><span class="lineCov">     170312 :   return new pass_early_ipa_sra (ctxt);</span>
<span class="lineNum">    5640 </span>            : }
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.0</a></td></tr>
  </table>
  <br>
<h3>LCOV profile is generated on x86_64 machine using following configure options: configure --disable-bootstrap --enable-coverage=opt --enable-languages=c,c++,fortran,go,jit,lto --enable-host-shared. GCC test suite is run with the built compiler.</h3></body></html>
