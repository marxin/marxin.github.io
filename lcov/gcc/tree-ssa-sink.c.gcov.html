<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - gcc.info - gcc/tree-ssa-sink.c</title>
  <link rel="stylesheet" type="text/css" href="../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../index.html">top level</a> - <a href="index.html">gcc</a> - tree-ssa-sink.c<span style="font-size: 80%;"> (source / <a href="tree-ssa-sink.c.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">gcc.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">220</td>
            <td class="headerCovTableEntry">220</td>
            <td class="headerCovTableEntryHi">100.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2018-09-22 10:58:49</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">9</td>
            <td class="headerCovTableEntry">9</td>
            <td class="headerCovTableEntryHi">100.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /* Code sinking for trees</a>
<span class="lineNum">       2 </span>            :    Copyright (C) 2001-2018 Free Software Foundation, Inc.
<span class="lineNum">       3 </span>            :    Contributed by Daniel Berlin &lt;dan@dberlin.org&gt;
<span class="lineNum">       4 </span>            : 
<span class="lineNum">       5 </span>            : This file is part of GCC.
<span class="lineNum">       6 </span>            : 
<span class="lineNum">       7 </span>            : GCC is free software; you can redistribute it and/or modify
<span class="lineNum">       8 </span>            : it under the terms of the GNU General Public License as published by
<span class="lineNum">       9 </span>            : the Free Software Foundation; either version 3, or (at your option)
<span class="lineNum">      10 </span>            : any later version.
<span class="lineNum">      11 </span>            : 
<span class="lineNum">      12 </span>            : GCC is distributed in the hope that it will be useful,
<span class="lineNum">      13 </span>            : but WITHOUT ANY WARRANTY; without even the implied warranty of
<span class="lineNum">      14 </span>            : MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
<span class="lineNum">      15 </span>            : GNU General Public License for more details.
<span class="lineNum">      16 </span>            : 
<span class="lineNum">      17 </span>            : You should have received a copy of the GNU General Public License
<span class="lineNum">      18 </span>            : along with GCC; see the file COPYING3.  If not see
<span class="lineNum">      19 </span>            : &lt;http://www.gnu.org/licenses/&gt;.  */
<span class="lineNum">      20 </span>            : 
<span class="lineNum">      21 </span>            : #include &quot;config.h&quot;
<span class="lineNum">      22 </span>            : #include &quot;system.h&quot;
<span class="lineNum">      23 </span>            : #include &quot;coretypes.h&quot;
<span class="lineNum">      24 </span>            : #include &quot;backend.h&quot;
<span class="lineNum">      25 </span>            : #include &quot;tree.h&quot;
<span class="lineNum">      26 </span>            : #include &quot;gimple.h&quot;
<span class="lineNum">      27 </span>            : #include &quot;cfghooks.h&quot;
<span class="lineNum">      28 </span>            : #include &quot;tree-pass.h&quot;
<span class="lineNum">      29 </span>            : #include &quot;ssa.h&quot;
<span class="lineNum">      30 </span>            : #include &quot;gimple-pretty-print.h&quot;
<span class="lineNum">      31 </span>            : #include &quot;fold-const.h&quot;
<span class="lineNum">      32 </span>            : #include &quot;stor-layout.h&quot;
<span class="lineNum">      33 </span>            : #include &quot;cfganal.h&quot;
<span class="lineNum">      34 </span>            : #include &quot;gimple-iterator.h&quot;
<span class="lineNum">      35 </span>            : #include &quot;tree-cfg.h&quot;
<span class="lineNum">      36 </span>            : #include &quot;cfgloop.h&quot;
<span class="lineNum">      37 </span>            : #include &quot;params.h&quot;
<span class="lineNum">      38 </span>            : 
<span class="lineNum">      39 </span>            : /* TODO:
<span class="lineNum">      40 </span>            :    1. Sinking store only using scalar promotion (IE without moving the RHS):
<span class="lineNum">      41 </span>            : 
<span class="lineNum">      42 </span>            :    *q = p;
<span class="lineNum">      43 </span>            :    p = p + 1;
<span class="lineNum">      44 </span>            :    if (something)
<span class="lineNum">      45 </span>            :      *q = &lt;not p&gt;;
<span class="lineNum">      46 </span>            :    else
<span class="lineNum">      47 </span>            :      y = *q;
<span class="lineNum">      48 </span>            : 
<span class="lineNum">      49 </span>            : 
<span class="lineNum">      50 </span>            :    should become
<span class="lineNum">      51 </span>            :    sinktemp = p;
<span class="lineNum">      52 </span>            :    p = p + 1;
<span class="lineNum">      53 </span>            :    if (something)
<span class="lineNum">      54 </span>            :      *q = &lt;not p&gt;;
<span class="lineNum">      55 </span>            :    else
<span class="lineNum">      56 </span>            :    {
<span class="lineNum">      57 </span>            :      *q = sinktemp;
<span class="lineNum">      58 </span>            :      y = *q
<span class="lineNum">      59 </span>            :    }
<span class="lineNum">      60 </span>            :    Store copy propagation will take care of the store elimination above.
<span class="lineNum">      61 </span>            : 
<span class="lineNum">      62 </span>            : 
<span class="lineNum">      63 </span>            :    2. Sinking using Partial Dead Code Elimination.  */
<span class="lineNum">      64 </span>            : 
<span class="lineNum">      65 </span>            : 
<span class="lineNum">      66 </span>            : static struct
<span class="lineNum">      67 </span>            : {
<span class="lineNum">      68 </span>            :   /* The number of statements sunk down the flowgraph by code sinking.  */
<span class="lineNum">      69 </span>            :   int sunk;
<span class="lineNum">      70 </span>            : 
<span class="lineNum">      71 </span>            : } sink_stats;
<span class="lineNum">      72 </span>            : 
<span class="lineNum">      73 </span>            : 
<span class="lineNum">      74 </span>            : /* Given a PHI, and one of its arguments (DEF), find the edge for
<span class="lineNum">      75 </span>            :    that argument and return it.  If the argument occurs twice in the PHI node,
<span class="lineNum">      76 </span>            :    we return NULL.  */
<a name="77"><span class="lineNum">      77 </span>            : </a>
<span class="lineNum">      78 </span>            : static basic_block
<span class="lineNum">      79 </span><span class="lineCov">     109261 : find_bb_for_arg (gphi *phi, tree def)</span>
<span class="lineNum">      80 </span>            : {
<span class="lineNum">      81 </span><span class="lineCov">     109261 :   size_t i;</span>
<span class="lineNum">      82 </span><span class="lineCov">     109261 :   bool foundone = false;</span>
<span class="lineNum">      83 </span><span class="lineCov">     109261 :   basic_block result = NULL;</span>
<span class="lineNum">      84 </span><span class="lineCov">     349733 :   for (i = 0; i &lt; gimple_phi_num_args (phi); i++)</span>
<span class="lineNum">      85 </span><span class="lineCov">     244501 :     if (PHI_ARG_DEF (phi, i) == def)</span>
<span class="lineNum">      86 </span>            :       {
<span class="lineNum">      87 </span><span class="lineCov">     113290 :         if (foundone)</span>
<span class="lineNum">      88 </span>            :           return NULL;
<span class="lineNum">      89 </span><span class="lineCov">     109261 :         foundone = true;</span>
<span class="lineNum">      90 </span><span class="lineCov">     109261 :         result = gimple_phi_arg_edge (phi, i)-&gt;src;</span>
<span class="lineNum">      91 </span>            :       }
<span class="lineNum">      92 </span>            :   return result;
<span class="lineNum">      93 </span>            : }
<span class="lineNum">      94 </span>            : 
<span class="lineNum">      95 </span>            : /* When the first immediate use is in a statement, then return true if all
<span class="lineNum">      96 </span>            :    immediate uses in IMM are in the same statement.
<span class="lineNum">      97 </span>            :    We could also do the case where  the first immediate use is in a phi node,
<span class="lineNum">      98 </span>            :    and all the other uses are in phis in the same basic block, but this
<span class="lineNum">      99 </span>            :    requires some expensive checking later (you have to make sure no def/vdef
<span class="lineNum">     100 </span>            :    in the statement occurs for multiple edges in the various phi nodes it's
<span class="lineNum">     101 </span>            :    used in, so that you only have one place you can sink it to.  */
<span class="lineNum">     102 </span>            : 
<span class="lineNum">     103 </span>            : static bool
<span class="lineNum">     104 </span><span class="lineCov">    3457277 : all_immediate_uses_same_place (def_operand_p def_p)</span>
<span class="lineNum">     105 </span>            : {
<span class="lineNum">     106 </span><span class="lineCov">    3457277 :   tree var = DEF_FROM_PTR (def_p);</span>
<span class="lineNum">     107 </span><span class="lineCov">    3457277 :   imm_use_iterator imm_iter;</span>
<span class="lineNum">     108 </span><span class="lineCov">    3457277 :   use_operand_p use_p;</span>
<span class="lineNum">     109 </span>            : 
<span class="lineNum">     110 </span><span class="lineCov">    3457277 :   gimple *firstuse = NULL;</span>
<span class="lineNum">     111 </span><span class="lineCov">    7578375 :   FOR_EACH_IMM_USE_FAST (use_p, imm_iter, var)</span>
<span class="lineNum">     112 </span>            :     {
<span class="lineNum">     113 </span><span class="lineCov">   10072984 :       if (is_gimple_debug (USE_STMT (use_p)))</span>
<span class="lineNum">     114 </span>            :         continue;
<span class="lineNum">     115 </span><span class="lineCov">    4394083 :       if (firstuse == NULL)</span>
<span class="lineNum">     116 </span>            :         firstuse = USE_STMT (use_p);
<span class="lineNum">     117 </span>            :       else
<span class="lineNum">     118 </span><span class="lineCov">     936806 :         if (firstuse != USE_STMT (use_p))</span>
<span class="lineNum">     119 </span>            :           return false;
<span class="lineNum">     120 </span>            :     }
<span class="lineNum">     121 </span>            : 
<span class="lineNum">     122 </span>            :   return true;
<span class="lineNum">     123 </span>            : }
<span class="lineNum">     124 </span>            : 
<span class="lineNum">     125 </span>            : /* Find the nearest common dominator of all of the immediate uses in IMM.  */
<span class="lineNum">     126 </span>            : 
<span class="lineNum">     127 </span>            : static basic_block
<span class="lineNum">     128 </span><span class="lineCov">    3053594 : nearest_common_dominator_of_uses (def_operand_p def_p, bool *debug_stmts)</span>
<span class="lineNum">     129 </span>            : {
<span class="lineNum">     130 </span><span class="lineCov">    3053594 :   tree var = DEF_FROM_PTR (def_p);</span>
<span class="lineNum">     131 </span><span class="lineCov">    6107188 :   auto_bitmap blocks;</span>
<span class="lineNum">     132 </span><span class="lineCov">    3053594 :   basic_block commondom;</span>
<span class="lineNum">     133 </span><span class="lineCov">    3053594 :   unsigned int j;</span>
<span class="lineNum">     134 </span><span class="lineCov">    3053594 :   bitmap_iterator bi;</span>
<span class="lineNum">     135 </span><span class="lineCov">    3053594 :   imm_use_iterator imm_iter;</span>
<span class="lineNum">     136 </span><span class="lineCov">    3053594 :   use_operand_p use_p;</span>
<span class="lineNum">     137 </span>            : 
<span class="lineNum">     138 </span><span class="lineCov">   11022997 :   FOR_EACH_IMM_USE_FAST (use_p, imm_iter, var)</span>
<span class="lineNum">     139 </span>            :     {
<span class="lineNum">     140 </span><span class="lineCov">    7969403 :       gimple *usestmt = USE_STMT (use_p);</span>
<span class="lineNum">     141 </span><span class="lineCov">    7969403 :       basic_block useblock;</span>
<span class="lineNum">     142 </span>            : 
<span class="lineNum">     143 </span><span class="lineCov">    7969403 :       if (gphi *phi = dyn_cast &lt;gphi *&gt; (usestmt))</span>
<span class="lineNum">     144 </span>            :         {
<span class="lineNum">     145 </span><span class="lineCov">     814770 :           int idx = PHI_ARG_INDEX_FROM_USE (use_p);</span>
<span class="lineNum">     146 </span>            : 
<span class="lineNum">     147 </span><span class="lineCov">     814770 :           useblock = gimple_phi_arg_edge (phi, idx)-&gt;src;</span>
<span class="lineNum">     148 </span>            :         }
<span class="lineNum">     149 </span><span class="lineCov">   14309266 :       else if (is_gimple_debug (usestmt))</span>
<span class="lineNum">     150 </span>            :         {
<span class="lineNum">     151 </span><span class="lineCov">    1906769 :           *debug_stmts = true;</span>
<span class="lineNum">     152 </span><span class="lineCov">    1906769 :           continue;</span>
<span class="lineNum">     153 </span>            :         }
<span class="lineNum">     154 </span>            :       else
<span class="lineNum">     155 </span>            :         {
<span class="lineNum">     156 </span><span class="lineCov">   10495728 :           useblock = gimple_bb (usestmt);</span>
<span class="lineNum">     157 </span>            :         }
<span class="lineNum">     158 </span>            : 
<span class="lineNum">     159 </span>            :       /* Short circuit. Nothing dominates the entry block.  */
<span class="lineNum">     160 </span><span class="lineCov">    6062634 :       if (useblock == ENTRY_BLOCK_PTR_FOR_FN (cfun))</span>
<span class="lineNum">     161 </span>            :         return NULL;
<span class="lineNum">     162 </span>            : 
<span class="lineNum">     163 </span><span class="lineCov">   12125268 :       bitmap_set_bit (blocks, useblock-&gt;index);</span>
<span class="lineNum">     164 </span>            :     }
<span class="lineNum">     165 </span><span class="lineCov">    6107188 :   commondom = BASIC_BLOCK_FOR_FN (cfun, bitmap_first_set_bit (blocks));</span>
<span class="lineNum">     166 </span><span class="lineCov">   11425330 :   EXECUTE_IF_SET_IN_BITMAP (blocks, 0, j, bi)</span>
<span class="lineNum">     167 </span><span class="lineCov">    5318142 :     commondom = nearest_common_dominator (CDI_DOMINATORS, commondom,</span>
<span class="lineNum">     168 </span><span class="lineCov">    5318142 :                                           BASIC_BLOCK_FOR_FN (cfun, j));</span>
<span class="lineNum">     169 </span>            :   return commondom;
<span class="lineNum">     170 </span>            : }
<span class="lineNum">     171 </span>            : 
<span class="lineNum">     172 </span>            : /* Given EARLY_BB and LATE_BB, two blocks in a path through the dominator
<span class="lineNum">     173 </span>            :    tree, return the best basic block between them (inclusive) to place
<span class="lineNum">     174 </span>            :    statements.
<span class="lineNum">     175 </span>            : 
<span class="lineNum">     176 </span>            :    We want the most control dependent block in the shallowest loop nest.
<span class="lineNum">     177 </span>            : 
<span class="lineNum">     178 </span>            :    If the resulting block is in a shallower loop nest, then use it.  Else
<span class="lineNum">     179 </span>            :    only use the resulting block if it has significantly lower execution
<span class="lineNum">     180 </span>            :    frequency than EARLY_BB to avoid gratutious statement movement.  We
<span class="lineNum">     181 </span>            :    consider statements with VOPS more desirable to move.
<span class="lineNum">     182 </span>            : 
<span class="lineNum">     183 </span>            :    This pass would obviously benefit from PDO as it utilizes block
<span class="lineNum">     184 </span>            :    frequencies.  It would also benefit from recomputing frequencies
<span class="lineNum">     185 </span>            :    if profile data is not available since frequencies often get out
<span class="lineNum">     186 </span>            :    of sync with reality.  */
<a name="187"><span class="lineNum">     187 </span>            : </a>
<span class="lineNum">     188 </span>            : static basic_block
<span class="lineNum">     189 </span><span class="lineCov">    2758528 : select_best_block (basic_block early_bb,</span>
<span class="lineNum">     190 </span>            :                    basic_block late_bb,
<span class="lineNum">     191 </span>            :                    gimple *stmt)
<span class="lineNum">     192 </span>            : {
<span class="lineNum">     193 </span><span class="lineCov">    2758528 :   basic_block best_bb = late_bb;</span>
<span class="lineNum">     194 </span><span class="lineCov">    2758528 :   basic_block temp_bb = late_bb;</span>
<span class="lineNum">     195 </span><span class="lineCov">    3461553 :   int threshold;</span>
<span class="lineNum">     196 </span>            : 
<span class="lineNum">     197 </span><span class="lineCov">    3461553 :   while (temp_bb != early_bb)</span>
<span class="lineNum">     198 </span>            :     {
<span class="lineNum">     199 </span>            :       /* If we've moved into a lower loop nest, then that becomes
<span class="lineNum">     200 </span>            :          our best block.  */
<span class="lineNum">     201 </span><span class="lineCov">     703025 :       if (bb_loop_depth (temp_bb) &lt; bb_loop_depth (best_bb))</span>
<span class="lineNum">     202 </span><span class="lineCov">      29549 :         best_bb = temp_bb;</span>
<span class="lineNum">     203 </span>            : 
<span class="lineNum">     204 </span>            :       /* Walk up the dominator tree, hopefully we'll find a shallower
<span class="lineNum">     205 </span>            :          loop nest.  */
<span class="lineNum">     206 </span><span class="lineCov">     703025 :       temp_bb = get_immediate_dominator (CDI_DOMINATORS, temp_bb);</span>
<span class="lineNum">     207 </span>            :     }
<span class="lineNum">     208 </span>            : 
<span class="lineNum">     209 </span>            :   /* If we found a shallower loop nest, then we always consider that
<span class="lineNum">     210 </span>            :      a win.  This will always give us the most control dependent block
<span class="lineNum">     211 </span>            :      within that loop nest.  */
<span class="lineNum">     212 </span><span class="lineCov">    2758528 :   if (bb_loop_depth (best_bb) &lt; bb_loop_depth (early_bb))</span>
<span class="lineNum">     213 </span>            :     return best_bb;
<span class="lineNum">     214 </span>            : 
<span class="lineNum">     215 </span>            :   /* Get the sinking threshold.  If the statement to be moved has memory
<span class="lineNum">     216 </span>            :      operands, then increase the threshold by 7% as those are even more
<span class="lineNum">     217 </span>            :      profitable to avoid, clamping at 100%.  */
<span class="lineNum">     218 </span><span class="lineCov">    2748258 :   threshold = PARAM_VALUE (PARAM_SINK_FREQUENCY_THRESHOLD);</span>
<span class="lineNum">     219 </span><span class="lineCov">    8082053 :   if (gimple_vuse (stmt) || gimple_vdef (stmt))</span>
<span class="lineNum">     220 </span>            :     {
<span class="lineNum">     221 </span><span class="lineCov">     162721 :       threshold += 7;</span>
<span class="lineNum">     222 </span><span class="lineCov">     162721 :       if (threshold &gt; 100)</span>
<span class="lineNum">     223 </span><span class="lineCov">          7 :         threshold = 100;</span>
<span class="lineNum">     224 </span>            :     }
<span class="lineNum">     225 </span>            : 
<span class="lineNum">     226 </span>            :   /* If BEST_BB is at the same nesting level, then require it to have
<span class="lineNum">     227 </span>            :      significantly lower execution frequency to avoid gratutious movement.  */
<span class="lineNum">     228 </span><span class="lineCov">    2748258 :   if (bb_loop_depth (best_bb) == bb_loop_depth (early_bb)</span>
<span class="lineNum">     229 </span>            :       /* If result of comparsion is unknown, preffer EARLY_BB.
<span class="lineNum">     230 </span>            :          Thus use !(...&gt;=..) rather than (...&lt;...)  */
<span class="lineNum">     231 </span><span class="lineCov">    8094480 :       &amp;&amp; !(best_bb-&gt;count.apply_scale (100, 1)</span>
<span class="lineNum">     232 </span><span class="lineCov">    7891054 :            &gt; (early_bb-&gt;count.apply_scale (threshold, 1))))</span>
<span class="lineNum">     233 </span><span class="lineCov">     203426 :     return best_bb;</span>
<span class="lineNum">     234 </span>            : 
<span class="lineNum">     235 </span>            :   /* No better block found, so return EARLY_BB, which happens to be the
<span class="lineNum">     236 </span>            :      statement's original block.  */
<span class="lineNum">     237 </span>            :   return early_bb;
<span class="lineNum">     238 </span>            : }
<span class="lineNum">     239 </span>            : 
<span class="lineNum">     240 </span>            : /* Given a statement (STMT) and the basic block it is currently in (FROMBB),
<span class="lineNum">     241 </span>            :    determine the location to sink the statement to, if any.
<span class="lineNum">     242 </span>            :    Returns true if there is such location; in that case, TOGSI points to the
<span class="lineNum">     243 </span>            :    statement before that STMT should be moved.  */
<span class="lineNum">     244 </span>            : 
<span class="lineNum">     245 </span>            : static bool
<span class="lineNum">     246 </span><span class="lineCov">   34052608 : statement_sink_location (gimple *stmt, basic_block frombb,</span>
<span class="lineNum">     247 </span>            :                          gimple_stmt_iterator *togsi, bool *zero_uses_p)
<span class="lineNum">     248 </span>            : {
<span class="lineNum">     249 </span><span class="lineCov">   34052608 :   gimple *use;</span>
<span class="lineNum">     250 </span><span class="lineCov">   34052608 :   use_operand_p one_use = NULL_USE_OPERAND_P;</span>
<span class="lineNum">     251 </span><span class="lineCov">   34052608 :   basic_block sinkbb;</span>
<span class="lineNum">     252 </span><span class="lineCov">   34052608 :   use_operand_p use_p;</span>
<span class="lineNum">     253 </span><span class="lineCov">   34052608 :   def_operand_p def_p;</span>
<span class="lineNum">     254 </span><span class="lineCov">   34052608 :   ssa_op_iter iter;</span>
<span class="lineNum">     255 </span><span class="lineCov">   34052608 :   imm_use_iterator imm_iter;</span>
<span class="lineNum">     256 </span>            : 
<span class="lineNum">     257 </span><span class="lineCov">   34052608 :   *zero_uses_p = false;</span>
<span class="lineNum">     258 </span>            : 
<span class="lineNum">     259 </span>            :   /* We only can sink assignments and non-looping const/pure calls.  */
<span class="lineNum">     260 </span><span class="lineCov">   34052608 :   int cf;</span>
<span class="lineNum">     261 </span><span class="lineCov">   34052608 :   if (!is_gimple_assign (stmt)</span>
<span class="lineNum">     262 </span><span class="lineCov">   34052608 :       &amp;&amp; (!is_gimple_call (stmt)</span>
<span class="lineNum">     263 </span><span class="lineCov">    1657292 :           || !((cf = gimple_call_flags (stmt)) &amp; (ECF_CONST|ECF_PURE))</span>
<span class="lineNum">     264 </span><span class="lineCov">     224637 :           || (cf &amp; ECF_LOOPING_CONST_OR_PURE)))</span>
<span class="lineNum">     265 </span><span class="lineCov">   24986277 :     return false;</span>
<span class="lineNum">     266 </span>            : 
<span class="lineNum">     267 </span>            :   /* We only can sink stmts with a single definition.  */
<span class="lineNum">     268 </span><span class="lineCov">    9066331 :   def_p = single_ssa_def_operand (stmt, SSA_OP_ALL_DEFS);</span>
<span class="lineNum">     269 </span><span class="lineCov">    9066331 :   if (def_p == NULL_DEF_OPERAND_P)</span>
<span class="lineNum">     270 </span>            :     return false;
<span class="lineNum">     271 </span>            : 
<span class="lineNum">     272 </span>            :   /* There are a few classes of things we can't or don't move, some because we
<span class="lineNum">     273 </span>            :      don't have code to handle it, some because it's not profitable and some
<span class="lineNum">     274 </span>            :      because it's not legal.
<span class="lineNum">     275 </span>            : 
<span class="lineNum">     276 </span>            :      We can't sink things that may be global stores, at least not without
<span class="lineNum">     277 </span>            :      calculating a lot more information, because we may cause it to no longer
<span class="lineNum">     278 </span>            :      be seen by an external routine that needs it depending on where it gets
<span class="lineNum">     279 </span>            :      moved to.
<span class="lineNum">     280 </span>            : 
<span class="lineNum">     281 </span>            :      We can't sink statements that end basic blocks without splitting the
<span class="lineNum">     282 </span>            :      incoming edge for the sink location to place it there.
<span class="lineNum">     283 </span>            : 
<span class="lineNum">     284 </span>            :      We can't sink statements that have volatile operands.
<span class="lineNum">     285 </span>            : 
<span class="lineNum">     286 </span>            :      We don't want to sink dead code, so anything with 0 immediate uses is not
<span class="lineNum">     287 </span>            :      sunk.
<span class="lineNum">     288 </span>            : 
<span class="lineNum">     289 </span>            :      Don't sink BLKmode assignments if current function has any local explicit
<span class="lineNum">     290 </span>            :      register variables, as BLKmode assignments may involve memcpy or memset
<span class="lineNum">     291 </span>            :      calls or, on some targets, inline expansion thereof that sometimes need
<span class="lineNum">     292 </span>            :      to use specific hard registers.
<span class="lineNum">     293 </span>            : 
<span class="lineNum">     294 </span>            :   */
<span class="lineNum">     295 </span><span class="lineCov">    9066331 :   if (stmt_ends_bb_p (stmt)</span>
<span class="lineNum">     296 </span><span class="lineCov">    8963637 :       || gimple_has_side_effects (stmt)</span>
<span class="lineNum">     297 </span><span class="lineCov">    9066331 :       || (cfun-&gt;has_local_explicit_reg_vars</span>
<span class="lineNum">     298 </span><span class="lineCov">    8202735 :           &amp;&amp; TYPE_MODE (TREE_TYPE (gimple_get_lhs (stmt))) == BLKmode))</span>
<span class="lineNum">     299 </span><span class="lineCov">     863596 :     return false;</span>
<span class="lineNum">     300 </span>            : 
<span class="lineNum">     301 </span>            :   /* Return if there are no immediate uses of this stmt.  */
<span class="lineNum">     302 </span><span class="lineCov">   16405470 :   if (has_zero_uses (DEF_FROM_PTR (def_p)))</span>
<span class="lineNum">     303 </span>            :     {
<span class="lineNum">     304 </span><span class="lineCov">      68268 :       *zero_uses_p = true;</span>
<span class="lineNum">     305 </span><span class="lineCov">      68268 :       return false;</span>
<span class="lineNum">     306 </span>            :     }
<span class="lineNum">     307 </span>            : 
<span class="lineNum">     308 </span><span class="lineCov">   16268934 :   if (SSA_NAME_OCCURS_IN_ABNORMAL_PHI (DEF_FROM_PTR (def_p)))</span>
<span class="lineNum">     309 </span>            :     return false;
<span class="lineNum">     310 </span>            : 
<span class="lineNum">     311 </span><span class="lineCov">   19824630 :   FOR_EACH_SSA_USE_OPERAND (use_p, stmt, iter, SSA_OP_ALL_USES)</span>
<span class="lineNum">     312 </span>            :     {
<span class="lineNum">     313 </span><span class="lineCov">   11690961 :       tree use = USE_FROM_PTR (use_p);</span>
<span class="lineNum">     314 </span><span class="lineCov">   11690961 :       if (SSA_NAME_OCCURS_IN_ABNORMAL_PHI (use))</span>
<span class="lineNum">     315 </span>            :         return false;
<span class="lineNum">     316 </span>            :     }
<span class="lineNum">     317 </span>            : 
<span class="lineNum">     318 </span><span class="lineCov">    8133669 :   use = NULL;</span>
<span class="lineNum">     319 </span>            : 
<span class="lineNum">     320 </span>            :   /* If stmt is a store the one and only use needs to be the VOP
<span class="lineNum">     321 </span>            :      merging PHI node.  */
<span class="lineNum">     322 </span><span class="lineCov">   24401007 :   if (virtual_operand_p (DEF_FROM_PTR (def_p)))</span>
<span class="lineNum">     323 </span>            :     {
<span class="lineNum">     324 </span><span class="lineCov">    5330571 :       FOR_EACH_IMM_USE_FAST (use_p, imm_iter, DEF_FROM_PTR (def_p))</span>
<span class="lineNum">     325 </span>            :         {
<span class="lineNum">     326 </span><span class="lineCov">    2765414 :           gimple *use_stmt = USE_STMT (use_p);</span>
<span class="lineNum">     327 </span>            : 
<span class="lineNum">     328 </span>            :           /* A killing definition is not a use.  */
<span class="lineNum">     329 </span><span class="lineCov">    2765414 :           if ((gimple_has_lhs (use_stmt)</span>
<span class="lineNum">     330 </span><span class="lineCov">    2154905 :                &amp;&amp; operand_equal_p (gimple_get_lhs (stmt),</span>
<span class="lineNum">     331 </span><span class="lineCov">    2154905 :                                    gimple_get_lhs (use_stmt), 0))</span>
<span class="lineNum">     332 </span><span class="lineCov">    3000080 :               || stmt_kills_ref_p (use_stmt, gimple_get_lhs (stmt)))</span>
<span class="lineNum">     333 </span>            :             {
<span class="lineNum">     334 </span>            :               /* If use_stmt is or might be a nop assignment then USE_STMT
<span class="lineNum">     335 </span>            :                  acts as a use as well as definition.  */
<span class="lineNum">     336 </span><span class="lineCov">       9310 :               if (stmt != use_stmt</span>
<span class="lineNum">     337 </span><span class="lineCov">       9310 :                   &amp;&amp; ref_maybe_used_by_stmt_p (use_stmt,</span>
<span class="lineNum">     338 </span>            :                                                gimple_get_lhs (stmt)))
<span class="lineNum">     339 </span>            :                 return false;
<span class="lineNum">     340 </span><span class="lineCov">       9098 :               continue;</span>
<span class="lineNum">     341 </span>            :             }
<span class="lineNum">     342 </span>            : 
<span class="lineNum">     343 </span><span class="lineCov">    5512208 :           if (gimple_code (use_stmt) != GIMPLE_PHI)</span>
<span class="lineNum">     344 </span>            :             return false;
<span class="lineNum">     345 </span>            : 
<span class="lineNum">     346 </span><span class="lineCov">     691802 :           if (use</span>
<span class="lineNum">     347 </span><span class="lineCov">     345901 :               &amp;&amp; use != use_stmt)</span>
<span class="lineNum">     348 </span>            :             return false;
<span class="lineNum">     349 </span>            : 
<span class="lineNum">     350 </span>            :           use = use_stmt;
<span class="lineNum">     351 </span>            :         }
<span class="lineNum">     352 </span><span class="lineCov">      26965 :       if (!use)</span>
<span class="lineNum">     353 </span>            :         return false;
<span class="lineNum">     354 </span>            :     }
<span class="lineNum">     355 </span>            :   /* If all the immediate uses are not in the same place, find the nearest
<span class="lineNum">     356 </span>            :      common dominator of all the immediate uses.  For PHI nodes, we have to
<span class="lineNum">     357 </span>            :      find the nearest common dominator of all of the predecessor blocks, since
<span class="lineNum">     358 </span>            :      that is where insertion would have to take place.  */
<span class="lineNum">     359 </span><span class="lineCov">    5595477 :   else if (gimple_vuse (stmt)</span>
<span class="lineNum">     360 </span><span class="lineCov">    5595477 :            || !all_immediate_uses_same_place (def_p))</span>
<span class="lineNum">     361 </span>            :     {
<span class="lineNum">     362 </span><span class="lineCov">    3053594 :       bool debug_stmts = false;</span>
<span class="lineNum">     363 </span><span class="lineCov">    3053594 :       basic_block commondom = nearest_common_dominator_of_uses (def_p,</span>
<span class="lineNum">     364 </span>            :                                                                 &amp;debug_stmts);
<span class="lineNum">     365 </span>            : 
<span class="lineNum">     366 </span><span class="lineCov">    3053594 :       if (commondom == frombb)</span>
<span class="lineNum">     367 </span>            :         return false;
<span class="lineNum">     368 </span>            : 
<span class="lineNum">     369 </span>            :       /* If this is a load then do not sink past any stores.
<span class="lineNum">     370 </span>            :          ???  This is overly simple but cheap.  We basically look
<span class="lineNum">     371 </span>            :          for an existing load with the same VUSE in the path to one
<span class="lineNum">     372 </span>            :          of the sink candidate blocks and we adjust commondom to the
<span class="lineNum">     373 </span>            :          nearest to commondom.  */
<span class="lineNum">     374 </span><span class="lineCov">     608674 :       if (gimple_vuse (stmt))</span>
<span class="lineNum">     375 </span>            :         {
<span class="lineNum">     376 </span>            :           /* Do not sink loads from hard registers.  */
<span class="lineNum">     377 </span><span class="lineCov">     249795 :           if (gimple_assign_single_p (stmt)</span>
<span class="lineNum">     378 </span><span class="lineCov">     497386 :               &amp;&amp; TREE_CODE (gimple_assign_rhs1 (stmt)) == VAR_DECL</span>
<span class="lineNum">     379 </span><span class="lineCov">      19968 :               &amp;&amp; DECL_HARD_REGISTER (gimple_assign_rhs1 (stmt)))</span>
<span class="lineNum">     380 </span><span class="lineCov">     110059 :             return false;</span>
<span class="lineNum">     381 </span>            : 
<span class="lineNum">     382 </span><span class="lineCov">     249793 :           imm_use_iterator imm_iter;</span>
<span class="lineNum">     383 </span><span class="lineCov">     249793 :           use_operand_p use_p;</span>
<span class="lineNum">     384 </span><span class="lineCov">     249793 :           basic_block found = NULL;</span>
<span class="lineNum">     385 </span><span class="lineCov">    1716891 :           FOR_EACH_IMM_USE_FAST (use_p, imm_iter, gimple_vuse (stmt))</span>
<span class="lineNum">     386 </span>            :             {
<span class="lineNum">     387 </span><span class="lineCov">    1325104 :               gimple *use_stmt = USE_STMT (use_p);</span>
<span class="lineNum">     388 </span><span class="lineCov">    1325104 :               basic_block bb = gimple_bb (use_stmt);</span>
<span class="lineNum">     389 </span>            :               /* For PHI nodes the block we know sth about
<span class="lineNum">     390 </span>            :                  is the incoming block with the use.  */
<span class="lineNum">     391 </span><span class="lineCov">    2650208 :               if (gimple_code (use_stmt) == GIMPLE_PHI)</span>
<span class="lineNum">     392 </span><span class="lineCov">     186848 :                 bb = EDGE_PRED (bb, PHI_ARG_INDEX_FROM_USE (use_p))-&gt;src;</span>
<span class="lineNum">     393 </span>            :               /* Any dominator of commondom would be ok with
<span class="lineNum">     394 </span>            :                  adjusting commondom to that block.  */
<span class="lineNum">     395 </span><span class="lineCov">    1325104 :               bb = nearest_common_dominator (CDI_DOMINATORS, bb, commondom);</span>
<span class="lineNum">     396 </span><span class="lineCov">    1325104 :               if (!found)</span>
<span class="lineNum">     397 </span>            :                 found = bb;
<span class="lineNum">     398 </span><span class="lineCov">    1075311 :               else if (dominated_by_p (CDI_DOMINATORS, bb, found))</span>
<span class="lineNum">     399 </span><span class="lineCov">     820167 :                 found = bb;</span>
<span class="lineNum">     400 </span>            :               /* If we can't improve, stop.  */
<span class="lineNum">     401 </span><span class="lineCov">    1325104 :               if (found == commondom)</span>
<span class="lineNum">     402 </span>            :                 break;
<span class="lineNum">     403 </span>            :             }
<span class="lineNum">     404 </span><span class="lineCov">     249793 :           commondom = found;</span>
<span class="lineNum">     405 </span><span class="lineCov">     249793 :           if (commondom == frombb)</span>
<span class="lineNum">     406 </span>            :             return false;
<span class="lineNum">     407 </span>            :         }
<span class="lineNum">     408 </span>            : 
<span class="lineNum">     409 </span>            :       /* Our common dominator has to be dominated by frombb in order to be a
<span class="lineNum">     410 </span>            :          trivially safe place to put this statement, since it has multiple
<span class="lineNum">     411 </span>            :          uses.  */
<span class="lineNum">     412 </span><span class="lineCov">     194278 :       if (!dominated_by_p (CDI_DOMINATORS, commondom, frombb))</span>
<span class="lineNum">     413 </span>            :         return false;
<span class="lineNum">     414 </span>            : 
<span class="lineNum">     415 </span><span class="lineCov">     194278 :       commondom = select_best_block (frombb, commondom, stmt);</span>
<span class="lineNum">     416 </span>            : 
<span class="lineNum">     417 </span><span class="lineCov">     194278 :       if (commondom == frombb)</span>
<span class="lineNum">     418 </span>            :         return false;   
<span class="lineNum">     419 </span>            : 
<span class="lineNum">     420 </span><span class="lineCov">      63190 :       *togsi = gsi_after_labels (commondom);</span>
<span class="lineNum">     421 </span>            : 
<span class="lineNum">     422 </span><span class="lineCov">      63190 :       return true;</span>
<span class="lineNum">     423 </span>            :     }
<span class="lineNum">     424 </span>            :   else
<span class="lineNum">     425 </span>            :     {
<span class="lineNum">     426 </span><span class="lineCov">    5340280 :       FOR_EACH_IMM_USE_FAST (one_use, imm_iter, DEF_FROM_PTR (def_p))</span>
<span class="lineNum">     427 </span>            :         {
<span class="lineNum">     428 </span><span class="lineCov">    5340280 :           if (is_gimple_debug (USE_STMT (one_use)))</span>
<span class="lineNum">     429 </span><span class="lineCov">     128257 :             continue;</span>
<span class="lineNum">     430 </span>            :           break;
<span class="lineNum">     431 </span>            :         }
<span class="lineNum">     432 </span><span class="lineCov">    2541883 :       use = USE_STMT (one_use);</span>
<span class="lineNum">     433 </span>            : 
<span class="lineNum">     434 </span><span class="lineCov">    5083766 :       if (gimple_code (use) != GIMPLE_PHI)</span>
<span class="lineNum">     435 </span>            :         {
<span class="lineNum">     436 </span><span class="lineCov">    2459018 :           sinkbb = gimple_bb (use);</span>
<span class="lineNum">     437 </span><span class="lineCov">    4918036 :           sinkbb = select_best_block (frombb, gimple_bb (use), stmt);</span>
<span class="lineNum">     438 </span>            : 
<span class="lineNum">     439 </span><span class="lineCov">    2459018 :           if (sinkbb == frombb)</span>
<span class="lineNum">     440 </span>            :             return false;
<span class="lineNum">     441 </span>            : 
<span class="lineNum">     442 </span><span class="lineCov">      77410 :           *togsi = gsi_for_stmt (use);</span>
<span class="lineNum">     443 </span>            : 
<span class="lineNum">     444 </span><span class="lineCov">      77410 :           return true;</span>
<span class="lineNum">     445 </span>            :         }
<span class="lineNum">     446 </span>            :     }
<span class="lineNum">     447 </span>            : 
<span class="lineNum">     448 </span><span class="lineCov">     218522 :   sinkbb = find_bb_for_arg (as_a &lt;gphi *&gt; (use), DEF_FROM_PTR (def_p));</span>
<span class="lineNum">     449 </span>            : 
<span class="lineNum">     450 </span>            :   /* This can happen if there are multiple uses in a PHI.  */
<span class="lineNum">     451 </span><span class="lineCov">     109261 :   if (!sinkbb)</span>
<span class="lineNum">     452 </span>            :     return false;
<span class="lineNum">     453 </span>            :   
<span class="lineNum">     454 </span><span class="lineCov">     105232 :   sinkbb = select_best_block (frombb, sinkbb, stmt);</span>
<span class="lineNum">     455 </span><span class="lineCov">     105232 :   if (!sinkbb || sinkbb == frombb)</span>
<span class="lineNum">     456 </span>            :     return false;
<span class="lineNum">     457 </span>            : 
<span class="lineNum">     458 </span>            :   /* If the latch block is empty, don't make it non-empty by sinking
<span class="lineNum">     459 </span>            :      something into it.  */
<span class="lineNum">     460 </span><span class="lineCov">      23482 :   if (sinkbb == frombb-&gt;loop_father-&gt;latch</span>
<span class="lineNum">     461 </span><span class="lineCov">      23482 :       &amp;&amp; empty_block_p (sinkbb))</span>
<span class="lineNum">     462 </span>            :     return false;
<span class="lineNum">     463 </span>            : 
<span class="lineNum">     464 </span><span class="lineCov">      18700 :   *togsi = gsi_after_labels (sinkbb);</span>
<span class="lineNum">     465 </span>            : 
<span class="lineNum">     466 </span><span class="lineCov">      18700 :   return true;</span>
<span class="lineNum">     467 </span>            : }
<span class="lineNum">     468 </span>            : 
<span class="lineNum">     469 </span>            : /* Perform code sinking on BB */
<span class="lineNum">     470 </span>            : 
<span class="lineNum">     471 </span>            : static void
<span class="lineNum">     472 </span><span class="lineCov">    8662966 : sink_code_in_bb (basic_block bb)</span>
<span class="lineNum">     473 </span>            : {
<span class="lineNum">     474 </span><span class="lineCov">    8662966 :   basic_block son;</span>
<span class="lineNum">     475 </span><span class="lineCov">    8662966 :   gimple_stmt_iterator gsi;</span>
<span class="lineNum">     476 </span><span class="lineCov">    8662966 :   edge_iterator ei;</span>
<span class="lineNum">     477 </span><span class="lineCov">    8662966 :   edge e;</span>
<span class="lineNum">     478 </span><span class="lineCov">    8662966 :   bool last = true;</span>
<span class="lineNum">     479 </span>            : 
<span class="lineNum">     480 </span>            :   /* If this block doesn't dominate anything, there can't be any place to sink
<span class="lineNum">     481 </span>            :      the statements to.  */
<span class="lineNum">     482 </span><span class="lineCov">    8662966 :   if (first_dom_son (CDI_DOMINATORS, bb) == NULL)</span>
<span class="lineNum">     483 </span>            :     goto earlyout;
<span class="lineNum">     484 </span>            : 
<span class="lineNum">     485 </span>            :   /* We can't move things across abnormal edges, so don't try.  */
<span class="lineNum">     486 </span><span class="lineCov">   13090025 :   FOR_EACH_EDGE (e, ei, bb-&gt;succs)</span>
<span class="lineNum">     487 </span><span class="lineCov">    6294904 :     if (e-&gt;flags &amp; EDGE_ABNORMAL)</span>
<span class="lineNum">     488 </span>            :       goto earlyout;
<span class="lineNum">     489 </span>            : 
<span class="lineNum">     490 </span><span class="lineCov">   74896550 :   for (gsi = gsi_last_bb (bb); !gsi_end_p (gsi);)</span>
<span class="lineNum">     491 </span>            :     {
<span class="lineNum">     492 </span><span class="lineCov">   34052608 :       gimple *stmt = gsi_stmt (gsi);</span>
<span class="lineNum">     493 </span><span class="lineCov">   34052608 :       gimple_stmt_iterator togsi;</span>
<span class="lineNum">     494 </span><span class="lineCov">   34052608 :       bool zero_uses_p;</span>
<span class="lineNum">     495 </span>            : 
<span class="lineNum">     496 </span><span class="lineCov">   34052608 :       if (!statement_sink_location (stmt, bb, &amp;togsi, &amp;zero_uses_p))</span>
<span class="lineNum">     497 </span>            :         {
<span class="lineNum">     498 </span><span class="lineCov">   33893308 :           gimple_stmt_iterator saved = gsi;</span>
<span class="lineNum">     499 </span><span class="lineCov">   67786616 :           if (!gsi_end_p (gsi))</span>
<span class="lineNum">     500 </span><span class="lineCov">   33893308 :             gsi_prev (&amp;gsi);</span>
<span class="lineNum">     501 </span>            :           /* If we face a dead stmt remove it as it possibly blocks
<span class="lineNum">     502 </span>            :              sinking of uses.  */
<span class="lineNum">     503 </span><span class="lineCov">   33893308 :           if (zero_uses_p</span>
<span class="lineNum">     504 </span><span class="lineCov">   33961576 :               &amp;&amp; ! gimple_vdef (stmt))</span>
<span class="lineNum">     505 </span>            :             {
<span class="lineNum">     506 </span><span class="lineCov">      67436 :               gsi_remove (&amp;saved, true);</span>
<span class="lineNum">     507 </span><span class="lineCov">      67436 :               release_defs (stmt);</span>
<span class="lineNum">     508 </span>            :             }
<span class="lineNum">     509 </span>            :           else
<span class="lineNum">     510 </span>            :             last = false;
<span class="lineNum">     511 </span><span class="lineCov">   33893308 :           continue;</span>
<span class="lineNum">     512 </span>            :         }
<span class="lineNum">     513 </span><span class="lineCov">     159300 :       if (dump_file)</span>
<span class="lineNum">     514 </span>            :         {
<span class="lineNum">     515 </span><span class="lineCov">         14 :           fprintf (dump_file, &quot;Sinking &quot;);</span>
<span class="lineNum">     516 </span><span class="lineCov">         14 :           print_gimple_stmt (dump_file, stmt, 0, TDF_VOPS);</span>
<span class="lineNum">     517 </span><span class="lineCov">         14 :           fprintf (dump_file, &quot; from bb %d to bb %d\n&quot;,</span>
<span class="lineNum">     518 </span><span class="lineCov">         14 :                    bb-&gt;index, (gsi_bb (togsi))-&gt;index);</span>
<span class="lineNum">     519 </span>            :         }
<span class="lineNum">     520 </span>            : 
<span class="lineNum">     521 </span>            :       /* Update virtual operands of statements in the path we
<span class="lineNum">     522 </span>            :          do not sink to.  */
<span class="lineNum">     523 </span><span class="lineCov">     318600 :       if (gimple_vdef (stmt))</span>
<span class="lineNum">     524 </span>            :         {
<span class="lineNum">     525 </span><span class="lineCov">       6457 :           imm_use_iterator iter;</span>
<span class="lineNum">     526 </span><span class="lineCov">       6457 :           use_operand_p use_p;</span>
<span class="lineNum">     527 </span><span class="lineCov">       6457 :           gimple *vuse_stmt;</span>
<span class="lineNum">     528 </span>            : 
<span class="lineNum">     529 </span><span class="lineCov">      23849 :           FOR_EACH_IMM_USE_STMT (vuse_stmt, iter, gimple_vdef (stmt))</span>
<span class="lineNum">     530 </span><span class="lineCov">      21870 :             if (gimple_code (vuse_stmt) != GIMPLE_PHI)</span>
<span class="lineNum">     531 </span><span class="lineCov">      26868 :               FOR_EACH_IMM_USE_ON_STMT (use_p, iter)</span>
<span class="lineNum">     532 </span><span class="lineCov">       8956 :                 SET_USE (use_p, gimple_vuse (stmt));</span>
<span class="lineNum">     533 </span>            :         }
<span class="lineNum">     534 </span>            : 
<span class="lineNum">     535 </span>            :       /* If this is the end of the basic block, we need to insert at the end
<span class="lineNum">     536 </span>            :          of the basic block.  */
<span class="lineNum">     537 </span><span class="lineCov">     318600 :       if (gsi_end_p (togsi))</span>
<span class="lineNum">     538 </span><span class="lineCov">      40534 :         gsi_move_to_bb_end (&amp;gsi, gsi_bb (togsi));</span>
<span class="lineNum">     539 </span>            :       else
<span class="lineNum">     540 </span><span class="lineCov">     139033 :         gsi_move_before (&amp;gsi, &amp;togsi);</span>
<span class="lineNum">     541 </span>            : 
<span class="lineNum">     542 </span><span class="lineCov">     159300 :       sink_stats.sunk++;</span>
<span class="lineNum">     543 </span>            : 
<span class="lineNum">     544 </span>            :       /* If we've just removed the last statement of the BB, the
<span class="lineNum">     545 </span>            :          gsi_end_p() test below would fail, but gsi_prev() would have
<span class="lineNum">     546 </span>            :          succeeded, and we want it to succeed.  So we keep track of
<span class="lineNum">     547 </span>            :          whether we're at the last statement and pick up the new last
<span class="lineNum">     548 </span>            :          statement.  */
<span class="lineNum">     549 </span><span class="lineCov">     159300 :       if (last)</span>
<span class="lineNum">     550 </span>            :         {
<span class="lineNum">     551 </span><span class="lineCov">        135 :           gsi = gsi_last_bb (bb);</span>
<span class="lineNum">     552 </span><span class="lineCov">        135 :           continue;</span>
<span class="lineNum">     553 </span>            :         }
<span class="lineNum">     554 </span>            : 
<span class="lineNum">     555 </span><span class="lineCov">     159165 :       last = false;</span>
<span class="lineNum">     556 </span><span class="lineCov">     318330 :       if (!gsi_end_p (gsi))</span>
<span class="lineNum">     557 </span><span class="lineCov">     159165 :         gsi_prev (&amp;gsi);</span>
<span class="lineNum">     558 </span>            : 
<span class="lineNum">     559 </span>            :     }
<span class="lineNum">     560 </span><span class="lineCov">    3395667 :  earlyout:</span>
<span class="lineNum">     561 </span><span class="lineCov">   16704999 :   for (son = first_dom_son (CDI_POST_DOMINATORS, bb);</span>
<span class="lineNum">     562 </span><span class="lineCov">   16704999 :        son;</span>
<span class="lineNum">     563 </span><span class="lineCov">    8042033 :        son = next_dom_son (CDI_POST_DOMINATORS, son))</span>
<span class="lineNum">     564 </span>            :     {
<span class="lineNum">     565 </span><span class="lineCov">    8042033 :       sink_code_in_bb (son);</span>
<span class="lineNum">     566 </span>            :     }
<span class="lineNum">     567 </span><span class="lineCov">    8662966 : }</span>
<span class="lineNum">     568 </span>            : 
<span class="lineNum">     569 </span>            : /* Perform code sinking.
<span class="lineNum">     570 </span>            :    This moves code down the flowgraph when we know it would be
<span class="lineNum">     571 </span>            :    profitable to do so, or it wouldn't increase the number of
<span class="lineNum">     572 </span>            :    executions of the statement.
<span class="lineNum">     573 </span>            : 
<span class="lineNum">     574 </span>            :    IE given
<span class="lineNum">     575 </span>            : 
<span class="lineNum">     576 </span>            :    a_1 = b + c;
<span class="lineNum">     577 </span>            :    if (&lt;something&gt;)
<span class="lineNum">     578 </span>            :    {
<span class="lineNum">     579 </span>            :    }
<span class="lineNum">     580 </span>            :    else
<span class="lineNum">     581 </span>            :    {
<span class="lineNum">     582 </span>            :      foo (&amp;b, &amp;c);
<span class="lineNum">     583 </span>            :      a_5 = b + c;
<span class="lineNum">     584 </span>            :    }
<span class="lineNum">     585 </span>            :    a_6 = PHI (a_5, a_1);
<span class="lineNum">     586 </span>            :    USE a_6.
<span class="lineNum">     587 </span>            : 
<span class="lineNum">     588 </span>            :    we'll transform this into:
<span class="lineNum">     589 </span>            : 
<span class="lineNum">     590 </span>            :    if (&lt;something&gt;)
<span class="lineNum">     591 </span>            :    {
<span class="lineNum">     592 </span>            :       a_1 = b + c;
<span class="lineNum">     593 </span>            :    }
<span class="lineNum">     594 </span>            :    else
<span class="lineNum">     595 </span>            :    {
<span class="lineNum">     596 </span>            :       foo (&amp;b, &amp;c);
<span class="lineNum">     597 </span>            :       a_5 = b + c;
<span class="lineNum">     598 </span>            :    }
<span class="lineNum">     599 </span>            :    a_6 = PHI (a_5, a_1);
<span class="lineNum">     600 </span>            :    USE a_6.
<span class="lineNum">     601 </span>            : 
<span class="lineNum">     602 </span>            :    Note that this reduces the number of computations of a = b + c to 1
<span class="lineNum">     603 </span>            :    when we take the else edge, instead of 2.
<span class="lineNum">     604 </span>            : */
<span class="lineNum">     605 </span>            : namespace {
<span class="lineNum">     606 </span>            : 
<span class="lineNum">     607 </span>            : const pass_data pass_data_sink_code =
<span class="lineNum">     608 </span>            : {
<span class="lineNum">     609 </span>            :   GIMPLE_PASS, /* type */
<span class="lineNum">     610 </span>            :   &quot;sink&quot;, /* name */
<span class="lineNum">     611 </span>            :   OPTGROUP_NONE, /* optinfo_flags */
<span class="lineNum">     612 </span>            :   TV_TREE_SINK, /* tv_id */
<span class="lineNum">     613 </span>            :   /* PROP_no_crit_edges is ensured by running split_critical_edges in
<span class="lineNum">     614 </span>            :      pass_data_sink_code::execute ().  */
<span class="lineNum">     615 </span>            :   ( PROP_cfg | PROP_ssa ), /* properties_required */
<span class="lineNum">     616 </span>            :   0, /* properties_provided */
<span class="lineNum">     617 </span>            :   0, /* properties_destroyed */
<span class="lineNum">     618 </span>            :   0, /* todo_flags_start */
<span class="lineNum">     619 </span>            :   TODO_update_ssa, /* todo_flags_finish */
<span class="lineNum">     620 </span>            : };
<span class="lineNum">     621 </span>            : 
<span class="lineNum">     622 </span>            : class pass_sink_code : public gimple_opt_pass
<span class="lineNum">     623 </span>            : {
<span class="lineNum">     624 </span>            : public:
<span class="lineNum">     625 </span>            :   pass_sink_code (gcc::context *ctxt)
<span class="lineNum">     626 </span><span class="lineCov">     340624 :     : gimple_opt_pass (pass_data_sink_code, ctxt)</span>
<span class="lineNum">     627 </span>            :   {}
<a name="628"><span class="lineNum">     628 </span>            : </a>
<span class="lineNum">     629 </span>            :   /* opt_pass methods: */
<span class="lineNum">     630 </span><span class="lineCov">     620946 :   virtual bool gate (function *) { return flag_tree_sink != 0; }</span>
<span class="lineNum">     631 </span>            :   virtual unsigned int execute (function *);
<span class="lineNum">     632 </span>            : 
<span class="lineNum">     633 </span>            : }; // class pass_sink_code
<a name="634"><span class="lineNum">     634 </span>            : </a>
<span class="lineNum">     635 </span>            : unsigned int
<span class="lineNum">     636 </span><span class="lineCov">     620933 : pass_sink_code::execute (function *fun)</span>
<span class="lineNum">     637 </span>            : {
<span class="lineNum">     638 </span><span class="lineCov">     620933 :   loop_optimizer_init (LOOPS_NORMAL);</span>
<span class="lineNum">     639 </span><span class="lineCov">     620933 :   split_critical_edges ();</span>
<span class="lineNum">     640 </span><span class="lineCov">     620933 :   connect_infinite_loops_to_exit ();</span>
<span class="lineNum">     641 </span><span class="lineCov">     620933 :   memset (&amp;sink_stats, 0, sizeof (sink_stats));</span>
<span class="lineNum">     642 </span><span class="lineCov">     620933 :   calculate_dominance_info (CDI_DOMINATORS);</span>
<span class="lineNum">     643 </span><span class="lineCov">     620933 :   calculate_dominance_info (CDI_POST_DOMINATORS);</span>
<span class="lineNum">     644 </span><span class="lineCov">     620933 :   sink_code_in_bb (EXIT_BLOCK_PTR_FOR_FN (fun));</span>
<span class="lineNum">     645 </span><span class="lineCov">     620933 :   statistics_counter_event (fun, &quot;Sunk statements&quot;, sink_stats.sunk);</span>
<span class="lineNum">     646 </span><span class="lineCov">     620933 :   free_dominance_info (CDI_POST_DOMINATORS);</span>
<span class="lineNum">     647 </span><span class="lineCov">     620933 :   remove_fake_exit_edges ();</span>
<span class="lineNum">     648 </span><span class="lineCov">     620933 :   loop_optimizer_finalize ();</span>
<span class="lineNum">     649 </span>            : 
<span class="lineNum">     650 </span><span class="lineCov">     620933 :   return 0;</span>
<span class="lineNum">     651 </span>            : }
<span class="lineNum">     652 </span>            : 
<span class="lineNum">     653 </span>            : } // anon namespace
<a name="654"><span class="lineNum">     654 </span>            : </a>
<span class="lineNum">     655 </span>            : gimple_opt_pass *
<span class="lineNum">     656 </span><span class="lineCov">     170312 : make_pass_sink_code (gcc::context *ctxt)</span>
<span class="lineNum">     657 </span>            : {
<span class="lineNum">     658 </span><span class="lineCov">     170312 :   return new pass_sink_code (ctxt);</span>
<span class="lineNum">     659 </span>            : }
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.0</a></td></tr>
  </table>
  <br>
<h3>LCOV profile is generated on x86_64 machine using following configure options: configure --disable-bootstrap --enable-coverage=opt --enable-languages=c,c++,fortran,go,jit,lto --enable-host-shared. GCC test suite is run with the built compiler.</h3></body></html>
