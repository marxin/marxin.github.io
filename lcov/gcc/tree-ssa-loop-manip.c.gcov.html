<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - gcc.info - gcc/tree-ssa-loop-manip.c</title>
  <link rel="stylesheet" type="text/css" href="../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../index.html">top level</a> - <a href="index.html">gcc</a> - tree-ssa-loop-manip.c<span style="font-size: 80%;"> (source / <a href="tree-ssa-loop-manip.c.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">gcc.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">670</td>
            <td class="headerCovTableEntry">687</td>
            <td class="headerCovTableEntryHi">97.5 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2018-09-22 10:58:49</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">34</td>
            <td class="headerCovTableEntry">34</td>
            <td class="headerCovTableEntryHi">100.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /* High-level loop manipulation functions.</a>
<span class="lineNum">       2 </span>            :    Copyright (C) 2004-2018 Free Software Foundation, Inc.
<span class="lineNum">       3 </span>            : 
<span class="lineNum">       4 </span>            : This file is part of GCC.
<span class="lineNum">       5 </span>            : 
<span class="lineNum">       6 </span>            : GCC is free software; you can redistribute it and/or modify it
<span class="lineNum">       7 </span>            : under the terms of the GNU General Public License as published by the
<span class="lineNum">       8 </span>            : Free Software Foundation; either version 3, or (at your option) any
<span class="lineNum">       9 </span>            : later version.
<span class="lineNum">      10 </span>            : 
<span class="lineNum">      11 </span>            : GCC is distributed in the hope that it will be useful, but WITHOUT
<span class="lineNum">      12 </span>            : ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
<span class="lineNum">      13 </span>            : FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
<span class="lineNum">      14 </span>            : for more details.
<span class="lineNum">      15 </span>            : 
<span class="lineNum">      16 </span>            : You should have received a copy of the GNU General Public License
<span class="lineNum">      17 </span>            : along with GCC; see the file COPYING3.  If not see
<span class="lineNum">      18 </span>            : &lt;http://www.gnu.org/licenses/&gt;.  */
<span class="lineNum">      19 </span>            : 
<span class="lineNum">      20 </span>            : #include &quot;config.h&quot;
<span class="lineNum">      21 </span>            : #include &quot;system.h&quot;
<span class="lineNum">      22 </span>            : #include &quot;coretypes.h&quot;
<span class="lineNum">      23 </span>            : #include &quot;backend.h&quot;
<span class="lineNum">      24 </span>            : #include &quot;tree.h&quot;
<span class="lineNum">      25 </span>            : #include &quot;gimple.h&quot;
<span class="lineNum">      26 </span>            : #include &quot;cfghooks.h&quot;
<span class="lineNum">      27 </span>            : #include &quot;tree-pass.h&quot;        /* ??? for TODO_update_ssa but this isn't a pass.  */
<span class="lineNum">      28 </span>            : #include &quot;ssa.h&quot;
<span class="lineNum">      29 </span>            : #include &quot;gimple-pretty-print.h&quot;
<span class="lineNum">      30 </span>            : #include &quot;fold-const.h&quot;
<span class="lineNum">      31 </span>            : #include &quot;cfganal.h&quot;
<span class="lineNum">      32 </span>            : #include &quot;gimplify.h&quot;
<span class="lineNum">      33 </span>            : #include &quot;gimple-iterator.h&quot;
<span class="lineNum">      34 </span>            : #include &quot;gimplify-me.h&quot;
<span class="lineNum">      35 </span>            : #include &quot;tree-cfg.h&quot;
<span class="lineNum">      36 </span>            : #include &quot;tree-ssa-loop-ivopts.h&quot;
<span class="lineNum">      37 </span>            : #include &quot;tree-ssa-loop-manip.h&quot;
<span class="lineNum">      38 </span>            : #include &quot;tree-ssa-loop-niter.h&quot;
<span class="lineNum">      39 </span>            : #include &quot;tree-ssa-loop.h&quot;
<span class="lineNum">      40 </span>            : #include &quot;tree-into-ssa.h&quot;
<span class="lineNum">      41 </span>            : #include &quot;tree-ssa.h&quot;
<span class="lineNum">      42 </span>            : #include &quot;cfgloop.h&quot;
<span class="lineNum">      43 </span>            : #include &quot;tree-scalar-evolution.h&quot;
<span class="lineNum">      44 </span>            : #include &quot;params.h&quot;
<span class="lineNum">      45 </span>            : #include &quot;tree-inline.h&quot;
<span class="lineNum">      46 </span>            : 
<span class="lineNum">      47 </span>            : /* All bitmaps for rewriting into loop-closed SSA go on this obstack,
<span class="lineNum">      48 </span>            :    so that we can free them all at once.  */
<span class="lineNum">      49 </span>            : static bitmap_obstack loop_renamer_obstack;
<span class="lineNum">      50 </span>            : 
<span class="lineNum">      51 </span>            : /* Creates an induction variable with value BASE + STEP * iteration in LOOP.
<span class="lineNum">      52 </span>            :    It is expected that neither BASE nor STEP are shared with other expressions
<span class="lineNum">      53 </span>            :    (unless the sharing rules allow this).  Use VAR as a base var_decl for it
<span class="lineNum">      54 </span>            :    (if NULL, a new temporary will be created).  The increment will occur at
<span class="lineNum">      55 </span>            :    INCR_POS (after it if AFTER is true, before it otherwise).  INCR_POS and
<span class="lineNum">      56 </span>            :    AFTER can be computed using standard_iv_increment_position.  The ssa versions
<span class="lineNum">      57 </span>            :    of the variable before and after increment will be stored in VAR_BEFORE and
<span class="lineNum">      58 </span>            :    VAR_AFTER (unless they are NULL).  */
<a name="59"><span class="lineNum">      59 </span>            : </a>
<span class="lineNum">      60 </span>            : void
<span class="lineNum">      61 </span><span class="lineCov">     373328 : create_iv (tree base, tree step, tree var, struct loop *loop,</span>
<span class="lineNum">      62 </span>            :            gimple_stmt_iterator *incr_pos, bool after,
<span class="lineNum">      63 </span>            :            tree *var_before, tree *var_after)
<span class="lineNum">      64 </span>            : {
<span class="lineNum">      65 </span><span class="lineCov">     373328 :   gassign *stmt;</span>
<span class="lineNum">      66 </span><span class="lineCov">     373328 :   gphi *phi;</span>
<span class="lineNum">      67 </span><span class="lineCov">     373328 :   tree initial, step1;</span>
<span class="lineNum">      68 </span><span class="lineCov">     373328 :   gimple_seq stmts;</span>
<span class="lineNum">      69 </span><span class="lineCov">     373328 :   tree vb, va;</span>
<span class="lineNum">      70 </span><span class="lineCov">     373328 :   enum tree_code incr_op = PLUS_EXPR;</span>
<span class="lineNum">      71 </span><span class="lineCov">     373328 :   edge pe = loop_preheader_edge (loop);</span>
<span class="lineNum">      72 </span>            : 
<span class="lineNum">      73 </span><span class="lineCov">     373328 :   if (var != NULL_TREE)</span>
<span class="lineNum">      74 </span>            :     {
<span class="lineNum">      75 </span><span class="lineCov">     241799 :       vb = make_ssa_name (var);</span>
<span class="lineNum">      76 </span><span class="lineCov">     483598 :       va = make_ssa_name (var);</span>
<span class="lineNum">      77 </span>            :     }
<span class="lineNum">      78 </span>            :   else
<span class="lineNum">      79 </span>            :     {
<span class="lineNum">      80 </span><span class="lineCov">     131529 :       vb = make_temp_ssa_name (TREE_TYPE (base), NULL, &quot;ivtmp&quot;);</span>
<span class="lineNum">      81 </span><span class="lineCov">     131529 :       va = make_temp_ssa_name (TREE_TYPE (base), NULL, &quot;ivtmp&quot;);</span>
<span class="lineNum">      82 </span>            :     }
<span class="lineNum">      83 </span><span class="lineCov">     373328 :   if (var_before)</span>
<span class="lineNum">      84 </span><span class="lineCov">     261363 :     *var_before = vb;</span>
<span class="lineNum">      85 </span><span class="lineCov">     373328 :   if (var_after)</span>
<span class="lineNum">      86 </span><span class="lineCov">     370390 :     *var_after = va;</span>
<span class="lineNum">      87 </span>            : 
<span class="lineNum">      88 </span>            :   /* For easier readability of the created code, produce MINUS_EXPRs
<span class="lineNum">      89 </span>            :      when suitable.  */
<span class="lineNum">      90 </span><span class="lineCov">     373328 :   if (TREE_CODE (step) == INTEGER_CST)</span>
<span class="lineNum">      91 </span>            :     {
<span class="lineNum">      92 </span><span class="lineCov">     338411 :       if (TYPE_UNSIGNED (TREE_TYPE (step)))</span>
<span class="lineNum">      93 </span>            :         {
<span class="lineNum">      94 </span><span class="lineCov">     674552 :           step1 = fold_build1 (NEGATE_EXPR, TREE_TYPE (step), step);</span>
<span class="lineNum">      95 </span><span class="lineCov">     337276 :           if (tree_int_cst_lt (step1, step))</span>
<span class="lineNum">      96 </span>            :             {
<span class="lineNum">      97 </span><span class="lineCov">     118757 :               incr_op = MINUS_EXPR;</span>
<span class="lineNum">      98 </span><span class="lineCov">     118757 :               step = step1;</span>
<span class="lineNum">      99 </span>            :             }
<span class="lineNum">     100 </span>            :         }
<span class="lineNum">     101 </span>            :       else
<span class="lineNum">     102 </span>            :         {
<span class="lineNum">     103 </span><span class="lineCov">       1135 :           bool ovf;</span>
<span class="lineNum">     104 </span>            : 
<span class="lineNum">     105 </span><span class="lineCov">       1135 :           if (!tree_expr_nonnegative_warnv_p (step, &amp;ovf)</span>
<span class="lineNum">     106 </span><span class="lineCov">       1135 :               &amp;&amp; may_negate_without_overflow_p (step))</span>
<span class="lineNum">     107 </span>            :             {
<span class="lineNum">     108 </span><span class="lineCov">         13 :               incr_op = MINUS_EXPR;</span>
<span class="lineNum">     109 </span><span class="lineCov">         13 :               step = fold_build1 (NEGATE_EXPR, TREE_TYPE (step), step);</span>
<span class="lineNum">     110 </span>            :             }
<span class="lineNum">     111 </span>            :         }
<span class="lineNum">     112 </span>            :     }
<span class="lineNum">     113 </span><span class="lineCov">     373328 :   if (POINTER_TYPE_P (TREE_TYPE (base)))</span>
<span class="lineNum">     114 </span>            :     {
<span class="lineNum">     115 </span><span class="lineCov">      39352 :       if (TREE_CODE (base) == ADDR_EXPR)</span>
<span class="lineNum">     116 </span><span class="lineCov">      13899 :         mark_addressable (TREE_OPERAND (base, 0));</span>
<span class="lineNum">     117 </span><span class="lineCov">      39352 :       step = convert_to_ptrofftype (step);</span>
<span class="lineNum">     118 </span><span class="lineCov">      39352 :       if (incr_op == MINUS_EXPR)</span>
<span class="lineNum">     119 </span><span class="lineCov">        389 :         step = fold_build1 (NEGATE_EXPR, TREE_TYPE (step), step);</span>
<span class="lineNum">     120 </span>            :       incr_op = POINTER_PLUS_EXPR;
<span class="lineNum">     121 </span>            :     }
<span class="lineNum">     122 </span>            :   /* Gimplify the step if necessary.  We put the computations in front of the
<span class="lineNum">     123 </span>            :      loop (i.e. the step should be loop invariant).  */
<span class="lineNum">     124 </span><span class="lineCov">     373328 :   step = force_gimple_operand (step, &amp;stmts, true, NULL_TREE);</span>
<span class="lineNum">     125 </span><span class="lineCov">     373328 :   if (stmts)</span>
<span class="lineNum">     126 </span><span class="lineCov">      31317 :     gsi_insert_seq_on_edge_immediate (pe, stmts);</span>
<span class="lineNum">     127 </span>            : 
<span class="lineNum">     128 </span><span class="lineCov">     373328 :   stmt = gimple_build_assign (va, incr_op, vb, step);</span>
<span class="lineNum">     129 </span><span class="lineCov">     373328 :   if (after)</span>
<span class="lineNum">     130 </span><span class="lineCov">       9245 :     gsi_insert_after (incr_pos, stmt, GSI_NEW_STMT);</span>
<span class="lineNum">     131 </span>            :   else
<span class="lineNum">     132 </span><span class="lineCov">     364083 :     gsi_insert_before (incr_pos, stmt, GSI_NEW_STMT);</span>
<span class="lineNum">     133 </span>            : 
<span class="lineNum">     134 </span><span class="lineCov">     373328 :   initial = force_gimple_operand (base, &amp;stmts, true, var);</span>
<span class="lineNum">     135 </span><span class="lineCov">     373328 :   if (stmts)</span>
<span class="lineNum">     136 </span><span class="lineCov">     119380 :     gsi_insert_seq_on_edge_immediate (pe, stmts);</span>
<span class="lineNum">     137 </span>            : 
<span class="lineNum">     138 </span><span class="lineCov">     373328 :   phi = create_phi_node (vb, loop-&gt;header);</span>
<span class="lineNum">     139 </span><span class="lineCov">     373328 :   add_phi_arg (phi, initial, loop_preheader_edge (loop), UNKNOWN_LOCATION);</span>
<span class="lineNum">     140 </span><span class="lineCov">     373328 :   add_phi_arg (phi, va, loop_latch_edge (loop), UNKNOWN_LOCATION);</span>
<span class="lineNum">     141 </span><span class="lineCov">     373328 : }</span>
<span class="lineNum">     142 </span>            : 
<span class="lineNum">     143 </span>            : /* Return the innermost superloop LOOP of USE_LOOP that is a superloop of
<span class="lineNum">     144 </span>            :    both DEF_LOOP and USE_LOOP.  */
<span class="lineNum">     145 </span>            : 
<span class="lineNum">     146 </span>            : static inline struct loop *
<span class="lineNum">     147 </span><span class="lineCov">      46294 : find_sibling_superloop (struct loop *use_loop, struct loop *def_loop)</span>
<span class="lineNum">     148 </span>            : {
<span class="lineNum">     149 </span><span class="lineCov">      46294 :   unsigned ud = loop_depth (use_loop);</span>
<span class="lineNum">     150 </span><span class="lineCov">      46294 :   unsigned dd = loop_depth (def_loop);</span>
<span class="lineNum">     151 </span><span class="lineCov">      46294 :   gcc_assert (ud &gt; 0 &amp;&amp; dd &gt; 0);</span>
<span class="lineNum">     152 </span><span class="lineCov">      46294 :   if (ud &gt; dd)</span>
<span class="lineNum">     153 </span><span class="lineCov">       6576 :     use_loop = superloop_at_depth (use_loop, dd);</span>
<span class="lineNum">     154 </span><span class="lineCov">      46294 :   if (ud &lt; dd)</span>
<span class="lineNum">     155 </span><span class="lineCov">       9761 :     def_loop = superloop_at_depth (def_loop, ud);</span>
<span class="lineNum">     156 </span><span class="lineCov">     140259 :   while (loop_outer (use_loop) != loop_outer (def_loop))</span>
<span class="lineNum">     157 </span>            :     {
<span class="lineNum">     158 </span><span class="lineCov">        459 :       use_loop = loop_outer (use_loop);</span>
<span class="lineNum">     159 </span><span class="lineCov">        459 :       def_loop = loop_outer (def_loop);</span>
<span class="lineNum">     160 </span><span class="lineCov">        459 :       gcc_assert (use_loop &amp;&amp; def_loop);</span>
<span class="lineNum">     161 </span>            :     }
<span class="lineNum">     162 </span><span class="lineCov">      46294 :   return use_loop;</span>
<span class="lineNum">     163 </span>            : }
<span class="lineNum">     164 </span>            : 
<span class="lineNum">     165 </span>            : /* DEF_BB is a basic block containing a DEF that needs rewriting into
<span class="lineNum">     166 </span>            :    loop-closed SSA form.  USE_BLOCKS is the set of basic blocks containing
<span class="lineNum">     167 </span>            :    uses of DEF that &quot;escape&quot; from the loop containing DEF_BB (i.e. blocks in
<span class="lineNum">     168 </span>            :    USE_BLOCKS are dominated by DEF_BB but not in the loop father of DEF_B).
<span class="lineNum">     169 </span>            :    ALL_EXITS[I] is the set of all basic blocks that exit loop I.
<span class="lineNum">     170 </span>            : 
<span class="lineNum">     171 </span>            :    Compute the subset of LOOP_EXITS that exit the loop containing DEF_BB
<span class="lineNum">     172 </span>            :    or one of its loop fathers, in which DEF is live.  This set is returned
<span class="lineNum">     173 </span>            :    in the bitmap LIVE_EXITS.
<span class="lineNum">     174 </span>            : 
<span class="lineNum">     175 </span>            :    Instead of computing the complete livein set of the def, we use the loop
<span class="lineNum">     176 </span>            :    nesting tree as a form of poor man's structure analysis.  This greatly
<span class="lineNum">     177 </span>            :    speeds up the analysis, which is important because this function may be
<span class="lineNum">     178 </span>            :    called on all SSA names that need rewriting, one at a time.  */
<span class="lineNum">     179 </span>            : 
<span class="lineNum">     180 </span>            : static void
<span class="lineNum">     181 </span><span class="lineCov">     812387 : compute_live_loop_exits (bitmap live_exits, bitmap use_blocks,</span>
<span class="lineNum">     182 </span>            :                          bitmap *loop_exits, basic_block def_bb)
<span class="lineNum">     183 </span>            : {
<span class="lineNum">     184 </span><span class="lineCov">     812387 :   unsigned i;</span>
<span class="lineNum">     185 </span><span class="lineCov">     812387 :   bitmap_iterator bi;</span>
<span class="lineNum">     186 </span><span class="lineCov">     812387 :   struct loop *def_loop = def_bb-&gt;loop_father;</span>
<span class="lineNum">     187 </span><span class="lineCov">     812387 :   unsigned def_loop_depth = loop_depth (def_loop);</span>
<span class="lineNum">     188 </span><span class="lineCov">     812387 :   bitmap def_loop_exits;</span>
<span class="lineNum">     189 </span>            : 
<span class="lineNum">     190 </span>            :   /* Normally the work list size is bounded by the number of basic
<span class="lineNum">     191 </span>            :      blocks in the largest loop.  We don't know this number, but we
<span class="lineNum">     192 </span>            :      can be fairly sure that it will be relatively small.  */
<span class="lineNum">     193 </span><span class="lineCov">     812387 :   auto_vec&lt;basic_block&gt; worklist (MAX (8, n_basic_blocks_for_fn (cfun) / 128));</span>
<span class="lineNum">     194 </span>            : 
<span class="lineNum">     195 </span><span class="lineCov">    1894031 :   EXECUTE_IF_SET_IN_BITMAP (use_blocks, 0, i, bi)</span>
<span class="lineNum">     196 </span>            :     {
<span class="lineNum">     197 </span><span class="lineCov">    1081644 :       basic_block use_bb = BASIC_BLOCK_FOR_FN (cfun, i);</span>
<span class="lineNum">     198 </span><span class="lineCov">    1081644 :       struct loop *use_loop = use_bb-&gt;loop_father;</span>
<span class="lineNum">     199 </span><span class="lineCov">    1081644 :       gcc_checking_assert (def_loop != use_loop</span>
<span class="lineNum">     200 </span>            :                            &amp;&amp; ! flow_loop_nested_p (def_loop, use_loop));
<span class="lineNum">     201 </span><span class="lineCov">    1081644 :       if (! flow_loop_nested_p (use_loop, def_loop))</span>
<span class="lineNum">     202 </span><span class="lineCov">      37505 :         use_bb = find_sibling_superloop (use_loop, def_loop)-&gt;header;</span>
<span class="lineNum">     203 </span><span class="lineCov">    1081644 :       if (bitmap_set_bit (live_exits, use_bb-&gt;index))</span>
<span class="lineNum">     204 </span><span class="lineCov">    1073825 :         worklist.safe_push (use_bb);</span>
<span class="lineNum">     205 </span>            :     }
<span class="lineNum">     206 </span>            : 
<span class="lineNum">     207 </span>            :   /* Iterate until the worklist is empty.  */
<span class="lineNum">     208 </span><span class="lineCov">    2697117 :   while (! worklist.is_empty ())</span>
<span class="lineNum">     209 </span>            :     {
<span class="lineNum">     210 </span><span class="lineCov">    1884730 :       edge e;</span>
<span class="lineNum">     211 </span><span class="lineCov">    1884730 :       edge_iterator ei;</span>
<span class="lineNum">     212 </span>            : 
<span class="lineNum">     213 </span>            :       /* Pull a block off the worklist.  */
<span class="lineNum">     214 </span><span class="lineCov">    1884730 :       basic_block bb = worklist.pop ();</span>
<span class="lineNum">     215 </span>            : 
<span class="lineNum">     216 </span>            :       /* Make sure we have at least enough room in the work list
<span class="lineNum">     217 </span>            :          for all predecessors of this block.  */
<span class="lineNum">     218 </span><span class="lineCov">    3769460 :       worklist.reserve (EDGE_COUNT (bb-&gt;preds));</span>
<span class="lineNum">     219 </span>            : 
<span class="lineNum">     220 </span>            :       /* For each predecessor block.  */
<span class="lineNum">     221 </span><span class="lineCov">    6012739 :       FOR_EACH_EDGE (e, ei, bb-&gt;preds)</span>
<span class="lineNum">     222 </span>            :         {
<span class="lineNum">     223 </span><span class="lineCov">    2243279 :           basic_block pred = e-&gt;src;</span>
<span class="lineNum">     224 </span><span class="lineCov">    2243279 :           struct loop *pred_loop = pred-&gt;loop_father;</span>
<span class="lineNum">     225 </span><span class="lineCov">    2243279 :           unsigned pred_loop_depth = loop_depth (pred_loop);</span>
<span class="lineNum">     226 </span><span class="lineCov">    2243279 :           bool pred_visited;</span>
<span class="lineNum">     227 </span>            : 
<span class="lineNum">     228 </span>            :           /* We should have met DEF_BB along the way.  */
<span class="lineNum">     229 </span><span class="lineCov">    2243279 :           gcc_assert (pred != ENTRY_BLOCK_PTR_FOR_FN (cfun));</span>
<span class="lineNum">     230 </span>            : 
<span class="lineNum">     231 </span><span class="lineCov">    2243279 :           if (pred_loop_depth &gt;= def_loop_depth)</span>
<span class="lineNum">     232 </span>            :             {
<span class="lineNum">     233 </span><span class="lineCov">    1148364 :               if (pred_loop_depth &gt; def_loop_depth)</span>
<span class="lineNum">     234 </span><span class="lineCov">      57664 :                 pred_loop = superloop_at_depth (pred_loop, def_loop_depth);</span>
<span class="lineNum">     235 </span>            :               /* If we've reached DEF_LOOP, our train ends here.  */
<span class="lineNum">     236 </span><span class="lineCov">    1148364 :               if (pred_loop == def_loop)</span>
<span class="lineNum">     237 </span>            :                 continue;
<span class="lineNum">     238 </span>            :             }
<span class="lineNum">     239 </span><span class="lineCov">    1094915 :           else if (! flow_loop_nested_p (pred_loop, def_loop))</span>
<span class="lineNum">     240 </span><span class="lineCov">       8789 :             pred = find_sibling_superloop (pred_loop, def_loop)-&gt;header;</span>
<span class="lineNum">     241 </span>            : 
<span class="lineNum">     242 </span>            :           /* Add PRED to the LIVEIN set.  PRED_VISITED is true if
<span class="lineNum">     243 </span>            :              we had already added PRED to LIVEIN before.  */
<span class="lineNum">     244 </span><span class="lineCov">    1305147 :           pred_visited = !bitmap_set_bit (live_exits, pred-&gt;index);</span>
<span class="lineNum">     245 </span>            : 
<span class="lineNum">     246 </span>            :           /* If we have visited PRED before, don't add it to the worklist.
<span class="lineNum">     247 </span>            :              If BB dominates PRED, then we're probably looking at a loop.
<span class="lineNum">     248 </span>            :              We're only interested in looking up in the dominance tree
<span class="lineNum">     249 </span>            :              because DEF_BB dominates all the uses.  */
<span class="lineNum">     250 </span><span class="lineCov">    1305147 :           if (pred_visited || dominated_by_p (CDI_DOMINATORS, pred, bb))</span>
<span class="lineNum">     251 </span><span class="lineCov">     494242 :             continue;</span>
<span class="lineNum">     252 </span>            : 
<span class="lineNum">     253 </span><span class="lineCov">     810905 :           worklist.quick_push (pred);</span>
<span class="lineNum">     254 </span>            :         }
<span class="lineNum">     255 </span>            :     }
<span class="lineNum">     256 </span>            : 
<span class="lineNum">     257 </span><span class="lineCov">     812387 :   def_loop_exits = BITMAP_ALLOC (&amp;loop_renamer_obstack);</span>
<span class="lineNum">     258 </span><span class="lineCov">     812387 :   for (struct loop *loop = def_loop;</span>
<span class="lineNum">     259 </span><span class="lineCov">    2196488 :        loop != current_loops-&gt;tree_root;</span>
<span class="lineNum">     260 </span><span class="lineCov">    1384101 :        loop = loop_outer (loop))</span>
<span class="lineNum">     261 </span><span class="lineCov">    1384101 :     bitmap_ior_into (def_loop_exits, loop_exits[loop-&gt;num]);</span>
<span class="lineNum">     262 </span><span class="lineCov">     812387 :   bitmap_and_into (live_exits, def_loop_exits);</span>
<span class="lineNum">     263 </span><span class="lineCov">     812387 :   BITMAP_FREE (def_loop_exits);</span>
<span class="lineNum">     264 </span><span class="lineCov">     812387 : }</span>
<span class="lineNum">     265 </span>            : 
<span class="lineNum">     266 </span>            : /* Add a loop-closing PHI for VAR in basic block EXIT.  */
<a name="267"><span class="lineNum">     267 </span>            : </a>
<span class="lineNum">     268 </span>            : static void
<span class="lineNum">     269 </span><span class="lineCov">     905970 : add_exit_phi (basic_block exit, tree var)</span>
<span class="lineNum">     270 </span>            : {
<span class="lineNum">     271 </span><span class="lineCov">     905970 :   gphi *phi;</span>
<span class="lineNum">     272 </span><span class="lineCov">     905970 :   edge e;</span>
<span class="lineNum">     273 </span><span class="lineCov">     905970 :   edge_iterator ei;</span>
<span class="lineNum">     274 </span>            : 
<span class="lineNum">     275 </span>            :   /* Check that at least one of the edges entering the EXIT block exits
<span class="lineNum">     276 </span>            :      the loop, or a superloop of that loop, that VAR is defined in.  */
<span class="lineNum">     277 </span><span class="lineCov">     905970 :   if (flag_checking)</span>
<span class="lineNum">     278 </span>            :     {
<span class="lineNum">     279 </span><span class="lineCov">     905872 :       gimple *def_stmt = SSA_NAME_DEF_STMT (var);</span>
<span class="lineNum">     280 </span><span class="lineCov">     905872 :       basic_block def_bb = gimple_bb (def_stmt);</span>
<span class="lineNum">     281 </span><span class="lineCov">    1817340 :       FOR_EACH_EDGE (e, ei, exit-&gt;preds)</span>
<span class="lineNum">     282 </span>            :         {
<span class="lineNum">     283 </span><span class="lineCov">    2734404 :           struct loop *aloop = find_common_loop (def_bb-&gt;loop_father,</span>
<span class="lineNum">     284 </span><span class="lineCov">     911468 :                                                  e-&gt;src-&gt;loop_father);</span>
<span class="lineNum">     285 </span><span class="lineCov">     911468 :           if (!flow_bb_inside_loop_p (aloop, e-&gt;dest))</span>
<span class="lineNum">     286 </span>            :             break;
<span class="lineNum">     287 </span>            :         }
<span class="lineNum">     288 </span><span class="lineCov">     905872 :       gcc_assert (e);</span>
<span class="lineNum">     289 </span>            :     }
<span class="lineNum">     290 </span>            : 
<span class="lineNum">     291 </span><span class="lineCov">     905970 :   phi = create_phi_node (NULL_TREE, exit);</span>
<span class="lineNum">     292 </span><span class="lineCov">    1811940 :   create_new_def_for (var, phi, gimple_phi_result_ptr (phi));</span>
<span class="lineNum">     293 </span><span class="lineCov">    2775398 :   FOR_EACH_EDGE (e, ei, exit-&gt;preds)</span>
<span class="lineNum">     294 </span><span class="lineCov">     963458 :     add_phi_arg (phi, var, e, UNKNOWN_LOCATION);</span>
<span class="lineNum">     295 </span>            : 
<span class="lineNum">     296 </span><span class="lineCov">     905970 :   if (dump_file &amp;&amp; (dump_flags &amp; TDF_DETAILS))</span>
<span class="lineNum">     297 </span>            :     {
<span class="lineNum">     298 </span><span class="lineCov">        573 :       fprintf (dump_file, &quot;;; Created LCSSA PHI: &quot;);</span>
<span class="lineNum">     299 </span><span class="lineCov">        573 :       print_gimple_stmt (dump_file, phi, 0, dump_flags);</span>
<span class="lineNum">     300 </span>            :     }
<span class="lineNum">     301 </span><span class="lineCov">     905970 : }</span>
<span class="lineNum">     302 </span>            : 
<span class="lineNum">     303 </span>            : /* Add exit phis for VAR that is used in LIVEIN.
<span class="lineNum">     304 </span>            :    Exits of the loops are stored in LOOP_EXITS.  */
<span class="lineNum">     305 </span>            : 
<span class="lineNum">     306 </span>            : static void
<span class="lineNum">     307 </span><span class="lineCov">     812387 : add_exit_phis_var (tree var, bitmap use_blocks, bitmap *loop_exits)</span>
<span class="lineNum">     308 </span>            : {
<span class="lineNum">     309 </span><span class="lineCov">     812387 :   unsigned index;</span>
<span class="lineNum">     310 </span><span class="lineCov">     812387 :   bitmap_iterator bi;</span>
<span class="lineNum">     311 </span><span class="lineCov">     812387 :   basic_block def_bb = gimple_bb (SSA_NAME_DEF_STMT (var));</span>
<span class="lineNum">     312 </span><span class="lineCov">     812387 :   bitmap live_exits = BITMAP_ALLOC (&amp;loop_renamer_obstack);</span>
<span class="lineNum">     313 </span>            : 
<span class="lineNum">     314 </span><span class="lineCov">     812387 :   gcc_checking_assert (! bitmap_bit_p (use_blocks, def_bb-&gt;index));</span>
<span class="lineNum">     315 </span>            : 
<span class="lineNum">     316 </span><span class="lineCov">     812387 :   compute_live_loop_exits (live_exits, use_blocks, loop_exits, def_bb);</span>
<span class="lineNum">     317 </span>            : 
<span class="lineNum">     318 </span><span class="lineCov">    1718357 :   EXECUTE_IF_SET_IN_BITMAP (live_exits, 0, index, bi)</span>
<span class="lineNum">     319 </span>            :     {
<span class="lineNum">     320 </span><span class="lineCov">     905970 :       add_exit_phi (BASIC_BLOCK_FOR_FN (cfun, index), var);</span>
<span class="lineNum">     321 </span>            :     }
<span class="lineNum">     322 </span>            : 
<span class="lineNum">     323 </span><span class="lineCov">     812387 :   BITMAP_FREE (live_exits);</span>
<span class="lineNum">     324 </span><span class="lineCov">     812387 : }</span>
<span class="lineNum">     325 </span>            : 
<span class="lineNum">     326 </span>            : /* Add exit phis for the names marked in NAMES_TO_RENAME.
<span class="lineNum">     327 </span>            :    Exits of the loops are stored in EXITS.  Sets of blocks where the ssa
<span class="lineNum">     328 </span>            :    names are used are stored in USE_BLOCKS.  */
<span class="lineNum">     329 </span>            : 
<span class="lineNum">     330 </span>            : static void
<span class="lineNum">     331 </span><span class="lineCov">     212687 : add_exit_phis (bitmap names_to_rename, bitmap *use_blocks, bitmap *loop_exits)</span>
<span class="lineNum">     332 </span>            : {
<span class="lineNum">     333 </span><span class="lineCov">     212687 :   unsigned i;</span>
<span class="lineNum">     334 </span><span class="lineCov">     212687 :   bitmap_iterator bi;</span>
<span class="lineNum">     335 </span>            : 
<span class="lineNum">     336 </span><span class="lineCov">    1025074 :   EXECUTE_IF_SET_IN_BITMAP (names_to_rename, 0, i, bi)</span>
<span class="lineNum">     337 </span>            :     {
<span class="lineNum">     338 </span><span class="lineCov">     812387 :       add_exit_phis_var (ssa_name (i), use_blocks[i], loop_exits);</span>
<span class="lineNum">     339 </span>            :     }
<span class="lineNum">     340 </span><span class="lineCov">     212687 : }</span>
<span class="lineNum">     341 </span>            : 
<span class="lineNum">     342 </span>            : /* Fill the array of bitmaps LOOP_EXITS with all loop exit edge targets.  */
<span class="lineNum">     343 </span>            : 
<span class="lineNum">     344 </span>            : static void
<span class="lineNum">     345 </span><span class="lineCov">     212687 : get_loops_exits (bitmap *loop_exits)</span>
<span class="lineNum">     346 </span>            : {
<span class="lineNum">     347 </span><span class="lineCov">     212687 :   struct loop *loop;</span>
<span class="lineNum">     348 </span><span class="lineCov">     212687 :   unsigned j;</span>
<span class="lineNum">     349 </span><span class="lineCov">     212687 :   edge e;</span>
<span class="lineNum">     350 </span>            : 
<span class="lineNum">     351 </span><span class="lineCov">     951926 :   FOR_EACH_LOOP (loop, 0)</span>
<span class="lineNum">     352 </span>            :     {
<span class="lineNum">     353 </span><span class="lineCov">     739239 :       vec&lt;edge&gt; exit_edges = get_loop_exit_edges (loop);</span>
<span class="lineNum">     354 </span><span class="lineCov">     739239 :       loop_exits[loop-&gt;num] = BITMAP_ALLOC (&amp;loop_renamer_obstack);</span>
<span class="lineNum">     355 </span><span class="lineCov">    2469898 :       FOR_EACH_VEC_ELT (exit_edges, j, e)</span>
<span class="lineNum">     356 </span><span class="lineCov">    1730659 :         bitmap_set_bit (loop_exits[loop-&gt;num], e-&gt;dest-&gt;index);</span>
<span class="lineNum">     357 </span><span class="lineCov">    1475459 :       exit_edges.release ();</span>
<span class="lineNum">     358 </span>            :     }
<span class="lineNum">     359 </span><span class="lineCov">     212687 : }</span>
<span class="lineNum">     360 </span>            : 
<span class="lineNum">     361 </span>            : /* For USE in BB, if it is used outside of the loop it is defined in,
<span class="lineNum">     362 </span>            :    mark it for rewrite.  Record basic block BB where it is used
<span class="lineNum">     363 </span>            :    to USE_BLOCKS.  Record the ssa name index to NEED_PHIS bitmap.
<span class="lineNum">     364 </span>            :    Note that for USEs in phis, BB should be the src of the edge corresponding to
<span class="lineNum">     365 </span>            :    the use, rather than the bb containing the phi.  */
<span class="lineNum">     366 </span>            : 
<span class="lineNum">     367 </span>            : static void
<span class="lineNum">     368 </span><span class="lineCov">   48995685 : find_uses_to_rename_use (basic_block bb, tree use, bitmap *use_blocks,</span>
<span class="lineNum">     369 </span>            :                          bitmap need_phis)
<span class="lineNum">     370 </span>            : {
<span class="lineNum">     371 </span><span class="lineCov">   48995685 :   unsigned ver;</span>
<span class="lineNum">     372 </span><span class="lineCov">   48995685 :   basic_block def_bb;</span>
<span class="lineNum">     373 </span><span class="lineCov">   48995685 :   struct loop *def_loop;</span>
<span class="lineNum">     374 </span>            : 
<span class="lineNum">     375 </span><span class="lineCov">   48995685 :   if (TREE_CODE (use) != SSA_NAME)</span>
<span class="lineNum">     376 </span>            :     return;
<span class="lineNum">     377 </span>            : 
<span class="lineNum">     378 </span><span class="lineCov">   46787242 :   ver = SSA_NAME_VERSION (use);</span>
<span class="lineNum">     379 </span><span class="lineCov">   93574484 :   def_bb = gimple_bb (SSA_NAME_DEF_STMT (use));</span>
<span class="lineNum">     380 </span><span class="lineCov">   46787242 :   if (!def_bb)</span>
<span class="lineNum">     381 </span>            :     return;
<span class="lineNum">     382 </span><span class="lineCov">   42850240 :   def_loop = def_bb-&gt;loop_father;</span>
<span class="lineNum">     383 </span>            : 
<span class="lineNum">     384 </span>            :   /* If the definition is not inside a loop, it is not interesting.  */
<span class="lineNum">     385 </span><span class="lineCov">   69276583 :   if (!loop_outer (def_loop))</span>
<span class="lineNum">     386 </span>            :     return;
<span class="lineNum">     387 </span>            : 
<span class="lineNum">     388 </span>            :   /* If the use is not outside of the loop it is defined in, it is not
<span class="lineNum">     389 </span>            :      interesting.  */
<span class="lineNum">     390 </span><span class="lineCov">   26426343 :   if (flow_bb_inside_loop_p (def_loop, bb))</span>
<span class="lineNum">     391 </span>            :     return;
<span class="lineNum">     392 </span>            : 
<span class="lineNum">     393 </span>            :   /* If we're seeing VER for the first time, we still have to allocate
<span class="lineNum">     394 </span>            :      a bitmap for its uses.  */
<span class="lineNum">     395 </span><span class="lineCov">    1182489 :   if (bitmap_set_bit (need_phis, ver))</span>
<span class="lineNum">     396 </span><span class="lineCov">     812387 :     use_blocks[ver] = BITMAP_ALLOC (&amp;loop_renamer_obstack);</span>
<span class="lineNum">     397 </span><span class="lineCov">    1182489 :   bitmap_set_bit (use_blocks[ver], bb-&gt;index);</span>
<span class="lineNum">     398 </span>            : }
<span class="lineNum">     399 </span>            : 
<span class="lineNum">     400 </span>            : /* For uses matching USE_FLAGS in STMT, mark names that are used outside of the
<span class="lineNum">     401 </span>            :    loop they are defined to rewrite.  Record the set of blocks in which the ssa
<span class="lineNum">     402 </span>            :    names are used to USE_BLOCKS, and the ssa names themselves to NEED_PHIS.  */
<a name="403"><span class="lineNum">     403 </span>            : </a>
<span class="lineNum">     404 </span>            : static void
<span class="lineNum">     405 </span><span class="lineCov">  110683847 : find_uses_to_rename_stmt (gimple *stmt, bitmap *use_blocks, bitmap need_phis,</span>
<span class="lineNum">     406 </span>            :                           int use_flags)
<span class="lineNum">     407 </span>            : {
<span class="lineNum">     408 </span><span class="lineCov">  110683847 :   ssa_op_iter iter;</span>
<span class="lineNum">     409 </span><span class="lineCov">  110683847 :   tree var;</span>
<span class="lineNum">     410 </span><span class="lineCov">  110683847 :   basic_block bb = gimple_bb (stmt);</span>
<span class="lineNum">     411 </span>            : 
<span class="lineNum">     412 </span><span class="lineCov">  221367694 :   if (is_gimple_debug (stmt))</span>
<span class="lineNum">     413 </span><span class="lineCov">   64708920 :     return;</span>
<span class="lineNum">     414 </span>            : 
<span class="lineNum">     415 </span>            :   /* FOR_EACH_SSA_TREE_OPERAND iterator does not allows SSA_OP_VIRTUAL_USES
<span class="lineNum">     416 </span>            :      only.  */
<span class="lineNum">     417 </span><span class="lineCov">   45974927 :   if (use_flags == SSA_OP_VIRTUAL_USES)</span>
<span class="lineNum">     418 </span>            :     {
<span class="lineNum">     419 </span><span class="lineNoCov">          0 :       tree vuse = gimple_vuse (stmt);</span>
<span class="lineNum">     420 </span><span class="lineNoCov">          0 :       if (vuse != NULL_TREE)</span>
<span class="lineNum">     421 </span><span class="lineNoCov">          0 :         find_uses_to_rename_use (bb, gimple_vuse (stmt), use_blocks, need_phis);</span>
<span class="lineNum">     422 </span>            :     }
<span class="lineNum">     423 </span>            :   else
<span class="lineNum">     424 </span><span class="lineCov">   85689769 :     FOR_EACH_SSA_TREE_OPERAND (var, stmt, iter, use_flags)</span>
<span class="lineNum">     425 </span><span class="lineCov">   39714842 :       find_uses_to_rename_use (bb, var, use_blocks, need_phis);</span>
<span class="lineNum">     426 </span>            : }
<span class="lineNum">     427 </span>            : 
<span class="lineNum">     428 </span>            : /* Marks names matching USE_FLAGS that are used in BB and outside of the loop
<span class="lineNum">     429 </span>            :    they are defined in for rewrite.  Records the set of blocks in which the ssa
<span class="lineNum">     430 </span>            :    names are used to USE_BLOCKS.  Record the SSA names that will
<span class="lineNum">     431 </span>            :    need exit PHIs in NEED_PHIS.  */
<a name="432"><span class="lineNum">     432 </span>            : </a>
<span class="lineNum">     433 </span>            : static void
<span class="lineNum">     434 </span><span class="lineCov">   15672139 : find_uses_to_rename_bb (basic_block bb, bitmap *use_blocks, bitmap need_phis,</span>
<span class="lineNum">     435 </span>            :                         int use_flags)
<span class="lineNum">     436 </span>            : {
<span class="lineNum">     437 </span><span class="lineCov">   15672139 :   edge e;</span>
<span class="lineNum">     438 </span><span class="lineCov">   15672139 :   edge_iterator ei;</span>
<span class="lineNum">     439 </span><span class="lineCov">   15672139 :   bool do_virtuals = (use_flags &amp; SSA_OP_VIRTUAL_USES) != 0;</span>
<span class="lineNum">     440 </span><span class="lineCov">   15672139 :   bool do_nonvirtuals = (use_flags &amp; SSA_OP_USE) != 0;</span>
<span class="lineNum">     441 </span>            : 
<span class="lineNum">     442 </span><span class="lineCov">   53771300 :   FOR_EACH_EDGE (e, ei, bb-&gt;succs)</span>
<span class="lineNum">     443 </span><span class="lineCov">   56917344 :     for (gphi_iterator bsi = gsi_start_phis (e-&gt;dest); !gsi_end_p (bsi);</span>
<span class="lineNum">     444 </span><span class="lineCov">   17245161 :          gsi_next (&amp;bsi))</span>
<span class="lineNum">     445 </span>            :       {
<span class="lineNum">     446 </span><span class="lineCov">   17245161 :         gphi *phi = bsi.phi ();</span>
<span class="lineNum">     447 </span><span class="lineCov">   34490322 :         bool virtual_p = virtual_operand_p (gimple_phi_result (phi));</span>
<span class="lineNum">     448 </span><span class="lineCov">   17245161 :         if ((virtual_p &amp;&amp; do_virtuals)</span>
<span class="lineNum">     449 </span><span class="lineCov">   17245161 :             || (!virtual_p &amp;&amp; do_nonvirtuals))</span>
<span class="lineNum">     450 </span><span class="lineCov">    9270400 :           find_uses_to_rename_use (bb, PHI_ARG_DEF_FROM_EDGE (phi, e),</span>
<span class="lineNum">     451 </span>            :                                    use_blocks, need_phis);
<span class="lineNum">     452 </span>            :       }
<span class="lineNum">     453 </span>            : 
<span class="lineNum">     454 </span><span class="lineCov">  268384111 :   for (gimple_stmt_iterator bsi = gsi_start_bb (bb); !gsi_end_p (bsi);</span>
<span class="lineNum">     455 </span><span class="lineCov">  110683847 :        gsi_next (&amp;bsi))</span>
<span class="lineNum">     456 </span><span class="lineCov">  221367694 :     find_uses_to_rename_stmt (gsi_stmt (bsi), use_blocks, need_phis,</span>
<span class="lineNum">     457 </span>            :                               use_flags);
<span class="lineNum">     458 </span><span class="lineCov">   15672139 : }</span>
<span class="lineNum">     459 </span>            : 
<span class="lineNum">     460 </span>            : /* Marks names matching USE_FLAGS that are used outside of the loop they are
<span class="lineNum">     461 </span>            :    defined in for rewrite.  Records the set of blocks in which the ssa names are
<span class="lineNum">     462 </span>            :    used to USE_BLOCKS.  Record the SSA names that will need exit PHIs in
<span class="lineNum">     463 </span>            :    NEED_PHIS.  If CHANGED_BBS is not NULL, scan only blocks in this set.  */
<span class="lineNum">     464 </span>            : 
<span class="lineNum">     465 </span>            : static void
<span class="lineNum">     466 </span><span class="lineCov">     667211 : find_uses_to_rename (bitmap changed_bbs, bitmap *use_blocks, bitmap need_phis,</span>
<span class="lineNum">     467 </span>            :                      int use_flags)
<span class="lineNum">     468 </span>            : {
<span class="lineNum">     469 </span><span class="lineCov">     667211 :   basic_block bb;</span>
<span class="lineNum">     470 </span><span class="lineCov">     667211 :   unsigned index;</span>
<span class="lineNum">     471 </span><span class="lineCov">     667211 :   bitmap_iterator bi;</span>
<span class="lineNum">     472 </span>            : 
<span class="lineNum">     473 </span><span class="lineCov">     667211 :   if (changed_bbs)</span>
<span class="lineNum">     474 </span><span class="lineCov">     121222 :     EXECUTE_IF_SET_IN_BITMAP (changed_bbs, 0, index, bi)</span>
<span class="lineNum">     475 </span>            :       {
<span class="lineNum">     476 </span><span class="lineCov">      10244 :         bb = BASIC_BLOCK_FOR_FN (cfun, index);</span>
<span class="lineNum">     477 </span><span class="lineCov">      10244 :         if (bb)</span>
<span class="lineNum">     478 </span><span class="lineCov">      10244 :           find_uses_to_rename_bb (bb, use_blocks, need_phis, use_flags);</span>
<span class="lineNum">     479 </span>            :       }
<span class="lineNum">     480 </span>            :   else
<span class="lineNum">     481 </span><span class="lineCov">   16218128 :     FOR_EACH_BB_FN (bb, cfun)</span>
<span class="lineNum">     482 </span><span class="lineCov">   15661895 :       find_uses_to_rename_bb (bb, use_blocks, need_phis, use_flags);</span>
<span class="lineNum">     483 </span><span class="lineCov">     667211 : }</span>
<span class="lineNum">     484 </span>            : 
<span class="lineNum">     485 </span>            : /* Mark uses of DEF that are used outside of the loop they are defined in for
<span class="lineNum">     486 </span>            :    rewrite.  Record the set of blocks in which the ssa names are used to
<span class="lineNum">     487 </span>            :    USE_BLOCKS.  Record the SSA names that will need exit PHIs in NEED_PHIS.  */
<span class="lineNum">     488 </span>            : 
<span class="lineNum">     489 </span>            : static void
<span class="lineNum">     490 </span><span class="lineCov">       5264 : find_uses_to_rename_def (tree def, bitmap *use_blocks, bitmap need_phis)</span>
<span class="lineNum">     491 </span>            : {
<span class="lineNum">     492 </span><span class="lineCov">       5264 :   gimple *use_stmt;</span>
<span class="lineNum">     493 </span><span class="lineCov">       5264 :   imm_use_iterator imm_iter;</span>
<span class="lineNum">     494 </span>            : 
<span class="lineNum">     495 </span><span class="lineCov">      15806 :   FOR_EACH_IMM_USE_STMT (use_stmt, imm_iter, def)</span>
<span class="lineNum">     496 </span>            :     {
<span class="lineNum">     497 </span><span class="lineCov">      21084 :       if (is_gimple_debug (use_stmt))</span>
<span class="lineNum">     498 </span>            :         continue;
<span class="lineNum">     499 </span>            : 
<span class="lineNum">     500 </span><span class="lineCov">      10400 :       basic_block use_bb = gimple_bb (use_stmt);</span>
<span class="lineNum">     501 </span>            : 
<span class="lineNum">     502 </span><span class="lineCov">      10400 :       use_operand_p use_p;</span>
<span class="lineNum">     503 </span><span class="lineCov">      41686 :       FOR_EACH_IMM_USE_ON_STMT (use_p, imm_iter)</span>
<span class="lineNum">     504 </span>            :         {
<span class="lineNum">     505 </span><span class="lineCov">      20886 :           if (gimple_code (use_stmt) == GIMPLE_PHI)</span>
<span class="lineNum">     506 </span>            :             {
<span class="lineNum">     507 </span><span class="lineCov">       9408 :               edge e = gimple_phi_arg_edge (as_a &lt;gphi *&gt; (use_stmt),</span>
<span class="lineNum">     508 </span><span class="lineCov">       4704 :                                             PHI_ARG_INDEX_FROM_USE (use_p));</span>
<span class="lineNum">     509 </span><span class="lineCov">       4704 :               use_bb = e-&gt;src;</span>
<span class="lineNum">     510 </span>            :             }
<span class="lineNum">     511 </span><span class="lineCov">      20886 :           find_uses_to_rename_use (use_bb, USE_FROM_PTR (use_p), use_blocks,</span>
<span class="lineNum">     512 </span>            :                                    need_phis);
<span class="lineNum">     513 </span>            :         }
<span class="lineNum">     514 </span>            :     }
<span class="lineNum">     515 </span><span class="lineCov">       5264 : }</span>
<span class="lineNum">     516 </span>            : 
<span class="lineNum">     517 </span>            : /* Marks names matching USE_FLAGS that are defined in LOOP and used outside of
<span class="lineNum">     518 </span>            :    it for rewrite.  Records the set of blocks in which the ssa names are used to
<span class="lineNum">     519 </span>            :    USE_BLOCKS.  Record the SSA names that will need exit PHIs in NEED_PHIS.  */
<a name="520"><span class="lineNum">     520 </span>            : </a>
<span class="lineNum">     521 </span>            : static void
<span class="lineNum">     522 </span><span class="lineCov">       1080 : find_uses_to_rename_in_loop (struct loop *loop, bitmap *use_blocks,</span>
<span class="lineNum">     523 </span>            :                              bitmap need_phis, int use_flags)
<span class="lineNum">     524 </span>            : {
<span class="lineNum">     525 </span><span class="lineCov">       1080 :   bool do_virtuals = (use_flags &amp; SSA_OP_VIRTUAL_USES) != 0;</span>
<span class="lineNum">     526 </span><span class="lineCov">       1080 :   bool do_nonvirtuals = (use_flags &amp; SSA_OP_USE) != 0;</span>
<span class="lineNum">     527 </span><span class="lineCov">       1080 :   int def_flags = ((do_virtuals ? SSA_OP_VIRTUAL_DEFS : 0)</span>
<span class="lineNum">     528 </span><span class="lineCov">       1080 :                    | (do_nonvirtuals ? SSA_OP_DEF : 0));</span>
<span class="lineNum">     529 </span>            : 
<span class="lineNum">     530 </span>            : 
<span class="lineNum">     531 </span><span class="lineCov">       1080 :   basic_block *bbs = get_loop_body (loop);</span>
<span class="lineNum">     532 </span>            : 
<span class="lineNum">     533 </span><span class="lineCov">       7080 :   for (unsigned int i = 0; i &lt; loop-&gt;num_nodes; i++)</span>
<span class="lineNum">     534 </span>            :     {
<span class="lineNum">     535 </span><span class="lineCov">       6000 :       basic_block bb = bbs[i];</span>
<span class="lineNum">     536 </span>            : 
<span class="lineNum">     537 </span><span class="lineCov">      15158 :       for (gphi_iterator bsi = gsi_start_phis (bb); !gsi_end_p (bsi);</span>
<span class="lineNum">     538 </span><span class="lineCov">       4579 :            gsi_next (&amp;bsi))</span>
<span class="lineNum">     539 </span>            :         {
<span class="lineNum">     540 </span><span class="lineCov">       4579 :           gphi *phi = bsi.phi ();</span>
<span class="lineNum">     541 </span><span class="lineCov">       4579 :           tree res = gimple_phi_result (phi);</span>
<span class="lineNum">     542 </span><span class="lineCov">       4579 :           bool virtual_p = virtual_operand_p (res);</span>
<span class="lineNum">     543 </span><span class="lineCov">       4579 :           if ((virtual_p &amp;&amp; do_virtuals)</span>
<span class="lineNum">     544 </span><span class="lineCov">       2339 :               || (!virtual_p &amp;&amp; do_nonvirtuals))</span>
<span class="lineNum">     545 </span><span class="lineCov">       2518 :             find_uses_to_rename_def (res, use_blocks, need_phis);</span>
<span class="lineNum">     546 </span>            :       }
<span class="lineNum">     547 </span>            : 
<span class="lineNum">     548 </span><span class="lineCov">      55754 :       for (gimple_stmt_iterator bsi = gsi_start_bb (bb); !gsi_end_p (bsi);</span>
<span class="lineNum">     549 </span><span class="lineCov">      18877 :            gsi_next (&amp;bsi))</span>
<span class="lineNum">     550 </span>            :         {
<span class="lineNum">     551 </span><span class="lineCov">      18877 :           gimple *stmt = gsi_stmt (bsi);</span>
<span class="lineNum">     552 </span>            :           /* FOR_EACH_SSA_TREE_OPERAND iterator does not allows
<span class="lineNum">     553 </span>            :              SSA_OP_VIRTUAL_DEFS only.  */
<span class="lineNum">     554 </span><span class="lineCov">      18877 :           if (def_flags == SSA_OP_VIRTUAL_DEFS)</span>
<span class="lineNum">     555 </span>            :             {
<span class="lineNum">     556 </span><span class="lineCov">      16645 :               tree vdef = gimple_vdef (stmt);</span>
<span class="lineNum">     557 </span><span class="lineCov">      13159 :               if (vdef != NULL)</span>
<span class="lineNum">     558 </span><span class="lineCov">       1264 :                 find_uses_to_rename_def (vdef, use_blocks, need_phis);</span>
<span class="lineNum">     559 </span>            :             }
<span class="lineNum">     560 </span>            :           else
<span class="lineNum">     561 </span>            :             {
<span class="lineNum">     562 </span><span class="lineCov">       2232 :               tree var;</span>
<span class="lineNum">     563 </span><span class="lineCov">       2232 :               ssa_op_iter iter;</span>
<span class="lineNum">     564 </span><span class="lineCov">       3714 :               FOR_EACH_SSA_TREE_OPERAND (var, stmt, iter, def_flags)</span>
<span class="lineNum">     565 </span><span class="lineCov">       1482 :                 find_uses_to_rename_def (var, use_blocks, need_phis);</span>
<span class="lineNum">     566 </span>            :             }
<span class="lineNum">     567 </span>            :         }
<span class="lineNum">     568 </span>            :     }
<span class="lineNum">     569 </span>            : 
<span class="lineNum">     570 </span><span class="lineCov">       1080 :   XDELETEVEC (bbs);</span>
<span class="lineNum">     571 </span><span class="lineCov">       1080 : }</span>
<span class="lineNum">     572 </span>            : 
<span class="lineNum">     573 </span>            : /* Rewrites the program into a loop closed ssa form -- i.e. inserts extra
<span class="lineNum">     574 </span>            :    phi nodes to ensure that no variable is used outside the loop it is
<span class="lineNum">     575 </span>            :    defined in.
<span class="lineNum">     576 </span>            : 
<span class="lineNum">     577 </span>            :    This strengthening of the basic ssa form has several advantages:
<span class="lineNum">     578 </span>            : 
<span class="lineNum">     579 </span>            :    1) Updating it during unrolling/peeling/versioning is trivial, since
<span class="lineNum">     580 </span>            :       we do not need to care about the uses outside of the loop.
<span class="lineNum">     581 </span>            :       The same applies to virtual operands which are also rewritten into
<span class="lineNum">     582 </span>            :       loop closed SSA form.  Note that virtual operands are always live
<span class="lineNum">     583 </span>            :       until function exit.
<span class="lineNum">     584 </span>            :    2) The behavior of all uses of an induction variable is the same.
<span class="lineNum">     585 </span>            :       Without this, you need to distinguish the case when the variable
<span class="lineNum">     586 </span>            :       is used outside of the loop it is defined in, for example
<span class="lineNum">     587 </span>            : 
<span class="lineNum">     588 </span>            :       for (i = 0; i &lt; 100; i++)
<span class="lineNum">     589 </span>            :         {
<span class="lineNum">     590 </span>            :           for (j = 0; j &lt; 100; j++)
<span class="lineNum">     591 </span>            :             {
<span class="lineNum">     592 </span>            :               k = i + j;
<span class="lineNum">     593 </span>            :               use1 (k);
<span class="lineNum">     594 </span>            :             }
<span class="lineNum">     595 </span>            :           use2 (k);
<span class="lineNum">     596 </span>            :         }
<span class="lineNum">     597 </span>            : 
<span class="lineNum">     598 </span>            :       Looking from the outer loop with the normal SSA form, the first use of k
<span class="lineNum">     599 </span>            :       is not well-behaved, while the second one is an induction variable with
<span class="lineNum">     600 </span>            :       base 99 and step 1.
<span class="lineNum">     601 </span>            : 
<span class="lineNum">     602 </span>            :       If LOOP is non-null, only rewrite uses that have defs in LOOP.  Otherwise,
<span class="lineNum">     603 </span>            :       if CHANGED_BBS is not NULL, we look for uses outside loops only in the
<span class="lineNum">     604 </span>            :       basic blocks in this set.
<span class="lineNum">     605 </span>            : 
<span class="lineNum">     606 </span>            :       USE_FLAGS allows us to specify whether we want virtual, non-virtual or
<span class="lineNum">     607 </span>            :       both variables rewritten.
<span class="lineNum">     608 </span>            : 
<span class="lineNum">     609 </span>            :       UPDATE_FLAG is used in the call to update_ssa.  See
<span class="lineNum">     610 </span>            :       TODO_update_ssa* for documentation.  */
<span class="lineNum">     611 </span>            : 
<span class="lineNum">     612 </span>            : void
<span class="lineNum">     613 </span><span class="lineCov">    2792426 : rewrite_into_loop_closed_ssa_1 (bitmap changed_bbs, unsigned update_flag,</span>
<span class="lineNum">     614 </span>            :                                 int use_flags, struct loop *loop)
<span class="lineNum">     615 </span>            : {
<span class="lineNum">     616 </span><span class="lineCov">    2792426 :   bitmap *use_blocks;</span>
<span class="lineNum">     617 </span><span class="lineCov">    2792426 :   bitmap names_to_rename;</span>
<span class="lineNum">     618 </span>            : 
<span class="lineNum">     619 </span><span class="lineCov">    2792426 :   loops_state_set (LOOP_CLOSED_SSA);</span>
<span class="lineNum">     620 </span><span class="lineCov">    2792426 :   if (number_of_loops (cfun) &lt;= 1)</span>
<span class="lineNum">     621 </span>            :     return;
<span class="lineNum">     622 </span>            : 
<span class="lineNum">     623 </span>            :   /* If the pass has caused the SSA form to be out-of-date, update it
<span class="lineNum">     624 </span>            :      now.  */
<span class="lineNum">     625 </span><span class="lineCov">     668291 :   if (update_flag != 0)</span>
<span class="lineNum">     626 </span><span class="lineCov">     667069 :     update_ssa (update_flag);</span>
<span class="lineNum">     627 </span><span class="lineCov">       1222 :   else if (flag_checking)</span>
<span class="lineNum">     628 </span><span class="lineCov">       1222 :     verify_ssa (true, true);</span>
<span class="lineNum">     629 </span>            : 
<span class="lineNum">     630 </span><span class="lineCov">     668291 :   bitmap_obstack_initialize (&amp;loop_renamer_obstack);</span>
<span class="lineNum">     631 </span>            : 
<span class="lineNum">     632 </span><span class="lineCov">     668291 :   names_to_rename = BITMAP_ALLOC (&amp;loop_renamer_obstack);</span>
<span class="lineNum">     633 </span>            : 
<span class="lineNum">     634 </span>            :   /* Uses of names to rename.  We don't have to initialize this array,
<span class="lineNum">     635 </span>            :      because we know that we will only have entries for the SSA names
<span class="lineNum">     636 </span>            :      in NAMES_TO_RENAME.  */
<span class="lineNum">     637 </span><span class="lineCov">    1336582 :   use_blocks = XNEWVEC (bitmap, num_ssa_names);</span>
<span class="lineNum">     638 </span>            : 
<span class="lineNum">     639 </span><span class="lineCov">     668291 :   if (loop != NULL)</span>
<span class="lineNum">     640 </span>            :     {
<span class="lineNum">     641 </span><span class="lineCov">       1080 :       gcc_assert (changed_bbs == NULL);</span>
<span class="lineNum">     642 </span><span class="lineCov">       1080 :       find_uses_to_rename_in_loop (loop, use_blocks, names_to_rename,</span>
<span class="lineNum">     643 </span>            :                                    use_flags);
<span class="lineNum">     644 </span>            :     }
<span class="lineNum">     645 </span>            :   else
<span class="lineNum">     646 </span>            :     {
<span class="lineNum">     647 </span><span class="lineCov">     667211 :       gcc_assert (loop == NULL);</span>
<span class="lineNum">     648 </span><span class="lineCov">     667211 :       find_uses_to_rename (changed_bbs, use_blocks, names_to_rename, use_flags);</span>
<span class="lineNum">     649 </span>            :     }
<span class="lineNum">     650 </span>            : 
<span class="lineNum">     651 </span><span class="lineCov">    1336582 :   if (!bitmap_empty_p (names_to_rename))</span>
<span class="lineNum">     652 </span>            :     {
<span class="lineNum">     653 </span>            :       /* An array of bitmaps where LOOP_EXITS[I] is the set of basic blocks
<span class="lineNum">     654 </span>            :          that are the destination of an edge exiting loop number I.  */
<span class="lineNum">     655 </span><span class="lineCov">     425374 :       bitmap *loop_exits = XNEWVEC (bitmap, number_of_loops (cfun));</span>
<span class="lineNum">     656 </span><span class="lineCov">     212687 :       get_loops_exits (loop_exits);</span>
<span class="lineNum">     657 </span>            : 
<span class="lineNum">     658 </span>            :       /* Add the PHI nodes on exits of the loops for the names we need to
<span class="lineNum">     659 </span>            :          rewrite.  */
<span class="lineNum">     660 </span><span class="lineCov">     212687 :       add_exit_phis (names_to_rename, use_blocks, loop_exits);</span>
<span class="lineNum">     661 </span>            : 
<span class="lineNum">     662 </span><span class="lineCov">     212687 :       free (loop_exits);</span>
<span class="lineNum">     663 </span>            : 
<span class="lineNum">     664 </span>            :       /* Fix up all the names found to be used outside their original
<span class="lineNum">     665 </span>            :          loops.  */
<span class="lineNum">     666 </span><span class="lineCov">     212687 :       update_ssa (TODO_update_ssa);</span>
<span class="lineNum">     667 </span>            :     }
<span class="lineNum">     668 </span>            : 
<span class="lineNum">     669 </span><span class="lineCov">     668291 :   bitmap_obstack_release (&amp;loop_renamer_obstack);</span>
<span class="lineNum">     670 </span><span class="lineCov">     668291 :   free (use_blocks);</span>
<span class="lineNum">     671 </span>            : }
<span class="lineNum">     672 </span>            : 
<span class="lineNum">     673 </span>            : /* Rewrites the non-virtual defs and uses into a loop closed ssa form.  If
<span class="lineNum">     674 </span>            :    CHANGED_BBS is not NULL, we look for uses outside loops only in the basic
<span class="lineNum">     675 </span>            :    blocks in this set.  UPDATE_FLAG is used in the call to update_ssa.  See
<span class="lineNum">     676 </span>            :    TODO_update_ssa* for documentation.  */
<a name="677"><span class="lineNum">     677 </span>            : </a>
<span class="lineNum">     678 </span>            : void
<span class="lineNum">     679 </span><span class="lineCov">    2791346 : rewrite_into_loop_closed_ssa (bitmap changed_bbs, unsigned update_flag)</span>
<span class="lineNum">     680 </span>            : {
<span class="lineNum">     681 </span><span class="lineCov">    2791346 :   rewrite_into_loop_closed_ssa_1 (changed_bbs, update_flag, SSA_OP_USE, NULL);</span>
<span class="lineNum">     682 </span><span class="lineCov">    2791346 : }</span>
<span class="lineNum">     683 </span>            : 
<span class="lineNum">     684 </span>            : /* Rewrites virtual defs and uses with def in LOOP into loop closed ssa
<span class="lineNum">     685 </span>            :    form.  */
<a name="686"><span class="lineNum">     686 </span>            : </a>
<span class="lineNum">     687 </span>            : void
<span class="lineNum">     688 </span><span class="lineCov">       1003 : rewrite_virtuals_into_loop_closed_ssa (struct loop *loop)</span>
<span class="lineNum">     689 </span>            : {
<span class="lineNum">     690 </span><span class="lineCov">       1003 :   rewrite_into_loop_closed_ssa_1 (NULL, 0, SSA_OP_VIRTUAL_USES, loop);</span>
<span class="lineNum">     691 </span><span class="lineCov">       1003 : }</span>
<span class="lineNum">     692 </span>            : 
<span class="lineNum">     693 </span>            : /* Check invariants of the loop closed ssa form for the def in DEF_BB.  */
<span class="lineNum">     694 </span>            : 
<span class="lineNum">     695 </span>            : static void
<span class="lineNum">     696 </span><span class="lineCov">   44721321 : check_loop_closed_ssa_def (basic_block def_bb, tree def)</span>
<span class="lineNum">     697 </span>            : {
<span class="lineNum">     698 </span><span class="lineCov">   44721321 :   use_operand_p use_p;</span>
<span class="lineNum">     699 </span><span class="lineCov">   44721321 :   imm_use_iterator iterator;</span>
<span class="lineNum">     700 </span><span class="lineCov">  128270871 :   FOR_EACH_IMM_USE_FAST (use_p, iterator, def)</span>
<span class="lineNum">     701 </span>            :     {
<span class="lineNum">     702 </span><span class="lineCov">  167099100 :       if (is_gimple_debug (USE_STMT (use_p)))</span>
<span class="lineNum">     703 </span>            :         continue;
<span class="lineNum">     704 </span>            : 
<span class="lineNum">     705 </span><span class="lineCov">   70694725 :       basic_block use_bb = gimple_bb (USE_STMT (use_p));</span>
<span class="lineNum">     706 </span><span class="lineCov">  141389450 :       if (is_a &lt;gphi *&gt; (USE_STMT (use_p)))</span>
<span class="lineNum">     707 </span><span class="lineCov">   15141361 :         use_bb = EDGE_PRED (use_bb, PHI_ARG_INDEX_FROM_USE (use_p))-&gt;src;</span>
<span class="lineNum">     708 </span>            : 
<span class="lineNum">     709 </span><span class="lineCov">   70694725 :       gcc_assert (flow_bb_inside_loop_p (def_bb-&gt;loop_father, use_bb));</span>
<span class="lineNum">     710 </span>            :     }
<span class="lineNum">     711 </span><span class="lineCov">   44721321 : }</span>
<span class="lineNum">     712 </span>            : 
<span class="lineNum">     713 </span>            : /* Checks invariants of loop closed ssa form in BB.  */
<a name="714"><span class="lineNum">     714 </span>            : </a>
<span class="lineNum">     715 </span>            : static void
<span class="lineNum">     716 </span><span class="lineCov">   15537469 : check_loop_closed_ssa_bb (basic_block bb)</span>
<span class="lineNum">     717 </span>            : {
<span class="lineNum">     718 </span><span class="lineCov">   42221545 :   for (gphi_iterator bsi = gsi_start_phis (bb); !gsi_end_p (bsi);</span>
<span class="lineNum">     719 </span><span class="lineCov">   13342038 :        gsi_next (&amp;bsi))</span>
<span class="lineNum">     720 </span>            :     {
<span class="lineNum">     721 </span><span class="lineCov">   13342038 :       gphi *phi = bsi.phi ();</span>
<span class="lineNum">     722 </span>            : 
<span class="lineNum">     723 </span><span class="lineCov">   53368152 :       if (!virtual_operand_p (PHI_RESULT (phi)))</span>
<span class="lineNum">     724 </span><span class="lineCov">   28483449 :         check_loop_closed_ssa_def (bb, PHI_RESULT (phi));</span>
<span class="lineNum">     725 </span>            :     }
<span class="lineNum">     726 </span>            : 
<span class="lineNum">     727 </span><span class="lineCov">  121093629 :   for (gimple_stmt_iterator bsi = gsi_start_nondebug_bb (bb); !gsi_end_p (bsi);</span>
<span class="lineNum">     728 </span><span class="lineCov">   52778080 :        gsi_next_nondebug (&amp;bsi))</span>
<span class="lineNum">     729 </span>            :     {
<span class="lineNum">     730 </span><span class="lineCov">   52778080 :       ssa_op_iter iter;</span>
<span class="lineNum">     731 </span><span class="lineCov">   52778080 :       tree var;</span>
<span class="lineNum">     732 </span><span class="lineCov">   52778080 :       gimple *stmt = gsi_stmt (bsi);</span>
<span class="lineNum">     733 </span>            : 
<span class="lineNum">     734 </span><span class="lineCov">   88004918 :       FOR_EACH_SSA_TREE_OPERAND (var, stmt, iter, SSA_OP_DEF)</span>
<span class="lineNum">     735 </span><span class="lineCov">   35226838 :         check_loop_closed_ssa_def (bb, var);</span>
<span class="lineNum">     736 </span>            :     }
<span class="lineNum">     737 </span><span class="lineCov">   15537469 : }</span>
<span class="lineNum">     738 </span>            : 
<span class="lineNum">     739 </span>            : /* Checks that invariants of the loop closed ssa form are preserved.
<span class="lineNum">     740 </span>            :    Call verify_ssa when VERIFY_SSA_P is true.  Note all loops are checked
<span class="lineNum">     741 </span>            :    if LOOP is NULL, otherwise, only LOOP is checked.  */
<span class="lineNum">     742 </span>            : 
<span class="lineNum">     743 </span>            : DEBUG_FUNCTION void
<span class="lineNum">     744 </span><span class="lineCov">    1325757 : verify_loop_closed_ssa (bool verify_ssa_p, struct loop *loop)</span>
<span class="lineNum">     745 </span>            : {
<span class="lineNum">     746 </span><span class="lineCov">    2651514 :   if (number_of_loops (cfun) &lt;= 1)</span>
<span class="lineNum">     747 </span>            :     return;
<span class="lineNum">     748 </span>            : 
<span class="lineNum">     749 </span><span class="lineCov">    1325757 :   if (verify_ssa_p)</span>
<span class="lineNum">     750 </span><span class="lineCov">      15410 :     verify_ssa (false, true);</span>
<span class="lineNum">     751 </span>            : 
<span class="lineNum">     752 </span><span class="lineCov">    1325757 :   timevar_push (TV_VERIFY_LOOP_CLOSED);</span>
<span class="lineNum">     753 </span>            : 
<span class="lineNum">     754 </span><span class="lineCov">    1325757 :   if (loop == NULL)</span>
<span class="lineNum">     755 </span>            :     {
<span class="lineNum">     756 </span><span class="lineCov">    1324833 :       basic_block bb;</span>
<span class="lineNum">     757 </span>            : 
<span class="lineNum">     758 </span><span class="lineCov">   38662381 :       FOR_EACH_BB_FN (bb, cfun)</span>
<span class="lineNum">     759 </span><span class="lineCov">   37337548 :         if (bb-&gt;loop_father &amp;&amp; bb-&gt;loop_father-&gt;num &gt; 0)</span>
<span class="lineNum">     760 </span><span class="lineCov">   15532372 :           check_loop_closed_ssa_bb (bb);</span>
<span class="lineNum">     761 </span>            :     }
<span class="lineNum">     762 </span>            :   else
<span class="lineNum">     763 </span>            :     {
<span class="lineNum">     764 </span><span class="lineCov">        924 :       basic_block *bbs = get_loop_body (loop);</span>
<span class="lineNum">     765 </span>            : 
<span class="lineNum">     766 </span><span class="lineCov">       6021 :       for (unsigned i = 0; i &lt; loop-&gt;num_nodes; ++i)</span>
<span class="lineNum">     767 </span><span class="lineCov">       5097 :         check_loop_closed_ssa_bb (bbs[i]);</span>
<span class="lineNum">     768 </span>            : 
<span class="lineNum">     769 </span><span class="lineCov">        924 :       free (bbs);</span>
<span class="lineNum">     770 </span>            :     }
<span class="lineNum">     771 </span>            : 
<span class="lineNum">     772 </span><span class="lineCov">    1325757 :   timevar_pop (TV_VERIFY_LOOP_CLOSED);</span>
<span class="lineNum">     773 </span>            : }
<span class="lineNum">     774 </span>            : 
<span class="lineNum">     775 </span>            : /* Split loop exit edge EXIT.  The things are a bit complicated by a need to
<span class="lineNum">     776 </span>            :    preserve the loop closed ssa form.  The newly created block is returned.  */
<a name="777"><span class="lineNum">     777 </span>            : </a>
<span class="lineNum">     778 </span>            : basic_block
<span class="lineNum">     779 </span><span class="lineCov">      25549 : split_loop_exit_edge (edge exit)</span>
<span class="lineNum">     780 </span>            : {
<span class="lineNum">     781 </span><span class="lineCov">      25549 :   basic_block dest = exit-&gt;dest;</span>
<span class="lineNum">     782 </span><span class="lineCov">      25549 :   basic_block bb = split_edge (exit);</span>
<span class="lineNum">     783 </span><span class="lineCov">      25549 :   gphi *phi, *new_phi;</span>
<span class="lineNum">     784 </span><span class="lineCov">      25549 :   tree new_name, name;</span>
<span class="lineNum">     785 </span><span class="lineCov">      25549 :   use_operand_p op_p;</span>
<span class="lineNum">     786 </span><span class="lineCov">      25549 :   gphi_iterator psi;</span>
<span class="lineNum">     787 </span><span class="lineCov">      25549 :   source_location locus;</span>
<span class="lineNum">     788 </span>            : 
<span class="lineNum">     789 </span><span class="lineCov">      58570 :   for (psi = gsi_start_phis (dest); !gsi_end_p (psi); gsi_next (&amp;psi))</span>
<span class="lineNum">     790 </span>            :     {
<span class="lineNum">     791 </span><span class="lineCov">      33021 :       phi = psi.phi ();</span>
<span class="lineNum">     792 </span><span class="lineCov">      33021 :       op_p = PHI_ARG_DEF_PTR_FROM_EDGE (phi, single_succ_edge (bb));</span>
<span class="lineNum">     793 </span><span class="lineCov">      33021 :       locus = gimple_phi_arg_location_from_edge (phi, single_succ_edge (bb));</span>
<span class="lineNum">     794 </span>            : 
<span class="lineNum">     795 </span><span class="lineCov">      33021 :       name = USE_FROM_PTR (op_p);</span>
<span class="lineNum">     796 </span>            : 
<span class="lineNum">     797 </span>            :       /* If the argument of the PHI node is a constant, we do not need
<span class="lineNum">     798 </span>            :          to keep it inside loop.  */
<span class="lineNum">     799 </span><span class="lineCov">      33021 :       if (TREE_CODE (name) != SSA_NAME)</span>
<span class="lineNum">     800 </span>            :         continue;
<span class="lineNum">     801 </span>            : 
<span class="lineNum">     802 </span>            :       /* Otherwise create an auxiliary phi node that will copy the value
<span class="lineNum">     803 </span>            :          of the SSA name out of the loop.  */
<span class="lineNum">     804 </span><span class="lineCov">      32055 :       new_name = duplicate_ssa_name (name, NULL);</span>
<span class="lineNum">     805 </span><span class="lineCov">      32055 :       new_phi = create_phi_node (new_name, bb);</span>
<span class="lineNum">     806 </span><span class="lineCov">      32055 :       add_phi_arg (new_phi, name, exit, locus);</span>
<span class="lineNum">     807 </span><span class="lineCov">      32055 :       SET_USE (op_p, new_name);</span>
<span class="lineNum">     808 </span>            :     }
<span class="lineNum">     809 </span>            : 
<span class="lineNum">     810 </span><span class="lineCov">      25549 :   return bb;</span>
<span class="lineNum">     811 </span>            : }
<span class="lineNum">     812 </span>            : 
<span class="lineNum">     813 </span>            : /* Returns the basic block in that statements should be emitted for induction
<span class="lineNum">     814 </span>            :    variables incremented at the end of the LOOP.  */
<a name="815"><span class="lineNum">     815 </span>            : </a>
<span class="lineNum">     816 </span>            : basic_block
<span class="lineNum">     817 </span><span class="lineCov">    7594098 : ip_end_pos (struct loop *loop)</span>
<span class="lineNum">     818 </span>            : {
<span class="lineNum">     819 </span><span class="lineCov">    7594098 :   return loop-&gt;latch;</span>
<span class="lineNum">     820 </span>            : }
<span class="lineNum">     821 </span>            : 
<span class="lineNum">     822 </span>            : /* Returns the basic block in that statements should be emitted for induction
<span class="lineNum">     823 </span>            :    variables incremented just before exit condition of a LOOP.  */
<span class="lineNum">     824 </span>            : 
<span class="lineNum">     825 </span>            : basic_block
<span class="lineNum">     826 </span><span class="lineCov">   24460933 : ip_normal_pos (struct loop *loop)</span>
<span class="lineNum">     827 </span>            : {
<span class="lineNum">     828 </span><span class="lineCov">   24460933 :   gimple *last;</span>
<span class="lineNum">     829 </span><span class="lineCov">   24460933 :   basic_block bb;</span>
<span class="lineNum">     830 </span><span class="lineCov">   24460933 :   edge exit;</span>
<span class="lineNum">     831 </span>            : 
<span class="lineNum">     832 </span><span class="lineCov">   24460933 :   if (!single_pred_p (loop-&gt;latch))</span>
<span class="lineNum">     833 </span>            :     return NULL;
<span class="lineNum">     834 </span>            : 
<span class="lineNum">     835 </span><span class="lineCov">   24295483 :   bb = single_pred (loop-&gt;latch);</span>
<span class="lineNum">     836 </span><span class="lineCov">   24295483 :   last = last_stmt (bb);</span>
<span class="lineNum">     837 </span><span class="lineCov">   24295483 :   if (!last</span>
<span class="lineNum">     838 </span><span class="lineCov">   24295483 :       || gimple_code (last) != GIMPLE_COND)</span>
<span class="lineNum">     839 </span>            :     return NULL;
<span class="lineNum">     840 </span>            : 
<span class="lineNum">     841 </span><span class="lineCov">   48567670 :   exit = EDGE_SUCC (bb, 0);</span>
<span class="lineNum">     842 </span><span class="lineCov">   24283835 :   if (exit-&gt;dest == loop-&gt;latch)</span>
<span class="lineNum">     843 </span><span class="lineCov">   15672976 :     exit = EDGE_SUCC (bb, 1);</span>
<span class="lineNum">     844 </span>            : 
<span class="lineNum">     845 </span><span class="lineCov">   24283835 :   if (flow_bb_inside_loop_p (loop, exit-&gt;dest))</span>
<span class="lineNum">     846 </span><span class="lineCov">      19766 :     return NULL;</span>
<span class="lineNum">     847 </span>            : 
<span class="lineNum">     848 </span>            :   return bb;
<span class="lineNum">     849 </span>            : }
<span class="lineNum">     850 </span>            : 
<span class="lineNum">     851 </span>            : /* Stores the standard position for induction variable increment in LOOP
<span class="lineNum">     852 </span>            :    (just before the exit condition if it is available and latch block is empty,
<span class="lineNum">     853 </span>            :    end of the latch block otherwise) to BSI.  INSERT_AFTER is set to true if
<span class="lineNum">     854 </span>            :    the increment should be inserted after *BSI.  */
<a name="855"><span class="lineNum">     855 </span>            : </a>
<span class="lineNum">     856 </span>            : void
<span class="lineNum">     857 </span><span class="lineCov">      55389 : standard_iv_increment_position (struct loop *loop, gimple_stmt_iterator *bsi,</span>
<span class="lineNum">     858 </span>            :                                 bool *insert_after)
<span class="lineNum">     859 </span>            : {
<span class="lineNum">     860 </span><span class="lineCov">      55389 :   basic_block bb = ip_normal_pos (loop), latch = ip_end_pos (loop);</span>
<span class="lineNum">     861 </span><span class="lineCov">      55389 :   gimple *last = last_stmt (latch);</span>
<span class="lineNum">     862 </span>            : 
<span class="lineNum">     863 </span><span class="lineCov">      55389 :   if (!bb</span>
<span class="lineNum">     864 </span><span class="lineCov">      55389 :       || (last &amp;&amp; gimple_code (last) != GIMPLE_LABEL))</span>
<span class="lineNum">     865 </span>            :     {
<span class="lineNum">     866 </span><span class="lineNoCov">          0 :       *bsi = gsi_last_bb (latch);</span>
<span class="lineNum">     867 </span><span class="lineNoCov">          0 :       *insert_after = true;</span>
<span class="lineNum">     868 </span>            :     }
<span class="lineNum">     869 </span>            :   else
<span class="lineNum">     870 </span>            :     {
<span class="lineNum">     871 </span><span class="lineCov">      55389 :       *bsi = gsi_last_bb (bb);</span>
<span class="lineNum">     872 </span><span class="lineCov">      55389 :       *insert_after = false;</span>
<span class="lineNum">     873 </span>            :     }
<span class="lineNum">     874 </span><span class="lineCov">      55389 : }</span>
<span class="lineNum">     875 </span>            : 
<span class="lineNum">     876 </span>            : /* Copies phi node arguments for duplicated blocks.  The index of the first
<span class="lineNum">     877 </span>            :    duplicated block is FIRST_NEW_BLOCK.  */
<span class="lineNum">     878 </span>            : 
<span class="lineNum">     879 </span>            : static void
<span class="lineNum">     880 </span><span class="lineCov">      70577 : copy_phi_node_args (unsigned first_new_block)</span>
<span class="lineNum">     881 </span>            : {
<span class="lineNum">     882 </span><span class="lineCov">      70577 :   unsigned i;</span>
<span class="lineNum">     883 </span>            : 
<span class="lineNum">     884 </span><span class="lineCov">     625780 :   for (i = first_new_block; i &lt; (unsigned) last_basic_block_for_fn (cfun); i++)</span>
<span class="lineNum">     885 </span><span class="lineCov">     555203 :     BASIC_BLOCK_FOR_FN (cfun, i)-&gt;flags |= BB_DUPLICATED;</span>
<span class="lineNum">     886 </span>            : 
<span class="lineNum">     887 </span><span class="lineCov">     625780 :   for (i = first_new_block; i &lt; (unsigned) last_basic_block_for_fn (cfun); i++)</span>
<span class="lineNum">     888 </span><span class="lineCov">     555203 :     add_phi_args_after_copy_bb (BASIC_BLOCK_FOR_FN (cfun, i));</span>
<span class="lineNum">     889 </span>            : 
<span class="lineNum">     890 </span><span class="lineCov">     625780 :   for (i = first_new_block; i &lt; (unsigned) last_basic_block_for_fn (cfun); i++)</span>
<span class="lineNum">     891 </span><span class="lineCov">     555203 :     BASIC_BLOCK_FOR_FN (cfun, i)-&gt;flags &amp;= ~BB_DUPLICATED;</span>
<span class="lineNum">     892 </span><span class="lineCov">      70577 : }</span>
<span class="lineNum">     893 </span>            : 
<span class="lineNum">     894 </span>            : 
<span class="lineNum">     895 </span>            : /* The same as cfgloopmanip.c:duplicate_loop_to_header_edge, but also
<span class="lineNum">     896 </span>            :    updates the PHI nodes at start of the copied region.  In order to
<span class="lineNum">     897 </span>            :    achieve this, only loops whose exits all lead to the same location
<span class="lineNum">     898 </span>            :    are handled.
<span class="lineNum">     899 </span>            : 
<span class="lineNum">     900 </span>            :    Notice that we do not completely update the SSA web after
<span class="lineNum">     901 </span>            :    duplication.  The caller is responsible for calling update_ssa
<span class="lineNum">     902 </span>            :    after the loop has been duplicated.  */
<a name="903"><span class="lineNum">     903 </span>            : </a>
<span class="lineNum">     904 </span>            : bool
<span class="lineNum">     905 </span><span class="lineCov">      70586 : gimple_duplicate_loop_to_header_edge (struct loop *loop, edge e,</span>
<span class="lineNum">     906 </span>            :                                     unsigned int ndupl, sbitmap wont_exit,
<span class="lineNum">     907 </span>            :                                     edge orig, vec&lt;edge&gt; *to_remove,
<span class="lineNum">     908 </span>            :                                     int flags)
<span class="lineNum">     909 </span>            : {
<span class="lineNum">     910 </span><span class="lineCov">      70586 :   unsigned first_new_block;</span>
<span class="lineNum">     911 </span>            : 
<span class="lineNum">     912 </span><span class="lineCov">     141172 :   if (!loops_state_satisfies_p (LOOPS_HAVE_SIMPLE_LATCHES))</span>
<span class="lineNum">     913 </span>            :     return false;
<span class="lineNum">     914 </span><span class="lineCov">     141172 :   if (!loops_state_satisfies_p (LOOPS_HAVE_PREHEADERS))</span>
<span class="lineNum">     915 </span>            :     return false;
<span class="lineNum">     916 </span>            : 
<span class="lineNum">     917 </span><span class="lineCov">      70586 :   first_new_block = last_basic_block_for_fn (cfun);</span>
<span class="lineNum">     918 </span><span class="lineCov">      70586 :   if (!duplicate_loop_to_header_edge (loop, e, ndupl, wont_exit,</span>
<span class="lineNum">     919 </span>            :                                       orig, to_remove, flags))
<span class="lineNum">     920 </span>            :     return false;
<span class="lineNum">     921 </span>            : 
<span class="lineNum">     922 </span>            :   /* Readd the removed phi args for e.  */
<span class="lineNum">     923 </span><span class="lineCov">      70577 :   flush_pending_stmts (e);</span>
<span class="lineNum">     924 </span>            : 
<span class="lineNum">     925 </span>            :   /* Copy the phi node arguments.  */
<span class="lineNum">     926 </span><span class="lineCov">      70577 :   copy_phi_node_args (first_new_block);</span>
<span class="lineNum">     927 </span>            : 
<span class="lineNum">     928 </span><span class="lineCov">      70577 :   scev_reset ();</span>
<span class="lineNum">     929 </span>            : 
<span class="lineNum">     930 </span><span class="lineCov">      70577 :   return true;</span>
<span class="lineNum">     931 </span>            : }
<span class="lineNum">     932 </span>            : 
<span class="lineNum">     933 </span>            : /* Returns true if we can unroll LOOP FACTOR times.  Number
<span class="lineNum">     934 </span>            :    of iterations of the loop is returned in NITER.  */
<a name="935"><span class="lineNum">     935 </span>            : </a>
<span class="lineNum">     936 </span>            : bool
<span class="lineNum">     937 </span><span class="lineCov">        495 : can_unroll_loop_p (struct loop *loop, unsigned factor,</span>
<span class="lineNum">     938 </span>            :                    struct tree_niter_desc *niter)
<span class="lineNum">     939 </span>            : {
<span class="lineNum">     940 </span><span class="lineCov">        495 :   edge exit;</span>
<span class="lineNum">     941 </span>            : 
<span class="lineNum">     942 </span>            :   /* Check whether unrolling is possible.  We only want to unroll loops
<span class="lineNum">     943 </span>            :      for that we are able to determine number of iterations.  We also
<span class="lineNum">     944 </span>            :      want to split the extra iterations of the loop from its end,
<span class="lineNum">     945 </span>            :      therefore we require that the loop has precisely one
<span class="lineNum">     946 </span>            :      exit.  */
<span class="lineNum">     947 </span>            : 
<span class="lineNum">     948 </span><span class="lineCov">        495 :   exit = single_dom_exit (loop);</span>
<span class="lineNum">     949 </span><span class="lineCov">        495 :   if (!exit)</span>
<span class="lineNum">     950 </span>            :     return false;
<span class="lineNum">     951 </span>            : 
<span class="lineNum">     952 </span><span class="lineCov">        477 :   if (!number_of_iterations_exit (loop, exit, niter, false)</span>
<span class="lineNum">     953 </span><span class="lineCov">        476 :       || niter-&gt;cmp == ERROR_MARK</span>
<span class="lineNum">     954 </span>            :       /* Scalar evolutions analysis might have copy propagated
<span class="lineNum">     955 </span>            :          the abnormal ssa names into these expressions, hence
<span class="lineNum">     956 </span>            :          emitting the computations based on them during loop
<span class="lineNum">     957 </span>            :          unrolling might create overlapping life ranges for
<span class="lineNum">     958 </span>            :          them, and failures in out-of-ssa.  */
<span class="lineNum">     959 </span><span class="lineCov">        474 :       || contains_abnormal_ssa_name_p (niter-&gt;may_be_zero)</span>
<span class="lineNum">     960 </span><span class="lineCov">        474 :       || contains_abnormal_ssa_name_p (niter-&gt;control.base)</span>
<span class="lineNum">     961 </span><span class="lineCov">        474 :       || contains_abnormal_ssa_name_p (niter-&gt;control.step)</span>
<span class="lineNum">     962 </span><span class="lineCov">        951 :       || contains_abnormal_ssa_name_p (niter-&gt;bound))</span>
<span class="lineNum">     963 </span><span class="lineCov">          3 :     return false;</span>
<span class="lineNum">     964 </span>            : 
<span class="lineNum">     965 </span>            :   /* And of course, we must be able to duplicate the loop.  */
<span class="lineNum">     966 </span><span class="lineCov">        474 :   if (!can_duplicate_loop_p (loop))</span>
<span class="lineNum">     967 </span>            :     return false;
<span class="lineNum">     968 </span>            : 
<span class="lineNum">     969 </span>            :   /* The final loop should be small enough.  */
<span class="lineNum">     970 </span><span class="lineCov">        474 :   if (tree_num_loop_insns (loop, &amp;eni_size_weights) * factor</span>
<span class="lineNum">     971 </span><span class="lineCov">        474 :       &gt; (unsigned) PARAM_VALUE (PARAM_MAX_UNROLLED_INSNS))</span>
<span class="lineNum">     972 </span><span class="lineCov">          7 :     return false;</span>
<span class="lineNum">     973 </span>            : 
<span class="lineNum">     974 </span>            :   return true;
<span class="lineNum">     975 </span>            : }
<span class="lineNum">     976 </span>            : 
<span class="lineNum">     977 </span>            : /* Determines the conditions that control execution of LOOP unrolled FACTOR
<span class="lineNum">     978 </span>            :    times.  DESC is number of iterations of LOOP.  ENTER_COND is set to
<span class="lineNum">     979 </span>            :    condition that must be true if the main loop can be entered.
<span class="lineNum">     980 </span>            :    EXIT_BASE, EXIT_STEP, EXIT_CMP and EXIT_BOUND are set to values describing
<span class="lineNum">     981 </span>            :    how the exit from the unrolled loop should be controlled.  */
<a name="982"><span class="lineNum">     982 </span>            : </a>
<span class="lineNum">     983 </span>            : static void
<span class="lineNum">     984 </span><span class="lineCov">        462 : determine_exit_conditions (struct loop *loop, struct tree_niter_desc *desc,</span>
<span class="lineNum">     985 </span>            :                            unsigned factor, tree *enter_cond,
<span class="lineNum">     986 </span>            :                            tree *exit_base, tree *exit_step,
<span class="lineNum">     987 </span>            :                            enum tree_code *exit_cmp, tree *exit_bound)
<span class="lineNum">     988 </span>            : {
<span class="lineNum">     989 </span><span class="lineCov">        462 :   gimple_seq stmts;</span>
<span class="lineNum">     990 </span><span class="lineCov">        462 :   tree base = desc-&gt;control.base;</span>
<span class="lineNum">     991 </span><span class="lineCov">        462 :   tree step = desc-&gt;control.step;</span>
<span class="lineNum">     992 </span><span class="lineCov">        462 :   tree bound = desc-&gt;bound;</span>
<span class="lineNum">     993 </span><span class="lineCov">        462 :   tree type = TREE_TYPE (step);</span>
<span class="lineNum">     994 </span><span class="lineCov">        462 :   tree bigstep, delta;</span>
<span class="lineNum">     995 </span><span class="lineCov">        462 :   tree min = lower_bound_in_type (type, type);</span>
<span class="lineNum">     996 </span><span class="lineCov">        462 :   tree max = upper_bound_in_type (type, type);</span>
<span class="lineNum">     997 </span><span class="lineCov">        462 :   enum tree_code cmp = desc-&gt;cmp;</span>
<span class="lineNum">     998 </span><span class="lineCov">        462 :   tree cond = boolean_true_node, assum;</span>
<span class="lineNum">     999 </span>            : 
<span class="lineNum">    1000 </span>            :   /* For pointers, do the arithmetics in the type of step.  */
<span class="lineNum">    1001 </span><span class="lineCov">        462 :   base = fold_convert (type, base);</span>
<span class="lineNum">    1002 </span><span class="lineCov">        462 :   bound = fold_convert (type, bound);</span>
<span class="lineNum">    1003 </span>            : 
<span class="lineNum">    1004 </span><span class="lineCov">        462 :   *enter_cond = boolean_false_node;</span>
<span class="lineNum">    1005 </span><span class="lineCov">        462 :   *exit_base = NULL_TREE;</span>
<span class="lineNum">    1006 </span><span class="lineCov">        462 :   *exit_step = NULL_TREE;</span>
<span class="lineNum">    1007 </span><span class="lineCov">        462 :   *exit_cmp = ERROR_MARK;</span>
<span class="lineNum">    1008 </span><span class="lineCov">        462 :   *exit_bound = NULL_TREE;</span>
<span class="lineNum">    1009 </span><span class="lineCov">        462 :   gcc_assert (cmp != ERROR_MARK);</span>
<span class="lineNum">    1010 </span>            : 
<span class="lineNum">    1011 </span>            :   /* We only need to be correct when we answer question
<span class="lineNum">    1012 </span>            :      &quot;Do at least FACTOR more iterations remain?&quot; in the unrolled loop.
<span class="lineNum">    1013 </span>            :      Thus, transforming BASE + STEP * i &lt;&gt; BOUND to
<span class="lineNum">    1014 </span>            :      BASE + STEP * i &lt; BOUND is ok.  */
<span class="lineNum">    1015 </span><span class="lineCov">        462 :   if (cmp == NE_EXPR)</span>
<span class="lineNum">    1016 </span>            :     {
<span class="lineNum">    1017 </span><span class="lineCov">         77 :       if (tree_int_cst_sign_bit (step))</span>
<span class="lineNum">    1018 </span>            :         cmp = GT_EXPR;
<span class="lineNum">    1019 </span>            :       else
<span class="lineNum">    1020 </span><span class="lineCov">         22 :         cmp = LT_EXPR;</span>
<span class="lineNum">    1021 </span>            :     }
<span class="lineNum">    1022 </span><span class="lineCov">        385 :   else if (cmp == LT_EXPR)</span>
<span class="lineNum">    1023 </span>            :     {
<span class="lineNum">    1024 </span><span class="lineCov">        385 :       gcc_assert (!tree_int_cst_sign_bit (step));</span>
<span class="lineNum">    1025 </span>            :     }
<span class="lineNum">    1026 </span><span class="lineNoCov">          0 :   else if (cmp == GT_EXPR)</span>
<span class="lineNum">    1027 </span>            :     {
<span class="lineNum">    1028 </span><span class="lineNoCov">          0 :       gcc_assert (tree_int_cst_sign_bit (step));</span>
<span class="lineNum">    1029 </span>            :     }
<span class="lineNum">    1030 </span>            :   else
<span class="lineNum">    1031 </span><span class="lineNoCov">          0 :     gcc_unreachable ();</span>
<span class="lineNum">    1032 </span>            : 
<span class="lineNum">    1033 </span>            :   /* The main body of the loop may be entered iff:
<span class="lineNum">    1034 </span>            : 
<span class="lineNum">    1035 </span>            :      1) desc-&gt;may_be_zero is false.
<span class="lineNum">    1036 </span>            :      2) it is possible to check that there are at least FACTOR iterations
<span class="lineNum">    1037 </span>            :         of the loop, i.e., BOUND - step * FACTOR does not overflow.
<span class="lineNum">    1038 </span>            :      3) # of iterations is at least FACTOR  */
<span class="lineNum">    1039 </span>            : 
<span class="lineNum">    1040 </span><span class="lineCov">        462 :   if (!integer_zerop (desc-&gt;may_be_zero))</span>
<span class="lineNum">    1041 </span><span class="lineCov">          6 :     cond = fold_build2 (TRUTH_AND_EXPR, boolean_type_node,</span>
<span class="lineNum">    1042 </span>            :                         invert_truthvalue (desc-&gt;may_be_zero),
<span class="lineNum">    1043 </span>            :                         cond);
<span class="lineNum">    1044 </span>            : 
<span class="lineNum">    1045 </span><span class="lineCov">        924 :   bigstep = fold_build2 (MULT_EXPR, type, step,</span>
<span class="lineNum">    1046 </span>            :                          build_int_cst_type (type, factor));
<span class="lineNum">    1047 </span><span class="lineCov">        462 :   delta = fold_build2 (MINUS_EXPR, type, bigstep, step);</span>
<span class="lineNum">    1048 </span><span class="lineCov">        462 :   if (cmp == LT_EXPR)</span>
<span class="lineNum">    1049 </span><span class="lineCov">        407 :     assum = fold_build2 (GE_EXPR, boolean_type_node,</span>
<span class="lineNum">    1050 </span>            :                          bound,
<span class="lineNum">    1051 </span>            :                          fold_build2 (PLUS_EXPR, type, min, delta));
<span class="lineNum">    1052 </span>            :   else
<span class="lineNum">    1053 </span><span class="lineCov">         55 :     assum = fold_build2 (LE_EXPR, boolean_type_node,</span>
<span class="lineNum">    1054 </span>            :                          bound,
<span class="lineNum">    1055 </span>            :                          fold_build2 (PLUS_EXPR, type, max, delta));
<span class="lineNum">    1056 </span><span class="lineCov">        462 :   cond = fold_build2 (TRUTH_AND_EXPR, boolean_type_node, assum, cond);</span>
<span class="lineNum">    1057 </span>            : 
<span class="lineNum">    1058 </span><span class="lineCov">        462 :   bound = fold_build2 (MINUS_EXPR, type, bound, delta);</span>
<span class="lineNum">    1059 </span><span class="lineCov">        462 :   assum = fold_build2 (cmp, boolean_type_node, base, bound);</span>
<span class="lineNum">    1060 </span><span class="lineCov">        462 :   cond = fold_build2 (TRUTH_AND_EXPR, boolean_type_node, assum, cond);</span>
<span class="lineNum">    1061 </span>            : 
<span class="lineNum">    1062 </span><span class="lineCov">        462 :   cond = force_gimple_operand (unshare_expr (cond), &amp;stmts, false, NULL_TREE);</span>
<span class="lineNum">    1063 </span><span class="lineCov">        462 :   if (stmts)</span>
<span class="lineNum">    1064 </span><span class="lineCov">         18 :     gsi_insert_seq_on_edge_immediate (loop_preheader_edge (loop), stmts);</span>
<span class="lineNum">    1065 </span>            :   /* cond now may be a gimple comparison, which would be OK, but also any
<span class="lineNum">    1066 </span>            :      other gimple rhs (say a &amp;&amp; b).  In this case we need to force it to
<span class="lineNum">    1067 </span>            :      operand.  */
<span class="lineNum">    1068 </span><span class="lineCov">        462 :   if (!is_gimple_condexpr (cond))</span>
<span class="lineNum">    1069 </span>            :     {
<span class="lineNum">    1070 </span><span class="lineCov">         14 :       cond = force_gimple_operand (cond, &amp;stmts, true, NULL_TREE);</span>
<span class="lineNum">    1071 </span><span class="lineCov">         14 :       if (stmts)</span>
<span class="lineNum">    1072 </span><span class="lineCov">         14 :         gsi_insert_seq_on_edge_immediate (loop_preheader_edge (loop), stmts);</span>
<span class="lineNum">    1073 </span>            :     }
<span class="lineNum">    1074 </span><span class="lineCov">        462 :   *enter_cond = cond;</span>
<span class="lineNum">    1075 </span>            : 
<span class="lineNum">    1076 </span><span class="lineCov">        462 :   base = force_gimple_operand (unshare_expr (base), &amp;stmts, true, NULL_TREE);</span>
<span class="lineNum">    1077 </span><span class="lineCov">        462 :   if (stmts)</span>
<span class="lineNum">    1078 </span><span class="lineCov">         15 :     gsi_insert_seq_on_edge_immediate (loop_preheader_edge (loop), stmts);</span>
<span class="lineNum">    1079 </span><span class="lineCov">        462 :   bound = force_gimple_operand (unshare_expr (bound), &amp;stmts, true, NULL_TREE);</span>
<span class="lineNum">    1080 </span><span class="lineCov">        462 :   if (stmts)</span>
<span class="lineNum">    1081 </span><span class="lineCov">        371 :     gsi_insert_seq_on_edge_immediate (loop_preheader_edge (loop), stmts);</span>
<span class="lineNum">    1082 </span>            : 
<span class="lineNum">    1083 </span><span class="lineCov">        462 :   *exit_base = base;</span>
<span class="lineNum">    1084 </span><span class="lineCov">        462 :   *exit_step = bigstep;</span>
<span class="lineNum">    1085 </span><span class="lineCov">        462 :   *exit_cmp = cmp;</span>
<span class="lineNum">    1086 </span><span class="lineCov">        462 :   *exit_bound = bound;</span>
<span class="lineNum">    1087 </span><span class="lineCov">        462 : }</span>
<span class="lineNum">    1088 </span>            : 
<span class="lineNum">    1089 </span>            : /* Scales the frequencies of all basic blocks in LOOP that are strictly
<span class="lineNum">    1090 </span>            :    dominated by BB by NUM/DEN.  */
<a name="1091"><span class="lineNum">    1091 </span>            : </a>
<span class="lineNum">    1092 </span>            : static void
<span class="lineNum">    1093 </span><span class="lineCov">       1400 : scale_dominated_blocks_in_loop (struct loop *loop, basic_block bb,</span>
<span class="lineNum">    1094 </span>            :                                 profile_count num, profile_count den)
<span class="lineNum">    1095 </span>            : {
<span class="lineNum">    1096 </span><span class="lineCov">       1400 :   basic_block son;</span>
<span class="lineNum">    1097 </span>            : 
<span class="lineNum">    1098 </span><span class="lineCov">       2800 :   if (!den.nonzero_p () &amp;&amp; !(num == profile_count::zero ()))</span>
<span class="lineNum">    1099 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">    1100 </span>            : 
<span class="lineNum">    1101 </span><span class="lineCov">       1400 :   for (son = first_dom_son (CDI_DOMINATORS, bb);</span>
<span class="lineNum">    1102 </span><span class="lineCov">       2338 :        son;</span>
<span class="lineNum">    1103 </span><span class="lineCov">        938 :        son = next_dom_son (CDI_DOMINATORS, son))</span>
<span class="lineNum">    1104 </span>            :     {
<span class="lineNum">    1105 </span><span class="lineCov">        938 :       if (!flow_bb_inside_loop_p (loop, son))</span>
<span class="lineNum">    1106 </span>            :         continue;
<span class="lineNum">    1107 </span><span class="lineCov">        938 :       scale_bbs_frequencies_profile_count (&amp;son, 1, num, den);</span>
<span class="lineNum">    1108 </span><span class="lineCov">        938 :       scale_dominated_blocks_in_loop (loop, son, num, den);</span>
<span class="lineNum">    1109 </span>            :     }
<span class="lineNum">    1110 </span>            : }
<span class="lineNum">    1111 </span>            : 
<span class="lineNum">    1112 </span>            : /* Return estimated niter for LOOP after unrolling by FACTOR times.  */
<a name="1113"><span class="lineNum">    1113 </span>            : </a>
<span class="lineNum">    1114 </span>            : gcov_type
<span class="lineNum">    1115 </span><span class="lineCov">      16261 : niter_for_unrolled_loop (struct loop *loop, unsigned factor)</span>
<span class="lineNum">    1116 </span>            : {
<span class="lineNum">    1117 </span><span class="lineCov">      16261 :   gcc_assert (factor != 0);</span>
<span class="lineNum">    1118 </span><span class="lineCov">      16261 :   bool profile_p = false;</span>
<span class="lineNum">    1119 </span><span class="lineCov">      16261 :   gcov_type est_niter = expected_loop_iterations_unbounded (loop, &amp;profile_p);</span>
<span class="lineNum">    1120 </span>            :   /* Note that this is really CEIL (est_niter + 1, factor) - 1, where the
<span class="lineNum">    1121 </span>            :      &quot;+ 1&quot; converts latch iterations to loop iterations and the &quot;- 1&quot;
<span class="lineNum">    1122 </span>            :      converts back.  */
<span class="lineNum">    1123 </span><span class="lineCov">      16261 :   gcov_type new_est_niter = est_niter / factor;</span>
<span class="lineNum">    1124 </span>            : 
<span class="lineNum">    1125 </span><span class="lineCov">      16261 :   if (est_niter == -1)</span>
<span class="lineNum">    1126 </span>            :     return -1;
<span class="lineNum">    1127 </span>            : 
<span class="lineNum">    1128 </span>            :   /* Without profile feedback, loops for which we do not know a better estimate
<span class="lineNum">    1129 </span>            :      are assumed to roll 10 times.  When we unroll such loop, it appears to
<span class="lineNum">    1130 </span>            :      roll too little, and it may even seem to be cold.  To avoid this, we
<span class="lineNum">    1131 </span>            :      ensure that the created loop appears to roll at least 5 times (but at
<span class="lineNum">    1132 </span>            :      most as many times as before unrolling).  Don't do adjustment if profile
<span class="lineNum">    1133 </span>            :      feedback is present.  */
<span class="lineNum">    1134 </span><span class="lineCov">      16261 :   if (new_est_niter &lt; 5 &amp;&amp; !profile_p)</span>
<span class="lineNum">    1135 </span>            :     {
<span class="lineNum">    1136 </span><span class="lineCov">      12390 :       if (est_niter &lt; 5)</span>
<span class="lineNum">    1137 </span><span class="lineCov">       1664 :         new_est_niter = est_niter;</span>
<span class="lineNum">    1138 </span>            :       else
<span class="lineNum">    1139 </span><span class="lineCov">      10726 :         new_est_niter = 5;</span>
<span class="lineNum">    1140 </span>            :     }
<span class="lineNum">    1141 </span>            : 
<span class="lineNum">    1142 </span><span class="lineCov">      16261 :   if (loop-&gt;any_upper_bound)</span>
<span class="lineNum">    1143 </span>            :     {
<span class="lineNum">    1144 </span>            :       /* As above, this is really CEIL (upper_bound + 1, factor) - 1.  */
<span class="lineNum">    1145 </span><span class="lineCov">      16261 :       widest_int bound = wi::udiv_floor (loop-&gt;nb_iterations_upper_bound,</span>
<span class="lineNum">    1146 </span><span class="lineCov">      16261 :                                          factor);</span>
<span class="lineNum">    1147 </span><span class="lineCov">      16261 :       if (wi::ltu_p (bound, new_est_niter))</span>
<span class="lineNum">    1148 </span><span class="lineCov">       8868 :         new_est_niter = bound.to_uhwi ();</span>
<span class="lineNum">    1149 </span>            :     }
<span class="lineNum">    1150 </span>            : 
<span class="lineNum">    1151 </span><span class="lineCov">      16261 :   return new_est_niter;</span>
<span class="lineNum">    1152 </span>            : }
<span class="lineNum">    1153 </span>            : 
<span class="lineNum">    1154 </span>            : /* Unroll LOOP FACTOR times.  DESC describes number of iterations of LOOP.
<span class="lineNum">    1155 </span>            :    EXIT is the exit of the loop to that DESC corresponds.
<span class="lineNum">    1156 </span>            : 
<span class="lineNum">    1157 </span>            :    If N is number of iterations of the loop and MAY_BE_ZERO is the condition
<span class="lineNum">    1158 </span>            :    under that loop exits in the first iteration even if N != 0,
<span class="lineNum">    1159 </span>            : 
<span class="lineNum">    1160 </span>            :    while (1)
<span class="lineNum">    1161 </span>            :      {
<span class="lineNum">    1162 </span>            :        x = phi (init, next);
<span class="lineNum">    1163 </span>            : 
<span class="lineNum">    1164 </span>            :        pre;
<span class="lineNum">    1165 </span>            :        if (st)
<span class="lineNum">    1166 </span>            :          break;
<span class="lineNum">    1167 </span>            :        post;
<span class="lineNum">    1168 </span>            :      }
<span class="lineNum">    1169 </span>            : 
<span class="lineNum">    1170 </span>            :    becomes (with possibly the exit conditions formulated a bit differently,
<span class="lineNum">    1171 </span>            :    avoiding the need to create a new iv):
<span class="lineNum">    1172 </span>            : 
<span class="lineNum">    1173 </span>            :    if (MAY_BE_ZERO || N &lt; FACTOR)
<span class="lineNum">    1174 </span>            :      goto rest;
<span class="lineNum">    1175 </span>            : 
<span class="lineNum">    1176 </span>            :    do
<span class="lineNum">    1177 </span>            :      {
<span class="lineNum">    1178 </span>            :        x = phi (init, next);
<span class="lineNum">    1179 </span>            : 
<span class="lineNum">    1180 </span>            :        pre;
<span class="lineNum">    1181 </span>            :        post;
<span class="lineNum">    1182 </span>            :        pre;
<span class="lineNum">    1183 </span>            :        post;
<span class="lineNum">    1184 </span>            :        ...
<span class="lineNum">    1185 </span>            :        pre;
<span class="lineNum">    1186 </span>            :        post;
<span class="lineNum">    1187 </span>            :        N -= FACTOR;
<span class="lineNum">    1188 </span>            : 
<span class="lineNum">    1189 </span>            :      } while (N &gt;= FACTOR);
<span class="lineNum">    1190 </span>            : 
<span class="lineNum">    1191 </span>            :    rest:
<span class="lineNum">    1192 </span>            :      init' = phi (init, x);
<span class="lineNum">    1193 </span>            : 
<span class="lineNum">    1194 </span>            :    while (1)
<span class="lineNum">    1195 </span>            :      {
<span class="lineNum">    1196 </span>            :        x = phi (init', next);
<span class="lineNum">    1197 </span>            : 
<span class="lineNum">    1198 </span>            :        pre;
<span class="lineNum">    1199 </span>            :        if (st)
<span class="lineNum">    1200 </span>            :          break;
<span class="lineNum">    1201 </span>            :        post;
<span class="lineNum">    1202 </span>            :      }
<span class="lineNum">    1203 </span>            : 
<span class="lineNum">    1204 </span>            :    Before the loop is unrolled, TRANSFORM is called for it (only for the
<span class="lineNum">    1205 </span>            :    unrolled loop, but not for its versioned copy).  DATA is passed to
<span class="lineNum">    1206 </span>            :    TRANSFORM.  */
<span class="lineNum">    1207 </span>            : 
<span class="lineNum">    1208 </span>            : /* Probability in % that the unrolled loop is entered.  Just a guess.  */
<span class="lineNum">    1209 </span>            : #define PROB_UNROLLED_LOOP_ENTERED 90
<span class="lineNum">    1210 </span>            : 
<span class="lineNum">    1211 </span>            : void
<span class="lineNum">    1212 </span><span class="lineCov">        462 : tree_transform_and_unroll_loop (struct loop *loop, unsigned factor,</span>
<span class="lineNum">    1213 </span>            :                                 edge exit, struct tree_niter_desc *desc,
<span class="lineNum">    1214 </span>            :                                 transform_callback transform,
<span class="lineNum">    1215 </span>            :                                 void *data)
<span class="lineNum">    1216 </span>            : {
<span class="lineNum">    1217 </span><span class="lineCov">        462 :   gcond *exit_if;</span>
<span class="lineNum">    1218 </span><span class="lineCov">        462 :   tree ctr_before, ctr_after;</span>
<span class="lineNum">    1219 </span><span class="lineCov">        462 :   tree enter_main_cond, exit_base, exit_step, exit_bound;</span>
<span class="lineNum">    1220 </span><span class="lineCov">        462 :   enum tree_code exit_cmp;</span>
<span class="lineNum">    1221 </span><span class="lineCov">        462 :   gphi *phi_old_loop, *phi_new_loop, *phi_rest;</span>
<span class="lineNum">    1222 </span><span class="lineCov">        462 :   gphi_iterator psi_old_loop, psi_new_loop;</span>
<span class="lineNum">    1223 </span><span class="lineCov">        462 :   tree init, next, new_init;</span>
<span class="lineNum">    1224 </span><span class="lineCov">        462 :   struct loop *new_loop;</span>
<span class="lineNum">    1225 </span><span class="lineCov">        462 :   basic_block rest, exit_bb;</span>
<span class="lineNum">    1226 </span><span class="lineCov">        462 :   edge old_entry, new_entry, old_latch, precond_edge, new_exit;</span>
<span class="lineNum">    1227 </span><span class="lineCov">        462 :   edge new_nonexit, e;</span>
<span class="lineNum">    1228 </span><span class="lineCov">        462 :   gimple_stmt_iterator bsi;</span>
<span class="lineNum">    1229 </span><span class="lineCov">        462 :   use_operand_p op;</span>
<span class="lineNum">    1230 </span><span class="lineCov">        462 :   bool ok;</span>
<span class="lineNum">    1231 </span><span class="lineCov">        462 :   unsigned i;</span>
<span class="lineNum">    1232 </span><span class="lineCov">        462 :   profile_probability prob, prob_entry, scale_unrolled;</span>
<span class="lineNum">    1233 </span><span class="lineCov">        462 :   profile_count freq_e, freq_h;</span>
<span class="lineNum">    1234 </span><span class="lineCov">        462 :   gcov_type new_est_niter = niter_for_unrolled_loop (loop, factor);</span>
<span class="lineNum">    1235 </span><span class="lineCov">        462 :   unsigned irr = loop_preheader_edge (loop)-&gt;flags &amp; EDGE_IRREDUCIBLE_LOOP;</span>
<span class="lineNum">    1236 </span><span class="lineCov">        462 :   auto_vec&lt;edge&gt; to_remove;</span>
<span class="lineNum">    1237 </span>            : 
<span class="lineNum">    1238 </span><span class="lineCov">        462 :   determine_exit_conditions (loop, desc, factor,</span>
<span class="lineNum">    1239 </span>            :                              &amp;enter_main_cond, &amp;exit_base, &amp;exit_step,
<span class="lineNum">    1240 </span>            :                              &amp;exit_cmp, &amp;exit_bound);
<span class="lineNum">    1241 </span>            : 
<span class="lineNum">    1242 </span>            :   /* Let us assume that the unrolled loop is quite likely to be entered.  */
<span class="lineNum">    1243 </span><span class="lineCov">        462 :   if (integer_nonzerop (enter_main_cond))</span>
<span class="lineNum">    1244 </span><span class="lineCov">        118 :     prob_entry = profile_probability::always ();</span>
<span class="lineNum">    1245 </span>            :   else
<span class="lineNum">    1246 </span><span class="lineCov">        403 :     prob_entry = profile_probability::guessed_always ()</span>
<span class="lineNum">    1247 </span><span class="lineCov">        403 :                         .apply_scale (PROB_UNROLLED_LOOP_ENTERED, 100);</span>
<span class="lineNum">    1248 </span>            : 
<span class="lineNum">    1249 </span>            :   /* The values for scales should keep profile consistent, and somewhat close
<span class="lineNum">    1250 </span>            :      to correct.
<span class="lineNum">    1251 </span>            : 
<span class="lineNum">    1252 </span>            :      TODO: The current value of SCALE_REST makes it appear that the loop that
<span class="lineNum">    1253 </span>            :      is created by splitting the remaining iterations of the unrolled loop is
<span class="lineNum">    1254 </span>            :      executed the same number of times as the original loop, and with the same
<span class="lineNum">    1255 </span>            :      frequencies, which is obviously wrong.  This does not appear to cause
<span class="lineNum">    1256 </span>            :      problems, so we do not bother with fixing it for now.  To make the profile
<span class="lineNum">    1257 </span>            :      correct, we would need to change the probability of the exit edge of the
<span class="lineNum">    1258 </span>            :      loop, and recompute the distribution of frequencies in its body because
<span class="lineNum">    1259 </span>            :      of this change (scale the frequencies of blocks before and after the exit
<span class="lineNum">    1260 </span>            :      by appropriate factors).  */
<span class="lineNum">    1261 </span><span class="lineCov">        462 :   scale_unrolled = prob_entry;</span>
<span class="lineNum">    1262 </span>            : 
<span class="lineNum">    1263 </span><span class="lineCov">       1386 :   new_loop = loop_version (loop, enter_main_cond, NULL, prob_entry,</span>
<span class="lineNum">    1264 </span>            :                            prob_entry.invert (), scale_unrolled,
<span class="lineNum">    1265 </span>            :                            profile_probability::guessed_always (),
<span class="lineNum">    1266 </span>            :                            true);
<span class="lineNum">    1267 </span><span class="lineCov">        462 :   gcc_assert (new_loop != NULL);</span>
<span class="lineNum">    1268 </span><span class="lineCov">        462 :   update_ssa (TODO_update_ssa);</span>
<span class="lineNum">    1269 </span>            : 
<span class="lineNum">    1270 </span>            :   /* Prepare the cfg and update the phi nodes.  Move the loop exit to the
<span class="lineNum">    1271 </span>            :      loop latch (and make its condition dummy, for the moment).  */
<span class="lineNum">    1272 </span><span class="lineCov">        462 :   rest = loop_preheader_edge (new_loop)-&gt;src;</span>
<span class="lineNum">    1273 </span><span class="lineCov">        462 :   precond_edge = single_pred_edge (rest);</span>
<span class="lineNum">    1274 </span><span class="lineCov">        462 :   split_edge (loop_latch_edge (loop));</span>
<span class="lineNum">    1275 </span><span class="lineCov">        462 :   exit_bb = single_pred (loop-&gt;latch);</span>
<span class="lineNum">    1276 </span>            : 
<span class="lineNum">    1277 </span>            :   /* Since the exit edge will be removed, the frequency of all the blocks
<span class="lineNum">    1278 </span>            :      in the loop that are dominated by it must be scaled by
<span class="lineNum">    1279 </span>            :      1 / (1 - exit-&gt;probability).  */
<span class="lineNum">    1280 </span><span class="lineCov">        924 :   if (exit-&gt;probability.initialized_p ())</span>
<span class="lineNum">    1281 </span><span class="lineCov">       1386 :     scale_dominated_blocks_in_loop (loop, exit-&gt;src,</span>
<span class="lineNum">    1282 </span>            :                                     /* We are scaling up here so probability
<span class="lineNum">    1283 </span>            :                                        does not fit.  */
<span class="lineNum">    1284 </span><span class="lineCov">        462 :                                     loop-&gt;header-&gt;count,</span>
<span class="lineNum">    1285 </span><span class="lineCov">        462 :                                     loop-&gt;header-&gt;count</span>
<span class="lineNum">    1286 </span><span class="lineCov">        462 :                                     - loop-&gt;header-&gt;count.apply_probability</span>
<span class="lineNum">    1287 </span><span class="lineCov">        924 :                                          (exit-&gt;probability));</span>
<span class="lineNum">    1288 </span>            : 
<span class="lineNum">    1289 </span><span class="lineCov">        462 :   bsi = gsi_last_bb (exit_bb);</span>
<span class="lineNum">    1290 </span><span class="lineCov">        462 :   exit_if = gimple_build_cond (EQ_EXPR, integer_zero_node,</span>
<span class="lineNum">    1291 </span>            :                                integer_zero_node,
<span class="lineNum">    1292 </span>            :                                NULL_TREE, NULL_TREE);
<span class="lineNum">    1293 </span>            : 
<span class="lineNum">    1294 </span><span class="lineCov">        462 :   gsi_insert_after (&amp;bsi, exit_if, GSI_NEW_STMT);</span>
<span class="lineNum">    1295 </span><span class="lineCov">        462 :   new_exit = make_edge (exit_bb, rest, EDGE_FALSE_VALUE | irr);</span>
<span class="lineNum">    1296 </span><span class="lineCov">        462 :   rescan_loop_exit (new_exit, true, false);</span>
<span class="lineNum">    1297 </span>            : 
<span class="lineNum">    1298 </span>            :   /* Set the probability of new exit to the same of the old one.  Fix
<span class="lineNum">    1299 </span>            :      the frequency of the latch block, by scaling it back by
<span class="lineNum">    1300 </span>            :      1 - exit-&gt;probability.  */
<span class="lineNum">    1301 </span><span class="lineCov">        462 :   new_exit-&gt;probability = exit-&gt;probability;</span>
<span class="lineNum">    1302 </span><span class="lineCov">        462 :   new_nonexit = single_pred_edge (loop-&gt;latch);</span>
<span class="lineNum">    1303 </span><span class="lineCov">        462 :   new_nonexit-&gt;probability = exit-&gt;probability.invert ();</span>
<span class="lineNum">    1304 </span><span class="lineCov">        462 :   new_nonexit-&gt;flags = EDGE_TRUE_VALUE;</span>
<span class="lineNum">    1305 </span><span class="lineCov">        924 :   if (new_nonexit-&gt;probability.initialized_p ())</span>
<span class="lineNum">    1306 </span><span class="lineCov">        462 :     scale_bbs_frequencies (&amp;loop-&gt;latch, 1, new_nonexit-&gt;probability);</span>
<span class="lineNum">    1307 </span>            : 
<span class="lineNum">    1308 </span><span class="lineCov">        462 :   old_entry = loop_preheader_edge (loop);</span>
<span class="lineNum">    1309 </span><span class="lineCov">        462 :   new_entry = loop_preheader_edge (new_loop);</span>
<span class="lineNum">    1310 </span><span class="lineCov">        462 :   old_latch = loop_latch_edge (loop);</span>
<span class="lineNum">    1311 </span><span class="lineCov">        462 :   for (psi_old_loop = gsi_start_phis (loop-&gt;header),</span>
<span class="lineNum">    1312 </span><span class="lineCov">        462 :        psi_new_loop = gsi_start_phis (new_loop-&gt;header);</span>
<span class="lineNum">    1313 </span><span class="lineCov">       3028 :        !gsi_end_p (psi_old_loop);</span>
<span class="lineNum">    1314 </span><span class="lineCov">       2104 :        gsi_next (&amp;psi_old_loop), gsi_next (&amp;psi_new_loop))</span>
<span class="lineNum">    1315 </span>            :     {
<span class="lineNum">    1316 </span><span class="lineCov">       1052 :       phi_old_loop = psi_old_loop.phi ();</span>
<span class="lineNum">    1317 </span><span class="lineCov">       1052 :       phi_new_loop = psi_new_loop.phi ();</span>
<span class="lineNum">    1318 </span>            : 
<span class="lineNum">    1319 </span><span class="lineCov">       1052 :       init = PHI_ARG_DEF_FROM_EDGE (phi_old_loop, old_entry);</span>
<span class="lineNum">    1320 </span><span class="lineCov">       1052 :       op = PHI_ARG_DEF_PTR_FROM_EDGE (phi_new_loop, new_entry);</span>
<span class="lineNum">    1321 </span><span class="lineCov">       2104 :       gcc_assert (operand_equal_for_phi_arg_p (init, USE_FROM_PTR (op)));</span>
<span class="lineNum">    1322 </span><span class="lineCov">       1052 :       next = PHI_ARG_DEF_FROM_EDGE (phi_old_loop, old_latch);</span>
<span class="lineNum">    1323 </span>            : 
<span class="lineNum">    1324 </span>            :       /* Prefer using original variable as a base for the new ssa name.
<span class="lineNum">    1325 </span>            :          This is necessary for virtual ops, and useful in order to avoid
<span class="lineNum">    1326 </span>            :          losing debug info for real ops.  */
<span class="lineNum">    1327 </span><span class="lineCov">       1052 :       if (TREE_CODE (next) == SSA_NAME</span>
<span class="lineNum">    1328 </span><span class="lineCov">       2104 :           &amp;&amp; useless_type_conversion_p (TREE_TYPE (next),</span>
<span class="lineNum">    1329 </span><span class="lineCov">       1052 :                                         TREE_TYPE (init)))</span>
<span class="lineNum">    1330 </span><span class="lineCov">       2104 :         new_init = copy_ssa_name (next);</span>
<span class="lineNum">    1331 </span><span class="lineNoCov">          0 :       else if (TREE_CODE (init) == SSA_NAME</span>
<span class="lineNum">    1332 </span><span class="lineNoCov">          0 :                &amp;&amp; useless_type_conversion_p (TREE_TYPE (init),</span>
<span class="lineNum">    1333 </span><span class="lineNoCov">          0 :                                              TREE_TYPE (next)))</span>
<span class="lineNum">    1334 </span><span class="lineNoCov">          0 :         new_init = copy_ssa_name (init);</span>
<span class="lineNum">    1335 </span><span class="lineNoCov">          0 :       else if (useless_type_conversion_p (TREE_TYPE (next), TREE_TYPE (init)))</span>
<span class="lineNum">    1336 </span><span class="lineNoCov">          0 :         new_init = make_temp_ssa_name (TREE_TYPE (next), NULL, &quot;unrinittmp&quot;);</span>
<span class="lineNum">    1337 </span>            :       else
<span class="lineNum">    1338 </span><span class="lineNoCov">          0 :         new_init = make_temp_ssa_name (TREE_TYPE (init), NULL, &quot;unrinittmp&quot;);</span>
<span class="lineNum">    1339 </span>            : 
<span class="lineNum">    1340 </span><span class="lineCov">       1052 :       phi_rest = create_phi_node (new_init, rest);</span>
<span class="lineNum">    1341 </span>            : 
<span class="lineNum">    1342 </span><span class="lineCov">       1052 :       add_phi_arg (phi_rest, init, precond_edge, UNKNOWN_LOCATION);</span>
<span class="lineNum">    1343 </span><span class="lineCov">       1052 :       add_phi_arg (phi_rest, next, new_exit, UNKNOWN_LOCATION);</span>
<span class="lineNum">    1344 </span><span class="lineCov">       1052 :       SET_USE (op, new_init);</span>
<span class="lineNum">    1345 </span>            :     }
<span class="lineNum">    1346 </span>            : 
<span class="lineNum">    1347 </span><span class="lineCov">        462 :   remove_path (exit);</span>
<span class="lineNum">    1348 </span>            : 
<span class="lineNum">    1349 </span>            :   /* Transform the loop.  */
<span class="lineNum">    1350 </span><span class="lineCov">        462 :   if (transform)</span>
<span class="lineNum">    1351 </span><span class="lineCov">        392 :     (*transform) (loop, data);</span>
<span class="lineNum">    1352 </span>            : 
<span class="lineNum">    1353 </span>            :   /* Unroll the loop and remove the exits in all iterations except for the
<span class="lineNum">    1354 </span>            :      last one.  */
<span class="lineNum">    1355 </span><span class="lineCov">        924 :   auto_sbitmap wont_exit (factor);</span>
<span class="lineNum">    1356 </span><span class="lineCov">        924 :   bitmap_ones (wont_exit);</span>
<span class="lineNum">    1357 </span><span class="lineCov">        924 :   bitmap_clear_bit (wont_exit, factor - 1);</span>
<span class="lineNum">    1358 </span>            : 
<span class="lineNum">    1359 </span><span class="lineCov">        924 :   ok = gimple_duplicate_loop_to_header_edge</span>
<span class="lineNum">    1360 </span><span class="lineCov">        924 :           (loop, loop_latch_edge (loop), factor - 1,</span>
<span class="lineNum">    1361 </span>            :            wont_exit, new_exit, &amp;to_remove, DLTHE_FLAG_UPDATE_FREQ);
<span class="lineNum">    1362 </span><span class="lineCov">        462 :   gcc_assert (ok);</span>
<span class="lineNum">    1363 </span>            : 
<span class="lineNum">    1364 </span><span class="lineCov">       1211 :   FOR_EACH_VEC_ELT (to_remove, i, e)</span>
<span class="lineNum">    1365 </span>            :     {
<span class="lineNum">    1366 </span><span class="lineCov">        749 :       ok = remove_path (e);</span>
<span class="lineNum">    1367 </span><span class="lineCov">        749 :       gcc_assert (ok);</span>
<span class="lineNum">    1368 </span>            :     }
<span class="lineNum">    1369 </span><span class="lineCov">        462 :   update_ssa (TODO_update_ssa);</span>
<span class="lineNum">    1370 </span>            : 
<span class="lineNum">    1371 </span>            :   /* Ensure that the frequencies in the loop match the new estimated
<span class="lineNum">    1372 </span>            :      number of iterations, and change the probability of the new
<span class="lineNum">    1373 </span>            :      exit edge.  */
<span class="lineNum">    1374 </span>            : 
<span class="lineNum">    1375 </span><span class="lineCov">        462 :   freq_h = loop-&gt;header-&gt;count;</span>
<span class="lineNum">    1376 </span><span class="lineCov">        462 :   freq_e = (loop_preheader_edge (loop))-&gt;count ();</span>
<span class="lineNum">    1377 </span><span class="lineCov">        462 :   if (freq_h.nonzero_p ())</span>
<span class="lineNum">    1378 </span>            :     {
<span class="lineNum">    1379 </span>            :       /* Avoid dropping loop body profile counter to 0 because of zero count
<span class="lineNum">    1380 </span>            :          in loop's preheader.  */
<span class="lineNum">    1381 </span><span class="lineCov">        924 :       if (freq_h.nonzero_p () &amp;&amp; !(freq_e == profile_count::zero ()))</span>
<span class="lineNum">    1382 </span><span class="lineCov">        462 :         freq_e = freq_e.force_nonzero ();</span>
<span class="lineNum">    1383 </span><span class="lineCov">        462 :       scale_loop_frequencies (loop, freq_e.probability_in (freq_h));</span>
<span class="lineNum">    1384 </span>            :     }
<span class="lineNum">    1385 </span>            : 
<span class="lineNum">    1386 </span><span class="lineCov">        462 :   exit_bb = single_pred (loop-&gt;latch);</span>
<span class="lineNum">    1387 </span><span class="lineCov">        462 :   new_exit = find_edge (exit_bb, rest);</span>
<span class="lineNum">    1388 </span><span class="lineCov">        462 :   new_exit-&gt;probability = profile_probability::always ()</span>
<span class="lineNum">    1389 </span><span class="lineCov">        462 :                                 .apply_scale (1, new_est_niter + 1);</span>
<span class="lineNum">    1390 </span>            : 
<span class="lineNum">    1391 </span><span class="lineCov">        462 :   rest-&gt;count += new_exit-&gt;count ();</span>
<span class="lineNum">    1392 </span>            : 
<span class="lineNum">    1393 </span><span class="lineCov">        462 :   new_nonexit = single_pred_edge (loop-&gt;latch);</span>
<span class="lineNum">    1394 </span><span class="lineCov">        462 :   prob = new_nonexit-&gt;probability;</span>
<span class="lineNum">    1395 </span><span class="lineCov">        462 :   new_nonexit-&gt;probability = new_exit-&gt;probability.invert ();</span>
<span class="lineNum">    1396 </span><span class="lineCov">        462 :   prob = new_nonexit-&gt;probability / prob;</span>
<span class="lineNum">    1397 </span><span class="lineCov">        924 :   if (prob.initialized_p ())</span>
<span class="lineNum">    1398 </span><span class="lineCov">        462 :     scale_bbs_frequencies (&amp;loop-&gt;latch, 1, prob);</span>
<span class="lineNum">    1399 </span>            : 
<span class="lineNum">    1400 </span>            :   /* Finally create the new counter for number of iterations and add the new
<span class="lineNum">    1401 </span>            :      exit instruction.  */
<span class="lineNum">    1402 </span><span class="lineCov">        462 :   bsi = gsi_last_nondebug_bb (exit_bb);</span>
<span class="lineNum">    1403 </span><span class="lineCov">        924 :   exit_if = as_a &lt;gcond *&gt; (gsi_stmt (bsi));</span>
<span class="lineNum">    1404 </span><span class="lineCov">        462 :   create_iv (exit_base, exit_step, NULL_TREE, loop,</span>
<span class="lineNum">    1405 </span>            :              &amp;bsi, false, &amp;ctr_before, &amp;ctr_after);
<span class="lineNum">    1406 </span><span class="lineCov">        462 :   gimple_cond_set_code (exit_if, exit_cmp);</span>
<span class="lineNum">    1407 </span><span class="lineCov">        462 :   gimple_cond_set_lhs (exit_if, ctr_after);</span>
<span class="lineNum">    1408 </span><span class="lineCov">        462 :   gimple_cond_set_rhs (exit_if, exit_bound);</span>
<span class="lineNum">    1409 </span><span class="lineCov">        462 :   update_stmt (exit_if);</span>
<span class="lineNum">    1410 </span>            : 
<span class="lineNum">    1411 </span><span class="lineCov">        462 :   checking_verify_flow_info ();</span>
<span class="lineNum">    1412 </span><span class="lineCov">        462 :   checking_verify_loop_structure ();</span>
<span class="lineNum">    1413 </span><span class="lineCov">        462 :   checking_verify_loop_closed_ssa (true, loop);</span>
<span class="lineNum">    1414 </span><span class="lineCov">        924 :   checking_verify_loop_closed_ssa (true, new_loop);</span>
<span class="lineNum">    1415 </span><span class="lineCov">        462 : }</span>
<span class="lineNum">    1416 </span>            : 
<span class="lineNum">    1417 </span>            : /* Wrapper over tree_transform_and_unroll_loop for case we do not
<span class="lineNum">    1418 </span>            :    want to transform the loop before unrolling.  The meaning
<span class="lineNum">    1419 </span>            :    of the arguments is the same as for tree_transform_and_unroll_loop.  */
<a name="1420"><span class="lineNum">    1420 </span>            : </a>
<span class="lineNum">    1421 </span>            : void
<span class="lineNum">    1422 </span><span class="lineCov">         70 : tree_unroll_loop (struct loop *loop, unsigned factor,</span>
<span class="lineNum">    1423 </span>            :                   edge exit, struct tree_niter_desc *desc)
<span class="lineNum">    1424 </span>            : {
<span class="lineNum">    1425 </span><span class="lineCov">         70 :   tree_transform_and_unroll_loop (loop, factor, exit, desc,</span>
<span class="lineNum">    1426 </span>            :                                   NULL, NULL);
<span class="lineNum">    1427 </span><span class="lineCov">         70 : }</span>
<span class="lineNum">    1428 </span>            : 
<span class="lineNum">    1429 </span>            : /* Rewrite the phi node at position PSI in function of the main
<span class="lineNum">    1430 </span>            :    induction variable MAIN_IV and insert the generated code at GSI.  */
<a name="1431"><span class="lineNum">    1431 </span>            : </a>
<span class="lineNum">    1432 </span>            : static void
<span class="lineNum">    1433 </span><span class="lineCov">       1761 : rewrite_phi_with_iv (loop_p loop,</span>
<span class="lineNum">    1434 </span>            :                      gphi_iterator *psi,
<span class="lineNum">    1435 </span>            :                      gimple_stmt_iterator *gsi,
<span class="lineNum">    1436 </span>            :                      tree main_iv)
<span class="lineNum">    1437 </span>            : {
<span class="lineNum">    1438 </span><span class="lineCov">       1761 :   affine_iv iv;</span>
<span class="lineNum">    1439 </span><span class="lineCov">       1761 :   gassign *stmt;</span>
<span class="lineNum">    1440 </span><span class="lineCov">       1761 :   gphi *phi = psi-&gt;phi ();</span>
<span class="lineNum">    1441 </span><span class="lineCov">       3522 :   tree atype, mtype, val, res = PHI_RESULT (phi);</span>
<span class="lineNum">    1442 </span>            : 
<span class="lineNum">    1443 </span><span class="lineCov">       3522 :   if (virtual_operand_p (res) || res == main_iv)</span>
<span class="lineNum">    1444 </span>            :     {
<span class="lineNum">    1445 </span><span class="lineCov">        986 :       gsi_next (psi);</span>
<span class="lineNum">    1446 </span><span class="lineCov">       1064 :       return;</span>
<span class="lineNum">    1447 </span>            :     }
<span class="lineNum">    1448 </span>            : 
<span class="lineNum">    1449 </span><span class="lineCov">        775 :   if (!simple_iv (loop, loop, res, &amp;iv, true))</span>
<span class="lineNum">    1450 </span>            :     {
<span class="lineNum">    1451 </span><span class="lineCov">         78 :       gsi_next (psi);</span>
<span class="lineNum">    1452 </span><span class="lineCov">         78 :       return;</span>
<span class="lineNum">    1453 </span>            :     }
<span class="lineNum">    1454 </span>            : 
<span class="lineNum">    1455 </span><span class="lineCov">        697 :   remove_phi_node (psi, false);</span>
<span class="lineNum">    1456 </span>            : 
<span class="lineNum">    1457 </span><span class="lineCov">        697 :   atype = TREE_TYPE (res);</span>
<span class="lineNum">    1458 </span><span class="lineCov">        697 :   mtype = POINTER_TYPE_P (atype) ? sizetype : atype;</span>
<span class="lineNum">    1459 </span><span class="lineCov">        697 :   val = fold_build2 (MULT_EXPR, mtype, unshare_expr (iv.step),</span>
<span class="lineNum">    1460 </span>            :                      fold_convert (mtype, main_iv));
<span class="lineNum">    1461 </span><span class="lineCov">       1394 :   val = fold_build2 (POINTER_TYPE_P (atype)</span>
<span class="lineNum">    1462 </span>            :                      ? POINTER_PLUS_EXPR : PLUS_EXPR,
<span class="lineNum">    1463 </span>            :                      atype, unshare_expr (iv.base), val);
<span class="lineNum">    1464 </span><span class="lineCov">        697 :   val = force_gimple_operand_gsi (gsi, val, false, NULL_TREE, true,</span>
<span class="lineNum">    1465 </span>            :                                   GSI_SAME_STMT);
<span class="lineNum">    1466 </span><span class="lineCov">        697 :   stmt = gimple_build_assign (res, val);</span>
<span class="lineNum">    1467 </span><span class="lineCov">        697 :   gsi_insert_before (gsi, stmt, GSI_SAME_STMT);</span>
<span class="lineNum">    1468 </span>            : }
<span class="lineNum">    1469 </span>            : 
<span class="lineNum">    1470 </span>            : /* Rewrite all the phi nodes of LOOP in function of the main induction
<span class="lineNum">    1471 </span>            :    variable MAIN_IV.  */
<a name="1472"><span class="lineNum">    1472 </span>            : </a>
<span class="lineNum">    1473 </span>            : static void
<span class="lineNum">    1474 </span><span class="lineCov">        507 : rewrite_all_phi_nodes_with_iv (loop_p loop, tree main_iv)</span>
<span class="lineNum">    1475 </span>            : {
<span class="lineNum">    1476 </span><span class="lineCov">        507 :   unsigned i;</span>
<span class="lineNum">    1477 </span><span class="lineCov">        507 :   basic_block *bbs = get_loop_body_in_dom_order (loop);</span>
<span class="lineNum">    1478 </span><span class="lineCov">        507 :   gphi_iterator psi;</span>
<span class="lineNum">    1479 </span>            : 
<span class="lineNum">    1480 </span><span class="lineCov">       1732 :   for (i = 0; i &lt; loop-&gt;num_nodes; i++)</span>
<span class="lineNum">    1481 </span>            :     {
<span class="lineNum">    1482 </span><span class="lineCov">       1225 :       basic_block bb = bbs[i];</span>
<span class="lineNum">    1483 </span><span class="lineCov">       1225 :       gimple_stmt_iterator gsi = gsi_after_labels (bb);</span>
<span class="lineNum">    1484 </span>            : 
<span class="lineNum">    1485 </span><span class="lineCov">       1225 :       if (bb-&gt;loop_father != loop)</span>
<span class="lineNum">    1486 </span><span class="lineCov">         85 :         continue;</span>
<span class="lineNum">    1487 </span>            : 
<span class="lineNum">    1488 </span><span class="lineCov">       2901 :       for (psi = gsi_start_phis (bb); !gsi_end_p (psi); )</span>
<span class="lineNum">    1489 </span><span class="lineCov">       1761 :         rewrite_phi_with_iv (loop, &amp;psi, &amp;gsi, main_iv);</span>
<span class="lineNum">    1490 </span>            :     }
<span class="lineNum">    1491 </span>            : 
<span class="lineNum">    1492 </span><span class="lineCov">        507 :   free (bbs);</span>
<span class="lineNum">    1493 </span><span class="lineCov">        507 : }</span>
<span class="lineNum">    1494 </span>            : 
<span class="lineNum">    1495 </span>            : /* Bases all the induction variables in LOOP on a single induction variable
<span class="lineNum">    1496 </span>            :    (with base 0 and step 1), whose final value is compared with *NIT.  When the
<span class="lineNum">    1497 </span>            :    IV type precision has to be larger than *NIT type precision, *NIT is
<span class="lineNum">    1498 </span>            :    converted to the larger type, the conversion code is inserted before the
<span class="lineNum">    1499 </span>            :    loop, and *NIT is updated to the new definition.  When BUMP_IN_LATCH is true,
<span class="lineNum">    1500 </span>            :    the induction variable is incremented in the loop latch, otherwise it is
<span class="lineNum">    1501 </span>            :    incremented in the loop header.  Return the induction variable that was
<span class="lineNum">    1502 </span>            :    created.  */
<a name="1503"><span class="lineNum">    1503 </span>            : </a>
<span class="lineNum">    1504 </span>            : tree
<span class="lineNum">    1505 </span><span class="lineCov">        507 : canonicalize_loop_ivs (struct loop *loop, tree *nit, bool bump_in_latch)</span>
<span class="lineNum">    1506 </span>            : {
<span class="lineNum">    1507 </span><span class="lineCov">        507 :   unsigned precision = TYPE_PRECISION (TREE_TYPE (*nit));</span>
<span class="lineNum">    1508 </span><span class="lineCov">        507 :   unsigned original_precision = precision;</span>
<span class="lineNum">    1509 </span><span class="lineCov">        507 :   tree type, var_before;</span>
<span class="lineNum">    1510 </span><span class="lineCov">        507 :   gimple_stmt_iterator gsi;</span>
<span class="lineNum">    1511 </span><span class="lineCov">        507 :   gphi_iterator psi;</span>
<span class="lineNum">    1512 </span><span class="lineCov">        507 :   gcond *stmt;</span>
<span class="lineNum">    1513 </span><span class="lineCov">        507 :   edge exit = single_dom_exit (loop);</span>
<span class="lineNum">    1514 </span><span class="lineCov">        507 :   gimple_seq stmts;</span>
<span class="lineNum">    1515 </span><span class="lineCov">        507 :   bool unsigned_p = false;</span>
<span class="lineNum">    1516 </span>            : 
<span class="lineNum">    1517 </span><span class="lineCov">        507 :   for (psi = gsi_start_phis (loop-&gt;header);</span>
<span class="lineNum">    1518 </span><span class="lineCov">       2216 :        !gsi_end_p (psi); gsi_next (&amp;psi))</span>
<span class="lineNum">    1519 </span>            :     {
<span class="lineNum">    1520 </span><span class="lineCov">       1202 :       gphi *phi = psi.phi ();</span>
<span class="lineNum">    1521 </span><span class="lineCov">       2404 :       tree res = PHI_RESULT (phi);</span>
<span class="lineNum">    1522 </span><span class="lineCov">       1202 :       bool uns;</span>
<span class="lineNum">    1523 </span>            : 
<span class="lineNum">    1524 </span><span class="lineCov">       1202 :       type = TREE_TYPE (res);</span>
<span class="lineNum">    1525 </span><span class="lineCov">       1202 :       if (virtual_operand_p (res)</span>
<span class="lineNum">    1526 </span><span class="lineCov">        756 :           || (!INTEGRAL_TYPE_P (type)</span>
<span class="lineNum">    1527 </span><span class="lineCov">         14 :               &amp;&amp; !POINTER_TYPE_P (type))</span>
<span class="lineNum">    1528 </span><span class="lineCov">       1948 :           || TYPE_PRECISION (type) &lt; precision)</span>
<span class="lineNum">    1529 </span>            :         continue;
<span class="lineNum">    1530 </span>            : 
<span class="lineNum">    1531 </span><span class="lineCov">        724 :       uns = POINTER_TYPE_P (type) | TYPE_UNSIGNED (type);</span>
<span class="lineNum">    1532 </span>            : 
<span class="lineNum">    1533 </span><span class="lineCov">       1448 :       if (TYPE_PRECISION (type) &gt; precision)</span>
<span class="lineNum">    1534 </span>            :         unsigned_p = uns;
<span class="lineNum">    1535 </span>            :       else
<span class="lineNum">    1536 </span><span class="lineCov">        720 :         unsigned_p |= uns;</span>
<span class="lineNum">    1537 </span>            : 
<span class="lineNum">    1538 </span>            :       precision = TYPE_PRECISION (type);
<span class="lineNum">    1539 </span>            :     }
<span class="lineNum">    1540 </span>            : 
<span class="lineNum">    1541 </span><span class="lineCov">       1014 :   scalar_int_mode mode = smallest_int_mode_for_size (precision);</span>
<span class="lineNum">    1542 </span><span class="lineCov">        507 :   precision = GET_MODE_PRECISION (mode);</span>
<span class="lineNum">    1543 </span><span class="lineCov">        507 :   type = build_nonstandard_integer_type (precision, unsigned_p);</span>
<span class="lineNum">    1544 </span>            : 
<span class="lineNum">    1545 </span><span class="lineCov">        507 :   if (original_precision != precision</span>
<span class="lineNum">    1546 </span><span class="lineCov">        507 :       || TYPE_UNSIGNED (TREE_TYPE (*nit)) != unsigned_p)</span>
<span class="lineNum">    1547 </span>            :     {
<span class="lineNum">    1548 </span><span class="lineCov">        232 :       *nit = fold_convert (type, *nit);</span>
<span class="lineNum">    1549 </span><span class="lineCov">        232 :       *nit = force_gimple_operand (*nit, &amp;stmts, true, NULL_TREE);</span>
<span class="lineNum">    1550 </span><span class="lineCov">        232 :       if (stmts)</span>
<span class="lineNum">    1551 </span><span class="lineCov">         97 :         gsi_insert_seq_on_edge_immediate (loop_preheader_edge (loop), stmts);</span>
<span class="lineNum">    1552 </span>            :     }
<span class="lineNum">    1553 </span>            : 
<span class="lineNum">    1554 </span><span class="lineCov">        507 :   if (bump_in_latch)</span>
<span class="lineNum">    1555 </span><span class="lineCov">       1014 :     gsi = gsi_last_bb (loop-&gt;latch);</span>
<span class="lineNum">    1556 </span>            :   else
<span class="lineNum">    1557 </span><span class="lineNoCov">          0 :     gsi = gsi_last_nondebug_bb (loop-&gt;header);</span>
<span class="lineNum">    1558 </span><span class="lineCov">       1014 :   create_iv (build_int_cst_type (type, 0), build_int_cst (type, 1), NULL_TREE,</span>
<span class="lineNum">    1559 </span>            :              loop, &amp;gsi, bump_in_latch, &amp;var_before, NULL);
<span class="lineNum">    1560 </span>            : 
<span class="lineNum">    1561 </span><span class="lineCov">        507 :   rewrite_all_phi_nodes_with_iv (loop, var_before);</span>
<span class="lineNum">    1562 </span>            : 
<span class="lineNum">    1563 </span><span class="lineCov">        507 :   stmt = as_a &lt;gcond *&gt; (last_stmt (exit-&gt;src));</span>
<span class="lineNum">    1564 </span>            :   /* Make the loop exit if the control condition is not satisfied.  */
<span class="lineNum">    1565 </span><span class="lineCov">        507 :   if (exit-&gt;flags &amp; EDGE_TRUE_VALUE)</span>
<span class="lineNum">    1566 </span>            :     {
<span class="lineNum">    1567 </span><span class="lineCov">        267 :       edge te, fe;</span>
<span class="lineNum">    1568 </span>            : 
<span class="lineNum">    1569 </span><span class="lineCov">        267 :       extract_true_false_edges_from_block (exit-&gt;src, &amp;te, &amp;fe);</span>
<span class="lineNum">    1570 </span><span class="lineCov">        267 :       te-&gt;flags = EDGE_FALSE_VALUE;</span>
<span class="lineNum">    1571 </span><span class="lineCov">        267 :       fe-&gt;flags = EDGE_TRUE_VALUE;</span>
<span class="lineNum">    1572 </span>            :     }
<span class="lineNum">    1573 </span><span class="lineCov">        507 :   gimple_cond_set_code (stmt, LT_EXPR);</span>
<span class="lineNum">    1574 </span><span class="lineCov">        507 :   gimple_cond_set_lhs (stmt, var_before);</span>
<span class="lineNum">    1575 </span><span class="lineCov">        507 :   gimple_cond_set_rhs (stmt, *nit);</span>
<span class="lineNum">    1576 </span><span class="lineCov">        507 :   update_stmt (stmt);</span>
<span class="lineNum">    1577 </span>            : 
<span class="lineNum">    1578 </span><span class="lineCov">        507 :   return var_before;</span>
<span class="lineNum">    1579 </span>            : }
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.0</a></td></tr>
  </table>
  <br>
<h3>LCOV profile is generated on x86_64 machine using following configure options: configure --disable-bootstrap --enable-coverage=opt --enable-languages=c,c++,fortran,go,jit,lto --enable-host-shared. GCC test suite is run with the built compiler.</h3></body></html>
