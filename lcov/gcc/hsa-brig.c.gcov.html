<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - gcc.info - gcc/hsa-brig.c</title>
  <link rel="stylesheet" type="text/css" href="../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../index.html">top level</a> - <a href="index.html">gcc</a> - hsa-brig.c<span style="font-size: 80%;"> (source / <a href="hsa-brig.c.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">gcc.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">4</td>
            <td class="headerCovTableEntry">1428</td>
            <td class="headerCovTableEntryLo">0.3 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2018-09-22 10:58:49</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">1</td>
            <td class="headerCovTableEntry">60</td>
            <td class="headerCovTableEntryLo">1.7 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /* Producing binary form of HSA BRIG from our internal representation.</a>
<span class="lineNum">       2 </span>            :    Copyright (C) 2013-2018 Free Software Foundation, Inc.
<span class="lineNum">       3 </span>            :    Contributed by Martin Jambor &lt;mjambor@suse.cz&gt; and
<span class="lineNum">       4 </span>            :    Martin Liska &lt;mliska@suse.cz&gt;.
<span class="lineNum">       5 </span>            : 
<span class="lineNum">       6 </span>            : This file is part of GCC.
<span class="lineNum">       7 </span>            : 
<span class="lineNum">       8 </span>            : GCC is free software; you can redistribute it and/or modify
<span class="lineNum">       9 </span>            : it under the terms of the GNU General Public License as published by
<span class="lineNum">      10 </span>            : the Free Software Foundation; either version 3, or (at your option)
<span class="lineNum">      11 </span>            : any later version.
<span class="lineNum">      12 </span>            : 
<span class="lineNum">      13 </span>            : GCC is distributed in the hope that it will be useful,
<span class="lineNum">      14 </span>            : but WITHOUT ANY WARRANTY; without even the implied warranty of
<span class="lineNum">      15 </span>            : MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
<span class="lineNum">      16 </span>            : GNU General Public License for more details.
<span class="lineNum">      17 </span>            : 
<span class="lineNum">      18 </span>            : You should have received a copy of the GNU General Public License
<span class="lineNum">      19 </span>            : along with GCC; see the file COPYING3.  If not see
<span class="lineNum">      20 </span>            : &lt;http://www.gnu.org/licenses/&gt;.  */
<span class="lineNum">      21 </span>            : 
<span class="lineNum">      22 </span>            : #include &quot;config.h&quot;
<span class="lineNum">      23 </span>            : #include &quot;system.h&quot;
<span class="lineNum">      24 </span>            : #include &quot;coretypes.h&quot;
<span class="lineNum">      25 </span>            : #include &quot;tm.h&quot;
<span class="lineNum">      26 </span>            : #include &quot;target.h&quot;
<span class="lineNum">      27 </span>            : #include &quot;memmodel.h&quot;
<span class="lineNum">      28 </span>            : #include &quot;tm_p.h&quot;
<span class="lineNum">      29 </span>            : #include &quot;is-a.h&quot;
<span class="lineNum">      30 </span>            : #include &quot;vec.h&quot;
<span class="lineNum">      31 </span>            : #include &quot;hash-table.h&quot;
<span class="lineNum">      32 </span>            : #include &quot;hash-map.h&quot;
<span class="lineNum">      33 </span>            : #include &quot;tree.h&quot;
<span class="lineNum">      34 </span>            : #include &quot;tree-iterator.h&quot;
<span class="lineNum">      35 </span>            : #include &quot;stor-layout.h&quot;
<span class="lineNum">      36 </span>            : #include &quot;output.h&quot;
<span class="lineNum">      37 </span>            : #include &quot;basic-block.h&quot;
<span class="lineNum">      38 </span>            : #include &quot;function.h&quot;
<span class="lineNum">      39 </span>            : #include &quot;cfg.h&quot;
<span class="lineNum">      40 </span>            : #include &quot;fold-const.h&quot;
<span class="lineNum">      41 </span>            : #include &quot;stringpool.h&quot;
<span class="lineNum">      42 </span>            : #include &quot;gimple-pretty-print.h&quot;
<span class="lineNum">      43 </span>            : #include &quot;diagnostic-core.h&quot;
<span class="lineNum">      44 </span>            : #include &quot;cgraph.h&quot;
<span class="lineNum">      45 </span>            : #include &quot;dumpfile.h&quot;
<span class="lineNum">      46 </span>            : #include &quot;print-tree.h&quot;
<span class="lineNum">      47 </span>            : #include &quot;symbol-summary.h&quot;
<span class="lineNum">      48 </span>            : #include &quot;hsa-common.h&quot;
<span class="lineNum">      49 </span>            : #include &quot;gomp-constants.h&quot;
<span class="lineNum">      50 </span>            : 
<span class="lineNum">      51 </span>            : /* Convert VAL to little endian form, if necessary.  */
<a name="52"><span class="lineNum">      52 </span>            : </a>
<span class="lineNum">      53 </span>            : static uint16_t
<span class="lineNum">      54 </span><span class="lineNoCov">          0 : lendian16 (uint16_t val)</span>
<span class="lineNum">      55 </span>            : {
<span class="lineNum">      56 </span>            : #if GCC_VERSION &gt;= 4008
<span class="lineNum">      57 </span>            : #if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
<span class="lineNum">      58 </span><span class="lineNoCov">          0 :   return val;</span>
<span class="lineNum">      59 </span>            : #elif __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
<span class="lineNum">      60 </span>            :   return __builtin_bswap16 (val);
<span class="lineNum">      61 </span>            : #else   /* __ORDER_PDP_ENDIAN__ */
<span class="lineNum">      62 </span>            :   return val;
<span class="lineNum">      63 </span>            : #endif
<span class="lineNum">      64 </span>            : #else
<span class="lineNum">      65 </span>            : // provide a safe slower default, with shifts and masking
<span class="lineNum">      66 </span>            : #ifndef WORDS_BIGENDIAN
<span class="lineNum">      67 </span>            :   return val;
<span class="lineNum">      68 </span>            : #else
<span class="lineNum">      69 </span>            :   return (val &gt;&gt; 8) | (val &lt;&lt; 8);
<span class="lineNum">      70 </span>            : #endif
<span class="lineNum">      71 </span>            : #endif
<span class="lineNum">      72 </span>            : }
<span class="lineNum">      73 </span>            : 
<span class="lineNum">      74 </span>            : /* Convert VAL to little endian form, if necessary.  */
<a name="75"><span class="lineNum">      75 </span>            : </a>
<span class="lineNum">      76 </span>            : static uint32_t
<span class="lineNum">      77 </span><span class="lineNoCov">          0 : lendian32 (uint32_t val)</span>
<span class="lineNum">      78 </span>            : {
<span class="lineNum">      79 </span>            : #if GCC_VERSION &gt;= 4006
<span class="lineNum">      80 </span>            : #if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
<span class="lineNum">      81 </span><span class="lineNoCov">          0 :   return val;</span>
<span class="lineNum">      82 </span>            : #elif __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
<span class="lineNum">      83 </span>            :   return __builtin_bswap32 (val);
<span class="lineNum">      84 </span>            : #else  /* __ORDER_PDP_ENDIAN__ */
<span class="lineNum">      85 </span>            :   return (val &gt;&gt; 16) | (val &lt;&lt; 16);
<span class="lineNum">      86 </span>            : #endif
<span class="lineNum">      87 </span>            : #else
<span class="lineNum">      88 </span>            : // provide a safe slower default, with shifts and masking
<span class="lineNum">      89 </span>            : #ifndef WORDS_BIGENDIAN
<span class="lineNum">      90 </span>            :   return val;
<span class="lineNum">      91 </span>            : #else
<span class="lineNum">      92 </span>            :   val = ((val &amp; 0xff00ff00) &gt;&gt; 8) | ((val &amp; 0xff00ff) &lt;&lt; 8);
<span class="lineNum">      93 </span>            :   return (val &gt;&gt; 16) | (val &lt;&lt; 16);
<span class="lineNum">      94 </span>            : #endif
<span class="lineNum">      95 </span>            : #endif
<span class="lineNum">      96 </span>            : }
<span class="lineNum">      97 </span>            : 
<span class="lineNum">      98 </span>            : /* Convert VAL to little endian form, if necessary.  */
<a name="99"><span class="lineNum">      99 </span>            : </a>
<span class="lineNum">     100 </span>            : static uint64_t
<span class="lineNum">     101 </span><span class="lineNoCov">          0 : lendian64 (uint64_t val)</span>
<span class="lineNum">     102 </span>            : {
<span class="lineNum">     103 </span>            : #if GCC_VERSION &gt;= 4006
<span class="lineNum">     104 </span>            : #if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
<span class="lineNum">     105 </span><span class="lineNoCov">          0 :   return val;</span>
<span class="lineNum">     106 </span>            : #elif __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
<span class="lineNum">     107 </span>            :   return __builtin_bswap64 (val);
<span class="lineNum">     108 </span>            : #else  /* __ORDER_PDP_ENDIAN__ */
<span class="lineNum">     109 </span>            :   return (((val &amp; 0xffffll) &lt;&lt; 48)
<span class="lineNum">     110 </span>            :           | ((val &amp; 0xffff0000ll) &lt;&lt; 16)
<span class="lineNum">     111 </span>            :           | ((val &amp; 0xffff00000000ll) &gt;&gt; 16)
<span class="lineNum">     112 </span>            :           | ((val &amp; 0xffff000000000000ll) &gt;&gt; 48));
<span class="lineNum">     113 </span>            : #endif
<span class="lineNum">     114 </span>            : #else
<span class="lineNum">     115 </span>            : // provide a safe slower default, with shifts and masking
<span class="lineNum">     116 </span>            : #ifndef WORDS_BIGENDIAN
<span class="lineNum">     117 </span>            :   return val;
<span class="lineNum">     118 </span>            : #else
<span class="lineNum">     119 </span>            :   val = (((val &amp; 0xff00ff00ff00ff00ll) &gt;&gt; 8)
<span class="lineNum">     120 </span>            :          | ((val &amp; 0x00ff00ff00ff00ffll) &lt;&lt; 8));
<span class="lineNum">     121 </span>            :   val = ((( val &amp; 0xffff0000ffff0000ll) &gt;&gt; 16)
<span class="lineNum">     122 </span>            :          | (( val &amp; 0x0000ffff0000ffffll) &lt;&lt; 16));
<span class="lineNum">     123 </span>            :   return (val &gt;&gt; 32) | (val &lt;&lt; 32);
<span class="lineNum">     124 </span>            : #endif
<span class="lineNum">     125 </span>            : #endif
<span class="lineNum">     126 </span>            : }
<span class="lineNum">     127 </span>            : 
<span class="lineNum">     128 </span>            : #define BRIG_ELF_SECTION_NAME &quot;.brig&quot;
<span class="lineNum">     129 </span>            : #define BRIG_LABEL_STRING &quot;hsa_brig&quot;
<span class="lineNum">     130 </span>            : #define BRIG_SECTION_DATA_NAME    &quot;hsa_data&quot;
<span class="lineNum">     131 </span>            : #define BRIG_SECTION_CODE_NAME    &quot;hsa_code&quot;
<span class="lineNum">     132 </span>            : #define BRIG_SECTION_OPERAND_NAME &quot;hsa_operand&quot;
<span class="lineNum">     133 </span>            : 
<span class="lineNum">     134 </span>            : #define BRIG_CHUNK_MAX_SIZE (64 * 1024)
<span class="lineNum">     135 </span>            : 
<span class="lineNum">     136 </span>            : /* Required HSA section alignment.  */
<span class="lineNum">     137 </span>            : 
<span class="lineNum">     138 </span>            : #define HSA_SECTION_ALIGNMENT 16
<span class="lineNum">     139 </span>            : 
<span class="lineNum">     140 </span>            : /* Chunks of BRIG binary data.  */
<span class="lineNum">     141 </span>            : 
<span class="lineNum">     142 </span>            : struct hsa_brig_data_chunk
<span class="lineNum">     143 </span>            : {
<span class="lineNum">     144 </span>            :   /* Size of the data already stored into a chunk.  */
<span class="lineNum">     145 </span>            :   unsigned size;
<span class="lineNum">     146 </span>            : 
<span class="lineNum">     147 </span>            :   /* Pointer to the data.  */
<span class="lineNum">     148 </span>            :   char *data;
<span class="lineNum">     149 </span>            : };
<span class="lineNum">     150 </span>            : 
<span class="lineNum">     151 </span>            : /* Structure representing a BRIG section, holding and writing its data.  */
<span class="lineNum">     152 </span>            : 
<span class="lineNum">     153 </span>            : class hsa_brig_section
<span class="lineNum">     154 </span>            : {
<span class="lineNum">     155 </span>            : public:
<span class="lineNum">     156 </span>            :   /* Section name that will be output to the BRIG.  */
<span class="lineNum">     157 </span>            :   const char *section_name;
<span class="lineNum">     158 </span>            :   /* Size in bytes of all data stored in the section.  */
<span class="lineNum">     159 </span>            :   unsigned total_size;
<span class="lineNum">     160 </span>            :   /* The size of the header of the section including padding.  */
<span class="lineNum">     161 </span>            :   unsigned header_byte_count;
<span class="lineNum">     162 </span>            :   /* The size of the header of the section without any padding.  */
<span class="lineNum">     163 </span>            :   unsigned header_byte_delta;
<span class="lineNum">     164 </span>            : 
<span class="lineNum">     165 </span>            :   void init (const char *name);
<span class="lineNum">     166 </span>            :   void release ();
<span class="lineNum">     167 </span>            :   void output ();
<span class="lineNum">     168 </span>            :   unsigned add (const void *data, unsigned len, void **output = NULL);
<span class="lineNum">     169 </span>            :   void round_size_up (int factor);
<span class="lineNum">     170 </span>            :   void *get_ptr_by_offset (unsigned int offset);
<span class="lineNum">     171 </span>            : 
<span class="lineNum">     172 </span>            : private:
<span class="lineNum">     173 </span>            :   void allocate_new_chunk ();
<span class="lineNum">     174 </span>            : 
<span class="lineNum">     175 </span>            :   /* Buffers of binary data, each containing BRIG_CHUNK_MAX_SIZE bytes.  */
<span class="lineNum">     176 </span>            :   vec &lt;struct hsa_brig_data_chunk&gt; chunks;
<span class="lineNum">     177 </span>            : 
<span class="lineNum">     178 </span>            :   /* More convenient access to the last chunk from the vector above.  */
<span class="lineNum">     179 </span>            :   struct hsa_brig_data_chunk *cur_chunk;
<span class="lineNum">     180 </span>            : };
<span class="lineNum">     181 </span>            : 
<span class="lineNum">     182 </span>            : static struct hsa_brig_section brig_data, brig_code, brig_operand;
<span class="lineNum">     183 </span>            : static uint32_t brig_insn_count;
<span class="lineNum">     184 </span>            : static bool brig_initialized = false;
<span class="lineNum">     185 </span>            : 
<span class="lineNum">     186 </span>            : /* Mapping between emitted HSA functions and their offset in code segment.  */
<span class="lineNum">     187 </span>            : static hash_map&lt;tree, BrigCodeOffset32_t&gt; *function_offsets;
<span class="lineNum">     188 </span>            : 
<span class="lineNum">     189 </span>            : /* Hash map of emitted function declarations.  */
<span class="lineNum">     190 </span>            : static hash_map &lt;tree, BrigDirectiveExecutable *&gt; *emitted_declarations;
<span class="lineNum">     191 </span>            : 
<span class="lineNum">     192 </span>            : /* Hash table of emitted internal function declaration offsets.  */
<span class="lineNum">     193 </span>            : hash_table &lt;hsa_internal_fn_hasher&gt; *hsa_emitted_internal_decls;
<span class="lineNum">     194 </span>            : 
<span class="lineNum">     195 </span>            : /* List of sbr instructions.  */
<span class="lineNum">     196 </span>            : static vec &lt;hsa_insn_sbr *&gt; *switch_instructions;
<span class="lineNum">     197 </span>            : 
<span class="lineNum">     198 </span>            : struct function_linkage_pair
<span class="lineNum">     199 </span>            : {
<span class="lineNum">     200 </span>            :   function_linkage_pair (tree decl, unsigned int off)
<span class="lineNum">     201 </span><span class="lineNoCov">          0 :     : function_decl (decl), offset (off) {}</span>
<span class="lineNum">     202 </span>            : 
<span class="lineNum">     203 </span>            :   /* Declaration of called function.  */
<span class="lineNum">     204 </span>            :   tree function_decl;
<span class="lineNum">     205 </span>            : 
<span class="lineNum">     206 </span>            :   /* Offset in operand section.  */
<span class="lineNum">     207 </span>            :   unsigned int offset;
<span class="lineNum">     208 </span>            : };
<span class="lineNum">     209 </span>            : 
<span class="lineNum">     210 </span>            : /* Vector of function calls where we need to resolve function offsets.  */
<span class="lineNum">     211 </span>            : static auto_vec &lt;function_linkage_pair&gt; function_call_linkage;
<span class="lineNum">     212 </span>            : 
<span class="lineNum">     213 </span>            : /* Add a new chunk, allocate data for it and initialize it.  */
<a name="214"><span class="lineNum">     214 </span>            : </a>
<span class="lineNum">     215 </span>            : void
<span class="lineNum">     216 </span><span class="lineNoCov">          0 : hsa_brig_section::allocate_new_chunk ()</span>
<span class="lineNum">     217 </span>            : {
<span class="lineNum">     218 </span><span class="lineNoCov">          0 :   struct hsa_brig_data_chunk new_chunk;</span>
<span class="lineNum">     219 </span>            : 
<span class="lineNum">     220 </span><span class="lineNoCov">          0 :   new_chunk.data = XCNEWVEC (char, BRIG_CHUNK_MAX_SIZE);</span>
<span class="lineNum">     221 </span><span class="lineNoCov">          0 :   new_chunk.size = 0;</span>
<span class="lineNum">     222 </span><span class="lineNoCov">          0 :   cur_chunk = chunks.safe_push (new_chunk);</span>
<span class="lineNum">     223 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     224 </span>            : 
<span class="lineNum">     225 </span>            : /* Initialize the brig section.  */
<span class="lineNum">     226 </span>            : 
<span class="lineNum">     227 </span>            : void
<span class="lineNum">     228 </span><span class="lineNoCov">          0 : hsa_brig_section::init (const char *name)</span>
<span class="lineNum">     229 </span>            : {
<span class="lineNum">     230 </span><span class="lineNoCov">          0 :   section_name = name;</span>
<span class="lineNum">     231 </span>            :   /* While the following computation is basically wrong, because the intent
<span class="lineNum">     232 </span>            :      certainly wasn't to have the first character of name and padding, which
<span class="lineNum">     233 </span>            :      are a part of sizeof (BrigSectionHeader), included in the first addend,
<span class="lineNum">     234 </span>            :      this is what the disassembler expects.  */
<span class="lineNum">     235 </span><span class="lineNoCov">          0 :   total_size = sizeof (BrigSectionHeader) + strlen (section_name);</span>
<span class="lineNum">     236 </span><span class="lineNoCov">          0 :   chunks.create (1);</span>
<span class="lineNum">     237 </span><span class="lineNoCov">          0 :   allocate_new_chunk ();</span>
<span class="lineNum">     238 </span><span class="lineNoCov">          0 :   header_byte_delta = total_size;</span>
<span class="lineNum">     239 </span><span class="lineNoCov">          0 :   round_size_up (4);</span>
<span class="lineNum">     240 </span><span class="lineNoCov">          0 :   header_byte_count = total_size;</span>
<span class="lineNum">     241 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     242 </span>            : 
<span class="lineNum">     243 </span>            : /* Free all data in the section.  */
<span class="lineNum">     244 </span>            : 
<span class="lineNum">     245 </span>            : void
<span class="lineNum">     246 </span><span class="lineNoCov">          0 : hsa_brig_section::release ()</span>
<span class="lineNum">     247 </span>            : {
<span class="lineNum">     248 </span><span class="lineNoCov">          0 :   for (unsigned i = 0; i &lt; chunks.length (); i++)</span>
<span class="lineNum">     249 </span><span class="lineNoCov">          0 :     free (chunks[i].data);</span>
<span class="lineNum">     250 </span><span class="lineNoCov">          0 :   chunks.release ();</span>
<span class="lineNum">     251 </span><span class="lineNoCov">          0 :   cur_chunk = NULL;</span>
<span class="lineNum">     252 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     253 </span>            : 
<span class="lineNum">     254 </span>            : /* Write the section to the output file to a section with the name given at
<span class="lineNum">     255 </span>            :    initialization.  Switches the output section and does not restore it.  */
<span class="lineNum">     256 </span>            : 
<span class="lineNum">     257 </span>            : void
<span class="lineNum">     258 </span><span class="lineNoCov">          0 : hsa_brig_section::output ()</span>
<span class="lineNum">     259 </span>            : {
<span class="lineNum">     260 </span><span class="lineNoCov">          0 :   struct BrigSectionHeader section_header;</span>
<span class="lineNum">     261 </span><span class="lineNoCov">          0 :   char padding[8];</span>
<span class="lineNum">     262 </span>            : 
<span class="lineNum">     263 </span><span class="lineNoCov">          0 :   section_header.byteCount = lendian64 (total_size);</span>
<span class="lineNum">     264 </span><span class="lineNoCov">          0 :   section_header.headerByteCount = lendian32 (header_byte_count);</span>
<span class="lineNum">     265 </span><span class="lineNoCov">          0 :   section_header.nameLength = lendian32 (strlen (section_name));</span>
<span class="lineNum">     266 </span><span class="lineNoCov">          0 :   assemble_string ((const char *) &amp;section_header, 16);</span>
<span class="lineNum">     267 </span><span class="lineNoCov">          0 :   assemble_string (section_name, (section_header.nameLength));</span>
<span class="lineNum">     268 </span><span class="lineNoCov">          0 :   memset (&amp;padding, 0, sizeof (padding));</span>
<span class="lineNum">     269 </span>            :   /* This is also a consequence of the wrong header size computation described
<span class="lineNum">     270 </span>            :      in a comment in hsa_brig_section::init.  */
<span class="lineNum">     271 </span><span class="lineNoCov">          0 :   assemble_string (padding, 8);</span>
<span class="lineNum">     272 </span><span class="lineNoCov">          0 :   for (unsigned i = 0; i &lt; chunks.length (); i++)</span>
<span class="lineNum">     273 </span><span class="lineNoCov">          0 :     assemble_string (chunks[i].data, chunks[i].size);</span>
<span class="lineNum">     274 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     275 </span>            : 
<span class="lineNum">     276 </span>            : /* Add to the stream LEN bytes of opaque binary DATA.  Return the offset at
<span class="lineNum">     277 </span>            :    which it was stored.  If OUTPUT is not NULL, store into it the pointer to
<span class="lineNum">     278 </span>            :    the place where DATA was actually stored.  */
<a name="279"><span class="lineNum">     279 </span>            : </a>
<span class="lineNum">     280 </span>            : unsigned
<span class="lineNum">     281 </span><span class="lineNoCov">          0 : hsa_brig_section::add (const void *data, unsigned len, void **output)</span>
<span class="lineNum">     282 </span>            : {
<span class="lineNum">     283 </span><span class="lineNoCov">          0 :   unsigned offset = total_size;</span>
<span class="lineNum">     284 </span>            : 
<span class="lineNum">     285 </span><span class="lineNoCov">          0 :   gcc_assert (len &lt;= BRIG_CHUNK_MAX_SIZE);</span>
<span class="lineNum">     286 </span><span class="lineNoCov">          0 :   if (cur_chunk-&gt;size &gt; (BRIG_CHUNK_MAX_SIZE - len))</span>
<span class="lineNum">     287 </span><span class="lineNoCov">          0 :     allocate_new_chunk ();</span>
<span class="lineNum">     288 </span>            : 
<span class="lineNum">     289 </span><span class="lineNoCov">          0 :   char *dst = cur_chunk-&gt;data + cur_chunk-&gt;size;</span>
<span class="lineNum">     290 </span><span class="lineNoCov">          0 :   memcpy (dst, data, len);</span>
<span class="lineNum">     291 </span><span class="lineNoCov">          0 :   if (output)</span>
<span class="lineNum">     292 </span><span class="lineNoCov">          0 :     *output = dst;</span>
<span class="lineNum">     293 </span><span class="lineNoCov">          0 :   cur_chunk-&gt;size += len;</span>
<span class="lineNum">     294 </span><span class="lineNoCov">          0 :   total_size += len;</span>
<span class="lineNum">     295 </span>            : 
<span class="lineNum">     296 </span><span class="lineNoCov">          0 :   return offset;</span>
<span class="lineNum">     297 </span>            : }
<span class="lineNum">     298 </span>            : 
<span class="lineNum">     299 </span>            : /* Add padding to section so that its size is divisible by FACTOR.  */
<a name="300"><span class="lineNum">     300 </span>            : </a>
<span class="lineNum">     301 </span>            : void
<span class="lineNum">     302 </span><span class="lineNoCov">          0 : hsa_brig_section::round_size_up (int factor)</span>
<span class="lineNum">     303 </span>            : {
<span class="lineNum">     304 </span><span class="lineNoCov">          0 :   unsigned padding, res = total_size % factor;</span>
<span class="lineNum">     305 </span>            : 
<span class="lineNum">     306 </span><span class="lineNoCov">          0 :   if (res == 0)</span>
<span class="lineNum">     307 </span>            :     return;
<span class="lineNum">     308 </span>            : 
<span class="lineNum">     309 </span><span class="lineNoCov">          0 :   padding = factor - res;</span>
<span class="lineNum">     310 </span><span class="lineNoCov">          0 :   total_size += padding;</span>
<span class="lineNum">     311 </span><span class="lineNoCov">          0 :   if (cur_chunk-&gt;size &gt; (BRIG_CHUNK_MAX_SIZE - padding))</span>
<span class="lineNum">     312 </span>            :     {
<span class="lineNum">     313 </span><span class="lineNoCov">          0 :       padding -= BRIG_CHUNK_MAX_SIZE - cur_chunk-&gt;size;</span>
<span class="lineNum">     314 </span><span class="lineNoCov">          0 :       cur_chunk-&gt;size = BRIG_CHUNK_MAX_SIZE;</span>
<span class="lineNum">     315 </span><span class="lineNoCov">          0 :       allocate_new_chunk ();</span>
<span class="lineNum">     316 </span>            :     }
<span class="lineNum">     317 </span>            : 
<span class="lineNum">     318 </span><span class="lineNoCov">          0 :   cur_chunk-&gt;size += padding;</span>
<span class="lineNum">     319 </span>            : }
<span class="lineNum">     320 </span>            : 
<span class="lineNum">     321 </span>            : /* Return pointer to data by global OFFSET in the section.  */
<span class="lineNum">     322 </span>            : 
<span class="lineNum">     323 </span>            : void *
<span class="lineNum">     324 </span><span class="lineNoCov">          0 : hsa_brig_section::get_ptr_by_offset (unsigned int offset)</span>
<span class="lineNum">     325 </span>            : {
<span class="lineNum">     326 </span><span class="lineNoCov">          0 :   gcc_assert (offset &lt; total_size);</span>
<span class="lineNum">     327 </span><span class="lineNoCov">          0 :   offset -= header_byte_delta;</span>
<span class="lineNum">     328 </span>            : 
<span class="lineNum">     329 </span><span class="lineNoCov">          0 :   unsigned i;</span>
<span class="lineNum">     330 </span><span class="lineNoCov">          0 :   for (i = 0; offset &gt;= chunks[i].size; i++)</span>
<span class="lineNum">     331 </span><span class="lineNoCov">          0 :     offset -= chunks[i].size;</span>
<span class="lineNum">     332 </span>            : 
<span class="lineNum">     333 </span><span class="lineNoCov">          0 :   return chunks[i].data + offset;</span>
<span class="lineNum">     334 </span>            : }
<span class="lineNum">     335 </span>            : 
<span class="lineNum">     336 </span>            : /* BRIG string data hashing.  */
<span class="lineNum">     337 </span>            : 
<span class="lineNum">     338 </span>            : struct brig_string_slot
<span class="lineNum">     339 </span>            : {
<span class="lineNum">     340 </span>            :   const char *s;
<span class="lineNum">     341 </span>            :   char prefix;
<span class="lineNum">     342 </span>            :   int len;
<span class="lineNum">     343 </span>            :   uint32_t offset;
<span class="lineNum">     344 </span>            : };
<span class="lineNum">     345 </span>            : 
<span class="lineNum">     346 </span>            : /* Hash table helpers.  */
<span class="lineNum">     347 </span>            : 
<span class="lineNum">     348 </span>            : struct brig_string_slot_hasher : pointer_hash &lt;brig_string_slot&gt;
<span class="lineNum">     349 </span>            : {
<span class="lineNum">     350 </span>            :   static inline hashval_t hash (const value_type);
<span class="lineNum">     351 </span>            :   static inline bool equal (const value_type, const compare_type);
<span class="lineNum">     352 </span>            :   static inline void remove (value_type);
<span class="lineNum">     353 </span>            : };
<span class="lineNum">     354 </span>            : 
<span class="lineNum">     355 </span>            : /* Returns a hash code for DS.  Adapted from libiberty's htab_hash_string
<span class="lineNum">     356 </span>            :    to support strings that may not end in '\0'.  */
<span class="lineNum">     357 </span>            : 
<span class="lineNum">     358 </span>            : inline hashval_t
<span class="lineNum">     359 </span>            : brig_string_slot_hasher::hash (const value_type ds)
<span class="lineNum">     360 </span>            : {
<span class="lineNum">     361 </span><span class="lineNoCov">          0 :   hashval_t r = ds-&gt;len;</span>
<span class="lineNum">     362 </span><span class="lineNoCov">          0 :   int i;</span>
<span class="lineNum">     363 </span>            : 
<span class="lineNum">     364 </span><span class="lineNoCov">          0 :   for (i = 0; i &lt; ds-&gt;len; i++)</span>
<span class="lineNum">     365 </span><span class="lineNoCov">          0 :      r = r * 67 + (unsigned) ds-&gt;s[i] - 113;</span>
<span class="lineNum">     366 </span><span class="lineNoCov">          0 :   r = r * 67 + (unsigned) ds-&gt;prefix - 113;</span>
<span class="lineNum">     367 </span><span class="lineNoCov">          0 :   return r;</span>
<span class="lineNum">     368 </span>            : }
<span class="lineNum">     369 </span>            : 
<span class="lineNum">     370 </span>            : /* Returns nonzero if DS1 and DS2 are equal.  */
<a name="371"><span class="lineNum">     371 </span>            : </a>
<span class="lineNum">     372 </span>            : inline bool
<span class="lineNum">     373 </span><span class="lineNoCov">          0 : brig_string_slot_hasher::equal (const value_type ds1, const compare_type ds2)</span>
<span class="lineNum">     374 </span>            : {
<span class="lineNum">     375 </span><span class="lineNoCov">          0 :   if (ds1-&gt;len == ds2-&gt;len)</span>
<span class="lineNum">     376 </span><span class="lineNoCov">          0 :     return ds1-&gt;prefix == ds2-&gt;prefix</span>
<span class="lineNum">     377 </span><span class="lineNoCov">          0 :       &amp;&amp; memcmp (ds1-&gt;s, ds2-&gt;s, ds1-&gt;len) == 0;</span>
<span class="lineNum">     378 </span>            : 
<span class="lineNum">     379 </span>            :   return 0;
<span class="lineNum">     380 </span>            : }
<span class="lineNum">     381 </span>            : 
<span class="lineNum">     382 </span>            : /* Deallocate memory for DS upon its removal.  */
<span class="lineNum">     383 </span>            : 
<span class="lineNum">     384 </span>            : inline void
<span class="lineNum">     385 </span>            : brig_string_slot_hasher::remove (value_type ds)
<span class="lineNum">     386 </span>            : {
<span class="lineNum">     387 </span><span class="lineNoCov">          0 :   free (const_cast&lt;char *&gt; (ds-&gt;s));</span>
<span class="lineNum">     388 </span><span class="lineNoCov">          0 :   free (ds);</span>
<span class="lineNum">     389 </span>            : }
<span class="lineNum">     390 </span>            : 
<span class="lineNum">     391 </span>            : /* Hash for strings we output in order not to duplicate them needlessly.  */
<span class="lineNum">     392 </span>            : 
<span class="lineNum">     393 </span>            : static hash_table&lt;brig_string_slot_hasher&gt; *brig_string_htab;
<span class="lineNum">     394 </span>            : 
<span class="lineNum">     395 </span>            : /* Emit a null terminated string STR to the data section and return its
<span class="lineNum">     396 </span>            :    offset in it.  If PREFIX is non-zero, output it just before STR too.
<span class="lineNum">     397 </span>            :    Sanitize the string if SANITIZE option is set to true.  */
<a name="398"><span class="lineNum">     398 </span>            : </a>
<span class="lineNum">     399 </span>            : static unsigned
<span class="lineNum">     400 </span><span class="lineNoCov">          0 : brig_emit_string (const char *str, char prefix = 0, bool sanitize = true)</span>
<span class="lineNum">     401 </span>            : {
<span class="lineNum">     402 </span><span class="lineNoCov">          0 :   unsigned slen = strlen (str);</span>
<span class="lineNum">     403 </span><span class="lineNoCov">          0 :   unsigned offset, len = slen + (prefix ? 1 : 0);</span>
<span class="lineNum">     404 </span><span class="lineNoCov">          0 :   uint32_t hdr_len = lendian32 (len);</span>
<span class="lineNum">     405 </span><span class="lineNoCov">          0 :   brig_string_slot s_slot;</span>
<span class="lineNum">     406 </span><span class="lineNoCov">          0 :   brig_string_slot **slot;</span>
<span class="lineNum">     407 </span><span class="lineNoCov">          0 :   char *str2;</span>
<span class="lineNum">     408 </span>            : 
<span class="lineNum">     409 </span><span class="lineNoCov">          0 :   str2 = xstrdup (str);</span>
<span class="lineNum">     410 </span>            : 
<span class="lineNum">     411 </span><span class="lineNoCov">          0 :   if (sanitize)</span>
<span class="lineNum">     412 </span><span class="lineNoCov">          0 :     hsa_sanitize_name (str2);</span>
<span class="lineNum">     413 </span><span class="lineNoCov">          0 :   s_slot.s = str2;</span>
<span class="lineNum">     414 </span><span class="lineNoCov">          0 :   s_slot.len = slen;</span>
<span class="lineNum">     415 </span><span class="lineNoCov">          0 :   s_slot.prefix = prefix;</span>
<span class="lineNum">     416 </span><span class="lineNoCov">          0 :   s_slot.offset = 0;</span>
<span class="lineNum">     417 </span>            : 
<span class="lineNum">     418 </span><span class="lineNoCov">          0 :   slot = brig_string_htab-&gt;find_slot (&amp;s_slot, INSERT);</span>
<span class="lineNum">     419 </span><span class="lineNoCov">          0 :   if (*slot == NULL)</span>
<span class="lineNum">     420 </span>            :     {
<span class="lineNum">     421 </span><span class="lineNoCov">          0 :       brig_string_slot *new_slot = XCNEW (brig_string_slot);</span>
<span class="lineNum">     422 </span>            : 
<span class="lineNum">     423 </span>            :       /* In theory we should fill in BrigData but that would mean copying
<span class="lineNum">     424 </span>            :          the string to a buffer for no reason, so we just emulate it.  */
<span class="lineNum">     425 </span><span class="lineNoCov">          0 :       offset = brig_data.add (&amp;hdr_len, sizeof (hdr_len));</span>
<span class="lineNum">     426 </span><span class="lineNoCov">          0 :       if (prefix)</span>
<span class="lineNum">     427 </span><span class="lineNoCov">          0 :         brig_data.add (&amp;prefix, 1);</span>
<span class="lineNum">     428 </span>            : 
<span class="lineNum">     429 </span><span class="lineNoCov">          0 :       brig_data.add (str2, slen);</span>
<span class="lineNum">     430 </span><span class="lineNoCov">          0 :       brig_data.round_size_up (4);</span>
<span class="lineNum">     431 </span>            : 
<span class="lineNum">     432 </span>            :       /* TODO: could use the string we just copied into
<span class="lineNum">     433 </span>            :          brig_string-&gt;cur_chunk */
<span class="lineNum">     434 </span><span class="lineNoCov">          0 :       new_slot-&gt;s = str2;</span>
<span class="lineNum">     435 </span><span class="lineNoCov">          0 :       new_slot-&gt;len = slen;</span>
<span class="lineNum">     436 </span><span class="lineNoCov">          0 :       new_slot-&gt;prefix = prefix;</span>
<span class="lineNum">     437 </span><span class="lineNoCov">          0 :       new_slot-&gt;offset = offset;</span>
<span class="lineNum">     438 </span><span class="lineNoCov">          0 :       *slot = new_slot;</span>
<span class="lineNum">     439 </span>            :     }
<span class="lineNum">     440 </span>            :   else
<span class="lineNum">     441 </span>            :     {
<span class="lineNum">     442 </span><span class="lineNoCov">          0 :       offset = (*slot)-&gt;offset;</span>
<span class="lineNum">     443 </span><span class="lineNoCov">          0 :       free (str2);</span>
<span class="lineNum">     444 </span>            :     }
<span class="lineNum">     445 </span>            : 
<span class="lineNum">     446 </span><span class="lineNoCov">          0 :   return offset;</span>
<span class="lineNum">     447 </span>            : }
<span class="lineNum">     448 </span>            : 
<span class="lineNum">     449 </span>            : /* Linked list of queued operands.  */
<span class="lineNum">     450 </span>            : 
<span class="lineNum">     451 </span>            : static struct operand_queue
<span class="lineNum">     452 </span>            : {
<span class="lineNum">     453 </span>            :   /* First from the chain of queued operands.  */
<span class="lineNum">     454 </span>            :   hsa_op_base *first_op, *last_op;
<span class="lineNum">     455 </span>            : 
<span class="lineNum">     456 </span>            :   /* The offset at which the next operand will be enqueued.  */
<span class="lineNum">     457 </span>            :   unsigned projected_size;
<span class="lineNum">     458 </span>            : 
<span class="lineNum">     459 </span>            : } op_queue;
<span class="lineNum">     460 </span>            : 
<span class="lineNum">     461 </span>            : /* Unless already initialized, initialize infrastructure to produce BRIG.  */
<a name="462"><span class="lineNum">     462 </span>            : </a>
<span class="lineNum">     463 </span>            : static void
<span class="lineNum">     464 </span><span class="lineNoCov">          0 : brig_init (void)</span>
<span class="lineNum">     465 </span>            : {
<span class="lineNum">     466 </span><span class="lineNoCov">          0 :   brig_insn_count = 0;</span>
<span class="lineNum">     467 </span>            : 
<span class="lineNum">     468 </span><span class="lineNoCov">          0 :   if (brig_initialized)</span>
<span class="lineNum">     469 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">     470 </span>            : 
<span class="lineNum">     471 </span><span class="lineNoCov">          0 :   brig_string_htab = new hash_table&lt;brig_string_slot_hasher&gt; (37);</span>
<span class="lineNum">     472 </span><span class="lineNoCov">          0 :   brig_data.init (BRIG_SECTION_DATA_NAME);</span>
<span class="lineNum">     473 </span><span class="lineNoCov">          0 :   brig_code.init (BRIG_SECTION_CODE_NAME);</span>
<span class="lineNum">     474 </span><span class="lineNoCov">          0 :   brig_operand.init (BRIG_SECTION_OPERAND_NAME);</span>
<span class="lineNum">     475 </span><span class="lineNoCov">          0 :   brig_initialized = true;</span>
<span class="lineNum">     476 </span>            : 
<span class="lineNum">     477 </span><span class="lineNoCov">          0 :   struct BrigDirectiveModule moddir;</span>
<span class="lineNum">     478 </span><span class="lineNoCov">          0 :   memset (&amp;moddir, 0, sizeof (moddir));</span>
<span class="lineNum">     479 </span><span class="lineNoCov">          0 :   moddir.base.byteCount = lendian16 (sizeof (moddir));</span>
<span class="lineNum">     480 </span>            : 
<span class="lineNum">     481 </span><span class="lineNoCov">          0 :   char *modname;</span>
<span class="lineNum">     482 </span><span class="lineNoCov">          0 :   if (main_input_filename &amp;&amp; *main_input_filename != '\0')</span>
<span class="lineNum">     483 </span>            :     {
<span class="lineNum">     484 </span><span class="lineNoCov">          0 :       const char *part = strrchr (main_input_filename, '/');</span>
<span class="lineNum">     485 </span><span class="lineNoCov">          0 :       if (!part)</span>
<span class="lineNum">     486 </span>            :         part = main_input_filename;
<span class="lineNum">     487 </span>            :       else
<span class="lineNum">     488 </span><span class="lineNoCov">          0 :         part++;</span>
<span class="lineNum">     489 </span><span class="lineNoCov">          0 :       modname = concat (&quot;&amp;__hsa_module_&quot;, part, NULL);</span>
<span class="lineNum">     490 </span><span class="lineNoCov">          0 :       char *extension = strchr (modname, '.');</span>
<span class="lineNum">     491 </span><span class="lineNoCov">          0 :       if (extension)</span>
<span class="lineNum">     492 </span><span class="lineNoCov">          0 :         *extension = '\0';</span>
<span class="lineNum">     493 </span>            : 
<span class="lineNum">     494 </span>            :       /* As in LTO mode, we have to emit a different module names.  */
<span class="lineNum">     495 </span><span class="lineNoCov">          0 :       if (flag_ltrans)</span>
<span class="lineNum">     496 </span>            :         {
<span class="lineNum">     497 </span><span class="lineNoCov">          0 :           part = strrchr (asm_file_name, '/');</span>
<span class="lineNum">     498 </span><span class="lineNoCov">          0 :           if (!part)</span>
<span class="lineNum">     499 </span>            :             part = asm_file_name;
<span class="lineNum">     500 </span>            :           else
<span class="lineNum">     501 </span><span class="lineNoCov">          0 :             part++;</span>
<span class="lineNum">     502 </span><span class="lineNoCov">          0 :           char *modname2;</span>
<span class="lineNum">     503 </span><span class="lineNoCov">          0 :           modname2 = xasprintf (&quot;%s_%s&quot;, modname, part);</span>
<span class="lineNum">     504 </span><span class="lineNoCov">          0 :           free (modname);</span>
<span class="lineNum">     505 </span><span class="lineNoCov">          0 :           modname = modname2;</span>
<span class="lineNum">     506 </span>            :         }
<span class="lineNum">     507 </span>            : 
<span class="lineNum">     508 </span><span class="lineNoCov">          0 :       hsa_sanitize_name (modname);</span>
<span class="lineNum">     509 </span><span class="lineNoCov">          0 :       moddir.name = brig_emit_string (modname);</span>
<span class="lineNum">     510 </span><span class="lineNoCov">          0 :       free (modname);</span>
<span class="lineNum">     511 </span>            :     }
<span class="lineNum">     512 </span>            :   else
<span class="lineNum">     513 </span><span class="lineNoCov">          0 :     moddir.name = brig_emit_string (&quot;__hsa_module_unnamed&quot;, '&amp;');</span>
<span class="lineNum">     514 </span><span class="lineNoCov">          0 :   moddir.base.kind = lendian16 (BRIG_KIND_DIRECTIVE_MODULE);</span>
<span class="lineNum">     515 </span><span class="lineNoCov">          0 :   moddir.hsailMajor = lendian32 (BRIG_VERSION_HSAIL_MAJOR);</span>
<span class="lineNum">     516 </span><span class="lineNoCov">          0 :   moddir.hsailMinor = lendian32 (BRIG_VERSION_HSAIL_MINOR);</span>
<span class="lineNum">     517 </span><span class="lineNoCov">          0 :   moddir.profile = hsa_full_profile_p () ? BRIG_PROFILE_FULL: BRIG_PROFILE_BASE;</span>
<span class="lineNum">     518 </span><span class="lineNoCov">          0 :   if (hsa_machine_large_p ())</span>
<span class="lineNum">     519 </span><span class="lineNoCov">          0 :     moddir.machineModel = BRIG_MACHINE_LARGE;</span>
<span class="lineNum">     520 </span>            :   else
<span class="lineNum">     521 </span><span class="lineNoCov">          0 :     moddir.machineModel = BRIG_MACHINE_SMALL;</span>
<span class="lineNum">     522 </span><span class="lineNoCov">          0 :   moddir.defaultFloatRound = BRIG_ROUND_FLOAT_DEFAULT;</span>
<span class="lineNum">     523 </span><span class="lineNoCov">          0 :   brig_code.add (&amp;moddir, sizeof (moddir));</span>
<span class="lineNum">     524 </span>            : }
<span class="lineNum">     525 </span>            : 
<span class="lineNum">     526 </span>            : /* Free all BRIG data.  */
<a name="527"><span class="lineNum">     527 </span>            : </a>
<span class="lineNum">     528 </span>            : static void
<span class="lineNum">     529 </span><span class="lineNoCov">          0 : brig_release_data (void)</span>
<span class="lineNum">     530 </span>            : {
<span class="lineNum">     531 </span><span class="lineNoCov">          0 :   delete brig_string_htab;</span>
<span class="lineNum">     532 </span><span class="lineNoCov">          0 :   brig_data.release ();</span>
<span class="lineNum">     533 </span><span class="lineNoCov">          0 :   brig_code.release ();</span>
<span class="lineNum">     534 </span><span class="lineNoCov">          0 :   brig_operand.release ();</span>
<span class="lineNum">     535 </span>            : 
<span class="lineNum">     536 </span><span class="lineNoCov">          0 :   brig_initialized = 0;</span>
<span class="lineNum">     537 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     538 </span>            : 
<span class="lineNum">     539 </span>            : /* Enqueue operation OP.  Return the offset at which it will be stored.  */
<a name="540"><span class="lineNum">     540 </span>            : </a>
<span class="lineNum">     541 </span>            : static unsigned int
<span class="lineNum">     542 </span><span class="lineNoCov">          0 : enqueue_op (hsa_op_base *op)</span>
<span class="lineNum">     543 </span>            : {
<span class="lineNum">     544 </span><span class="lineNoCov">          0 :   unsigned ret;</span>
<span class="lineNum">     545 </span>            : 
<span class="lineNum">     546 </span><span class="lineNoCov">          0 :   if (op-&gt;m_brig_op_offset)</span>
<span class="lineNum">     547 </span>            :     return op-&gt;m_brig_op_offset;
<span class="lineNum">     548 </span>            : 
<span class="lineNum">     549 </span><span class="lineNoCov">          0 :   ret = op_queue.projected_size;</span>
<span class="lineNum">     550 </span><span class="lineNoCov">          0 :   op-&gt;m_brig_op_offset = op_queue.projected_size;</span>
<span class="lineNum">     551 </span>            : 
<span class="lineNum">     552 </span><span class="lineNoCov">          0 :   if (!op_queue.first_op)</span>
<span class="lineNum">     553 </span><span class="lineNoCov">          0 :     op_queue.first_op = op;</span>
<span class="lineNum">     554 </span>            :   else
<span class="lineNum">     555 </span><span class="lineNoCov">          0 :     op_queue.last_op-&gt;m_next = op;</span>
<span class="lineNum">     556 </span><span class="lineNoCov">          0 :   op_queue.last_op = op;</span>
<span class="lineNum">     557 </span>            : 
<span class="lineNum">     558 </span><span class="lineNoCov">          0 :   if (is_a &lt;hsa_op_immed *&gt; (op))</span>
<span class="lineNum">     559 </span><span class="lineNoCov">          0 :     op_queue.projected_size += sizeof (struct BrigOperandConstantBytes);</span>
<span class="lineNum">     560 </span><span class="lineNoCov">          0 :   else if (is_a &lt;hsa_op_reg *&gt; (op))</span>
<span class="lineNum">     561 </span><span class="lineNoCov">          0 :     op_queue.projected_size += sizeof (struct BrigOperandRegister);</span>
<span class="lineNum">     562 </span><span class="lineNoCov">          0 :   else if (is_a &lt;hsa_op_address *&gt; (op))</span>
<span class="lineNum">     563 </span><span class="lineNoCov">          0 :     op_queue.projected_size += sizeof (struct BrigOperandAddress);</span>
<span class="lineNum">     564 </span><span class="lineNoCov">          0 :   else if (is_a &lt;hsa_op_code_ref *&gt; (op))</span>
<span class="lineNum">     565 </span><span class="lineNoCov">          0 :     op_queue.projected_size += sizeof (struct BrigOperandCodeRef);</span>
<span class="lineNum">     566 </span><span class="lineNoCov">          0 :   else if (is_a &lt;hsa_op_code_list *&gt; (op))</span>
<span class="lineNum">     567 </span><span class="lineNoCov">          0 :     op_queue.projected_size += sizeof (struct BrigOperandCodeList);</span>
<span class="lineNum">     568 </span><span class="lineNoCov">          0 :   else if (is_a &lt;hsa_op_operand_list *&gt; (op))</span>
<span class="lineNum">     569 </span><span class="lineNoCov">          0 :     op_queue.projected_size += sizeof (struct BrigOperandOperandList);</span>
<span class="lineNum">     570 </span>            :   else
<span class="lineNum">     571 </span><span class="lineNoCov">          0 :     gcc_unreachable ();</span>
<span class="lineNum">     572 </span>            :   return ret;
<span class="lineNum">     573 </span>            : }
<span class="lineNum">     574 </span>            : 
<span class="lineNum">     575 </span>            : static void emit_immediate_operand (hsa_op_immed *imm);
<span class="lineNum">     576 </span>            : 
<span class="lineNum">     577 </span>            : /* Emit directive describing a symbol if it has not been emitted already.
<span class="lineNum">     578 </span>            :    Return the offset of the directive.  */
<a name="579"><span class="lineNum">     579 </span>            : </a>
<span class="lineNum">     580 </span>            : static unsigned
<span class="lineNum">     581 </span><span class="lineNoCov">          0 : emit_directive_variable (struct hsa_symbol *symbol)</span>
<span class="lineNum">     582 </span>            : {
<span class="lineNum">     583 </span><span class="lineNoCov">          0 :   struct BrigDirectiveVariable dirvar;</span>
<span class="lineNum">     584 </span><span class="lineNoCov">          0 :   unsigned name_offset;</span>
<span class="lineNum">     585 </span><span class="lineNoCov">          0 :   static unsigned res_name_offset;</span>
<span class="lineNum">     586 </span>            : 
<span class="lineNum">     587 </span><span class="lineNoCov">          0 :   if (symbol-&gt;m_directive_offset)</span>
<span class="lineNum">     588 </span>            :     return symbol-&gt;m_directive_offset;
<span class="lineNum">     589 </span>            : 
<span class="lineNum">     590 </span><span class="lineNoCov">          0 :   memset (&amp;dirvar, 0, sizeof (dirvar));</span>
<span class="lineNum">     591 </span><span class="lineNoCov">          0 :   dirvar.base.byteCount = lendian16 (sizeof (dirvar));</span>
<span class="lineNum">     592 </span><span class="lineNoCov">          0 :   dirvar.base.kind = lendian16 (BRIG_KIND_DIRECTIVE_VARIABLE);</span>
<span class="lineNum">     593 </span><span class="lineNoCov">          0 :   dirvar.allocation = symbol-&gt;m_allocation;</span>
<span class="lineNum">     594 </span>            : 
<span class="lineNum">     595 </span><span class="lineNoCov">          0 :   char prefix = symbol-&gt;m_global_scope_p ? '&amp;' : '%';</span>
<span class="lineNum">     596 </span>            : 
<span class="lineNum">     597 </span><span class="lineNoCov">          0 :   if (symbol-&gt;m_decl &amp;&amp; TREE_CODE (symbol-&gt;m_decl) == RESULT_DECL)</span>
<span class="lineNum">     598 </span>            :     {
<span class="lineNum">     599 </span><span class="lineNoCov">          0 :       if (res_name_offset == 0)</span>
<span class="lineNum">     600 </span><span class="lineNoCov">          0 :         res_name_offset = brig_emit_string (symbol-&gt;m_name, '%');</span>
<span class="lineNum">     601 </span><span class="lineNoCov">          0 :       name_offset = res_name_offset;</span>
<span class="lineNum">     602 </span>            :     }
<span class="lineNum">     603 </span><span class="lineNoCov">          0 :   else if (symbol-&gt;m_name)</span>
<span class="lineNum">     604 </span><span class="lineNoCov">          0 :     name_offset = brig_emit_string (symbol-&gt;m_name, prefix);</span>
<span class="lineNum">     605 </span>            :   else
<span class="lineNum">     606 </span>            :     {
<span class="lineNum">     607 </span><span class="lineNoCov">          0 :       char buf[64];</span>
<span class="lineNum">     608 </span><span class="lineNoCov">          0 :       snprintf (buf, 64, &quot;__%s_%i&quot;, hsa_seg_name (symbol-&gt;m_segment),</span>
<span class="lineNum">     609 </span>            :                 symbol-&gt;m_name_number);
<span class="lineNum">     610 </span><span class="lineNoCov">          0 :       name_offset = brig_emit_string (buf, prefix);</span>
<span class="lineNum">     611 </span>            :     }
<span class="lineNum">     612 </span>            : 
<span class="lineNum">     613 </span><span class="lineNoCov">          0 :   dirvar.name = lendian32 (name_offset);</span>
<span class="lineNum">     614 </span>            : 
<span class="lineNum">     615 </span><span class="lineNoCov">          0 :   if (symbol-&gt;m_decl &amp;&amp; TREE_CODE (symbol-&gt;m_decl) == CONST_DECL)</span>
<span class="lineNum">     616 </span>            :     {
<span class="lineNum">     617 </span><span class="lineNoCov">          0 :       hsa_op_immed *tmp = new hsa_op_immed (DECL_INITIAL (symbol-&gt;m_decl));</span>
<span class="lineNum">     618 </span><span class="lineNoCov">          0 :       dirvar.init = lendian32 (enqueue_op (tmp));</span>
<span class="lineNum">     619 </span>            :     }
<span class="lineNum">     620 </span>            :   else
<span class="lineNum">     621 </span><span class="lineNoCov">          0 :     dirvar.init = 0;</span>
<span class="lineNum">     622 </span><span class="lineNoCov">          0 :   dirvar.type = lendian16 (symbol-&gt;m_type);</span>
<span class="lineNum">     623 </span><span class="lineNoCov">          0 :   dirvar.segment = symbol-&gt;m_segment;</span>
<span class="lineNum">     624 </span><span class="lineNoCov">          0 :   dirvar.align = symbol-&gt;m_align;</span>
<span class="lineNum">     625 </span><span class="lineNoCov">          0 :   dirvar.linkage = symbol-&gt;m_linkage;</span>
<span class="lineNum">     626 </span><span class="lineNoCov">          0 :   dirvar.dim.lo = symbol-&gt;m_dim;</span>
<span class="lineNum">     627 </span><span class="lineNoCov">          0 :   dirvar.dim.hi = symbol-&gt;m_dim &gt;&gt; 32;</span>
<span class="lineNum">     628 </span>            : 
<span class="lineNum">     629 </span>            :   /* Global variables are just declared and linked via HSA runtime.  */
<span class="lineNum">     630 </span><span class="lineNoCov">          0 :   if (symbol-&gt;m_linkage != BRIG_ALLOCATION_PROGRAM)</span>
<span class="lineNum">     631 </span><span class="lineNoCov">          0 :     dirvar.modifier |= BRIG_VARIABLE_DEFINITION;</span>
<span class="lineNum">     632 </span><span class="lineNoCov">          0 :   dirvar.reserved = 0;</span>
<span class="lineNum">     633 </span>            : 
<span class="lineNum">     634 </span><span class="lineNoCov">          0 :   if (symbol-&gt;m_cst_value)</span>
<span class="lineNum">     635 </span>            :     {
<span class="lineNum">     636 </span><span class="lineNoCov">          0 :       dirvar.modifier |= BRIG_VARIABLE_CONST;</span>
<span class="lineNum">     637 </span><span class="lineNoCov">          0 :       dirvar.init = lendian32 (enqueue_op (symbol-&gt;m_cst_value));</span>
<span class="lineNum">     638 </span>            :     }
<span class="lineNum">     639 </span>            : 
<span class="lineNum">     640 </span><span class="lineNoCov">          0 :   symbol-&gt;m_directive_offset = brig_code.add (&amp;dirvar, sizeof (dirvar));</span>
<span class="lineNum">     641 </span><span class="lineNoCov">          0 :   return symbol-&gt;m_directive_offset;</span>
<span class="lineNum">     642 </span>            : }
<span class="lineNum">     643 </span>            : 
<span class="lineNum">     644 </span>            : /* Emit directives describing either a function declaration or definition F and
<span class="lineNum">     645 </span>            :    return the produced BrigDirectiveExecutable structure.  The function does
<span class="lineNum">     646 </span>            :    not take into account any instructions when calculating nextModuleEntry
<span class="lineNum">     647 </span>            :    field of the produced BrigDirectiveExecutable structure so when emitting
<span class="lineNum">     648 </span>            :    actual definitions, this field needs to be updated after all of the function
<span class="lineNum">     649 </span>            :    is actually added to the code section.  */
<span class="lineNum">     650 </span>            : 
<span class="lineNum">     651 </span>            : static BrigDirectiveExecutable *
<span class="lineNum">     652 </span><span class="lineNoCov">          0 : emit_function_directives (hsa_function_representation *f, bool is_declaration)</span>
<span class="lineNum">     653 </span>            : {
<span class="lineNum">     654 </span><span class="lineNoCov">          0 :   struct BrigDirectiveExecutable fndir;</span>
<span class="lineNum">     655 </span><span class="lineNoCov">          0 :   unsigned name_offset, inarg_off, scoped_off, next_toplev_off;</span>
<span class="lineNum">     656 </span><span class="lineNoCov">          0 :   int count = 0;</span>
<span class="lineNum">     657 </span><span class="lineNoCov">          0 :   void *ptr_to_fndir;</span>
<span class="lineNum">     658 </span><span class="lineNoCov">          0 :   hsa_symbol *sym;</span>
<span class="lineNum">     659 </span>            : 
<span class="lineNum">     660 </span><span class="lineNoCov">          0 :   if (!f-&gt;m_declaration_p)</span>
<span class="lineNum">     661 </span><span class="lineNoCov">          0 :     for (int i = 0; f-&gt;m_global_symbols.iterate (i, &amp;sym); i++)</span>
<span class="lineNum">     662 </span>            :       {
<span class="lineNum">     663 </span><span class="lineNoCov">          0 :         gcc_assert (!sym-&gt;m_emitted_to_brig);</span>
<span class="lineNum">     664 </span><span class="lineNoCov">          0 :         sym-&gt;m_emitted_to_brig = true;</span>
<span class="lineNum">     665 </span><span class="lineNoCov">          0 :         emit_directive_variable (sym);</span>
<span class="lineNum">     666 </span><span class="lineNoCov">          0 :         brig_insn_count++;</span>
<span class="lineNum">     667 </span>            :       }
<span class="lineNum">     668 </span>            : 
<span class="lineNum">     669 </span><span class="lineNoCov">          0 :   name_offset = brig_emit_string (f-&gt;m_name, '&amp;');</span>
<span class="lineNum">     670 </span><span class="lineNoCov">          0 :   inarg_off = brig_code.total_size + sizeof (fndir)</span>
<span class="lineNum">     671 </span><span class="lineNoCov">          0 :     + (f-&gt;m_output_arg ? sizeof (struct BrigDirectiveVariable) : 0);</span>
<span class="lineNum">     672 </span><span class="lineNoCov">          0 :   scoped_off = inarg_off</span>
<span class="lineNum">     673 </span><span class="lineNoCov">          0 :     + f-&gt;m_input_args.length () * sizeof (struct BrigDirectiveVariable);</span>
<span class="lineNum">     674 </span>            : 
<span class="lineNum">     675 </span><span class="lineNoCov">          0 :   if (!f-&gt;m_declaration_p)</span>
<span class="lineNum">     676 </span>            :     {
<span class="lineNum">     677 </span><span class="lineNoCov">          0 :       count += f-&gt;m_spill_symbols.length ();</span>
<span class="lineNum">     678 </span><span class="lineNoCov">          0 :       count += f-&gt;m_private_variables.length ();</span>
<span class="lineNum">     679 </span>            :     }
<span class="lineNum">     680 </span>            : 
<span class="lineNum">     681 </span><span class="lineNoCov">          0 :   next_toplev_off = scoped_off + count * sizeof (struct BrigDirectiveVariable);</span>
<span class="lineNum">     682 </span>            : 
<span class="lineNum">     683 </span><span class="lineNoCov">          0 :   memset (&amp;fndir, 0, sizeof (fndir));</span>
<span class="lineNum">     684 </span><span class="lineNoCov">          0 :   fndir.base.byteCount = lendian16 (sizeof (fndir));</span>
<span class="lineNum">     685 </span><span class="lineNoCov">          0 :   fndir.base.kind = lendian16 (f-&gt;m_kern_p ? BRIG_KIND_DIRECTIVE_KERNEL</span>
<span class="lineNum">     686 </span>            :                                : BRIG_KIND_DIRECTIVE_FUNCTION);
<span class="lineNum">     687 </span><span class="lineNoCov">          0 :   fndir.name = lendian32 (name_offset);</span>
<span class="lineNum">     688 </span><span class="lineNoCov">          0 :   fndir.inArgCount = lendian16 (f-&gt;m_input_args.length ());</span>
<span class="lineNum">     689 </span><span class="lineNoCov">          0 :   fndir.outArgCount = lendian16 (f-&gt;m_output_arg ? 1 : 0);</span>
<span class="lineNum">     690 </span><span class="lineNoCov">          0 :   fndir.firstInArg = lendian32 (inarg_off);</span>
<span class="lineNum">     691 </span><span class="lineNoCov">          0 :   fndir.firstCodeBlockEntry = lendian32 (scoped_off);</span>
<span class="lineNum">     692 </span><span class="lineNoCov">          0 :   fndir.nextModuleEntry = lendian32 (next_toplev_off);</span>
<span class="lineNum">     693 </span><span class="lineNoCov">          0 :   fndir.linkage = f-&gt;get_linkage ();</span>
<span class="lineNum">     694 </span><span class="lineNoCov">          0 :   if (!f-&gt;m_declaration_p)</span>
<span class="lineNum">     695 </span><span class="lineNoCov">          0 :     fndir.modifier |= BRIG_EXECUTABLE_DEFINITION;</span>
<span class="lineNum">     696 </span><span class="lineNoCov">          0 :   memset (&amp;fndir.reserved, 0, sizeof (fndir.reserved));</span>
<span class="lineNum">     697 </span>            : 
<span class="lineNum">     698 </span>            :   /* Once we put a definition of function_offsets, we should not overwrite
<span class="lineNum">     699 </span>            :      it with a declaration of the function.  */
<span class="lineNum">     700 </span><span class="lineNoCov">          0 :   if (f-&gt;m_internal_fn == NULL)</span>
<span class="lineNum">     701 </span>            :     {
<span class="lineNum">     702 </span><span class="lineNoCov">          0 :       if (!function_offsets-&gt;get (f-&gt;m_decl) || !is_declaration)</span>
<span class="lineNum">     703 </span><span class="lineNoCov">          0 :         function_offsets-&gt;put (f-&gt;m_decl, brig_code.total_size);</span>
<span class="lineNum">     704 </span>            :     }
<span class="lineNum">     705 </span>            :   else
<span class="lineNum">     706 </span>            :     {
<span class="lineNum">     707 </span>            :       /* Internal function.  */
<span class="lineNum">     708 </span><span class="lineNoCov">          0 :       hsa_internal_fn **slot</span>
<span class="lineNum">     709 </span><span class="lineNoCov">          0 :         = hsa_emitted_internal_decls-&gt;find_slot (f-&gt;m_internal_fn, INSERT);</span>
<span class="lineNum">     710 </span><span class="lineNoCov">          0 :       hsa_internal_fn *int_fn = new hsa_internal_fn (f-&gt;m_internal_fn);</span>
<span class="lineNum">     711 </span><span class="lineNoCov">          0 :       int_fn-&gt;m_offset = brig_code.total_size;</span>
<span class="lineNum">     712 </span><span class="lineNoCov">          0 :       *slot = int_fn;</span>
<span class="lineNum">     713 </span>            :     }
<span class="lineNum">     714 </span>            : 
<span class="lineNum">     715 </span><span class="lineNoCov">          0 :   brig_code.add (&amp;fndir, sizeof (fndir), &amp;ptr_to_fndir);</span>
<span class="lineNum">     716 </span>            : 
<span class="lineNum">     717 </span><span class="lineNoCov">          0 :   if (f-&gt;m_output_arg)</span>
<span class="lineNum">     718 </span><span class="lineNoCov">          0 :     emit_directive_variable (f-&gt;m_output_arg);</span>
<span class="lineNum">     719 </span><span class="lineNoCov">          0 :   for (unsigned i = 0; i &lt; f-&gt;m_input_args.length (); i++)</span>
<span class="lineNum">     720 </span><span class="lineNoCov">          0 :     emit_directive_variable (f-&gt;m_input_args[i]);</span>
<span class="lineNum">     721 </span>            : 
<span class="lineNum">     722 </span><span class="lineNoCov">          0 :   if (!f-&gt;m_declaration_p)</span>
<span class="lineNum">     723 </span>            :     {
<span class="lineNum">     724 </span><span class="lineNoCov">          0 :       for (int i = 0; f-&gt;m_spill_symbols.iterate (i, &amp;sym); i++)</span>
<span class="lineNum">     725 </span>            :         {
<span class="lineNum">     726 </span><span class="lineNoCov">          0 :           emit_directive_variable (sym);</span>
<span class="lineNum">     727 </span><span class="lineNoCov">          0 :           brig_insn_count++;</span>
<span class="lineNum">     728 </span>            :         }
<span class="lineNum">     729 </span><span class="lineNoCov">          0 :       for (unsigned i = 0; i &lt; f-&gt;m_private_variables.length (); i++)</span>
<span class="lineNum">     730 </span>            :         {
<span class="lineNum">     731 </span><span class="lineNoCov">          0 :           emit_directive_variable (f-&gt;m_private_variables[i]);</span>
<span class="lineNum">     732 </span><span class="lineNoCov">          0 :           brig_insn_count++;</span>
<span class="lineNum">     733 </span>            :         }
<span class="lineNum">     734 </span>            :     }
<span class="lineNum">     735 </span>            : 
<span class="lineNum">     736 </span><span class="lineNoCov">          0 :   return (BrigDirectiveExecutable *) ptr_to_fndir;</span>
<span class="lineNum">     737 </span>            : }
<span class="lineNum">     738 </span>            : 
<span class="lineNum">     739 </span>            : /* Emit a label directive for the given HBB.  We assume it is about to start on
<span class="lineNum">     740 </span>            :    the current offset in the code section.  */
<a name="741"><span class="lineNum">     741 </span>            : </a>
<span class="lineNum">     742 </span>            : static void
<span class="lineNum">     743 </span><span class="lineNoCov">          0 : emit_bb_label_directive (hsa_bb *hbb)</span>
<span class="lineNum">     744 </span>            : {
<span class="lineNum">     745 </span><span class="lineNoCov">          0 :   struct BrigDirectiveLabel lbldir;</span>
<span class="lineNum">     746 </span>            : 
<span class="lineNum">     747 </span><span class="lineNoCov">          0 :   lbldir.base.byteCount = lendian16 (sizeof (lbldir));</span>
<span class="lineNum">     748 </span><span class="lineNoCov">          0 :   lbldir.base.kind = lendian16 (BRIG_KIND_DIRECTIVE_LABEL);</span>
<span class="lineNum">     749 </span><span class="lineNoCov">          0 :   char buf[32];</span>
<span class="lineNum">     750 </span><span class="lineNoCov">          0 :   snprintf (buf, 32, &quot;BB_%u_%i&quot;, DECL_UID (current_function_decl),</span>
<span class="lineNum">     751 </span>            :             hbb-&gt;m_index);
<span class="lineNum">     752 </span><span class="lineNoCov">          0 :   lbldir.name = lendian32 (brig_emit_string (buf, '@'));</span>
<span class="lineNum">     753 </span>            : 
<span class="lineNum">     754 </span><span class="lineNoCov">          0 :   hbb-&gt;m_label_ref.m_directive_offset = brig_code.add (&amp;lbldir,</span>
<span class="lineNum">     755 </span>            :                                                        sizeof (lbldir));
<span class="lineNum">     756 </span><span class="lineNoCov">          0 :   brig_insn_count++;</span>
<span class="lineNum">     757 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     758 </span>            : 
<span class="lineNum">     759 </span>            : /* Map a normal HSAIL type to the type of the equivalent BRIG operand
<span class="lineNum">     760 </span>            :    holding such, for constants and registers.  */
<a name="761"><span class="lineNum">     761 </span>            : </a>
<span class="lineNum">     762 </span>            : static BrigType16_t
<span class="lineNum">     763 </span><span class="lineNoCov">          0 : regtype_for_type (BrigType16_t t)</span>
<span class="lineNum">     764 </span>            : {
<span class="lineNum">     765 </span><span class="lineNoCov">          0 :   switch (t)</span>
<span class="lineNum">     766 </span>            :     {
<span class="lineNum">     767 </span>            :     case BRIG_TYPE_B1:
<span class="lineNum">     768 </span>            :       return BRIG_TYPE_B1;
<span class="lineNum">     769 </span>            : 
<span class="lineNum">     770 </span><span class="lineNoCov">          0 :     case BRIG_TYPE_U8:</span>
<span class="lineNum">     771 </span><span class="lineNoCov">          0 :     case BRIG_TYPE_U16:</span>
<span class="lineNum">     772 </span><span class="lineNoCov">          0 :     case BRIG_TYPE_U32:</span>
<span class="lineNum">     773 </span><span class="lineNoCov">          0 :     case BRIG_TYPE_S8:</span>
<span class="lineNum">     774 </span><span class="lineNoCov">          0 :     case BRIG_TYPE_S16:</span>
<span class="lineNum">     775 </span><span class="lineNoCov">          0 :     case BRIG_TYPE_S32:</span>
<span class="lineNum">     776 </span><span class="lineNoCov">          0 :     case BRIG_TYPE_B8:</span>
<span class="lineNum">     777 </span><span class="lineNoCov">          0 :     case BRIG_TYPE_B16:</span>
<span class="lineNum">     778 </span><span class="lineNoCov">          0 :     case BRIG_TYPE_B32:</span>
<span class="lineNum">     779 </span><span class="lineNoCov">          0 :     case BRIG_TYPE_F16:</span>
<span class="lineNum">     780 </span><span class="lineNoCov">          0 :     case BRIG_TYPE_F32:</span>
<span class="lineNum">     781 </span><span class="lineNoCov">          0 :     case BRIG_TYPE_U8X4:</span>
<span class="lineNum">     782 </span><span class="lineNoCov">          0 :     case BRIG_TYPE_U16X2:</span>
<span class="lineNum">     783 </span><span class="lineNoCov">          0 :     case BRIG_TYPE_S8X4:</span>
<span class="lineNum">     784 </span><span class="lineNoCov">          0 :     case BRIG_TYPE_S16X2:</span>
<span class="lineNum">     785 </span><span class="lineNoCov">          0 :     case BRIG_TYPE_F16X2:</span>
<span class="lineNum">     786 </span><span class="lineNoCov">          0 :       return BRIG_TYPE_B32;</span>
<span class="lineNum">     787 </span>            : 
<span class="lineNum">     788 </span><span class="lineNoCov">          0 :     case BRIG_TYPE_U64:</span>
<span class="lineNum">     789 </span><span class="lineNoCov">          0 :     case BRIG_TYPE_S64:</span>
<span class="lineNum">     790 </span><span class="lineNoCov">          0 :     case BRIG_TYPE_F64:</span>
<span class="lineNum">     791 </span><span class="lineNoCov">          0 :     case BRIG_TYPE_B64:</span>
<span class="lineNum">     792 </span><span class="lineNoCov">          0 :     case BRIG_TYPE_U8X8:</span>
<span class="lineNum">     793 </span><span class="lineNoCov">          0 :     case BRIG_TYPE_U16X4:</span>
<span class="lineNum">     794 </span><span class="lineNoCov">          0 :     case BRIG_TYPE_U32X2:</span>
<span class="lineNum">     795 </span><span class="lineNoCov">          0 :     case BRIG_TYPE_S8X8:</span>
<span class="lineNum">     796 </span><span class="lineNoCov">          0 :     case BRIG_TYPE_S16X4:</span>
<span class="lineNum">     797 </span><span class="lineNoCov">          0 :     case BRIG_TYPE_S32X2:</span>
<span class="lineNum">     798 </span><span class="lineNoCov">          0 :     case BRIG_TYPE_F16X4:</span>
<span class="lineNum">     799 </span><span class="lineNoCov">          0 :     case BRIG_TYPE_F32X2:</span>
<span class="lineNum">     800 </span><span class="lineNoCov">          0 :       return BRIG_TYPE_B64;</span>
<span class="lineNum">     801 </span>            : 
<span class="lineNum">     802 </span><span class="lineNoCov">          0 :     case BRIG_TYPE_B128:</span>
<span class="lineNum">     803 </span><span class="lineNoCov">          0 :     case BRIG_TYPE_U8X16:</span>
<span class="lineNum">     804 </span><span class="lineNoCov">          0 :     case BRIG_TYPE_U16X8:</span>
<span class="lineNum">     805 </span><span class="lineNoCov">          0 :     case BRIG_TYPE_U32X4:</span>
<span class="lineNum">     806 </span><span class="lineNoCov">          0 :     case BRIG_TYPE_U64X2:</span>
<span class="lineNum">     807 </span><span class="lineNoCov">          0 :     case BRIG_TYPE_S8X16:</span>
<span class="lineNum">     808 </span><span class="lineNoCov">          0 :     case BRIG_TYPE_S16X8:</span>
<span class="lineNum">     809 </span><span class="lineNoCov">          0 :     case BRIG_TYPE_S32X4:</span>
<span class="lineNum">     810 </span><span class="lineNoCov">          0 :     case BRIG_TYPE_S64X2:</span>
<span class="lineNum">     811 </span><span class="lineNoCov">          0 :     case BRIG_TYPE_F16X8:</span>
<span class="lineNum">     812 </span><span class="lineNoCov">          0 :     case BRIG_TYPE_F32X4:</span>
<span class="lineNum">     813 </span><span class="lineNoCov">          0 :     case BRIG_TYPE_F64X2:</span>
<span class="lineNum">     814 </span><span class="lineNoCov">          0 :       return BRIG_TYPE_B128;</span>
<span class="lineNum">     815 </span>            : 
<span class="lineNum">     816 </span><span class="lineNoCov">          0 :     default:</span>
<span class="lineNum">     817 </span><span class="lineNoCov">          0 :       gcc_unreachable ();</span>
<span class="lineNum">     818 </span>            :     }
<span class="lineNum">     819 </span>            : }
<span class="lineNum">     820 </span>            : 
<span class="lineNum">     821 </span>            : /* Return the length of the BRIG type TYPE that is going to be streamed out as
<span class="lineNum">     822 </span>            :    an immediate constant (so it must not be B1).  */
<a name="823"><span class="lineNum">     823 </span>            : </a>
<span class="lineNum">     824 </span>            : unsigned
<span class="lineNum">     825 </span><span class="lineNoCov">          0 : hsa_get_imm_brig_type_len (BrigType16_t type)</span>
<span class="lineNum">     826 </span>            : {
<span class="lineNum">     827 </span><span class="lineNoCov">          0 :   BrigType16_t base_type = type &amp; BRIG_TYPE_BASE_MASK;</span>
<span class="lineNum">     828 </span><span class="lineNoCov">          0 :   BrigType16_t pack_type = type &amp; BRIG_TYPE_PACK_MASK;</span>
<span class="lineNum">     829 </span>            : 
<span class="lineNum">     830 </span><span class="lineNoCov">          0 :   switch (pack_type)</span>
<span class="lineNum">     831 </span>            :     {
<span class="lineNum">     832 </span><span class="lineNoCov">          0 :     case BRIG_TYPE_PACK_NONE:</span>
<span class="lineNum">     833 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">     834 </span>            :     case BRIG_TYPE_PACK_32:
<span class="lineNum">     835 </span>            :       return 4;
<span class="lineNum">     836 </span><span class="lineNoCov">          0 :     case BRIG_TYPE_PACK_64:</span>
<span class="lineNum">     837 </span><span class="lineNoCov">          0 :       return 8;</span>
<span class="lineNum">     838 </span><span class="lineNoCov">          0 :     case BRIG_TYPE_PACK_128:</span>
<span class="lineNum">     839 </span><span class="lineNoCov">          0 :       return 16;</span>
<span class="lineNum">     840 </span><span class="lineNoCov">          0 :     default:</span>
<span class="lineNum">     841 </span><span class="lineNoCov">          0 :       gcc_unreachable ();</span>
<span class="lineNum">     842 </span>            :     }
<span class="lineNum">     843 </span>            : 
<span class="lineNum">     844 </span><span class="lineNoCov">          0 :   switch (base_type)</span>
<span class="lineNum">     845 </span>            :     {
<span class="lineNum">     846 </span>            :     case BRIG_TYPE_U8:
<span class="lineNum">     847 </span>            :     case BRIG_TYPE_S8:
<span class="lineNum">     848 </span>            :     case BRIG_TYPE_B8:
<span class="lineNum">     849 </span>            :       return 1;
<span class="lineNum">     850 </span><span class="lineNoCov">          0 :     case BRIG_TYPE_U16:</span>
<span class="lineNum">     851 </span><span class="lineNoCov">          0 :     case BRIG_TYPE_S16:</span>
<span class="lineNum">     852 </span><span class="lineNoCov">          0 :     case BRIG_TYPE_F16:</span>
<span class="lineNum">     853 </span><span class="lineNoCov">          0 :     case BRIG_TYPE_B16:</span>
<span class="lineNum">     854 </span><span class="lineNoCov">          0 :       return 2;</span>
<span class="lineNum">     855 </span><span class="lineNoCov">          0 :     case BRIG_TYPE_U32:</span>
<span class="lineNum">     856 </span><span class="lineNoCov">          0 :     case BRIG_TYPE_S32:</span>
<span class="lineNum">     857 </span><span class="lineNoCov">          0 :     case BRIG_TYPE_F32:</span>
<span class="lineNum">     858 </span><span class="lineNoCov">          0 :     case BRIG_TYPE_B32:</span>
<span class="lineNum">     859 </span><span class="lineNoCov">          0 :       return 4;</span>
<span class="lineNum">     860 </span><span class="lineNoCov">          0 :     case BRIG_TYPE_U64:</span>
<span class="lineNum">     861 </span><span class="lineNoCov">          0 :     case BRIG_TYPE_S64:</span>
<span class="lineNum">     862 </span><span class="lineNoCov">          0 :     case BRIG_TYPE_F64:</span>
<span class="lineNum">     863 </span><span class="lineNoCov">          0 :     case BRIG_TYPE_B64:</span>
<span class="lineNum">     864 </span><span class="lineNoCov">          0 :       return 8;</span>
<span class="lineNum">     865 </span><span class="lineNoCov">          0 :     case BRIG_TYPE_B128:</span>
<span class="lineNum">     866 </span><span class="lineNoCov">          0 :       return 16;</span>
<span class="lineNum">     867 </span><span class="lineNoCov">          0 :     default:</span>
<span class="lineNum">     868 </span><span class="lineNoCov">          0 :       gcc_unreachable ();</span>
<span class="lineNum">     869 </span>            :     }
<span class="lineNum">     870 </span>            : }
<span class="lineNum">     871 </span>            : 
<span class="lineNum">     872 </span>            : /* Emit one scalar VALUE to the buffer DATA intended for BRIG emission.
<span class="lineNum">     873 </span>            :    If NEED_LEN is not equal to zero, shrink or extend the value
<span class="lineNum">     874 </span>            :    to NEED_LEN bytes.  Return how many bytes were written.  */
<a name="875"><span class="lineNum">     875 </span>            : </a>
<span class="lineNum">     876 </span>            : static int
<span class="lineNum">     877 </span><span class="lineNoCov">          0 : emit_immediate_scalar_to_buffer (tree value, char *data, unsigned need_len)</span>
<span class="lineNum">     878 </span>            : {
<span class="lineNum">     879 </span><span class="lineNoCov">          0 :   union hsa_bytes bytes;</span>
<span class="lineNum">     880 </span>            : 
<span class="lineNum">     881 </span><span class="lineNoCov">          0 :   memset (&amp;bytes, 0, sizeof (bytes));</span>
<span class="lineNum">     882 </span><span class="lineNoCov">          0 :   tree type = TREE_TYPE (value);</span>
<span class="lineNum">     883 </span><span class="lineNoCov">          0 :   gcc_checking_assert (TREE_CODE (type) != VECTOR_TYPE);</span>
<span class="lineNum">     884 </span>            : 
<span class="lineNum">     885 </span><span class="lineNoCov">          0 :   unsigned data_len = tree_to_uhwi (TYPE_SIZE (type)) / BITS_PER_UNIT;</span>
<span class="lineNum">     886 </span><span class="lineNoCov">          0 :   if (INTEGRAL_TYPE_P (type)</span>
<span class="lineNum">     887 </span><span class="lineNoCov">          0 :       || (POINTER_TYPE_P (type) &amp;&amp; TREE_CODE (value) == INTEGER_CST))</span>
<span class="lineNum">     888 </span><span class="lineNoCov">          0 :     switch (data_len)</span>
<span class="lineNum">     889 </span>            :       {
<span class="lineNum">     890 </span><span class="lineNoCov">          0 :       case 1:</span>
<span class="lineNum">     891 </span><span class="lineNoCov">          0 :         bytes.b8 = (uint8_t) TREE_INT_CST_LOW (value);</span>
<span class="lineNum">     892 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">     893 </span><span class="lineNoCov">          0 :       case 2:</span>
<span class="lineNum">     894 </span><span class="lineNoCov">          0 :         bytes.b16 = (uint16_t) TREE_INT_CST_LOW (value);</span>
<span class="lineNum">     895 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">     896 </span><span class="lineNoCov">          0 :       case 4:</span>
<span class="lineNum">     897 </span><span class="lineNoCov">          0 :         bytes.b32 = (uint32_t) TREE_INT_CST_LOW (value);</span>
<span class="lineNum">     898 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">     899 </span><span class="lineNoCov">          0 :       case 8:</span>
<span class="lineNum">     900 </span><span class="lineNoCov">          0 :         bytes.b64 = (uint64_t) TREE_INT_CST_LOW (value);</span>
<span class="lineNum">     901 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">     902 </span><span class="lineNoCov">          0 :       default:</span>
<span class="lineNum">     903 </span><span class="lineNoCov">          0 :         gcc_unreachable ();</span>
<span class="lineNum">     904 </span>            :       }
<span class="lineNum">     905 </span><span class="lineNoCov">          0 :   else if (SCALAR_FLOAT_TYPE_P (type))</span>
<span class="lineNum">     906 </span>            :     {
<span class="lineNum">     907 </span><span class="lineNoCov">          0 :       if (data_len == 2)</span>
<span class="lineNum">     908 </span>            :         {
<span class="lineNum">     909 </span><span class="lineNoCov">          0 :           sorry (&quot;Support for HSA does not implement immediate 16 bit FPU &quot;</span>
<span class="lineNum">     910 </span>            :                  &quot;operands&quot;);
<span class="lineNum">     911 </span><span class="lineNoCov">          0 :           return 2;</span>
<span class="lineNum">     912 </span>            :         }
<span class="lineNum">     913 </span><span class="lineNoCov">          0 :       unsigned int_len = GET_MODE_SIZE (SCALAR_FLOAT_TYPE_MODE (type));</span>
<span class="lineNum">     914 </span>            :       /* There are always 32 bits in each long, no matter the size of
<span class="lineNum">     915 </span>            :          the hosts long.  */
<span class="lineNum">     916 </span><span class="lineNoCov">          0 :       long tmp[6];</span>
<span class="lineNum">     917 </span>            : 
<span class="lineNum">     918 </span><span class="lineNoCov">          0 :       real_to_target (tmp, TREE_REAL_CST_PTR (value), TYPE_MODE (type));</span>
<span class="lineNum">     919 </span>            : 
<span class="lineNum">     920 </span><span class="lineNoCov">          0 :       if (int_len == 4)</span>
<span class="lineNum">     921 </span><span class="lineNoCov">          0 :         bytes.b32 = (uint32_t) tmp[0];</span>
<span class="lineNum">     922 </span>            :       else
<span class="lineNum">     923 </span>            :         {
<span class="lineNum">     924 </span><span class="lineNoCov">          0 :           bytes.b64 = (uint64_t)(uint32_t) tmp[1];</span>
<span class="lineNum">     925 </span><span class="lineNoCov">          0 :           bytes.b64 &lt;&lt;= 32;</span>
<span class="lineNum">     926 </span><span class="lineNoCov">          0 :           bytes.b64 |= (uint32_t) tmp[0];</span>
<span class="lineNum">     927 </span>            :         }
<span class="lineNum">     928 </span>            :     }
<span class="lineNum">     929 </span>            :   else
<span class="lineNum">     930 </span><span class="lineNoCov">          0 :     gcc_unreachable ();</span>
<span class="lineNum">     931 </span>            : 
<span class="lineNum">     932 </span><span class="lineNoCov">          0 :   int len;</span>
<span class="lineNum">     933 </span><span class="lineNoCov">          0 :   if (need_len == 0)</span>
<span class="lineNum">     934 </span><span class="lineNoCov">          0 :     len = data_len;</span>
<span class="lineNum">     935 </span>            :   else
<span class="lineNum">     936 </span><span class="lineNoCov">          0 :     len = need_len;</span>
<span class="lineNum">     937 </span>            : 
<span class="lineNum">     938 </span><span class="lineNoCov">          0 :   memcpy (data, &amp;bytes, len);</span>
<span class="lineNum">     939 </span><span class="lineNoCov">          0 :   return len;</span>
<span class="lineNum">     940 </span>            : }
<span class="lineNum">     941 </span>            : 
<span class="lineNum">     942 </span>            : char *
<span class="lineNum">     943 </span><span class="lineNoCov">          0 : hsa_op_immed::emit_to_buffer (unsigned *brig_repr_size)</span>
<span class="lineNum">     944 </span>            : {
<span class="lineNum">     945 </span><span class="lineNoCov">          0 :   char *brig_repr;</span>
<span class="lineNum">     946 </span><span class="lineNoCov">          0 :   *brig_repr_size = hsa_get_imm_brig_type_len (m_type);</span>
<span class="lineNum">     947 </span>            : 
<span class="lineNum">     948 </span><span class="lineNoCov">          0 :   if (m_tree_value != NULL_TREE)</span>
<span class="lineNum">     949 </span>            :     {
<span class="lineNum">     950 </span>            :       /* Update brig_repr_size for special tree values.  */
<span class="lineNum">     951 </span><span class="lineNoCov">          0 :       if (TREE_CODE (m_tree_value) == STRING_CST)</span>
<span class="lineNum">     952 </span><span class="lineNoCov">          0 :         *brig_repr_size = TREE_STRING_LENGTH (m_tree_value);</span>
<span class="lineNum">     953 </span><span class="lineNoCov">          0 :       else if (TREE_CODE (m_tree_value) == CONSTRUCTOR)</span>
<span class="lineNum">     954 </span><span class="lineNoCov">          0 :         *brig_repr_size</span>
<span class="lineNum">     955 </span><span class="lineNoCov">          0 :           = tree_to_uhwi (TYPE_SIZE_UNIT (TREE_TYPE (m_tree_value)));</span>
<span class="lineNum">     956 </span>            : 
<span class="lineNum">     957 </span><span class="lineNoCov">          0 :       unsigned total_len = *brig_repr_size;</span>
<span class="lineNum">     958 </span>            : 
<span class="lineNum">     959 </span>            :       /* As we can have a constructor with fewer elements, fill the memory
<span class="lineNum">     960 </span>            :          with zeros.  */
<span class="lineNum">     961 </span><span class="lineNoCov">          0 :       brig_repr = XCNEWVEC (char, total_len);</span>
<span class="lineNum">     962 </span><span class="lineNoCov">          0 :       char *p = brig_repr;</span>
<span class="lineNum">     963 </span>            : 
<span class="lineNum">     964 </span><span class="lineNoCov">          0 :       if (TREE_CODE (m_tree_value) == VECTOR_CST)</span>
<span class="lineNum">     965 </span>            :         {
<span class="lineNum">     966 </span>            :           /* Variable-length vectors aren't supported.  */
<span class="lineNum">     967 </span><span class="lineNoCov">          0 :           int i, num = VECTOR_CST_NELTS (m_tree_value).to_constant ();</span>
<span class="lineNum">     968 </span><span class="lineNoCov">          0 :           for (i = 0; i &lt; num; i++)</span>
<span class="lineNum">     969 </span>            :             {
<span class="lineNum">     970 </span><span class="lineNoCov">          0 :               tree v = VECTOR_CST_ELT (m_tree_value, i);</span>
<span class="lineNum">     971 </span><span class="lineNoCov">          0 :               unsigned actual = emit_immediate_scalar_to_buffer (v, p, 0);</span>
<span class="lineNum">     972 </span><span class="lineNoCov">          0 :               total_len -= actual;</span>
<span class="lineNum">     973 </span><span class="lineNoCov">          0 :               p += actual;</span>
<span class="lineNum">     974 </span>            :             }
<span class="lineNum">     975 </span>            :           /* Vectors should have the exact size.  */
<span class="lineNum">     976 </span><span class="lineNoCov">          0 :           gcc_assert (total_len == 0);</span>
<span class="lineNum">     977 </span>            :         }
<span class="lineNum">     978 </span><span class="lineNoCov">          0 :       else if (TREE_CODE (m_tree_value) == STRING_CST)</span>
<span class="lineNum">     979 </span><span class="lineNoCov">          0 :         memcpy (brig_repr, TREE_STRING_POINTER (m_tree_value),</span>
<span class="lineNum">     980 </span><span class="lineNoCov">          0 :                 TREE_STRING_LENGTH (m_tree_value));</span>
<span class="lineNum">     981 </span><span class="lineNoCov">          0 :       else if (TREE_CODE (m_tree_value) == COMPLEX_CST)</span>
<span class="lineNum">     982 </span>            :         {
<span class="lineNum">     983 </span><span class="lineNoCov">          0 :           gcc_assert (total_len % 2 == 0);</span>
<span class="lineNum">     984 </span><span class="lineNoCov">          0 :           unsigned actual;</span>
<span class="lineNum">     985 </span><span class="lineNoCov">          0 :           actual</span>
<span class="lineNum">     986 </span><span class="lineNoCov">          0 :             = emit_immediate_scalar_to_buffer (TREE_REALPART (m_tree_value), p,</span>
<span class="lineNum">     987 </span>            :                                                total_len / 2);
<span class="lineNum">     988 </span>            : 
<span class="lineNum">     989 </span><span class="lineNoCov">          0 :           gcc_assert (actual == total_len / 2);</span>
<span class="lineNum">     990 </span><span class="lineNoCov">          0 :           p += actual;</span>
<span class="lineNum">     991 </span>            : 
<span class="lineNum">     992 </span><span class="lineNoCov">          0 :           actual</span>
<span class="lineNum">     993 </span><span class="lineNoCov">          0 :             = emit_immediate_scalar_to_buffer (TREE_IMAGPART (m_tree_value), p,</span>
<span class="lineNum">     994 </span>            :                                                total_len / 2);
<span class="lineNum">     995 </span><span class="lineNoCov">          0 :           gcc_assert (actual == total_len / 2);</span>
<span class="lineNum">     996 </span>            :         }
<span class="lineNum">     997 </span><span class="lineNoCov">          0 :       else if (TREE_CODE (m_tree_value) == CONSTRUCTOR)</span>
<span class="lineNum">     998 </span>            :         {
<span class="lineNum">     999 </span><span class="lineNoCov">          0 :           unsigned len = CONSTRUCTOR_NELTS (m_tree_value);</span>
<span class="lineNum">    1000 </span><span class="lineNoCov">          0 :           for (unsigned i = 0; i &lt; len; i++)</span>
<span class="lineNum">    1001 </span>            :             {
<span class="lineNum">    1002 </span><span class="lineNoCov">          0 :               tree v = CONSTRUCTOR_ELT (m_tree_value, i)-&gt;value;</span>
<span class="lineNum">    1003 </span><span class="lineNoCov">          0 :               unsigned actual = emit_immediate_scalar_to_buffer (v, p, 0);</span>
<span class="lineNum">    1004 </span><span class="lineNoCov">          0 :               total_len -= actual;</span>
<span class="lineNum">    1005 </span><span class="lineNoCov">          0 :               p += actual;</span>
<span class="lineNum">    1006 </span>            :             }
<span class="lineNum">    1007 </span>            :         }
<span class="lineNum">    1008 </span>            :       else
<span class="lineNum">    1009 </span><span class="lineNoCov">          0 :         emit_immediate_scalar_to_buffer (m_tree_value, p, total_len);</span>
<span class="lineNum">    1010 </span>            :     }
<span class="lineNum">    1011 </span>            :   else
<span class="lineNum">    1012 </span>            :     {
<span class="lineNum">    1013 </span><span class="lineNoCov">          0 :       hsa_bytes bytes;</span>
<span class="lineNum">    1014 </span>            : 
<span class="lineNum">    1015 </span><span class="lineNoCov">          0 :       switch (*brig_repr_size)</span>
<span class="lineNum">    1016 </span>            :         {
<span class="lineNum">    1017 </span><span class="lineNoCov">          0 :         case 1:</span>
<span class="lineNum">    1018 </span><span class="lineNoCov">          0 :           bytes.b8 = (uint8_t) m_int_value;</span>
<span class="lineNum">    1019 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">    1020 </span><span class="lineNoCov">          0 :         case 2:</span>
<span class="lineNum">    1021 </span><span class="lineNoCov">          0 :           bytes.b16 = (uint16_t) m_int_value;</span>
<span class="lineNum">    1022 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">    1023 </span><span class="lineNoCov">          0 :         case 4:</span>
<span class="lineNum">    1024 </span><span class="lineNoCov">          0 :           bytes.b32 = (uint32_t) m_int_value;</span>
<span class="lineNum">    1025 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">    1026 </span><span class="lineNoCov">          0 :         case 8:</span>
<span class="lineNum">    1027 </span><span class="lineNoCov">          0 :           bytes.b64 = (uint64_t) m_int_value;</span>
<span class="lineNum">    1028 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">    1029 </span><span class="lineNoCov">          0 :         default:</span>
<span class="lineNum">    1030 </span><span class="lineNoCov">          0 :           gcc_unreachable ();</span>
<span class="lineNum">    1031 </span>            :         }
<span class="lineNum">    1032 </span>            : 
<span class="lineNum">    1033 </span><span class="lineNoCov">          0 :       brig_repr = XNEWVEC (char, *brig_repr_size);</span>
<span class="lineNum">    1034 </span><span class="lineNoCov">          0 :       memcpy (brig_repr, &amp;bytes, *brig_repr_size);</span>
<span class="lineNum">    1035 </span>            :     }
<span class="lineNum">    1036 </span>            : 
<span class="lineNum">    1037 </span><span class="lineNoCov">          0 :   return brig_repr;</span>
<span class="lineNum">    1038 </span>            : }
<span class="lineNum">    1039 </span>            : 
<span class="lineNum">    1040 </span>            : /* Emit an immediate BRIG operand IMM.  The BRIG type of the immediate might
<span class="lineNum">    1041 </span>            :    have been massaged to comply with various HSA/BRIG type requirements, so the
<span class="lineNum">    1042 </span>            :    only important aspect of that is the length (because HSAIL might expect
<span class="lineNum">    1043 </span>            :    smaller constants or become bit-data).  The data should be represented
<span class="lineNum">    1044 </span>            :    according to what is in the tree representation.  */
<a name="1045"><span class="lineNum">    1045 </span>            : </a>
<span class="lineNum">    1046 </span>            : static void
<span class="lineNum">    1047 </span><span class="lineNoCov">          0 : emit_immediate_operand (hsa_op_immed *imm)</span>
<span class="lineNum">    1048 </span>            : {
<span class="lineNum">    1049 </span><span class="lineNoCov">          0 :   unsigned brig_repr_size;</span>
<span class="lineNum">    1050 </span><span class="lineNoCov">          0 :   char *brig_repr = imm-&gt;emit_to_buffer (&amp;brig_repr_size);</span>
<span class="lineNum">    1051 </span><span class="lineNoCov">          0 :   struct BrigOperandConstantBytes out;</span>
<span class="lineNum">    1052 </span>            : 
<span class="lineNum">    1053 </span><span class="lineNoCov">          0 :   memset (&amp;out, 0, sizeof (out));</span>
<span class="lineNum">    1054 </span><span class="lineNoCov">          0 :   out.base.byteCount = lendian16 (sizeof (out));</span>
<span class="lineNum">    1055 </span><span class="lineNoCov">          0 :   out.base.kind = lendian16 (BRIG_KIND_OPERAND_CONSTANT_BYTES);</span>
<span class="lineNum">    1056 </span><span class="lineNoCov">          0 :   uint32_t byteCount = lendian32 (brig_repr_size);</span>
<span class="lineNum">    1057 </span><span class="lineNoCov">          0 :   out.type = lendian16 (imm-&gt;m_type);</span>
<span class="lineNum">    1058 </span><span class="lineNoCov">          0 :   out.bytes = lendian32 (brig_data.add (&amp;byteCount, sizeof (byteCount)));</span>
<span class="lineNum">    1059 </span><span class="lineNoCov">          0 :   brig_operand.add (&amp;out, sizeof (out));</span>
<span class="lineNum">    1060 </span><span class="lineNoCov">          0 :   brig_data.add (brig_repr, brig_repr_size);</span>
<span class="lineNum">    1061 </span><span class="lineNoCov">          0 :   brig_data.round_size_up (4);</span>
<span class="lineNum">    1062 </span>            : 
<span class="lineNum">    1063 </span><span class="lineNoCov">          0 :   free (brig_repr);</span>
<span class="lineNum">    1064 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1065 </span>            : 
<span class="lineNum">    1066 </span>            : /* Emit a register BRIG operand REG.  */
<a name="1067"><span class="lineNum">    1067 </span>            : </a>
<span class="lineNum">    1068 </span>            : static void
<span class="lineNum">    1069 </span><span class="lineNoCov">          0 : emit_register_operand (hsa_op_reg *reg)</span>
<span class="lineNum">    1070 </span>            : {
<span class="lineNum">    1071 </span><span class="lineNoCov">          0 :   struct BrigOperandRegister out;</span>
<span class="lineNum">    1072 </span>            : 
<span class="lineNum">    1073 </span><span class="lineNoCov">          0 :   out.base.byteCount = lendian16 (sizeof (out));</span>
<span class="lineNum">    1074 </span><span class="lineNoCov">          0 :   out.base.kind = lendian16 (BRIG_KIND_OPERAND_REGISTER);</span>
<span class="lineNum">    1075 </span><span class="lineNoCov">          0 :   out.regNum = lendian32 (reg-&gt;m_hard_num);</span>
<span class="lineNum">    1076 </span>            : 
<span class="lineNum">    1077 </span><span class="lineNoCov">          0 :   switch (regtype_for_type (reg-&gt;m_type))</span>
<span class="lineNum">    1078 </span>            :     {
<span class="lineNum">    1079 </span><span class="lineNoCov">          0 :     case BRIG_TYPE_B32:</span>
<span class="lineNum">    1080 </span><span class="lineNoCov">          0 :       out.regKind = BRIG_REGISTER_KIND_SINGLE;</span>
<span class="lineNum">    1081 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">    1082 </span><span class="lineNoCov">          0 :     case BRIG_TYPE_B64:</span>
<span class="lineNum">    1083 </span><span class="lineNoCov">          0 :       out.regKind = BRIG_REGISTER_KIND_DOUBLE;</span>
<span class="lineNum">    1084 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">    1085 </span><span class="lineNoCov">          0 :     case BRIG_TYPE_B128:</span>
<span class="lineNum">    1086 </span><span class="lineNoCov">          0 :       out.regKind = BRIG_REGISTER_KIND_QUAD;</span>
<span class="lineNum">    1087 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">    1088 </span><span class="lineNoCov">          0 :     case BRIG_TYPE_B1:</span>
<span class="lineNum">    1089 </span><span class="lineNoCov">          0 :       out.regKind = BRIG_REGISTER_KIND_CONTROL;</span>
<span class="lineNum">    1090 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">    1091 </span><span class="lineNoCov">          0 :     default:</span>
<span class="lineNum">    1092 </span><span class="lineNoCov">          0 :       gcc_unreachable ();</span>
<span class="lineNum">    1093 </span>            :     }
<span class="lineNum">    1094 </span>            : 
<span class="lineNum">    1095 </span><span class="lineNoCov">          0 :   brig_operand.add (&amp;out, sizeof (out));</span>
<span class="lineNum">    1096 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1097 </span>            : 
<span class="lineNum">    1098 </span>            : /* Emit an address BRIG operand ADDR.  */
<a name="1099"><span class="lineNum">    1099 </span>            : </a>
<span class="lineNum">    1100 </span>            : static void
<span class="lineNum">    1101 </span><span class="lineNoCov">          0 : emit_address_operand (hsa_op_address *addr)</span>
<span class="lineNum">    1102 </span>            : {
<span class="lineNum">    1103 </span><span class="lineNoCov">          0 :   struct BrigOperandAddress out;</span>
<span class="lineNum">    1104 </span>            : 
<span class="lineNum">    1105 </span><span class="lineNoCov">          0 :   out.base.byteCount = lendian16 (sizeof (out));</span>
<span class="lineNum">    1106 </span><span class="lineNoCov">          0 :   out.base.kind = lendian16 (BRIG_KIND_OPERAND_ADDRESS);</span>
<span class="lineNum">    1107 </span><span class="lineNoCov">          0 :   out.symbol = addr-&gt;m_symbol</span>
<span class="lineNum">    1108 </span><span class="lineNoCov">          0 :     ? lendian32 (emit_directive_variable (addr-&gt;m_symbol)) : 0;</span>
<span class="lineNum">    1109 </span><span class="lineNoCov">          0 :   out.reg = addr-&gt;m_reg ? lendian32 (enqueue_op (addr-&gt;m_reg)) : 0;</span>
<span class="lineNum">    1110 </span>            : 
<span class="lineNum">    1111 </span><span class="lineNoCov">          0 :   if (sizeof (addr-&gt;m_imm_offset) == 8)</span>
<span class="lineNum">    1112 </span>            :     {
<span class="lineNum">    1113 </span><span class="lineNoCov">          0 :       out.offset.lo = lendian32 (addr-&gt;m_imm_offset);</span>
<span class="lineNum">    1114 </span><span class="lineNoCov">          0 :       out.offset.hi = lendian32 (addr-&gt;m_imm_offset &gt;&gt; 32);</span>
<span class="lineNum">    1115 </span>            :     }
<span class="lineNum">    1116 </span>            :   else
<span class="lineNum">    1117 </span>            :     {
<span class="lineNum">    1118 </span>            :       gcc_assert (sizeof (addr-&gt;m_imm_offset) == 4);
<span class="lineNum">    1119 </span>            :       out.offset.lo = lendian32 (addr-&gt;m_imm_offset);
<span class="lineNum">    1120 </span>            :       out.offset.hi = 0;
<span class="lineNum">    1121 </span>            :     }
<span class="lineNum">    1122 </span>            : 
<span class="lineNum">    1123 </span><span class="lineNoCov">          0 :   brig_operand.add (&amp;out, sizeof (out));</span>
<span class="lineNum">    1124 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1125 </span>            : 
<span class="lineNum">    1126 </span>            : /* Emit a code reference operand REF.  */
<a name="1127"><span class="lineNum">    1127 </span>            : </a>
<span class="lineNum">    1128 </span>            : static void
<span class="lineNum">    1129 </span><span class="lineNoCov">          0 : emit_code_ref_operand (hsa_op_code_ref *ref)</span>
<span class="lineNum">    1130 </span>            : {
<span class="lineNum">    1131 </span><span class="lineNoCov">          0 :   struct BrigOperandCodeRef out;</span>
<span class="lineNum">    1132 </span>            : 
<span class="lineNum">    1133 </span><span class="lineNoCov">          0 :   out.base.byteCount = lendian16 (sizeof (out));</span>
<span class="lineNum">    1134 </span><span class="lineNoCov">          0 :   out.base.kind = lendian16 (BRIG_KIND_OPERAND_CODE_REF);</span>
<span class="lineNum">    1135 </span><span class="lineNoCov">          0 :   out.ref = lendian32 (ref-&gt;m_directive_offset);</span>
<span class="lineNum">    1136 </span><span class="lineNoCov">          0 :   brig_operand.add (&amp;out, sizeof (out));</span>
<span class="lineNum">    1137 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1138 </span>            : 
<span class="lineNum">    1139 </span>            : /* Emit a code list operand CODE_LIST.  */
<span class="lineNum">    1140 </span>            : 
<span class="lineNum">    1141 </span>            : static void
<span class="lineNum">    1142 </span><span class="lineNoCov">          0 : emit_code_list_operand (hsa_op_code_list *code_list)</span>
<span class="lineNum">    1143 </span>            : {
<span class="lineNum">    1144 </span><span class="lineNoCov">          0 :   struct BrigOperandCodeList out;</span>
<span class="lineNum">    1145 </span><span class="lineNoCov">          0 :   unsigned args = code_list-&gt;m_offsets.length ();</span>
<span class="lineNum">    1146 </span>            : 
<span class="lineNum">    1147 </span><span class="lineNoCov">          0 :   for (unsigned i = 0; i &lt; args; i++)</span>
<span class="lineNum">    1148 </span><span class="lineNoCov">          0 :     gcc_assert (code_list-&gt;m_offsets[i]);</span>
<span class="lineNum">    1149 </span>            : 
<span class="lineNum">    1150 </span><span class="lineNoCov">          0 :   out.base.byteCount = lendian16 (sizeof (out));</span>
<span class="lineNum">    1151 </span><span class="lineNoCov">          0 :   out.base.kind = lendian16 (BRIG_KIND_OPERAND_CODE_LIST);</span>
<span class="lineNum">    1152 </span>            : 
<span class="lineNum">    1153 </span><span class="lineNoCov">          0 :   uint32_t byteCount = lendian32 (4 * args);</span>
<span class="lineNum">    1154 </span>            : 
<span class="lineNum">    1155 </span><span class="lineNoCov">          0 :   out.elements = lendian32 (brig_data.add (&amp;byteCount, sizeof (byteCount)));</span>
<span class="lineNum">    1156 </span><span class="lineNoCov">          0 :   brig_data.add (code_list-&gt;m_offsets.address (), args * sizeof (uint32_t));</span>
<span class="lineNum">    1157 </span><span class="lineNoCov">          0 :   brig_data.round_size_up (4);</span>
<span class="lineNum">    1158 </span><span class="lineNoCov">          0 :   brig_operand.add (&amp;out, sizeof (out));</span>
<span class="lineNum">    1159 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1160 </span>            : 
<span class="lineNum">    1161 </span>            : /* Emit an operand list operand OPERAND_LIST.  */
<span class="lineNum">    1162 </span>            : 
<span class="lineNum">    1163 </span>            : static void
<span class="lineNum">    1164 </span><span class="lineNoCov">          0 : emit_operand_list_operand (hsa_op_operand_list *operand_list)</span>
<span class="lineNum">    1165 </span>            : {
<span class="lineNum">    1166 </span><span class="lineNoCov">          0 :   struct BrigOperandOperandList out;</span>
<span class="lineNum">    1167 </span><span class="lineNoCov">          0 :   unsigned args = operand_list-&gt;m_offsets.length ();</span>
<span class="lineNum">    1168 </span>            : 
<span class="lineNum">    1169 </span><span class="lineNoCov">          0 :   for (unsigned i = 0; i &lt; args; i++)</span>
<span class="lineNum">    1170 </span><span class="lineNoCov">          0 :     gcc_assert (operand_list-&gt;m_offsets[i]);</span>
<span class="lineNum">    1171 </span>            : 
<span class="lineNum">    1172 </span><span class="lineNoCov">          0 :   out.base.byteCount = lendian16 (sizeof (out));</span>
<span class="lineNum">    1173 </span><span class="lineNoCov">          0 :   out.base.kind = lendian16 (BRIG_KIND_OPERAND_OPERAND_LIST);</span>
<span class="lineNum">    1174 </span>            : 
<span class="lineNum">    1175 </span><span class="lineNoCov">          0 :   uint32_t byteCount = lendian32 (4 * args);</span>
<span class="lineNum">    1176 </span>            : 
<span class="lineNum">    1177 </span><span class="lineNoCov">          0 :   out.elements = lendian32 (brig_data.add (&amp;byteCount, sizeof (byteCount)));</span>
<span class="lineNum">    1178 </span><span class="lineNoCov">          0 :   brig_data.add (operand_list-&gt;m_offsets.address (), args * sizeof (uint32_t));</span>
<span class="lineNum">    1179 </span><span class="lineNoCov">          0 :   brig_data.round_size_up (4);</span>
<span class="lineNum">    1180 </span><span class="lineNoCov">          0 :   brig_operand.add (&amp;out, sizeof (out));</span>
<span class="lineNum">    1181 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1182 </span>            : 
<span class="lineNum">    1183 </span>            : /* Emit all operands queued for writing.  */
<a name="1184"><span class="lineNum">    1184 </span>            : </a>
<span class="lineNum">    1185 </span>            : static void
<span class="lineNum">    1186 </span><span class="lineNoCov">          0 : emit_queued_operands (void)</span>
<span class="lineNum">    1187 </span>            : {
<span class="lineNum">    1188 </span><span class="lineNoCov">          0 :   for (hsa_op_base *op = op_queue.first_op; op; op = op-&gt;m_next)</span>
<span class="lineNum">    1189 </span>            :     {
<span class="lineNum">    1190 </span><span class="lineNoCov">          0 :       gcc_assert (op-&gt;m_brig_op_offset == brig_operand.total_size);</span>
<span class="lineNum">    1191 </span><span class="lineNoCov">          0 :       if (hsa_op_immed *imm = dyn_cast &lt;hsa_op_immed *&gt; (op))</span>
<span class="lineNum">    1192 </span><span class="lineNoCov">          0 :         emit_immediate_operand (imm);</span>
<span class="lineNum">    1193 </span><span class="lineNoCov">          0 :       else if (hsa_op_reg *reg = dyn_cast &lt;hsa_op_reg *&gt; (op))</span>
<span class="lineNum">    1194 </span><span class="lineNoCov">          0 :         emit_register_operand (reg);</span>
<span class="lineNum">    1195 </span><span class="lineNoCov">          0 :       else if (hsa_op_address *addr = dyn_cast &lt;hsa_op_address *&gt; (op))</span>
<span class="lineNum">    1196 </span><span class="lineNoCov">          0 :         emit_address_operand (addr);</span>
<span class="lineNum">    1197 </span><span class="lineNoCov">          0 :       else if (hsa_op_code_ref *ref = dyn_cast &lt;hsa_op_code_ref *&gt; (op))</span>
<span class="lineNum">    1198 </span><span class="lineNoCov">          0 :         emit_code_ref_operand (ref);</span>
<span class="lineNum">    1199 </span><span class="lineNoCov">          0 :       else if (hsa_op_code_list *code_list = dyn_cast &lt;hsa_op_code_list *&gt; (op))</span>
<span class="lineNum">    1200 </span><span class="lineNoCov">          0 :         emit_code_list_operand (code_list);</span>
<span class="lineNum">    1201 </span><span class="lineNoCov">          0 :       else if (hsa_op_operand_list *l = dyn_cast &lt;hsa_op_operand_list *&gt; (op))</span>
<span class="lineNum">    1202 </span><span class="lineNoCov">          0 :         emit_operand_list_operand (l);</span>
<span class="lineNum">    1203 </span>            :       else
<span class="lineNum">    1204 </span><span class="lineNoCov">          0 :         gcc_unreachable ();</span>
<span class="lineNum">    1205 </span>            :     }
<span class="lineNum">    1206 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1207 </span>            : 
<span class="lineNum">    1208 </span>            : /* Emit directives describing the function that is used for
<span class="lineNum">    1209 </span>            :    a function declaration.  */
<a name="1210"><span class="lineNum">    1210 </span>            : </a>
<span class="lineNum">    1211 </span>            : static BrigDirectiveExecutable *
<span class="lineNum">    1212 </span><span class="lineNoCov">          0 : emit_function_declaration (tree decl)</span>
<span class="lineNum">    1213 </span>            : {
<span class="lineNum">    1214 </span><span class="lineNoCov">          0 :   hsa_function_representation *f = hsa_generate_function_declaration (decl);</span>
<span class="lineNum">    1215 </span>            : 
<span class="lineNum">    1216 </span><span class="lineNoCov">          0 :   BrigDirectiveExecutable *e = emit_function_directives (f, true);</span>
<span class="lineNum">    1217 </span><span class="lineNoCov">          0 :   emit_queued_operands ();</span>
<span class="lineNum">    1218 </span>            : 
<span class="lineNum">    1219 </span><span class="lineNoCov">          0 :   delete f;</span>
<span class="lineNum">    1220 </span>            : 
<span class="lineNum">    1221 </span><span class="lineNoCov">          0 :   return e;</span>
<span class="lineNum">    1222 </span>            : }
<span class="lineNum">    1223 </span>            : 
<span class="lineNum">    1224 </span>            : /* Emit directives describing the function that is used for
<span class="lineNum">    1225 </span>            :    an internal function declaration.  */
<a name="1226"><span class="lineNum">    1226 </span>            : </a>
<span class="lineNum">    1227 </span>            : static BrigDirectiveExecutable *
<span class="lineNum">    1228 </span><span class="lineNoCov">          0 : emit_internal_fn_decl (hsa_internal_fn *fn)</span>
<span class="lineNum">    1229 </span>            : {
<span class="lineNum">    1230 </span><span class="lineNoCov">          0 :   hsa_function_representation *f = hsa_generate_internal_fn_decl (fn);</span>
<span class="lineNum">    1231 </span>            : 
<span class="lineNum">    1232 </span><span class="lineNoCov">          0 :   BrigDirectiveExecutable *e = emit_function_directives (f, true);</span>
<span class="lineNum">    1233 </span><span class="lineNoCov">          0 :   emit_queued_operands ();</span>
<span class="lineNum">    1234 </span>            : 
<span class="lineNum">    1235 </span><span class="lineNoCov">          0 :   delete f;</span>
<span class="lineNum">    1236 </span>            : 
<span class="lineNum">    1237 </span><span class="lineNoCov">          0 :   return e;</span>
<span class="lineNum">    1238 </span>            : }
<span class="lineNum">    1239 </span>            : 
<span class="lineNum">    1240 </span>            : /* Enqueue all operands of INSN and return offset to BRIG data section
<span class="lineNum">    1241 </span>            :    to list of operand offsets.  */
<span class="lineNum">    1242 </span>            : 
<span class="lineNum">    1243 </span>            : static unsigned
<span class="lineNum">    1244 </span><span class="lineNoCov">          0 : emit_insn_operands (hsa_insn_basic *insn)</span>
<span class="lineNum">    1245 </span>            : {
<span class="lineNum">    1246 </span><span class="lineNoCov">          0 :   auto_vec&lt;BrigOperandOffset32_t, HSA_BRIG_INT_STORAGE_OPERANDS&gt;</span>
<span class="lineNum">    1247 </span><span class="lineNoCov">          0 :     operand_offsets;</span>
<span class="lineNum">    1248 </span>            : 
<span class="lineNum">    1249 </span><span class="lineNoCov">          0 :   unsigned l = insn-&gt;operand_count ();</span>
<span class="lineNum">    1250 </span>            : 
<span class="lineNum">    1251 </span>            :   /* We have N operands so use 4 * N for the byte_count.  */
<span class="lineNum">    1252 </span><span class="lineNoCov">          0 :   uint32_t byte_count = lendian32 (4 * l);</span>
<span class="lineNum">    1253 </span><span class="lineNoCov">          0 :   unsigned offset = brig_data.add (&amp;byte_count, sizeof (byte_count));</span>
<span class="lineNum">    1254 </span><span class="lineNoCov">          0 :   if (l &gt; 0)</span>
<span class="lineNum">    1255 </span>            :     {
<span class="lineNum">    1256 </span><span class="lineNoCov">          0 :       operand_offsets.safe_grow (l);</span>
<span class="lineNum">    1257 </span><span class="lineNoCov">          0 :       for (unsigned i = 0; i &lt; l; i++)</span>
<span class="lineNum">    1258 </span><span class="lineNoCov">          0 :         operand_offsets[i] = lendian32 (enqueue_op (insn-&gt;get_op (i)));</span>
<span class="lineNum">    1259 </span>            : 
<span class="lineNum">    1260 </span><span class="lineNoCov">          0 :       brig_data.add (operand_offsets.address (),</span>
<span class="lineNum">    1261 </span>            :                      l * sizeof (BrigOperandOffset32_t));
<span class="lineNum">    1262 </span>            :     }
<span class="lineNum">    1263 </span><span class="lineNoCov">          0 :   brig_data.round_size_up (4);</span>
<span class="lineNum">    1264 </span><span class="lineNoCov">          0 :   return offset;</span>
<span class="lineNum">    1265 </span>            : }
<span class="lineNum">    1266 </span>            : 
<span class="lineNum">    1267 </span>            : /* Enqueue operand OP0, OP1, OP2 (if different from NULL) and return offset
<span class="lineNum">    1268 </span>            :    to BRIG data section to list of operand offsets.  */
<span class="lineNum">    1269 </span>            : 
<span class="lineNum">    1270 </span>            : static unsigned
<span class="lineNum">    1271 </span><span class="lineNoCov">          0 : emit_operands (hsa_op_base *op0, hsa_op_base *op1 = NULL,</span>
<span class="lineNum">    1272 </span>            :                hsa_op_base *op2 = NULL)
<span class="lineNum">    1273 </span>            : {
<span class="lineNum">    1274 </span><span class="lineNoCov">          0 :   auto_vec&lt;BrigOperandOffset32_t, HSA_BRIG_INT_STORAGE_OPERANDS&gt;</span>
<span class="lineNum">    1275 </span><span class="lineNoCov">          0 :     operand_offsets;</span>
<span class="lineNum">    1276 </span>            : 
<span class="lineNum">    1277 </span><span class="lineNoCov">          0 :   gcc_checking_assert (op0 != NULL);</span>
<span class="lineNum">    1278 </span><span class="lineNoCov">          0 :   operand_offsets.safe_push (enqueue_op (op0));</span>
<span class="lineNum">    1279 </span>            : 
<span class="lineNum">    1280 </span><span class="lineNoCov">          0 :   if (op1 != NULL)</span>
<span class="lineNum">    1281 </span>            :     {
<span class="lineNum">    1282 </span><span class="lineNoCov">          0 :       operand_offsets.safe_push (enqueue_op (op1));</span>
<span class="lineNum">    1283 </span><span class="lineNoCov">          0 :       if (op2 != NULL)</span>
<span class="lineNum">    1284 </span><span class="lineNoCov">          0 :         operand_offsets.safe_push (enqueue_op (op2));</span>
<span class="lineNum">    1285 </span>            :     }
<span class="lineNum">    1286 </span>            : 
<span class="lineNum">    1287 </span><span class="lineNoCov">          0 :   unsigned l = operand_offsets.length ();</span>
<span class="lineNum">    1288 </span>            : 
<span class="lineNum">    1289 </span>            :   /* We have N operands so use 4 * N for the byte_count.  */
<span class="lineNum">    1290 </span><span class="lineNoCov">          0 :   uint32_t byte_count = lendian32 (4 * l);</span>
<span class="lineNum">    1291 </span>            : 
<span class="lineNum">    1292 </span><span class="lineNoCov">          0 :   unsigned offset = brig_data.add (&amp;byte_count, sizeof (byte_count));</span>
<span class="lineNum">    1293 </span><span class="lineNoCov">          0 :   brig_data.add (operand_offsets.address (),</span>
<span class="lineNum">    1294 </span>            :                  l * sizeof (BrigOperandOffset32_t));
<span class="lineNum">    1295 </span>            : 
<span class="lineNum">    1296 </span><span class="lineNoCov">          0 :   brig_data.round_size_up (4);</span>
<span class="lineNum">    1297 </span>            : 
<span class="lineNum">    1298 </span><span class="lineNoCov">          0 :   return offset;</span>
<span class="lineNum">    1299 </span>            : }
<span class="lineNum">    1300 </span>            : 
<span class="lineNum">    1301 </span>            : /* Emit an HSA memory instruction and all necessary directives, schedule
<span class="lineNum">    1302 </span>            :    necessary operands for writing.  */
<a name="1303"><span class="lineNum">    1303 </span>            : </a>
<span class="lineNum">    1304 </span>            : static void
<span class="lineNum">    1305 </span><span class="lineNoCov">          0 : emit_memory_insn (hsa_insn_mem *mem)</span>
<span class="lineNum">    1306 </span>            : {
<span class="lineNum">    1307 </span><span class="lineNoCov">          0 :   struct BrigInstMem repr;</span>
<span class="lineNum">    1308 </span><span class="lineNoCov">          0 :   gcc_checking_assert (mem-&gt;operand_count () == 2);</span>
<span class="lineNum">    1309 </span>            : 
<span class="lineNum">    1310 </span><span class="lineNoCov">          0 :   hsa_op_address *addr = as_a &lt;hsa_op_address *&gt; (mem-&gt;get_op (1));</span>
<span class="lineNum">    1311 </span>            : 
<span class="lineNum">    1312 </span>            :   /* This is necessary because of the erroneous typedef of
<span class="lineNum">    1313 </span>            :      BrigMemoryModifier8_t which introduces padding which may then contain
<span class="lineNum">    1314 </span>            :      random stuff (which we do not want so that we can test things don't
<span class="lineNum">    1315 </span>            :      change).  */
<span class="lineNum">    1316 </span><span class="lineNoCov">          0 :   memset (&amp;repr, 0, sizeof (repr));</span>
<span class="lineNum">    1317 </span><span class="lineNoCov">          0 :   repr.base.base.byteCount = lendian16 (sizeof (repr));</span>
<span class="lineNum">    1318 </span><span class="lineNoCov">          0 :   repr.base.base.kind = lendian16 (BRIG_KIND_INST_MEM);</span>
<span class="lineNum">    1319 </span><span class="lineNoCov">          0 :   repr.base.opcode = lendian16 (mem-&gt;m_opcode);</span>
<span class="lineNum">    1320 </span><span class="lineNoCov">          0 :   repr.base.type = lendian16 (mem-&gt;m_type);</span>
<span class="lineNum">    1321 </span><span class="lineNoCov">          0 :   repr.base.operands = lendian32 (emit_insn_operands (mem));</span>
<span class="lineNum">    1322 </span>            : 
<span class="lineNum">    1323 </span><span class="lineNoCov">          0 :   if (addr-&gt;m_symbol)</span>
<span class="lineNum">    1324 </span><span class="lineNoCov">          0 :     repr.segment = addr-&gt;m_symbol-&gt;m_segment;</span>
<span class="lineNum">    1325 </span>            :   else
<span class="lineNum">    1326 </span><span class="lineNoCov">          0 :     repr.segment = BRIG_SEGMENT_FLAT;</span>
<span class="lineNum">    1327 </span><span class="lineNoCov">          0 :   repr.modifier = 0;</span>
<span class="lineNum">    1328 </span><span class="lineNoCov">          0 :   repr.equivClass = mem-&gt;m_equiv_class;</span>
<span class="lineNum">    1329 </span><span class="lineNoCov">          0 :   repr.align = mem-&gt;m_align;</span>
<span class="lineNum">    1330 </span><span class="lineNoCov">          0 :   if (mem-&gt;m_opcode == BRIG_OPCODE_LD)</span>
<span class="lineNum">    1331 </span><span class="lineNoCov">          0 :     repr.width = BRIG_WIDTH_1;</span>
<span class="lineNum">    1332 </span>            :   else
<span class="lineNum">    1333 </span><span class="lineNoCov">          0 :     repr.width = BRIG_WIDTH_NONE;</span>
<span class="lineNum">    1334 </span><span class="lineNoCov">          0 :   memset (&amp;repr.reserved, 0, sizeof (repr.reserved));</span>
<span class="lineNum">    1335 </span><span class="lineNoCov">          0 :   brig_code.add (&amp;repr, sizeof (repr));</span>
<span class="lineNum">    1336 </span><span class="lineNoCov">          0 :   brig_insn_count++;</span>
<span class="lineNum">    1337 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1338 </span>            : 
<span class="lineNum">    1339 </span>            : /* Emit an HSA signal memory instruction and all necessary directives, schedule
<span class="lineNum">    1340 </span>            :    necessary operands for writing.  */
<a name="1341"><span class="lineNum">    1341 </span>            : </a>
<span class="lineNum">    1342 </span>            : static void
<span class="lineNum">    1343 </span><span class="lineNoCov">          0 : emit_signal_insn (hsa_insn_signal *mem)</span>
<span class="lineNum">    1344 </span>            : {
<span class="lineNum">    1345 </span><span class="lineNoCov">          0 :   struct BrigInstSignal repr;</span>
<span class="lineNum">    1346 </span>            : 
<span class="lineNum">    1347 </span><span class="lineNoCov">          0 :   memset (&amp;repr, 0, sizeof (repr));</span>
<span class="lineNum">    1348 </span><span class="lineNoCov">          0 :   repr.base.base.byteCount = lendian16 (sizeof (repr));</span>
<span class="lineNum">    1349 </span><span class="lineNoCov">          0 :   repr.base.base.kind = lendian16 (BRIG_KIND_INST_SIGNAL);</span>
<span class="lineNum">    1350 </span><span class="lineNoCov">          0 :   repr.base.opcode = lendian16 (mem-&gt;m_opcode);</span>
<span class="lineNum">    1351 </span><span class="lineNoCov">          0 :   repr.base.type = lendian16 (mem-&gt;m_type);</span>
<span class="lineNum">    1352 </span><span class="lineNoCov">          0 :   repr.base.operands = lendian32 (emit_insn_operands (mem));</span>
<span class="lineNum">    1353 </span>            : 
<span class="lineNum">    1354 </span><span class="lineNoCov">          0 :   repr.memoryOrder = mem-&gt;m_memory_order;</span>
<span class="lineNum">    1355 </span><span class="lineNoCov">          0 :   repr.signalOperation = mem-&gt;m_signalop;</span>
<span class="lineNum">    1356 </span><span class="lineNoCov">          0 :   repr.signalType = hsa_machine_large_p () ? BRIG_TYPE_SIG64 : BRIG_TYPE_SIG32;</span>
<span class="lineNum">    1357 </span>            : 
<span class="lineNum">    1358 </span><span class="lineNoCov">          0 :   brig_code.add (&amp;repr, sizeof (repr));</span>
<span class="lineNum">    1359 </span><span class="lineNoCov">          0 :   brig_insn_count++;</span>
<span class="lineNum">    1360 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1361 </span>            : 
<span class="lineNum">    1362 </span>            : /* Emit an HSA atomic memory instruction and all necessary directives, schedule
<span class="lineNum">    1363 </span>            :    necessary operands for writing.  */
<a name="1364"><span class="lineNum">    1364 </span>            : </a>
<span class="lineNum">    1365 </span>            : static void
<span class="lineNum">    1366 </span><span class="lineNoCov">          0 : emit_atomic_insn (hsa_insn_atomic *mem)</span>
<span class="lineNum">    1367 </span>            : {
<span class="lineNum">    1368 </span><span class="lineNoCov">          0 :   struct BrigInstAtomic repr;</span>
<span class="lineNum">    1369 </span>            : 
<span class="lineNum">    1370 </span>            :   /* Either operand[0] or operand[1] must be an address operand.  */
<span class="lineNum">    1371 </span><span class="lineNoCov">          0 :   hsa_op_address *addr = NULL;</span>
<span class="lineNum">    1372 </span><span class="lineNoCov">          0 :   if (is_a &lt;hsa_op_address *&gt; (mem-&gt;get_op (0)))</span>
<span class="lineNum">    1373 </span><span class="lineNoCov">          0 :     addr = as_a &lt;hsa_op_address *&gt; (mem-&gt;get_op (0));</span>
<span class="lineNum">    1374 </span>            :   else
<span class="lineNum">    1375 </span><span class="lineNoCov">          0 :     addr = as_a &lt;hsa_op_address *&gt; (mem-&gt;get_op (1));</span>
<span class="lineNum">    1376 </span>            : 
<span class="lineNum">    1377 </span><span class="lineNoCov">          0 :   memset (&amp;repr, 0, sizeof (repr));</span>
<span class="lineNum">    1378 </span><span class="lineNoCov">          0 :   repr.base.base.byteCount = lendian16 (sizeof (repr));</span>
<span class="lineNum">    1379 </span><span class="lineNoCov">          0 :   repr.base.base.kind = lendian16 (BRIG_KIND_INST_ATOMIC);</span>
<span class="lineNum">    1380 </span><span class="lineNoCov">          0 :   repr.base.opcode = lendian16 (mem-&gt;m_opcode);</span>
<span class="lineNum">    1381 </span><span class="lineNoCov">          0 :   repr.base.type = lendian16 (mem-&gt;m_type);</span>
<span class="lineNum">    1382 </span><span class="lineNoCov">          0 :   repr.base.operands = lendian32 (emit_insn_operands (mem));</span>
<span class="lineNum">    1383 </span>            : 
<span class="lineNum">    1384 </span><span class="lineNoCov">          0 :   if (addr-&gt;m_symbol)</span>
<span class="lineNum">    1385 </span><span class="lineNoCov">          0 :     repr.segment = addr-&gt;m_symbol-&gt;m_segment;</span>
<span class="lineNum">    1386 </span>            :   else
<span class="lineNum">    1387 </span><span class="lineNoCov">          0 :     repr.segment = BRIG_SEGMENT_FLAT;</span>
<span class="lineNum">    1388 </span><span class="lineNoCov">          0 :   repr.memoryOrder = mem-&gt;m_memoryorder;</span>
<span class="lineNum">    1389 </span><span class="lineNoCov">          0 :   repr.memoryScope = mem-&gt;m_memoryscope;</span>
<span class="lineNum">    1390 </span><span class="lineNoCov">          0 :   repr.atomicOperation = mem-&gt;m_atomicop;</span>
<span class="lineNum">    1391 </span>            : 
<span class="lineNum">    1392 </span><span class="lineNoCov">          0 :   brig_code.add (&amp;repr, sizeof (repr));</span>
<span class="lineNum">    1393 </span><span class="lineNoCov">          0 :   brig_insn_count++;</span>
<span class="lineNum">    1394 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1395 </span>            : 
<span class="lineNum">    1396 </span>            : /* Emit an HSA LDA instruction and all necessary directives, schedule
<span class="lineNum">    1397 </span>            :    necessary operands for writing.  */
<a name="1398"><span class="lineNum">    1398 </span>            : </a>
<span class="lineNum">    1399 </span>            : static void
<span class="lineNum">    1400 </span><span class="lineNoCov">          0 : emit_addr_insn (hsa_insn_basic *insn)</span>
<span class="lineNum">    1401 </span>            : {
<span class="lineNum">    1402 </span><span class="lineNoCov">          0 :   struct BrigInstAddr repr;</span>
<span class="lineNum">    1403 </span>            : 
<span class="lineNum">    1404 </span><span class="lineNoCov">          0 :   hsa_op_address *addr = as_a &lt;hsa_op_address *&gt; (insn-&gt;get_op (1));</span>
<span class="lineNum">    1405 </span>            : 
<span class="lineNum">    1406 </span><span class="lineNoCov">          0 :   repr.base.base.byteCount = lendian16 (sizeof (repr));</span>
<span class="lineNum">    1407 </span><span class="lineNoCov">          0 :   repr.base.base.kind = lendian16 (BRIG_KIND_INST_ADDR);</span>
<span class="lineNum">    1408 </span><span class="lineNoCov">          0 :   repr.base.opcode = lendian16 (insn-&gt;m_opcode);</span>
<span class="lineNum">    1409 </span><span class="lineNoCov">          0 :   repr.base.type = lendian16 (insn-&gt;m_type);</span>
<span class="lineNum">    1410 </span><span class="lineNoCov">          0 :   repr.base.operands = lendian32 (emit_insn_operands (insn));</span>
<span class="lineNum">    1411 </span>            : 
<span class="lineNum">    1412 </span><span class="lineNoCov">          0 :   if (addr-&gt;m_symbol)</span>
<span class="lineNum">    1413 </span><span class="lineNoCov">          0 :     repr.segment = addr-&gt;m_symbol-&gt;m_segment;</span>
<span class="lineNum">    1414 </span>            :   else
<span class="lineNum">    1415 </span><span class="lineNoCov">          0 :     repr.segment = BRIG_SEGMENT_FLAT;</span>
<span class="lineNum">    1416 </span><span class="lineNoCov">          0 :   memset (&amp;repr.reserved, 0, sizeof (repr.reserved));</span>
<span class="lineNum">    1417 </span>            : 
<span class="lineNum">    1418 </span><span class="lineNoCov">          0 :   brig_code.add (&amp;repr, sizeof (repr));</span>
<span class="lineNum">    1419 </span><span class="lineNoCov">          0 :   brig_insn_count++;</span>
<span class="lineNum">    1420 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1421 </span>            : 
<span class="lineNum">    1422 </span>            : /* Emit an HSA segment conversion instruction and all necessary directives,
<span class="lineNum">    1423 </span>            :    schedule necessary operands for writing.  */
<a name="1424"><span class="lineNum">    1424 </span>            : </a>
<span class="lineNum">    1425 </span>            : static void
<span class="lineNum">    1426 </span><span class="lineNoCov">          0 : emit_segment_insn (hsa_insn_seg *seg)</span>
<span class="lineNum">    1427 </span>            : {
<span class="lineNum">    1428 </span><span class="lineNoCov">          0 :   struct BrigInstSegCvt repr;</span>
<span class="lineNum">    1429 </span>            : 
<span class="lineNum">    1430 </span><span class="lineNoCov">          0 :   repr.base.base.byteCount = lendian16 (sizeof (repr));</span>
<span class="lineNum">    1431 </span><span class="lineNoCov">          0 :   repr.base.base.kind = lendian16 (BRIG_KIND_INST_SEG_CVT);</span>
<span class="lineNum">    1432 </span><span class="lineNoCov">          0 :   repr.base.opcode = lendian16 (seg-&gt;m_opcode);</span>
<span class="lineNum">    1433 </span><span class="lineNoCov">          0 :   repr.base.type = lendian16 (seg-&gt;m_type);</span>
<span class="lineNum">    1434 </span><span class="lineNoCov">          0 :   repr.base.operands = lendian32 (emit_insn_operands (seg));</span>
<span class="lineNum">    1435 </span><span class="lineNoCov">          0 :   repr.sourceType = lendian16 (as_a &lt;hsa_op_reg *&gt; (seg-&gt;get_op (1))-&gt;m_type);</span>
<span class="lineNum">    1436 </span><span class="lineNoCov">          0 :   repr.segment = seg-&gt;m_segment;</span>
<span class="lineNum">    1437 </span><span class="lineNoCov">          0 :   repr.modifier = 0;</span>
<span class="lineNum">    1438 </span>            : 
<span class="lineNum">    1439 </span><span class="lineNoCov">          0 :   brig_code.add (&amp;repr, sizeof (repr));</span>
<span class="lineNum">    1440 </span>            : 
<span class="lineNum">    1441 </span><span class="lineNoCov">          0 :   brig_insn_count++;</span>
<span class="lineNum">    1442 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1443 </span>            : 
<span class="lineNum">    1444 </span>            : /* Emit an HSA alloca instruction and all necessary directives,
<span class="lineNum">    1445 </span>            :    schedule necessary operands for writing.  */
<a name="1446"><span class="lineNum">    1446 </span>            : </a>
<span class="lineNum">    1447 </span>            : static void
<span class="lineNum">    1448 </span><span class="lineNoCov">          0 : emit_alloca_insn (hsa_insn_alloca *alloca)</span>
<span class="lineNum">    1449 </span>            : {
<span class="lineNum">    1450 </span><span class="lineNoCov">          0 :   struct BrigInstMem repr;</span>
<span class="lineNum">    1451 </span><span class="lineNoCov">          0 :   gcc_checking_assert (alloca-&gt;operand_count () == 2);</span>
<span class="lineNum">    1452 </span>            : 
<span class="lineNum">    1453 </span><span class="lineNoCov">          0 :   memset (&amp;repr, 0, sizeof (repr));</span>
<span class="lineNum">    1454 </span><span class="lineNoCov">          0 :   repr.base.base.byteCount = lendian16 (sizeof (repr));</span>
<span class="lineNum">    1455 </span><span class="lineNoCov">          0 :   repr.base.base.kind = lendian16 (BRIG_KIND_INST_MEM);</span>
<span class="lineNum">    1456 </span><span class="lineNoCov">          0 :   repr.base.opcode = lendian16 (alloca-&gt;m_opcode);</span>
<span class="lineNum">    1457 </span><span class="lineNoCov">          0 :   repr.base.type = lendian16 (alloca-&gt;m_type);</span>
<span class="lineNum">    1458 </span><span class="lineNoCov">          0 :   repr.base.operands = lendian32 (emit_insn_operands (alloca));</span>
<span class="lineNum">    1459 </span><span class="lineNoCov">          0 :   repr.segment = BRIG_SEGMENT_PRIVATE;</span>
<span class="lineNum">    1460 </span><span class="lineNoCov">          0 :   repr.modifier = 0;</span>
<span class="lineNum">    1461 </span><span class="lineNoCov">          0 :   repr.equivClass = 0;</span>
<span class="lineNum">    1462 </span><span class="lineNoCov">          0 :   repr.align = alloca-&gt;m_align;</span>
<span class="lineNum">    1463 </span><span class="lineNoCov">          0 :   repr.width = BRIG_WIDTH_NONE;</span>
<span class="lineNum">    1464 </span><span class="lineNoCov">          0 :   memset (&amp;repr.reserved, 0, sizeof (repr.reserved));</span>
<span class="lineNum">    1465 </span><span class="lineNoCov">          0 :   brig_code.add (&amp;repr, sizeof (repr));</span>
<span class="lineNum">    1466 </span><span class="lineNoCov">          0 :   brig_insn_count++;</span>
<span class="lineNum">    1467 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1468 </span>            : 
<span class="lineNum">    1469 </span>            : /* Emit an HSA comparison instruction and all necessary directives,
<span class="lineNum">    1470 </span>            :    schedule necessary operands for writing.  */
<a name="1471"><span class="lineNum">    1471 </span>            : </a>
<span class="lineNum">    1472 </span>            : static void
<span class="lineNum">    1473 </span><span class="lineNoCov">          0 : emit_cmp_insn (hsa_insn_cmp *cmp)</span>
<span class="lineNum">    1474 </span>            : {
<span class="lineNum">    1475 </span><span class="lineNoCov">          0 :   struct BrigInstCmp repr;</span>
<span class="lineNum">    1476 </span>            : 
<span class="lineNum">    1477 </span><span class="lineNoCov">          0 :   memset (&amp;repr, 0, sizeof (repr));</span>
<span class="lineNum">    1478 </span><span class="lineNoCov">          0 :   repr.base.base.byteCount = lendian16 (sizeof (repr));</span>
<span class="lineNum">    1479 </span><span class="lineNoCov">          0 :   repr.base.base.kind = lendian16 (BRIG_KIND_INST_CMP);</span>
<span class="lineNum">    1480 </span><span class="lineNoCov">          0 :   repr.base.opcode = lendian16 (cmp-&gt;m_opcode);</span>
<span class="lineNum">    1481 </span><span class="lineNoCov">          0 :   repr.base.type = lendian16 (cmp-&gt;m_type);</span>
<span class="lineNum">    1482 </span><span class="lineNoCov">          0 :   repr.base.operands = lendian32 (emit_insn_operands (cmp));</span>
<span class="lineNum">    1483 </span>            : 
<span class="lineNum">    1484 </span><span class="lineNoCov">          0 :   if (is_a &lt;hsa_op_reg *&gt; (cmp-&gt;get_op (1)))</span>
<span class="lineNum">    1485 </span><span class="lineNoCov">          0 :     repr.sourceType</span>
<span class="lineNum">    1486 </span><span class="lineNoCov">          0 :       = lendian16 (as_a &lt;hsa_op_reg *&gt; (cmp-&gt;get_op (1))-&gt;m_type);</span>
<span class="lineNum">    1487 </span>            :   else
<span class="lineNum">    1488 </span><span class="lineNoCov">          0 :     repr.sourceType</span>
<span class="lineNum">    1489 </span><span class="lineNoCov">          0 :       = lendian16 (as_a &lt;hsa_op_immed *&gt; (cmp-&gt;get_op (1))-&gt;m_type);</span>
<span class="lineNum">    1490 </span><span class="lineNoCov">          0 :   repr.modifier = 0;</span>
<span class="lineNum">    1491 </span><span class="lineNoCov">          0 :   repr.compare = cmp-&gt;m_compare;</span>
<span class="lineNum">    1492 </span><span class="lineNoCov">          0 :   repr.pack = 0;</span>
<span class="lineNum">    1493 </span>            : 
<span class="lineNum">    1494 </span><span class="lineNoCov">          0 :   brig_code.add (&amp;repr, sizeof (repr));</span>
<span class="lineNum">    1495 </span><span class="lineNoCov">          0 :   brig_insn_count++;</span>
<span class="lineNum">    1496 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1497 </span>            : 
<span class="lineNum">    1498 </span>            : /* Emit an HSA generic branching/sycnronization instruction.  */
<a name="1499"><span class="lineNum">    1499 </span>            : </a>
<span class="lineNum">    1500 </span>            : static void
<span class="lineNum">    1501 </span><span class="lineNoCov">          0 : emit_generic_branch_insn (hsa_insn_br *br)</span>
<span class="lineNum">    1502 </span>            : {
<span class="lineNum">    1503 </span><span class="lineNoCov">          0 :   struct BrigInstBr repr;</span>
<span class="lineNum">    1504 </span><span class="lineNoCov">          0 :   repr.base.base.byteCount = lendian16 (sizeof (repr));</span>
<span class="lineNum">    1505 </span><span class="lineNoCov">          0 :   repr.base.base.kind = lendian16 (BRIG_KIND_INST_BR);</span>
<span class="lineNum">    1506 </span><span class="lineNoCov">          0 :   repr.base.opcode = lendian16 (br-&gt;m_opcode);</span>
<span class="lineNum">    1507 </span><span class="lineNoCov">          0 :   repr.width = br-&gt;m_width;</span>
<span class="lineNum">    1508 </span><span class="lineNoCov">          0 :   repr.base.type = lendian16 (br-&gt;m_type);</span>
<span class="lineNum">    1509 </span><span class="lineNoCov">          0 :   repr.base.operands = lendian32 (emit_insn_operands (br));</span>
<span class="lineNum">    1510 </span><span class="lineNoCov">          0 :   memset (&amp;repr.reserved, 0, sizeof (repr.reserved));</span>
<span class="lineNum">    1511 </span>            : 
<span class="lineNum">    1512 </span><span class="lineNoCov">          0 :   brig_code.add (&amp;repr, sizeof (repr));</span>
<span class="lineNum">    1513 </span><span class="lineNoCov">          0 :   brig_insn_count++;</span>
<span class="lineNum">    1514 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1515 </span>            : 
<span class="lineNum">    1516 </span>            : /* Emit an HSA conditional branching instruction and all necessary directives,
<span class="lineNum">    1517 </span>            :    schedule necessary operands for writing.  */
<a name="1518"><span class="lineNum">    1518 </span>            : </a>
<span class="lineNum">    1519 </span>            : static void
<span class="lineNum">    1520 </span><span class="lineNoCov">          0 : emit_cond_branch_insn (hsa_insn_cbr *br)</span>
<span class="lineNum">    1521 </span>            : {
<span class="lineNum">    1522 </span><span class="lineNoCov">          0 :   struct BrigInstBr repr;</span>
<span class="lineNum">    1523 </span>            : 
<span class="lineNum">    1524 </span><span class="lineNoCov">          0 :   basic_block target = NULL;</span>
<span class="lineNum">    1525 </span><span class="lineNoCov">          0 :   edge_iterator ei;</span>
<span class="lineNum">    1526 </span><span class="lineNoCov">          0 :   edge e;</span>
<span class="lineNum">    1527 </span>            : 
<span class="lineNum">    1528 </span>            :   /* At the moment we only handle direct conditional jumps.  */
<span class="lineNum">    1529 </span><span class="lineNoCov">          0 :   gcc_assert (br-&gt;m_opcode == BRIG_OPCODE_CBR);</span>
<span class="lineNum">    1530 </span><span class="lineNoCov">          0 :   repr.base.base.byteCount = lendian16 (sizeof (repr));</span>
<span class="lineNum">    1531 </span><span class="lineNoCov">          0 :   repr.base.base.kind = lendian16 (BRIG_KIND_INST_BR);</span>
<span class="lineNum">    1532 </span><span class="lineNoCov">          0 :   repr.base.opcode = lendian16 (br-&gt;m_opcode);</span>
<span class="lineNum">    1533 </span><span class="lineNoCov">          0 :   repr.width = br-&gt;m_width;</span>
<span class="lineNum">    1534 </span>            :   /* For Conditional jumps the type is always B1.  */
<span class="lineNum">    1535 </span><span class="lineNoCov">          0 :   repr.base.type = lendian16 (BRIG_TYPE_B1);</span>
<span class="lineNum">    1536 </span>            : 
<span class="lineNum">    1537 </span><span class="lineNoCov">          0 :   FOR_EACH_EDGE (e, ei, br-&gt;m_bb-&gt;succs)</span>
<span class="lineNum">    1538 </span><span class="lineNoCov">          0 :     if (e-&gt;flags &amp; EDGE_TRUE_VALUE)</span>
<span class="lineNum">    1539 </span>            :       {
<span class="lineNum">    1540 </span><span class="lineNoCov">          0 :         target = e-&gt;dest;</span>
<span class="lineNum">    1541 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">    1542 </span>            :       }
<span class="lineNum">    1543 </span><span class="lineNoCov">          0 :   gcc_assert (target);</span>
<span class="lineNum">    1544 </span>            : 
<span class="lineNum">    1545 </span><span class="lineNoCov">          0 :   repr.base.operands</span>
<span class="lineNum">    1546 </span><span class="lineNoCov">          0 :     = lendian32 (emit_operands (br-&gt;get_op (0),</span>
<span class="lineNum">    1547 </span><span class="lineNoCov">          0 :                                 &amp;hsa_bb_for_bb (target)-&gt;m_label_ref));</span>
<span class="lineNum">    1548 </span><span class="lineNoCov">          0 :   memset (&amp;repr.reserved, 0, sizeof (repr.reserved));</span>
<span class="lineNum">    1549 </span>            : 
<span class="lineNum">    1550 </span><span class="lineNoCov">          0 :   brig_code.add (&amp;repr, sizeof (repr));</span>
<span class="lineNum">    1551 </span><span class="lineNoCov">          0 :   brig_insn_count++;</span>
<span class="lineNum">    1552 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1553 </span>            : 
<span class="lineNum">    1554 </span>            : /* Emit an HSA unconditional jump branching instruction that points to
<span class="lineNum">    1555 </span>            :    a label REFERENCE.  */
<a name="1556"><span class="lineNum">    1556 </span>            : </a>
<span class="lineNum">    1557 </span>            : static void
<span class="lineNum">    1558 </span><span class="lineNoCov">          0 : emit_unconditional_jump (hsa_op_code_ref *reference)</span>
<span class="lineNum">    1559 </span>            : {
<span class="lineNum">    1560 </span><span class="lineNoCov">          0 :   struct BrigInstBr repr;</span>
<span class="lineNum">    1561 </span>            : 
<span class="lineNum">    1562 </span><span class="lineNoCov">          0 :   repr.base.base.byteCount = lendian16 (sizeof (repr));</span>
<span class="lineNum">    1563 </span><span class="lineNoCov">          0 :   repr.base.base.kind = lendian16 (BRIG_KIND_INST_BR);</span>
<span class="lineNum">    1564 </span><span class="lineNoCov">          0 :   repr.base.opcode = lendian16 (BRIG_OPCODE_BR);</span>
<span class="lineNum">    1565 </span><span class="lineNoCov">          0 :   repr.base.type = lendian16 (BRIG_TYPE_NONE);</span>
<span class="lineNum">    1566 </span>            :   /* Direct branches to labels must be width(all).  */
<span class="lineNum">    1567 </span><span class="lineNoCov">          0 :   repr.width = BRIG_WIDTH_ALL;</span>
<span class="lineNum">    1568 </span>            : 
<span class="lineNum">    1569 </span><span class="lineNoCov">          0 :   repr.base.operands = lendian32 (emit_operands (reference));</span>
<span class="lineNum">    1570 </span><span class="lineNoCov">          0 :   memset (&amp;repr.reserved, 0, sizeof (repr.reserved));</span>
<span class="lineNum">    1571 </span><span class="lineNoCov">          0 :   brig_code.add (&amp;repr, sizeof (repr));</span>
<span class="lineNum">    1572 </span><span class="lineNoCov">          0 :   brig_insn_count++;</span>
<span class="lineNum">    1573 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1574 </span>            : 
<span class="lineNum">    1575 </span>            : /* Emit an HSA switch jump instruction that uses a jump table to
<span class="lineNum">    1576 </span>            :    jump to a destination label.  */
<a name="1577"><span class="lineNum">    1577 </span>            : </a>
<span class="lineNum">    1578 </span>            : static void
<span class="lineNum">    1579 </span><span class="lineNoCov">          0 : emit_switch_insn (hsa_insn_sbr *sbr)</span>
<span class="lineNum">    1580 </span>            : {
<span class="lineNum">    1581 </span><span class="lineNoCov">          0 :   struct BrigInstBr repr;</span>
<span class="lineNum">    1582 </span>            : 
<span class="lineNum">    1583 </span><span class="lineNoCov">          0 :   gcc_assert (sbr-&gt;m_opcode == BRIG_OPCODE_SBR);</span>
<span class="lineNum">    1584 </span><span class="lineNoCov">          0 :   repr.base.base.byteCount = lendian16 (sizeof (repr));</span>
<span class="lineNum">    1585 </span><span class="lineNoCov">          0 :   repr.base.base.kind = lendian16 (BRIG_KIND_INST_BR);</span>
<span class="lineNum">    1586 </span><span class="lineNoCov">          0 :   repr.base.opcode = lendian16 (sbr-&gt;m_opcode);</span>
<span class="lineNum">    1587 </span><span class="lineNoCov">          0 :   repr.width = BRIG_WIDTH_1;</span>
<span class="lineNum">    1588 </span>            :   /* For Conditional jumps the type is always B1.  */
<span class="lineNum">    1589 </span><span class="lineNoCov">          0 :   hsa_op_reg *index = as_a &lt;hsa_op_reg *&gt; (sbr-&gt;get_op (0));</span>
<span class="lineNum">    1590 </span><span class="lineNoCov">          0 :   repr.base.type = lendian16 (index-&gt;m_type);</span>
<span class="lineNum">    1591 </span><span class="lineNoCov">          0 :   repr.base.operands</span>
<span class="lineNum">    1592 </span><span class="lineNoCov">          0 :     = lendian32 (emit_operands (sbr-&gt;get_op (0), sbr-&gt;m_label_code_list));</span>
<span class="lineNum">    1593 </span><span class="lineNoCov">          0 :   memset (&amp;repr.reserved, 0, sizeof (repr.reserved));</span>
<span class="lineNum">    1594 </span>            : 
<span class="lineNum">    1595 </span><span class="lineNoCov">          0 :   brig_code.add (&amp;repr, sizeof (repr));</span>
<span class="lineNum">    1596 </span><span class="lineNoCov">          0 :   brig_insn_count++;</span>
<span class="lineNum">    1597 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1598 </span>            : 
<span class="lineNum">    1599 </span>            : /* Emit a HSA convert instruction and all necessary directives, schedule
<span class="lineNum">    1600 </span>            :    necessary operands for writing.  */
<a name="1601"><span class="lineNum">    1601 </span>            : </a>
<span class="lineNum">    1602 </span>            : static void
<span class="lineNum">    1603 </span><span class="lineNoCov">          0 : emit_cvt_insn (hsa_insn_cvt *insn)</span>
<span class="lineNum">    1604 </span>            : {
<span class="lineNum">    1605 </span><span class="lineNoCov">          0 :   struct BrigInstCvt repr;</span>
<span class="lineNum">    1606 </span><span class="lineNoCov">          0 :   BrigType16_t srctype;</span>
<span class="lineNum">    1607 </span>            : 
<span class="lineNum">    1608 </span><span class="lineNoCov">          0 :   repr.base.base.byteCount = lendian16 (sizeof (repr));</span>
<span class="lineNum">    1609 </span><span class="lineNoCov">          0 :   repr.base.base.kind = lendian16 (BRIG_KIND_INST_CVT);</span>
<span class="lineNum">    1610 </span><span class="lineNoCov">          0 :   repr.base.opcode = lendian16 (insn-&gt;m_opcode);</span>
<span class="lineNum">    1611 </span><span class="lineNoCov">          0 :   repr.base.type = lendian16 (insn-&gt;m_type);</span>
<span class="lineNum">    1612 </span><span class="lineNoCov">          0 :   repr.base.operands = lendian32 (emit_insn_operands (insn));</span>
<span class="lineNum">    1613 </span>            : 
<span class="lineNum">    1614 </span><span class="lineNoCov">          0 :   if (is_a &lt;hsa_op_reg *&gt; (insn-&gt;get_op (1)))</span>
<span class="lineNum">    1615 </span><span class="lineNoCov">          0 :     srctype = as_a &lt;hsa_op_reg *&gt; (insn-&gt;get_op (1))-&gt;m_type;</span>
<span class="lineNum">    1616 </span>            :   else
<span class="lineNum">    1617 </span><span class="lineNoCov">          0 :     srctype = as_a &lt;hsa_op_immed *&gt; (insn-&gt;get_op (1))-&gt;m_type;</span>
<span class="lineNum">    1618 </span><span class="lineNoCov">          0 :   repr.sourceType = lendian16 (srctype);</span>
<span class="lineNum">    1619 </span><span class="lineNoCov">          0 :   repr.modifier = 0;</span>
<span class="lineNum">    1620 </span>            :   /* float to smaller float requires a rounding setting (we default
<span class="lineNum">    1621 </span>            :      to 'near'.  */
<span class="lineNum">    1622 </span><span class="lineNoCov">          0 :   if (hsa_type_float_p (insn-&gt;m_type)</span>
<span class="lineNum">    1623 </span><span class="lineNoCov">          0 :       &amp;&amp; (!hsa_type_float_p (srctype)</span>
<span class="lineNum">    1624 </span><span class="lineNoCov">          0 :           || ((insn-&gt;m_type &amp; BRIG_TYPE_BASE_MASK)</span>
<span class="lineNum">    1625 </span>            :               &lt; (srctype &amp; BRIG_TYPE_BASE_MASK))))
<span class="lineNum">    1626 </span><span class="lineNoCov">          0 :     repr.round = BRIG_ROUND_FLOAT_NEAR_EVEN;</span>
<span class="lineNum">    1627 </span><span class="lineNoCov">          0 :   else if (hsa_type_integer_p (insn-&gt;m_type) &amp;&amp;</span>
<span class="lineNum">    1628 </span><span class="lineNoCov">          0 :            hsa_type_float_p (srctype))</span>
<span class="lineNum">    1629 </span><span class="lineNoCov">          0 :     repr.round = BRIG_ROUND_INTEGER_ZERO;</span>
<span class="lineNum">    1630 </span>            :   else
<span class="lineNum">    1631 </span><span class="lineNoCov">          0 :     repr.round = BRIG_ROUND_NONE;</span>
<span class="lineNum">    1632 </span><span class="lineNoCov">          0 :   brig_code.add (&amp;repr, sizeof (repr));</span>
<span class="lineNum">    1633 </span><span class="lineNoCov">          0 :   brig_insn_count++;</span>
<span class="lineNum">    1634 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1635 </span>            : 
<span class="lineNum">    1636 </span>            : /* Emit call instruction INSN, where this instruction must be closed
<span class="lineNum">    1637 </span>            :    within a call block instruction.  */
<a name="1638"><span class="lineNum">    1638 </span>            : </a>
<span class="lineNum">    1639 </span>            : static void
<span class="lineNum">    1640 </span><span class="lineNoCov">          0 : emit_call_insn (hsa_insn_call *call)</span>
<span class="lineNum">    1641 </span>            : {
<span class="lineNum">    1642 </span><span class="lineNoCov">          0 :   struct BrigInstBr repr;</span>
<span class="lineNum">    1643 </span>            : 
<span class="lineNum">    1644 </span><span class="lineNoCov">          0 :   repr.base.base.byteCount = lendian16 (sizeof (repr));</span>
<span class="lineNum">    1645 </span><span class="lineNoCov">          0 :   repr.base.base.kind = lendian16 (BRIG_KIND_INST_BR);</span>
<span class="lineNum">    1646 </span><span class="lineNoCov">          0 :   repr.base.opcode = lendian16 (BRIG_OPCODE_CALL);</span>
<span class="lineNum">    1647 </span><span class="lineNoCov">          0 :   repr.base.type = lendian16 (BRIG_TYPE_NONE);</span>
<span class="lineNum">    1648 </span>            : 
<span class="lineNum">    1649 </span><span class="lineNoCov">          0 :   repr.base.operands</span>
<span class="lineNum">    1650 </span><span class="lineNoCov">          0 :     = lendian32 (emit_operands (call-&gt;m_result_code_list, &amp;call-&gt;m_func,</span>
<span class="lineNum">    1651 </span><span class="lineNoCov">          0 :                                 call-&gt;m_args_code_list));</span>
<span class="lineNum">    1652 </span>            : 
<span class="lineNum">    1653 </span>            :   /* Internal functions have not set m_called_function.  */
<span class="lineNum">    1654 </span><span class="lineNoCov">          0 :   if (call-&gt;m_called_function)</span>
<span class="lineNum">    1655 </span>            :     {
<span class="lineNum">    1656 </span><span class="lineNoCov">          0 :       function_linkage_pair pair (call-&gt;m_called_function,</span>
<span class="lineNum">    1657 </span><span class="lineNoCov">          0 :                                   call-&gt;m_func.m_brig_op_offset);</span>
<span class="lineNum">    1658 </span><span class="lineNoCov">          0 :       function_call_linkage.safe_push (pair);</span>
<span class="lineNum">    1659 </span>            :     }
<span class="lineNum">    1660 </span>            :   else
<span class="lineNum">    1661 </span>            :     {
<span class="lineNum">    1662 </span><span class="lineNoCov">          0 :       hsa_internal_fn *slot</span>
<span class="lineNum">    1663 </span><span class="lineNoCov">          0 :         = hsa_emitted_internal_decls-&gt;find (call-&gt;m_called_internal_fn);</span>
<span class="lineNum">    1664 </span><span class="lineNoCov">          0 :       gcc_assert (slot);</span>
<span class="lineNum">    1665 </span><span class="lineNoCov">          0 :       gcc_assert (slot-&gt;m_offset &gt; 0);</span>
<span class="lineNum">    1666 </span><span class="lineNoCov">          0 :       call-&gt;m_func.m_directive_offset = slot-&gt;m_offset;</span>
<span class="lineNum">    1667 </span>            :     }
<span class="lineNum">    1668 </span>            : 
<span class="lineNum">    1669 </span><span class="lineNoCov">          0 :   repr.width = BRIG_WIDTH_ALL;</span>
<span class="lineNum">    1670 </span><span class="lineNoCov">          0 :   memset (&amp;repr.reserved, 0, sizeof (repr.reserved));</span>
<span class="lineNum">    1671 </span>            : 
<span class="lineNum">    1672 </span><span class="lineNoCov">          0 :   brig_code.add (&amp;repr, sizeof (repr));</span>
<span class="lineNum">    1673 </span><span class="lineNoCov">          0 :   brig_insn_count++;</span>
<span class="lineNum">    1674 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1675 </span>            : 
<span class="lineNum">    1676 </span>            : /* Emit argument block directive.  */
<span class="lineNum">    1677 </span>            : 
<span class="lineNum">    1678 </span>            : static void
<span class="lineNum">    1679 </span><span class="lineNoCov">          0 : emit_arg_block_insn (hsa_insn_arg_block *insn)</span>
<span class="lineNum">    1680 </span>            : {
<span class="lineNum">    1681 </span><span class="lineNoCov">          0 :   switch (insn-&gt;m_kind)</span>
<span class="lineNum">    1682 </span>            :     {
<span class="lineNum">    1683 </span><span class="lineNoCov">          0 :     case BRIG_KIND_DIRECTIVE_ARG_BLOCK_START:</span>
<span class="lineNum">    1684 </span><span class="lineNoCov">          0 :       {</span>
<span class="lineNum">    1685 </span><span class="lineNoCov">          0 :         struct BrigDirectiveArgBlock repr;</span>
<span class="lineNum">    1686 </span><span class="lineNoCov">          0 :         repr.base.byteCount = lendian16 (sizeof (repr));</span>
<span class="lineNum">    1687 </span><span class="lineNoCov">          0 :         repr.base.kind = lendian16 (insn-&gt;m_kind);</span>
<span class="lineNum">    1688 </span><span class="lineNoCov">          0 :         brig_code.add (&amp;repr, sizeof (repr));</span>
<span class="lineNum">    1689 </span>            : 
<span class="lineNum">    1690 </span><span class="lineNoCov">          0 :         for (unsigned i = 0; i &lt; insn-&gt;m_call_insn-&gt;m_input_args.length (); i++)</span>
<span class="lineNum">    1691 </span>            :           {
<span class="lineNum">    1692 </span><span class="lineNoCov">          0 :             insn-&gt;m_call_insn-&gt;m_args_code_list-&gt;m_offsets[i]</span>
<span class="lineNum">    1693 </span><span class="lineNoCov">          0 :               = lendian32 (emit_directive_variable</span>
<span class="lineNum">    1694 </span><span class="lineNoCov">          0 :                            (insn-&gt;m_call_insn-&gt;m_input_args[i]));</span>
<span class="lineNum">    1695 </span><span class="lineNoCov">          0 :             brig_insn_count++;</span>
<span class="lineNum">    1696 </span>            :           }
<span class="lineNum">    1697 </span>            : 
<span class="lineNum">    1698 </span><span class="lineNoCov">          0 :         if (insn-&gt;m_call_insn-&gt;m_output_arg)</span>
<span class="lineNum">    1699 </span>            :           {
<span class="lineNum">    1700 </span><span class="lineNoCov">          0 :             insn-&gt;m_call_insn-&gt;m_result_code_list-&gt;m_offsets[0]</span>
<span class="lineNum">    1701 </span><span class="lineNoCov">          0 :               = lendian32 (emit_directive_variable</span>
<span class="lineNum">    1702 </span>            :                            (insn-&gt;m_call_insn-&gt;m_output_arg));
<span class="lineNum">    1703 </span><span class="lineNoCov">          0 :             brig_insn_count++;</span>
<span class="lineNum">    1704 </span>            :           }
<span class="lineNum">    1705 </span>            : 
<span class="lineNum">    1706 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">    1707 </span>            :       }
<span class="lineNum">    1708 </span><span class="lineNoCov">          0 :     case BRIG_KIND_DIRECTIVE_ARG_BLOCK_END:</span>
<span class="lineNum">    1709 </span><span class="lineNoCov">          0 :       {</span>
<span class="lineNum">    1710 </span><span class="lineNoCov">          0 :         struct BrigDirectiveArgBlock repr;</span>
<span class="lineNum">    1711 </span><span class="lineNoCov">          0 :         repr.base.byteCount = lendian16 (sizeof (repr));</span>
<span class="lineNum">    1712 </span><span class="lineNoCov">          0 :         repr.base.kind = lendian16 (insn-&gt;m_kind);</span>
<span class="lineNum">    1713 </span><span class="lineNoCov">          0 :         brig_code.add (&amp;repr, sizeof (repr));</span>
<span class="lineNum">    1714 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">    1715 </span>            :       }
<span class="lineNum">    1716 </span><span class="lineNoCov">          0 :     default:</span>
<span class="lineNum">    1717 </span><span class="lineNoCov">          0 :       gcc_unreachable ();</span>
<span class="lineNum">    1718 </span>            :     }
<span class="lineNum">    1719 </span>            : 
<span class="lineNum">    1720 </span><span class="lineNoCov">          0 :   brig_insn_count++;</span>
<span class="lineNum">    1721 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1722 </span>            : 
<span class="lineNum">    1723 </span>            : /* Emit comment directive.  */
<a name="1724"><span class="lineNum">    1724 </span>            : </a>
<span class="lineNum">    1725 </span>            : static void
<span class="lineNum">    1726 </span><span class="lineNoCov">          0 : emit_comment_insn (hsa_insn_comment *insn)</span>
<span class="lineNum">    1727 </span>            : {
<span class="lineNum">    1728 </span><span class="lineNoCov">          0 :   struct BrigDirectiveComment repr;</span>
<span class="lineNum">    1729 </span><span class="lineNoCov">          0 :   memset (&amp;repr, 0, sizeof (repr));</span>
<span class="lineNum">    1730 </span>            : 
<span class="lineNum">    1731 </span><span class="lineNoCov">          0 :   repr.base.byteCount = lendian16 (sizeof (repr));</span>
<span class="lineNum">    1732 </span><span class="lineNoCov">          0 :   repr.base.kind = lendian16 (insn-&gt;m_opcode);</span>
<span class="lineNum">    1733 </span><span class="lineNoCov">          0 :   repr.name = brig_emit_string (insn-&gt;m_comment, '\0', false);</span>
<span class="lineNum">    1734 </span><span class="lineNoCov">          0 :   brig_code.add (&amp;repr, sizeof (repr));</span>
<span class="lineNum">    1735 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1736 </span>            : 
<span class="lineNum">    1737 </span>            : /* Emit queue instruction INSN.  */
<a name="1738"><span class="lineNum">    1738 </span>            : </a>
<span class="lineNum">    1739 </span>            : static void
<span class="lineNum">    1740 </span><span class="lineNoCov">          0 : emit_queue_insn (hsa_insn_queue *insn)</span>
<span class="lineNum">    1741 </span>            : {
<span class="lineNum">    1742 </span><span class="lineNoCov">          0 :   BrigInstQueue repr;</span>
<span class="lineNum">    1743 </span><span class="lineNoCov">          0 :   memset (&amp;repr, 0, sizeof (repr));</span>
<span class="lineNum">    1744 </span>            : 
<span class="lineNum">    1745 </span><span class="lineNoCov">          0 :   repr.base.base.byteCount = lendian16 (sizeof (repr));</span>
<span class="lineNum">    1746 </span><span class="lineNoCov">          0 :   repr.base.base.kind = lendian16 (BRIG_KIND_INST_QUEUE);</span>
<span class="lineNum">    1747 </span><span class="lineNoCov">          0 :   repr.base.opcode = lendian16 (insn-&gt;m_opcode);</span>
<span class="lineNum">    1748 </span><span class="lineNoCov">          0 :   repr.base.type = lendian16 (insn-&gt;m_type);</span>
<span class="lineNum">    1749 </span><span class="lineNoCov">          0 :   repr.segment = insn-&gt;m_segment;</span>
<span class="lineNum">    1750 </span><span class="lineNoCov">          0 :   repr.memoryOrder = insn-&gt;m_memory_order;</span>
<span class="lineNum">    1751 </span><span class="lineNoCov">          0 :   repr.base.operands = lendian32 (emit_insn_operands (insn));</span>
<span class="lineNum">    1752 </span><span class="lineNoCov">          0 :   brig_data.round_size_up (4);</span>
<span class="lineNum">    1753 </span><span class="lineNoCov">          0 :   brig_code.add (&amp;repr, sizeof (repr));</span>
<span class="lineNum">    1754 </span>            : 
<span class="lineNum">    1755 </span><span class="lineNoCov">          0 :   brig_insn_count++;</span>
<span class="lineNum">    1756 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1757 </span>            : 
<span class="lineNum">    1758 </span>            : /* Emit source type instruction INSN.  */
<a name="1759"><span class="lineNum">    1759 </span>            : </a>
<span class="lineNum">    1760 </span>            : static void
<span class="lineNum">    1761 </span><span class="lineNoCov">          0 : emit_srctype_insn (hsa_insn_srctype *insn)</span>
<span class="lineNum">    1762 </span>            : {
<span class="lineNum">    1763 </span>            :   /* We assume that BrigInstMod has a BrigInstBasic prefix.  */
<span class="lineNum">    1764 </span><span class="lineNoCov">          0 :   struct BrigInstSourceType repr;</span>
<span class="lineNum">    1765 </span><span class="lineNoCov">          0 :   unsigned operand_count = insn-&gt;operand_count ();</span>
<span class="lineNum">    1766 </span><span class="lineNoCov">          0 :   gcc_checking_assert (operand_count &gt;= 2);</span>
<span class="lineNum">    1767 </span>            : 
<span class="lineNum">    1768 </span><span class="lineNoCov">          0 :   memset (&amp;repr, 0, sizeof (repr));</span>
<span class="lineNum">    1769 </span><span class="lineNoCov">          0 :   repr.sourceType = lendian16 (insn-&gt;m_source_type);</span>
<span class="lineNum">    1770 </span><span class="lineNoCov">          0 :   repr.base.base.byteCount = lendian16 (sizeof (repr));</span>
<span class="lineNum">    1771 </span><span class="lineNoCov">          0 :   repr.base.base.kind = lendian16 (BRIG_KIND_INST_SOURCE_TYPE);</span>
<span class="lineNum">    1772 </span><span class="lineNoCov">          0 :   repr.base.opcode = lendian16 (insn-&gt;m_opcode);</span>
<span class="lineNum">    1773 </span><span class="lineNoCov">          0 :   repr.base.type = lendian16 (insn-&gt;m_type);</span>
<span class="lineNum">    1774 </span>            : 
<span class="lineNum">    1775 </span><span class="lineNoCov">          0 :   repr.base.operands = lendian32 (emit_insn_operands (insn));</span>
<span class="lineNum">    1776 </span><span class="lineNoCov">          0 :   brig_code.add (&amp;repr, sizeof (struct BrigInstSourceType));</span>
<span class="lineNum">    1777 </span><span class="lineNoCov">          0 :   brig_insn_count++;</span>
<span class="lineNum">    1778 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1779 </span>            : 
<span class="lineNum">    1780 </span>            : /* Emit packed instruction INSN.  */
<span class="lineNum">    1781 </span>            : 
<span class="lineNum">    1782 </span>            : static void
<span class="lineNum">    1783 </span><span class="lineNoCov">          0 : emit_packed_insn (hsa_insn_packed *insn)</span>
<span class="lineNum">    1784 </span>            : {
<span class="lineNum">    1785 </span>            :   /* We assume that BrigInstMod has a BrigInstBasic prefix.  */
<span class="lineNum">    1786 </span><span class="lineNoCov">          0 :   struct BrigInstSourceType repr;</span>
<span class="lineNum">    1787 </span><span class="lineNoCov">          0 :   unsigned operand_count = insn-&gt;operand_count ();</span>
<span class="lineNum">    1788 </span><span class="lineNoCov">          0 :   gcc_checking_assert (operand_count &gt;= 2);</span>
<span class="lineNum">    1789 </span>            : 
<span class="lineNum">    1790 </span><span class="lineNoCov">          0 :   memset (&amp;repr, 0, sizeof (repr));</span>
<span class="lineNum">    1791 </span><span class="lineNoCov">          0 :   repr.sourceType = lendian16 (insn-&gt;m_source_type);</span>
<span class="lineNum">    1792 </span><span class="lineNoCov">          0 :   repr.base.base.byteCount = lendian16 (sizeof (repr));</span>
<span class="lineNum">    1793 </span><span class="lineNoCov">          0 :   repr.base.base.kind = lendian16 (BRIG_KIND_INST_SOURCE_TYPE);</span>
<span class="lineNum">    1794 </span><span class="lineNoCov">          0 :   repr.base.opcode = lendian16 (insn-&gt;m_opcode);</span>
<span class="lineNum">    1795 </span><span class="lineNoCov">          0 :   repr.base.type = lendian16 (insn-&gt;m_type);</span>
<span class="lineNum">    1796 </span>            : 
<span class="lineNum">    1797 </span><span class="lineNoCov">          0 :   if (insn-&gt;m_opcode == BRIG_OPCODE_COMBINE)</span>
<span class="lineNum">    1798 </span>            :     {
<span class="lineNum">    1799 </span>            :       /* Create operand list for packed type.  */
<span class="lineNum">    1800 </span><span class="lineNoCov">          0 :       for (unsigned i = 1; i &lt; operand_count; i++)</span>
<span class="lineNum">    1801 </span>            :         {
<span class="lineNum">    1802 </span><span class="lineNoCov">          0 :           gcc_checking_assert (insn-&gt;get_op (i));</span>
<span class="lineNum">    1803 </span><span class="lineNoCov">          0 :           insn-&gt;m_operand_list-&gt;m_offsets[i - 1]</span>
<span class="lineNum">    1804 </span><span class="lineNoCov">          0 :             = lendian32 (enqueue_op (insn-&gt;get_op (i)));</span>
<span class="lineNum">    1805 </span>            :         }
<span class="lineNum">    1806 </span>            : 
<span class="lineNum">    1807 </span><span class="lineNoCov">          0 :       repr.base.operands = lendian32 (emit_operands (insn-&gt;get_op (0),</span>
<span class="lineNum">    1808 </span><span class="lineNoCov">          0 :                                                      insn-&gt;m_operand_list));</span>
<span class="lineNum">    1809 </span>            :     }
<span class="lineNum">    1810 </span><span class="lineNoCov">          0 :   else if (insn-&gt;m_opcode == BRIG_OPCODE_EXPAND)</span>
<span class="lineNum">    1811 </span>            :     {
<span class="lineNum">    1812 </span>            :       /* Create operand list for packed type.  */
<span class="lineNum">    1813 </span><span class="lineNoCov">          0 :       for (unsigned i = 0; i &lt; operand_count - 1; i++)</span>
<span class="lineNum">    1814 </span>            :         {
<span class="lineNum">    1815 </span><span class="lineNoCov">          0 :           gcc_checking_assert (insn-&gt;get_op (i));</span>
<span class="lineNum">    1816 </span><span class="lineNoCov">          0 :           insn-&gt;m_operand_list-&gt;m_offsets[i]</span>
<span class="lineNum">    1817 </span><span class="lineNoCov">          0 :             = lendian32 (enqueue_op (insn-&gt;get_op (i)));</span>
<span class="lineNum">    1818 </span>            :         }
<span class="lineNum">    1819 </span>            : 
<span class="lineNum">    1820 </span><span class="lineNoCov">          0 :       unsigned ops = emit_operands (insn-&gt;m_operand_list,</span>
<span class="lineNum">    1821 </span><span class="lineNoCov">          0 :                                     insn-&gt;get_op (insn-&gt;operand_count () - 1));</span>
<span class="lineNum">    1822 </span><span class="lineNoCov">          0 :       repr.base.operands = lendian32 (ops);</span>
<span class="lineNum">    1823 </span>            :     }
<span class="lineNum">    1824 </span>            : 
<span class="lineNum">    1825 </span>            : 
<span class="lineNum">    1826 </span><span class="lineNoCov">          0 :   brig_code.add (&amp;repr, sizeof (struct BrigInstSourceType));</span>
<span class="lineNum">    1827 </span><span class="lineNoCov">          0 :   brig_insn_count++;</span>
<span class="lineNum">    1828 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1829 </span>            : 
<span class="lineNum">    1830 </span>            : /* Emit a basic HSA instruction and all necessary directives, schedule
<span class="lineNum">    1831 </span>            :    necessary operands for writing.  */
<a name="1832"><span class="lineNum">    1832 </span>            : </a>
<span class="lineNum">    1833 </span>            : static void
<span class="lineNum">    1834 </span><span class="lineNoCov">          0 : emit_basic_insn (hsa_insn_basic *insn)</span>
<span class="lineNum">    1835 </span>            : {
<span class="lineNum">    1836 </span>            :   /* We assume that BrigInstMod has a BrigInstBasic prefix.  */
<span class="lineNum">    1837 </span><span class="lineNoCov">          0 :   struct BrigInstMod repr;</span>
<span class="lineNum">    1838 </span><span class="lineNoCov">          0 :   BrigType16_t type;</span>
<span class="lineNum">    1839 </span>            : 
<span class="lineNum">    1840 </span><span class="lineNoCov">          0 :   memset (&amp;repr, 0, sizeof (repr));</span>
<span class="lineNum">    1841 </span><span class="lineNoCov">          0 :   repr.base.base.byteCount = lendian16 (sizeof (BrigInstBasic));</span>
<span class="lineNum">    1842 </span><span class="lineNoCov">          0 :   repr.base.base.kind = lendian16 (BRIG_KIND_INST_BASIC);</span>
<span class="lineNum">    1843 </span><span class="lineNoCov">          0 :   repr.base.opcode = lendian16 (insn-&gt;m_opcode);</span>
<span class="lineNum">    1844 </span><span class="lineNoCov">          0 :   switch (insn-&gt;m_opcode)</span>
<span class="lineNum">    1845 </span>            :     {
<span class="lineNum">    1846 </span>            :       /* And the bit-logical operations need bit types and whine about
<span class="lineNum">    1847 </span>            :          arithmetic types :-/  */
<span class="lineNum">    1848 </span><span class="lineNoCov">          0 :       case BRIG_OPCODE_AND:</span>
<span class="lineNum">    1849 </span><span class="lineNoCov">          0 :       case BRIG_OPCODE_OR:</span>
<span class="lineNum">    1850 </span><span class="lineNoCov">          0 :       case BRIG_OPCODE_XOR:</span>
<span class="lineNum">    1851 </span><span class="lineNoCov">          0 :       case BRIG_OPCODE_NOT:</span>
<span class="lineNum">    1852 </span><span class="lineNoCov">          0 :         type = regtype_for_type (insn-&gt;m_type);</span>
<span class="lineNum">    1853 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">    1854 </span><span class="lineNoCov">          0 :       default:</span>
<span class="lineNum">    1855 </span><span class="lineNoCov">          0 :         type = insn-&gt;m_type;</span>
<span class="lineNum">    1856 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">    1857 </span>            :     }
<span class="lineNum">    1858 </span><span class="lineNoCov">          0 :   repr.base.type = lendian16 (type);</span>
<span class="lineNum">    1859 </span><span class="lineNoCov">          0 :   repr.base.operands = lendian32 (emit_insn_operands (insn));</span>
<span class="lineNum">    1860 </span>            : 
<span class="lineNum">    1861 </span><span class="lineNoCov">          0 :   if (hsa_type_packed_p (type))</span>
<span class="lineNum">    1862 </span>            :     {
<span class="lineNum">    1863 </span><span class="lineNoCov">          0 :       if (hsa_type_float_p (type)</span>
<span class="lineNum">    1864 </span><span class="lineNoCov">          0 :           &amp;&amp; !hsa_opcode_floating_bit_insn_p (insn-&gt;m_opcode))</span>
<span class="lineNum">    1865 </span><span class="lineNoCov">          0 :         repr.round = BRIG_ROUND_FLOAT_NEAR_EVEN;</span>
<span class="lineNum">    1866 </span>            :       else
<span class="lineNum">    1867 </span><span class="lineNoCov">          0 :         repr.round = 0;</span>
<span class="lineNum">    1868 </span>            :       /* We assume that destination and sources agree in packing layout.  */
<span class="lineNum">    1869 </span><span class="lineNoCov">          0 :       if (insn-&gt;num_used_ops () &gt;= 2)</span>
<span class="lineNum">    1870 </span><span class="lineNoCov">          0 :         repr.pack = BRIG_PACK_PP;</span>
<span class="lineNum">    1871 </span>            :       else
<span class="lineNum">    1872 </span><span class="lineNoCov">          0 :         repr.pack = BRIG_PACK_P;</span>
<span class="lineNum">    1873 </span><span class="lineNoCov">          0 :       repr.reserved = 0;</span>
<span class="lineNum">    1874 </span><span class="lineNoCov">          0 :       repr.base.base.byteCount = lendian16 (sizeof (BrigInstMod));</span>
<span class="lineNum">    1875 </span><span class="lineNoCov">          0 :       repr.base.base.kind = lendian16 (BRIG_KIND_INST_MOD);</span>
<span class="lineNum">    1876 </span><span class="lineNoCov">          0 :       brig_code.add (&amp;repr, sizeof (struct BrigInstMod));</span>
<span class="lineNum">    1877 </span>            :     }
<span class="lineNum">    1878 </span>            :   else
<span class="lineNum">    1879 </span><span class="lineNoCov">          0 :     brig_code.add (&amp;repr, sizeof (struct BrigInstBasic));</span>
<span class="lineNum">    1880 </span><span class="lineNoCov">          0 :   brig_insn_count++;</span>
<span class="lineNum">    1881 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1882 </span>            : 
<span class="lineNum">    1883 </span>            : /* Emit an HSA instruction and all necessary directives, schedule necessary
<span class="lineNum">    1884 </span>            :    operands for writing.  */
<a name="1885"><span class="lineNum">    1885 </span>            : </a>
<span class="lineNum">    1886 </span>            : static void
<span class="lineNum">    1887 </span><span class="lineNoCov">          0 : emit_insn (hsa_insn_basic *insn)</span>
<span class="lineNum">    1888 </span>            : {
<span class="lineNum">    1889 </span><span class="lineNoCov">          0 :   gcc_assert (!is_a &lt;hsa_insn_phi *&gt; (insn));</span>
<span class="lineNum">    1890 </span>            : 
<span class="lineNum">    1891 </span><span class="lineNoCov">          0 :   insn-&gt;m_brig_offset = brig_code.total_size;</span>
<span class="lineNum">    1892 </span>            : 
<span class="lineNum">    1893 </span><span class="lineNoCov">          0 :   if (hsa_insn_signal *signal = dyn_cast &lt;hsa_insn_signal *&gt; (insn))</span>
<span class="lineNum">    1894 </span><span class="lineNoCov">          0 :     emit_signal_insn (signal);</span>
<span class="lineNum">    1895 </span><span class="lineNoCov">          0 :   else if (hsa_insn_atomic *atom = dyn_cast &lt;hsa_insn_atomic *&gt; (insn))</span>
<span class="lineNum">    1896 </span><span class="lineNoCov">          0 :     emit_atomic_insn (atom);</span>
<span class="lineNum">    1897 </span><span class="lineNoCov">          0 :   else if (hsa_insn_mem *mem = dyn_cast &lt;hsa_insn_mem *&gt; (insn))</span>
<span class="lineNum">    1898 </span><span class="lineNoCov">          0 :     emit_memory_insn (mem);</span>
<span class="lineNum">    1899 </span><span class="lineNoCov">          0 :   else if (insn-&gt;m_opcode == BRIG_OPCODE_LDA)</span>
<span class="lineNum">    1900 </span><span class="lineNoCov">          0 :     emit_addr_insn (insn);</span>
<span class="lineNum">    1901 </span><span class="lineNoCov">          0 :   else if (hsa_insn_seg *seg = dyn_cast &lt;hsa_insn_seg *&gt; (insn))</span>
<span class="lineNum">    1902 </span><span class="lineNoCov">          0 :     emit_segment_insn (seg);</span>
<span class="lineNum">    1903 </span><span class="lineNoCov">          0 :   else if (hsa_insn_cmp *cmp = dyn_cast &lt;hsa_insn_cmp *&gt; (insn))</span>
<span class="lineNum">    1904 </span><span class="lineNoCov">          0 :     emit_cmp_insn (cmp);</span>
<span class="lineNum">    1905 </span><span class="lineNoCov">          0 :   else if (hsa_insn_cbr *br = dyn_cast &lt;hsa_insn_cbr *&gt; (insn))</span>
<span class="lineNum">    1906 </span><span class="lineNoCov">          0 :     emit_cond_branch_insn (br);</span>
<span class="lineNum">    1907 </span><span class="lineNoCov">          0 :   else if (hsa_insn_sbr *sbr = dyn_cast &lt;hsa_insn_sbr *&gt; (insn))</span>
<span class="lineNum">    1908 </span>            :     {
<span class="lineNum">    1909 </span><span class="lineNoCov">          0 :       if (switch_instructions == NULL)</span>
<span class="lineNum">    1910 </span><span class="lineNoCov">          0 :         switch_instructions = new vec &lt;hsa_insn_sbr *&gt; ();</span>
<span class="lineNum">    1911 </span>            : 
<span class="lineNum">    1912 </span><span class="lineNoCov">          0 :       switch_instructions-&gt;safe_push (sbr);</span>
<span class="lineNum">    1913 </span><span class="lineNoCov">          0 :       emit_switch_insn (sbr);</span>
<span class="lineNum">    1914 </span>            :     }
<span class="lineNum">    1915 </span><span class="lineNoCov">          0 :   else if (hsa_insn_br *br = dyn_cast &lt;hsa_insn_br *&gt; (insn))</span>
<span class="lineNum">    1916 </span><span class="lineNoCov">          0 :     emit_generic_branch_insn (br);</span>
<span class="lineNum">    1917 </span><span class="lineNoCov">          0 :   else if (hsa_insn_arg_block *block = dyn_cast &lt;hsa_insn_arg_block *&gt; (insn))</span>
<span class="lineNum">    1918 </span><span class="lineNoCov">          0 :     emit_arg_block_insn (block);</span>
<span class="lineNum">    1919 </span><span class="lineNoCov">          0 :   else if (hsa_insn_call *call = dyn_cast &lt;hsa_insn_call *&gt; (insn))</span>
<span class="lineNum">    1920 </span><span class="lineNoCov">          0 :     emit_call_insn (call);</span>
<span class="lineNum">    1921 </span><span class="lineNoCov">          0 :   else if (hsa_insn_comment *comment = dyn_cast &lt;hsa_insn_comment *&gt; (insn))</span>
<span class="lineNum">    1922 </span><span class="lineNoCov">          0 :     emit_comment_insn (comment);</span>
<span class="lineNum">    1923 </span><span class="lineNoCov">          0 :   else if (hsa_insn_queue *queue = dyn_cast &lt;hsa_insn_queue *&gt; (insn))</span>
<span class="lineNum">    1924 </span><span class="lineNoCov">          0 :     emit_queue_insn (queue);</span>
<span class="lineNum">    1925 </span><span class="lineNoCov">          0 :   else if (hsa_insn_srctype *srctype = dyn_cast &lt;hsa_insn_srctype *&gt; (insn))</span>
<span class="lineNum">    1926 </span><span class="lineNoCov">          0 :     emit_srctype_insn (srctype);</span>
<span class="lineNum">    1927 </span><span class="lineNoCov">          0 :   else if (hsa_insn_packed *packed = dyn_cast &lt;hsa_insn_packed *&gt; (insn))</span>
<span class="lineNum">    1928 </span><span class="lineNoCov">          0 :     emit_packed_insn (packed);</span>
<span class="lineNum">    1929 </span><span class="lineNoCov">          0 :   else if (hsa_insn_cvt *cvt = dyn_cast &lt;hsa_insn_cvt *&gt; (insn))</span>
<span class="lineNum">    1930 </span><span class="lineNoCov">          0 :     emit_cvt_insn (cvt);</span>
<span class="lineNum">    1931 </span><span class="lineNoCov">          0 :   else if (hsa_insn_alloca *alloca = dyn_cast &lt;hsa_insn_alloca *&gt; (insn))</span>
<span class="lineNum">    1932 </span><span class="lineNoCov">          0 :     emit_alloca_insn (alloca);</span>
<span class="lineNum">    1933 </span>            :   else
<span class="lineNum">    1934 </span><span class="lineNoCov">          0 :     emit_basic_insn (insn);</span>
<span class="lineNum">    1935 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1936 </span>            : 
<span class="lineNum">    1937 </span>            : /* We have just finished emitting BB and are about to emit NEXT_BB if non-NULL,
<span class="lineNum">    1938 </span>            :    or we are about to finish emitting code, if it is NULL.  If the fall through
<span class="lineNum">    1939 </span>            :    edge from BB does not lead to NEXT_BB, emit an unconditional jump.  */
<a name="1940"><span class="lineNum">    1940 </span>            : </a>
<span class="lineNum">    1941 </span>            : static void
<span class="lineNum">    1942 </span><span class="lineNoCov">          0 : perhaps_emit_branch (basic_block bb, basic_block next_bb)</span>
<span class="lineNum">    1943 </span>            : {
<span class="lineNum">    1944 </span><span class="lineNoCov">          0 :   basic_block t_bb = NULL, ff = NULL;</span>
<span class="lineNum">    1945 </span>            : 
<span class="lineNum">    1946 </span><span class="lineNoCov">          0 :   edge_iterator ei;</span>
<span class="lineNum">    1947 </span><span class="lineNoCov">          0 :   edge e;</span>
<span class="lineNum">    1948 </span>            : 
<span class="lineNum">    1949 </span>            :   /* If the last instruction of BB is a switch, ignore emission of all
<span class="lineNum">    1950 </span>            :      edges.  */
<span class="lineNum">    1951 </span><span class="lineNoCov">          0 :   if (hsa_bb_for_bb (bb)-&gt;m_last_insn</span>
<span class="lineNum">    1952 </span><span class="lineNoCov">          0 :       &amp;&amp; is_a &lt;hsa_insn_sbr *&gt; (hsa_bb_for_bb (bb)-&gt;m_last_insn))</span>
<span class="lineNum">    1953 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">    1954 </span>            : 
<span class="lineNum">    1955 </span><span class="lineNoCov">          0 :   FOR_EACH_EDGE (e, ei, bb-&gt;succs)</span>
<span class="lineNum">    1956 </span><span class="lineNoCov">          0 :     if (e-&gt;flags &amp; EDGE_TRUE_VALUE)</span>
<span class="lineNum">    1957 </span>            :       {
<span class="lineNum">    1958 </span><span class="lineNoCov">          0 :         gcc_assert (!t_bb);</span>
<span class="lineNum">    1959 </span><span class="lineNoCov">          0 :         t_bb = e-&gt;dest;</span>
<span class="lineNum">    1960 </span>            :       }
<span class="lineNum">    1961 </span>            :     else
<span class="lineNum">    1962 </span>            :       {
<span class="lineNum">    1963 </span><span class="lineNoCov">          0 :         gcc_assert (!ff);</span>
<span class="lineNum">    1964 </span><span class="lineNoCov">          0 :         ff = e-&gt;dest;</span>
<span class="lineNum">    1965 </span>            :       }
<span class="lineNum">    1966 </span>            : 
<span class="lineNum">    1967 </span><span class="lineNoCov">          0 :   if (!ff || ff == next_bb || ff == EXIT_BLOCK_PTR_FOR_FN (cfun))</span>
<span class="lineNum">    1968 </span>            :     return;
<span class="lineNum">    1969 </span>            : 
<span class="lineNum">    1970 </span><span class="lineNoCov">          0 :   emit_unconditional_jump (&amp;hsa_bb_for_bb (ff)-&gt;m_label_ref);</span>
<span class="lineNum">    1971 </span>            : }
<span class="lineNum">    1972 </span>            : 
<span class="lineNum">    1973 </span>            : /* Emit the a function with name NAME to the various brig sections.  */
<span class="lineNum">    1974 </span>            : 
<span class="lineNum">    1975 </span>            : void
<span class="lineNum">    1976 </span><span class="lineNoCov">          0 : hsa_brig_emit_function (void)</span>
<span class="lineNum">    1977 </span>            : {
<span class="lineNum">    1978 </span><span class="lineNoCov">          0 :   basic_block bb, prev_bb;</span>
<span class="lineNum">    1979 </span><span class="lineNoCov">          0 :   hsa_insn_basic *insn;</span>
<span class="lineNum">    1980 </span><span class="lineNoCov">          0 :   BrigDirectiveExecutable *ptr_to_fndir;</span>
<span class="lineNum">    1981 </span>            : 
<span class="lineNum">    1982 </span><span class="lineNoCov">          0 :   brig_init ();</span>
<span class="lineNum">    1983 </span>            : 
<span class="lineNum">    1984 </span><span class="lineNoCov">          0 :   brig_insn_count = 0;</span>
<span class="lineNum">    1985 </span><span class="lineNoCov">          0 :   memset (&amp;op_queue, 0, sizeof (op_queue));</span>
<span class="lineNum">    1986 </span><span class="lineNoCov">          0 :   op_queue.projected_size = brig_operand.total_size;</span>
<span class="lineNum">    1987 </span>            : 
<span class="lineNum">    1988 </span><span class="lineNoCov">          0 :   if (!function_offsets)</span>
<span class="lineNum">    1989 </span><span class="lineNoCov">          0 :     function_offsets = new hash_map&lt;tree, BrigCodeOffset32_t&gt; ();</span>
<span class="lineNum">    1990 </span>            : 
<span class="lineNum">    1991 </span><span class="lineNoCov">          0 :   if (!emitted_declarations)</span>
<span class="lineNum">    1992 </span><span class="lineNoCov">          0 :     emitted_declarations = new hash_map &lt;tree, BrigDirectiveExecutable *&gt; ();</span>
<span class="lineNum">    1993 </span>            : 
<span class="lineNum">    1994 </span><span class="lineNoCov">          0 :   for (unsigned i = 0; i &lt; hsa_cfun-&gt;m_called_functions.length (); i++)</span>
<span class="lineNum">    1995 </span>            :     {
<span class="lineNum">    1996 </span><span class="lineNoCov">          0 :       tree called = hsa_cfun-&gt;m_called_functions[i];</span>
<span class="lineNum">    1997 </span>            : 
<span class="lineNum">    1998 </span>            :       /* If the function has no definition, emit a declaration.  */
<span class="lineNum">    1999 </span><span class="lineNoCov">          0 :       if (!emitted_declarations-&gt;get (called))</span>
<span class="lineNum">    2000 </span>            :         {
<span class="lineNum">    2001 </span><span class="lineNoCov">          0 :           BrigDirectiveExecutable *e = emit_function_declaration (called);</span>
<span class="lineNum">    2002 </span><span class="lineNoCov">          0 :           emitted_declarations-&gt;put (called, e);</span>
<span class="lineNum">    2003 </span>            :         }
<span class="lineNum">    2004 </span>            :     }
<span class="lineNum">    2005 </span>            : 
<span class="lineNum">    2006 </span><span class="lineNoCov">          0 :   for (unsigned i = 0; i &lt; hsa_cfun-&gt;m_called_internal_fns.length (); i++)</span>
<span class="lineNum">    2007 </span>            :     {
<span class="lineNum">    2008 </span><span class="lineNoCov">          0 :       hsa_internal_fn *called = hsa_cfun-&gt;m_called_internal_fns[i];</span>
<span class="lineNum">    2009 </span><span class="lineNoCov">          0 :       emit_internal_fn_decl (called);</span>
<span class="lineNum">    2010 </span>            :     }
<span class="lineNum">    2011 </span>            : 
<span class="lineNum">    2012 </span><span class="lineNoCov">          0 :   ptr_to_fndir = emit_function_directives (hsa_cfun, false);</span>
<span class="lineNum">    2013 </span><span class="lineNoCov">          0 :   for (insn = hsa_bb_for_bb (ENTRY_BLOCK_PTR_FOR_FN (cfun))-&gt;m_first_insn;</span>
<span class="lineNum">    2014 </span><span class="lineNoCov">          0 :        insn;</span>
<span class="lineNum">    2015 </span><span class="lineNoCov">          0 :        insn = insn-&gt;m_next)</span>
<span class="lineNum">    2016 </span><span class="lineNoCov">          0 :     emit_insn (insn);</span>
<span class="lineNum">    2017 </span><span class="lineNoCov">          0 :   prev_bb = ENTRY_BLOCK_PTR_FOR_FN (cfun);</span>
<span class="lineNum">    2018 </span><span class="lineNoCov">          0 :   FOR_EACH_BB_FN (bb, cfun)</span>
<span class="lineNum">    2019 </span>            :     {
<span class="lineNum">    2020 </span><span class="lineNoCov">          0 :       perhaps_emit_branch (prev_bb, bb);</span>
<span class="lineNum">    2021 </span><span class="lineNoCov">          0 :       emit_bb_label_directive (hsa_bb_for_bb (bb));</span>
<span class="lineNum">    2022 </span><span class="lineNoCov">          0 :       for (insn = hsa_bb_for_bb (bb)-&gt;m_first_insn; insn; insn = insn-&gt;m_next)</span>
<span class="lineNum">    2023 </span><span class="lineNoCov">          0 :         emit_insn (insn);</span>
<span class="lineNum">    2024 </span><span class="lineNoCov">          0 :       prev_bb = bb;</span>
<span class="lineNum">    2025 </span>            :     }
<span class="lineNum">    2026 </span><span class="lineNoCov">          0 :   perhaps_emit_branch (prev_bb, NULL);</span>
<span class="lineNum">    2027 </span><span class="lineNoCov">          0 :   ptr_to_fndir-&gt;nextModuleEntry = lendian32 (brig_code.total_size);</span>
<span class="lineNum">    2028 </span>            : 
<span class="lineNum">    2029 </span>            :   /* Fill up label references for all sbr instructions.  */
<span class="lineNum">    2030 </span><span class="lineNoCov">          0 :   if (switch_instructions)</span>
<span class="lineNum">    2031 </span>            :     {
<span class="lineNum">    2032 </span><span class="lineNoCov">          0 :       for (unsigned i = 0; i &lt; switch_instructions-&gt;length (); i++)</span>
<span class="lineNum">    2033 </span>            :         {
<span class="lineNum">    2034 </span><span class="lineNoCov">          0 :           hsa_insn_sbr *sbr = (*switch_instructions)[i];</span>
<span class="lineNum">    2035 </span><span class="lineNoCov">          0 :           for (unsigned j = 0; j &lt; sbr-&gt;m_jump_table.length (); j++)</span>
<span class="lineNum">    2036 </span>            :             {
<span class="lineNum">    2037 </span><span class="lineNoCov">          0 :               hsa_bb *hbb = hsa_bb_for_bb (sbr-&gt;m_jump_table[j]);</span>
<span class="lineNum">    2038 </span><span class="lineNoCov">          0 :               sbr-&gt;m_label_code_list-&gt;m_offsets[j]</span>
<span class="lineNum">    2039 </span><span class="lineNoCov">          0 :                 = hbb-&gt;m_label_ref.m_directive_offset;</span>
<span class="lineNum">    2040 </span>            :             }
<span class="lineNum">    2041 </span>            :         }
<span class="lineNum">    2042 </span>            : 
<span class="lineNum">    2043 </span><span class="lineNoCov">          0 :       switch_instructions-&gt;release ();</span>
<span class="lineNum">    2044 </span><span class="lineNoCov">          0 :       delete switch_instructions;</span>
<span class="lineNum">    2045 </span><span class="lineNoCov">          0 :       switch_instructions = NULL;</span>
<span class="lineNum">    2046 </span>            :     }
<span class="lineNum">    2047 </span>            : 
<span class="lineNum">    2048 </span><span class="lineNoCov">          0 :   if (dump_file)</span>
<span class="lineNum">    2049 </span>            :     {
<span class="lineNum">    2050 </span><span class="lineNoCov">          0 :       fprintf (dump_file, &quot;------- After BRIG emission: -------\n&quot;);</span>
<span class="lineNum">    2051 </span><span class="lineNoCov">          0 :       dump_hsa_cfun (dump_file);</span>
<span class="lineNum">    2052 </span>            :     }
<span class="lineNum">    2053 </span>            : 
<span class="lineNum">    2054 </span><span class="lineNoCov">          0 :   emit_queued_operands ();</span>
<span class="lineNum">    2055 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    2056 </span>            : 
<span class="lineNum">    2057 </span>            : /* Emit all OMP symbols related to OMP.  */
<a name="2058"><span class="lineNum">    2058 </span>            : </a>
<span class="lineNum">    2059 </span>            : void
<span class="lineNum">    2060 </span><span class="lineNoCov">          0 : hsa_brig_emit_omp_symbols (void)</span>
<span class="lineNum">    2061 </span>            : {
<span class="lineNum">    2062 </span><span class="lineNoCov">          0 :   brig_init ();</span>
<span class="lineNum">    2063 </span><span class="lineNoCov">          0 :   emit_directive_variable (hsa_num_threads);</span>
<span class="lineNum">    2064 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    2065 </span>            : 
<span class="lineNum">    2066 </span>            : /* Create and return __hsa_global_variables symbol that contains
<span class="lineNum">    2067 </span>            :    all informations consumed by libgomp to link global variables
<span class="lineNum">    2068 </span>            :    with their string names used by an HSA kernel.  */
<a name="2069"><span class="lineNum">    2069 </span>            : </a>
<span class="lineNum">    2070 </span>            : static tree
<span class="lineNum">    2071 </span><span class="lineNoCov">          0 : hsa_output_global_variables ()</span>
<span class="lineNum">    2072 </span>            : {
<span class="lineNum">    2073 </span><span class="lineNoCov">          0 :   unsigned l = hsa_global_variable_symbols-&gt;elements ();</span>
<span class="lineNum">    2074 </span>            : 
<span class="lineNum">    2075 </span><span class="lineNoCov">          0 :   tree variable_info_type = make_node (RECORD_TYPE);</span>
<span class="lineNum">    2076 </span><span class="lineNoCov">          0 :   tree id_f1 = build_decl (BUILTINS_LOCATION, FIELD_DECL,</span>
<span class="lineNum">    2077 </span><span class="lineNoCov">          0 :                            get_identifier (&quot;name&quot;), ptr_type_node);</span>
<span class="lineNum">    2078 </span><span class="lineNoCov">          0 :   DECL_CHAIN (id_f1) = NULL_TREE;</span>
<span class="lineNum">    2079 </span><span class="lineNoCov">          0 :   tree id_f2 = build_decl (BUILTINS_LOCATION, FIELD_DECL,</span>
<span class="lineNum">    2080 </span>            :                            get_identifier (&quot;omp_data_size&quot;),
<span class="lineNum">    2081 </span><span class="lineNoCov">          0 :                            ptr_type_node);</span>
<span class="lineNum">    2082 </span><span class="lineNoCov">          0 :   DECL_CHAIN (id_f2) = id_f1;</span>
<span class="lineNum">    2083 </span><span class="lineNoCov">          0 :   finish_builtin_struct (variable_info_type, &quot;__hsa_variable_info&quot;, id_f2,</span>
<span class="lineNum">    2084 </span>            :                          NULL_TREE);
<span class="lineNum">    2085 </span>            : 
<span class="lineNum">    2086 </span><span class="lineNoCov">          0 :   tree int_num_of_global_vars;</span>
<span class="lineNum">    2087 </span><span class="lineNoCov">          0 :   int_num_of_global_vars = build_int_cst (uint32_type_node, l);</span>
<span class="lineNum">    2088 </span><span class="lineNoCov">          0 :   tree global_vars_num_index_type = build_index_type (int_num_of_global_vars);</span>
<span class="lineNum">    2089 </span><span class="lineNoCov">          0 :   tree global_vars_array_type = build_array_type (variable_info_type,</span>
<span class="lineNum">    2090 </span><span class="lineNoCov">          0 :                                                   global_vars_num_index_type);</span>
<span class="lineNum">    2091 </span><span class="lineNoCov">          0 :   TYPE_ARTIFICIAL (global_vars_array_type) = 1;</span>
<span class="lineNum">    2092 </span>            : 
<span class="lineNum">    2093 </span><span class="lineNoCov">          0 :   vec&lt;constructor_elt, va_gc&gt; *global_vars_vec = NULL;</span>
<span class="lineNum">    2094 </span>            : 
<span class="lineNum">    2095 </span><span class="lineNoCov">          0 :   for (hash_table &lt;hsa_noop_symbol_hasher&gt;::iterator it</span>
<span class="lineNum">    2096 </span><span class="lineNoCov">          0 :        = hsa_global_variable_symbols-&gt;begin ();</span>
<span class="lineNum">    2097 </span><span class="lineNoCov">          0 :        it != hsa_global_variable_symbols-&gt;end (); ++it)</span>
<span class="lineNum">    2098 </span>            :     {
<span class="lineNum">    2099 </span><span class="lineNoCov">          0 :       unsigned len = strlen ((*it)-&gt;m_name);</span>
<span class="lineNum">    2100 </span><span class="lineNoCov">          0 :       char *copy = XNEWVEC (char, len + 2);</span>
<span class="lineNum">    2101 </span><span class="lineNoCov">          0 :       copy[0] = '&amp;';</span>
<span class="lineNum">    2102 </span><span class="lineNoCov">          0 :       memcpy (copy + 1, (*it)-&gt;m_name, len);</span>
<span class="lineNum">    2103 </span><span class="lineNoCov">          0 :       copy[len + 1] = '\0';</span>
<span class="lineNum">    2104 </span><span class="lineNoCov">          0 :       len++;</span>
<span class="lineNum">    2105 </span><span class="lineNoCov">          0 :       hsa_sanitize_name (copy);</span>
<span class="lineNum">    2106 </span>            : 
<span class="lineNum">    2107 </span><span class="lineNoCov">          0 :       tree var_name = build_string (len, copy);</span>
<span class="lineNum">    2108 </span><span class="lineNoCov">          0 :       TREE_TYPE (var_name)</span>
<span class="lineNum">    2109 </span><span class="lineNoCov">          0 :         = build_array_type (char_type_node, build_index_type (size_int (len)));</span>
<span class="lineNum">    2110 </span><span class="lineNoCov">          0 :       free (copy);</span>
<span class="lineNum">    2111 </span>            : 
<span class="lineNum">    2112 </span><span class="lineNoCov">          0 :       vec&lt;constructor_elt, va_gc&gt; *variable_info_vec = NULL;</span>
<span class="lineNum">    2113 </span><span class="lineNoCov">          0 :       CONSTRUCTOR_APPEND_ELT (variable_info_vec, NULL_TREE,</span>
<span class="lineNum">    2114 </span>            :                               build1 (ADDR_EXPR,
<span class="lineNum">    2115 </span>            :                                       build_pointer_type (TREE_TYPE (var_name)),
<span class="lineNum">    2116 </span>            :                                       var_name));
<span class="lineNum">    2117 </span><span class="lineNoCov">          0 :       CONSTRUCTOR_APPEND_ELT (variable_info_vec, NULL_TREE,</span>
<span class="lineNum">    2118 </span>            :                               build_fold_addr_expr ((*it)-&gt;m_decl));
<span class="lineNum">    2119 </span>            : 
<span class="lineNum">    2120 </span><span class="lineNoCov">          0 :       tree variable_info_ctor = build_constructor (variable_info_type,</span>
<span class="lineNum">    2121 </span>            :                                                    variable_info_vec);
<span class="lineNum">    2122 </span>            : 
<span class="lineNum">    2123 </span><span class="lineNoCov">          0 :       CONSTRUCTOR_APPEND_ELT (global_vars_vec, NULL_TREE,</span>
<span class="lineNum">    2124 </span>            :                               variable_info_ctor);
<span class="lineNum">    2125 </span>            :     }
<span class="lineNum">    2126 </span>            : 
<span class="lineNum">    2127 </span><span class="lineNoCov">          0 :   tree global_vars_ctor = build_constructor (global_vars_array_type,</span>
<span class="lineNum">    2128 </span>            :                                              global_vars_vec);
<span class="lineNum">    2129 </span>            : 
<span class="lineNum">    2130 </span><span class="lineNoCov">          0 :   char tmp_name[64];</span>
<span class="lineNum">    2131 </span><span class="lineNoCov">          0 :   ASM_GENERATE_INTERNAL_LABEL (tmp_name, &quot;__hsa_global_variables&quot;, 1);</span>
<span class="lineNum">    2132 </span><span class="lineNoCov">          0 :   tree global_vars_table = build_decl (UNKNOWN_LOCATION, VAR_DECL,</span>
<span class="lineNum">    2133 </span>            :                                            get_identifier (tmp_name),
<span class="lineNum">    2134 </span><span class="lineNoCov">          0 :                                            global_vars_array_type);</span>
<span class="lineNum">    2135 </span><span class="lineNoCov">          0 :   TREE_STATIC (global_vars_table) = 1;</span>
<span class="lineNum">    2136 </span><span class="lineNoCov">          0 :   TREE_READONLY (global_vars_table) = 1;</span>
<span class="lineNum">    2137 </span><span class="lineNoCov">          0 :   TREE_PUBLIC (global_vars_table) = 0;</span>
<span class="lineNum">    2138 </span><span class="lineNoCov">          0 :   DECL_ARTIFICIAL (global_vars_table) = 1;</span>
<span class="lineNum">    2139 </span><span class="lineNoCov">          0 :   DECL_IGNORED_P (global_vars_table) = 1;</span>
<span class="lineNum">    2140 </span><span class="lineNoCov">          0 :   DECL_EXTERNAL (global_vars_table) = 0;</span>
<span class="lineNum">    2141 </span><span class="lineNoCov">          0 :   TREE_CONSTANT (global_vars_table) = 1;</span>
<span class="lineNum">    2142 </span><span class="lineNoCov">          0 :   DECL_INITIAL (global_vars_table) = global_vars_ctor;</span>
<span class="lineNum">    2143 </span><span class="lineNoCov">          0 :   varpool_node::finalize_decl (global_vars_table);</span>
<span class="lineNum">    2144 </span>            : 
<span class="lineNum">    2145 </span><span class="lineNoCov">          0 :   return global_vars_table;</span>
<span class="lineNum">    2146 </span>            : }
<span class="lineNum">    2147 </span>            : 
<span class="lineNum">    2148 </span>            : /* Create __hsa_host_functions and __hsa_kernels that contain
<span class="lineNum">    2149 </span>            :    all informations consumed by libgomp to register all kernels
<span class="lineNum">    2150 </span>            :    in the BRIG binary.  */
<span class="lineNum">    2151 </span>            : 
<span class="lineNum">    2152 </span>            : static void
<span class="lineNum">    2153 </span><span class="lineNoCov">          0 : hsa_output_kernels (tree *host_func_table, tree *kernels)</span>
<span class="lineNum">    2154 </span>            : {
<span class="lineNum">    2155 </span><span class="lineNoCov">          0 :   unsigned map_count = hsa_get_number_decl_kernel_mappings ();</span>
<span class="lineNum">    2156 </span>            : 
<span class="lineNum">    2157 </span><span class="lineNoCov">          0 :   tree int_num_of_kernels;</span>
<span class="lineNum">    2158 </span><span class="lineNoCov">          0 :   int_num_of_kernels = build_int_cst (uint32_type_node, map_count);</span>
<span class="lineNum">    2159 </span><span class="lineNoCov">          0 :   tree kernel_num_index_type = build_index_type (int_num_of_kernels);</span>
<span class="lineNum">    2160 </span><span class="lineNoCov">          0 :   tree host_functions_array_type = build_array_type (ptr_type_node,</span>
<span class="lineNum">    2161 </span><span class="lineNoCov">          0 :                                                      kernel_num_index_type);</span>
<span class="lineNum">    2162 </span><span class="lineNoCov">          0 :   TYPE_ARTIFICIAL (host_functions_array_type) = 1;</span>
<span class="lineNum">    2163 </span>            : 
<span class="lineNum">    2164 </span><span class="lineNoCov">          0 :   vec&lt;constructor_elt, va_gc&gt; *host_functions_vec = NULL;</span>
<span class="lineNum">    2165 </span><span class="lineNoCov">          0 :   for (unsigned i = 0; i &lt; map_count; ++i)</span>
<span class="lineNum">    2166 </span>            :     {
<span class="lineNum">    2167 </span><span class="lineNoCov">          0 :       tree decl = hsa_get_decl_kernel_mapping_decl (i);</span>
<span class="lineNum">    2168 </span><span class="lineNoCov">          0 :       tree host_fn = build_fold_addr_expr (hsa_get_host_function (decl));</span>
<span class="lineNum">    2169 </span><span class="lineNoCov">          0 :       CONSTRUCTOR_APPEND_ELT (host_functions_vec, NULL_TREE, host_fn);</span>
<span class="lineNum">    2170 </span>            :     }
<span class="lineNum">    2171 </span><span class="lineNoCov">          0 :   tree host_functions_ctor = build_constructor (host_functions_array_type,</span>
<span class="lineNum">    2172 </span>            :                                                 host_functions_vec);
<span class="lineNum">    2173 </span><span class="lineNoCov">          0 :   char tmp_name[64];</span>
<span class="lineNum">    2174 </span><span class="lineNoCov">          0 :   ASM_GENERATE_INTERNAL_LABEL (tmp_name, &quot;__hsa_host_functions&quot;, 1);</span>
<span class="lineNum">    2175 </span><span class="lineNoCov">          0 :   tree hsa_host_func_table = build_decl (UNKNOWN_LOCATION, VAR_DECL,</span>
<span class="lineNum">    2176 </span>            :                                          get_identifier (tmp_name),
<span class="lineNum">    2177 </span><span class="lineNoCov">          0 :                                          host_functions_array_type);</span>
<span class="lineNum">    2178 </span><span class="lineNoCov">          0 :   TREE_STATIC (hsa_host_func_table) = 1;</span>
<span class="lineNum">    2179 </span><span class="lineNoCov">          0 :   TREE_READONLY (hsa_host_func_table) = 1;</span>
<span class="lineNum">    2180 </span><span class="lineNoCov">          0 :   TREE_PUBLIC (hsa_host_func_table) = 0;</span>
<span class="lineNum">    2181 </span><span class="lineNoCov">          0 :   DECL_ARTIFICIAL (hsa_host_func_table) = 1;</span>
<span class="lineNum">    2182 </span><span class="lineNoCov">          0 :   DECL_IGNORED_P (hsa_host_func_table) = 1;</span>
<span class="lineNum">    2183 </span><span class="lineNoCov">          0 :   DECL_EXTERNAL (hsa_host_func_table) = 0;</span>
<span class="lineNum">    2184 </span><span class="lineNoCov">          0 :   TREE_CONSTANT (hsa_host_func_table) = 1;</span>
<span class="lineNum">    2185 </span><span class="lineNoCov">          0 :   DECL_INITIAL (hsa_host_func_table) = host_functions_ctor;</span>
<span class="lineNum">    2186 </span><span class="lineNoCov">          0 :   varpool_node::finalize_decl (hsa_host_func_table);</span>
<span class="lineNum">    2187 </span><span class="lineNoCov">          0 :   *host_func_table = hsa_host_func_table;</span>
<span class="lineNum">    2188 </span>            : 
<span class="lineNum">    2189 </span>            :   /* Following code emits list of kernel_info structures.  */
<span class="lineNum">    2190 </span>            : 
<span class="lineNum">    2191 </span><span class="lineNoCov">          0 :   tree kernel_info_type = make_node (RECORD_TYPE);</span>
<span class="lineNum">    2192 </span><span class="lineNoCov">          0 :   tree id_f1 = build_decl (BUILTINS_LOCATION, FIELD_DECL,</span>
<span class="lineNum">    2193 </span><span class="lineNoCov">          0 :                            get_identifier (&quot;name&quot;), ptr_type_node);</span>
<span class="lineNum">    2194 </span><span class="lineNoCov">          0 :   DECL_CHAIN (id_f1) = NULL_TREE;</span>
<span class="lineNum">    2195 </span><span class="lineNoCov">          0 :   tree id_f2 = build_decl (BUILTINS_LOCATION, FIELD_DECL,</span>
<span class="lineNum">    2196 </span>            :                            get_identifier (&quot;omp_data_size&quot;),
<span class="lineNum">    2197 </span><span class="lineNoCov">          0 :                            unsigned_type_node);</span>
<span class="lineNum">    2198 </span><span class="lineNoCov">          0 :   DECL_CHAIN (id_f2) = id_f1;</span>
<span class="lineNum">    2199 </span><span class="lineNoCov">          0 :   tree id_f3 = build_decl (BUILTINS_LOCATION, FIELD_DECL,</span>
<span class="lineNum">    2200 </span>            :                            get_identifier (&quot;gridified_kernel_p&quot;),
<span class="lineNum">    2201 </span><span class="lineNoCov">          0 :                            boolean_type_node);</span>
<span class="lineNum">    2202 </span><span class="lineNoCov">          0 :   DECL_CHAIN (id_f3) = id_f2;</span>
<span class="lineNum">    2203 </span><span class="lineNoCov">          0 :   tree id_f4 = build_decl (BUILTINS_LOCATION, FIELD_DECL,</span>
<span class="lineNum">    2204 </span>            :                            get_identifier (&quot;kernel_dependencies_count&quot;),
<span class="lineNum">    2205 </span><span class="lineNoCov">          0 :                            unsigned_type_node);</span>
<span class="lineNum">    2206 </span><span class="lineNoCov">          0 :   DECL_CHAIN (id_f4) = id_f3;</span>
<span class="lineNum">    2207 </span><span class="lineNoCov">          0 :   tree id_f5 = build_decl (BUILTINS_LOCATION, FIELD_DECL,</span>
<span class="lineNum">    2208 </span>            :                            get_identifier (&quot;kernel_dependencies&quot;),
<span class="lineNum">    2209 </span>            :                            build_pointer_type (build_pointer_type
<span class="lineNum">    2210 </span><span class="lineNoCov">          0 :                                                (char_type_node)));</span>
<span class="lineNum">    2211 </span><span class="lineNoCov">          0 :   DECL_CHAIN (id_f5) = id_f4;</span>
<span class="lineNum">    2212 </span><span class="lineNoCov">          0 :   finish_builtin_struct (kernel_info_type, &quot;__hsa_kernel_info&quot;, id_f5,</span>
<span class="lineNum">    2213 </span>            :                          NULL_TREE);
<span class="lineNum">    2214 </span>            : 
<span class="lineNum">    2215 </span><span class="lineNoCov">          0 :   int_num_of_kernels = build_int_cstu (uint32_type_node, map_count);</span>
<span class="lineNum">    2216 </span><span class="lineNoCov">          0 :   tree kernel_info_vector_type</span>
<span class="lineNum">    2217 </span><span class="lineNoCov">          0 :     = build_array_type (kernel_info_type,</span>
<span class="lineNum">    2218 </span><span class="lineNoCov">          0 :                         build_index_type (int_num_of_kernels));</span>
<span class="lineNum">    2219 </span><span class="lineNoCov">          0 :   TYPE_ARTIFICIAL (kernel_info_vector_type) = 1;</span>
<span class="lineNum">    2220 </span>            : 
<span class="lineNum">    2221 </span><span class="lineNoCov">          0 :   vec&lt;constructor_elt, va_gc&gt; *kernel_info_vector_vec = NULL;</span>
<span class="lineNum">    2222 </span><span class="lineNoCov">          0 :   tree kernel_dependencies_vector_type = NULL;</span>
<span class="lineNum">    2223 </span>            : 
<span class="lineNum">    2224 </span><span class="lineNoCov">          0 :   for (unsigned i = 0; i &lt; map_count; ++i)</span>
<span class="lineNum">    2225 </span>            :     {
<span class="lineNum">    2226 </span><span class="lineNoCov">          0 :       tree kernel = hsa_get_decl_kernel_mapping_decl (i);</span>
<span class="lineNum">    2227 </span><span class="lineNoCov">          0 :       char *name = hsa_get_decl_kernel_mapping_name (i);</span>
<span class="lineNum">    2228 </span><span class="lineNoCov">          0 :       unsigned len = strlen (name);</span>
<span class="lineNum">    2229 </span><span class="lineNoCov">          0 :       char *copy = XNEWVEC (char, len + 2);</span>
<span class="lineNum">    2230 </span><span class="lineNoCov">          0 :       copy[0] = '&amp;';</span>
<span class="lineNum">    2231 </span><span class="lineNoCov">          0 :       memcpy (copy + 1, name, len);</span>
<span class="lineNum">    2232 </span><span class="lineNoCov">          0 :       copy[len + 1] = '\0';</span>
<span class="lineNum">    2233 </span><span class="lineNoCov">          0 :       len++;</span>
<span class="lineNum">    2234 </span>            : 
<span class="lineNum">    2235 </span><span class="lineNoCov">          0 :       tree kern_name = build_string (len, copy);</span>
<span class="lineNum">    2236 </span><span class="lineNoCov">          0 :       TREE_TYPE (kern_name)</span>
<span class="lineNum">    2237 </span><span class="lineNoCov">          0 :         = build_array_type (char_type_node, build_index_type (size_int (len)));</span>
<span class="lineNum">    2238 </span><span class="lineNoCov">          0 :       free (copy);</span>
<span class="lineNum">    2239 </span>            : 
<span class="lineNum">    2240 </span><span class="lineNoCov">          0 :       unsigned omp_size = hsa_get_decl_kernel_mapping_omp_size (i);</span>
<span class="lineNum">    2241 </span><span class="lineNoCov">          0 :       tree omp_data_size = build_int_cstu (unsigned_type_node, omp_size);</span>
<span class="lineNum">    2242 </span><span class="lineNoCov">          0 :       bool gridified_kernel_p = hsa_get_decl_kernel_mapping_gridified (i);</span>
<span class="lineNum">    2243 </span><span class="lineNoCov">          0 :       tree gridified_kernel_p_tree = build_int_cstu (boolean_type_node,</span>
<span class="lineNum">    2244 </span>            :                                                      gridified_kernel_p);
<span class="lineNum">    2245 </span><span class="lineNoCov">          0 :       unsigned count = 0;</span>
<span class="lineNum">    2246 </span><span class="lineNoCov">          0 :       vec&lt;constructor_elt, va_gc&gt; *kernel_dependencies_vec = NULL;</span>
<span class="lineNum">    2247 </span><span class="lineNoCov">          0 :       if (hsa_decl_kernel_dependencies)</span>
<span class="lineNum">    2248 </span>            :         {
<span class="lineNum">    2249 </span><span class="lineNoCov">          0 :           vec&lt;const char *&gt; **slot;</span>
<span class="lineNum">    2250 </span><span class="lineNoCov">          0 :           slot = hsa_decl_kernel_dependencies-&gt;get (kernel);</span>
<span class="lineNum">    2251 </span><span class="lineNoCov">          0 :           if (slot)</span>
<span class="lineNum">    2252 </span>            :             {
<span class="lineNum">    2253 </span><span class="lineNoCov">          0 :               vec &lt;const char *&gt; *dependencies = *slot;</span>
<span class="lineNum">    2254 </span><span class="lineNoCov">          0 :               count = dependencies-&gt;length ();</span>
<span class="lineNum">    2255 </span>            : 
<span class="lineNum">    2256 </span><span class="lineNoCov">          0 :               kernel_dependencies_vector_type</span>
<span class="lineNum">    2257 </span><span class="lineNoCov">          0 :                 = build_array_type (build_pointer_type (char_type_node),</span>
<span class="lineNum">    2258 </span>            :                                     build_index_type (size_int (count)));
<span class="lineNum">    2259 </span><span class="lineNoCov">          0 :               TYPE_ARTIFICIAL (kernel_dependencies_vector_type) = 1;</span>
<span class="lineNum">    2260 </span>            : 
<span class="lineNum">    2261 </span><span class="lineNoCov">          0 :               for (unsigned j = 0; j &lt; count; j++)</span>
<span class="lineNum">    2262 </span>            :                 {
<span class="lineNum">    2263 </span><span class="lineNoCov">          0 :                   const char *d = (*dependencies)[j];</span>
<span class="lineNum">    2264 </span><span class="lineNoCov">          0 :                   len = strlen (d);</span>
<span class="lineNum">    2265 </span><span class="lineNoCov">          0 :                   tree dependency_name = build_string (len, d);</span>
<span class="lineNum">    2266 </span><span class="lineNoCov">          0 :                   TREE_TYPE (dependency_name)</span>
<span class="lineNum">    2267 </span><span class="lineNoCov">          0 :                     = build_array_type (char_type_node,</span>
<span class="lineNum">    2268 </span>            :                                         build_index_type (size_int (len)));
<span class="lineNum">    2269 </span>            : 
<span class="lineNum">    2270 </span><span class="lineNoCov">          0 :                   CONSTRUCTOR_APPEND_ELT</span>
<span class="lineNum">    2271 </span>            :                     (kernel_dependencies_vec, NULL_TREE,
<span class="lineNum">    2272 </span>            :                      build1 (ADDR_EXPR,
<span class="lineNum">    2273 </span>            :                              build_pointer_type (TREE_TYPE (dependency_name)),
<span class="lineNum">    2274 </span>            :                              dependency_name));
<span class="lineNum">    2275 </span>            :                 }
<span class="lineNum">    2276 </span>            :             }
<span class="lineNum">    2277 </span>            :         }
<span class="lineNum">    2278 </span>            : 
<span class="lineNum">    2279 </span><span class="lineNoCov">          0 :       tree dependencies_count = build_int_cstu (unsigned_type_node, count);</span>
<span class="lineNum">    2280 </span>            : 
<span class="lineNum">    2281 </span><span class="lineNoCov">          0 :       vec&lt;constructor_elt, va_gc&gt; *kernel_info_vec = NULL;</span>
<span class="lineNum">    2282 </span><span class="lineNoCov">          0 :       CONSTRUCTOR_APPEND_ELT (kernel_info_vec, NULL_TREE,</span>
<span class="lineNum">    2283 </span>            :                               build1 (ADDR_EXPR,
<span class="lineNum">    2284 </span>            :                                       build_pointer_type (TREE_TYPE
<span class="lineNum">    2285 </span>            :                                                           (kern_name)),
<span class="lineNum">    2286 </span>            :                                       kern_name));
<span class="lineNum">    2287 </span><span class="lineNoCov">          0 :       CONSTRUCTOR_APPEND_ELT (kernel_info_vec, NULL_TREE, omp_data_size);</span>
<span class="lineNum">    2288 </span><span class="lineNoCov">          0 :       CONSTRUCTOR_APPEND_ELT (kernel_info_vec, NULL_TREE,</span>
<span class="lineNum">    2289 </span>            :                               gridified_kernel_p_tree);
<span class="lineNum">    2290 </span><span class="lineNoCov">          0 :       CONSTRUCTOR_APPEND_ELT (kernel_info_vec, NULL_TREE, dependencies_count);</span>
<span class="lineNum">    2291 </span>            : 
<span class="lineNum">    2292 </span><span class="lineNoCov">          0 :       if (count &gt; 0)</span>
<span class="lineNum">    2293 </span>            :         {
<span class="lineNum">    2294 </span><span class="lineNoCov">          0 :           ASM_GENERATE_INTERNAL_LABEL (tmp_name, &quot;__hsa_dependencies_list&quot;, i);</span>
<span class="lineNum">    2295 </span><span class="lineNoCov">          0 :           gcc_checking_assert (kernel_dependencies_vector_type);</span>
<span class="lineNum">    2296 </span><span class="lineNoCov">          0 :           tree dependencies_list = build_decl (UNKNOWN_LOCATION, VAR_DECL,</span>
<span class="lineNum">    2297 </span>            :                                                get_identifier (tmp_name),
<span class="lineNum">    2298 </span><span class="lineNoCov">          0 :                                                kernel_dependencies_vector_type);</span>
<span class="lineNum">    2299 </span>            : 
<span class="lineNum">    2300 </span><span class="lineNoCov">          0 :           TREE_STATIC (dependencies_list) = 1;</span>
<span class="lineNum">    2301 </span><span class="lineNoCov">          0 :           TREE_READONLY (dependencies_list) = 1;</span>
<span class="lineNum">    2302 </span><span class="lineNoCov">          0 :           TREE_PUBLIC (dependencies_list) = 0;</span>
<span class="lineNum">    2303 </span><span class="lineNoCov">          0 :           DECL_ARTIFICIAL (dependencies_list) = 1;</span>
<span class="lineNum">    2304 </span><span class="lineNoCov">          0 :           DECL_IGNORED_P (dependencies_list) = 1;</span>
<span class="lineNum">    2305 </span><span class="lineNoCov">          0 :           DECL_EXTERNAL (dependencies_list) = 0;</span>
<span class="lineNum">    2306 </span><span class="lineNoCov">          0 :           TREE_CONSTANT (dependencies_list) = 1;</span>
<span class="lineNum">    2307 </span><span class="lineNoCov">          0 :           DECL_INITIAL (dependencies_list)</span>
<span class="lineNum">    2308 </span><span class="lineNoCov">          0 :             = build_constructor (kernel_dependencies_vector_type,</span>
<span class="lineNum">    2309 </span>            :                                  kernel_dependencies_vec);
<span class="lineNum">    2310 </span><span class="lineNoCov">          0 :           varpool_node::finalize_decl (dependencies_list);</span>
<span class="lineNum">    2311 </span>            : 
<span class="lineNum">    2312 </span><span class="lineNoCov">          0 :           CONSTRUCTOR_APPEND_ELT (kernel_info_vec, NULL_TREE,</span>
<span class="lineNum">    2313 </span>            :                                   build1 (ADDR_EXPR,
<span class="lineNum">    2314 </span>            :                                           build_pointer_type
<span class="lineNum">    2315 </span>            :                                             (TREE_TYPE (dependencies_list)),
<span class="lineNum">    2316 </span>            :                                           dependencies_list));
<span class="lineNum">    2317 </span>            :         }
<span class="lineNum">    2318 </span>            :       else
<span class="lineNum">    2319 </span><span class="lineNoCov">          0 :         CONSTRUCTOR_APPEND_ELT (kernel_info_vec, NULL_TREE, null_pointer_node);</span>
<span class="lineNum">    2320 </span>            : 
<span class="lineNum">    2321 </span><span class="lineNoCov">          0 :       tree kernel_info_ctor = build_constructor (kernel_info_type,</span>
<span class="lineNum">    2322 </span>            :                                                  kernel_info_vec);
<span class="lineNum">    2323 </span>            : 
<span class="lineNum">    2324 </span><span class="lineNoCov">          0 :       CONSTRUCTOR_APPEND_ELT (kernel_info_vector_vec, NULL_TREE,</span>
<span class="lineNum">    2325 </span>            :                               kernel_info_ctor);
<span class="lineNum">    2326 </span>            :     }
<span class="lineNum">    2327 </span>            : 
<span class="lineNum">    2328 </span><span class="lineNoCov">          0 :   ASM_GENERATE_INTERNAL_LABEL (tmp_name, &quot;__hsa_kernels&quot;, 1);</span>
<span class="lineNum">    2329 </span><span class="lineNoCov">          0 :   tree hsa_kernels = build_decl (UNKNOWN_LOCATION, VAR_DECL,</span>
<span class="lineNum">    2330 </span>            :                                  get_identifier (tmp_name),
<span class="lineNum">    2331 </span><span class="lineNoCov">          0 :                                  kernel_info_vector_type);</span>
<span class="lineNum">    2332 </span>            : 
<span class="lineNum">    2333 </span><span class="lineNoCov">          0 :   TREE_STATIC (hsa_kernels) = 1;</span>
<span class="lineNum">    2334 </span><span class="lineNoCov">          0 :   TREE_READONLY (hsa_kernels) = 1;</span>
<span class="lineNum">    2335 </span><span class="lineNoCov">          0 :   TREE_PUBLIC (hsa_kernels) = 0;</span>
<span class="lineNum">    2336 </span><span class="lineNoCov">          0 :   DECL_ARTIFICIAL (hsa_kernels) = 1;</span>
<span class="lineNum">    2337 </span><span class="lineNoCov">          0 :   DECL_IGNORED_P (hsa_kernels) = 1;</span>
<span class="lineNum">    2338 </span><span class="lineNoCov">          0 :   DECL_EXTERNAL (hsa_kernels) = 0;</span>
<span class="lineNum">    2339 </span><span class="lineNoCov">          0 :   TREE_CONSTANT (hsa_kernels) = 1;</span>
<span class="lineNum">    2340 </span><span class="lineNoCov">          0 :   DECL_INITIAL (hsa_kernels) = build_constructor (kernel_info_vector_type,</span>
<span class="lineNum">    2341 </span>            :                                                   kernel_info_vector_vec);
<span class="lineNum">    2342 </span><span class="lineNoCov">          0 :   varpool_node::finalize_decl (hsa_kernels);</span>
<span class="lineNum">    2343 </span><span class="lineNoCov">          0 :   *kernels = hsa_kernels;</span>
<span class="lineNum">    2344 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    2345 </span>            : 
<span class="lineNum">    2346 </span>            : /* Create a static constructor that will register out brig stuff with
<span class="lineNum">    2347 </span>            :    libgomp.  */
<a name="2348"><span class="lineNum">    2348 </span>            : </a>
<span class="lineNum">    2349 </span>            : static void
<span class="lineNum">    2350 </span><span class="lineNoCov">          0 : hsa_output_libgomp_mapping (tree brig_decl)</span>
<span class="lineNum">    2351 </span>            : {
<span class="lineNum">    2352 </span><span class="lineNoCov">          0 :   unsigned kernel_count = hsa_get_number_decl_kernel_mappings ();</span>
<span class="lineNum">    2353 </span><span class="lineNoCov">          0 :   unsigned global_variable_count = hsa_global_variable_symbols-&gt;elements ();</span>
<span class="lineNum">    2354 </span>            : 
<span class="lineNum">    2355 </span><span class="lineNoCov">          0 :   tree kernels;</span>
<span class="lineNum">    2356 </span><span class="lineNoCov">          0 :   tree host_func_table;</span>
<span class="lineNum">    2357 </span>            : 
<span class="lineNum">    2358 </span><span class="lineNoCov">          0 :   hsa_output_kernels (&amp;host_func_table, &amp;kernels);</span>
<span class="lineNum">    2359 </span><span class="lineNoCov">          0 :   tree global_vars = hsa_output_global_variables ();</span>
<span class="lineNum">    2360 </span>            : 
<span class="lineNum">    2361 </span><span class="lineNoCov">          0 :   tree hsa_image_desc_type = make_node (RECORD_TYPE);</span>
<span class="lineNum">    2362 </span><span class="lineNoCov">          0 :   tree id_f1 = build_decl (BUILTINS_LOCATION, FIELD_DECL,</span>
<span class="lineNum">    2363 </span><span class="lineNoCov">          0 :                            get_identifier (&quot;brig_module&quot;), ptr_type_node);</span>
<span class="lineNum">    2364 </span><span class="lineNoCov">          0 :   DECL_CHAIN (id_f1) = NULL_TREE;</span>
<span class="lineNum">    2365 </span><span class="lineNoCov">          0 :   tree id_f2 = build_decl (BUILTINS_LOCATION, FIELD_DECL,</span>
<span class="lineNum">    2366 </span>            :                            get_identifier (&quot;kernel_count&quot;),
<span class="lineNum">    2367 </span><span class="lineNoCov">          0 :                            unsigned_type_node);</span>
<span class="lineNum">    2368 </span>            : 
<span class="lineNum">    2369 </span><span class="lineNoCov">          0 :   DECL_CHAIN (id_f2) = id_f1;</span>
<span class="lineNum">    2370 </span><span class="lineNoCov">          0 :   tree id_f3 = build_decl (BUILTINS_LOCATION, FIELD_DECL,</span>
<span class="lineNum">    2371 </span>            :                            get_identifier (&quot;hsa_kernel_infos&quot;),
<span class="lineNum">    2372 </span><span class="lineNoCov">          0 :                            ptr_type_node);</span>
<span class="lineNum">    2373 </span><span class="lineNoCov">          0 :   DECL_CHAIN (id_f3) = id_f2;</span>
<span class="lineNum">    2374 </span><span class="lineNoCov">          0 :   tree id_f4 = build_decl (BUILTINS_LOCATION, FIELD_DECL,</span>
<span class="lineNum">    2375 </span>            :                            get_identifier (&quot;global_variable_count&quot;),
<span class="lineNum">    2376 </span><span class="lineNoCov">          0 :                            unsigned_type_node);</span>
<span class="lineNum">    2377 </span><span class="lineNoCov">          0 :   DECL_CHAIN (id_f4) = id_f3;</span>
<span class="lineNum">    2378 </span><span class="lineNoCov">          0 :   tree id_f5 = build_decl (BUILTINS_LOCATION, FIELD_DECL,</span>
<span class="lineNum">    2379 </span>            :                            get_identifier (&quot;hsa_global_variable_infos&quot;),
<span class="lineNum">    2380 </span><span class="lineNoCov">          0 :                            ptr_type_node);</span>
<span class="lineNum">    2381 </span><span class="lineNoCov">          0 :   DECL_CHAIN (id_f5) = id_f4;</span>
<span class="lineNum">    2382 </span><span class="lineNoCov">          0 :   finish_builtin_struct (hsa_image_desc_type, &quot;__hsa_image_desc&quot;, id_f5,</span>
<span class="lineNum">    2383 </span>            :                          NULL_TREE);
<span class="lineNum">    2384 </span><span class="lineNoCov">          0 :   TYPE_ARTIFICIAL (hsa_image_desc_type) = 1;</span>
<span class="lineNum">    2385 </span>            : 
<span class="lineNum">    2386 </span><span class="lineNoCov">          0 :   vec&lt;constructor_elt, va_gc&gt; *img_desc_vec = NULL;</span>
<span class="lineNum">    2387 </span><span class="lineNoCov">          0 :   CONSTRUCTOR_APPEND_ELT (img_desc_vec, NULL_TREE,</span>
<span class="lineNum">    2388 </span>            :                           build_fold_addr_expr (brig_decl));
<span class="lineNum">    2389 </span><span class="lineNoCov">          0 :   CONSTRUCTOR_APPEND_ELT (img_desc_vec, NULL_TREE,</span>
<span class="lineNum">    2390 </span>            :                           build_int_cstu (unsigned_type_node, kernel_count));
<span class="lineNum">    2391 </span><span class="lineNoCov">          0 :   CONSTRUCTOR_APPEND_ELT (img_desc_vec, NULL_TREE,</span>
<span class="lineNum">    2392 </span>            :                           build1 (ADDR_EXPR,
<span class="lineNum">    2393 </span>            :                                   build_pointer_type (TREE_TYPE (kernels)),
<span class="lineNum">    2394 </span>            :                                   kernels));
<span class="lineNum">    2395 </span><span class="lineNoCov">          0 :   CONSTRUCTOR_APPEND_ELT (img_desc_vec, NULL_TREE,</span>
<span class="lineNum">    2396 </span>            :                           build_int_cstu (unsigned_type_node,
<span class="lineNum">    2397 </span>            :                                           global_variable_count));
<span class="lineNum">    2398 </span><span class="lineNoCov">          0 :   CONSTRUCTOR_APPEND_ELT (img_desc_vec, NULL_TREE,</span>
<span class="lineNum">    2399 </span>            :                           build1 (ADDR_EXPR,
<span class="lineNum">    2400 </span>            :                                   build_pointer_type (TREE_TYPE (global_vars)),
<span class="lineNum">    2401 </span>            :                                   global_vars));
<span class="lineNum">    2402 </span>            : 
<span class="lineNum">    2403 </span><span class="lineNoCov">          0 :   tree img_desc_ctor = build_constructor (hsa_image_desc_type, img_desc_vec);</span>
<span class="lineNum">    2404 </span>            : 
<span class="lineNum">    2405 </span><span class="lineNoCov">          0 :   char tmp_name[64];</span>
<span class="lineNum">    2406 </span><span class="lineNoCov">          0 :   ASM_GENERATE_INTERNAL_LABEL (tmp_name, &quot;__hsa_img_descriptor&quot;, 1);</span>
<span class="lineNum">    2407 </span><span class="lineNoCov">          0 :   tree hsa_img_descriptor = build_decl (UNKNOWN_LOCATION, VAR_DECL,</span>
<span class="lineNum">    2408 </span>            :                                         get_identifier (tmp_name),
<span class="lineNum">    2409 </span><span class="lineNoCov">          0 :                                         hsa_image_desc_type);</span>
<span class="lineNum">    2410 </span><span class="lineNoCov">          0 :   TREE_STATIC (hsa_img_descriptor) = 1;</span>
<span class="lineNum">    2411 </span><span class="lineNoCov">          0 :   TREE_READONLY (hsa_img_descriptor) = 1;</span>
<span class="lineNum">    2412 </span><span class="lineNoCov">          0 :   TREE_PUBLIC (hsa_img_descriptor) = 0;</span>
<span class="lineNum">    2413 </span><span class="lineNoCov">          0 :   DECL_ARTIFICIAL (hsa_img_descriptor) = 1;</span>
<span class="lineNum">    2414 </span><span class="lineNoCov">          0 :   DECL_IGNORED_P (hsa_img_descriptor) = 1;</span>
<span class="lineNum">    2415 </span><span class="lineNoCov">          0 :   DECL_EXTERNAL (hsa_img_descriptor) = 0;</span>
<span class="lineNum">    2416 </span><span class="lineNoCov">          0 :   TREE_CONSTANT (hsa_img_descriptor) = 1;</span>
<span class="lineNum">    2417 </span><span class="lineNoCov">          0 :   DECL_INITIAL (hsa_img_descriptor) = img_desc_ctor;</span>
<span class="lineNum">    2418 </span><span class="lineNoCov">          0 :   varpool_node::finalize_decl (hsa_img_descriptor);</span>
<span class="lineNum">    2419 </span>            : 
<span class="lineNum">    2420 </span>            :   /* Construct the &quot;host_table&quot; libgomp expects.  */
<span class="lineNum">    2421 </span><span class="lineNoCov">          0 :   tree index_type = build_index_type (build_int_cst (integer_type_node, 4));</span>
<span class="lineNum">    2422 </span><span class="lineNoCov">          0 :   tree libgomp_host_table_type = build_array_type (ptr_type_node, index_type);</span>
<span class="lineNum">    2423 </span><span class="lineNoCov">          0 :   TYPE_ARTIFICIAL (libgomp_host_table_type) = 1;</span>
<span class="lineNum">    2424 </span><span class="lineNoCov">          0 :   vec&lt;constructor_elt, va_gc&gt; *libgomp_host_table_vec = NULL;</span>
<span class="lineNum">    2425 </span><span class="lineNoCov">          0 :   tree host_func_table_addr = build_fold_addr_expr (host_func_table);</span>
<span class="lineNum">    2426 </span><span class="lineNoCov">          0 :   CONSTRUCTOR_APPEND_ELT (libgomp_host_table_vec, NULL_TREE,</span>
<span class="lineNum">    2427 </span>            :                           host_func_table_addr);
<span class="lineNum">    2428 </span><span class="lineNoCov">          0 :   offset_int func_table_size</span>
<span class="lineNum">    2429 </span><span class="lineNoCov">          0 :     = wi::to_offset (TYPE_SIZE_UNIT (ptr_type_node)) * kernel_count;</span>
<span class="lineNum">    2430 </span><span class="lineNoCov">          0 :   CONSTRUCTOR_APPEND_ELT (libgomp_host_table_vec, NULL_TREE,</span>
<span class="lineNum">    2431 </span>            :                           fold_build2 (POINTER_PLUS_EXPR,
<span class="lineNum">    2432 </span>            :                                        TREE_TYPE (host_func_table_addr),
<span class="lineNum">    2433 </span>            :                                        host_func_table_addr,
<span class="lineNum">    2434 </span>            :                                        build_int_cst (size_type_node,
<span class="lineNum">    2435 </span>            :                                                       func_table_size.to_uhwi
<span class="lineNum">    2436 </span>            :                                                       ())));
<span class="lineNum">    2437 </span><span class="lineNoCov">          0 :   CONSTRUCTOR_APPEND_ELT (libgomp_host_table_vec, NULL_TREE, null_pointer_node);</span>
<span class="lineNum">    2438 </span><span class="lineNoCov">          0 :   CONSTRUCTOR_APPEND_ELT (libgomp_host_table_vec, NULL_TREE, null_pointer_node);</span>
<span class="lineNum">    2439 </span><span class="lineNoCov">          0 :   tree libgomp_host_table_ctor = build_constructor (libgomp_host_table_type,</span>
<span class="lineNum">    2440 </span>            :                                                     libgomp_host_table_vec);
<span class="lineNum">    2441 </span><span class="lineNoCov">          0 :   ASM_GENERATE_INTERNAL_LABEL (tmp_name, &quot;__hsa_libgomp_host_table&quot;, 1);</span>
<span class="lineNum">    2442 </span><span class="lineNoCov">          0 :   tree hsa_libgomp_host_table = build_decl (UNKNOWN_LOCATION, VAR_DECL,</span>
<span class="lineNum">    2443 </span>            :                                             get_identifier (tmp_name),
<span class="lineNum">    2444 </span><span class="lineNoCov">          0 :                                             libgomp_host_table_type);</span>
<span class="lineNum">    2445 </span>            : 
<span class="lineNum">    2446 </span><span class="lineNoCov">          0 :   TREE_STATIC (hsa_libgomp_host_table) = 1;</span>
<span class="lineNum">    2447 </span><span class="lineNoCov">          0 :   TREE_READONLY (hsa_libgomp_host_table) = 1;</span>
<span class="lineNum">    2448 </span><span class="lineNoCov">          0 :   TREE_PUBLIC (hsa_libgomp_host_table) = 0;</span>
<span class="lineNum">    2449 </span><span class="lineNoCov">          0 :   DECL_ARTIFICIAL (hsa_libgomp_host_table) = 1;</span>
<span class="lineNum">    2450 </span><span class="lineNoCov">          0 :   DECL_IGNORED_P (hsa_libgomp_host_table) = 1;</span>
<span class="lineNum">    2451 </span><span class="lineNoCov">          0 :   DECL_EXTERNAL (hsa_libgomp_host_table) = 0;</span>
<span class="lineNum">    2452 </span><span class="lineNoCov">          0 :   TREE_CONSTANT (hsa_libgomp_host_table) = 1;</span>
<span class="lineNum">    2453 </span><span class="lineNoCov">          0 :   DECL_INITIAL (hsa_libgomp_host_table) = libgomp_host_table_ctor;</span>
<span class="lineNum">    2454 </span><span class="lineNoCov">          0 :   varpool_node::finalize_decl (hsa_libgomp_host_table);</span>
<span class="lineNum">    2455 </span>            : 
<span class="lineNum">    2456 </span>            :   /* Generate an initializer with a call to the registration routine.  */
<span class="lineNum">    2457 </span>            : 
<span class="lineNum">    2458 </span><span class="lineNoCov">          0 :   tree offload_register</span>
<span class="lineNum">    2459 </span><span class="lineNoCov">          0 :     = builtin_decl_explicit (BUILT_IN_GOMP_OFFLOAD_REGISTER);</span>
<span class="lineNum">    2460 </span><span class="lineNoCov">          0 :   gcc_checking_assert (offload_register);</span>
<span class="lineNum">    2461 </span>            : 
<span class="lineNum">    2462 </span><span class="lineNoCov">          0 :   tree *hsa_ctor_stmts = hsa_get_ctor_statements ();</span>
<span class="lineNum">    2463 </span><span class="lineNoCov">          0 :   append_to_statement_list</span>
<span class="lineNum">    2464 </span><span class="lineNoCov">          0 :     (build_call_expr (offload_register, 4,</span>
<span class="lineNum">    2465 </span>            :                       build_int_cstu (unsigned_type_node,
<span class="lineNum">    2466 </span><span class="lineNoCov">          0 :                                       GOMP_VERSION_PACK (GOMP_VERSION,</span>
<span class="lineNum">    2467 </span>            :                                                          GOMP_VERSION_HSA)),
<span class="lineNum">    2468 </span>            :                       build_fold_addr_expr (hsa_libgomp_host_table),
<span class="lineNum">    2469 </span><span class="lineNoCov">          0 :                       build_int_cst (integer_type_node, GOMP_DEVICE_HSA),</span>
<span class="lineNum">    2470 </span>            :                       build_fold_addr_expr (hsa_img_descriptor)),
<span class="lineNum">    2471 </span>            :      hsa_ctor_stmts);
<span class="lineNum">    2472 </span>            : 
<span class="lineNum">    2473 </span><span class="lineNoCov">          0 :   cgraph_build_static_cdtor ('I', *hsa_ctor_stmts, DEFAULT_INIT_PRIORITY);</span>
<span class="lineNum">    2474 </span>            : 
<span class="lineNum">    2475 </span><span class="lineNoCov">          0 :   tree offload_unregister</span>
<span class="lineNum">    2476 </span><span class="lineNoCov">          0 :     = builtin_decl_explicit (BUILT_IN_GOMP_OFFLOAD_UNREGISTER);</span>
<span class="lineNum">    2477 </span><span class="lineNoCov">          0 :   gcc_checking_assert (offload_unregister);</span>
<span class="lineNum">    2478 </span>            : 
<span class="lineNum">    2479 </span><span class="lineNoCov">          0 :   tree *hsa_dtor_stmts = hsa_get_dtor_statements ();</span>
<span class="lineNum">    2480 </span><span class="lineNoCov">          0 :   append_to_statement_list</span>
<span class="lineNum">    2481 </span><span class="lineNoCov">          0 :     (build_call_expr (offload_unregister, 4,</span>
<span class="lineNum">    2482 </span>            :                       build_int_cstu (unsigned_type_node,
<span class="lineNum">    2483 </span><span class="lineNoCov">          0 :                                       GOMP_VERSION_PACK (GOMP_VERSION,</span>
<span class="lineNum">    2484 </span>            :                                                          GOMP_VERSION_HSA)),
<span class="lineNum">    2485 </span>            :                       build_fold_addr_expr (hsa_libgomp_host_table),
<span class="lineNum">    2486 </span><span class="lineNoCov">          0 :                       build_int_cst (integer_type_node, GOMP_DEVICE_HSA),</span>
<span class="lineNum">    2487 </span>            :                       build_fold_addr_expr (hsa_img_descriptor)),
<span class="lineNum">    2488 </span>            :      hsa_dtor_stmts);
<span class="lineNum">    2489 </span><span class="lineNoCov">          0 :   cgraph_build_static_cdtor ('D', *hsa_dtor_stmts, DEFAULT_INIT_PRIORITY);</span>
<span class="lineNum">    2490 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    2491 </span>            : 
<span class="lineNum">    2492 </span>            : /* Emit the brig module we have compiled to a section in the final assembly and
<span class="lineNum">    2493 </span>            :    also create a compile unit static constructor that will register the brig
<span class="lineNum">    2494 </span>            :    module with libgomp.  */
<span class="lineNum">    2495 </span>            : 
<span class="lineNum">    2496 </span>            : void
<span class="lineNum">    2497 </span><span class="lineCov">     139750 : hsa_output_brig (void)</span>
<span class="lineNum">    2498 </span>            : {
<span class="lineNum">    2499 </span><span class="lineCov">     139750 :   section *saved_section;</span>
<span class="lineNum">    2500 </span>            : 
<span class="lineNum">    2501 </span><span class="lineCov">     139750 :   if (!brig_initialized)</span>
<span class="lineNum">    2502 </span><span class="lineCov">     139750 :     return;</span>
<span class="lineNum">    2503 </span>            : 
<span class="lineNum">    2504 </span><span class="lineNoCov">          0 :   for (unsigned i = 0; i &lt; function_call_linkage.length (); i++)</span>
<span class="lineNum">    2505 </span>            :     {
<span class="lineNum">    2506 </span><span class="lineNoCov">          0 :       function_linkage_pair p = function_call_linkage[i];</span>
<span class="lineNum">    2507 </span>            : 
<span class="lineNum">    2508 </span><span class="lineNoCov">          0 :       BrigCodeOffset32_t *func_offset = function_offsets-&gt;get (p.function_decl);</span>
<span class="lineNum">    2509 </span><span class="lineNoCov">          0 :       gcc_assert (*func_offset);</span>
<span class="lineNum">    2510 </span><span class="lineNoCov">          0 :       BrigOperandCodeRef *code_ref</span>
<span class="lineNum">    2511 </span><span class="lineNoCov">          0 :         = (BrigOperandCodeRef *) (brig_operand.get_ptr_by_offset (p.offset));</span>
<span class="lineNum">    2512 </span><span class="lineNoCov">          0 :       gcc_assert (code_ref-&gt;base.kind == BRIG_KIND_OPERAND_CODE_REF);</span>
<span class="lineNum">    2513 </span><span class="lineNoCov">          0 :       code_ref-&gt;ref = lendian32 (*func_offset);</span>
<span class="lineNum">    2514 </span>            :     }
<span class="lineNum">    2515 </span>            : 
<span class="lineNum">    2516 </span>            :   /* Iterate all function declarations and if we meet a function that should
<span class="lineNum">    2517 </span>            :      have module linkage and we are unable to emit HSAIL for the function,
<span class="lineNum">    2518 </span>            :      then change the linkage to program linkage.  Doing so, we will emit
<span class="lineNum">    2519 </span>            :      a valid BRIG image.  */
<span class="lineNum">    2520 </span><span class="lineNoCov">          0 :   if (hsa_failed_functions != NULL &amp;&amp; emitted_declarations != NULL)</span>
<span class="lineNum">    2521 </span><span class="lineNoCov">          0 :     for (hash_map &lt;tree, BrigDirectiveExecutable *&gt;::iterator it</span>
<span class="lineNum">    2522 </span><span class="lineNoCov">          0 :          = emitted_declarations-&gt;begin ();</span>
<span class="lineNum">    2523 </span><span class="lineNoCov">          0 :          it != emitted_declarations-&gt;end ();</span>
<span class="lineNum">    2524 </span><span class="lineNoCov">          0 :          ++it)</span>
<span class="lineNum">    2525 </span>            :       {
<span class="lineNum">    2526 </span><span class="lineNoCov">          0 :         if (hsa_failed_functions-&gt;contains ((*it).first))</span>
<span class="lineNum">    2527 </span><span class="lineNoCov">          0 :           (*it).second-&gt;linkage = BRIG_LINKAGE_PROGRAM;</span>
<span class="lineNum">    2528 </span>            :       }
<span class="lineNum">    2529 </span>            : 
<span class="lineNum">    2530 </span><span class="lineNoCov">          0 :   saved_section = in_section;</span>
<span class="lineNum">    2531 </span>            : 
<span class="lineNum">    2532 </span><span class="lineNoCov">          0 :   switch_to_section (get_section (BRIG_ELF_SECTION_NAME, SECTION_NOTYPE, NULL));</span>
<span class="lineNum">    2533 </span><span class="lineNoCov">          0 :   char tmp_name[64];</span>
<span class="lineNum">    2534 </span><span class="lineNoCov">          0 :   ASM_GENERATE_INTERNAL_LABEL (tmp_name, BRIG_LABEL_STRING, 1);</span>
<span class="lineNum">    2535 </span><span class="lineNoCov">          0 :   ASM_OUTPUT_LABEL (asm_out_file, tmp_name);</span>
<span class="lineNum">    2536 </span><span class="lineNoCov">          0 :   tree brig_id = get_identifier (tmp_name);</span>
<span class="lineNum">    2537 </span><span class="lineNoCov">          0 :   tree brig_decl = build_decl (UNKNOWN_LOCATION, VAR_DECL, brig_id,</span>
<span class="lineNum">    2538 </span><span class="lineNoCov">          0 :                                char_type_node);</span>
<span class="lineNum">    2539 </span><span class="lineNoCov">          0 :   SET_DECL_ASSEMBLER_NAME (brig_decl, brig_id);</span>
<span class="lineNum">    2540 </span><span class="lineNoCov">          0 :   TREE_ADDRESSABLE (brig_decl) = 1;</span>
<span class="lineNum">    2541 </span><span class="lineNoCov">          0 :   TREE_READONLY (brig_decl) = 1;</span>
<span class="lineNum">    2542 </span><span class="lineNoCov">          0 :   DECL_ARTIFICIAL (brig_decl) = 1;</span>
<span class="lineNum">    2543 </span><span class="lineNoCov">          0 :   DECL_IGNORED_P (brig_decl) = 1;</span>
<span class="lineNum">    2544 </span><span class="lineNoCov">          0 :   TREE_STATIC (brig_decl) = 1;</span>
<span class="lineNum">    2545 </span><span class="lineNoCov">          0 :   TREE_PUBLIC (brig_decl) = 0;</span>
<span class="lineNum">    2546 </span><span class="lineNoCov">          0 :   TREE_USED (brig_decl) = 1;</span>
<span class="lineNum">    2547 </span><span class="lineNoCov">          0 :   DECL_INITIAL (brig_decl) = brig_decl;</span>
<span class="lineNum">    2548 </span><span class="lineNoCov">          0 :   TREE_ASM_WRITTEN (brig_decl) = 1;</span>
<span class="lineNum">    2549 </span>            : 
<span class="lineNum">    2550 </span><span class="lineNoCov">          0 :   BrigModuleHeader module_header;</span>
<span class="lineNum">    2551 </span><span class="lineNoCov">          0 :   memcpy (&amp;module_header.identification, &quot;HSA BRIG&quot;,</span>
<span class="lineNum">    2552 </span>            :           sizeof (module_header.identification));
<span class="lineNum">    2553 </span><span class="lineNoCov">          0 :   module_header.brigMajor = lendian32 (BRIG_VERSION_BRIG_MAJOR);</span>
<span class="lineNum">    2554 </span><span class="lineNoCov">          0 :   module_header.brigMinor = lendian32 (BRIG_VERSION_BRIG_MINOR);</span>
<span class="lineNum">    2555 </span><span class="lineNoCov">          0 :   uint64_t section_index[3];</span>
<span class="lineNum">    2556 </span>            : 
<span class="lineNum">    2557 </span><span class="lineNoCov">          0 :   int data_padding, code_padding, operand_padding;</span>
<span class="lineNum">    2558 </span><span class="lineNoCov">          0 :   data_padding = HSA_SECTION_ALIGNMENT</span>
<span class="lineNum">    2559 </span><span class="lineNoCov">          0 :     - brig_data.total_size % HSA_SECTION_ALIGNMENT;</span>
<span class="lineNum">    2560 </span><span class="lineNoCov">          0 :   code_padding = HSA_SECTION_ALIGNMENT</span>
<span class="lineNum">    2561 </span><span class="lineNoCov">          0 :     - brig_code.total_size % HSA_SECTION_ALIGNMENT;</span>
<span class="lineNum">    2562 </span><span class="lineNoCov">          0 :   operand_padding = HSA_SECTION_ALIGNMENT</span>
<span class="lineNum">    2563 </span><span class="lineNoCov">          0 :     - brig_operand.total_size % HSA_SECTION_ALIGNMENT;</span>
<span class="lineNum">    2564 </span>            : 
<span class="lineNum">    2565 </span><span class="lineNoCov">          0 :   uint64_t module_size = sizeof (module_header)</span>
<span class="lineNum">    2566 </span>            :     + sizeof (section_index)
<span class="lineNum">    2567 </span><span class="lineNoCov">          0 :     + brig_data.total_size</span>
<span class="lineNum">    2568 </span><span class="lineNoCov">          0 :     + data_padding</span>
<span class="lineNum">    2569 </span><span class="lineNoCov">          0 :     + brig_code.total_size</span>
<span class="lineNum">    2570 </span><span class="lineNoCov">          0 :     + code_padding</span>
<span class="lineNum">    2571 </span><span class="lineNoCov">          0 :     + brig_operand.total_size</span>
<span class="lineNum">    2572 </span><span class="lineNoCov">          0 :     + operand_padding;</span>
<span class="lineNum">    2573 </span><span class="lineNoCov">          0 :   gcc_assert ((module_size % 16) == 0);</span>
<span class="lineNum">    2574 </span><span class="lineNoCov">          0 :   module_header.byteCount = lendian64 (module_size);</span>
<span class="lineNum">    2575 </span><span class="lineNoCov">          0 :   memset (&amp;module_header.hash, 0, sizeof (module_header.hash));</span>
<span class="lineNum">    2576 </span><span class="lineNoCov">          0 :   module_header.reserved = 0;</span>
<span class="lineNum">    2577 </span><span class="lineNoCov">          0 :   module_header.sectionCount = lendian32 (3);</span>
<span class="lineNum">    2578 </span><span class="lineNoCov">          0 :   module_header.sectionIndex = lendian64 (sizeof (module_header));</span>
<span class="lineNum">    2579 </span><span class="lineNoCov">          0 :   assemble_string ((const char *) &amp;module_header, sizeof (module_header));</span>
<span class="lineNum">    2580 </span><span class="lineNoCov">          0 :   uint64_t off = sizeof (module_header) + sizeof (section_index);</span>
<span class="lineNum">    2581 </span><span class="lineNoCov">          0 :   section_index[0] = lendian64 (off);</span>
<span class="lineNum">    2582 </span><span class="lineNoCov">          0 :   off += brig_data.total_size + data_padding;</span>
<span class="lineNum">    2583 </span><span class="lineNoCov">          0 :   section_index[1] = lendian64 (off);</span>
<span class="lineNum">    2584 </span><span class="lineNoCov">          0 :   off += brig_code.total_size + code_padding;</span>
<span class="lineNum">    2585 </span><span class="lineNoCov">          0 :   section_index[2] = lendian64 (off);</span>
<span class="lineNum">    2586 </span><span class="lineNoCov">          0 :   assemble_string ((const char *) &amp;section_index, sizeof (section_index));</span>
<span class="lineNum">    2587 </span>            : 
<span class="lineNum">    2588 </span><span class="lineNoCov">          0 :   char padding[HSA_SECTION_ALIGNMENT];</span>
<span class="lineNum">    2589 </span><span class="lineNoCov">          0 :   memset (padding, 0, sizeof (padding));</span>
<span class="lineNum">    2590 </span>            : 
<span class="lineNum">    2591 </span><span class="lineNoCov">          0 :   brig_data.output ();</span>
<span class="lineNum">    2592 </span><span class="lineNoCov">          0 :   assemble_string (padding, data_padding);</span>
<span class="lineNum">    2593 </span><span class="lineNoCov">          0 :   brig_code.output ();</span>
<span class="lineNum">    2594 </span><span class="lineNoCov">          0 :   assemble_string (padding, code_padding);</span>
<span class="lineNum">    2595 </span><span class="lineNoCov">          0 :   brig_operand.output ();</span>
<span class="lineNum">    2596 </span><span class="lineNoCov">          0 :   assemble_string (padding, operand_padding);</span>
<span class="lineNum">    2597 </span>            : 
<span class="lineNum">    2598 </span><span class="lineNoCov">          0 :   if (saved_section)</span>
<span class="lineNum">    2599 </span><span class="lineNoCov">          0 :     switch_to_section (saved_section);</span>
<span class="lineNum">    2600 </span>            : 
<span class="lineNum">    2601 </span><span class="lineNoCov">          0 :   hsa_output_libgomp_mapping (brig_decl);</span>
<span class="lineNum">    2602 </span>            : 
<span class="lineNum">    2603 </span><span class="lineNoCov">          0 :   hsa_free_decl_kernel_mapping ();</span>
<span class="lineNum">    2604 </span><span class="lineNoCov">          0 :   brig_release_data ();</span>
<span class="lineNum">    2605 </span><span class="lineNoCov">          0 :   hsa_deinit_compilation_unit_data ();</span>
<span class="lineNum">    2606 </span>            : 
<span class="lineNum">    2607 </span><span class="lineNoCov">          0 :   delete emitted_declarations;</span>
<span class="lineNum">    2608 </span><span class="lineNoCov">          0 :   emitted_declarations = NULL;</span>
<span class="lineNum">    2609 </span><span class="lineNoCov">          0 :   delete function_offsets;</span>
<span class="lineNum">    2610 </span><span class="lineNoCov">          0 :   function_offsets = NULL;</span>
<span class="lineNum">    2611 </span>            : }
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.0</a></td></tr>
  </table>
  <br>
<h3>LCOV profile is generated on x86_64 machine using following configure options: configure --disable-bootstrap --enable-coverage=opt --enable-languages=c,c++,fortran,go,jit,lto --enable-host-shared. GCC test suite is run with the built compiler.</h3></body></html>
