<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - gcc.info - gcc/lcm.c</title>
  <link rel="stylesheet" type="text/css" href="../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../index.html">top level</a> - <a href="index.html">gcc</a> - lcm.c<span style="font-size: 80%;"> (source / <a href="lcm.c.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">gcc.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">307</td>
            <td class="headerCovTableEntry">307</td>
            <td class="headerCovTableEntryHi">100.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2018-09-22 10:58:49</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">11</td>
            <td class="headerCovTableEntry">11</td>
            <td class="headerCovTableEntryHi">100.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /* Generic partial redundancy elimination with lazy code motion support.</a>
<span class="lineNum">       2 </span>            :    Copyright (C) 1998-2018 Free Software Foundation, Inc.
<span class="lineNum">       3 </span>            : 
<span class="lineNum">       4 </span>            : This file is part of GCC.
<span class="lineNum">       5 </span>            : 
<span class="lineNum">       6 </span>            : GCC is free software; you can redistribute it and/or modify it under
<span class="lineNum">       7 </span>            : the terms of the GNU General Public License as published by the Free
<span class="lineNum">       8 </span>            : Software Foundation; either version 3, or (at your option) any later
<span class="lineNum">       9 </span>            : version.
<span class="lineNum">      10 </span>            : 
<span class="lineNum">      11 </span>            : GCC is distributed in the hope that it will be useful, but WITHOUT ANY
<span class="lineNum">      12 </span>            : WARRANTY; without even the implied warranty of MERCHANTABILITY or
<span class="lineNum">      13 </span>            : FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
<span class="lineNum">      14 </span>            : for more details.
<span class="lineNum">      15 </span>            : 
<span class="lineNum">      16 </span>            : You should have received a copy of the GNU General Public License
<span class="lineNum">      17 </span>            : along with GCC; see the file COPYING3.  If not see
<span class="lineNum">      18 </span>            : &lt;http://www.gnu.org/licenses/&gt;.  */
<span class="lineNum">      19 </span>            : 
<span class="lineNum">      20 </span>            : /* These routines are meant to be used by various optimization
<span class="lineNum">      21 </span>            :    passes which can be modeled as lazy code motion problems.
<span class="lineNum">      22 </span>            :    Including, but not limited to:
<span class="lineNum">      23 </span>            : 
<span class="lineNum">      24 </span>            :         * Traditional partial redundancy elimination.
<span class="lineNum">      25 </span>            : 
<span class="lineNum">      26 </span>            :         * Placement of caller/caller register save/restores.
<span class="lineNum">      27 </span>            : 
<span class="lineNum">      28 </span>            :         * Load/store motion.
<span class="lineNum">      29 </span>            : 
<span class="lineNum">      30 </span>            :         * Copy motion.
<span class="lineNum">      31 </span>            : 
<span class="lineNum">      32 </span>            :         * Conversion of flat register files to a stacked register
<span class="lineNum">      33 </span>            :         model.
<span class="lineNum">      34 </span>            : 
<span class="lineNum">      35 </span>            :         * Dead load/store elimination.
<span class="lineNum">      36 </span>            : 
<span class="lineNum">      37 </span>            :   These routines accept as input:
<span class="lineNum">      38 </span>            : 
<span class="lineNum">      39 </span>            :         * Basic block information (number of blocks, lists of
<span class="lineNum">      40 </span>            :         predecessors and successors).  Note the granularity
<span class="lineNum">      41 </span>            :         does not need to be basic block, they could be statements
<span class="lineNum">      42 </span>            :         or functions.
<span class="lineNum">      43 </span>            : 
<span class="lineNum">      44 </span>            :         * Bitmaps of local properties (computed, transparent and
<span class="lineNum">      45 </span>            :         anticipatable expressions).
<span class="lineNum">      46 </span>            : 
<span class="lineNum">      47 </span>            :   The output of these routines is bitmap of redundant computations
<span class="lineNum">      48 </span>            :   and a bitmap of optimal placement points.  */
<span class="lineNum">      49 </span>            : 
<span class="lineNum">      50 </span>            : 
<span class="lineNum">      51 </span>            : #include &quot;config.h&quot;
<span class="lineNum">      52 </span>            : #include &quot;system.h&quot;
<span class="lineNum">      53 </span>            : #include &quot;coretypes.h&quot;
<span class="lineNum">      54 </span>            : #include &quot;backend.h&quot;
<span class="lineNum">      55 </span>            : #include &quot;cfganal.h&quot;
<span class="lineNum">      56 </span>            : #include &quot;lcm.h&quot;
<span class="lineNum">      57 </span>            : 
<span class="lineNum">      58 </span>            : /* Edge based LCM routines.  */
<span class="lineNum">      59 </span>            : static void compute_antinout_edge (sbitmap *, sbitmap *, sbitmap *, sbitmap *);
<span class="lineNum">      60 </span>            : static void compute_earliest (struct edge_list *, int, sbitmap *, sbitmap *,
<span class="lineNum">      61 </span>            :                               sbitmap *, sbitmap *, sbitmap *);
<span class="lineNum">      62 </span>            : static void compute_laterin (struct edge_list *, sbitmap *, sbitmap *,
<span class="lineNum">      63 </span>            :                              sbitmap *, sbitmap *);
<span class="lineNum">      64 </span>            : static void compute_insert_delete (struct edge_list *edge_list, sbitmap *,
<span class="lineNum">      65 </span>            :                                    sbitmap *, sbitmap *, sbitmap *, sbitmap *);
<span class="lineNum">      66 </span>            : 
<span class="lineNum">      67 </span>            : /* Edge based LCM routines on a reverse flowgraph.  */
<span class="lineNum">      68 </span>            : static void compute_farthest (struct edge_list *, int, sbitmap *, sbitmap *,
<span class="lineNum">      69 </span>            :                               sbitmap*, sbitmap *, sbitmap *);
<span class="lineNum">      70 </span>            : static void compute_nearerout (struct edge_list *, sbitmap *, sbitmap *,
<span class="lineNum">      71 </span>            :                                sbitmap *, sbitmap *);
<span class="lineNum">      72 </span>            : static void compute_rev_insert_delete (struct edge_list *edge_list, sbitmap *,
<span class="lineNum">      73 </span>            :                                        sbitmap *, sbitmap *, sbitmap *,
<span class="lineNum">      74 </span>            :                                        sbitmap *);
<span class="lineNum">      75 </span>            : 
<span class="lineNum">      76 </span>            : /* Edge based lcm routines.  */
<span class="lineNum">      77 </span>            : 
<span class="lineNum">      78 </span>            : /* Compute expression anticipatability at entrance and exit of each block.
<span class="lineNum">      79 </span>            :    This is done based on the flow graph, and not on the pred-succ lists.
<span class="lineNum">      80 </span>            :    Other than that, its pretty much identical to compute_antinout.  */
<span class="lineNum">      81 </span>            : 
<span class="lineNum">      82 </span>            : static void
<span class="lineNum">      83 </span><span class="lineCov">     308886 : compute_antinout_edge (sbitmap *antloc, sbitmap *transp, sbitmap *antin,</span>
<span class="lineNum">      84 </span>            :                        sbitmap *antout)
<span class="lineNum">      85 </span>            : {
<span class="lineNum">      86 </span><span class="lineCov">     308886 :   basic_block bb;</span>
<span class="lineNum">      87 </span><span class="lineCov">     308886 :   edge e;</span>
<span class="lineNum">      88 </span><span class="lineCov">     308886 :   basic_block *worklist, *qin, *qout, *qend;</span>
<span class="lineNum">      89 </span><span class="lineCov">     308886 :   unsigned int qlen;</span>
<span class="lineNum">      90 </span><span class="lineCov">     308886 :   edge_iterator ei;</span>
<span class="lineNum">      91 </span>            : 
<span class="lineNum">      92 </span>            :   /* Allocate a worklist array/queue.  Entries are only added to the
<span class="lineNum">      93 </span>            :      list if they were not already on the list.  So the size is
<span class="lineNum">      94 </span>            :      bounded by the number of basic blocks.  */
<span class="lineNum">      95 </span><span class="lineCov">     308886 :   qin = qout = worklist = XNEWVEC (basic_block, n_basic_blocks_for_fn (cfun));</span>
<span class="lineNum">      96 </span>            : 
<span class="lineNum">      97 </span>            :   /* We want a maximal solution, so make an optimistic initialization of
<span class="lineNum">      98 </span>            :      ANTIN.  */
<span class="lineNum">      99 </span><span class="lineCov">     308886 :   bitmap_vector_ones (antin, last_basic_block_for_fn (cfun));</span>
<span class="lineNum">     100 </span>            : 
<span class="lineNum">     101 </span>            :   /* Put every block on the worklist; this is necessary because of the
<span class="lineNum">     102 </span>            :      optimistic initialization of ANTIN above.  */
<span class="lineNum">     103 </span><span class="lineCov">     308886 :   int *postorder = XNEWVEC (int, n_basic_blocks_for_fn (cfun));</span>
<span class="lineNum">     104 </span><span class="lineCov">     308886 :   int postorder_num = post_order_compute (postorder, false, false);</span>
<span class="lineNum">     105 </span><span class="lineCov">    5726040 :   for (int i = 0; i &lt; postorder_num; ++i)</span>
<span class="lineNum">     106 </span>            :     {
<span class="lineNum">     107 </span><span class="lineCov">    5417154 :       bb = BASIC_BLOCK_FOR_FN (cfun, postorder[i]);</span>
<span class="lineNum">     108 </span><span class="lineCov">    5417154 :       *qin++ = bb;</span>
<span class="lineNum">     109 </span><span class="lineCov">    5417154 :       bb-&gt;aux = bb;</span>
<span class="lineNum">     110 </span>            :     }
<span class="lineNum">     111 </span><span class="lineCov">     308886 :   free (postorder);</span>
<span class="lineNum">     112 </span>            : 
<span class="lineNum">     113 </span><span class="lineCov">     308886 :   qin = worklist;</span>
<span class="lineNum">     114 </span><span class="lineCov">     308886 :   qend = &amp;worklist[n_basic_blocks_for_fn (cfun) - NUM_FIXED_BLOCKS];</span>
<span class="lineNum">     115 </span><span class="lineCov">     308886 :   qlen = n_basic_blocks_for_fn (cfun) - NUM_FIXED_BLOCKS;</span>
<span class="lineNum">     116 </span>            : 
<span class="lineNum">     117 </span>            :   /* Mark blocks which are predecessors of the exit block so that we
<span class="lineNum">     118 </span>            :      can easily identify them below.  */
<span class="lineNum">     119 </span><span class="lineCov">    1176955 :   FOR_EACH_EDGE (e, ei, EXIT_BLOCK_PTR_FOR_FN (cfun)-&gt;preds)</span>
<span class="lineNum">     120 </span><span class="lineCov">     559183 :     e-&gt;src-&gt;aux = EXIT_BLOCK_PTR_FOR_FN (cfun);</span>
<span class="lineNum">     121 </span>            : 
<span class="lineNum">     122 </span>            :   /* Iterate until the worklist is empty.  */
<span class="lineNum">     123 </span><span class="lineCov">    6357188 :   while (qlen)</span>
<span class="lineNum">     124 </span>            :     {
<span class="lineNum">     125 </span>            :       /* Take the first entry off the worklist.  */
<span class="lineNum">     126 </span><span class="lineCov">    6048302 :       bb = *qout++;</span>
<span class="lineNum">     127 </span><span class="lineCov">    6048302 :       qlen--;</span>
<span class="lineNum">     128 </span>            : 
<span class="lineNum">     129 </span><span class="lineCov">    6048302 :       if (qout &gt;= qend)</span>
<span class="lineNum">     130 </span><span class="lineCov">     309685 :         qout = worklist;</span>
<span class="lineNum">     131 </span>            : 
<span class="lineNum">     132 </span><span class="lineCov">    6048302 :       if (bb-&gt;aux == EXIT_BLOCK_PTR_FOR_FN (cfun))</span>
<span class="lineNum">     133 </span>            :         /* Do not clear the aux field for blocks which are predecessors of
<span class="lineNum">     134 </span>            :            the EXIT block.  That way we never add then to the worklist
<span class="lineNum">     135 </span>            :            again.  */
<span class="lineNum">     136 </span><span class="lineCov">     559183 :         bitmap_clear (antout[bb-&gt;index]);</span>
<span class="lineNum">     137 </span>            :       else
<span class="lineNum">     138 </span>            :         {
<span class="lineNum">     139 </span>            :           /* Clear the aux field of this block so that it can be added to
<span class="lineNum">     140 </span>            :              the worklist again if necessary.  */
<span class="lineNum">     141 </span><span class="lineCov">    5489119 :           bb-&gt;aux = NULL;</span>
<span class="lineNum">     142 </span><span class="lineCov">    5489119 :           bitmap_intersection_of_succs (antout[bb-&gt;index], antin, bb);</span>
<span class="lineNum">     143 </span>            :         }
<span class="lineNum">     144 </span>            : 
<span class="lineNum">     145 </span><span class="lineCov">    6048302 :       if (bitmap_or_and (antin[bb-&gt;index], antloc[bb-&gt;index],</span>
<span class="lineNum">     146 </span><span class="lineCov">    6048302 :                                    transp[bb-&gt;index], antout[bb-&gt;index]))</span>
<span class="lineNum">     147 </span>            :         /* If the in state of this block changed, then we need
<span class="lineNum">     148 </span>            :            to add the predecessors of this block to the worklist
<span class="lineNum">     149 </span>            :            if they are not already on the worklist.  */
<span class="lineNum">     150 </span><span class="lineCov">   19426065 :         FOR_EACH_EDGE (e, ei, bb-&gt;preds)</span>
<span class="lineNum">     151 </span><span class="lineCov">    8230715 :           if (!e-&gt;src-&gt;aux &amp;&amp; e-&gt;src != ENTRY_BLOCK_PTR_FOR_FN (cfun))</span>
<span class="lineNum">     152 </span>            :             {
<span class="lineNum">     153 </span><span class="lineCov">     631148 :               *qin++ = e-&gt;src;</span>
<span class="lineNum">     154 </span><span class="lineCov">     631148 :               e-&gt;src-&gt;aux = e;</span>
<span class="lineNum">     155 </span><span class="lineCov">     631148 :               qlen++;</span>
<span class="lineNum">     156 </span><span class="lineCov">     631148 :               if (qin &gt;= qend)</span>
<span class="lineNum">     157 </span><span class="lineCov">        799 :                 qin = worklist;</span>
<span class="lineNum">     158 </span>            :             }
<span class="lineNum">     159 </span>            :     }
<span class="lineNum">     160 </span>            : 
<span class="lineNum">     161 </span><span class="lineCov">     308886 :   clear_aux_for_edges ();</span>
<span class="lineNum">     162 </span><span class="lineCov">     308886 :   clear_aux_for_blocks ();</span>
<span class="lineNum">     163 </span><span class="lineCov">     308886 :   free (worklist);</span>
<span class="lineNum">     164 </span><span class="lineCov">     308886 : }</span>
<span class="lineNum">     165 </span>            : 
<span class="lineNum">     166 </span>            : /* Compute the earliest vector for edge based lcm.  */
<a name="167"><span class="lineNum">     167 </span>            : </a>
<span class="lineNum">     168 </span>            : static void
<span class="lineNum">     169 </span><span class="lineCov">     308875 : compute_earliest (struct edge_list *edge_list, int n_exprs, sbitmap *antin,</span>
<span class="lineNum">     170 </span>            :                   sbitmap *antout, sbitmap *avout, sbitmap *kill,
<span class="lineNum">     171 </span>            :                   sbitmap *earliest)
<span class="lineNum">     172 </span>            : {
<span class="lineNum">     173 </span><span class="lineCov">     308875 :   int x, num_edges;</span>
<span class="lineNum">     174 </span><span class="lineCov">     308875 :   basic_block pred, succ;</span>
<span class="lineNum">     175 </span>            : 
<span class="lineNum">     176 </span><span class="lineCov">     308875 :   num_edges = NUM_EDGES (edge_list);</span>
<span class="lineNum">     177 </span>            : 
<span class="lineNum">     178 </span><span class="lineCov">     308875 :   auto_sbitmap difference (n_exprs), temp_bitmap (n_exprs);</span>
<span class="lineNum">     179 </span><span class="lineCov">    8863177 :   for (x = 0; x &lt; num_edges; x++)</span>
<span class="lineNum">     180 </span>            :     {
<span class="lineNum">     181 </span><span class="lineCov">    8554302 :       pred = INDEX_EDGE_PRED_BB (edge_list, x);</span>
<span class="lineNum">     182 </span><span class="lineCov">    8554302 :       succ = INDEX_EDGE_SUCC_BB (edge_list, x);</span>
<span class="lineNum">     183 </span><span class="lineCov">    8554302 :       if (pred == ENTRY_BLOCK_PTR_FOR_FN (cfun))</span>
<span class="lineNum">     184 </span><span class="lineCov">     308875 :         bitmap_copy (earliest[x], antin[succ-&gt;index]);</span>
<span class="lineNum">     185 </span>            :       else
<span class="lineNum">     186 </span>            :         {
<span class="lineNum">     187 </span><span class="lineCov">    8245427 :           if (succ == EXIT_BLOCK_PTR_FOR_FN (cfun))</span>
<span class="lineNum">     188 </span><span class="lineCov">     559171 :             bitmap_clear (earliest[x]);</span>
<span class="lineNum">     189 </span>            :           else
<span class="lineNum">     190 </span>            :             {
<span class="lineNum">     191 </span><span class="lineCov">    7686256 :               bitmap_and_compl (difference, antin[succ-&gt;index],</span>
<span class="lineNum">     192 </span><span class="lineCov">    7686256 :                                   avout[pred-&gt;index]);</span>
<span class="lineNum">     193 </span><span class="lineCov">   15372512 :               bitmap_not (temp_bitmap, antout[pred-&gt;index]);</span>
<span class="lineNum">     194 </span><span class="lineCov">    7686256 :               bitmap_and_or (earliest[x], difference,</span>
<span class="lineNum">     195 </span><span class="lineCov">   15372512 :                                     kill[pred-&gt;index], temp_bitmap);</span>
<span class="lineNum">     196 </span>            :             }
<span class="lineNum">     197 </span>            :         }
<span class="lineNum">     198 </span>            :     }
<span class="lineNum">     199 </span><span class="lineCov">     308875 : }</span>
<span class="lineNum">     200 </span>            : 
<span class="lineNum">     201 </span>            : /* later(p,s) is dependent on the calculation of laterin(p).
<span class="lineNum">     202 </span>            :    laterin(p) is dependent on the calculation of later(p2,p).
<span class="lineNum">     203 </span>            : 
<span class="lineNum">     204 </span>            :      laterin(ENTRY) is defined as all 0's
<span class="lineNum">     205 </span>            :      later(ENTRY, succs(ENTRY)) are defined using laterin(ENTRY)
<span class="lineNum">     206 </span>            :      laterin(succs(ENTRY)) is defined by later(ENTRY, succs(ENTRY)).
<span class="lineNum">     207 </span>            : 
<span class="lineNum">     208 </span>            :    If we progress in this manner, starting with all basic blocks
<span class="lineNum">     209 </span>            :    in the work list, anytime we change later(bb), we need to add
<span class="lineNum">     210 </span>            :    succs(bb) to the worklist if they are not already on the worklist.
<span class="lineNum">     211 </span>            : 
<span class="lineNum">     212 </span>            :    Boundary conditions:
<span class="lineNum">     213 </span>            : 
<span class="lineNum">     214 </span>            :      We prime the worklist all the normal basic blocks.   The ENTRY block can
<span class="lineNum">     215 </span>            :      never be added to the worklist since it is never the successor of any
<span class="lineNum">     216 </span>            :      block.  We explicitly prevent the EXIT block from being added to the
<span class="lineNum">     217 </span>            :      worklist.
<span class="lineNum">     218 </span>            : 
<span class="lineNum">     219 </span>            :      We optimistically initialize LATER.  That is the only time this routine
<span class="lineNum">     220 </span>            :      will compute LATER for an edge out of the entry block since the entry
<span class="lineNum">     221 </span>            :      block is never on the worklist.  Thus, LATERIN is neither used nor
<span class="lineNum">     222 </span>            :      computed for the ENTRY block.
<span class="lineNum">     223 </span>            : 
<span class="lineNum">     224 </span>            :      Since the EXIT block is never added to the worklist, we will neither
<span class="lineNum">     225 </span>            :      use nor compute LATERIN for the exit block.  Edges which reach the
<span class="lineNum">     226 </span>            :      EXIT block are handled in the normal fashion inside the loop.  However,
<span class="lineNum">     227 </span>            :      the insertion/deletion computation needs LATERIN(EXIT), so we have
<span class="lineNum">     228 </span>            :      to compute it.  */
<span class="lineNum">     229 </span>            : 
<span class="lineNum">     230 </span>            : static void
<span class="lineNum">     231 </span><span class="lineCov">     308875 : compute_laterin (struct edge_list *edge_list, sbitmap *earliest,</span>
<span class="lineNum">     232 </span>            :                  sbitmap *antloc, sbitmap *later, sbitmap *laterin)
<span class="lineNum">     233 </span>            : {
<span class="lineNum">     234 </span><span class="lineCov">     308875 :   int num_edges, i;</span>
<span class="lineNum">     235 </span><span class="lineCov">     308875 :   edge e;</span>
<span class="lineNum">     236 </span><span class="lineCov">     308875 :   basic_block *worklist, *qin, *qout, *qend, bb;</span>
<span class="lineNum">     237 </span><span class="lineCov">     308875 :   unsigned int qlen;</span>
<span class="lineNum">     238 </span><span class="lineCov">     308875 :   edge_iterator ei;</span>
<span class="lineNum">     239 </span>            : 
<span class="lineNum">     240 </span><span class="lineCov">     308875 :   num_edges = NUM_EDGES (edge_list);</span>
<span class="lineNum">     241 </span>            : 
<span class="lineNum">     242 </span>            :   /* Allocate a worklist array/queue.  Entries are only added to the
<span class="lineNum">     243 </span>            :      list if they were not already on the list.  So the size is
<span class="lineNum">     244 </span>            :      bounded by the number of basic blocks.  */
<span class="lineNum">     245 </span><span class="lineCov">     617750 :   qin = qout = worklist</span>
<span class="lineNum">     246 </span><span class="lineCov">     308875 :     = XNEWVEC (basic_block, n_basic_blocks_for_fn (cfun));</span>
<span class="lineNum">     247 </span>            : 
<span class="lineNum">     248 </span>            :   /* Initialize a mapping from each edge to its index.  */
<span class="lineNum">     249 </span><span class="lineCov">    8863177 :   for (i = 0; i &lt; num_edges; i++)</span>
<span class="lineNum">     250 </span><span class="lineCov">    8554302 :     INDEX_EDGE (edge_list, i)-&gt;aux = (void *) (size_t) i;</span>
<span class="lineNum">     251 </span>            : 
<span class="lineNum">     252 </span>            :   /* We want a maximal solution, so initially consider LATER true for
<span class="lineNum">     253 </span>            :      all edges.  This allows propagation through a loop since the incoming
<span class="lineNum">     254 </span>            :      loop edge will have LATER set, so if all the other incoming edges
<span class="lineNum">     255 </span>            :      to the loop are set, then LATERIN will be set for the head of the
<span class="lineNum">     256 </span>            :      loop.
<span class="lineNum">     257 </span>            : 
<span class="lineNum">     258 </span>            :      If the optimistic setting of LATER on that edge was incorrect (for
<span class="lineNum">     259 </span>            :      example the expression is ANTLOC in a block within the loop) then
<span class="lineNum">     260 </span>            :      this algorithm will detect it when we process the block at the head
<span class="lineNum">     261 </span>            :      of the optimistic edge.  That will requeue the affected blocks.  */
<span class="lineNum">     262 </span><span class="lineCov">     308875 :   bitmap_vector_ones (later, num_edges);</span>
<span class="lineNum">     263 </span>            : 
<span class="lineNum">     264 </span>            :   /* Note that even though we want an optimistic setting of LATER, we
<span class="lineNum">     265 </span>            :      do not want to be overly optimistic.  Consider an outgoing edge from
<span class="lineNum">     266 </span>            :      the entry block.  That edge should always have a LATER value the
<span class="lineNum">     267 </span>            :      same as EARLIEST for that edge.  */
<span class="lineNum">     268 </span><span class="lineCov">     926625 :   FOR_EACH_EDGE (e, ei, ENTRY_BLOCK_PTR_FOR_FN (cfun)-&gt;succs)</span>
<span class="lineNum">     269 </span><span class="lineCov">     308875 :     bitmap_copy (later[(size_t) e-&gt;aux], earliest[(size_t) e-&gt;aux]);</span>
<span class="lineNum">     270 </span>            : 
<span class="lineNum">     271 </span>            :   /* Add all the blocks to the worklist.  This prevents an early exit from
<span class="lineNum">     272 </span>            :      the loop given our optimistic initialization of LATER above.  */
<span class="lineNum">     273 </span><span class="lineCov">     308875 :   auto_vec&lt;int, 20&gt; postorder;</span>
<span class="lineNum">     274 </span><span class="lineCov">     308875 :   inverted_post_order_compute (&amp;postorder);</span>
<span class="lineNum">     275 </span><span class="lineCov">   12687474 :   for (unsigned int i = 0; i &lt; postorder.length (); ++i)</span>
<span class="lineNum">     276 </span>            :     {
<span class="lineNum">     277 </span><span class="lineCov">    6034862 :       bb = BASIC_BLOCK_FOR_FN (cfun, postorder[i]);</span>
<span class="lineNum">     278 </span><span class="lineCov">    6034862 :       if (bb == EXIT_BLOCK_PTR_FOR_FN (cfun)</span>
<span class="lineNum">     279 </span><span class="lineCov">    5725987 :           || bb == ENTRY_BLOCK_PTR_FOR_FN (cfun))</span>
<span class="lineNum">     280 </span>            :         continue;
<span class="lineNum">     281 </span><span class="lineCov">    5417112 :       *qin++ = bb;</span>
<span class="lineNum">     282 </span><span class="lineCov">    5417112 :       bb-&gt;aux = bb;</span>
<span class="lineNum">     283 </span>            :     }
<span class="lineNum">     284 </span>            : 
<span class="lineNum">     285 </span>            :   /* Note that we do not use the last allocated element for our queue,
<span class="lineNum">     286 </span>            :      as EXIT_BLOCK is never inserted into it. */
<span class="lineNum">     287 </span><span class="lineCov">     308875 :   qin = worklist;</span>
<span class="lineNum">     288 </span><span class="lineCov">     308875 :   qend = &amp;worklist[n_basic_blocks_for_fn (cfun) - NUM_FIXED_BLOCKS];</span>
<span class="lineNum">     289 </span><span class="lineCov">     308875 :   qlen = n_basic_blocks_for_fn (cfun) - NUM_FIXED_BLOCKS;</span>
<span class="lineNum">     290 </span>            : 
<span class="lineNum">     291 </span>            :   /* Iterate until the worklist is empty.  */
<span class="lineNum">     292 </span><span class="lineCov">    6693012 :   while (qlen)</span>
<span class="lineNum">     293 </span>            :     {
<span class="lineNum">     294 </span>            :       /* Take the first entry off the worklist.  */
<span class="lineNum">     295 </span><span class="lineCov">    6384137 :       bb = *qout++;</span>
<span class="lineNum">     296 </span><span class="lineCov">    6384137 :       bb-&gt;aux = NULL;</span>
<span class="lineNum">     297 </span><span class="lineCov">    6384137 :       qlen--;</span>
<span class="lineNum">     298 </span><span class="lineCov">    6384137 :       if (qout &gt;= qend)</span>
<span class="lineNum">     299 </span><span class="lineCov">     312052 :         qout = worklist;</span>
<span class="lineNum">     300 </span>            : 
<span class="lineNum">     301 </span>            :       /* Compute the intersection of LATERIN for each incoming edge to B.  */
<span class="lineNum">     302 </span><span class="lineCov">    6384137 :       bitmap_ones (laterin[bb-&gt;index]);</span>
<span class="lineNum">     303 </span><span class="lineCov">   24841284 :       FOR_EACH_EDGE (e, ei, bb-&gt;preds)</span>
<span class="lineNum">     304 </span><span class="lineCov">   24146020 :         bitmap_and (laterin[bb-&gt;index], laterin[bb-&gt;index],</span>
<span class="lineNum">     305 </span><span class="lineCov">   12073010 :                     later[(size_t)e-&gt;aux]);</span>
<span class="lineNum">     306 </span>            : 
<span class="lineNum">     307 </span>            :       /* Calculate LATER for all outgoing edges.  */
<span class="lineNum">     308 </span><span class="lineCov">   22573046 :       FOR_EACH_EDGE (e, ei, bb-&gt;succs)</span>
<span class="lineNum">     309 </span><span class="lineCov">   39219088 :         if (bitmap_ior_and_compl (later[(size_t) e-&gt;aux],</span>
<span class="lineNum">     310 </span><span class="lineCov">    9804772 :                                   earliest[(size_t) e-&gt;aux],</span>
<span class="lineNum">     311 </span><span class="lineCov">    9804772 :                                   laterin[bb-&gt;index],</span>
<span class="lineNum">     312 </span><span class="lineCov">    9804772 :                                   antloc[bb-&gt;index])</span>
<span class="lineNum">     313 </span>            :             /* If LATER for an outgoing edge was changed, then we need
<span class="lineNum">     314 </span>            :                to add the target of the outgoing edge to the worklist.  */
<span class="lineNum">     315 </span><span class="lineCov">    9804772 :             &amp;&amp; e-&gt;dest != EXIT_BLOCK_PTR_FOR_FN (cfun) &amp;&amp; e-&gt;dest-&gt;aux == 0)</span>
<span class="lineNum">     316 </span>            :           {
<span class="lineNum">     317 </span><span class="lineCov">     967025 :             *qin++ = e-&gt;dest;</span>
<span class="lineNum">     318 </span><span class="lineCov">     967025 :             e-&gt;dest-&gt;aux = e;</span>
<span class="lineNum">     319 </span><span class="lineCov">     967025 :             qlen++;</span>
<span class="lineNum">     320 </span><span class="lineCov">     967025 :             if (qin &gt;= qend)</span>
<span class="lineNum">     321 </span><span class="lineCov">       3177 :               qin = worklist;</span>
<span class="lineNum">     322 </span>            :           }
<span class="lineNum">     323 </span>            :     }
<span class="lineNum">     324 </span>            : 
<span class="lineNum">     325 </span>            :   /* Computation of insertion and deletion points requires computing LATERIN
<span class="lineNum">     326 </span>            :      for the EXIT block.  We allocated an extra entry in the LATERIN array
<span class="lineNum">     327 </span>            :      for just this purpose.  */
<span class="lineNum">     328 </span><span class="lineCov">     308875 :   bitmap_ones (laterin[last_basic_block_for_fn (cfun)]);</span>
<span class="lineNum">     329 </span><span class="lineCov">    1176921 :   FOR_EACH_EDGE (e, ei, EXIT_BLOCK_PTR_FOR_FN (cfun)-&gt;preds)</span>
<span class="lineNum">     330 </span><span class="lineCov">    1677513 :     bitmap_and (laterin[last_basic_block_for_fn (cfun)],</span>
<span class="lineNum">     331 </span><span class="lineCov">     559171 :                 laterin[last_basic_block_for_fn (cfun)],</span>
<span class="lineNum">     332 </span><span class="lineCov">     559171 :                 later[(size_t) e-&gt;aux]);</span>
<span class="lineNum">     333 </span>            : 
<span class="lineNum">     334 </span><span class="lineCov">     308875 :   clear_aux_for_edges ();</span>
<span class="lineNum">     335 </span><span class="lineCov">     308875 :   free (worklist);</span>
<span class="lineNum">     336 </span><span class="lineCov">     308875 : }</span>
<span class="lineNum">     337 </span>            : 
<span class="lineNum">     338 </span>            : /* Compute the insertion and deletion points for edge based LCM.  */
<a name="339"><span class="lineNum">     339 </span>            : </a>
<span class="lineNum">     340 </span>            : static void
<span class="lineNum">     341 </span><span class="lineCov">     308875 : compute_insert_delete (struct edge_list *edge_list, sbitmap *antloc,</span>
<span class="lineNum">     342 </span>            :                        sbitmap *later, sbitmap *laterin, sbitmap *insert,
<span class="lineNum">     343 </span>            :                        sbitmap *del)
<span class="lineNum">     344 </span>            : {
<span class="lineNum">     345 </span><span class="lineCov">     308875 :   int x;</span>
<span class="lineNum">     346 </span><span class="lineCov">     308875 :   basic_block bb;</span>
<span class="lineNum">     347 </span>            : 
<span class="lineNum">     348 </span><span class="lineCov">    5725987 :   FOR_EACH_BB_FN (bb, cfun)</span>
<span class="lineNum">     349 </span><span class="lineCov">   10834224 :     bitmap_and_compl (del[bb-&gt;index], antloc[bb-&gt;index],</span>
<span class="lineNum">     350 </span><span class="lineCov">    5417112 :                         laterin[bb-&gt;index]);</span>
<span class="lineNum">     351 </span>            : 
<span class="lineNum">     352 </span><span class="lineCov">    8863177 :   for (x = 0; x &lt; NUM_EDGES (edge_list); x++)</span>
<span class="lineNum">     353 </span>            :     {
<span class="lineNum">     354 </span><span class="lineCov">    8554302 :       basic_block b = INDEX_EDGE_SUCC_BB (edge_list, x);</span>
<span class="lineNum">     355 </span>            : 
<span class="lineNum">     356 </span><span class="lineCov">    8554302 :       if (b == EXIT_BLOCK_PTR_FOR_FN (cfun))</span>
<span class="lineNum">     357 </span><span class="lineCov">    1118342 :         bitmap_and_compl (insert[x], later[x],</span>
<span class="lineNum">     358 </span><span class="lineCov">     559171 :                           laterin[last_basic_block_for_fn (cfun)]);</span>
<span class="lineNum">     359 </span>            :       else
<span class="lineNum">     360 </span><span class="lineCov">    7995131 :         bitmap_and_compl (insert[x], later[x], laterin[b-&gt;index]);</span>
<span class="lineNum">     361 </span>            :     }
<span class="lineNum">     362 </span><span class="lineCov">     308875 : }</span>
<span class="lineNum">     363 </span>            : 
<span class="lineNum">     364 </span>            : /* Given local properties TRANSP, ANTLOC, AVLOC, KILL return the insert and
<span class="lineNum">     365 </span>            :    delete vectors for edge based LCM  and return the AVIN, AVOUT bitmap.
<span class="lineNum">     366 </span>            :    map the insert vector to what edge an expression should be inserted on.  */
<a name="367"><span class="lineNum">     367 </span>            : </a>
<span class="lineNum">     368 </span>            : struct edge_list *
<span class="lineNum">     369 </span><span class="lineCov">     308875 : pre_edge_lcm_avs (int n_exprs, sbitmap *transp,</span>
<span class="lineNum">     370 </span>            :               sbitmap *avloc, sbitmap *antloc, sbitmap *kill,
<span class="lineNum">     371 </span>            :               sbitmap *avin, sbitmap *avout,
<span class="lineNum">     372 </span>            :               sbitmap **insert, sbitmap **del)
<span class="lineNum">     373 </span>            : {
<span class="lineNum">     374 </span><span class="lineCov">     308875 :   sbitmap *antin, *antout, *earliest;</span>
<span class="lineNum">     375 </span><span class="lineCov">     308875 :   sbitmap *later, *laterin;</span>
<span class="lineNum">     376 </span><span class="lineCov">     308875 :   struct edge_list *edge_list;</span>
<span class="lineNum">     377 </span><span class="lineCov">     308875 :   int num_edges;</span>
<span class="lineNum">     378 </span>            : 
<span class="lineNum">     379 </span><span class="lineCov">     308875 :   edge_list = create_edge_list ();</span>
<span class="lineNum">     380 </span><span class="lineCov">     308875 :   num_edges = NUM_EDGES (edge_list);</span>
<span class="lineNum">     381 </span>            : 
<span class="lineNum">     382 </span>            : #ifdef LCM_DEBUG_INFO
<span class="lineNum">     383 </span>            :   if (dump_file)
<span class="lineNum">     384 </span>            :     {
<span class="lineNum">     385 </span>            :       fprintf (dump_file, &quot;Edge List:\n&quot;);
<span class="lineNum">     386 </span>            :       verify_edge_list (dump_file, edge_list);
<span class="lineNum">     387 </span>            :       print_edge_list (dump_file, edge_list);
<span class="lineNum">     388 </span>            :       dump_bitmap_vector (dump_file, &quot;transp&quot;, &quot;&quot;, transp,
<span class="lineNum">     389 </span>            :                           last_basic_block_for_fn (cfun));
<span class="lineNum">     390 </span>            :       dump_bitmap_vector (dump_file, &quot;antloc&quot;, &quot;&quot;, antloc,
<span class="lineNum">     391 </span>            :                           last_basic_block_for_fn (cfun));
<span class="lineNum">     392 </span>            :       dump_bitmap_vector (dump_file, &quot;avloc&quot;, &quot;&quot;, avloc,
<span class="lineNum">     393 </span>            :                           last_basic_block_for_fn (cfun));
<span class="lineNum">     394 </span>            :       dump_bitmap_vector (dump_file, &quot;kill&quot;, &quot;&quot;, kill,
<span class="lineNum">     395 </span>            :                           last_basic_block_for_fn (cfun));
<span class="lineNum">     396 </span>            :     }
<span class="lineNum">     397 </span>            : #endif
<span class="lineNum">     398 </span>            : 
<span class="lineNum">     399 </span>            :   /* Compute global availability.  */
<span class="lineNum">     400 </span><span class="lineCov">     308875 :   compute_available (avloc, kill, avout, avin);</span>
<span class="lineNum">     401 </span>            : 
<span class="lineNum">     402 </span>            :   /* Compute global anticipatability.  */
<span class="lineNum">     403 </span><span class="lineCov">     308875 :   antin = sbitmap_vector_alloc (last_basic_block_for_fn (cfun), n_exprs);</span>
<span class="lineNum">     404 </span><span class="lineCov">     308875 :   antout = sbitmap_vector_alloc (last_basic_block_for_fn (cfun), n_exprs);</span>
<span class="lineNum">     405 </span><span class="lineCov">     308875 :   compute_antinout_edge (antloc, transp, antin, antout);</span>
<span class="lineNum">     406 </span>            : 
<span class="lineNum">     407 </span>            : #ifdef LCM_DEBUG_INFO
<span class="lineNum">     408 </span>            :   if (dump_file)
<span class="lineNum">     409 </span>            :     {
<span class="lineNum">     410 </span>            :       dump_bitmap_vector (dump_file, &quot;antin&quot;, &quot;&quot;, antin,
<span class="lineNum">     411 </span>            :                           last_basic_block_for_fn (cfun));
<span class="lineNum">     412 </span>            :       dump_bitmap_vector (dump_file, &quot;antout&quot;, &quot;&quot;, antout,
<span class="lineNum">     413 </span>            :                           last_basic_block_for_fn (cfun));
<span class="lineNum">     414 </span>            :     }
<span class="lineNum">     415 </span>            : #endif
<span class="lineNum">     416 </span>            : 
<span class="lineNum">     417 </span>            :   /* Compute earliestness.  */
<span class="lineNum">     418 </span><span class="lineCov">     308875 :   earliest = sbitmap_vector_alloc (num_edges, n_exprs);</span>
<span class="lineNum">     419 </span><span class="lineCov">     308875 :   compute_earliest (edge_list, n_exprs, antin, antout, avout, kill, earliest);</span>
<span class="lineNum">     420 </span>            : 
<span class="lineNum">     421 </span>            : #ifdef LCM_DEBUG_INFO
<span class="lineNum">     422 </span>            :   if (dump_file)
<span class="lineNum">     423 </span>            :     dump_bitmap_vector (dump_file, &quot;earliest&quot;, &quot;&quot;, earliest, num_edges);
<span class="lineNum">     424 </span>            : #endif
<span class="lineNum">     425 </span>            : 
<span class="lineNum">     426 </span><span class="lineCov">     308875 :   sbitmap_vector_free (antout);</span>
<span class="lineNum">     427 </span><span class="lineCov">     308875 :   sbitmap_vector_free (antin);</span>
<span class="lineNum">     428 </span>            : 
<span class="lineNum">     429 </span><span class="lineCov">     308875 :   later = sbitmap_vector_alloc (num_edges, n_exprs);</span>
<span class="lineNum">     430 </span>            : 
<span class="lineNum">     431 </span>            :   /* Allocate an extra element for the exit block in the laterin vector.  */
<span class="lineNum">     432 </span><span class="lineCov">     308875 :   laterin = sbitmap_vector_alloc (last_basic_block_for_fn (cfun) + 1,</span>
<span class="lineNum">     433 </span>            :                                   n_exprs);
<span class="lineNum">     434 </span><span class="lineCov">     308875 :   compute_laterin (edge_list, earliest, antloc, later, laterin);</span>
<span class="lineNum">     435 </span>            : 
<span class="lineNum">     436 </span>            : #ifdef LCM_DEBUG_INFO
<span class="lineNum">     437 </span>            :   if (dump_file)
<span class="lineNum">     438 </span>            :     {
<span class="lineNum">     439 </span>            :       dump_bitmap_vector (dump_file, &quot;laterin&quot;, &quot;&quot;, laterin,
<span class="lineNum">     440 </span>            :                           last_basic_block_for_fn (cfun) + 1);
<span class="lineNum">     441 </span>            :       dump_bitmap_vector (dump_file, &quot;later&quot;, &quot;&quot;, later, num_edges);
<span class="lineNum">     442 </span>            :     }
<span class="lineNum">     443 </span>            : #endif
<span class="lineNum">     444 </span>            : 
<span class="lineNum">     445 </span><span class="lineCov">     308875 :   sbitmap_vector_free (earliest);</span>
<span class="lineNum">     446 </span>            : 
<span class="lineNum">     447 </span><span class="lineCov">     308875 :   *insert = sbitmap_vector_alloc (num_edges, n_exprs);</span>
<span class="lineNum">     448 </span><span class="lineCov">     308875 :   *del = sbitmap_vector_alloc (last_basic_block_for_fn (cfun), n_exprs);</span>
<span class="lineNum">     449 </span><span class="lineCov">     308875 :   bitmap_vector_clear (*insert, num_edges);</span>
<span class="lineNum">     450 </span><span class="lineCov">     308875 :   bitmap_vector_clear (*del, last_basic_block_for_fn (cfun));</span>
<span class="lineNum">     451 </span><span class="lineCov">     308875 :   compute_insert_delete (edge_list, antloc, later, laterin, *insert, *del);</span>
<span class="lineNum">     452 </span>            : 
<span class="lineNum">     453 </span><span class="lineCov">     617750 :   sbitmap_vector_free (laterin);</span>
<span class="lineNum">     454 </span><span class="lineCov">     617750 :   sbitmap_vector_free (later);</span>
<span class="lineNum">     455 </span>            : 
<span class="lineNum">     456 </span>            : #ifdef LCM_DEBUG_INFO
<span class="lineNum">     457 </span>            :   if (dump_file)
<span class="lineNum">     458 </span>            :     {
<span class="lineNum">     459 </span>            :       dump_bitmap_vector (dump_file, &quot;pre_insert_map&quot;, &quot;&quot;, *insert, num_edges);
<span class="lineNum">     460 </span>            :       dump_bitmap_vector (dump_file, &quot;pre_delete_map&quot;, &quot;&quot;, *del,
<span class="lineNum">     461 </span>            :                           last_basic_block_for_fn (cfun));
<span class="lineNum">     462 </span>            :     }
<span class="lineNum">     463 </span>            : #endif
<span class="lineNum">     464 </span>            : 
<span class="lineNum">     465 </span><span class="lineCov">     308875 :   return edge_list;</span>
<span class="lineNum">     466 </span>            : }
<span class="lineNum">     467 </span>            : 
<span class="lineNum">     468 </span>            : /* Wrapper to allocate avin/avout and call pre_edge_lcm_avs.  */
<a name="469"><span class="lineNum">     469 </span>            : </a>
<span class="lineNum">     470 </span>            : struct edge_list *
<span class="lineNum">     471 </span><span class="lineCov">     260276 : pre_edge_lcm (int n_exprs, sbitmap *transp,</span>
<span class="lineNum">     472 </span>            :               sbitmap *avloc, sbitmap *antloc, sbitmap *kill,
<span class="lineNum">     473 </span>            :               sbitmap **insert, sbitmap **del)
<span class="lineNum">     474 </span>            : {
<span class="lineNum">     475 </span><span class="lineCov">     260276 :   struct edge_list *edge_list;</span>
<span class="lineNum">     476 </span><span class="lineCov">     260276 :   sbitmap *avin, *avout;</span>
<span class="lineNum">     477 </span>            : 
<span class="lineNum">     478 </span><span class="lineCov">     260276 :   avin = sbitmap_vector_alloc (last_basic_block_for_fn (cfun), n_exprs);</span>
<span class="lineNum">     479 </span><span class="lineCov">     260276 :   avout = sbitmap_vector_alloc (last_basic_block_for_fn (cfun), n_exprs);</span>
<span class="lineNum">     480 </span>            : 
<span class="lineNum">     481 </span><span class="lineCov">     260276 :   edge_list = pre_edge_lcm_avs (n_exprs, transp, avloc, antloc, kill,</span>
<span class="lineNum">     482 </span>            :                                  avin, avout, insert, del);
<span class="lineNum">     483 </span>            : 
<span class="lineNum">     484 </span><span class="lineCov">     520552 :   sbitmap_vector_free (avout);</span>
<span class="lineNum">     485 </span><span class="lineCov">     520552 :   sbitmap_vector_free (avin);</span>
<span class="lineNum">     486 </span>            : 
<span class="lineNum">     487 </span><span class="lineCov">     260276 :   return edge_list;</span>
<span class="lineNum">     488 </span>            : }
<span class="lineNum">     489 </span>            : 
<span class="lineNum">     490 </span>            : /* Compute the AVIN and AVOUT vectors from the AVLOC and KILL vectors.
<span class="lineNum">     491 </span>            :    Return the number of passes we performed to iterate to a solution.  */
<span class="lineNum">     492 </span>            : 
<span class="lineNum">     493 </span>            : void
<span class="lineNum">     494 </span><span class="lineCov">    1184857 : compute_available (sbitmap *avloc, sbitmap *kill, sbitmap *avout,</span>
<span class="lineNum">     495 </span>            :                    sbitmap *avin)
<span class="lineNum">     496 </span>            : {
<span class="lineNum">     497 </span><span class="lineCov">    1184857 :   edge e;</span>
<span class="lineNum">     498 </span><span class="lineCov">    1184857 :   basic_block *worklist, *qin, *qout, *qend, bb;</span>
<span class="lineNum">     499 </span><span class="lineCov">    1184857 :   unsigned int qlen;</span>
<span class="lineNum">     500 </span><span class="lineCov">    1184857 :   edge_iterator ei;</span>
<span class="lineNum">     501 </span>            : 
<span class="lineNum">     502 </span>            :   /* Allocate a worklist array/queue.  Entries are only added to the
<span class="lineNum">     503 </span>            :      list if they were not already on the list.  So the size is
<span class="lineNum">     504 </span>            :      bounded by the number of basic blocks.  */
<span class="lineNum">     505 </span><span class="lineCov">    2369714 :   qin = qout = worklist =</span>
<span class="lineNum">     506 </span><span class="lineCov">    1184857 :     XNEWVEC (basic_block, n_basic_blocks_for_fn (cfun) - NUM_FIXED_BLOCKS);</span>
<span class="lineNum">     507 </span>            : 
<span class="lineNum">     508 </span>            :   /* We want a maximal solution.  */
<span class="lineNum">     509 </span><span class="lineCov">    1184857 :   bitmap_vector_ones (avout, last_basic_block_for_fn (cfun));</span>
<span class="lineNum">     510 </span>            : 
<span class="lineNum">     511 </span>            :   /* Put every block on the worklist; this is necessary because of the
<span class="lineNum">     512 </span>            :      optimistic initialization of AVOUT above.  Use inverted postorder
<span class="lineNum">     513 </span>            :      to make the dataflow problem require less iterations.  */
<span class="lineNum">     514 </span><span class="lineCov">    1184857 :   auto_vec&lt;int, 20&gt; postorder;</span>
<span class="lineNum">     515 </span><span class="lineCov">    1184857 :   inverted_post_order_compute (&amp;postorder);</span>
<span class="lineNum">     516 </span><span class="lineCov">   52154874 :   for (unsigned int i = 0; i &lt; postorder.length (); ++i)</span>
<span class="lineNum">     517 </span>            :     {
<span class="lineNum">     518 </span><span class="lineCov">   24892580 :       bb = BASIC_BLOCK_FOR_FN (cfun, postorder[i]);</span>
<span class="lineNum">     519 </span><span class="lineCov">   24892580 :       if (bb == EXIT_BLOCK_PTR_FOR_FN (cfun)</span>
<span class="lineNum">     520 </span><span class="lineCov">   23707723 :           || bb == ENTRY_BLOCK_PTR_FOR_FN (cfun))</span>
<span class="lineNum">     521 </span>            :         continue;
<span class="lineNum">     522 </span><span class="lineCov">   22522866 :       *qin++ = bb;</span>
<span class="lineNum">     523 </span><span class="lineCov">   22522866 :       bb-&gt;aux = bb;</span>
<span class="lineNum">     524 </span>            :     }
<span class="lineNum">     525 </span>            : 
<span class="lineNum">     526 </span><span class="lineCov">    1184857 :   qin = worklist;</span>
<span class="lineNum">     527 </span><span class="lineCov">    1184857 :   qend = &amp;worklist[n_basic_blocks_for_fn (cfun) - NUM_FIXED_BLOCKS];</span>
<span class="lineNum">     528 </span><span class="lineCov">    1184857 :   qlen = n_basic_blocks_for_fn (cfun) - NUM_FIXED_BLOCKS;</span>
<span class="lineNum">     529 </span>            : 
<span class="lineNum">     530 </span>            :   /* Mark blocks which are successors of the entry block so that we
<span class="lineNum">     531 </span>            :      can easily identify them below.  */
<span class="lineNum">     532 </span><span class="lineCov">    3554571 :   FOR_EACH_EDGE (e, ei, ENTRY_BLOCK_PTR_FOR_FN (cfun)-&gt;succs)</span>
<span class="lineNum">     533 </span><span class="lineCov">    1184857 :     e-&gt;dest-&gt;aux = ENTRY_BLOCK_PTR_FOR_FN (cfun);</span>
<span class="lineNum">     534 </span>            : 
<span class="lineNum">     535 </span>            :   /* Iterate until the worklist is empty.  */
<span class="lineNum">     536 </span><span class="lineCov">   32256516 :   while (qlen)</span>
<span class="lineNum">     537 </span>            :     {
<span class="lineNum">     538 </span>            :       /* Take the first entry off the worklist.  */
<span class="lineNum">     539 </span><span class="lineCov">   31071659 :       bb = *qout++;</span>
<span class="lineNum">     540 </span><span class="lineCov">   31071659 :       qlen--;</span>
<span class="lineNum">     541 </span>            : 
<span class="lineNum">     542 </span><span class="lineCov">   31071659 :       if (qout &gt;= qend)</span>
<span class="lineNum">     543 </span><span class="lineCov">    1231071 :         qout = worklist;</span>
<span class="lineNum">     544 </span>            : 
<span class="lineNum">     545 </span>            :       /* If one of the predecessor blocks is the ENTRY block, then the
<span class="lineNum">     546 </span>            :          intersection of avouts is the null set.  We can identify such blocks
<span class="lineNum">     547 </span>            :          by the special value in the AUX field in the block structure.  */
<span class="lineNum">     548 </span><span class="lineCov">   31071659 :       if (bb-&gt;aux == ENTRY_BLOCK_PTR_FOR_FN (cfun))</span>
<span class="lineNum">     549 </span>            :         /* Do not clear the aux field for blocks which are successors of the
<span class="lineNum">     550 </span>            :            ENTRY block.  That way we never add then to the worklist again.  */
<span class="lineNum">     551 </span><span class="lineCov">    1184857 :         bitmap_clear (avin[bb-&gt;index]);</span>
<span class="lineNum">     552 </span>            :       else
<span class="lineNum">     553 </span>            :         {
<span class="lineNum">     554 </span>            :           /* Clear the aux field of this block so that it can be added to
<span class="lineNum">     555 </span>            :              the worklist again if necessary.  */
<span class="lineNum">     556 </span><span class="lineCov">   29886802 :           bb-&gt;aux = NULL;</span>
<span class="lineNum">     557 </span><span class="lineCov">   29886802 :           bitmap_intersection_of_preds (avin[bb-&gt;index], avout, bb);</span>
<span class="lineNum">     558 </span>            :         }
<span class="lineNum">     559 </span>            : 
<span class="lineNum">     560 </span><span class="lineCov">   31071659 :       if (bitmap_ior_and_compl (avout[bb-&gt;index], avloc[bb-&gt;index],</span>
<span class="lineNum">     561 </span><span class="lineCov">   31071659 :                                     avin[bb-&gt;index], kill[bb-&gt;index]))</span>
<span class="lineNum">     562 </span>            :         /* If the out state of this block changed, then we need
<span class="lineNum">     563 </span>            :            to add the successors of this block to the worklist
<span class="lineNum">     564 </span>            :            if they are not already on the worklist.  */
<span class="lineNum">     565 </span><span class="lineCov">   95333246 :         FOR_EACH_EDGE (e, ei, bb-&gt;succs)</span>
<span class="lineNum">     566 </span><span class="lineCov">   40746284 :           if (!e-&gt;dest-&gt;aux &amp;&amp; e-&gt;dest != EXIT_BLOCK_PTR_FOR_FN (cfun))</span>
<span class="lineNum">     567 </span>            :             {
<span class="lineNum">     568 </span><span class="lineCov">    8548793 :               *qin++ = e-&gt;dest;</span>
<span class="lineNum">     569 </span><span class="lineCov">    8548793 :               e-&gt;dest-&gt;aux = e;</span>
<span class="lineNum">     570 </span><span class="lineCov">    8548793 :               qlen++;</span>
<span class="lineNum">     571 </span>            : 
<span class="lineNum">     572 </span><span class="lineCov">    8548793 :               if (qin &gt;= qend)</span>
<span class="lineNum">     573 </span><span class="lineCov">      46214 :                 qin = worklist;</span>
<span class="lineNum">     574 </span>            :             }
<span class="lineNum">     575 </span>            :     }
<span class="lineNum">     576 </span>            : 
<span class="lineNum">     577 </span><span class="lineCov">    1184857 :   clear_aux_for_edges ();</span>
<span class="lineNum">     578 </span><span class="lineCov">    1184857 :   clear_aux_for_blocks ();</span>
<span class="lineNum">     579 </span><span class="lineCov">    1184857 :   free (worklist);</span>
<span class="lineNum">     580 </span><span class="lineCov">    1184857 : }</span>
<span class="lineNum">     581 </span>            : 
<span class="lineNum">     582 </span>            : /* Compute the farthest vector for edge based lcm.  */
<a name="583"><span class="lineNum">     583 </span>            : </a>
<span class="lineNum">     584 </span>            : static void
<span class="lineNum">     585 </span><span class="lineCov">         11 : compute_farthest (struct edge_list *edge_list, int n_exprs,</span>
<span class="lineNum">     586 </span>            :                   sbitmap *st_avout, sbitmap *st_avin, sbitmap *st_antin,
<span class="lineNum">     587 </span>            :                   sbitmap *kill, sbitmap *farthest)
<span class="lineNum">     588 </span>            : {
<span class="lineNum">     589 </span><span class="lineCov">         11 :   int x, num_edges;</span>
<span class="lineNum">     590 </span><span class="lineCov">         11 :   basic_block pred, succ;</span>
<span class="lineNum">     591 </span>            : 
<span class="lineNum">     592 </span><span class="lineCov">         11 :   num_edges = NUM_EDGES (edge_list);</span>
<span class="lineNum">     593 </span>            : 
<span class="lineNum">     594 </span><span class="lineCov">         11 :   auto_sbitmap difference (n_exprs), temp_bitmap (n_exprs);</span>
<span class="lineNum">     595 </span><span class="lineCov">         81 :   for (x = 0; x &lt; num_edges; x++)</span>
<span class="lineNum">     596 </span>            :     {
<span class="lineNum">     597 </span><span class="lineCov">         70 :       pred = INDEX_EDGE_PRED_BB (edge_list, x);</span>
<span class="lineNum">     598 </span><span class="lineCov">         70 :       succ = INDEX_EDGE_SUCC_BB (edge_list, x);</span>
<span class="lineNum">     599 </span><span class="lineCov">         70 :       if (succ == EXIT_BLOCK_PTR_FOR_FN (cfun))</span>
<span class="lineNum">     600 </span><span class="lineCov">         12 :         bitmap_copy (farthest[x], st_avout[pred-&gt;index]);</span>
<span class="lineNum">     601 </span>            :       else
<span class="lineNum">     602 </span>            :         {
<span class="lineNum">     603 </span><span class="lineCov">         58 :           if (pred == ENTRY_BLOCK_PTR_FOR_FN (cfun))</span>
<span class="lineNum">     604 </span><span class="lineCov">         11 :             bitmap_clear (farthest[x]);</span>
<span class="lineNum">     605 </span>            :           else
<span class="lineNum">     606 </span>            :             {
<span class="lineNum">     607 </span><span class="lineCov">         47 :               bitmap_and_compl (difference, st_avout[pred-&gt;index],</span>
<span class="lineNum">     608 </span><span class="lineCov">         47 :                                   st_antin[succ-&gt;index]);</span>
<span class="lineNum">     609 </span><span class="lineCov">         94 :               bitmap_not (temp_bitmap, st_avin[succ-&gt;index]);</span>
<span class="lineNum">     610 </span><span class="lineCov">         47 :               bitmap_and_or (farthest[x], difference,</span>
<span class="lineNum">     611 </span><span class="lineCov">         94 :                                     kill[succ-&gt;index], temp_bitmap);</span>
<span class="lineNum">     612 </span>            :             }
<span class="lineNum">     613 </span>            :         }
<span class="lineNum">     614 </span>            :     }
<span class="lineNum">     615 </span><span class="lineCov">         11 : }</span>
<span class="lineNum">     616 </span>            : 
<span class="lineNum">     617 </span>            : /* Compute nearer and nearerout vectors for edge based lcm.
<span class="lineNum">     618 </span>            : 
<span class="lineNum">     619 </span>            :    This is the mirror of compute_laterin, additional comments on the
<span class="lineNum">     620 </span>            :    implementation can be found before compute_laterin.  */
<a name="621"><span class="lineNum">     621 </span>            : </a>
<span class="lineNum">     622 </span>            : static void
<span class="lineNum">     623 </span><span class="lineCov">         11 : compute_nearerout (struct edge_list *edge_list, sbitmap *farthest,</span>
<span class="lineNum">     624 </span>            :                    sbitmap *st_avloc, sbitmap *nearer, sbitmap *nearerout)
<span class="lineNum">     625 </span>            : {
<span class="lineNum">     626 </span><span class="lineCov">         11 :   int num_edges, i;</span>
<span class="lineNum">     627 </span><span class="lineCov">         11 :   edge e;</span>
<span class="lineNum">     628 </span><span class="lineCov">         11 :   basic_block *worklist, *tos, bb;</span>
<span class="lineNum">     629 </span><span class="lineCov">         11 :   edge_iterator ei;</span>
<span class="lineNum">     630 </span>            : 
<span class="lineNum">     631 </span><span class="lineCov">         11 :   num_edges = NUM_EDGES (edge_list);</span>
<span class="lineNum">     632 </span>            : 
<span class="lineNum">     633 </span>            :   /* Allocate a worklist array/queue.  Entries are only added to the
<span class="lineNum">     634 </span>            :      list if they were not already on the list.  So the size is
<span class="lineNum">     635 </span>            :      bounded by the number of basic blocks.  */
<span class="lineNum">     636 </span><span class="lineCov">         11 :   tos = worklist = XNEWVEC (basic_block, n_basic_blocks_for_fn (cfun) + 1);</span>
<span class="lineNum">     637 </span>            : 
<span class="lineNum">     638 </span>            :   /* Initialize NEARER for each edge and build a mapping from an edge to
<span class="lineNum">     639 </span>            :      its index.  */
<span class="lineNum">     640 </span><span class="lineCov">         81 :   for (i = 0; i &lt; num_edges; i++)</span>
<span class="lineNum">     641 </span><span class="lineCov">         70 :     INDEX_EDGE (edge_list, i)-&gt;aux = (void *) (size_t) i;</span>
<span class="lineNum">     642 </span>            : 
<span class="lineNum">     643 </span>            :   /* We want a maximal solution.  */
<span class="lineNum">     644 </span><span class="lineCov">         11 :   bitmap_vector_ones (nearer, num_edges);</span>
<span class="lineNum">     645 </span>            : 
<span class="lineNum">     646 </span>            :   /* Note that even though we want an optimistic setting of NEARER, we
<span class="lineNum">     647 </span>            :      do not want to be overly optimistic.  Consider an incoming edge to
<span class="lineNum">     648 </span>            :      the exit block.  That edge should always have a NEARER value the
<span class="lineNum">     649 </span>            :      same as FARTHEST for that edge.  */
<span class="lineNum">     650 </span><span class="lineCov">         34 :   FOR_EACH_EDGE (e, ei, EXIT_BLOCK_PTR_FOR_FN (cfun)-&gt;preds)</span>
<span class="lineNum">     651 </span><span class="lineCov">         12 :     bitmap_copy (nearer[(size_t)e-&gt;aux], farthest[(size_t)e-&gt;aux]);</span>
<span class="lineNum">     652 </span>            : 
<span class="lineNum">     653 </span>            :   /* Add all the blocks to the worklist.  This prevents an early exit
<span class="lineNum">     654 </span>            :      from the loop given our optimistic initialization of NEARER.  */
<span class="lineNum">     655 </span><span class="lineCov">         53 :   FOR_EACH_BB_FN (bb, cfun)</span>
<span class="lineNum">     656 </span>            :     {
<span class="lineNum">     657 </span><span class="lineCov">         42 :       *tos++ = bb;</span>
<span class="lineNum">     658 </span><span class="lineCov">         42 :       bb-&gt;aux = bb;</span>
<span class="lineNum">     659 </span>            :     }
<span class="lineNum">     660 </span>            : 
<span class="lineNum">     661 </span>            :   /* Iterate until the worklist is empty.  */
<span class="lineNum">     662 </span><span class="lineCov">         58 :   while (tos != worklist)</span>
<span class="lineNum">     663 </span>            :     {
<span class="lineNum">     664 </span>            :       /* Take the first entry off the worklist.  */
<span class="lineNum">     665 </span><span class="lineCov">         47 :       bb = *--tos;</span>
<span class="lineNum">     666 </span><span class="lineCov">         47 :       bb-&gt;aux = NULL;</span>
<span class="lineNum">     667 </span>            : 
<span class="lineNum">     668 </span>            :       /* Compute the intersection of NEARER for each outgoing edge from B.  */
<span class="lineNum">     669 </span><span class="lineCov">         47 :       bitmap_ones (nearerout[bb-&gt;index]);</span>
<span class="lineNum">     670 </span><span class="lineCov">        163 :       FOR_EACH_EDGE (e, ei, bb-&gt;succs)</span>
<span class="lineNum">     671 </span><span class="lineCov">        138 :         bitmap_and (nearerout[bb-&gt;index], nearerout[bb-&gt;index],</span>
<span class="lineNum">     672 </span><span class="lineCov">         69 :                          nearer[(size_t) e-&gt;aux]);</span>
<span class="lineNum">     673 </span>            : 
<span class="lineNum">     674 </span>            :       /* Calculate NEARER for all incoming edges.  */
<span class="lineNum">     675 </span><span class="lineCov">        161 :       FOR_EACH_EDGE (e, ei, bb-&gt;preds)</span>
<span class="lineNum">     676 </span><span class="lineCov">        268 :         if (bitmap_ior_and_compl (nearer[(size_t) e-&gt;aux],</span>
<span class="lineNum">     677 </span><span class="lineCov">         67 :                                       farthest[(size_t) e-&gt;aux],</span>
<span class="lineNum">     678 </span><span class="lineCov">         67 :                                       nearerout[e-&gt;dest-&gt;index],</span>
<span class="lineNum">     679 </span><span class="lineCov">         67 :                                       st_avloc[e-&gt;dest-&gt;index])</span>
<span class="lineNum">     680 </span>            :             /* If NEARER for an incoming edge was changed, then we need
<span class="lineNum">     681 </span>            :                to add the source of the incoming edge to the worklist.  */
<span class="lineNum">     682 </span><span class="lineCov">         67 :             &amp;&amp; e-&gt;src != ENTRY_BLOCK_PTR_FOR_FN (cfun) &amp;&amp; e-&gt;src-&gt;aux == 0)</span>
<span class="lineNum">     683 </span>            :           {
<span class="lineNum">     684 </span><span class="lineCov">          5 :             *tos++ = e-&gt;src;</span>
<span class="lineNum">     685 </span><span class="lineCov">          5 :             e-&gt;src-&gt;aux = e;</span>
<span class="lineNum">     686 </span>            :           }
<span class="lineNum">     687 </span>            :     }
<span class="lineNum">     688 </span>            : 
<span class="lineNum">     689 </span>            :   /* Computation of insertion and deletion points requires computing NEAREROUT
<span class="lineNum">     690 </span>            :      for the ENTRY block.  We allocated an extra entry in the NEAREROUT array
<span class="lineNum">     691 </span>            :      for just this purpose.  */
<span class="lineNum">     692 </span><span class="lineCov">         11 :   bitmap_ones (nearerout[last_basic_block_for_fn (cfun)]);</span>
<span class="lineNum">     693 </span><span class="lineCov">         33 :   FOR_EACH_EDGE (e, ei, ENTRY_BLOCK_PTR_FOR_FN (cfun)-&gt;succs)</span>
<span class="lineNum">     694 </span><span class="lineCov">         33 :     bitmap_and (nearerout[last_basic_block_for_fn (cfun)],</span>
<span class="lineNum">     695 </span><span class="lineCov">         11 :                      nearerout[last_basic_block_for_fn (cfun)],</span>
<span class="lineNum">     696 </span><span class="lineCov">         11 :                      nearer[(size_t) e-&gt;aux]);</span>
<span class="lineNum">     697 </span>            : 
<span class="lineNum">     698 </span><span class="lineCov">         11 :   clear_aux_for_edges ();</span>
<span class="lineNum">     699 </span><span class="lineCov">         11 :   free (tos);</span>
<span class="lineNum">     700 </span><span class="lineCov">         11 : }</span>
<span class="lineNum">     701 </span>            : 
<span class="lineNum">     702 </span>            : /* Compute the insertion and deletion points for edge based LCM.  */
<a name="703"><span class="lineNum">     703 </span>            : </a>
<span class="lineNum">     704 </span>            : static void
<span class="lineNum">     705 </span><span class="lineCov">         11 : compute_rev_insert_delete (struct edge_list *edge_list, sbitmap *st_avloc,</span>
<span class="lineNum">     706 </span>            :                            sbitmap *nearer, sbitmap *nearerout,
<span class="lineNum">     707 </span>            :                            sbitmap *insert, sbitmap *del)
<span class="lineNum">     708 </span>            : {
<span class="lineNum">     709 </span><span class="lineCov">         11 :   int x;</span>
<span class="lineNum">     710 </span><span class="lineCov">         11 :   basic_block bb;</span>
<span class="lineNum">     711 </span>            : 
<span class="lineNum">     712 </span><span class="lineCov">         53 :   FOR_EACH_BB_FN (bb, cfun)</span>
<span class="lineNum">     713 </span><span class="lineCov">         84 :     bitmap_and_compl (del[bb-&gt;index], st_avloc[bb-&gt;index],</span>
<span class="lineNum">     714 </span><span class="lineCov">         42 :                         nearerout[bb-&gt;index]);</span>
<span class="lineNum">     715 </span>            : 
<span class="lineNum">     716 </span><span class="lineCov">         81 :   for (x = 0; x &lt; NUM_EDGES (edge_list); x++)</span>
<span class="lineNum">     717 </span>            :     {
<span class="lineNum">     718 </span><span class="lineCov">         70 :       basic_block b = INDEX_EDGE_PRED_BB (edge_list, x);</span>
<span class="lineNum">     719 </span><span class="lineCov">         70 :       if (b == ENTRY_BLOCK_PTR_FOR_FN (cfun))</span>
<span class="lineNum">     720 </span><span class="lineCov">         22 :         bitmap_and_compl (insert[x], nearer[x],</span>
<span class="lineNum">     721 </span><span class="lineCov">         11 :                           nearerout[last_basic_block_for_fn (cfun)]);</span>
<span class="lineNum">     722 </span>            :       else
<span class="lineNum">     723 </span><span class="lineCov">         59 :         bitmap_and_compl (insert[x], nearer[x], nearerout[b-&gt;index]);</span>
<span class="lineNum">     724 </span>            :     }
<span class="lineNum">     725 </span><span class="lineCov">         11 : }</span>
<span class="lineNum">     726 </span>            : 
<span class="lineNum">     727 </span>            : /* Given local properties TRANSP, ST_AVLOC, ST_ANTLOC, KILL return the
<span class="lineNum">     728 </span>            :    insert and delete vectors for edge based reverse LCM.  Returns an
<span class="lineNum">     729 </span>            :    edgelist which is used to map the insert vector to what edge
<span class="lineNum">     730 </span>            :    an expression should be inserted on.  */
<a name="731"><span class="lineNum">     731 </span>            : </a>
<span class="lineNum">     732 </span>            : struct edge_list *
<span class="lineNum">     733 </span><span class="lineCov">         11 : pre_edge_rev_lcm (int n_exprs, sbitmap *transp,</span>
<span class="lineNum">     734 </span>            :                   sbitmap *st_avloc, sbitmap *st_antloc, sbitmap *kill,
<span class="lineNum">     735 </span>            :                   sbitmap **insert, sbitmap **del)
<span class="lineNum">     736 </span>            : {
<span class="lineNum">     737 </span><span class="lineCov">         11 :   sbitmap *st_antin, *st_antout;</span>
<span class="lineNum">     738 </span><span class="lineCov">         11 :   sbitmap *st_avout, *st_avin, *farthest;</span>
<span class="lineNum">     739 </span><span class="lineCov">         11 :   sbitmap *nearer, *nearerout;</span>
<span class="lineNum">     740 </span><span class="lineCov">         11 :   struct edge_list *edge_list;</span>
<span class="lineNum">     741 </span><span class="lineCov">         11 :   int num_edges;</span>
<span class="lineNum">     742 </span>            : 
<span class="lineNum">     743 </span><span class="lineCov">         11 :   edge_list = create_edge_list ();</span>
<span class="lineNum">     744 </span><span class="lineCov">         11 :   num_edges = NUM_EDGES (edge_list);</span>
<span class="lineNum">     745 </span>            : 
<span class="lineNum">     746 </span><span class="lineCov">         11 :   st_antin = sbitmap_vector_alloc (last_basic_block_for_fn (cfun), n_exprs);</span>
<span class="lineNum">     747 </span><span class="lineCov">         11 :   st_antout = sbitmap_vector_alloc (last_basic_block_for_fn (cfun), n_exprs);</span>
<span class="lineNum">     748 </span><span class="lineCov">         11 :   bitmap_vector_clear (st_antin, last_basic_block_for_fn (cfun));</span>
<span class="lineNum">     749 </span><span class="lineCov">         11 :   bitmap_vector_clear (st_antout, last_basic_block_for_fn (cfun));</span>
<span class="lineNum">     750 </span><span class="lineCov">         11 :   compute_antinout_edge (st_antloc, transp, st_antin, st_antout);</span>
<span class="lineNum">     751 </span>            : 
<span class="lineNum">     752 </span>            :   /* Compute global anticipatability.  */
<span class="lineNum">     753 </span><span class="lineCov">         11 :   st_avout = sbitmap_vector_alloc (last_basic_block_for_fn (cfun), n_exprs);</span>
<span class="lineNum">     754 </span><span class="lineCov">         11 :   st_avin = sbitmap_vector_alloc (last_basic_block_for_fn (cfun), n_exprs);</span>
<span class="lineNum">     755 </span><span class="lineCov">         11 :   compute_available (st_avloc, kill, st_avout, st_avin);</span>
<span class="lineNum">     756 </span>            : 
<span class="lineNum">     757 </span>            : #ifdef LCM_DEBUG_INFO
<span class="lineNum">     758 </span>            :   if (dump_file)
<span class="lineNum">     759 </span>            :     {
<span class="lineNum">     760 </span>            :       fprintf (dump_file, &quot;Edge List:\n&quot;);
<span class="lineNum">     761 </span>            :       verify_edge_list (dump_file, edge_list);
<span class="lineNum">     762 </span>            :       print_edge_list (dump_file, edge_list);
<span class="lineNum">     763 </span>            :       dump_bitmap_vector (dump_file, &quot;transp&quot;, &quot;&quot;, transp,
<span class="lineNum">     764 </span>            :                           last_basic_block_for_fn (cfun));
<span class="lineNum">     765 </span>            :       dump_bitmap_vector (dump_file, &quot;st_avloc&quot;, &quot;&quot;, st_avloc,
<span class="lineNum">     766 </span>            :                           last_basic_block_for_fn (cfun));
<span class="lineNum">     767 </span>            :       dump_bitmap_vector (dump_file, &quot;st_antloc&quot;, &quot;&quot;, st_antloc,
<span class="lineNum">     768 </span>            :                           last_basic_block_for_fn (cfun));
<span class="lineNum">     769 </span>            :       dump_bitmap_vector (dump_file, &quot;st_antin&quot;, &quot;&quot;, st_antin,
<span class="lineNum">     770 </span>            :                           last_basic_block_for_fn (cfun));
<span class="lineNum">     771 </span>            :       dump_bitmap_vector (dump_file, &quot;st_antout&quot;, &quot;&quot;, st_antout,
<span class="lineNum">     772 </span>            :                           last_basic_block_for_fn (cfun));
<span class="lineNum">     773 </span>            :       dump_bitmap_vector (dump_file, &quot;st_kill&quot;, &quot;&quot;, kill,
<span class="lineNum">     774 </span>            :                           last_basic_block_for_fn (cfun));
<span class="lineNum">     775 </span>            :     }
<span class="lineNum">     776 </span>            : #endif
<span class="lineNum">     777 </span>            : 
<span class="lineNum">     778 </span>            : #ifdef LCM_DEBUG_INFO
<span class="lineNum">     779 </span>            :   if (dump_file)
<span class="lineNum">     780 </span>            :     {
<span class="lineNum">     781 </span>            :       dump_bitmap_vector (dump_file, &quot;st_avout&quot;, &quot;&quot;, st_avout, last_basic_block_for_fn (cfun));
<span class="lineNum">     782 </span>            :       dump_bitmap_vector (dump_file, &quot;st_avin&quot;, &quot;&quot;, st_avin, last_basic_block_for_fn (cfun));
<span class="lineNum">     783 </span>            :     }
<span class="lineNum">     784 </span>            : #endif
<span class="lineNum">     785 </span>            : 
<span class="lineNum">     786 </span>            :   /* Compute farthestness.  */
<span class="lineNum">     787 </span><span class="lineCov">         11 :   farthest = sbitmap_vector_alloc (num_edges, n_exprs);</span>
<span class="lineNum">     788 </span><span class="lineCov">         11 :   compute_farthest (edge_list, n_exprs, st_avout, st_avin, st_antin,</span>
<span class="lineNum">     789 </span>            :                     kill, farthest);
<span class="lineNum">     790 </span>            : 
<span class="lineNum">     791 </span>            : #ifdef LCM_DEBUG_INFO
<span class="lineNum">     792 </span>            :   if (dump_file)
<span class="lineNum">     793 </span>            :     dump_bitmap_vector (dump_file, &quot;farthest&quot;, &quot;&quot;, farthest, num_edges);
<span class="lineNum">     794 </span>            : #endif
<span class="lineNum">     795 </span>            : 
<span class="lineNum">     796 </span><span class="lineCov">         11 :   sbitmap_vector_free (st_antin);</span>
<span class="lineNum">     797 </span><span class="lineCov">         11 :   sbitmap_vector_free (st_antout);</span>
<span class="lineNum">     798 </span>            : 
<span class="lineNum">     799 </span><span class="lineCov">         11 :   sbitmap_vector_free (st_avin);</span>
<span class="lineNum">     800 </span><span class="lineCov">         11 :   sbitmap_vector_free (st_avout);</span>
<span class="lineNum">     801 </span>            : 
<span class="lineNum">     802 </span><span class="lineCov">         11 :   nearer = sbitmap_vector_alloc (num_edges, n_exprs);</span>
<span class="lineNum">     803 </span>            : 
<span class="lineNum">     804 </span>            :   /* Allocate an extra element for the entry block.  */
<span class="lineNum">     805 </span><span class="lineCov">         11 :   nearerout = sbitmap_vector_alloc (last_basic_block_for_fn (cfun) + 1,</span>
<span class="lineNum">     806 </span>            :                                     n_exprs);
<span class="lineNum">     807 </span><span class="lineCov">         11 :   compute_nearerout (edge_list, farthest, st_avloc, nearer, nearerout);</span>
<span class="lineNum">     808 </span>            : 
<span class="lineNum">     809 </span>            : #ifdef LCM_DEBUG_INFO
<span class="lineNum">     810 </span>            :   if (dump_file)
<span class="lineNum">     811 </span>            :     {
<span class="lineNum">     812 </span>            :       dump_bitmap_vector (dump_file, &quot;nearerout&quot;, &quot;&quot;, nearerout,
<span class="lineNum">     813 </span>            :                            last_basic_block_for_fn (cfun) + 1);
<span class="lineNum">     814 </span>            :       dump_bitmap_vector (dump_file, &quot;nearer&quot;, &quot;&quot;, nearer, num_edges);
<span class="lineNum">     815 </span>            :     }
<span class="lineNum">     816 </span>            : #endif
<span class="lineNum">     817 </span>            : 
<span class="lineNum">     818 </span><span class="lineCov">         11 :   sbitmap_vector_free (farthest);</span>
<span class="lineNum">     819 </span>            : 
<span class="lineNum">     820 </span><span class="lineCov">         11 :   *insert = sbitmap_vector_alloc (num_edges, n_exprs);</span>
<span class="lineNum">     821 </span><span class="lineCov">         11 :   *del = sbitmap_vector_alloc (last_basic_block_for_fn (cfun), n_exprs);</span>
<span class="lineNum">     822 </span><span class="lineCov">         11 :   compute_rev_insert_delete (edge_list, st_avloc, nearer, nearerout,</span>
<span class="lineNum">     823 </span>            :                              *insert, *del);
<span class="lineNum">     824 </span>            : 
<span class="lineNum">     825 </span><span class="lineCov">         22 :   sbitmap_vector_free (nearerout);</span>
<span class="lineNum">     826 </span><span class="lineCov">         22 :   sbitmap_vector_free (nearer);</span>
<span class="lineNum">     827 </span>            : 
<span class="lineNum">     828 </span>            : #ifdef LCM_DEBUG_INFO
<span class="lineNum">     829 </span>            :   if (dump_file)
<span class="lineNum">     830 </span>            :     {
<span class="lineNum">     831 </span>            :       dump_bitmap_vector (dump_file, &quot;pre_insert_map&quot;, &quot;&quot;, *insert, num_edges);
<span class="lineNum">     832 </span>            :       dump_bitmap_vector (dump_file, &quot;pre_delete_map&quot;, &quot;&quot;, *del,
<span class="lineNum">     833 </span>            :                            last_basic_block_for_fn (cfun));
<span class="lineNum">     834 </span>            :     }
<span class="lineNum">     835 </span>            : #endif
<span class="lineNum">     836 </span><span class="lineCov">         11 :   return edge_list;</span>
<span class="lineNum">     837 </span>            : }
<span class="lineNum">     838 </span>            : 
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.0</a></td></tr>
  </table>
  <br>
<h3>LCOV profile is generated on x86_64 machine using following configure options: configure --disable-bootstrap --enable-coverage=opt --enable-languages=c,c++,fortran,go,jit,lto --enable-host-shared. GCC test suite is run with the built compiler.</h3></body></html>
