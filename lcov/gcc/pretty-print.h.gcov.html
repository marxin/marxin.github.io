<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - gcc.info - gcc/pretty-print.h</title>
  <link rel="stylesheet" type="text/css" href="../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../index.html">top level</a> - <a href="index.html">gcc</a> - pretty-print.h<span style="font-size: 80%;"> (source / <a href="pretty-print.h.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">gcc.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">12</td>
            <td class="headerCovTableEntry">25</td>
            <td class="headerCovTableEntryLo">48.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2018-09-22 10:58:49</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">1</td>
            <td class="headerCovTableEntry">6</td>
            <td class="headerCovTableEntryLo">16.7 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /* Various declarations for language-independent pretty-print subroutines.</a>
<span class="lineNum">       2 </span>            :    Copyright (C) 2002-2018 Free Software Foundation, Inc.
<span class="lineNum">       3 </span>            :    Contributed by Gabriel Dos Reis &lt;gdr@integrable-solutions.net&gt;
<span class="lineNum">       4 </span>            : 
<span class="lineNum">       5 </span>            : This file is part of GCC.
<span class="lineNum">       6 </span>            : 
<span class="lineNum">       7 </span>            : GCC is free software; you can redistribute it and/or modify it under
<span class="lineNum">       8 </span>            : the terms of the GNU General Public License as published by the Free
<span class="lineNum">       9 </span>            : Software Foundation; either version 3, or (at your option) any later
<span class="lineNum">      10 </span>            : version.
<span class="lineNum">      11 </span>            : 
<span class="lineNum">      12 </span>            : GCC is distributed in the hope that it will be useful, but WITHOUT ANY
<span class="lineNum">      13 </span>            : WARRANTY; without even the implied warranty of MERCHANTABILITY or
<span class="lineNum">      14 </span>            : FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
<span class="lineNum">      15 </span>            : for more details.
<span class="lineNum">      16 </span>            : 
<span class="lineNum">      17 </span>            : You should have received a copy of the GNU General Public License
<span class="lineNum">      18 </span>            : along with GCC; see the file COPYING3.  If not see
<span class="lineNum">      19 </span>            : &lt;http://www.gnu.org/licenses/&gt;.  */
<span class="lineNum">      20 </span>            : 
<span class="lineNum">      21 </span>            : #ifndef GCC_PRETTY_PRINT_H
<span class="lineNum">      22 </span>            : #define GCC_PRETTY_PRINT_H
<span class="lineNum">      23 </span>            : 
<span class="lineNum">      24 </span>            : #include &quot;obstack.h&quot;
<span class="lineNum">      25 </span>            : 
<span class="lineNum">      26 </span>            : /* Maximum number of format string arguments.  */
<span class="lineNum">      27 </span>            : #define PP_NL_ARGMAX   30
<span class="lineNum">      28 </span>            : 
<span class="lineNum">      29 </span>            : /* The type of a text to be formatted according a format specification
<span class="lineNum">      30 </span>            :    along with a list of things.  */
<span class="lineNum">      31 </span>            : struct text_info
<span class="lineNum">      32 </span>            : {
<span class="lineNum">      33 </span>            :   const char *format_spec;
<span class="lineNum">      34 </span>            :   va_list *args_ptr;
<span class="lineNum">      35 </span>            :   int err_no;  /* for %m */
<span class="lineNum">      36 </span>            :   void **x_data;
<span class="lineNum">      37 </span>            :   rich_location *m_richloc;
<span class="lineNum">      38 </span>            : 
<span class="lineNum">      39 </span>            :   void set_location (unsigned int idx, location_t loc,
<span class="lineNum">      40 </span>            :                      enum range_display_kind range_display_kind);
<span class="lineNum">      41 </span>            :   location_t get_location (unsigned int index_of_location) const;
<span class="lineNum">      42 </span>            : };
<span class="lineNum">      43 </span>            : 
<span class="lineNum">      44 </span>            : /* How often diagnostics are prefixed by their locations:
<span class="lineNum">      45 </span>            :    o DIAGNOSTICS_SHOW_PREFIX_NEVER: never - not yet supported;
<span class="lineNum">      46 </span>            :    o DIAGNOSTICS_SHOW_PREFIX_ONCE: emit only once;
<span class="lineNum">      47 </span>            :    o DIAGNOSTICS_SHOW_PREFIX_EVERY_LINE: emit each time a physical
<span class="lineNum">      48 </span>            :    line is started.  */
<span class="lineNum">      49 </span>            : enum diagnostic_prefixing_rule_t
<span class="lineNum">      50 </span>            : {
<span class="lineNum">      51 </span>            :   DIAGNOSTICS_SHOW_PREFIX_ONCE       = 0x0,
<span class="lineNum">      52 </span>            :   DIAGNOSTICS_SHOW_PREFIX_NEVER      = 0x1,
<span class="lineNum">      53 </span>            :   DIAGNOSTICS_SHOW_PREFIX_EVERY_LINE = 0x2
<span class="lineNum">      54 </span>            : };
<span class="lineNum">      55 </span>            : 
<span class="lineNum">      56 </span>            : /* The chunk_info data structure forms a stack of the results from the
<span class="lineNum">      57 </span>            :    first phase of formatting (pp_format) which have not yet been
<span class="lineNum">      58 </span>            :    output (pp_output_formatted_text).  A stack is necessary because
<span class="lineNum">      59 </span>            :    the diagnostic starter may decide to generate its own output by way
<span class="lineNum">      60 </span>            :    of the formatter.  */
<span class="lineNum">      61 </span>            : struct chunk_info
<span class="lineNum">      62 </span>            : {
<span class="lineNum">      63 </span>            :   /* Pointer to previous chunk on the stack.  */
<span class="lineNum">      64 </span>            :   struct chunk_info *prev;
<span class="lineNum">      65 </span>            : 
<span class="lineNum">      66 </span>            :   /* Array of chunks to output.  Each chunk is a NUL-terminated string.
<span class="lineNum">      67 </span>            :      In the first phase of formatting, even-numbered chunks are
<span class="lineNum">      68 </span>            :      to be output verbatim, odd-numbered chunks are format specifiers.
<span class="lineNum">      69 </span>            :      The second phase replaces all odd-numbered chunks with formatted
<span class="lineNum">      70 </span>            :      text, and the third phase simply emits all the chunks in sequence
<span class="lineNum">      71 </span>            :      with appropriate line-wrapping.  */
<span class="lineNum">      72 </span>            :   const char *args[PP_NL_ARGMAX * 2];
<span class="lineNum">      73 </span>            : };
<span class="lineNum">      74 </span>            : 
<span class="lineNum">      75 </span>            : /* The output buffer datatype.  This is best seen as an abstract datatype
<span class="lineNum">      76 </span>            :    whose fields should not be accessed directly by clients.  */
<span class="lineNum">      77 </span>            : struct output_buffer
<span class="lineNum">      78 </span>            : {
<span class="lineNum">      79 </span>            :   output_buffer ();
<span class="lineNum">      80 </span>            :   ~output_buffer ();
<span class="lineNum">      81 </span>            : 
<span class="lineNum">      82 </span>            :   /* Obstack where the text is built up.  */
<span class="lineNum">      83 </span>            :   struct obstack formatted_obstack;
<span class="lineNum">      84 </span>            : 
<span class="lineNum">      85 </span>            :   /* Obstack containing a chunked representation of the format
<span class="lineNum">      86 </span>            :      specification plus arguments.  */
<span class="lineNum">      87 </span>            :   struct obstack chunk_obstack;
<span class="lineNum">      88 </span>            : 
<span class="lineNum">      89 </span>            :   /* Currently active obstack: one of the above two.  This is used so
<span class="lineNum">      90 </span>            :      that the text formatters don't need to know which phase we're in.  */
<span class="lineNum">      91 </span>            :   struct obstack *obstack;
<span class="lineNum">      92 </span>            : 
<span class="lineNum">      93 </span>            :   /* Stack of chunk arrays.  These come from the chunk_obstack.  */
<span class="lineNum">      94 </span>            :   struct chunk_info *cur_chunk_array;
<span class="lineNum">      95 </span>            : 
<span class="lineNum">      96 </span>            :   /* Where to output formatted text.  */
<span class="lineNum">      97 </span>            :   FILE *stream;
<span class="lineNum">      98 </span>            : 
<span class="lineNum">      99 </span>            :   /* The amount of characters output so far.  */
<span class="lineNum">     100 </span>            :   int line_length;
<span class="lineNum">     101 </span>            : 
<span class="lineNum">     102 </span>            :   /* This must be large enough to hold any printed integer or
<span class="lineNum">     103 </span>            :      floating-point value.  */
<span class="lineNum">     104 </span>            :   char digit_buffer[128];
<span class="lineNum">     105 </span>            : 
<span class="lineNum">     106 </span>            :   /* Nonzero means that text should be flushed when
<span class="lineNum">     107 </span>            :      appropriate. Otherwise, text is buffered until either
<span class="lineNum">     108 </span>            :      pp_really_flush or pp_clear_output_area are called.  */
<span class="lineNum">     109 </span>            :   bool flush_p;
<span class="lineNum">     110 </span>            : };
<span class="lineNum">     111 </span>            : 
<span class="lineNum">     112 </span>            : /* Finishes constructing a NULL-terminated character string representing
<a name="113"><span class="lineNum">     113 </span>            :    the buffered text.  */</a>
<span class="lineNum">     114 </span>            : static inline const char *
<span class="lineNum">     115 </span><span class="lineNoCov">          0 : output_buffer_formatted_text (output_buffer *buff)</span>
<span class="lineNum">     116 </span>            : {
<span class="lineNum">     117 </span><span class="lineNoCov">          0 :   obstack_1grow (buff-&gt;obstack, '\0');</span>
<span class="lineNum">     118 </span><span class="lineNoCov">          0 :   return (const char *) obstack_base (buff-&gt;obstack);</span>
<span class="lineNum">     119 </span>            : }
<span class="lineNum">     120 </span>            : 
<span class="lineNum">     121 </span>            : /* Append to the output buffer a string specified by its
<a name="122"><span class="lineNum">     122 </span>            :    STARTing character and LENGTH.  */</a>
<span class="lineNum">     123 </span>            : static inline void
<span class="lineNum">     124 </span><span class="lineNoCov">          0 : output_buffer_append_r (output_buffer *buff, const char *start, int length)</span>
<span class="lineNum">     125 </span>            : {
<span class="lineNum">     126 </span><span class="lineNoCov">          0 :   gcc_checking_assert (start);</span>
<span class="lineNum">     127 </span><span class="lineNoCov">          0 :   obstack_grow (buff-&gt;obstack, start, length);</span>
<span class="lineNum">     128 </span><span class="lineNoCov">          0 :   for (int i = 0; i &lt; length; i++)</span>
<span class="lineNum">     129 </span><span class="lineNoCov">          0 :     if (start[i] == '\n')</span>
<span class="lineNum">     130 </span><span class="lineNoCov">          0 :       buff-&gt;line_length = 0;</span>
<span class="lineNum">     131 </span>            :     else
<span class="lineNum">     132 </span><span class="lineNoCov">          0 :       buff-&gt;line_length++;</span>
<span class="lineNum">     133 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     134 </span>            : 
<span class="lineNum">     135 </span>            : /*  Return a pointer to the last character emitted in the
<a name="136"><span class="lineNum">     136 </span>            :     output_buffer.  A NULL pointer means no character available.  */</a>
<span class="lineNum">     137 </span>            : static inline const char *
<span class="lineNum">     138 </span><span class="lineNoCov">          0 : output_buffer_last_position_in_text (const output_buffer *buff)</span>
<span class="lineNum">     139 </span>            : {
<span class="lineNum">     140 </span><span class="lineCov">  129363652 :   const char *p = NULL;</span>
<span class="lineNum">     141 </span><span class="lineCov">  129363652 :   struct obstack *text = buff-&gt;obstack;</span>
<span class="lineNum">     142 </span>            : 
<span class="lineNum">     143 </span><span class="lineCov">  129363652 :   if (obstack_base (text) != obstack_next_free (text))</span>
<span class="lineNum">     144 </span><span class="lineCov">  113438589 :     p = ((const char *) obstack_next_free (text)) - 1;</span>
<span class="lineNum">     145 </span><span class="lineCov">  125557519 :   return p;</span>
<span class="lineNum">     146 </span>            : }
<span class="lineNum">     147 </span>            : 
<span class="lineNum">     148 </span>            : 
<span class="lineNum">     149 </span>            : /* The type of pretty-printer flags passed to clients.  */
<span class="lineNum">     150 </span>            : typedef unsigned int pp_flags;
<span class="lineNum">     151 </span>            : 
<span class="lineNum">     152 </span>            : enum pp_padding
<span class="lineNum">     153 </span>            : {
<span class="lineNum">     154 </span>            :   pp_none, pp_before, pp_after
<span class="lineNum">     155 </span>            : };
<span class="lineNum">     156 </span>            : 
<span class="lineNum">     157 </span>            : /* Structure for switching in and out of verbatim mode in a convenient
<span class="lineNum">     158 </span>            :    manner.  */
<span class="lineNum">     159 </span>            : struct pp_wrapping_mode_t
<span class="lineNum">     160 </span>            : {
<span class="lineNum">     161 </span>            :   /* Current prefixing rule.  */
<span class="lineNum">     162 </span>            :   diagnostic_prefixing_rule_t rule;
<span class="lineNum">     163 </span>            : 
<span class="lineNum">     164 </span>            :   /* The ideal upper bound of number of characters per line, as suggested
<span class="lineNum">     165 </span>            :      by front-end.  */
<span class="lineNum">     166 </span>            :   int line_cutoff;
<span class="lineNum">     167 </span>            : };
<span class="lineNum">     168 </span>            : 
<span class="lineNum">     169 </span>            : /* Maximum characters per line in automatic line wrapping mode.
<span class="lineNum">     170 </span>            :    Zero means don't wrap lines.  */
<span class="lineNum">     171 </span>            : #define pp_line_cutoff(PP)  (PP)-&gt;wrapping.line_cutoff
<span class="lineNum">     172 </span>            : 
<span class="lineNum">     173 </span>            : /* Prefixing rule used in formatting a diagnostic message.  */
<span class="lineNum">     174 </span>            : #define pp_prefixing_rule(PP)  (PP)-&gt;wrapping.rule
<span class="lineNum">     175 </span>            : 
<span class="lineNum">     176 </span>            : /* Get or set the wrapping mode as a single entity.  */
<span class="lineNum">     177 </span>            : #define pp_wrapping_mode(PP) (PP)-&gt;wrapping
<span class="lineNum">     178 </span>            : 
<span class="lineNum">     179 </span>            : /* The type of a hook that formats client-specific data onto a pretty_printer.
<span class="lineNum">     180 </span>            :    A client-supplied formatter returns true if everything goes well,
<span class="lineNum">     181 </span>            :    otherwise it returns false.  */
<span class="lineNum">     182 </span>            : typedef bool (*printer_fn) (pretty_printer *, text_info *, const char *,
<span class="lineNum">     183 </span>            :                             int, bool, bool, bool, bool *, const char **);
<span class="lineNum">     184 </span>            : 
<span class="lineNum">     185 </span>            : /* Client supplied function used to decode formats.  */
<span class="lineNum">     186 </span>            : #define pp_format_decoder(PP) (PP)-&gt;format_decoder
<span class="lineNum">     187 </span>            : 
<span class="lineNum">     188 </span>            : /* Base class for an optional client-supplied object for doing additional
<span class="lineNum">     189 </span>            :    processing between stages 2 and 3 of formatted printing.  */
<span class="lineNum">     190 </span>            : class format_postprocessor
<a name="191"><span class="lineNum">     191 </span>            : {</a>
<span class="lineNum">     192 </span>            :  public:
<span class="lineNum">     193 </span><span class="lineNoCov">          0 :   virtual ~format_postprocessor () {}</span>
<span class="lineNum">     194 </span>            :   virtual void handle (pretty_printer *) = 0;
<span class="lineNum">     195 </span>            : };
<span class="lineNum">     196 </span>            : 
<span class="lineNum">     197 </span>            : /* TRUE if a newline character needs to be added before further
<span class="lineNum">     198 </span>            :    formatting.  */
<span class="lineNum">     199 </span>            : #define pp_needs_newline(PP)  (PP)-&gt;need_newline
<span class="lineNum">     200 </span>            : 
<span class="lineNum">     201 </span>            : /* True if PRETTY-PRINTER is in line-wrapping mode.  */
<span class="lineNum">     202 </span>            : #define pp_is_wrapping_line(PP) (pp_line_cutoff (PP) &gt; 0)
<span class="lineNum">     203 </span>            : 
<span class="lineNum">     204 </span>            : /* The amount of whitespace to be emitted when starting a new line.  */
<span class="lineNum">     205 </span>            : #define pp_indentation(PP) (PP)-&gt;indent_skip
<span class="lineNum">     206 </span>            : 
<span class="lineNum">     207 </span>            : /* True if identifiers are translated to the locale character set on
<span class="lineNum">     208 </span>            :    output.  */
<span class="lineNum">     209 </span>            : #define pp_translate_identifiers(PP) (PP)-&gt;translate_identifiers
<span class="lineNum">     210 </span>            : 
<span class="lineNum">     211 </span>            : /* True if colors should be shown.  */
<span class="lineNum">     212 </span>            : #define pp_show_color(PP) (PP)-&gt;show_color
<span class="lineNum">     213 </span>            : 
<span class="lineNum">     214 </span>            : /* The data structure that contains the bare minimum required to do
<span class="lineNum">     215 </span>            :    proper pretty-printing.  Clients may derived from this structure
<span class="lineNum">     216 </span>            :    and add additional fields they need.  */
<span class="lineNum">     217 </span>            : struct pretty_printer
<span class="lineNum">     218 </span>            : {
<span class="lineNum">     219 </span>            :   /* Default construct a pretty printer with specified
<span class="lineNum">     220 </span>            :      maximum line length cut off limit.  */
<span class="lineNum">     221 </span>            :   explicit pretty_printer (int = 0);
<span class="lineNum">     222 </span>            : 
<span class="lineNum">     223 </span>            :   virtual ~pretty_printer ();
<span class="lineNum">     224 </span>            : 
<span class="lineNum">     225 </span>            :   /* Where we print external representation of ENTITY.  */
<span class="lineNum">     226 </span>            :   output_buffer *buffer;
<span class="lineNum">     227 </span>            : 
<span class="lineNum">     228 </span>            :   /* The prefix for each new line.  If non-NULL, this is &quot;owned&quot; by the
<span class="lineNum">     229 </span>            :      pretty_printer, and will eventually be free-ed.  */
<span class="lineNum">     230 </span>            :   char *prefix;
<span class="lineNum">     231 </span>            : 
<span class="lineNum">     232 </span>            :   /* Where to put whitespace around the entity being formatted.  */
<span class="lineNum">     233 </span>            :   pp_padding padding;
<span class="lineNum">     234 </span>            : 
<span class="lineNum">     235 </span>            :   /* The real upper bound of number of characters per line, taking into
<span class="lineNum">     236 </span>            :      account the case of a very very looong prefix.  */
<span class="lineNum">     237 </span>            :   int maximum_length;
<span class="lineNum">     238 </span>            : 
<span class="lineNum">     239 </span>            :   /* Indentation count.  */
<span class="lineNum">     240 </span>            :   int indent_skip;
<span class="lineNum">     241 </span>            : 
<span class="lineNum">     242 </span>            :   /* Current wrapping mode.  */
<span class="lineNum">     243 </span>            :   pp_wrapping_mode_t wrapping;
<span class="lineNum">     244 </span>            : 
<span class="lineNum">     245 </span>            :   /* If non-NULL, this function formats a TEXT into the BUFFER.  When called,
<span class="lineNum">     246 </span>            :      TEXT-&gt;format_spec points to a format code.  FORMAT_DECODER should call
<span class="lineNum">     247 </span>            :      pp_string (and related functions) to add data to the BUFFER.
<span class="lineNum">     248 </span>            :      FORMAT_DECODER can read arguments from *TEXT-&gt;args_pts using VA_ARG.
<span class="lineNum">     249 </span>            :      If the BUFFER needs additional characters from the format string, it
<span class="lineNum">     250 </span>            :      should advance the TEXT-&gt;format_spec as it goes.  When FORMAT_DECODER
<span class="lineNum">     251 </span>            :      returns, TEXT-&gt;format_spec should point to the last character processed.
<span class="lineNum">     252 </span>            :      The QUOTE and BUFFER_PTR are passed in, to allow for deferring-handling
<span class="lineNum">     253 </span>            :      of format codes (e.g. %H and %I in the C++ frontend).  */
<span class="lineNum">     254 </span>            :   printer_fn format_decoder;
<span class="lineNum">     255 </span>            : 
<span class="lineNum">     256 </span>            :   /* If non-NULL, this is called by pp_format once after all format codes
<span class="lineNum">     257 </span>            :      have been processed, to allow for client-specific postprocessing.
<span class="lineNum">     258 </span>            :      This is used by the C++ frontend for handling the %H and %I
<span class="lineNum">     259 </span>            :      format codes (which interract with each other).  */
<span class="lineNum">     260 </span>            :   format_postprocessor *m_format_postprocessor;
<span class="lineNum">     261 </span>            : 
<span class="lineNum">     262 </span>            :   /* Nonzero if current PREFIX was emitted at least once.  */
<span class="lineNum">     263 </span>            :   bool emitted_prefix;
<span class="lineNum">     264 </span>            : 
<span class="lineNum">     265 </span>            :   /* Nonzero means one should emit a newline before outputting anything.  */
<span class="lineNum">     266 </span>            :   bool need_newline;
<span class="lineNum">     267 </span>            : 
<span class="lineNum">     268 </span>            :   /* Nonzero means identifiers are translated to the locale character
<span class="lineNum">     269 </span>            :      set on output.  */
<span class="lineNum">     270 </span>            :   bool translate_identifiers;
<span class="lineNum">     271 </span>            : 
<span class="lineNum">     272 </span>            :   /* Nonzero means that text should be colorized.  */
<span class="lineNum">     273 </span>            :   bool show_color;
<span class="lineNum">     274 </span>            : };
<span class="lineNum">     275 </span>            : 
<span class="lineNum">     276 </span>            : static inline const char *
<span class="lineNum">     277 </span>            : pp_get_prefix (const pretty_printer *pp) { return pp-&gt;prefix; }
<span class="lineNum">     278 </span>            : 
<span class="lineNum">     279 </span>            : #define pp_space(PP)            pp_character (PP, ' ')
<span class="lineNum">     280 </span>            : #define pp_left_paren(PP)       pp_character (PP, '(')
<span class="lineNum">     281 </span>            : #define pp_right_paren(PP)      pp_character (PP, ')')
<span class="lineNum">     282 </span>            : #define pp_left_bracket(PP)     pp_character (PP, '[')
<span class="lineNum">     283 </span>            : #define pp_right_bracket(PP)    pp_character (PP, ']')
<span class="lineNum">     284 </span>            : #define pp_left_brace(PP)       pp_character (PP, '{')
<span class="lineNum">     285 </span>            : #define pp_right_brace(PP)      pp_character (PP, '}')
<span class="lineNum">     286 </span>            : #define pp_semicolon(PP)        pp_character (PP, ';')
<span class="lineNum">     287 </span>            : #define pp_comma(PP)            pp_character (PP, ',')
<span class="lineNum">     288 </span>            : #define pp_dot(PP)              pp_character (PP, '.')
<span class="lineNum">     289 </span>            : #define pp_colon(PP)            pp_character (PP, ':')
<span class="lineNum">     290 </span>            : #define pp_colon_colon(PP)      pp_string (PP, &quot;::&quot;)
<span class="lineNum">     291 </span>            : #define pp_arrow(PP)            pp_string (PP, &quot;-&gt;&quot;)
<span class="lineNum">     292 </span>            : #define pp_equal(PP)            pp_character (PP, '=')
<span class="lineNum">     293 </span>            : #define pp_question(PP)         pp_character (PP, '?')
<span class="lineNum">     294 </span>            : #define pp_bar(PP)              pp_character (PP, '|')
<span class="lineNum">     295 </span>            : #define pp_bar_bar(PP)          pp_string (PP, &quot;||&quot;)
<span class="lineNum">     296 </span>            : #define pp_carret(PP)           pp_character (PP, '^')
<span class="lineNum">     297 </span>            : #define pp_ampersand(PP)        pp_character (PP, '&amp;')
<span class="lineNum">     298 </span>            : #define pp_ampersand_ampersand(PP) pp_string (PP, &quot;&amp;&amp;&quot;)
<span class="lineNum">     299 </span>            : #define pp_less(PP)             pp_character (PP, '&lt;')
<span class="lineNum">     300 </span>            : #define pp_less_equal(PP)       pp_string (PP, &quot;&lt;=&quot;)
<span class="lineNum">     301 </span>            : #define pp_greater(PP)          pp_character (PP, '&gt;')
<span class="lineNum">     302 </span>            : #define pp_greater_equal(PP)    pp_string (PP, &quot;&gt;=&quot;)
<span class="lineNum">     303 </span>            : #define pp_plus(PP)             pp_character (PP, '+')
<span class="lineNum">     304 </span>            : #define pp_minus(PP)            pp_character (PP, '-')
<span class="lineNum">     305 </span>            : #define pp_star(PP)             pp_character (PP, '*')
<span class="lineNum">     306 </span>            : #define pp_slash(PP)            pp_character (PP, '/')
<span class="lineNum">     307 </span>            : #define pp_modulo(PP)           pp_character (PP, '%')
<span class="lineNum">     308 </span>            : #define pp_exclamation(PP)      pp_character (PP, '!')
<span class="lineNum">     309 </span>            : #define pp_complement(PP)       pp_character (PP, '~')
<span class="lineNum">     310 </span>            : #define pp_quote(PP)            pp_character (PP, '\'')
<span class="lineNum">     311 </span>            : #define pp_backquote(PP)        pp_character (PP, '`')
<span class="lineNum">     312 </span>            : #define pp_doublequote(PP)      pp_character (PP, '&quot;')
<span class="lineNum">     313 </span>            : #define pp_underscore(PP)       pp_character (PP, '_')
<span class="lineNum">     314 </span>            : #define pp_maybe_newline_and_indent(PP, N) \
<span class="lineNum">     315 </span>            :   if (pp_needs_newline (PP)) pp_newline_and_indent (PP, N)
<span class="lineNum">     316 </span>            : #define pp_scalar(PP, FORMAT, SCALAR)                         \
<span class="lineNum">     317 </span>            :   do                                                          \
<span class="lineNum">     318 </span>            :     {                                                         \
<span class="lineNum">     319 </span>            :       sprintf (pp_buffer (PP)-&gt;digit_buffer, FORMAT, SCALAR); \
<span class="lineNum">     320 </span>            :       pp_string (PP, pp_buffer (PP)-&gt;digit_buffer);           \
<span class="lineNum">     321 </span>            :     }                                                         \
<span class="lineNum">     322 </span>            :   while (0)
<span class="lineNum">     323 </span>            : #define pp_decimal_int(PP, I)  pp_scalar (PP, &quot;%d&quot;, I)
<span class="lineNum">     324 </span>            : #define pp_unsigned_wide_integer(PP, I) \
<span class="lineNum">     325 </span>            :    pp_scalar (PP, HOST_WIDE_INT_PRINT_UNSIGNED, (unsigned HOST_WIDE_INT) I)
<span class="lineNum">     326 </span>            : #define pp_wide_int(PP, W, SGN)                                 \
<span class="lineNum">     327 </span>            :   do                                                            \
<span class="lineNum">     328 </span>            :     {                                                           \
<span class="lineNum">     329 </span>            :       print_dec (W, pp_buffer (PP)-&gt;digit_buffer, SGN);              \
<span class="lineNum">     330 </span>            :       pp_string (PP, pp_buffer (PP)-&gt;digit_buffer);          \
<span class="lineNum">     331 </span>            :     }                                                           \
<span class="lineNum">     332 </span>            :   while (0)
<span class="lineNum">     333 </span>            : #define pp_pointer(PP, P)      pp_scalar (PP, &quot;%p&quot;, P)
<span class="lineNum">     334 </span>            : 
<span class="lineNum">     335 </span>            : #define pp_identifier(PP, ID)  pp_string (PP, (pp_translate_identifiers (PP) \
<span class="lineNum">     336 </span>            :                                           ? identifier_to_locale (ID)   \
<span class="lineNum">     337 </span>            :                                           : (ID)))
<span class="lineNum">     338 </span>            : 
<span class="lineNum">     339 </span>            : 
<span class="lineNum">     340 </span>            : #define pp_buffer(PP) (PP)-&gt;buffer
<span class="lineNum">     341 </span>            : 
<span class="lineNum">     342 </span>            : extern void pp_set_line_maximum_length (pretty_printer *, int);
<span class="lineNum">     343 </span>            : extern void pp_set_prefix (pretty_printer *, char *);
<span class="lineNum">     344 </span>            : extern char *pp_take_prefix (pretty_printer *);
<span class="lineNum">     345 </span>            : extern void pp_destroy_prefix (pretty_printer *);
<span class="lineNum">     346 </span>            : extern int pp_remaining_character_count_for_line (pretty_printer *);
<span class="lineNum">     347 </span>            : extern void pp_clear_output_area (pretty_printer *);
<span class="lineNum">     348 </span>            : extern const char *pp_formatted_text (pretty_printer *);
<span class="lineNum">     349 </span>            : extern const char *pp_last_position_in_text (const pretty_printer *);
<span class="lineNum">     350 </span>            : extern void pp_emit_prefix (pretty_printer *);
<span class="lineNum">     351 </span>            : extern void pp_append_text (pretty_printer *, const char *, const char *);
<span class="lineNum">     352 </span>            : extern void pp_newline_and_flush (pretty_printer *);
<span class="lineNum">     353 </span>            : extern void pp_newline_and_indent (pretty_printer *, int);
<span class="lineNum">     354 </span>            : extern void pp_separate_with (pretty_printer *, char);
<span class="lineNum">     355 </span>            : 
<span class="lineNum">     356 </span>            : /* If we haven't already defined a front-end-specific diagnostics
<span class="lineNum">     357 </span>            :    style, use the generic one.  */
<span class="lineNum">     358 </span>            : #ifdef GCC_DIAG_STYLE
<span class="lineNum">     359 </span>            : #define GCC_PPDIAG_STYLE GCC_DIAG_STYLE
<span class="lineNum">     360 </span>            : #else
<span class="lineNum">     361 </span>            : #define GCC_PPDIAG_STYLE __gcc_diag__
<span class="lineNum">     362 </span>            : #endif
<span class="lineNum">     363 </span>            : 
<span class="lineNum">     364 </span>            : /* This header may be included before diagnostics-core.h, hence the duplicate
<span class="lineNum">     365 </span>            :    definitions to allow for GCC-specific formats.  */
<span class="lineNum">     366 </span>            : #if GCC_VERSION &gt;= 3005
<span class="lineNum">     367 </span>            : #define ATTRIBUTE_GCC_PPDIAG(m, n) __attribute__ ((__format__ (GCC_PPDIAG_STYLE, m ,n))) ATTRIBUTE_NONNULL(m)
<span class="lineNum">     368 </span>            : #else
<span class="lineNum">     369 </span>            : #define ATTRIBUTE_GCC_PPDIAG(m, n) ATTRIBUTE_NONNULL(m)
<span class="lineNum">     370 </span>            : #endif
<span class="lineNum">     371 </span>            : extern void pp_printf (pretty_printer *, const char *, ...)
<span class="lineNum">     372 </span>            :      ATTRIBUTE_GCC_PPDIAG(2,3);
<span class="lineNum">     373 </span>            : 
<span class="lineNum">     374 </span>            : extern void pp_verbatim (pretty_printer *, const char *, ...)
<span class="lineNum">     375 </span>            :      ATTRIBUTE_GCC_PPDIAG(2,3);
<span class="lineNum">     376 </span>            : extern void pp_flush (pretty_printer *);
<span class="lineNum">     377 </span>            : extern void pp_really_flush (pretty_printer *);
<span class="lineNum">     378 </span>            : extern void pp_format (pretty_printer *, text_info *);
<span class="lineNum">     379 </span>            : extern void pp_output_formatted_text (pretty_printer *);
<span class="lineNum">     380 </span>            : extern void pp_format_verbatim (pretty_printer *, text_info *);
<span class="lineNum">     381 </span>            : 
<span class="lineNum">     382 </span>            : extern void pp_indent (pretty_printer *);
<span class="lineNum">     383 </span>            : extern void pp_newline (pretty_printer *);
<span class="lineNum">     384 </span>            : extern void pp_character (pretty_printer *, int);
<span class="lineNum">     385 </span>            : extern void pp_string (pretty_printer *, const char *);
<span class="lineNum">     386 </span>            : extern void pp_write_text_to_stream (pretty_printer *);
<span class="lineNum">     387 </span>            : extern void pp_write_text_as_dot_label_to_stream (pretty_printer *, bool);
<span class="lineNum">     388 </span>            : extern void pp_maybe_space (pretty_printer *);
<span class="lineNum">     389 </span>            : 
<span class="lineNum">     390 </span>            : extern void pp_begin_quote (pretty_printer *, bool);
<span class="lineNum">     391 </span>            : extern void pp_end_quote (pretty_printer *, bool);
<span class="lineNum">     392 </span>            : 
<span class="lineNum">     393 </span>            : /* Switch into verbatim mode and return the old mode.  */
<span class="lineNum">     394 </span>            : static inline pp_wrapping_mode_t
<span class="lineNum">     395 </span>            : pp_set_verbatim_wrapping_ (pretty_printer *pp)
<span class="lineNum">     396 </span>            : {
<span class="lineNum">     397 </span><span class="lineCov">    4301193 :   pp_wrapping_mode_t oldmode = pp_wrapping_mode (pp);</span>
<span class="lineNum">     398 </span><span class="lineCov">    4301193 :   pp_line_cutoff (pp) = 0;</span>
<span class="lineNum">     399 </span><span class="lineCov">    4301193 :   pp_prefixing_rule (pp) = DIAGNOSTICS_SHOW_PREFIX_NEVER;</span>
<span class="lineNum">     400 </span><span class="lineCov">    4301193 :   return oldmode;</span>
<span class="lineNum">     401 </span>            : }
<span class="lineNum">     402 </span>            : #define pp_set_verbatim_wrapping(PP) pp_set_verbatim_wrapping_ (PP)
<span class="lineNum">     403 </span>            : 
<span class="lineNum">     404 </span>            : extern const char *identifier_to_locale (const char *);
<span class="lineNum">     405 </span>            : extern void *(*identifier_to_locale_alloc) (size_t);
<span class="lineNum">     406 </span>            : extern void (*identifier_to_locale_free) (void *);
<span class="lineNum">     407 </span>            : 
<span class="lineNum">     408 </span>            : /* Print I to PP in decimal.  */
<a name="409"><span class="lineNum">     409 </span>            : </a>
<span class="lineNum">     410 </span>            : inline void
<span class="lineNum">     411 </span><span class="lineCov">    4207397 : pp_wide_integer (pretty_printer *pp, HOST_WIDE_INT i)</span>
<span class="lineNum">     412 </span>            : {
<span class="lineNum">     413 </span><span class="lineCov">    4207397 :   pp_scalar (pp, HOST_WIDE_INT_PRINT_DEC, i);</span>
<span class="lineNum">     414 </span><span class="lineCov">    4207397 : }</span>
<span class="lineNum">     415 </span>            : 
<span class="lineNum">     416 </span>            : template&lt;unsigned int N, typename T&gt;
<span class="lineNum">     417 </span>            : void pp_wide_integer (pretty_printer *pp, const poly_int_pod&lt;N, T&gt; &amp;);
<span class="lineNum">     418 </span>            : 
<span class="lineNum">     419 </span>            : #endif /* GCC_PRETTY_PRINT_H */
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.0</a></td></tr>
  </table>
  <br>
<h3>LCOV profile is generated on x86_64 machine using following configure options: configure --disable-bootstrap --enable-coverage=opt --enable-languages=c,c++,fortran,go,jit,lto --enable-host-shared. GCC test suite is run with the built compiler.</h3></body></html>
