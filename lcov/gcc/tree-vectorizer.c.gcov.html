<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - gcc.info - gcc/tree-vectorizer.c</title>
  <link rel="stylesheet" type="text/css" href="../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../index.html">top level</a> - <a href="index.html">gcc</a> - tree-vectorizer.c<span style="font-size: 80%;"> (source / <a href="tree-vectorizer.c.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">gcc.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">587</td>
            <td class="headerCovTableEntry">675</td>
            <td class="headerCovTableEntryMed">87.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2018-09-22 10:58:49</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">40</td>
            <td class="headerCovTableEntry">49</td>
            <td class="headerCovTableEntryMed">81.6 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /* Vectorizer</a>
<span class="lineNum">       2 </span>            :    Copyright (C) 2003-2018 Free Software Foundation, Inc.
<span class="lineNum">       3 </span>            :    Contributed by Dorit Naishlos &lt;dorit@il.ibm.com&gt;
<span class="lineNum">       4 </span>            : 
<span class="lineNum">       5 </span>            : This file is part of GCC.
<span class="lineNum">       6 </span>            : 
<span class="lineNum">       7 </span>            : GCC is free software; you can redistribute it and/or modify it under
<span class="lineNum">       8 </span>            : the terms of the GNU General Public License as published by the Free
<span class="lineNum">       9 </span>            : Software Foundation; either version 3, or (at your option) any later
<span class="lineNum">      10 </span>            : version.
<span class="lineNum">      11 </span>            : 
<span class="lineNum">      12 </span>            : GCC is distributed in the hope that it will be useful, but WITHOUT ANY
<span class="lineNum">      13 </span>            : WARRANTY; without even the implied warranty of MERCHANTABILITY or
<span class="lineNum">      14 </span>            : FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
<span class="lineNum">      15 </span>            : for more details.
<span class="lineNum">      16 </span>            : 
<span class="lineNum">      17 </span>            : You should have received a copy of the GNU General Public License
<span class="lineNum">      18 </span>            : along with GCC; see the file COPYING3.  If not see
<span class="lineNum">      19 </span>            : &lt;http://www.gnu.org/licenses/&gt;.  */
<span class="lineNum">      20 </span>            : 
<span class="lineNum">      21 </span>            : /* Loop and basic block vectorizer.
<span class="lineNum">      22 </span>            : 
<span class="lineNum">      23 </span>            :   This file contains drivers for the three vectorizers:
<span class="lineNum">      24 </span>            :   (1) loop vectorizer (inter-iteration parallelism),
<span class="lineNum">      25 </span>            :   (2) loop-aware SLP (intra-iteration parallelism) (invoked by the loop
<span class="lineNum">      26 </span>            :       vectorizer)
<span class="lineNum">      27 </span>            :   (3) BB vectorizer (out-of-loops), aka SLP
<span class="lineNum">      28 </span>            : 
<span class="lineNum">      29 </span>            :   The rest of the vectorizer's code is organized as follows:
<span class="lineNum">      30 </span>            :   - tree-vect-loop.c - loop specific parts such as reductions, etc. These are
<span class="lineNum">      31 </span>            :     used by drivers (1) and (2).
<span class="lineNum">      32 </span>            :   - tree-vect-loop-manip.c - vectorizer's loop control-flow utilities, used by
<span class="lineNum">      33 </span>            :     drivers (1) and (2).
<span class="lineNum">      34 </span>            :   - tree-vect-slp.c - BB vectorization specific analysis and transformation,
<span class="lineNum">      35 </span>            :     used by drivers (2) and (3).
<span class="lineNum">      36 </span>            :   - tree-vect-stmts.c - statements analysis and transformation (used by all).
<span class="lineNum">      37 </span>            :   - tree-vect-data-refs.c - vectorizer specific data-refs analysis and
<span class="lineNum">      38 </span>            :     manipulations (used by all).
<span class="lineNum">      39 </span>            :   - tree-vect-patterns.c - vectorizable code patterns detector (used by all)
<span class="lineNum">      40 </span>            : 
<span class="lineNum">      41 </span>            :   Here's a poor attempt at illustrating that:
<span class="lineNum">      42 </span>            : 
<span class="lineNum">      43 </span>            :      tree-vectorizer.c:
<span class="lineNum">      44 </span>            :      loop_vect()  loop_aware_slp()  slp_vect()
<span class="lineNum">      45 </span>            :           |        /           \          /
<span class="lineNum">      46 </span>            :           |       /             \        /
<span class="lineNum">      47 </span>            :           tree-vect-loop.c  tree-vect-slp.c
<span class="lineNum">      48 </span>            :                 | \      \  /      /   |
<span class="lineNum">      49 </span>            :                 |  \      \/      /    |
<span class="lineNum">      50 </span>            :                 |   \     /\     /     |
<span class="lineNum">      51 </span>            :                 |    \   /  \   /      |
<span class="lineNum">      52 </span>            :          tree-vect-stmts.c  tree-vect-data-refs.c
<span class="lineNum">      53 </span>            :                        \      /
<span class="lineNum">      54 </span>            :                     tree-vect-patterns.c
<span class="lineNum">      55 </span>            : */
<span class="lineNum">      56 </span>            : 
<span class="lineNum">      57 </span>            : #include &quot;config.h&quot;
<span class="lineNum">      58 </span>            : #include &quot;system.h&quot;
<span class="lineNum">      59 </span>            : #include &quot;coretypes.h&quot;
<span class="lineNum">      60 </span>            : #include &quot;backend.h&quot;
<span class="lineNum">      61 </span>            : #include &quot;tree.h&quot;
<span class="lineNum">      62 </span>            : #include &quot;gimple.h&quot;
<span class="lineNum">      63 </span>            : #include &quot;predict.h&quot;
<span class="lineNum">      64 </span>            : #include &quot;tree-pass.h&quot;
<span class="lineNum">      65 </span>            : #include &quot;ssa.h&quot;
<span class="lineNum">      66 </span>            : #include &quot;cgraph.h&quot;
<span class="lineNum">      67 </span>            : #include &quot;fold-const.h&quot;
<span class="lineNum">      68 </span>            : #include &quot;stor-layout.h&quot;
<span class="lineNum">      69 </span>            : #include &quot;gimple-iterator.h&quot;
<span class="lineNum">      70 </span>            : #include &quot;gimple-walk.h&quot;
<span class="lineNum">      71 </span>            : #include &quot;tree-ssa-loop-manip.h&quot;
<span class="lineNum">      72 </span>            : #include &quot;tree-ssa-loop-niter.h&quot;
<span class="lineNum">      73 </span>            : #include &quot;tree-cfg.h&quot;
<span class="lineNum">      74 </span>            : #include &quot;cfgloop.h&quot;
<span class="lineNum">      75 </span>            : #include &quot;tree-vectorizer.h&quot;
<span class="lineNum">      76 </span>            : #include &quot;tree-ssa-propagate.h&quot;
<span class="lineNum">      77 </span>            : #include &quot;dbgcnt.h&quot;
<span class="lineNum">      78 </span>            : #include &quot;tree-scalar-evolution.h&quot;
<span class="lineNum">      79 </span>            : #include &quot;stringpool.h&quot;
<span class="lineNum">      80 </span>            : #include &quot;attribs.h&quot;
<span class="lineNum">      81 </span>            : #include &quot;gimple-pretty-print.h&quot;
<span class="lineNum">      82 </span>            : 
<span class="lineNum">      83 </span>            : 
<span class="lineNum">      84 </span>            : /* Loop or bb location, with hotness information.  */
<span class="lineNum">      85 </span>            : dump_user_location_t vect_location;
<span class="lineNum">      86 </span>            : 
<span class="lineNum">      87 </span>            : /* Dump a cost entry according to args to F.  */
<a name="88"><span class="lineNum">      88 </span>            : </a>
<span class="lineNum">      89 </span>            : void
<span class="lineNum">      90 </span><span class="lineCov">      85136 : dump_stmt_cost (FILE *f, void *data, int count, enum vect_cost_for_stmt kind,</span>
<span class="lineNum">      91 </span>            :                 stmt_vec_info stmt_info, int misalign,
<span class="lineNum">      92 </span>            :                 enum vect_cost_model_location where)
<span class="lineNum">      93 </span>            : {
<span class="lineNum">      94 </span><span class="lineCov">      85136 :   fprintf (f, &quot;%p &quot;, data);</span>
<span class="lineNum">      95 </span><span class="lineCov">      85136 :   if (stmt_info)</span>
<span class="lineNum">      96 </span>            :     {
<span class="lineNum">      97 </span><span class="lineCov">      85050 :       print_gimple_expr (f, STMT_VINFO_STMT (stmt_info), 0, TDF_SLIM);</span>
<span class="lineNum">      98 </span><span class="lineCov">      85050 :       fprintf (f, &quot; &quot;);</span>
<span class="lineNum">      99 </span>            :     }
<span class="lineNum">     100 </span>            :   else
<span class="lineNum">     101 </span><span class="lineCov">         86 :     fprintf (f, &quot;&lt;unknown&gt; &quot;);</span>
<span class="lineNum">     102 </span><span class="lineCov">      85136 :   fprintf (f, &quot;%d times &quot;, count);</span>
<span class="lineNum">     103 </span><span class="lineCov">      85136 :   const char *ks = &quot;unknown&quot;;</span>
<span class="lineNum">     104 </span><span class="lineCov">      85136 :   switch (kind)</span>
<span class="lineNum">     105 </span>            :     {
<span class="lineNum">     106 </span><span class="lineCov">      19900 :     case scalar_stmt:</span>
<span class="lineNum">     107 </span><span class="lineCov">      19900 :       ks = &quot;scalar_stmt&quot;;</span>
<span class="lineNum">     108 </span><span class="lineCov">      19900 :       break;</span>
<span class="lineNum">     109 </span><span class="lineCov">      12986 :     case scalar_load:</span>
<span class="lineNum">     110 </span><span class="lineCov">      12986 :       ks = &quot;scalar_load&quot;;</span>
<span class="lineNum">     111 </span><span class="lineCov">      12986 :       break;</span>
<span class="lineNum">     112 </span><span class="lineCov">      11411 :     case scalar_store:</span>
<span class="lineNum">     113 </span><span class="lineCov">      11411 :       ks = &quot;scalar_store&quot;;</span>
<span class="lineNum">     114 </span><span class="lineCov">      11411 :       break;</span>
<span class="lineNum">     115 </span><span class="lineCov">      12810 :     case vector_stmt:</span>
<span class="lineNum">     116 </span><span class="lineCov">      12810 :       ks = &quot;vector_stmt&quot;;</span>
<span class="lineNum">     117 </span><span class="lineCov">      12810 :       break;</span>
<span class="lineNum">     118 </span><span class="lineCov">       5960 :     case vector_load:</span>
<span class="lineNum">     119 </span><span class="lineCov">       5960 :       ks = &quot;vector_load&quot;;</span>
<span class="lineNum">     120 </span><span class="lineCov">       5960 :       break;</span>
<span class="lineNum">     121 </span><span class="lineNoCov">          0 :     case vector_gather_load:</span>
<span class="lineNum">     122 </span><span class="lineNoCov">          0 :       ks = &quot;vector_gather_load&quot;;</span>
<span class="lineNum">     123 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">     124 </span><span class="lineCov">       3405 :     case unaligned_load:</span>
<span class="lineNum">     125 </span><span class="lineCov">       3405 :       ks = &quot;unaligned_load&quot;;</span>
<span class="lineNum">     126 </span><span class="lineCov">       3405 :       break;</span>
<span class="lineNum">     127 </span><span class="lineCov">       2234 :     case unaligned_store:</span>
<span class="lineNum">     128 </span><span class="lineCov">       2234 :       ks = &quot;unaligned_store&quot;;</span>
<span class="lineNum">     129 </span><span class="lineCov">       2234 :       break;</span>
<span class="lineNum">     130 </span><span class="lineCov">       4172 :     case vector_store:</span>
<span class="lineNum">     131 </span><span class="lineCov">       4172 :       ks = &quot;unaligned_store&quot;;</span>
<span class="lineNum">     132 </span><span class="lineCov">       4172 :       break;</span>
<span class="lineNum">     133 </span><span class="lineNoCov">          0 :     case vector_scatter_store:</span>
<span class="lineNum">     134 </span><span class="lineNoCov">          0 :       ks = &quot;unaligned_store&quot;;</span>
<span class="lineNum">     135 </span><span class="lineNoCov">          0 :       break;</span>
<span class="lineNum">     136 </span><span class="lineCov">       1114 :     case vec_to_scalar:</span>
<span class="lineNum">     137 </span><span class="lineCov">       1114 :       ks = &quot;unaligned_store&quot;;</span>
<span class="lineNum">     138 </span><span class="lineCov">       1114 :       break;</span>
<span class="lineNum">     139 </span><span class="lineCov">       7330 :     case scalar_to_vec:</span>
<span class="lineNum">     140 </span><span class="lineCov">       7330 :       ks = &quot;unaligned_store&quot;;</span>
<span class="lineNum">     141 </span><span class="lineCov">       7330 :       break;</span>
<span class="lineNum">     142 </span><span class="lineCov">         32 :     case cond_branch_not_taken:</span>
<span class="lineNum">     143 </span><span class="lineCov">         32 :       ks = &quot;unaligned_store&quot;;</span>
<span class="lineNum">     144 </span><span class="lineCov">         32 :       break;</span>
<span class="lineNum">     145 </span><span class="lineCov">         48 :     case cond_branch_taken:</span>
<span class="lineNum">     146 </span><span class="lineCov">         48 :       ks = &quot;unaligned_store&quot;;</span>
<span class="lineNum">     147 </span><span class="lineCov">         48 :       break;</span>
<span class="lineNum">     148 </span><span class="lineCov">        948 :     case vec_perm:</span>
<span class="lineNum">     149 </span><span class="lineCov">        948 :       ks = &quot;unaligned_store&quot;;</span>
<span class="lineNum">     150 </span><span class="lineCov">        948 :       break;</span>
<span class="lineNum">     151 </span><span class="lineCov">       2291 :     case vec_promote_demote:</span>
<span class="lineNum">     152 </span><span class="lineCov">       2291 :       ks = &quot;unaligned_store&quot;;</span>
<span class="lineNum">     153 </span><span class="lineCov">       2291 :       break;</span>
<span class="lineNum">     154 </span><span class="lineCov">        495 :     case vec_construct:</span>
<span class="lineNum">     155 </span><span class="lineCov">        495 :       ks = &quot;unaligned_store&quot;;</span>
<span class="lineNum">     156 </span><span class="lineCov">        495 :       break;</span>
<span class="lineNum">     157 </span>            :     }
<span class="lineNum">     158 </span><span class="lineCov">      85136 :   fprintf (f, &quot;%s &quot;, ks);</span>
<span class="lineNum">     159 </span><span class="lineCov">      85136 :   if (kind == unaligned_load || kind == unaligned_store)</span>
<span class="lineNum">     160 </span><span class="lineCov">       5639 :     fprintf (f, &quot;(misalign %d) &quot;, misalign);</span>
<span class="lineNum">     161 </span><span class="lineCov">      85136 :   const char *ws = &quot;unknown&quot;;</span>
<span class="lineNum">     162 </span><span class="lineCov">      85136 :   switch (where)</span>
<span class="lineNum">     163 </span>            :     {
<span class="lineNum">     164 </span><span class="lineCov">       9436 :     case vect_prologue:</span>
<span class="lineNum">     165 </span><span class="lineCov">       9436 :       ws = &quot;prologue&quot;;</span>
<span class="lineNum">     166 </span><span class="lineCov">       9436 :       break;</span>
<span class="lineNum">     167 </span><span class="lineCov">      74027 :     case vect_body:</span>
<span class="lineNum">     168 </span><span class="lineCov">      74027 :       ws = &quot;body&quot;;</span>
<span class="lineNum">     169 </span><span class="lineCov">      74027 :       break;</span>
<span class="lineNum">     170 </span><span class="lineCov">       1673 :     case vect_epilogue:</span>
<span class="lineNum">     171 </span><span class="lineCov">       1673 :       ws = &quot;epilogue&quot;;</span>
<span class="lineNum">     172 </span><span class="lineCov">       1673 :       break;</span>
<span class="lineNum">     173 </span>            :     }
<span class="lineNum">     174 </span><span class="lineCov">      85136 :   fprintf (f, &quot;in %s\n&quot;, ws);</span>
<span class="lineNum">     175 </span><span class="lineCov">      85136 : }</span>
<span class="lineNum">     176 </span>            : 
<span class="lineNum">     177 </span>            : /* For mapping simduid to vectorization factor.  */
<span class="lineNum">     178 </span>            : 
<span class="lineNum">     179 </span><span class="lineCov">       5494 : struct simduid_to_vf : free_ptr_hash&lt;simduid_to_vf&gt;</span>
<span class="lineNum">     180 </span>            : {
<span class="lineNum">     181 </span>            :   unsigned int simduid;
<span class="lineNum">     182 </span>            :   poly_uint64 vf;
<span class="lineNum">     183 </span>            : 
<span class="lineNum">     184 </span>            :   /* hash_table support.  */
<span class="lineNum">     185 </span>            :   static inline hashval_t hash (const simduid_to_vf *);
<span class="lineNum">     186 </span>            :   static inline int equal (const simduid_to_vf *, const simduid_to_vf *);
<span class="lineNum">     187 </span>            : };
<a name="188"><span class="lineNum">     188 </span>            : </a>
<span class="lineNum">     189 </span>            : inline hashval_t
<span class="lineNum">     190 </span><span class="lineNoCov">          0 : simduid_to_vf::hash (const simduid_to_vf *p)</span>
<span class="lineNum">     191 </span>            : {
<span class="lineNum">     192 </span><span class="lineCov">       1799 :   return p-&gt;simduid;</span>
<span class="lineNum">     193 </span>            : }
<a name="194"><span class="lineNum">     194 </span>            : </a>
<span class="lineNum">     195 </span>            : inline int
<span class="lineNum">     196 </span><span class="lineNoCov">          0 : simduid_to_vf::equal (const simduid_to_vf *p1, const simduid_to_vf *p2)</span>
<span class="lineNum">     197 </span>            : {
<span class="lineNum">     198 </span><span class="lineCov">       1288 :   return p1-&gt;simduid == p2-&gt;simduid;</span>
<span class="lineNum">     199 </span>            : }
<span class="lineNum">     200 </span>            : 
<span class="lineNum">     201 </span>            : /* This hash maps the OMP simd array to the corresponding simduid used
<span class="lineNum">     202 </span>            :    to index into it.  Like thus,
<span class="lineNum">     203 </span>            : 
<span class="lineNum">     204 </span>            :         _7 = GOMP_SIMD_LANE (simduid.0)
<span class="lineNum">     205 </span>            :         ...
<span class="lineNum">     206 </span>            :         ...
<span class="lineNum">     207 </span>            :         D.1737[_7] = stuff;
<span class="lineNum">     208 </span>            : 
<span class="lineNum">     209 </span>            : 
<span class="lineNum">     210 </span>            :    This hash maps from the OMP simd array (D.1737[]) to DECL_UID of
<span class="lineNum">     211 </span>            :    simduid.0.  */
<span class="lineNum">     212 </span>            : 
<span class="lineNum">     213 </span>            : struct simd_array_to_simduid : free_ptr_hash&lt;simd_array_to_simduid&gt;
<span class="lineNum">     214 </span>            : {
<span class="lineNum">     215 </span>            :   tree decl;
<span class="lineNum">     216 </span>            :   unsigned int simduid;
<span class="lineNum">     217 </span>            : 
<span class="lineNum">     218 </span>            :   /* hash_table support.  */
<span class="lineNum">     219 </span>            :   static inline hashval_t hash (const simd_array_to_simduid *);
<span class="lineNum">     220 </span>            :   static inline int equal (const simd_array_to_simduid *,
<span class="lineNum">     221 </span>            :                            const simd_array_to_simduid *);
<span class="lineNum">     222 </span>            : };
<a name="223"><span class="lineNum">     223 </span>            : </a>
<span class="lineNum">     224 </span>            : inline hashval_t
<span class="lineNum">     225 </span><span class="lineNoCov">          0 : simd_array_to_simduid::hash (const simd_array_to_simduid *p)</span>
<span class="lineNum">     226 </span>            : {
<span class="lineNum">     227 </span><span class="lineCov">       4358 :   return DECL_UID (p-&gt;decl);</span>
<span class="lineNum">     228 </span>            : }
<a name="229"><span class="lineNum">     229 </span>            : </a>
<span class="lineNum">     230 </span>            : inline int
<span class="lineNum">     231 </span><span class="lineNoCov">          0 : simd_array_to_simduid::equal (const simd_array_to_simduid *p1,</span>
<span class="lineNum">     232 </span>            :                               const simd_array_to_simduid *p2)
<span class="lineNum">     233 </span>            : {
<span class="lineNum">     234 </span><span class="lineCov">       2336 :   return p1-&gt;decl == p2-&gt;decl;</span>
<span class="lineNum">     235 </span>            : }
<span class="lineNum">     236 </span>            : 
<span class="lineNum">     237 </span>            : /* Fold IFN_GOMP_SIMD_LANE, IFN_GOMP_SIMD_VF, IFN_GOMP_SIMD_LAST_LANE,
<span class="lineNum">     238 </span>            :    into their corresponding constants and remove
<span class="lineNum">     239 </span>            :    IFN_GOMP_SIMD_ORDERED_{START,END}.  */
<a name="240"><span class="lineNum">     240 </span>            : </a>
<span class="lineNum">     241 </span>            : static void
<span class="lineNum">     242 </span><span class="lineCov">       2313 : adjust_simduid_builtins (hash_table&lt;simduid_to_vf&gt; *htab)</span>
<span class="lineNum">     243 </span>            : {
<span class="lineNum">     244 </span><span class="lineCov">       2313 :   basic_block bb;</span>
<span class="lineNum">     245 </span>            : 
<span class="lineNum">     246 </span><span class="lineCov">      29250 :   FOR_EACH_BB_FN (bb, cfun)</span>
<span class="lineNum">     247 </span>            :     {
<span class="lineNum">     248 </span><span class="lineCov">      26937 :       gimple_stmt_iterator i;</span>
<span class="lineNum">     249 </span>            : 
<span class="lineNum">     250 </span><span class="lineCov">     308276 :       for (i = gsi_start_bb (bb); !gsi_end_p (i); )</span>
<span class="lineNum">     251 </span>            :         {
<span class="lineNum">     252 </span><span class="lineCov">     127201 :           poly_uint64 vf = 1;</span>
<span class="lineNum">     253 </span><span class="lineCov">     127201 :           enum internal_fn ifn;</span>
<span class="lineNum">     254 </span><span class="lineCov">     127201 :           gimple *stmt = gsi_stmt (i);</span>
<span class="lineNum">     255 </span><span class="lineCov">     127201 :           tree t;</span>
<span class="lineNum">     256 </span><span class="lineCov">     127201 :           if (!is_gimple_call (stmt)</span>
<span class="lineNum">     257 </span><span class="lineCov">     127201 :               || !gimple_call_internal_p (stmt))</span>
<span class="lineNum">     258 </span>            :             {
<span class="lineNum">     259 </span><span class="lineCov">     124972 :               gsi_next (&amp;i);</span>
<span class="lineNum">     260 </span><span class="lineCov">     125108 :               continue;</span>
<span class="lineNum">     261 </span>            :             }
<span class="lineNum">     262 </span><span class="lineCov">       2229 :           ifn = gimple_call_internal_fn (stmt);</span>
<span class="lineNum">     263 </span><span class="lineCov">       2229 :           switch (ifn)</span>
<span class="lineNum">     264 </span>            :             {
<span class="lineNum">     265 </span><span class="lineCov">       2093 :             case IFN_GOMP_SIMD_LANE:</span>
<span class="lineNum">     266 </span><span class="lineCov">       2093 :             case IFN_GOMP_SIMD_VF:</span>
<span class="lineNum">     267 </span><span class="lineCov">       2093 :             case IFN_GOMP_SIMD_LAST_LANE:</span>
<span class="lineNum">     268 </span><span class="lineCov">       2093 :               break;</span>
<span class="lineNum">     269 </span><span class="lineCov">        134 :             case IFN_GOMP_SIMD_ORDERED_START:</span>
<span class="lineNum">     270 </span><span class="lineCov">        134 :             case IFN_GOMP_SIMD_ORDERED_END:</span>
<span class="lineNum">     271 </span><span class="lineCov">        134 :               if (integer_onep (gimple_call_arg (stmt, 0)))</span>
<span class="lineNum">     272 </span>            :                 {
<span class="lineNum">     273 </span><span class="lineCov">         20 :                   enum built_in_function bcode</span>
<span class="lineNum">     274 </span>            :                     = (ifn == IFN_GOMP_SIMD_ORDERED_START
<span class="lineNum">     275 </span><span class="lineCov">         10 :                        ? BUILT_IN_GOMP_ORDERED_START</span>
<span class="lineNum">     276 </span>            :                        : BUILT_IN_GOMP_ORDERED_END);
<span class="lineNum">     277 </span><span class="lineCov">         10 :                   gimple *g</span>
<span class="lineNum">     278 </span><span class="lineCov">         20 :                     = gimple_build_call (builtin_decl_explicit (bcode), 0);</span>
<span class="lineNum">     279 </span><span class="lineCov">         10 :                   tree vdef = gimple_vdef (stmt);</span>
<span class="lineNum">     280 </span><span class="lineCov">         10 :                   gimple_set_vdef (g, vdef);</span>
<span class="lineNum">     281 </span><span class="lineCov">         10 :                   SSA_NAME_DEF_STMT (vdef) = g;</span>
<span class="lineNum">     282 </span><span class="lineCov">         20 :                   gimple_set_vuse (g, gimple_vuse (stmt));</span>
<span class="lineNum">     283 </span><span class="lineCov">         10 :                   gsi_replace (&amp;i, g, true);</span>
<span class="lineNum">     284 </span><span class="lineCov">         10 :                   continue;</span>
<span class="lineNum">     285 </span><span class="lineCov">        124 :                 }</span>
<span class="lineNum">     286 </span><span class="lineCov">        124 :               gsi_remove (&amp;i, true);</span>
<span class="lineNum">     287 </span><span class="lineCov">        124 :               unlink_stmt_vdef (stmt);</span>
<span class="lineNum">     288 </span><span class="lineCov">        124 :               continue;</span>
<span class="lineNum">     289 </span><span class="lineCov">          2 :             default:</span>
<span class="lineNum">     290 </span><span class="lineCov">          2 :               gsi_next (&amp;i);</span>
<span class="lineNum">     291 </span><span class="lineCov">          2 :               continue;</span>
<span class="lineNum">     292 </span>            :             }
<span class="lineNum">     293 </span><span class="lineCov">       2093 :           tree arg = gimple_call_arg (stmt, 0);</span>
<span class="lineNum">     294 </span><span class="lineCov">       2093 :           gcc_assert (arg != NULL_TREE);</span>
<span class="lineNum">     295 </span><span class="lineCov">       2093 :           gcc_assert (TREE_CODE (arg) == SSA_NAME);</span>
<span class="lineNum">     296 </span><span class="lineCov">       2093 :           simduid_to_vf *p = NULL, data;</span>
<span class="lineNum">     297 </span><span class="lineCov">       2093 :           data.simduid = DECL_UID (SSA_NAME_VAR (arg));</span>
<span class="lineNum">     298 </span>            :           /* Need to nullify loop safelen field since it's value is not
<span class="lineNum">     299 </span>            :              valid after transformation.  */
<span class="lineNum">     300 </span><span class="lineCov">       2093 :           if (bb-&gt;loop_father &amp;&amp; bb-&gt;loop_father-&gt;safelen &gt; 0)</span>
<span class="lineNum">     301 </span><span class="lineCov">        581 :             bb-&gt;loop_father-&gt;safelen = 0;</span>
<span class="lineNum">     302 </span><span class="lineCov">       2093 :           if (htab)</span>
<span class="lineNum">     303 </span>            :             {
<span class="lineNum">     304 </span><span class="lineCov">        818 :               p = htab-&gt;find (&amp;data);</span>
<span class="lineNum">     305 </span><span class="lineCov">        818 :               if (p)</span>
<span class="lineNum">     306 </span><span class="lineCov">        724 :                 vf = p-&gt;vf;</span>
<span class="lineNum">     307 </span>            :             }
<span class="lineNum">     308 </span><span class="lineCov">       2093 :           switch (ifn)</span>
<span class="lineNum">     309 </span>            :             {
<span class="lineNum">     310 </span><span class="lineCov">        420 :             case IFN_GOMP_SIMD_VF:</span>
<span class="lineNum">     311 </span><span class="lineCov">        840 :               t = build_int_cst (unsigned_type_node, vf);</span>
<span class="lineNum">     312 </span><span class="lineCov">        420 :               break;</span>
<span class="lineNum">     313 </span><span class="lineCov">        900 :             case IFN_GOMP_SIMD_LANE:</span>
<span class="lineNum">     314 </span><span class="lineCov">       1800 :               t = build_int_cst (unsigned_type_node, 0);</span>
<span class="lineNum">     315 </span><span class="lineCov">        900 :               break;</span>
<span class="lineNum">     316 </span><span class="lineCov">        773 :             case IFN_GOMP_SIMD_LAST_LANE:</span>
<span class="lineNum">     317 </span><span class="lineCov">        773 :               t = gimple_call_arg (stmt, 1);</span>
<span class="lineNum">     318 </span><span class="lineCov">        773 :               break;</span>
<span class="lineNum">     319 </span><span class="lineNoCov">          0 :             default:</span>
<span class="lineNum">     320 </span><span class="lineNoCov">          0 :               gcc_unreachable ();</span>
<span class="lineNum">     321 </span>            :             }
<span class="lineNum">     322 </span><span class="lineCov">       2093 :           tree lhs = gimple_call_lhs (stmt);</span>
<span class="lineNum">     323 </span><span class="lineCov">       2093 :           if (lhs)</span>
<span class="lineNum">     324 </span><span class="lineCov">       2093 :             replace_uses_by (lhs, t);</span>
<span class="lineNum">     325 </span><span class="lineCov">       2093 :           release_defs (stmt);</span>
<span class="lineNum">     326 </span><span class="lineCov">       2093 :           gsi_remove (&amp;i, true);</span>
<span class="lineNum">     327 </span>            :         }
<span class="lineNum">     328 </span>            :     }
<span class="lineNum">     329 </span><span class="lineCov">       2313 : }</span>
<span class="lineNum">     330 </span>            : 
<span class="lineNum">     331 </span>            : /* Helper structure for note_simd_array_uses.  */
<span class="lineNum">     332 </span>            : 
<span class="lineNum">     333 </span>            : struct note_simd_array_uses_struct
<span class="lineNum">     334 </span>            : {
<span class="lineNum">     335 </span>            :   hash_table&lt;simd_array_to_simduid&gt; **htab;
<span class="lineNum">     336 </span>            :   unsigned int simduid;
<span class="lineNum">     337 </span>            : };
<span class="lineNum">     338 </span>            : 
<span class="lineNum">     339 </span>            : /* Callback for note_simd_array_uses, called through walk_gimple_op.  */
<a name="340"><span class="lineNum">     340 </span>            : </a>
<span class="lineNum">     341 </span>            : static tree
<span class="lineNum">     342 </span><span class="lineCov">      22824 : note_simd_array_uses_cb (tree *tp, int *walk_subtrees, void *data)</span>
<span class="lineNum">     343 </span>            : {
<span class="lineNum">     344 </span><span class="lineCov">      22824 :   struct walk_stmt_info *wi = (struct walk_stmt_info *) data;</span>
<span class="lineNum">     345 </span><span class="lineCov">      22824 :   struct note_simd_array_uses_struct *ns</span>
<span class="lineNum">     346 </span>            :     = (struct note_simd_array_uses_struct *) wi-&gt;info;
<span class="lineNum">     347 </span>            : 
<span class="lineNum">     348 </span><span class="lineCov">      22824 :   if (TYPE_P (*tp))</span>
<span class="lineNum">     349 </span><span class="lineNoCov">          0 :     *walk_subtrees = 0;</span>
<span class="lineNum">     350 </span><span class="lineCov">      22824 :   else if (VAR_P (*tp)</span>
<span class="lineNum">     351 </span><span class="lineCov">       4358 :            &amp;&amp; lookup_attribute (&quot;omp simd array&quot;, DECL_ATTRIBUTES (*tp))</span>
<span class="lineNum">     352 </span><span class="lineCov">      27182 :            &amp;&amp; DECL_CONTEXT (*tp) == current_function_decl)</span>
<span class="lineNum">     353 </span>            :     {
<span class="lineNum">     354 </span><span class="lineCov">       4358 :       simd_array_to_simduid data;</span>
<span class="lineNum">     355 </span><span class="lineCov">       4358 :       if (!*ns-&gt;htab)</span>
<span class="lineNum">     356 </span><span class="lineCov">        837 :         *ns-&gt;htab = new hash_table&lt;simd_array_to_simduid&gt; (15);</span>
<span class="lineNum">     357 </span><span class="lineCov">       4358 :       data.decl = *tp;</span>
<span class="lineNum">     358 </span><span class="lineCov">       4358 :       data.simduid = ns-&gt;simduid;</span>
<span class="lineNum">     359 </span><span class="lineCov">       4358 :       simd_array_to_simduid **slot = (*ns-&gt;htab)-&gt;find_slot (&amp;data, INSERT);</span>
<span class="lineNum">     360 </span><span class="lineCov">       4358 :       if (*slot == NULL)</span>
<span class="lineNum">     361 </span>            :         {
<span class="lineNum">     362 </span><span class="lineCov">       2125 :           simd_array_to_simduid *p = XNEW (simd_array_to_simduid);</span>
<span class="lineNum">     363 </span><span class="lineCov">       2125 :           *p = data;</span>
<span class="lineNum">     364 </span><span class="lineCov">       2125 :           *slot = p;</span>
<span class="lineNum">     365 </span>            :         }
<span class="lineNum">     366 </span><span class="lineCov">       2233 :       else if ((*slot)-&gt;simduid != ns-&gt;simduid)</span>
<span class="lineNum">     367 </span><span class="lineNoCov">          0 :         (*slot)-&gt;simduid = -1U;</span>
<span class="lineNum">     368 </span><span class="lineCov">       4358 :       *walk_subtrees = 0;</span>
<span class="lineNum">     369 </span>            :     }
<span class="lineNum">     370 </span><span class="lineCov">      22824 :   return NULL_TREE;</span>
<span class="lineNum">     371 </span>            : }
<span class="lineNum">     372 </span>            : 
<span class="lineNum">     373 </span>            : /* Find &quot;omp simd array&quot; temporaries and map them to corresponding
<span class="lineNum">     374 </span>            :    simduid.  */
<a name="375"><span class="lineNum">     375 </span>            : </a>
<span class="lineNum">     376 </span>            : static void
<span class="lineNum">     377 </span><span class="lineCov">       2313 : note_simd_array_uses (hash_table&lt;simd_array_to_simduid&gt; **htab)</span>
<span class="lineNum">     378 </span>            : {
<span class="lineNum">     379 </span><span class="lineCov">       2313 :   basic_block bb;</span>
<span class="lineNum">     380 </span><span class="lineCov">       2313 :   gimple_stmt_iterator gsi;</span>
<span class="lineNum">     381 </span><span class="lineCov">       2313 :   struct walk_stmt_info wi;</span>
<span class="lineNum">     382 </span><span class="lineCov">       2313 :   struct note_simd_array_uses_struct ns;</span>
<span class="lineNum">     383 </span>            : 
<span class="lineNum">     384 </span><span class="lineCov">       2313 :   memset (&amp;wi, 0, sizeof (wi));</span>
<span class="lineNum">     385 </span><span class="lineCov">       2313 :   wi.info = &amp;ns;</span>
<span class="lineNum">     386 </span><span class="lineCov">       2313 :   ns.htab = htab;</span>
<span class="lineNum">     387 </span>            : 
<span class="lineNum">     388 </span><span class="lineCov">      26091 :   FOR_EACH_BB_FN (bb, cfun)</span>
<span class="lineNum">     389 </span><span class="lineCov">     157028 :     for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&amp;gsi))</span>
<span class="lineNum">     390 </span>            :       {
<span class="lineNum">     391 </span><span class="lineCov">     109472 :         gimple *stmt = gsi_stmt (gsi);</span>
<span class="lineNum">     392 </span><span class="lineCov">     218944 :         if (!is_gimple_call (stmt) || !gimple_call_internal_p (stmt))</span>
<span class="lineNum">     393 </span><span class="lineCov">     107371 :           continue;</span>
<span class="lineNum">     394 </span><span class="lineCov">       2240 :         switch (gimple_call_internal_fn (stmt))</span>
<span class="lineNum">     395 </span>            :           {
<span class="lineNum">     396 </span><span class="lineCov">       2101 :           case IFN_GOMP_SIMD_LANE:</span>
<span class="lineNum">     397 </span><span class="lineCov">       2101 :           case IFN_GOMP_SIMD_VF:</span>
<span class="lineNum">     398 </span><span class="lineCov">       2101 :           case IFN_GOMP_SIMD_LAST_LANE:</span>
<span class="lineNum">     399 </span><span class="lineCov">       2101 :             break;</span>
<span class="lineNum">     400 </span>            :           default:
<span class="lineNum">     401 </span>            :             continue;
<span class="lineNum">     402 </span>            :           }
<span class="lineNum">     403 </span><span class="lineCov">       2101 :         tree lhs = gimple_call_lhs (stmt);</span>
<span class="lineNum">     404 </span><span class="lineCov">       2101 :         if (lhs == NULL_TREE)</span>
<span class="lineNum">     405 </span>            :           continue;
<span class="lineNum">     406 </span><span class="lineCov">       2101 :         imm_use_iterator use_iter;</span>
<span class="lineNum">     407 </span><span class="lineCov">       2101 :         gimple *use_stmt;</span>
<span class="lineNum">     408 </span><span class="lineCov">       2101 :         ns.simduid = DECL_UID (SSA_NAME_VAR (gimple_call_arg (stmt, 0)));</span>
<span class="lineNum">     409 </span><span class="lineCov">       8808 :         FOR_EACH_IMM_USE_STMT (use_stmt, use_iter, lhs)</span>
<span class="lineNum">     410 </span><span class="lineCov">      13414 :           if (!is_gimple_debug (use_stmt))</span>
<span class="lineNum">     411 </span><span class="lineCov">       6674 :             walk_gimple_op (use_stmt, note_simd_array_uses_cb, &amp;wi);</span>
<span class="lineNum">     412 </span>            :       }
<span class="lineNum">     413 </span><span class="lineCov">       2313 : }</span>
<span class="lineNum">     414 </span>            : 
<span class="lineNum">     415 </span>            : /* Shrink arrays with &quot;omp simd array&quot; attribute to the corresponding
<span class="lineNum">     416 </span>            :    vectorization factor.  */
<a name="417"><span class="lineNum">     417 </span>            : </a>
<span class="lineNum">     418 </span>            : static void
<span class="lineNum">     419 </span><span class="lineCov">        837 : shrink_simd_arrays</span>
<span class="lineNum">     420 </span>            :   (hash_table&lt;simd_array_to_simduid&gt; *simd_array_to_simduid_htab,
<span class="lineNum">     421 </span>            :    hash_table&lt;simduid_to_vf&gt; *simduid_to_vf_htab)
<span class="lineNum">     422 </span>            : {
<span class="lineNum">     423 </span><span class="lineCov">        837 :   for (hash_table&lt;simd_array_to_simduid&gt;::iterator iter</span>
<span class="lineNum">     424 </span><span class="lineCov">        837 :          = simd_array_to_simduid_htab-&gt;begin ();</span>
<span class="lineNum">     425 </span><span class="lineCov">       8049 :        iter != simd_array_to_simduid_htab-&gt;end (); ++iter)</span>
<span class="lineNum">     426 </span><span class="lineCov">       2125 :     if ((*iter)-&gt;simduid != -1U)</span>
<span class="lineNum">     427 </span>            :       {
<span class="lineNum">     428 </span><span class="lineCov">       2125 :         tree decl = (*iter)-&gt;decl;</span>
<span class="lineNum">     429 </span><span class="lineCov">       2125 :         poly_uint64 vf = 1;</span>
<span class="lineNum">     430 </span><span class="lineCov">       2125 :         if (simduid_to_vf_htab)</span>
<span class="lineNum">     431 </span>            :           {
<span class="lineNum">     432 </span><span class="lineCov">        654 :             simduid_to_vf *p = NULL, data;</span>
<span class="lineNum">     433 </span><span class="lineCov">        654 :             data.simduid = (*iter)-&gt;simduid;</span>
<span class="lineNum">     434 </span><span class="lineCov">        654 :             p = simduid_to_vf_htab-&gt;find (&amp;data);</span>
<span class="lineNum">     435 </span><span class="lineCov">        654 :             if (p)</span>
<span class="lineNum">     436 </span><span class="lineCov">        550 :               vf = p-&gt;vf;</span>
<span class="lineNum">     437 </span>            :           }
<span class="lineNum">     438 </span><span class="lineCov">       2125 :         tree atype</span>
<span class="lineNum">     439 </span><span class="lineCov">       2125 :           = build_array_type_nelts (TREE_TYPE (TREE_TYPE (decl)), vf);</span>
<span class="lineNum">     440 </span><span class="lineCov">       2125 :         TREE_TYPE (decl) = atype;</span>
<span class="lineNum">     441 </span><span class="lineCov">       2125 :         relayout_decl (decl);</span>
<span class="lineNum">     442 </span>            :       }
<span class="lineNum">     443 </span>            : 
<span class="lineNum">     444 </span><span class="lineCov">        837 :   delete simd_array_to_simduid_htab;</span>
<span class="lineNum">     445 </span><span class="lineCov">        837 : }</span>
<span class="lineNum">     446 </span>            : 
<span class="lineNum">     447 </span>            : /* Initialize the vec_info with kind KIND_IN and target cost data
<a name="448"><span class="lineNum">     448 </span>            :    TARGET_COST_DATA_IN.  */</a>
<span class="lineNum">     449 </span>            : 
<span class="lineNum">     450 </span><span class="lineCov">     697389 : vec_info::vec_info (vec_info::vec_kind kind_in, void *target_cost_data_in,</span>
<span class="lineNum">     451 </span><span class="lineCov">     697389 :                     vec_info_shared *shared_)</span>
<span class="lineNum">     452 </span>            :   : kind (kind_in),
<span class="lineNum">     453 </span>            :     shared (shared_),
<span class="lineNum">     454 </span><span class="lineCov">    1394778 :     target_cost_data (target_cost_data_in)</span>
<span class="lineNum">     455 </span>            : {
<span class="lineNum">     456 </span><span class="lineCov">     697389 :   stmt_vec_infos.create (50);</span>
<a name="457"><span class="lineNum">     457 </span><span class="lineCov">     697389 : }</span></a>
<span class="lineNum">     458 </span>            : 
<span class="lineNum">     459 </span><span class="lineCov">     732593 : vec_info::~vec_info ()</span>
<span class="lineNum">     460 </span>            : {
<span class="lineNum">     461 </span><span class="lineCov">     697389 :   slp_instance instance;</span>
<span class="lineNum">     462 </span><span class="lineCov">     697389 :   unsigned int i;</span>
<span class="lineNum">     463 </span>            : 
<span class="lineNum">     464 </span><span class="lineCov">     717018 :   FOR_EACH_VEC_ELT (slp_instances, i, instance)</span>
<span class="lineNum">     465 </span><span class="lineCov">      19629 :     vect_free_slp_instance (instance, true);</span>
<span class="lineNum">     466 </span>            : 
<span class="lineNum">     467 </span><span class="lineCov">     697389 :   destroy_cost_data (target_cost_data);</span>
<span class="lineNum">     468 </span><span class="lineCov">     697389 :   free_stmt_vec_infos ();</span>
<a name="469"><span class="lineNum">     469 </span><span class="lineCov">     697389 : }</span></a>
<span class="lineNum">     470 </span>            : 
<span class="lineNum">     471 </span><span class="lineCov">     732768 : vec_info_shared::vec_info_shared ()</span>
<span class="lineNum">     472 </span>            :   : datarefs (vNULL),
<span class="lineNum">     473 </span>            :     datarefs_copy (vNULL),
<span class="lineNum">     474 </span><span class="lineCov">    1465536 :     ddrs (vNULL)</span>
<span class="lineNum">     475 </span>            : {
<a name="476"><span class="lineNum">     476 </span><span class="lineCov">     732768 : }</span></a>
<span class="lineNum">     477 </span>            : 
<span class="lineNum">     478 </span><span class="lineCov">    2198304 : vec_info_shared::~vec_info_shared ()</span>
<span class="lineNum">     479 </span>            : {
<span class="lineNum">     480 </span><span class="lineCov">     732768 :   free_data_refs (datarefs);</span>
<span class="lineNum">     481 </span><span class="lineCov">     732768 :   free_dependence_relations (ddrs);</span>
<span class="lineNum">     482 </span><span class="lineCov">    1045052 :   datarefs_copy.release ();</span>
<span class="lineNum">     483 </span><span class="lineCov">     732768 : }</span>
<a name="484"><span class="lineNum">     484 </span>            : </a>
<span class="lineNum">     485 </span>            : void
<span class="lineNum">     486 </span><span class="lineCov">     690920 : vec_info_shared::save_datarefs ()</span>
<span class="lineNum">     487 </span>            : {
<span class="lineNum">     488 </span><span class="lineCov">     690920 :   if (!flag_checking)</span>
<span class="lineNum">     489 </span>            :     return;
<span class="lineNum">     490 </span><span class="lineCov">    1003193 :   datarefs_copy.reserve_exact (datarefs.length ());</span>
<span class="lineNum">     491 </span><span class="lineCov">    3004263 :   for (unsigned i = 0; i &lt; datarefs.length (); ++i)</span>
<span class="lineNum">     492 </span><span class="lineCov">    1000535 :     datarefs_copy.quick_push (*datarefs[i]);</span>
<span class="lineNum">     493 </span>            : }
<a name="494"><span class="lineNum">     494 </span>            : </a>
<span class="lineNum">     495 </span>            : void
<span class="lineNum">     496 </span><span class="lineCov">      30230 : vec_info_shared::check_datarefs ()</span>
<span class="lineNum">     497 </span>            : {
<span class="lineNum">     498 </span><span class="lineCov">      30230 :   if (!flag_checking)</span>
<span class="lineNum">     499 </span>            :     return;
<span class="lineNum">     500 </span><span class="lineCov">      89900 :   gcc_assert (datarefs.length () == datarefs_copy.length ());</span>
<span class="lineNum">     501 </span><span class="lineCov">     293711 :   for (unsigned i = 0; i &lt; datarefs.length (); ++i)</span>
<span class="lineNum">     502 </span><span class="lineCov">     263481 :     if (memcmp (&amp;datarefs_copy[i], datarefs[i], sizeof (data_reference)) != 0)</span>
<span class="lineNum">     503 </span><span class="lineNoCov">          0 :       gcc_unreachable ();</span>
<span class="lineNum">     504 </span>            : }
<span class="lineNum">     505 </span>            : 
<span class="lineNum">     506 </span>            : /* Record that STMT belongs to the vectorizable region.  Create and return
<span class="lineNum">     507 </span>            :    an associated stmt_vec_info.  */
<a name="508"><span class="lineNum">     508 </span>            : </a>
<span class="lineNum">     509 </span>            : stmt_vec_info
<span class="lineNum">     510 </span><span class="lineCov">    5286375 : vec_info::add_stmt (gimple *stmt)</span>
<span class="lineNum">     511 </span>            : {
<span class="lineNum">     512 </span><span class="lineCov">    5286375 :   stmt_vec_info res = new_stmt_vec_info (stmt);</span>
<span class="lineNum">     513 </span><span class="lineCov">    5286375 :   set_vinfo_for_stmt (stmt, res);</span>
<span class="lineNum">     514 </span><span class="lineCov">    5286375 :   return res;</span>
<span class="lineNum">     515 </span>            : }
<span class="lineNum">     516 </span>            : 
<span class="lineNum">     517 </span>            : /* If STMT has an associated stmt_vec_info, return that vec_info, otherwise
<span class="lineNum">     518 </span>            :    return null.  It is safe to call this function on any statement, even if
<span class="lineNum">     519 </span>            :    it might not be part of the vectorizable region.  */
<a name="520"><span class="lineNum">     520 </span>            : </a>
<span class="lineNum">     521 </span>            : stmt_vec_info
<span class="lineNum">     522 </span><span class="lineCov">   13993335 : vec_info::lookup_stmt (gimple *stmt)</span>
<span class="lineNum">     523 </span>            : {
<span class="lineNum">     524 </span><span class="lineCov">   13993335 :   unsigned int uid = gimple_uid (stmt);</span>
<span class="lineNum">     525 </span><span class="lineCov">   27938833 :   if (uid &gt; 0 &amp;&amp; uid - 1 &lt; stmt_vec_infos.length ())</span>
<span class="lineNum">     526 </span>            :     {
<span class="lineNum">     527 </span><span class="lineCov">   13884760 :       stmt_vec_info res = stmt_vec_infos[uid - 1];</span>
<span class="lineNum">     528 </span><span class="lineCov">   13884760 :       if (res &amp;&amp; res-&gt;stmt == stmt)</span>
<span class="lineNum">     529 </span><span class="lineCov">   13867792 :         return res;</span>
<span class="lineNum">     530 </span>            :     }
<span class="lineNum">     531 </span>            :   return NULL;
<span class="lineNum">     532 </span>            : }
<span class="lineNum">     533 </span>            : 
<span class="lineNum">     534 </span>            : /* If NAME is an SSA_NAME and its definition has an associated stmt_vec_info,
<span class="lineNum">     535 </span>            :    return that stmt_vec_info, otherwise return null.  It is safe to call
<span class="lineNum">     536 </span>            :    this on arbitrary operands.  */
<a name="537"><span class="lineNum">     537 </span>            : </a>
<span class="lineNum">     538 </span>            : stmt_vec_info
<span class="lineNum">     539 </span><span class="lineCov">    1128410 : vec_info::lookup_def (tree name)</span>
<span class="lineNum">     540 </span>            : {
<span class="lineNum">     541 </span><span class="lineCov">    1128410 :   if (TREE_CODE (name) == SSA_NAME</span>
<span class="lineNum">     542 </span><span class="lineCov">    1128410 :       &amp;&amp; !SSA_NAME_IS_DEFAULT_DEF (name))</span>
<span class="lineNum">     543 </span><span class="lineCov">    2158800 :     return lookup_stmt (SSA_NAME_DEF_STMT (name));</span>
<span class="lineNum">     544 </span>            :   return NULL;
<span class="lineNum">     545 </span>            : }
<span class="lineNum">     546 </span>            : 
<span class="lineNum">     547 </span>            : /* See whether there is a single non-debug statement that uses LHS and
<span class="lineNum">     548 </span>            :    whether that statement has an associated stmt_vec_info.  Return the
<span class="lineNum">     549 </span>            :    stmt_vec_info if so, otherwise return null.  */
<a name="550"><span class="lineNum">     550 </span>            : </a>
<span class="lineNum">     551 </span>            : stmt_vec_info
<span class="lineNum">     552 </span><span class="lineCov">        753 : vec_info::lookup_single_use (tree lhs)</span>
<span class="lineNum">     553 </span>            : {
<span class="lineNum">     554 </span><span class="lineCov">        753 :   use_operand_p dummy;</span>
<span class="lineNum">     555 </span><span class="lineCov">        753 :   gimple *use_stmt;</span>
<span class="lineNum">     556 </span><span class="lineCov">        753 :   if (single_imm_use (lhs, &amp;dummy, &amp;use_stmt))</span>
<span class="lineNum">     557 </span><span class="lineCov">        753 :     return lookup_stmt (use_stmt);</span>
<span class="lineNum">     558 </span>            :   return NULL;
<span class="lineNum">     559 </span>            : }
<span class="lineNum">     560 </span>            : 
<span class="lineNum">     561 </span>            : /* Return vectorization information about DR.  */
<a name="562"><span class="lineNum">     562 </span>            : </a>
<span class="lineNum">     563 </span>            : dr_vec_info *
<span class="lineNum">     564 </span><span class="lineCov">    5828113 : vec_info::lookup_dr (data_reference *dr)</span>
<span class="lineNum">     565 </span>            : {
<span class="lineNum">     566 </span><span class="lineCov">    5828113 :   stmt_vec_info stmt_info = lookup_stmt (DR_STMT (dr));</span>
<span class="lineNum">     567 </span>            :   /* DR_STMT should never refer to a stmt in a pattern replacement.  */
<span class="lineNum">     568 </span><span class="lineCov">   11656226 :   gcc_checking_assert (!is_pattern_stmt_p (stmt_info));</span>
<span class="lineNum">     569 </span><span class="lineCov">    5828113 :   return STMT_VINFO_DR_INFO (stmt_info-&gt;dr_aux.stmt);</span>
<span class="lineNum">     570 </span>            : }
<span class="lineNum">     571 </span>            : 
<span class="lineNum">     572 </span>            : /* Record that NEW_STMT_INFO now implements the same data reference
<span class="lineNum">     573 </span>            :    as OLD_STMT_INFO.  */
<a name="574"><span class="lineNum">     574 </span>            : </a>
<span class="lineNum">     575 </span>            : void
<span class="lineNum">     576 </span><span class="lineCov">       2555 : vec_info::move_dr (stmt_vec_info new_stmt_info, stmt_vec_info old_stmt_info)</span>
<span class="lineNum">     577 </span>            : {
<span class="lineNum">     578 </span><span class="lineCov">       5110 :   gcc_assert (!is_pattern_stmt_p (old_stmt_info));</span>
<span class="lineNum">     579 </span><span class="lineCov">       2555 :   STMT_VINFO_DR_INFO (old_stmt_info)-&gt;stmt = new_stmt_info;</span>
<span class="lineNum">     580 </span><span class="lineCov">       2555 :   new_stmt_info-&gt;dr_aux = old_stmt_info-&gt;dr_aux;</span>
<span class="lineNum">     581 </span><span class="lineCov">       2555 :   STMT_VINFO_DR_WRT_VEC_LOOP (new_stmt_info)</span>
<span class="lineNum">     582 </span><span class="lineCov">       2555 :     = STMT_VINFO_DR_WRT_VEC_LOOP (old_stmt_info);</span>
<span class="lineNum">     583 </span><span class="lineCov">       2555 :   STMT_VINFO_GATHER_SCATTER_P (new_stmt_info)</span>
<span class="lineNum">     584 </span><span class="lineCov">       2555 :     = STMT_VINFO_GATHER_SCATTER_P (old_stmt_info);</span>
<span class="lineNum">     585 </span><span class="lineCov">       2555 : }</span>
<span class="lineNum">     586 </span>            : 
<span class="lineNum">     587 </span>            : /* Permanently remove the statement described by STMT_INFO from the
<span class="lineNum">     588 </span>            :    function.  */
<a name="589"><span class="lineNum">     589 </span>            : </a>
<span class="lineNum">     590 </span>            : void
<span class="lineNum">     591 </span><span class="lineCov">     129977 : vec_info::remove_stmt (stmt_vec_info stmt_info)</span>
<span class="lineNum">     592 </span>            : {
<span class="lineNum">     593 </span><span class="lineCov">     129977 :   gcc_assert (!stmt_info-&gt;pattern_stmt_p);</span>
<span class="lineNum">     594 </span><span class="lineCov">     129977 :   set_vinfo_for_stmt (stmt_info-&gt;stmt, NULL);</span>
<span class="lineNum">     595 </span><span class="lineCov">     129977 :   gimple_stmt_iterator si = gsi_for_stmt (stmt_info-&gt;stmt);</span>
<span class="lineNum">     596 </span><span class="lineCov">     129977 :   unlink_stmt_vdef (stmt_info-&gt;stmt);</span>
<span class="lineNum">     597 </span><span class="lineCov">     129977 :   gsi_remove (&amp;si, true);</span>
<span class="lineNum">     598 </span><span class="lineCov">     129977 :   release_defs (stmt_info-&gt;stmt);</span>
<span class="lineNum">     599 </span><span class="lineCov">     129977 :   free_stmt_vec_info (stmt_info);</span>
<span class="lineNum">     600 </span><span class="lineCov">     129977 : }</span>
<span class="lineNum">     601 </span>            : 
<span class="lineNum">     602 </span>            : /* Replace the statement at GSI by NEW_STMT, both the vectorization
<span class="lineNum">     603 </span>            :    information and the function itself.  STMT_INFO describes the statement
<span class="lineNum">     604 </span>            :    at GSI.  */
<a name="605"><span class="lineNum">     605 </span>            : </a>
<span class="lineNum">     606 </span>            : void
<span class="lineNum">     607 </span><span class="lineCov">        544 : vec_info::replace_stmt (gimple_stmt_iterator *gsi, stmt_vec_info stmt_info,</span>
<span class="lineNum">     608 </span>            :                         gimple *new_stmt)
<span class="lineNum">     609 </span>            : {
<span class="lineNum">     610 </span><span class="lineCov">        544 :   gimple *old_stmt = stmt_info-&gt;stmt;</span>
<span class="lineNum">     611 </span><span class="lineCov">        544 :   gcc_assert (!stmt_info-&gt;pattern_stmt_p &amp;&amp; old_stmt == gsi_stmt (*gsi));</span>
<span class="lineNum">     612 </span><span class="lineCov">        544 :   set_vinfo_for_stmt (old_stmt, NULL);</span>
<span class="lineNum">     613 </span><span class="lineCov">        544 :   set_vinfo_for_stmt (new_stmt, stmt_info);</span>
<span class="lineNum">     614 </span><span class="lineCov">        544 :   stmt_info-&gt;stmt = new_stmt;</span>
<span class="lineNum">     615 </span><span class="lineCov">        544 :   gsi_replace (gsi, new_stmt, true);</span>
<span class="lineNum">     616 </span><span class="lineCov">        544 : }</span>
<span class="lineNum">     617 </span>            : 
<span class="lineNum">     618 </span>            : /* Create and initialize a new stmt_vec_info struct for STMT.  */
<a name="619"><span class="lineNum">     619 </span>            : </a>
<span class="lineNum">     620 </span>            : stmt_vec_info
<span class="lineNum">     621 </span><span class="lineCov">    5286375 : vec_info::new_stmt_vec_info (gimple *stmt)</span>
<span class="lineNum">     622 </span>            : {
<span class="lineNum">     623 </span><span class="lineCov">    5286375 :   stmt_vec_info res = XCNEW (struct _stmt_vec_info);</span>
<span class="lineNum">     624 </span><span class="lineCov">    5286375 :   res-&gt;vinfo = this;</span>
<span class="lineNum">     625 </span><span class="lineCov">    5286375 :   res-&gt;stmt = stmt;</span>
<span class="lineNum">     626 </span>            : 
<span class="lineNum">     627 </span><span class="lineCov">    5286375 :   STMT_VINFO_TYPE (res) = undef_vec_info_type;</span>
<span class="lineNum">     628 </span><span class="lineCov">    5286375 :   STMT_VINFO_RELEVANT (res) = vect_unused_in_scope;</span>
<span class="lineNum">     629 </span><span class="lineCov">    5286375 :   STMT_VINFO_VECTORIZABLE (res) = true;</span>
<span class="lineNum">     630 </span><span class="lineCov">    5286375 :   STMT_VINFO_VEC_REDUCTION_TYPE (res) = TREE_CODE_REDUCTION;</span>
<span class="lineNum">     631 </span><span class="lineCov">    5286375 :   STMT_VINFO_VEC_CONST_COND_REDUC_CODE (res) = ERROR_MARK;</span>
<span class="lineNum">     632 </span>            : 
<span class="lineNum">     633 </span><span class="lineCov">    5286375 :   if (gimple_code (stmt) == GIMPLE_PHI</span>
<span class="lineNum">     634 </span><span class="lineCov">    5286375 :       &amp;&amp; is_loop_header_bb_p (gimple_bb (stmt)))</span>
<span class="lineNum">     635 </span><span class="lineCov">     122000 :     STMT_VINFO_DEF_TYPE (res) = vect_unknown_def_type;</span>
<span class="lineNum">     636 </span>            :   else
<span class="lineNum">     637 </span><span class="lineCov">    5164375 :     STMT_VINFO_DEF_TYPE (res) = vect_internal_def;</span>
<span class="lineNum">     638 </span>            : 
<span class="lineNum">     639 </span><span class="lineCov">   10572750 :   STMT_VINFO_SAME_ALIGN_REFS (res).create (0);</span>
<span class="lineNum">     640 </span><span class="lineCov">    5286375 :   STMT_SLP_TYPE (res) = loop_vect;</span>
<span class="lineNum">     641 </span>            : 
<span class="lineNum">     642 </span>            :   /* This is really &quot;uninitialized&quot; until vect_compute_data_ref_alignment.  */
<span class="lineNum">     643 </span><span class="lineCov">    5286375 :   res-&gt;dr_aux.misalignment = DR_MISALIGNMENT_UNINITIALIZED;</span>
<span class="lineNum">     644 </span>            : 
<span class="lineNum">     645 </span><span class="lineCov">    5286375 :   return res;</span>
<span class="lineNum">     646 </span>            : }
<span class="lineNum">     647 </span>            : 
<span class="lineNum">     648 </span>            : /* Associate STMT with INFO.  */
<a name="649"><span class="lineNum">     649 </span>            : </a>
<span class="lineNum">     650 </span>            : void
<span class="lineNum">     651 </span><span class="lineCov">    5417440 : vec_info::set_vinfo_for_stmt (gimple *stmt, stmt_vec_info info)</span>
<span class="lineNum">     652 </span>            : {
<span class="lineNum">     653 </span><span class="lineCov">    5417440 :   unsigned int uid = gimple_uid (stmt);</span>
<span class="lineNum">     654 </span><span class="lineCov">    5417440 :   if (uid == 0)</span>
<span class="lineNum">     655 </span>            :     {
<span class="lineNum">     656 </span><span class="lineCov">    5286919 :       gcc_checking_assert (info);</span>
<span class="lineNum">     657 </span><span class="lineCov">    5286919 :       uid = stmt_vec_infos.length () + 1;</span>
<span class="lineNum">     658 </span><span class="lineCov">    5286919 :       gimple_set_uid (stmt, uid);</span>
<span class="lineNum">     659 </span><span class="lineCov">    5286919 :       stmt_vec_infos.safe_push (info);</span>
<span class="lineNum">     660 </span>            :     }
<span class="lineNum">     661 </span>            :   else
<span class="lineNum">     662 </span>            :     {
<span class="lineNum">     663 </span><span class="lineCov">     130521 :       gcc_checking_assert (info == NULL);</span>
<span class="lineNum">     664 </span><span class="lineCov">     130521 :       stmt_vec_infos[uid - 1] = info;</span>
<span class="lineNum">     665 </span>            :     }
<span class="lineNum">     666 </span><span class="lineCov">    5417440 : }</span>
<span class="lineNum">     667 </span>            : 
<span class="lineNum">     668 </span>            : /* Free the contents of stmt_vec_infos.  */
<a name="669"><span class="lineNum">     669 </span>            : </a>
<span class="lineNum">     670 </span>            : void
<span class="lineNum">     671 </span><span class="lineCov">     697389 : vec_info::free_stmt_vec_infos (void)</span>
<span class="lineNum">     672 </span>            : {
<span class="lineNum">     673 </span><span class="lineCov">     697389 :   unsigned int i;</span>
<span class="lineNum">     674 </span><span class="lineCov">     697389 :   stmt_vec_info info;</span>
<span class="lineNum">     675 </span><span class="lineCov">    5984308 :   FOR_EACH_VEC_ELT (stmt_vec_infos, i, info)</span>
<span class="lineNum">     676 </span><span class="lineCov">    5286919 :     if (info != NULL)</span>
<span class="lineNum">     677 </span><span class="lineCov">    5156398 :       free_stmt_vec_info (info);</span>
<span class="lineNum">     678 </span><span class="lineCov">     697389 :   stmt_vec_infos.release ();</span>
<span class="lineNum">     679 </span><span class="lineCov">     697389 : }</span>
<span class="lineNum">     680 </span>            : 
<span class="lineNum">     681 </span>            : /* Free STMT_INFO.  */
<a name="682"><span class="lineNum">     682 </span>            : </a>
<span class="lineNum">     683 </span>            : void
<span class="lineNum">     684 </span><span class="lineCov">    5286375 : vec_info::free_stmt_vec_info (stmt_vec_info stmt_info)</span>
<span class="lineNum">     685 </span>            : {
<span class="lineNum">     686 </span><span class="lineCov">    5286375 :   if (stmt_info-&gt;pattern_stmt_p)</span>
<span class="lineNum">     687 </span>            :     {
<span class="lineNum">     688 </span><span class="lineCov">      63636 :       gimple_set_bb (stmt_info-&gt;stmt, NULL);</span>
<span class="lineNum">     689 </span><span class="lineCov">      63636 :       tree lhs = gimple_get_lhs (stmt_info-&gt;stmt);</span>
<span class="lineNum">     690 </span><span class="lineCov">      63636 :       if (lhs &amp;&amp; TREE_CODE (lhs) == SSA_NAME)</span>
<span class="lineNum">     691 </span><span class="lineCov">      61084 :         release_ssa_name (lhs);</span>
<span class="lineNum">     692 </span>            :     }
<span class="lineNum">     693 </span>            : 
<span class="lineNum">     694 </span><span class="lineCov">    5286375 :   STMT_VINFO_SAME_ALIGN_REFS (stmt_info).release ();</span>
<span class="lineNum">     695 </span><span class="lineCov">    5286375 :   STMT_VINFO_SIMD_CLONE_INFO (stmt_info).release ();</span>
<span class="lineNum">     696 </span><span class="lineCov">    5286375 :   free (stmt_info);</span>
<span class="lineNum">     697 </span><span class="lineCov">    5286375 : }</span>
<span class="lineNum">     698 </span>            : 
<span class="lineNum">     699 </span>            : /* A helper function to free scev and LOOP niter information, as well as
<span class="lineNum">     700 </span>            :    clear loop constraint LOOP_C_FINITE.  */
<a name="701"><span class="lineNum">     701 </span>            : </a>
<span class="lineNum">     702 </span>            : void
<span class="lineNum">     703 </span><span class="lineCov">      24691 : vect_free_loop_info_assumptions (struct loop *loop)</span>
<span class="lineNum">     704 </span>            : {
<span class="lineNum">     705 </span><span class="lineCov">      24691 :   scev_reset_htab ();</span>
<span class="lineNum">     706 </span>            :   /* We need to explicitly reset upper bound information since they are
<span class="lineNum">     707 </span>            :      used even after free_numbers_of_iterations_estimates.  */
<span class="lineNum">     708 </span><span class="lineCov">      24691 :   loop-&gt;any_upper_bound = false;</span>
<span class="lineNum">     709 </span><span class="lineCov">      24691 :   loop-&gt;any_likely_upper_bound = false;</span>
<span class="lineNum">     710 </span><span class="lineCov">      24691 :   free_numbers_of_iterations_estimates (loop);</span>
<span class="lineNum">     711 </span><span class="lineCov">      49382 :   loop_constraint_clear (loop, LOOP_C_FINITE);</span>
<span class="lineNum">     712 </span><span class="lineCov">      24691 : }</span>
<span class="lineNum">     713 </span>            : 
<span class="lineNum">     714 </span>            : /* If LOOP has been versioned during ifcvt, return the internal call
<span class="lineNum">     715 </span>            :    guarding it.  */
<a name="716"><span class="lineNum">     716 </span>            : </a>
<span class="lineNum">     717 </span>            : static gimple *
<span class="lineNum">     718 </span><span class="lineCov">      71607 : vect_loop_vectorized_call (struct loop *loop)</span>
<span class="lineNum">     719 </span>            : {
<span class="lineNum">     720 </span><span class="lineCov">      71607 :   basic_block bb = loop_preheader_edge (loop)-&gt;src;</span>
<span class="lineNum">     721 </span><span class="lineCov">     110780 :   gimple *g;</span>
<span class="lineNum">     722 </span><span class="lineCov">     110780 :   do</span>
<span class="lineNum">     723 </span>            :     {
<span class="lineNum">     724 </span><span class="lineCov">     110780 :       g = last_stmt (bb);</span>
<span class="lineNum">     725 </span><span class="lineCov">     110780 :       if (g)</span>
<span class="lineNum">     726 </span>            :         break;
<span class="lineNum">     727 </span><span class="lineCov">      47733 :       if (!single_pred_p (bb))</span>
<span class="lineNum">     728 </span>            :         break;
<span class="lineNum">     729 </span><span class="lineCov">      39173 :       bb = single_pred (bb);</span>
<span class="lineNum">     730 </span>            :     }
<span class="lineNum">     731 </span>            :   while (1);
<span class="lineNum">     732 </span><span class="lineCov">      71607 :   if (g &amp;&amp; gimple_code (g) == GIMPLE_COND)</span>
<span class="lineNum">     733 </span>            :     {
<span class="lineNum">     734 </span><span class="lineCov">      33736 :       gimple_stmt_iterator gsi = gsi_for_stmt (g);</span>
<span class="lineNum">     735 </span><span class="lineCov">      33736 :       gsi_prev (&amp;gsi);</span>
<span class="lineNum">     736 </span><span class="lineCov">      67472 :       if (!gsi_end_p (gsi))</span>
<span class="lineNum">     737 </span>            :         {
<span class="lineNum">     738 </span><span class="lineCov">      29169 :           g = gsi_stmt (gsi);</span>
<span class="lineNum">     739 </span><span class="lineCov">      29169 :           if (gimple_call_internal_p (g, IFN_LOOP_VECTORIZED)</span>
<span class="lineNum">     740 </span><span class="lineCov">      29169 :               &amp;&amp; (tree_to_shwi (gimple_call_arg (g, 0)) == loop-&gt;num</span>
<span class="lineNum">     741 </span><span class="lineCov">       2719 :                   || tree_to_shwi (gimple_call_arg (g, 1)) == loop-&gt;num))</span>
<span class="lineNum">     742 </span><span class="lineCov">       5352 :             return g;</span>
<span class="lineNum">     743 </span>            :         }
<span class="lineNum">     744 </span>            :     }
<span class="lineNum">     745 </span>            :   return NULL;
<span class="lineNum">     746 </span>            : }
<span class="lineNum">     747 </span>            : 
<span class="lineNum">     748 </span>            : /* If LOOP has been versioned during loop distribution, return the gurading
<span class="lineNum">     749 </span>            :    internal call.  */
<a name="750"><span class="lineNum">     750 </span>            : </a>
<span class="lineNum">     751 </span>            : static gimple *
<span class="lineNum">     752 </span><span class="lineCov">      68780 : vect_loop_dist_alias_call (struct loop *loop)</span>
<span class="lineNum">     753 </span>            : {
<span class="lineNum">     754 </span><span class="lineCov">      68780 :   basic_block bb;</span>
<span class="lineNum">     755 </span><span class="lineCov">      68780 :   basic_block entry;</span>
<span class="lineNum">     756 </span><span class="lineCov">      68780 :   struct loop *outer, *orig;</span>
<span class="lineNum">     757 </span><span class="lineCov">      68780 :   gimple_stmt_iterator gsi;</span>
<span class="lineNum">     758 </span><span class="lineCov">      68780 :   gimple *g;</span>
<span class="lineNum">     759 </span>            : 
<span class="lineNum">     760 </span><span class="lineCov">      68780 :   if (loop-&gt;orig_loop_num == 0)</span>
<span class="lineNum">     761 </span>            :     return NULL;
<span class="lineNum">     762 </span>            : 
<span class="lineNum">     763 </span><span class="lineCov">         13 :   orig = get_loop (cfun, loop-&gt;orig_loop_num);</span>
<span class="lineNum">     764 </span><span class="lineCov">         13 :   if (orig == NULL)</span>
<span class="lineNum">     765 </span>            :     {
<span class="lineNum">     766 </span>            :       /* The original loop is somehow destroyed.  Clear the information.  */
<span class="lineNum">     767 </span><span class="lineNoCov">          0 :       loop-&gt;orig_loop_num = 0;</span>
<span class="lineNum">     768 </span><span class="lineNoCov">          0 :       return NULL;</span>
<span class="lineNum">     769 </span>            :     }
<span class="lineNum">     770 </span>            : 
<span class="lineNum">     771 </span><span class="lineCov">         13 :   if (loop != orig)</span>
<span class="lineNum">     772 </span><span class="lineCov">          8 :     bb = nearest_common_dominator (CDI_DOMINATORS, loop-&gt;header, orig-&gt;header);</span>
<span class="lineNum">     773 </span>            :   else
<span class="lineNum">     774 </span><span class="lineCov">          5 :     bb = loop_preheader_edge (loop)-&gt;src;</span>
<span class="lineNum">     775 </span>            : 
<span class="lineNum">     776 </span><span class="lineCov">         13 :   outer = bb-&gt;loop_father;</span>
<span class="lineNum">     777 </span><span class="lineCov">         13 :   entry = ENTRY_BLOCK_PTR_FOR_FN (cfun);</span>
<span class="lineNum">     778 </span>            : 
<span class="lineNum">     779 </span>            :   /* Look upward in dominance tree.  */
<span class="lineNum">     780 </span><span class="lineCov">         26 :   for (; bb != entry &amp;&amp; flow_bb_inside_loop_p (outer, bb);</span>
<span class="lineNum">     781 </span><span class="lineCov">         13 :        bb = get_immediate_dominator (CDI_DOMINATORS, bb))</span>
<span class="lineNum">     782 </span>            :     {
<span class="lineNum">     783 </span><span class="lineCov">         22 :       g = last_stmt (bb);</span>
<span class="lineNum">     784 </span><span class="lineCov">         22 :       if (g == NULL || gimple_code (g) != GIMPLE_COND)</span>
<span class="lineNum">     785 </span>            :         continue;
<span class="lineNum">     786 </span>            : 
<span class="lineNum">     787 </span><span class="lineCov">         17 :       gsi = gsi_for_stmt (g);</span>
<span class="lineNum">     788 </span><span class="lineCov">         17 :       gsi_prev (&amp;gsi);</span>
<span class="lineNum">     789 </span><span class="lineCov">         34 :       if (gsi_end_p (gsi))</span>
<span class="lineNum">     790 </span>            :         continue;
<span class="lineNum">     791 </span>            : 
<span class="lineNum">     792 </span><span class="lineCov">         17 :       g = gsi_stmt (gsi);</span>
<span class="lineNum">     793 </span>            :       /* The guarding internal function call must have the same distribution
<span class="lineNum">     794 </span>            :          alias id.  */
<span class="lineNum">     795 </span><span class="lineCov">         17 :       if (gimple_call_internal_p (g, IFN_LOOP_DIST_ALIAS)</span>
<span class="lineNum">     796 </span><span class="lineCov">         17 :           &amp;&amp; (tree_to_shwi (gimple_call_arg (g, 0)) == loop-&gt;orig_loop_num))</span>
<span class="lineNum">     797 </span><span class="lineCov">          9 :         return g;</span>
<span class="lineNum">     798 </span>            :     }
<span class="lineNum">     799 </span>            :   return NULL;
<span class="lineNum">     800 </span>            : }
<span class="lineNum">     801 </span>            : 
<span class="lineNum">     802 </span>            : /* Set the uids of all the statements in basic blocks inside loop
<span class="lineNum">     803 </span>            :    represented by LOOP_VINFO. LOOP_VECTORIZED_CALL is the internal
<a name="804"><span class="lineNum">     804 </span>            :    call guarding the loop which has been if converted.  */</a>
<span class="lineNum">     805 </span>            : static void
<span class="lineNum">     806 </span><span class="lineCov">        758 : set_uid_loop_bbs (loop_vec_info loop_vinfo, gimple *loop_vectorized_call)</span>
<span class="lineNum">     807 </span>            : {
<span class="lineNum">     808 </span><span class="lineCov">        758 :   tree arg = gimple_call_arg (loop_vectorized_call, 1);</span>
<span class="lineNum">     809 </span><span class="lineCov">        758 :   basic_block *bbs;</span>
<span class="lineNum">     810 </span><span class="lineCov">        758 :   unsigned int i;</span>
<span class="lineNum">     811 </span><span class="lineCov">        758 :   struct loop *scalar_loop = get_loop (cfun, tree_to_shwi (arg));</span>
<span class="lineNum">     812 </span>            : 
<span class="lineNum">     813 </span><span class="lineCov">        758 :   LOOP_VINFO_SCALAR_LOOP (loop_vinfo) = scalar_loop;</span>
<span class="lineNum">     814 </span><span class="lineCov">        758 :   gcc_checking_assert (vect_loop_vectorized_call (scalar_loop)</span>
<span class="lineNum">     815 </span>            :                        == loop_vectorized_call);
<span class="lineNum">     816 </span>            :   /* If we are going to vectorize outer loop, prevent vectorization
<span class="lineNum">     817 </span>            :      of the inner loop in the scalar loop - either the scalar loop is
<span class="lineNum">     818 </span>            :      thrown away, so it is a wasted work, or is used only for
<span class="lineNum">     819 </span>            :      a few iterations.  */
<span class="lineNum">     820 </span><span class="lineCov">        758 :   if (scalar_loop-&gt;inner)</span>
<span class="lineNum">     821 </span>            :     {
<span class="lineNum">     822 </span><span class="lineCov">         18 :       gimple *g = vect_loop_vectorized_call (scalar_loop-&gt;inner);</span>
<span class="lineNum">     823 </span><span class="lineCov">         18 :       if (g)</span>
<span class="lineNum">     824 </span>            :         {
<span class="lineNum">     825 </span><span class="lineCov">         18 :           arg = gimple_call_arg (g, 0);</span>
<span class="lineNum">     826 </span><span class="lineCov">         18 :           get_loop (cfun, tree_to_shwi (arg))-&gt;dont_vectorize = true;</span>
<span class="lineNum">     827 </span><span class="lineCov">         18 :           fold_loop_internal_call (g, boolean_false_node);</span>
<span class="lineNum">     828 </span>            :         }
<span class="lineNum">     829 </span>            :     }
<span class="lineNum">     830 </span><span class="lineCov">        758 :   bbs = get_loop_body (scalar_loop);</span>
<span class="lineNum">     831 </span><span class="lineCov">       4743 :   for (i = 0; i &lt; scalar_loop-&gt;num_nodes; i++)</span>
<span class="lineNum">     832 </span>            :     {
<span class="lineNum">     833 </span><span class="lineCov">       3985 :       basic_block bb = bbs[i];</span>
<span class="lineNum">     834 </span><span class="lineCov">       3985 :       gimple_stmt_iterator gsi;</span>
<span class="lineNum">     835 </span><span class="lineCov">      11219 :       for (gsi = gsi_start_phis (bb); !gsi_end_p (gsi); gsi_next (&amp;gsi))</span>
<span class="lineNum">     836 </span>            :         {
<span class="lineNum">     837 </span><span class="lineCov">       3617 :           gimple *phi = gsi_stmt (gsi);</span>
<span class="lineNum">     838 </span><span class="lineCov">       7234 :           gimple_set_uid (phi, 0);</span>
<span class="lineNum">     839 </span>            :         }
<span class="lineNum">     840 </span><span class="lineCov">      28890 :       for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&amp;gsi))</span>
<span class="lineNum">     841 </span>            :         {
<span class="lineNum">     842 </span><span class="lineCov">      10460 :           gimple *stmt = gsi_stmt (gsi);</span>
<span class="lineNum">     843 </span><span class="lineCov">      20920 :           gimple_set_uid (stmt, 0);</span>
<span class="lineNum">     844 </span>            :         }
<span class="lineNum">     845 </span>            :     }
<span class="lineNum">     846 </span><span class="lineCov">        758 :   free (bbs);</span>
<span class="lineNum">     847 </span><span class="lineCov">        758 : }</span>
<span class="lineNum">     848 </span>            : 
<span class="lineNum">     849 </span>            : /* Try to vectorize LOOP.  */
<a name="850"><span class="lineNum">     850 </span>            : </a>
<span class="lineNum">     851 </span>            : static unsigned
<span class="lineNum">     852 </span><span class="lineCov">      67908 : try_vectorize_loop_1 (hash_table&lt;simduid_to_vf&gt; *&amp;simduid_to_vf_htab,</span>
<span class="lineNum">     853 </span>            :                       unsigned *num_vectorized_loops,
<span class="lineNum">     854 </span>            :                       loop_p loop, loop_vec_info orig_loop_vinfo,
<span class="lineNum">     855 </span>            :                       gimple *loop_vectorized_call,
<span class="lineNum">     856 </span>            :                       gimple *loop_dist_alias_call)
<span class="lineNum">     857 </span>            : {
<span class="lineNum">     858 </span><span class="lineCov">      67908 :   unsigned ret = 0;</span>
<span class="lineNum">     859 </span><span class="lineCov">     135816 :   vec_info_shared shared;</span>
<span class="lineNum">     860 </span><span class="lineCov">      67908 :   vect_location = find_loop_location (loop);</span>
<span class="lineNum">     861 </span><span class="lineCov">     135816 :   if (LOCATION_LOCUS (vect_location.get_location_t ()) != UNKNOWN_LOCATION</span>
<span class="lineNum">     862 </span><span class="lineCov">     133661 :       &amp;&amp; dump_enabled_p ())</span>
<span class="lineNum">     863 </span><span class="lineCov">      10443 :     dump_printf (MSG_NOTE, &quot;\nAnalyzing loop at %s:%d\n&quot;,</span>
<span class="lineNum">     864 </span><span class="lineCov">      20886 :                  LOCATION_FILE (vect_location.get_location_t ()),</span>
<span class="lineNum">     865 </span><span class="lineCov">      31329 :                  LOCATION_LINE (vect_location.get_location_t ()));</span>
<span class="lineNum">     866 </span>            : 
<span class="lineNum">     867 </span><span class="lineCov">      67908 :   loop_vec_info loop_vinfo = vect_analyze_loop (loop, orig_loop_vinfo, &amp;shared);</span>
<span class="lineNum">     868 </span><span class="lineCov">      67908 :   loop-&gt;aux = loop_vinfo;</span>
<span class="lineNum">     869 </span>            : 
<span class="lineNum">     870 </span><span class="lineCov">      67908 :   if (!loop_vinfo || !LOOP_VINFO_VECTORIZABLE_P (loop_vinfo))</span>
<span class="lineNum">     871 </span>            :     {
<span class="lineNum">     872 </span>            :       /* Free existing information if loop is analyzed with some
<span class="lineNum">     873 </span>            :          assumptions.  */
<span class="lineNum">     874 </span><span class="lineCov">     104214 :       if (loop_constraint_set_p (loop, LOOP_C_FINITE))</span>
<span class="lineNum">     875 </span><span class="lineCov">        222 :         vect_free_loop_info_assumptions (loop);</span>
<span class="lineNum">     876 </span>            : 
<span class="lineNum">     877 </span>            :       /* If we applied if-conversion then try to vectorize the
<span class="lineNum">     878 </span>            :          BB of innermost loops.
<span class="lineNum">     879 </span>            :          ???  Ideally BB vectorization would learn to vectorize
<span class="lineNum">     880 </span>            :          control flow by applying if-conversion on-the-fly, the
<span class="lineNum">     881 </span>            :          following retains the if-converted loop body even when
<span class="lineNum">     882 </span>            :          only non-if-converted parts took part in BB vectorization.  */
<span class="lineNum">     883 </span><span class="lineCov">      52107 :       if (flag_tree_slp_vectorize != 0</span>
<span class="lineNum">     884 </span><span class="lineCov">      50517 :           &amp;&amp; loop_vectorized_call</span>
<span class="lineNum">     885 </span><span class="lineCov">       1790 :           &amp;&amp; ! loop-&gt;inner)</span>
<span class="lineNum">     886 </span>            :         {
<span class="lineNum">     887 </span><span class="lineCov">       1764 :           basic_block bb = loop-&gt;header;</span>
<span class="lineNum">     888 </span><span class="lineCov">       1764 :           bool has_mask_load_store = false;</span>
<span class="lineNum">     889 </span><span class="lineCov">       1764 :           for (gimple_stmt_iterator gsi = gsi_start_bb (bb);</span>
<span class="lineNum">     890 </span><span class="lineCov">      67356 :                !gsi_end_p (gsi); gsi_next (&amp;gsi))</span>
<span class="lineNum">     891 </span>            :             {
<span class="lineNum">     892 </span><span class="lineCov">      31944 :               gimple *stmt = gsi_stmt (gsi);</span>
<span class="lineNum">     893 </span><span class="lineCov">      31944 :               if (is_gimple_call (stmt)</span>
<span class="lineNum">     894 </span><span class="lineCov">         41 :                   &amp;&amp; gimple_call_internal_p (stmt)</span>
<span class="lineNum">     895 </span><span class="lineCov">      31978 :                   &amp;&amp; (gimple_call_internal_fn (stmt) == IFN_MASK_LOAD</span>
<span class="lineNum">     896 </span><span class="lineCov">         19 :                       || gimple_call_internal_fn (stmt) == IFN_MASK_STORE))</span>
<span class="lineNum">     897 </span>            :                 {
<span class="lineNum">     898 </span>            :                   has_mask_load_store = true;
<span class="lineNum">     899 </span>            :                   break;
<span class="lineNum">     900 </span>            :                 }
<span class="lineNum">     901 </span><span class="lineCov">      31914 :               gimple_set_uid (stmt, -1);</span>
<span class="lineNum">     902 </span><span class="lineCov">      63828 :               gimple_set_visited (stmt, false);</span>
<span class="lineNum">     903 </span>            :             }
<span class="lineNum">     904 </span><span class="lineCov">       1764 :           if (! has_mask_load_store &amp;&amp; vect_slp_bb (bb))</span>
<span class="lineNum">     905 </span>            :             {
<span class="lineNum">     906 </span><span class="lineCov">          4 :               dump_printf_loc (MSG_NOTE, vect_location,</span>
<span class="lineNum">     907 </span>            :                                &quot;basic block vectorized\n&quot;);
<span class="lineNum">     908 </span><span class="lineCov">          2 :               fold_loop_internal_call (loop_vectorized_call,</span>
<span class="lineNum">     909 </span>            :                                        boolean_true_node);
<span class="lineNum">     910 </span><span class="lineCov">          2 :               loop_vectorized_call = NULL;</span>
<span class="lineNum">     911 </span><span class="lineCov">          2 :               ret |= TODO_cleanup_cfg;</span>
<span class="lineNum">     912 </span>            :             }
<span class="lineNum">     913 </span>            :         }
<span class="lineNum">     914 </span>            :       /* If outer loop vectorization fails for LOOP_VECTORIZED guarded
<span class="lineNum">     915 </span>            :          loop, don't vectorize its inner loop; we'll attempt to
<span class="lineNum">     916 </span>            :          vectorize LOOP_VECTORIZED guarded inner loop of the scalar
<span class="lineNum">     917 </span>            :          loop version.  */
<span class="lineNum">     918 </span><span class="lineCov">      52107 :       if (loop_vectorized_call &amp;&amp; loop-&gt;inner)</span>
<span class="lineNum">     919 </span><span class="lineCov">         29 :         loop-&gt;inner-&gt;dont_vectorize = true;</span>
<span class="lineNum">     920 </span><span class="lineCov">      52107 :       return ret;</span>
<span class="lineNum">     921 </span>            :     }
<span class="lineNum">     922 </span>            : 
<span class="lineNum">     923 </span><span class="lineCov">      15801 :   if (!dbg_cnt (vect_loop))</span>
<span class="lineNum">     924 </span>            :     {
<span class="lineNum">     925 </span>            :       /* Free existing information if loop is analyzed with some
<span class="lineNum">     926 </span>            :          assumptions.  */
<span class="lineNum">     927 </span><span class="lineCov">          4 :       if (loop_constraint_set_p (loop, LOOP_C_FINITE))</span>
<span class="lineNum">     928 </span><span class="lineNoCov">          0 :         vect_free_loop_info_assumptions (loop);</span>
<span class="lineNum">     929 </span><span class="lineCov">          2 :       return ret;</span>
<span class="lineNum">     930 </span>            :     }
<span class="lineNum">     931 </span>            : 
<span class="lineNum">     932 </span><span class="lineCov">      15799 :   if (loop_vectorized_call)</span>
<span class="lineNum">     933 </span><span class="lineCov">        758 :     set_uid_loop_bbs (loop_vinfo, loop_vectorized_call);</span>
<span class="lineNum">     934 </span>            : 
<span class="lineNum">     935 </span><span class="lineCov">      15799 :   unsigned HOST_WIDE_INT bytes;</span>
<span class="lineNum">     936 </span><span class="lineCov">      15799 :   if (current_vector_size.is_constant (&amp;bytes))</span>
<span class="lineNum">     937 </span><span class="lineCov">      31598 :     dump_printf_loc (MSG_OPTIMIZED_LOCATIONS, vect_location,</span>
<span class="lineNum">     938 </span>            :                      &quot;loop vectorized using %wu byte vectors\n&quot;, bytes);
<span class="lineNum">     939 </span>            :   else
<span class="lineNum">     940 </span>            :     dump_printf_loc (MSG_OPTIMIZED_LOCATIONS, vect_location,
<span class="lineNum">     941 </span>            :                      &quot;loop vectorized using variable length vectors\n&quot;);
<span class="lineNum">     942 </span>            : 
<span class="lineNum">     943 </span><span class="lineCov">      15799 :   loop_p new_loop = vect_transform_loop (loop_vinfo);</span>
<span class="lineNum">     944 </span><span class="lineCov">      15799 :   (*num_vectorized_loops)++;</span>
<span class="lineNum">     945 </span>            :   /* Now that the loop has been vectorized, allow it to be unrolled
<span class="lineNum">     946 </span>            :      etc.  */
<span class="lineNum">     947 </span><span class="lineCov">      15799 :   loop-&gt;force_vectorize = false;</span>
<span class="lineNum">     948 </span>            : 
<span class="lineNum">     949 </span><span class="lineCov">      15799 :   if (loop-&gt;simduid)</span>
<span class="lineNum">     950 </span>            :     {
<span class="lineNum">     951 </span><span class="lineCov">        327 :       simduid_to_vf *simduid_to_vf_data = XNEW (simduid_to_vf);</span>
<span class="lineNum">     952 </span><span class="lineCov">        327 :       if (!simduid_to_vf_htab)</span>
<span class="lineNum">     953 </span><span class="lineCov">        219 :         simduid_to_vf_htab = new hash_table&lt;simduid_to_vf&gt; (15);</span>
<span class="lineNum">     954 </span><span class="lineCov">        327 :       simduid_to_vf_data-&gt;simduid = DECL_UID (loop-&gt;simduid);</span>
<span class="lineNum">     955 </span><span class="lineCov">        327 :       simduid_to_vf_data-&gt;vf = loop_vinfo-&gt;vectorization_factor;</span>
<span class="lineNum">     956 </span><span class="lineCov">        327 :       *simduid_to_vf_htab-&gt;find_slot (simduid_to_vf_data, INSERT)</span>
<span class="lineNum">     957 </span><span class="lineCov">        327 :           = simduid_to_vf_data;</span>
<span class="lineNum">     958 </span>            :     }
<span class="lineNum">     959 </span>            : 
<span class="lineNum">     960 </span><span class="lineCov">      15799 :   if (loop_vectorized_call)</span>
<span class="lineNum">     961 </span>            :     {
<span class="lineNum">     962 </span><span class="lineCov">        758 :       fold_loop_internal_call (loop_vectorized_call, boolean_true_node);</span>
<span class="lineNum">     963 </span><span class="lineCov">        758 :       loop_vectorized_call = NULL;</span>
<span class="lineNum">     964 </span><span class="lineCov">        758 :       ret |= TODO_cleanup_cfg;</span>
<span class="lineNum">     965 </span>            :     }
<span class="lineNum">     966 </span><span class="lineCov">      15799 :   if (loop_dist_alias_call)</span>
<span class="lineNum">     967 </span>            :     {
<span class="lineNum">     968 </span><span class="lineCov">          2 :       tree value = gimple_call_arg (loop_dist_alias_call, 1);</span>
<span class="lineNum">     969 </span><span class="lineCov">          2 :       fold_loop_internal_call (loop_dist_alias_call, value);</span>
<span class="lineNum">     970 </span><span class="lineCov">          2 :       loop_dist_alias_call = NULL;</span>
<span class="lineNum">     971 </span><span class="lineCov">          2 :       ret |= TODO_cleanup_cfg;</span>
<span class="lineNum">     972 </span>            :     }
<span class="lineNum">     973 </span>            : 
<span class="lineNum">     974 </span>            :   /* Epilogue of vectorized loop must be vectorized too.  */
<span class="lineNum">     975 </span><span class="lineCov">      15799 :   if (new_loop)</span>
<span class="lineNum">     976 </span><span class="lineCov">          6 :     ret |= try_vectorize_loop_1 (simduid_to_vf_htab, num_vectorized_loops,</span>
<span class="lineNum">     977 </span>            :                                  new_loop, loop_vinfo, NULL, NULL);
<span class="lineNum">     978 </span>            : 
<span class="lineNum">     979 </span>            :   return ret;
<span class="lineNum">     980 </span>            : }
<span class="lineNum">     981 </span>            : 
<span class="lineNum">     982 </span>            : /* Try to vectorize LOOP.  */
<a name="983"><span class="lineNum">     983 </span>            : </a>
<span class="lineNum">     984 </span>            : static unsigned
<span class="lineNum">     985 </span><span class="lineCov">      71452 : try_vectorize_loop (hash_table&lt;simduid_to_vf&gt; *&amp;simduid_to_vf_htab,</span>
<span class="lineNum">     986 </span>            :                     unsigned *num_vectorized_loops, loop_p loop)
<span class="lineNum">     987 </span>            : {
<span class="lineNum">     988 </span><span class="lineCov">      71452 :   if (!((flag_tree_loop_vectorize</span>
<span class="lineNum">     989 </span><span class="lineCov">      66469 :          &amp;&amp; optimize_loop_nest_for_speed_p (loop))</span>
<span class="lineNum">     990 </span><span class="lineCov">       6186 :         || loop-&gt;force_vectorize))</span>
<span class="lineNum">     991 </span>            :     return 0;
<span class="lineNum">     992 </span>            : 
<span class="lineNum">     993 </span><span class="lineCov">      67902 :   return try_vectorize_loop_1 (simduid_to_vf_htab, num_vectorized_loops,</span>
<span class="lineNum">     994 </span>            :                                loop, NULL,
<span class="lineNum">     995 </span>            :                                vect_loop_vectorized_call (loop),
<span class="lineNum">     996 </span><span class="lineCov">      67902 :                                vect_loop_dist_alias_call (loop));</span>
<span class="lineNum">     997 </span>            : }
<span class="lineNum">     998 </span>            : 
<span class="lineNum">     999 </span>            : 
<span class="lineNum">    1000 </span>            : /* Function vectorize_loops.
<span class="lineNum">    1001 </span>            : 
<span class="lineNum">    1002 </span>            :    Entry point to loop vectorization phase.  */
<a name="1003"><span class="lineNum">    1003 </span>            : </a>
<span class="lineNum">    1004 </span>            : unsigned
<span class="lineNum">    1005 </span><span class="lineCov">      27561 : vectorize_loops (void)</span>
<span class="lineNum">    1006 </span>            : {
<span class="lineNum">    1007 </span><span class="lineCov">      27561 :   unsigned int i;</span>
<span class="lineNum">    1008 </span><span class="lineCov">      27561 :   unsigned int num_vectorized_loops = 0;</span>
<span class="lineNum">    1009 </span><span class="lineCov">      27561 :   unsigned int vect_loops_num;</span>
<span class="lineNum">    1010 </span><span class="lineCov">      27561 :   struct loop *loop;</span>
<span class="lineNum">    1011 </span><span class="lineCov">      27561 :   hash_table&lt;simduid_to_vf&gt; *simduid_to_vf_htab = NULL;</span>
<span class="lineNum">    1012 </span><span class="lineCov">      27561 :   hash_table&lt;simd_array_to_simduid&gt; *simd_array_to_simduid_htab = NULL;</span>
<span class="lineNum">    1013 </span><span class="lineCov">      27561 :   bool any_ifcvt_loops = false;</span>
<span class="lineNum">    1014 </span><span class="lineCov">      27561 :   unsigned ret = 0;</span>
<span class="lineNum">    1015 </span>            : 
<span class="lineNum">    1016 </span><span class="lineCov">      27561 :   vect_loops_num = number_of_loops (cfun);</span>
<span class="lineNum">    1017 </span>            : 
<span class="lineNum">    1018 </span>            :   /* Bail out if there are no loops.  */
<span class="lineNum">    1019 </span><span class="lineCov">      27561 :   if (vect_loops_num &lt;= 1)</span>
<span class="lineNum">    1020 </span>            :     return 0;
<span class="lineNum">    1021 </span>            : 
<span class="lineNum">    1022 </span><span class="lineCov">      27561 :   if (cfun-&gt;has_simduid_loops)</span>
<span class="lineNum">    1023 </span><span class="lineCov">       1628 :     note_simd_array_uses (&amp;simd_array_to_simduid_htab);</span>
<span class="lineNum">    1024 </span>            : 
<span class="lineNum">    1025 </span>            :   /*  ----------- Analyze loops. -----------  */
<span class="lineNum">    1026 </span>            : 
<span class="lineNum">    1027 </span>            :   /* If some loop was duplicated, it gets bigger number
<span class="lineNum">    1028 </span>            :      than all previously defined loops.  This fact allows us to run
<span class="lineNum">    1029 </span>            :      only over initial loops skipping newly generated ones.  */
<span class="lineNum">    1030 </span><span class="lineCov">     101720 :   FOR_EACH_LOOP (loop, 0)</span>
<span class="lineNum">    1031 </span><span class="lineCov">      74159 :     if (loop-&gt;dont_vectorize)</span>
<span class="lineNum">    1032 </span>            :       {
<span class="lineNum">    1033 </span><span class="lineCov">       2755 :         any_ifcvt_loops = true;</span>
<span class="lineNum">    1034 </span>            :         /* If-conversion sometimes versions both the outer loop
<span class="lineNum">    1035 </span>            :            (for the case when outer loop vectorization might be
<span class="lineNum">    1036 </span>            :            desirable) as well as the inner loop in the scalar version
<span class="lineNum">    1037 </span>            :            of the loop.  So we have:
<span class="lineNum">    1038 </span>            :             if (LOOP_VECTORIZED (1, 3))
<span class="lineNum">    1039 </span>            :               {
<span class="lineNum">    1040 </span>            :                 loop1
<span class="lineNum">    1041 </span>            :                   loop2
<span class="lineNum">    1042 </span>            :               }
<span class="lineNum">    1043 </span>            :             else
<span class="lineNum">    1044 </span>            :               loop3 (copy of loop1)
<span class="lineNum">    1045 </span>            :                 if (LOOP_VECTORIZED (4, 5))
<span class="lineNum">    1046 </span>            :                   loop4 (copy of loop2)
<span class="lineNum">    1047 </span>            :                 else
<span class="lineNum">    1048 </span>            :                   loop5 (copy of loop4)
<span class="lineNum">    1049 </span>            :            If FOR_EACH_LOOP gives us loop3 first (which has
<span class="lineNum">    1050 </span>            :            dont_vectorize set), make sure to process loop1 before loop4;
<span class="lineNum">    1051 </span>            :            so that we can prevent vectorization of loop4 if loop1
<span class="lineNum">    1052 </span>            :            is successfully vectorized.  */
<span class="lineNum">    1053 </span><span class="lineCov">       2755 :         if (loop-&gt;inner)</span>
<span class="lineNum">    1054 </span>            :           {
<span class="lineNum">    1055 </span><span class="lineCov">         96 :             gimple *loop_vectorized_call</span>
<span class="lineNum">    1056 </span><span class="lineCov">         96 :               = vect_loop_vectorized_call (loop);</span>
<span class="lineNum">    1057 </span><span class="lineCov">         96 :             if (loop_vectorized_call</span>
<span class="lineNum">    1058 </span><span class="lineCov">         96 :                 &amp;&amp; vect_loop_vectorized_call (loop-&gt;inner))</span>
<span class="lineNum">    1059 </span>            :               {
<span class="lineNum">    1060 </span><span class="lineCov">         48 :                 tree arg = gimple_call_arg (loop_vectorized_call, 0);</span>
<span class="lineNum">    1061 </span><span class="lineCov">         48 :                 struct loop *vector_loop</span>
<span class="lineNum">    1062 </span><span class="lineCov">         48 :                   = get_loop (cfun, tree_to_shwi (arg));</span>
<span class="lineNum">    1063 </span><span class="lineCov">         48 :                 if (vector_loop &amp;&amp; vector_loop != loop)</span>
<span class="lineNum">    1064 </span>            :                   {
<span class="lineNum">    1065 </span>            :                     /* Make sure we don't vectorize it twice.  */
<span class="lineNum">    1066 </span><span class="lineCov">         48 :                     vector_loop-&gt;dont_vectorize = true;</span>
<span class="lineNum">    1067 </span><span class="lineCov">         48 :                     ret |= try_vectorize_loop (simduid_to_vf_htab,</span>
<span class="lineNum">    1068 </span>            :                                                &amp;num_vectorized_loops,
<span class="lineNum">    1069 </span>            :                                                vector_loop);
<span class="lineNum">    1070 </span>            :                   }
<span class="lineNum">    1071 </span>            :               }
<span class="lineNum">    1072 </span>            :           }
<span class="lineNum">    1073 </span>            :       }
<span class="lineNum">    1074 </span>            :     else
<span class="lineNum">    1075 </span><span class="lineCov">      71404 :       ret |= try_vectorize_loop (simduid_to_vf_htab, &amp;num_vectorized_loops,</span>
<span class="lineNum">    1076 </span>            :                                  loop);
<span class="lineNum">    1077 </span>            : 
<span class="lineNum">    1078 </span><span class="lineCov">      27561 :   vect_location = dump_user_location_t ();</span>
<span class="lineNum">    1079 </span>            : 
<span class="lineNum">    1080 </span><span class="lineCov">      27561 :   statistics_counter_event (cfun, &quot;Vectorized loops&quot;, num_vectorized_loops);</span>
<span class="lineNum">    1081 </span><span class="lineCov">      27561 :   if (dump_enabled_p ()</span>
<span class="lineNum">    1082 </span><span class="lineCov">      27561 :       || (num_vectorized_loops &gt; 0 &amp;&amp; dump_enabled_p ()))</span>
<span class="lineNum">    1083 </span><span class="lineCov">      12422 :     dump_printf_loc (MSG_NOTE, vect_location,</span>
<span class="lineNum">    1084 </span>            :                      &quot;vectorized %u loops in function.\n&quot;,
<span class="lineNum">    1085 </span>            :                      num_vectorized_loops);
<span class="lineNum">    1086 </span>            : 
<span class="lineNum">    1087 </span>            :   /*  ----------- Finalize. -----------  */
<span class="lineNum">    1088 </span>            : 
<span class="lineNum">    1089 </span><span class="lineCov">      27561 :   if (any_ifcvt_loops)</span>
<span class="lineNum">    1090 </span><span class="lineCov">      35418 :     for (i = 1; i &lt; number_of_loops (cfun); i++)</span>
<span class="lineNum">    1091 </span>            :       {
<span class="lineNum">    1092 </span><span class="lineCov">      16239 :         loop = get_loop (cfun, i);</span>
<span class="lineNum">    1093 </span><span class="lineCov">      16239 :         if (loop &amp;&amp; loop-&gt;dont_vectorize)</span>
<span class="lineNum">    1094 </span>            :           {
<span class="lineNum">    1095 </span><span class="lineCov">       2755 :             gimple *g = vect_loop_vectorized_call (loop);</span>
<span class="lineNum">    1096 </span><span class="lineCov">       2755 :             if (g)</span>
<span class="lineNum">    1097 </span>            :               {
<span class="lineNum">    1098 </span><span class="lineCov">       1877 :                 fold_loop_internal_call (g, boolean_false_node);</span>
<span class="lineNum">    1099 </span><span class="lineCov">       1877 :                 ret |= TODO_cleanup_cfg;</span>
<span class="lineNum">    1100 </span><span class="lineCov">       1877 :                 g = NULL;</span>
<span class="lineNum">    1101 </span>            :               }
<span class="lineNum">    1102 </span>            :             else
<span class="lineNum">    1103 </span><span class="lineCov">        878 :               g = vect_loop_dist_alias_call (loop);</span>
<span class="lineNum">    1104 </span>            : 
<span class="lineNum">    1105 </span><span class="lineCov">       2755 :             if (g)</span>
<span class="lineNum">    1106 </span>            :               {
<span class="lineNum">    1107 </span><span class="lineCov">          3 :                 fold_loop_internal_call (g, boolean_false_node);</span>
<span class="lineNum">    1108 </span><span class="lineCov">          3 :                 ret |= TODO_cleanup_cfg;</span>
<span class="lineNum">    1109 </span>            :               }
<span class="lineNum">    1110 </span>            :           }
<span class="lineNum">    1111 </span>            :       }
<span class="lineNum">    1112 </span>            : 
<span class="lineNum">    1113 </span><span class="lineCov">     290636 :   for (i = 1; i &lt; number_of_loops (cfun); i++)</span>
<span class="lineNum">    1114 </span>            :     {
<span class="lineNum">    1115 </span><span class="lineCov">     117757 :       loop_vec_info loop_vinfo;</span>
<span class="lineNum">    1116 </span><span class="lineCov">     117757 :       bool has_mask_store;</span>
<span class="lineNum">    1117 </span>            : 
<span class="lineNum">    1118 </span><span class="lineCov">     117757 :       loop = get_loop (cfun, i);</span>
<span class="lineNum">    1119 </span><span class="lineCov">     117757 :       if (!loop || !loop-&gt;aux)</span>
<span class="lineNum">    1120 </span>            :         continue;
<span class="lineNum">    1121 </span><span class="lineCov">      15801 :       loop_vinfo = (loop_vec_info) loop-&gt;aux;</span>
<span class="lineNum">    1122 </span><span class="lineCov">      15801 :       has_mask_store = LOOP_VINFO_HAS_MASK_STORE (loop_vinfo);</span>
<span class="lineNum">    1123 </span><span class="lineCov">      15801 :       delete loop_vinfo;</span>
<span class="lineNum">    1124 </span><span class="lineCov">      15801 :       if (has_mask_store</span>
<span class="lineNum">    1125 </span><span class="lineCov">      15801 :           &amp;&amp; targetm.vectorize.empty_mask_is_expensive (IFN_MASK_STORE))</span>
<span class="lineNum">    1126 </span><span class="lineCov">         92 :         optimize_mask_stores (loop);</span>
<span class="lineNum">    1127 </span><span class="lineCov">      15801 :       loop-&gt;aux = NULL;</span>
<span class="lineNum">    1128 </span>            :     }
<span class="lineNum">    1129 </span>            : 
<span class="lineNum">    1130 </span>            :   /* Fold IFN_GOMP_SIMD_{VF,LANE,LAST_LANE,ORDERED_{START,END}} builtins.  */
<span class="lineNum">    1131 </span><span class="lineCov">      27561 :   if (cfun-&gt;has_simduid_loops)</span>
<span class="lineNum">    1132 </span><span class="lineCov">       1628 :     adjust_simduid_builtins (simduid_to_vf_htab);</span>
<span class="lineNum">    1133 </span>            : 
<span class="lineNum">    1134 </span>            :   /* Shrink any &quot;omp array simd&quot; temporary arrays to the
<span class="lineNum">    1135 </span>            :      actual vectorization factors.  */
<span class="lineNum">    1136 </span><span class="lineCov">      27561 :   if (simd_array_to_simduid_htab)</span>
<span class="lineNum">    1137 </span><span class="lineCov">        757 :     shrink_simd_arrays (simd_array_to_simduid_htab, simduid_to_vf_htab);</span>
<span class="lineNum">    1138 </span><span class="lineCov">      27561 :   delete simduid_to_vf_htab;</span>
<span class="lineNum">    1139 </span><span class="lineCov">      27561 :   cfun-&gt;has_simduid_loops = false;</span>
<span class="lineNum">    1140 </span>            : 
<span class="lineNum">    1141 </span><span class="lineCov">      27561 :   if (num_vectorized_loops &gt; 0)</span>
<span class="lineNum">    1142 </span>            :     {
<span class="lineNum">    1143 </span>            :       /* If we vectorized any loop only virtual SSA form needs to be updated.
<span class="lineNum">    1144 </span>            :          ???  Also while we try hard to update loop-closed SSA form we fail
<span class="lineNum">    1145 </span>            :          to properly do this in some corner-cases (see PR56286).  */
<span class="lineNum">    1146 </span><span class="lineCov">      10522 :       rewrite_into_loop_closed_ssa (NULL, TODO_update_ssa_only_virtuals);</span>
<span class="lineNum">    1147 </span><span class="lineCov">      10522 :       return TODO_cleanup_cfg;</span>
<span class="lineNum">    1148 </span>            :     }
<span class="lineNum">    1149 </span>            : 
<span class="lineNum">    1150 </span>            :   return ret;
<span class="lineNum">    1151 </span>            : }
<span class="lineNum">    1152 </span>            : 
<span class="lineNum">    1153 </span>            : 
<span class="lineNum">    1154 </span>            : /* Entry point to the simduid cleanup pass.  */
<span class="lineNum">    1155 </span>            : 
<span class="lineNum">    1156 </span>            : namespace {
<span class="lineNum">    1157 </span>            : 
<span class="lineNum">    1158 </span>            : const pass_data pass_data_simduid_cleanup =
<span class="lineNum">    1159 </span>            : {
<span class="lineNum">    1160 </span>            :   GIMPLE_PASS, /* type */
<span class="lineNum">    1161 </span>            :   &quot;simduid&quot;, /* name */
<span class="lineNum">    1162 </span>            :   OPTGROUP_NONE, /* optinfo_flags */
<span class="lineNum">    1163 </span>            :   TV_NONE, /* tv_id */
<span class="lineNum">    1164 </span>            :   ( PROP_ssa | PROP_cfg ), /* properties_required */
<span class="lineNum">    1165 </span>            :   0, /* properties_provided */
<span class="lineNum">    1166 </span>            :   0, /* properties_destroyed */
<span class="lineNum">    1167 </span>            :   0, /* todo_flags_start */
<span class="lineNum">    1168 </span>            :   0, /* todo_flags_finish */
<span class="lineNum">    1169 </span>            : };
<span class="lineNum">    1170 </span>            : 
<span class="lineNum">    1171 </span>            : class pass_simduid_cleanup : public gimple_opt_pass
<span class="lineNum">    1172 </span>            : {
<span class="lineNum">    1173 </span>            : public:
<span class="lineNum">    1174 </span>            :   pass_simduid_cleanup (gcc::context *ctxt)
<span class="lineNum">    1175 </span><span class="lineCov">     681248 :     : gimple_opt_pass (pass_data_simduid_cleanup, ctxt)</span>
<span class="lineNum">    1176 </span>            :   {}
<a name="1177"><span class="lineNum">    1177 </span>            : </a>
<a name="1178"><span class="lineNum">    1178 </span>            :   /* opt_pass methods: */</a>
<span class="lineNum">    1179 </span><span class="lineCov">     170312 :   opt_pass * clone () { return new pass_simduid_cleanup (m_ctxt); }</span>
<span class="lineNum">    1180 </span><span class="lineCov">    1453844 :   virtual bool gate (function *fun) { return fun-&gt;has_simduid_loops; }</span>
<span class="lineNum">    1181 </span>            :   virtual unsigned int execute (function *);
<span class="lineNum">    1182 </span>            : 
<span class="lineNum">    1183 </span>            : }; // class pass_simduid_cleanup
<a name="1184"><span class="lineNum">    1184 </span>            : </a>
<span class="lineNum">    1185 </span>            : unsigned int
<span class="lineNum">    1186 </span><span class="lineCov">        685 : pass_simduid_cleanup::execute (function *fun)</span>
<span class="lineNum">    1187 </span>            : {
<span class="lineNum">    1188 </span><span class="lineCov">        685 :   hash_table&lt;simd_array_to_simduid&gt; *simd_array_to_simduid_htab = NULL;</span>
<span class="lineNum">    1189 </span>            : 
<span class="lineNum">    1190 </span><span class="lineCov">        685 :   note_simd_array_uses (&amp;simd_array_to_simduid_htab);</span>
<span class="lineNum">    1191 </span>            : 
<span class="lineNum">    1192 </span>            :   /* Fold IFN_GOMP_SIMD_{VF,LANE,LAST_LANE,ORDERED_{START,END}} builtins.  */
<span class="lineNum">    1193 </span><span class="lineCov">        685 :   adjust_simduid_builtins (NULL);</span>
<span class="lineNum">    1194 </span>            : 
<span class="lineNum">    1195 </span>            :   /* Shrink any &quot;omp array simd&quot; temporary arrays to the
<span class="lineNum">    1196 </span>            :      actual vectorization factors.  */
<span class="lineNum">    1197 </span><span class="lineCov">        685 :   if (simd_array_to_simduid_htab)</span>
<span class="lineNum">    1198 </span><span class="lineCov">         80 :     shrink_simd_arrays (simd_array_to_simduid_htab, NULL);</span>
<span class="lineNum">    1199 </span><span class="lineCov">        685 :   fun-&gt;has_simduid_loops = false;</span>
<span class="lineNum">    1200 </span><span class="lineCov">        685 :   return 0;</span>
<span class="lineNum">    1201 </span>            : }
<span class="lineNum">    1202 </span>            : 
<span class="lineNum">    1203 </span>            : }  // anon namespace
<a name="1204"><span class="lineNum">    1204 </span>            : </a>
<span class="lineNum">    1205 </span>            : gimple_opt_pass *
<span class="lineNum">    1206 </span><span class="lineCov">     170312 : make_pass_simduid_cleanup (gcc::context *ctxt)</span>
<span class="lineNum">    1207 </span>            : {
<span class="lineNum">    1208 </span><span class="lineCov">     170312 :   return new pass_simduid_cleanup (ctxt);</span>
<span class="lineNum">    1209 </span>            : }
<span class="lineNum">    1210 </span>            : 
<span class="lineNum">    1211 </span>            : 
<span class="lineNum">    1212 </span>            : /*  Entry point to basic block SLP phase.  */
<span class="lineNum">    1213 </span>            : 
<span class="lineNum">    1214 </span>            : namespace {
<span class="lineNum">    1215 </span>            : 
<span class="lineNum">    1216 </span>            : const pass_data pass_data_slp_vectorize =
<span class="lineNum">    1217 </span>            : {
<span class="lineNum">    1218 </span>            :   GIMPLE_PASS, /* type */
<span class="lineNum">    1219 </span>            :   &quot;slp&quot;, /* name */
<span class="lineNum">    1220 </span>            :   OPTGROUP_LOOP | OPTGROUP_VEC, /* optinfo_flags */
<span class="lineNum">    1221 </span>            :   TV_TREE_SLP_VECTORIZATION, /* tv_id */
<span class="lineNum">    1222 </span>            :   ( PROP_ssa | PROP_cfg ), /* properties_required */
<span class="lineNum">    1223 </span>            :   0, /* properties_provided */
<span class="lineNum">    1224 </span>            :   0, /* properties_destroyed */
<span class="lineNum">    1225 </span>            :   0, /* todo_flags_start */
<span class="lineNum">    1226 </span>            :   TODO_update_ssa, /* todo_flags_finish */
<span class="lineNum">    1227 </span>            : };
<span class="lineNum">    1228 </span>            : 
<span class="lineNum">    1229 </span>            : class pass_slp_vectorize : public gimple_opt_pass
<span class="lineNum">    1230 </span>            : {
<span class="lineNum">    1231 </span>            : public:
<span class="lineNum">    1232 </span>            :   pass_slp_vectorize (gcc::context *ctxt)
<span class="lineNum">    1233 </span><span class="lineCov">     681248 :     : gimple_opt_pass (pass_data_slp_vectorize, ctxt)</span>
<span class="lineNum">    1234 </span>            :   {}
<a name="1235"><span class="lineNum">    1235 </span>            : </a>
<a name="1236"><span class="lineNum">    1236 </span>            :   /* opt_pass methods: */</a>
<span class="lineNum">    1237 </span><span class="lineCov">     170312 :   opt_pass * clone () { return new pass_slp_vectorize (m_ctxt); }</span>
<span class="lineNum">    1238 </span><span class="lineCov">     620947 :   virtual bool gate (function *) { return flag_tree_slp_vectorize != 0; }</span>
<span class="lineNum">    1239 </span>            :   virtual unsigned int execute (function *);
<span class="lineNum">    1240 </span>            : 
<span class="lineNum">    1241 </span>            : }; // class pass_slp_vectorize
<a name="1242"><span class="lineNum">    1242 </span>            : </a>
<span class="lineNum">    1243 </span>            : unsigned int
<span class="lineNum">    1244 </span><span class="lineCov">      61773 : pass_slp_vectorize::execute (function *fun)</span>
<span class="lineNum">    1245 </span>            : {
<span class="lineNum">    1246 </span><span class="lineCov">      61773 :   basic_block bb;</span>
<span class="lineNum">    1247 </span>            : 
<span class="lineNum">    1248 </span><span class="lineCov">      61773 :   bool in_loop_pipeline = scev_initialized_p ();</span>
<span class="lineNum">    1249 </span><span class="lineCov">      61773 :   if (!in_loop_pipeline)</span>
<span class="lineNum">    1250 </span>            :     {
<span class="lineNum">    1251 </span><span class="lineCov">      38139 :       loop_optimizer_init (LOOPS_NORMAL);</span>
<span class="lineNum">    1252 </span><span class="lineCov">      38139 :       scev_initialize ();</span>
<span class="lineNum">    1253 </span>            :     }
<span class="lineNum">    1254 </span>            : 
<span class="lineNum">    1255 </span>            :   /* Mark all stmts as not belonging to the current region and unvisited.  */
<span class="lineNum">    1256 </span><span class="lineCov">     805545 :   FOR_EACH_BB_FN (bb, fun)</span>
<span class="lineNum">    1257 </span>            :     {
<span class="lineNum">    1258 </span><span class="lineCov">   11134026 :       for (gimple_stmt_iterator gsi = gsi_start_bb (bb); !gsi_end_p (gsi);</span>
<span class="lineNum">    1259 </span><span class="lineCov">    4451355 :            gsi_next (&amp;gsi))</span>
<span class="lineNum">    1260 </span>            :         {
<span class="lineNum">    1261 </span><span class="lineCov">    4451355 :           gimple *stmt = gsi_stmt (gsi);</span>
<span class="lineNum">    1262 </span><span class="lineCov">    4451355 :           gimple_set_uid (stmt, -1);</span>
<span class="lineNum">    1263 </span><span class="lineCov">    8902710 :           gimple_set_visited (stmt, false);</span>
<span class="lineNum">    1264 </span>            :         }
<span class="lineNum">    1265 </span>            :     }
<span class="lineNum">    1266 </span>            : 
<span class="lineNum">    1267 </span><span class="lineCov">     805545 :   FOR_EACH_BB_FN (bb, fun)</span>
<span class="lineNum">    1268 </span>            :     {
<span class="lineNum">    1269 </span><span class="lineCov">     743772 :       if (vect_slp_bb (bb))</span>
<span class="lineNum">    1270 </span><span class="lineCov">      20620 :         dump_printf_loc (MSG_NOTE, vect_location, &quot;basic block vectorized\n&quot;);</span>
<span class="lineNum">    1271 </span>            :     }
<span class="lineNum">    1272 </span>            : 
<span class="lineNum">    1273 </span><span class="lineCov">      61773 :   if (!in_loop_pipeline)</span>
<span class="lineNum">    1274 </span>            :     {
<span class="lineNum">    1275 </span><span class="lineCov">      38139 :       scev_finalize ();</span>
<span class="lineNum">    1276 </span><span class="lineCov">      38139 :       loop_optimizer_finalize ();</span>
<span class="lineNum">    1277 </span>            :     }
<span class="lineNum">    1278 </span>            : 
<span class="lineNum">    1279 </span><span class="lineCov">      61773 :   return 0;</span>
<span class="lineNum">    1280 </span>            : }
<span class="lineNum">    1281 </span>            : 
<span class="lineNum">    1282 </span>            : } // anon namespace
<a name="1283"><span class="lineNum">    1283 </span>            : </a>
<span class="lineNum">    1284 </span>            : gimple_opt_pass *
<span class="lineNum">    1285 </span><span class="lineCov">     170312 : make_pass_slp_vectorize (gcc::context *ctxt)</span>
<span class="lineNum">    1286 </span>            : {
<span class="lineNum">    1287 </span><span class="lineCov">     170312 :   return new pass_slp_vectorize (ctxt);</span>
<span class="lineNum">    1288 </span>            : }
<span class="lineNum">    1289 </span>            : 
<span class="lineNum">    1290 </span>            : 
<span class="lineNum">    1291 </span>            : /* Increase alignment of global arrays to improve vectorization potential.
<span class="lineNum">    1292 </span>            :    TODO:
<span class="lineNum">    1293 </span>            :    - Consider also structs that have an array field.
<span class="lineNum">    1294 </span>            :    - Use ipa analysis to prune arrays that can't be vectorized?
<span class="lineNum">    1295 </span>            :      This should involve global alignment analysis and in the future also
<span class="lineNum">    1296 </span>            :      array padding.  */
<span class="lineNum">    1297 </span>            : 
<span class="lineNum">    1298 </span>            : static unsigned get_vec_alignment_for_type (tree);
<span class="lineNum">    1299 </span>            : static hash_map&lt;tree, unsigned&gt; *type_align_map;
<span class="lineNum">    1300 </span>            : 
<span class="lineNum">    1301 </span>            : /* Return alignment of array's vector type corresponding to scalar type.
<a name="1302"><span class="lineNum">    1302 </span>            :    0 if no vector type exists.  */</a>
<span class="lineNum">    1303 </span>            : static unsigned
<span class="lineNum">    1304 </span><span class="lineNoCov">          0 : get_vec_alignment_for_array_type (tree type) </span>
<span class="lineNum">    1305 </span>            : {
<span class="lineNum">    1306 </span><span class="lineNoCov">          0 :   gcc_assert (TREE_CODE (type) == ARRAY_TYPE);</span>
<span class="lineNum">    1307 </span><span class="lineNoCov">          0 :   poly_uint64 array_size, vector_size;</span>
<span class="lineNum">    1308 </span>            : 
<span class="lineNum">    1309 </span><span class="lineNoCov">          0 :   tree vectype = get_vectype_for_scalar_type (strip_array_types (type));</span>
<span class="lineNum">    1310 </span><span class="lineNoCov">          0 :   if (!vectype</span>
<span class="lineNum">    1311 </span><span class="lineNoCov">          0 :       || !poly_int_tree_p (TYPE_SIZE (type), &amp;array_size)</span>
<span class="lineNum">    1312 </span><span class="lineNoCov">          0 :       || !poly_int_tree_p (TYPE_SIZE (vectype), &amp;vector_size)</span>
<span class="lineNum">    1313 </span><span class="lineNoCov">          0 :       || maybe_lt (array_size, vector_size))</span>
<span class="lineNum">    1314 </span><span class="lineNoCov">          0 :     return 0;</span>
<span class="lineNum">    1315 </span>            : 
<span class="lineNum">    1316 </span><span class="lineNoCov">          0 :   return TYPE_ALIGN (vectype);</span>
<span class="lineNum">    1317 </span>            : }
<span class="lineNum">    1318 </span>            : 
<span class="lineNum">    1319 </span>            : /* Return alignment of field having maximum alignment of vector type
<span class="lineNum">    1320 </span>            :    corresponding to it's scalar type. For now, we only consider fields whose
<span class="lineNum">    1321 </span>            :    offset is a multiple of it's vector alignment.
<a name="1322"><span class="lineNum">    1322 </span>            :    0 if no suitable field is found.  */</a>
<span class="lineNum">    1323 </span>            : static unsigned
<span class="lineNum">    1324 </span><span class="lineNoCov">          0 : get_vec_alignment_for_record_type (tree type) </span>
<span class="lineNum">    1325 </span>            : {
<span class="lineNum">    1326 </span><span class="lineNoCov">          0 :   gcc_assert (TREE_CODE (type) == RECORD_TYPE);</span>
<span class="lineNum">    1327 </span>            : 
<span class="lineNum">    1328 </span><span class="lineNoCov">          0 :   unsigned max_align = 0, alignment;</span>
<span class="lineNum">    1329 </span><span class="lineNoCov">          0 :   HOST_WIDE_INT offset;</span>
<span class="lineNum">    1330 </span><span class="lineNoCov">          0 :   tree offset_tree;</span>
<span class="lineNum">    1331 </span>            : 
<span class="lineNum">    1332 </span><span class="lineNoCov">          0 :   if (TYPE_PACKED (type))</span>
<span class="lineNum">    1333 </span>            :     return 0;
<span class="lineNum">    1334 </span>            : 
<span class="lineNum">    1335 </span><span class="lineNoCov">          0 :   unsigned *slot = type_align_map-&gt;get (type);</span>
<span class="lineNum">    1336 </span><span class="lineNoCov">          0 :   if (slot)</span>
<span class="lineNum">    1337 </span><span class="lineNoCov">          0 :     return *slot;</span>
<span class="lineNum">    1338 </span>            : 
<span class="lineNum">    1339 </span><span class="lineNoCov">          0 :   for (tree field = first_field (type);</span>
<span class="lineNum">    1340 </span><span class="lineNoCov">          0 :        field != NULL_TREE;</span>
<span class="lineNum">    1341 </span><span class="lineNoCov">          0 :        field = DECL_CHAIN (field))</span>
<span class="lineNum">    1342 </span>            :     {
<span class="lineNum">    1343 </span>            :       /* Skip if not FIELD_DECL or if alignment is set by user.  */ 
<span class="lineNum">    1344 </span><span class="lineNoCov">          0 :       if (TREE_CODE (field) != FIELD_DECL</span>
<span class="lineNum">    1345 </span><span class="lineNoCov">          0 :           || DECL_USER_ALIGN (field)</span>
<span class="lineNum">    1346 </span><span class="lineNoCov">          0 :           || DECL_ARTIFICIAL (field))</span>
<span class="lineNum">    1347 </span>            :         continue;
<span class="lineNum">    1348 </span>            : 
<span class="lineNum">    1349 </span>            :       /* We don't need to process the type further if offset is variable,
<span class="lineNum">    1350 </span>            :          since the offsets of remaining members will also be variable.  */
<span class="lineNum">    1351 </span><span class="lineNoCov">          0 :       if (TREE_CODE (DECL_FIELD_OFFSET (field)) != INTEGER_CST</span>
<span class="lineNum">    1352 </span><span class="lineNoCov">          0 :           || TREE_CODE (DECL_FIELD_BIT_OFFSET (field)) != INTEGER_CST)</span>
<span class="lineNum">    1353 </span>            :         break;
<span class="lineNum">    1354 </span>            : 
<span class="lineNum">    1355 </span>            :       /* Similarly stop processing the type if offset_tree
<span class="lineNum">    1356 </span>            :          does not fit in unsigned HOST_WIDE_INT.  */
<span class="lineNum">    1357 </span><span class="lineNoCov">          0 :       offset_tree = bit_position (field);</span>
<span class="lineNum">    1358 </span><span class="lineNoCov">          0 :       if (!tree_fits_uhwi_p (offset_tree))</span>
<span class="lineNum">    1359 </span>            :         break;
<span class="lineNum">    1360 </span>            : 
<span class="lineNum">    1361 </span><span class="lineNoCov">          0 :       offset = tree_to_uhwi (offset_tree); </span>
<span class="lineNum">    1362 </span><span class="lineNoCov">          0 :       alignment = get_vec_alignment_for_type (TREE_TYPE (field));</span>
<span class="lineNum">    1363 </span>            : 
<span class="lineNum">    1364 </span>            :       /* Get maximum alignment of vectorized field/array among those members
<span class="lineNum">    1365 </span>            :          whose offset is multiple of the vector alignment.  */ 
<span class="lineNum">    1366 </span><span class="lineNoCov">          0 :       if (alignment</span>
<span class="lineNum">    1367 </span><span class="lineNoCov">          0 :           &amp;&amp; (offset % alignment == 0)</span>
<span class="lineNum">    1368 </span><span class="lineNoCov">          0 :           &amp;&amp; (alignment &gt; max_align))</span>
<span class="lineNum">    1369 </span><span class="lineNoCov">          0 :         max_align = alignment;</span>
<span class="lineNum">    1370 </span>            :     }
<span class="lineNum">    1371 </span>            : 
<span class="lineNum">    1372 </span><span class="lineNoCov">          0 :   type_align_map-&gt;put (type, max_align);</span>
<span class="lineNum">    1373 </span><span class="lineNoCov">          0 :   return max_align;</span>
<span class="lineNum">    1374 </span>            : }
<span class="lineNum">    1375 </span>            : 
<span class="lineNum">    1376 </span>            : /* Return alignment of vector type corresponding to decl's scalar type
<span class="lineNum">    1377 </span>            :    or 0 if it doesn't exist or the vector alignment is lesser than
<a name="1378"><span class="lineNum">    1378 </span>            :    decl's alignment.  */</a>
<span class="lineNum">    1379 </span>            : static unsigned
<span class="lineNum">    1380 </span><span class="lineNoCov">          0 : get_vec_alignment_for_type (tree type)</span>
<span class="lineNum">    1381 </span>            : {
<span class="lineNum">    1382 </span><span class="lineNoCov">          0 :   if (type == NULL_TREE)</span>
<span class="lineNum">    1383 </span>            :     return 0;
<span class="lineNum">    1384 </span>            : 
<span class="lineNum">    1385 </span><span class="lineNoCov">          0 :   gcc_assert (TYPE_P (type));</span>
<span class="lineNum">    1386 </span>            : 
<span class="lineNum">    1387 </span><span class="lineNoCov">          0 :   static unsigned alignment = 0;</span>
<span class="lineNum">    1388 </span><span class="lineNoCov">          0 :   switch (TREE_CODE (type))</span>
<span class="lineNum">    1389 </span>            :     {
<span class="lineNum">    1390 </span><span class="lineNoCov">          0 :       case ARRAY_TYPE:</span>
<span class="lineNum">    1391 </span><span class="lineNoCov">          0 :         alignment = get_vec_alignment_for_array_type (type);</span>
<span class="lineNum">    1392 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">    1393 </span><span class="lineNoCov">          0 :       case RECORD_TYPE:</span>
<span class="lineNum">    1394 </span><span class="lineNoCov">          0 :         alignment = get_vec_alignment_for_record_type (type);</span>
<span class="lineNum">    1395 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">    1396 </span><span class="lineNoCov">          0 :       default:</span>
<span class="lineNum">    1397 </span><span class="lineNoCov">          0 :         alignment = 0;</span>
<span class="lineNum">    1398 </span><span class="lineNoCov">          0 :         break;</span>
<span class="lineNum">    1399 </span>            :     }
<span class="lineNum">    1400 </span>            : 
<span class="lineNum">    1401 </span><span class="lineNoCov">          0 :   return (alignment &gt; TYPE_ALIGN (type)) ? alignment : 0;</span>
<span class="lineNum">    1402 </span>            : }
<span class="lineNum">    1403 </span>            : 
<a name="1404"><span class="lineNum">    1404 </span>            : /* Entry point to increase_alignment pass.  */</a>
<span class="lineNum">    1405 </span>            : static unsigned int
<span class="lineNum">    1406 </span><span class="lineNoCov">          0 : increase_alignment (void)</span>
<span class="lineNum">    1407 </span>            : {
<span class="lineNum">    1408 </span><span class="lineNoCov">          0 :   varpool_node *vnode;</span>
<span class="lineNum">    1409 </span>            : 
<span class="lineNum">    1410 </span><span class="lineNoCov">          0 :   vect_location = dump_user_location_t ();</span>
<span class="lineNum">    1411 </span><span class="lineNoCov">          0 :   type_align_map = new hash_map&lt;tree, unsigned&gt;;</span>
<span class="lineNum">    1412 </span>            : 
<span class="lineNum">    1413 </span>            :   /* Increase the alignment of all global arrays for vectorization.  */
<span class="lineNum">    1414 </span><span class="lineNoCov">          0 :   FOR_EACH_DEFINED_VARIABLE (vnode)</span>
<span class="lineNum">    1415 </span>            :     {
<span class="lineNum">    1416 </span><span class="lineNoCov">          0 :       tree decl = vnode-&gt;decl;</span>
<span class="lineNum">    1417 </span><span class="lineNoCov">          0 :       unsigned int alignment;</span>
<span class="lineNum">    1418 </span>            : 
<span class="lineNum">    1419 </span><span class="lineNoCov">          0 :       if ((decl_in_symtab_p (decl)</span>
<span class="lineNum">    1420 </span><span class="lineNoCov">          0 :           &amp;&amp; !symtab_node::get (decl)-&gt;can_increase_alignment_p ())</span>
<span class="lineNum">    1421 </span><span class="lineNoCov">          0 :           || DECL_USER_ALIGN (decl) || DECL_ARTIFICIAL (decl))</span>
<span class="lineNum">    1422 </span><span class="lineNoCov">          0 :         continue;</span>
<span class="lineNum">    1423 </span>            : 
<span class="lineNum">    1424 </span><span class="lineNoCov">          0 :       alignment = get_vec_alignment_for_type (TREE_TYPE (decl));</span>
<span class="lineNum">    1425 </span><span class="lineNoCov">          0 :       if (alignment &amp;&amp; vect_can_force_dr_alignment_p (decl, alignment))</span>
<span class="lineNum">    1426 </span>            :         {
<span class="lineNum">    1427 </span><span class="lineNoCov">          0 :           vnode-&gt;increase_alignment (alignment);</span>
<span class="lineNum">    1428 </span><span class="lineNoCov">          0 :           dump_printf (MSG_NOTE, &quot;Increasing alignment of decl: %T\n&quot;, decl);</span>
<span class="lineNum">    1429 </span>            :         }
<span class="lineNum">    1430 </span>            :     }
<span class="lineNum">    1431 </span>            : 
<span class="lineNum">    1432 </span><span class="lineNoCov">          0 :   delete type_align_map;</span>
<span class="lineNum">    1433 </span><span class="lineNoCov">          0 :   return 0;</span>
<span class="lineNum">    1434 </span>            : }
<span class="lineNum">    1435 </span>            : 
<span class="lineNum">    1436 </span>            : 
<span class="lineNum">    1437 </span>            : namespace {
<span class="lineNum">    1438 </span>            : 
<span class="lineNum">    1439 </span>            : const pass_data pass_data_ipa_increase_alignment =
<span class="lineNum">    1440 </span>            : {
<span class="lineNum">    1441 </span>            :   SIMPLE_IPA_PASS, /* type */
<span class="lineNum">    1442 </span>            :   &quot;increase_alignment&quot;, /* name */
<span class="lineNum">    1443 </span>            :   OPTGROUP_LOOP | OPTGROUP_VEC, /* optinfo_flags */
<span class="lineNum">    1444 </span>            :   TV_IPA_OPT, /* tv_id */
<span class="lineNum">    1445 </span>            :   0, /* properties_required */
<span class="lineNum">    1446 </span>            :   0, /* properties_provided */
<span class="lineNum">    1447 </span>            :   0, /* properties_destroyed */
<span class="lineNum">    1448 </span>            :   0, /* todo_flags_start */
<span class="lineNum">    1449 </span>            :   0, /* todo_flags_finish */
<span class="lineNum">    1450 </span>            : };
<span class="lineNum">    1451 </span>            : 
<span class="lineNum">    1452 </span>            : class pass_ipa_increase_alignment : public simple_ipa_opt_pass
<span class="lineNum">    1453 </span>            : {
<span class="lineNum">    1454 </span>            : public:
<span class="lineNum">    1455 </span>            :   pass_ipa_increase_alignment (gcc::context *ctxt)
<span class="lineNum">    1456 </span><span class="lineCov">     340624 :     : simple_ipa_opt_pass (pass_data_ipa_increase_alignment, ctxt)</span>
<span class="lineNum">    1457 </span>            :   {}
<a name="1458"><span class="lineNum">    1458 </span>            : </a>
<span class="lineNum">    1459 </span>            :   /* opt_pass methods: */
<span class="lineNum">    1460 </span><span class="lineCov">     139310 :   virtual bool gate (function *)</span>
<span class="lineNum">    1461 </span>            :     {
<span class="lineNum">    1462 </span><span class="lineCov">     139310 :       return flag_section_anchors &amp;&amp; flag_tree_loop_vectorize;</span>
<a name="1463"><span class="lineNum">    1463 </span>            :     }</a>
<span class="lineNum">    1464 </span>            : 
<span class="lineNum">    1465 </span><span class="lineNoCov">          0 :   virtual unsigned int execute (function *) { return increase_alignment (); }</span>
<span class="lineNum">    1466 </span>            : 
<span class="lineNum">    1467 </span>            : }; // class pass_ipa_increase_alignment
<span class="lineNum">    1468 </span>            : 
<span class="lineNum">    1469 </span>            : } // anon namespace
<a name="1470"><span class="lineNum">    1470 </span>            : </a>
<span class="lineNum">    1471 </span>            : simple_ipa_opt_pass *
<span class="lineNum">    1472 </span><span class="lineCov">     170312 : make_pass_ipa_increase_alignment (gcc::context *ctxt)</span>
<span class="lineNum">    1473 </span>            : {
<span class="lineNum">    1474 </span><span class="lineCov">     170312 :   return new pass_ipa_increase_alignment (ctxt);</span>
<span class="lineNum">    1475 </span>            : }
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.0</a></td></tr>
  </table>
  <br>
<h3>LCOV profile is generated on x86_64 machine using following configure options: configure --disable-bootstrap --enable-coverage=opt --enable-languages=c,c++,fortran,go,jit,lto --enable-host-shared. GCC test suite is run with the built compiler.</h3></body></html>
