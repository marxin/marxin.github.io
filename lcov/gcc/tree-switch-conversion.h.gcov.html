<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - gcc.info - gcc/tree-switch-conversion.h</title>
  <link rel="stylesheet" type="text/css" href="../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../index.html">top level</a> - <a href="index.html">gcc</a> - tree-switch-conversion.h<span style="font-size: 80%;"> (source / <a href="tree-switch-conversion.h.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">gcc.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">68</td>
            <td class="headerCovTableEntry">86</td>
            <td class="headerCovTableEntryMed">79.1 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2018-09-22 10:58:49</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">17</td>
            <td class="headerCovTableEntry">24</td>
            <td class="headerCovTableEntryLo">70.8 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /* Tree switch conversion for GNU compiler.</a>
<span class="lineNum">       2 </span>            :    Copyright (C) 2017 Free Software Foundation, Inc.
<span class="lineNum">       3 </span>            : 
<span class="lineNum">       4 </span>            : This file is part of GCC.
<span class="lineNum">       5 </span>            : 
<span class="lineNum">       6 </span>            : GCC is free software; you can redistribute it and/or modify it under
<span class="lineNum">       7 </span>            : the terms of the GNU General Public License as published by the Free
<span class="lineNum">       8 </span>            : Software Foundation; either version 3, or (at your option) any later
<span class="lineNum">       9 </span>            : version.
<span class="lineNum">      10 </span>            : 
<span class="lineNum">      11 </span>            : GCC is distributed in the hope that it will be useful, but WITHOUT ANY
<span class="lineNum">      12 </span>            : WARRANTY; without even the implied warranty of MERCHANTABILITY or
<span class="lineNum">      13 </span>            : FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
<span class="lineNum">      14 </span>            : for more details.
<span class="lineNum">      15 </span>            : 
<span class="lineNum">      16 </span>            : You should have received a copy of the GNU General Public License
<span class="lineNum">      17 </span>            : along with GCC; see the file COPYING3.  If not see
<span class="lineNum">      18 </span>            : &lt;http://www.gnu.org/licenses/&gt;.  */
<span class="lineNum">      19 </span>            : 
<span class="lineNum">      20 </span>            : #ifndef TREE_SWITCH_CONVERSION_H
<span class="lineNum">      21 </span>            : #define TREE_SWITCH_CONVERSION_H
<span class="lineNum">      22 </span>            : 
<span class="lineNum">      23 </span>            : namespace tree_switch_conversion {
<span class="lineNum">      24 </span>            : 
<span class="lineNum">      25 </span>            : /* Type of cluster.  */
<span class="lineNum">      26 </span>            : 
<span class="lineNum">      27 </span>            : enum cluster_type
<span class="lineNum">      28 </span>            : {
<span class="lineNum">      29 </span>            :   SIMPLE_CASE,
<span class="lineNum">      30 </span>            :   JUMP_TABLE,
<span class="lineNum">      31 </span>            :   BIT_TEST
<span class="lineNum">      32 </span>            : };
<span class="lineNum">      33 </span>            : 
<span class="lineNum">      34 </span>            : #define PRINT_CASE(f,c) print_generic_expr (f, c)
<span class="lineNum">      35 </span>            : 
<span class="lineNum">      36 </span>            : /* Abstract base class for representing a cluster of cases.
<span class="lineNum">      37 </span>            : 
<span class="lineNum">      38 </span>            :    Here is the inheritance hierarachy, and the enum_cluster_type
<span class="lineNum">      39 </span>            :    values for the concrete subclasses:
<span class="lineNum">      40 </span>            : 
<span class="lineNum">      41 </span>            :    cluster
<span class="lineNum">      42 </span>            :    |-simple_cluster (SIMPLE_CASE)
<span class="lineNum">      43 </span>            :    `-group_cluster
<span class="lineNum">      44 </span>            :      |-jump_table_cluster (JUMP_TABLE)
<span class="lineNum">      45 </span>            :      `-bit_test_cluster   (BIT_TEST).  */
<span class="lineNum">      46 </span>            : 
<span class="lineNum">      47 </span>            : struct cluster
<span class="lineNum">      48 </span>            : {
<span class="lineNum">      49 </span>            :   /* Constructor.  */
<span class="lineNum">      50 </span>            :   cluster (tree case_label_expr, basic_block case_bb, profile_probability prob,
<span class="lineNum">      51 </span>            :            profile_probability subtree_prob);
<a name="52"><span class="lineNum">      52 </span>            : </a>
<span class="lineNum">      53 </span>            :   /* Destructor.  */
<span class="lineNum">      54 </span><span class="lineNoCov">          0 :   virtual ~cluster ()</span>
<span class="lineNum">      55 </span><span class="lineNoCov">          0 :   {}</span>
<span class="lineNum">      56 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">      57 </span><span class="lineNoCov">          0 :   /* Return type.  */</span>
<span class="lineNum">      58 </span><span class="lineNoCov">          0 :   virtual cluster_type get_type () = 0;</span>
<span class="lineNum">      59 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">      60 </span>            :   /* Get low value covered by a cluster.  */
<span class="lineNum">      61 </span>            :   virtual tree get_low () = 0;
<span class="lineNum">      62 </span>            : 
<span class="lineNum">      63 </span>            :   /* Get high value covered by a cluster.  */
<span class="lineNum">      64 </span>            :   virtual tree get_high () = 0;
<span class="lineNum">      65 </span>            : 
<span class="lineNum">      66 </span>            :   /* Debug content of a cluster.  */
<span class="lineNum">      67 </span>            :   virtual void debug () = 0;
<span class="lineNum">      68 </span>            : 
<span class="lineNum">      69 </span>            :   /* Dump content of a cluster.  */
<span class="lineNum">      70 </span>            :   virtual void dump (FILE *f, bool details = false) = 0;
<span class="lineNum">      71 </span>            : 
<span class="lineNum">      72 </span>            :   /* Emit GIMPLE code to handle the cluster.  */
<span class="lineNum">      73 </span>            :   virtual void emit (tree, tree, tree, basic_block) = 0;
<span class="lineNum">      74 </span>            : 
<a name="75"><span class="lineNum">      75 </span>            :   /* Return true if a cluster handles only a single case value and the</a>
<span class="lineNum">      76 </span>            :      value is not a range.  */
<span class="lineNum">      77 </span>            :   virtual bool is_single_value_p ()
<span class="lineNum">      78 </span>            :   {
<span class="lineNum">      79 </span>            :     return false;
<span class="lineNum">      80 </span>            :   }
<span class="lineNum">      81 </span><span class="lineCov">        395 : </span>
<a name="82"><span class="lineNum">      82 </span>            :   /* Return range of a cluster.  If value would overflow in type of LOW,</a>
<span class="lineNum">      83 </span><span class="lineCov">        395 :      then return 0.  */</span>
<span class="lineNum">      84 </span>            :   static unsigned HOST_WIDE_INT get_range (tree low, tree high)
<span class="lineNum">      85 </span>            :   {
<span class="lineNum">      86 </span>            :     tree r = fold_build2 (MINUS_EXPR, TREE_TYPE (low), high, low);
<span class="lineNum">      87 </span>            :     if (!tree_fits_uhwi_p (r))
<span class="lineNum">      88 </span><span class="lineCov">     245234 :       return 0;</span>
<span class="lineNum">      89 </span>            : 
<span class="lineNum">      90 </span><span class="lineCov">     245234 :     return tree_to_uhwi (r) + 1;</span>
<span class="lineNum">      91 </span><span class="lineCov">     245234 :   }</span>
<span class="lineNum">      92 </span>            : 
<span class="lineNum">      93 </span>            :   /* Case label.  */
<span class="lineNum">      94 </span><span class="lineCov">     245142 :   tree m_case_label_expr;</span>
<span class="lineNum">      95 </span>            : 
<span class="lineNum">      96 </span>            :   /* Basic block of the case.  */
<span class="lineNum">      97 </span>            :   basic_block m_case_bb;
<span class="lineNum">      98 </span>            : 
<span class="lineNum">      99 </span>            :   /* Probability of taking this cluster.  */
<span class="lineNum">     100 </span>            :   profile_probability m_prob;
<span class="lineNum">     101 </span>            : 
<span class="lineNum">     102 </span>            :   /* Probability of reaching subtree rooted at this node.  */
<span class="lineNum">     103 </span>            :   profile_probability m_subtree_prob;
<span class="lineNum">     104 </span>            : 
<span class="lineNum">     105 </span>            : protected:
<span class="lineNum">     106 </span>            :   /* Default constructor.  */
<span class="lineNum">     107 </span>            :   cluster () {}
<a name="108"><span class="lineNum">     108 </span>            : };</a>
<span class="lineNum">     109 </span>            : 
<span class="lineNum">     110 </span>            : cluster::cluster (tree case_label_expr, basic_block case_bb,
<span class="lineNum">     111 </span><span class="lineCov">       9745 :                   profile_probability prob, profile_probability subtree_prob):</span>
<span class="lineNum">     112 </span>            :   m_case_label_expr (case_label_expr), m_case_bb (case_bb), m_prob (prob),
<span class="lineNum">     113 </span>            :   m_subtree_prob (subtree_prob)
<span class="lineNum">     114 </span><span class="lineCov">     121307 : {</span>
<span class="lineNum">     115 </span><span class="lineCov">     121307 : }</span>
<span class="lineNum">     116 </span>            : 
<span class="lineNum">     117 </span><span class="lineCov">     121307 : /* Subclass of cluster representing a simple contiguous range</span>
<span class="lineNum">     118 </span>            :    from [low..high].  */
<span class="lineNum">     119 </span><span class="lineCov">     121307 : </span>
<span class="lineNum">     120 </span>            : struct simple_cluster: public cluster
<span class="lineNum">     121 </span>            : {
<span class="lineNum">     122 </span>            :   /* Constructor.  */
<span class="lineNum">     123 </span>            :   simple_cluster (tree low, tree high, tree case_label_expr,
<span class="lineNum">     124 </span>            :                   basic_block case_bb, profile_probability prob);
<a name="125"><span class="lineNum">     125 </span>            : </a>
<span class="lineNum">     126 </span>            :   /* Destructor.  */
<span class="lineNum">     127 </span>            :   ~simple_cluster ()
<span class="lineNum">     128 </span>            :   {}
<a name="129"><span class="lineNum">     129 </span>            : </a>
<span class="lineNum">     130 </span>            :   cluster_type
<span class="lineNum">     131 </span><span class="lineCov">     121307 :   get_type ()</span>
<span class="lineNum">     132 </span><span class="lineCov">     121307 :   {</span>
<span class="lineNum">     133 </span><span class="lineCov">     121307 :     return SIMPLE_CASE;</span>
<span class="lineNum">     134 </span><span class="lineCov">     121307 :   }</span>
<a name="135"><span class="lineNum">     135 </span><span class="lineNoCov">          0 : </span></a>
<span class="lineNum">     136 </span><span class="lineNoCov">          0 :   tree</span>
<span class="lineNum">     137 </span>            :   get_low ()
<span class="lineNum">     138 </span>            :   {
<span class="lineNum">     139 </span><span class="lineCov">     113466 :     return m_low;</span>
<span class="lineNum">     140 </span>            :   }
<a name="141"><span class="lineNum">     141 </span><span class="lineCov">     113466 : </span></a>
<span class="lineNum">     142 </span>            :   tree
<span class="lineNum">     143 </span>            :   get_high ()
<span class="lineNum">     144 </span>            :   {
<span class="lineNum">     145 </span><span class="lineCov">     379223 :     return m_high;</span>
<span class="lineNum">     146 </span>            :   }
<a name="147"><span class="lineNum">     147 </span><span class="lineCov">     379223 : </span></a>
<span class="lineNum">     148 </span>            :   void
<span class="lineNum">     149 </span>            :   debug ()
<span class="lineNum">     150 </span>            :   {
<span class="lineNum">     151 </span><span class="lineCov">     349521 :     dump (stderr);</span>
<span class="lineNum">     152 </span>            :   }
<a name="153"><span class="lineNum">     153 </span><span class="lineCov">     349521 : </span></a>
<span class="lineNum">     154 </span>            :   void
<span class="lineNum">     155 </span>            :   dump (FILE *f, bool details ATTRIBUTE_UNUSED = false)
<span class="lineNum">     156 </span>            :   {
<span class="lineNum">     157 </span><span class="lineNoCov">          0 :     PRINT_CASE (f, get_low ());</span>
<span class="lineNum">     158 </span>            :     if (get_low () != get_high ())
<span class="lineNum">     159 </span><span class="lineNoCov">          0 :       {</span>
<span class="lineNum">     160 </span><span class="lineNoCov">          0 :         fprintf (f, &quot;-&quot;);</span>
<span class="lineNum">     161 </span>            :         PRINT_CASE (f, get_high ());
<span class="lineNum">     162 </span>            :       }
<span class="lineNum">     163 </span><span class="lineCov">         22 :     fprintf (f, &quot; &quot;);</span>
<a name="164"><span class="lineNum">     164 </span>            :   }</a>
<span class="lineNum">     165 </span><span class="lineCov">         22 : </span>
<span class="lineNum">     166 </span><span class="lineCov">         22 :   void emit (tree, tree, tree, basic_block)</span>
<span class="lineNum">     167 </span>            :   {
<span class="lineNum">     168 </span><span class="lineCov">          2 :     gcc_unreachable ();</span>
<a name="169"><span class="lineNum">     169 </span><span class="lineCov">          2 :   }</span></a>
<span class="lineNum">     170 </span>            : 
<span class="lineNum">     171 </span><span class="lineCov">         22 :   bool is_single_value_p ()</span>
<span class="lineNum">     172 </span><span class="lineCov">         22 :   {</span>
<span class="lineNum">     173 </span>            :     return tree_int_cst_equal (get_low (), get_high ());
<span class="lineNum">     174 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     175 </span>            : 
<span class="lineNum">     176 </span><span class="lineNoCov">          0 :   /* Low value of the case.  */</span>
<span class="lineNum">     177 </span>            :   tree m_low;
<span class="lineNum">     178 </span>            : 
<span class="lineNum">     179 </span><span class="lineCov">      37389 :   /* High value of the case.  */</span>
<span class="lineNum">     180 </span>            :   tree m_high;
<span class="lineNum">     181 </span><span class="lineCov">      37389 : </span>
<span class="lineNum">     182 </span>            :   /* True if case is a range.  */
<span class="lineNum">     183 </span>            :   bool m_range_p;
<a name="184"><span class="lineNum">     184 </span>            : };</a>
<span class="lineNum">     185 </span>            : 
<span class="lineNum">     186 </span>            : simple_cluster::simple_cluster (tree low, tree high, tree case_label_expr,
<span class="lineNum">     187 </span>            :                                 basic_block case_bb, profile_probability prob):
<span class="lineNum">     188 </span>            :   cluster (case_label_expr, case_bb, prob, prob),
<span class="lineNum">     189 </span>            :   m_low (low), m_high (high)
<span class="lineNum">     190 </span>            : {
<span class="lineNum">     191 </span>            :   m_range_p = m_high != NULL;
<span class="lineNum">     192 </span>            :   if (m_high == NULL)
<span class="lineNum">     193 </span>            :     m_high = m_low;
<span class="lineNum">     194 </span><span class="lineCov">     121307 : }</span>
<span class="lineNum">     195 </span><span class="lineCov">     121307 : </span>
<span class="lineNum">     196 </span>            : /* Abstract subclass of jump table and bit test cluster,
<span class="lineNum">     197 </span><span class="lineCov">     121307 :    handling a collection of simple_cluster instances.  */</span>
<span class="lineNum">     198 </span>            : 
<span class="lineNum">     199 </span><span class="lineCov">     121307 : struct group_cluster: public cluster</span>
<span class="lineNum">     200 </span><span class="lineCov">     121307 : {</span>
<span class="lineNum">     201 </span><span class="lineCov">     105039 :   /* Constructor.  */</span>
<span class="lineNum">     202 </span><span class="lineCov">     121307 :   group_cluster (vec&lt;cluster *&gt; &amp;clusters, unsigned start, unsigned end);</span>
<span class="lineNum">     203 </span>            : 
<span class="lineNum">     204 </span>            :   /* Destructor.  */
<span class="lineNum">     205 </span>            :   ~group_cluster ();
<span class="lineNum">     206 </span>            : 
<span class="lineNum">     207 </span>            :   tree
<span class="lineNum">     208 </span>            :   get_low ()
<span class="lineNum">     209 </span>            :   {
<span class="lineNum">     210 </span>            :     return m_cases[0]-&gt;get_low ();
<span class="lineNum">     211 </span>            :   }
<span class="lineNum">     212 </span>            : 
<span class="lineNum">     213 </span>            :   tree
<span class="lineNum">     214 </span>            :   get_high ()
<span class="lineNum">     215 </span>            :   {
<span class="lineNum">     216 </span><span class="lineCov">      10462 :     return m_cases[m_cases.length () - 1]-&gt;get_high ();</span>
<span class="lineNum">     217 </span>            :   }
<a name="218"><span class="lineNum">     218 </span><span class="lineCov">      10462 : </span></a>
<span class="lineNum">     219 </span>            :   void
<span class="lineNum">     220 </span>            :   debug ()
<span class="lineNum">     221 </span>            :   {
<span class="lineNum">     222 </span><span class="lineCov">      10462 :     dump (stderr);</span>
<span class="lineNum">     223 </span>            :   }
<span class="lineNum">     224 </span><span class="lineCov">      20924 : </span>
<span class="lineNum">     225 </span>            :   void dump (FILE *f, bool details = false);
<span class="lineNum">     226 </span>            : 
<span class="lineNum">     227 </span>            :   /* List of simple clusters handled by the group.  */
<span class="lineNum">     228 </span><span class="lineNoCov">          0 :   vec&lt;simple_cluster *&gt; m_cases;</span>
<span class="lineNum">     229 </span>            : };
<span class="lineNum">     230 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">     231 </span><span class="lineNoCov">          0 : /* Concrete subclass of group_cluster representing a collection</span>
<span class="lineNum">     232 </span>            :    of cases to be implemented as a jump table.
<span class="lineNum">     233 </span>            :    The &quot;emit&quot; vfunc gernerates a nested switch statement which
<span class="lineNum">     234 </span>            :    is later lowered to a jump table.  */
<span class="lineNum">     235 </span>            : 
<span class="lineNum">     236 </span>            : struct jump_table_cluster: public group_cluster
<span class="lineNum">     237 </span>            : {
<span class="lineNum">     238 </span>            :   /* Constructor.  */
<span class="lineNum">     239 </span>            :   jump_table_cluster (vec&lt;cluster *&gt; &amp;clusters, unsigned start, unsigned end)
<span class="lineNum">     240 </span>            :   : group_cluster (clusters, start, end)
<span class="lineNum">     241 </span>            :   {}
<a name="242"><span class="lineNum">     242 </span>            : </a>
<span class="lineNum">     243 </span>            :   cluster_type
<span class="lineNum">     244 </span>            :   get_type ()
<span class="lineNum">     245 </span>            :   {
<span class="lineNum">     246 </span>            :     return JUMP_TABLE;
<span class="lineNum">     247 </span>            :   }
<span class="lineNum">     248 </span><span class="lineCov">       9438 : </span>
<span class="lineNum">     249 </span>            :   void emit (tree index_expr, tree index_type,
<span class="lineNum">     250 </span>            :              tree default_label_expr, basic_block default_bb);
<span class="lineNum">     251 </span>            : 
<span class="lineNum">     252 </span><span class="lineCov">      28408 :   /* Find jump tables of given CLUSTERS, where all members of the vector</span>
<span class="lineNum">     253 </span>            :      are of type simple_cluster.  New clusters are returned.  */
<span class="lineNum">     254 </span><span class="lineCov">      28408 :   static vec&lt;cluster *&gt; find_jump_tables (vec&lt;cluster *&gt; &amp;clusters);</span>
<span class="lineNum">     255 </span>            : 
<span class="lineNum">     256 </span>            :   /* Return true when cluster starting at START and ending at END (inclusive)
<span class="lineNum">     257 </span>            :      can build a jump-table.  */
<span class="lineNum">     258 </span>            :   static bool can_be_handled (const vec&lt;cluster *&gt; &amp;clusters, unsigned start,
<span class="lineNum">     259 </span>            :                               unsigned end);
<span class="lineNum">     260 </span>            : 
<span class="lineNum">     261 </span>            :   /* Return true if cluster starting at START and ending at END (inclusive)
<span class="lineNum">     262 </span>            :      is profitable transformation.  */
<span class="lineNum">     263 </span>            :   static bool is_beneficial (const vec&lt;cluster *&gt; &amp;clusters, unsigned start,
<span class="lineNum">     264 </span>            :                              unsigned end);
<span class="lineNum">     265 </span>            : 
<span class="lineNum">     266 </span>            :   /* Return the smallest number of different values for which it is best
<span class="lineNum">     267 </span>            :      to use a jump-table instead of a tree of conditional branches.  */
<span class="lineNum">     268 </span>            :   static inline unsigned int case_values_threshold (void);
<span class="lineNum">     269 </span>            : 
<span class="lineNum">     270 </span>            :   /* Return whether jump table expansion is allowed.  */
<span class="lineNum">     271 </span>            :   static bool is_enabled (void);
<span class="lineNum">     272 </span>            : 
<span class="lineNum">     273 </span>            :   /* Max growth ratio for code that is optimized for size.  */
<span class="lineNum">     274 </span>            :   static const unsigned HOST_WIDE_INT max_ratio_for_size = 3;
<span class="lineNum">     275 </span>            : 
<span class="lineNum">     276 </span>            :   /* Max growth ratio for code that is optimized for speed.  */
<span class="lineNum">     277 </span>            :   static const unsigned HOST_WIDE_INT max_ratio_for_speed = 8;
<span class="lineNum">     278 </span>            : };
<span class="lineNum">     279 </span>            : 
<span class="lineNum">     280 </span>            : /* A GIMPLE switch statement can be expanded to a short sequence of bit-wise
<span class="lineNum">     281 </span>            : comparisons.  &quot;switch(x)&quot; is converted into &quot;if ((1 &lt;&lt; (x-MINVAL)) &amp; CST)&quot;
<span class="lineNum">     282 </span>            : where CST and MINVAL are integer constants.  This is better than a series
<span class="lineNum">     283 </span>            : of compare-and-banch insns in some cases,  e.g. we can implement:
<span class="lineNum">     284 </span>            : 
<span class="lineNum">     285 </span>            :         if ((x==4) || (x==6) || (x==9) || (x==11))
<span class="lineNum">     286 </span>            : 
<span class="lineNum">     287 </span>            : as a single bit test:
<span class="lineNum">     288 </span>            : 
<span class="lineNum">     289 </span>            :         if ((1&lt;&lt;x) &amp; ((1&lt;&lt;4)|(1&lt;&lt;6)|(1&lt;&lt;9)|(1&lt;&lt;11)))
<span class="lineNum">     290 </span>            : 
<span class="lineNum">     291 </span>            : This transformation is only applied if the number of case targets is small,
<span class="lineNum">     292 </span>            : if CST constains at least 3 bits, and &quot;1 &lt;&lt; x&quot; is cheap.  The bit tests are
<span class="lineNum">     293 </span>            : performed in &quot;word_mode&quot;.
<span class="lineNum">     294 </span>            : 
<span class="lineNum">     295 </span>            : The following example shows the code the transformation generates:
<span class="lineNum">     296 </span>            : 
<span class="lineNum">     297 </span>            :         int bar(int x)
<span class="lineNum">     298 </span>            :         {
<span class="lineNum">     299 </span>            :                 switch (x)
<span class="lineNum">     300 </span>            :                 {
<span class="lineNum">     301 </span>            :                 case '0':  case '1':  case '2':  case '3':  case '4':
<span class="lineNum">     302 </span>            :                 case '5':  case '6':  case '7':  case '8':  case '9':
<span class="lineNum">     303 </span>            :                 case 'A':  case 'B':  case 'C':  case 'D':  case 'E':
<span class="lineNum">     304 </span>            :                 case 'F':
<span class="lineNum">     305 </span>            :                         return 1;
<span class="lineNum">     306 </span>            :                 }
<span class="lineNum">     307 </span>            :                 return 0;
<span class="lineNum">     308 </span>            :         }
<span class="lineNum">     309 </span>            : 
<span class="lineNum">     310 </span>            : ==&gt;
<span class="lineNum">     311 </span>            : 
<span class="lineNum">     312 </span>            :         bar (int x)
<span class="lineNum">     313 </span>            :         {
<span class="lineNum">     314 </span>            :                 tmp1 = x - 48;
<span class="lineNum">     315 </span>            :                 if (tmp1 &gt; (70 - 48)) goto L2;
<span class="lineNum">     316 </span>            :                 tmp2 = 1 &lt;&lt; tmp1;
<span class="lineNum">     317 </span>            :                 tmp3 = 0b11111100000001111111111;
<span class="lineNum">     318 </span>            :                 if ((tmp2 &amp; tmp3) != 0) goto L1 ; else goto L2;
<span class="lineNum">     319 </span>            :         L1:
<span class="lineNum">     320 </span>            :                 return 1;
<span class="lineNum">     321 </span>            :         L2:
<span class="lineNum">     322 </span>            :                 return 0;
<span class="lineNum">     323 </span>            :         }
<span class="lineNum">     324 </span>            : 
<span class="lineNum">     325 </span>            : TODO: There are still some improvements to this transformation that could
<span class="lineNum">     326 </span>            : be implemented:
<span class="lineNum">     327 </span>            : 
<span class="lineNum">     328 </span>            : * A narrower mode than word_mode could be used if that is cheaper, e.g.
<span class="lineNum">     329 </span>            :   for x86_64 where a narrower-mode shift may result in smaller code.
<span class="lineNum">     330 </span>            : 
<span class="lineNum">     331 </span>            : * The compounded constant could be shifted rather than the one.  The
<span class="lineNum">     332 </span>            :   test would be either on the sign bit or on the least significant bit,
<span class="lineNum">     333 </span>            :   depending on the direction of the shift.  On some machines, the test
<span class="lineNum">     334 </span>            :   for the branch would be free if the bit to test is already set by the
<span class="lineNum">     335 </span>            :   shift operation.
<span class="lineNum">     336 </span>            : 
<span class="lineNum">     337 </span>            : This transformation was contributed by Roger Sayle, see this e-mail:
<span class="lineNum">     338 </span>            :    http://gcc.gnu.org/ml/gcc-patches/2003-01/msg01950.html
<span class="lineNum">     339 </span>            : */
<span class="lineNum">     340 </span>            : 
<span class="lineNum">     341 </span>            : struct bit_test_cluster: public group_cluster
<span class="lineNum">     342 </span>            : {
<span class="lineNum">     343 </span>            :   /* Constructor.  */
<span class="lineNum">     344 </span>            :   bit_test_cluster (vec&lt;cluster *&gt; &amp;clusters, unsigned start, unsigned end,
<span class="lineNum">     345 </span>            :                     bool handles_entire_switch)
<span class="lineNum">     346 </span>            :   :group_cluster (clusters, start, end),
<span class="lineNum">     347 </span>            :   m_handles_entire_switch (handles_entire_switch)
<span class="lineNum">     348 </span>            :   {}
<a name="349"><span class="lineNum">     349 </span>            : </a>
<span class="lineNum">     350 </span>            :   cluster_type
<span class="lineNum">     351 </span>            :   get_type ()
<span class="lineNum">     352 </span>            :   {
<span class="lineNum">     353 </span>            :     return BIT_TEST;
<span class="lineNum">     354 </span><span class="lineCov">        307 :   }</span>
<span class="lineNum">     355 </span><span class="lineCov">        307 : </span>
<span class="lineNum">     356 </span>            : /*  Expand a switch statement by a short sequence of bit-wise
<span class="lineNum">     357 </span>            :     comparisons.  &quot;switch(x)&quot; is effectively converted into
<span class="lineNum">     358 </span>            :     &quot;if ((1 &lt;&lt; (x-MINVAL)) &amp; CST)&quot; where CST and MINVAL are
<span class="lineNum">     359 </span><span class="lineCov">        638 :     integer constants.</span>
<span class="lineNum">     360 </span>            : 
<span class="lineNum">     361 </span><span class="lineCov">        638 :     INDEX_EXPR is the value being switched on.</span>
<span class="lineNum">     362 </span>            : 
<span class="lineNum">     363 </span>            :     MINVAL is the lowest case value of in the case nodes,
<span class="lineNum">     364 </span>            :     and RANGE is highest value minus MINVAL.  MINVAL and RANGE
<span class="lineNum">     365 </span>            :     are not guaranteed to be of the same type as INDEX_EXPR
<span class="lineNum">     366 </span>            :     (the gimplifier doesn't change the type of case label values,
<span class="lineNum">     367 </span>            :     and MINVAL and RANGE are derived from those values).
<span class="lineNum">     368 </span>            :     MAXVAL is MINVAL + RANGE.
<span class="lineNum">     369 </span>            : 
<span class="lineNum">     370 </span>            :     There *MUST* be max_case_bit_tests or less unique case
<span class="lineNum">     371 </span>            :     node targets.  */
<span class="lineNum">     372 </span>            :   void emit (tree index_expr, tree index_type,
<span class="lineNum">     373 </span>            :              tree default_label_expr, basic_block default_bb);
<span class="lineNum">     374 </span>            : 
<span class="lineNum">     375 </span>            :   /* Find bit tests of given CLUSTERS, where all members of the vector
<span class="lineNum">     376 </span>            :      are of type simple_cluster.  New clusters are returned.  */
<span class="lineNum">     377 </span>            :   static vec&lt;cluster *&gt; find_bit_tests (vec&lt;cluster *&gt; &amp;clusters);
<span class="lineNum">     378 </span>            : 
<span class="lineNum">     379 </span>            :   /* Return true when RANGE of case values with UNIQ labels
<span class="lineNum">     380 </span>            :      can build a bit test.  */
<span class="lineNum">     381 </span>            :   static bool can_be_handled (unsigned HOST_WIDE_INT range, unsigned uniq);
<span class="lineNum">     382 </span>            : 
<span class="lineNum">     383 </span>            :   /* Return true when cluster starting at START and ending at END (inclusive)
<span class="lineNum">     384 </span>            :      can build a bit test.  */
<span class="lineNum">     385 </span>            :   static bool can_be_handled (const vec&lt;cluster *&gt; &amp;clusters, unsigned start,
<span class="lineNum">     386 </span>            :                               unsigned end);
<span class="lineNum">     387 </span>            : 
<span class="lineNum">     388 </span>            :   /* Return true when COUNT of cases of UNIQ labels is beneficial for bit test
<span class="lineNum">     389 </span>            :      transformation.  */
<span class="lineNum">     390 </span>            :   static bool is_beneficial (unsigned count, unsigned uniq);
<span class="lineNum">     391 </span>            : 
<span class="lineNum">     392 </span>            :   /* Return true if cluster starting at START and ending at END (inclusive)
<span class="lineNum">     393 </span>            :      is profitable transformation.  */
<span class="lineNum">     394 </span>            :   static bool is_beneficial (const vec&lt;cluster *&gt; &amp;clusters, unsigned start,
<span class="lineNum">     395 </span>            :                              unsigned end);
<span class="lineNum">     396 </span>            : 
<span class="lineNum">     397 </span>            : /* Split the basic block at the statement pointed to by GSIP, and insert
<span class="lineNum">     398 </span>            :    a branch to the target basic block of E_TRUE conditional on tree
<span class="lineNum">     399 </span>            :    expression COND.
<span class="lineNum">     400 </span>            : 
<span class="lineNum">     401 </span>            :    It is assumed that there is already an edge from the to-be-split
<span class="lineNum">     402 </span>            :    basic block to E_TRUE-&gt;dest block.  This edge is removed, and the
<span class="lineNum">     403 </span>            :    profile information on the edge is re-used for the new conditional
<span class="lineNum">     404 </span>            :    jump.
<span class="lineNum">     405 </span>            : 
<span class="lineNum">     406 </span>            :    The CFG is updated.  The dominator tree will not be valid after
<span class="lineNum">     407 </span>            :    this transformation, but the immediate dominators are updated if
<span class="lineNum">     408 </span>            :    UPDATE_DOMINATORS is true.
<span class="lineNum">     409 </span>            : 
<span class="lineNum">     410 </span>            :    Returns the newly created basic block.  */
<span class="lineNum">     411 </span>            :   static basic_block hoist_edge_and_branch_if_true (gimple_stmt_iterator *gsip,
<span class="lineNum">     412 </span>            :                                                     tree cond,
<span class="lineNum">     413 </span>            :                                                     basic_block case_bb,
<span class="lineNum">     414 </span>            :                                                     profile_probability prob);
<span class="lineNum">     415 </span>            : 
<span class="lineNum">     416 </span>            :   /* True when the jump table handles an entire switch statement.  */
<span class="lineNum">     417 </span>            :   bool m_handles_entire_switch;
<span class="lineNum">     418 </span>            : 
<span class="lineNum">     419 </span>            :   /* Maximum number of different basic blocks that can be handled by
<span class="lineNum">     420 </span>            :      a bit test.  */
<span class="lineNum">     421 </span>            :   static const int m_max_case_bit_tests = 3;
<span class="lineNum">     422 </span>            : };
<span class="lineNum">     423 </span>            : 
<span class="lineNum">     424 </span>            : /* Helper struct to find minimal clusters.  */
<span class="lineNum">     425 </span>            : 
<span class="lineNum">     426 </span>            : struct min_cluster_item
<span class="lineNum">     427 </span>            : {
<span class="lineNum">     428 </span>            :   /* Constructor.  */
<span class="lineNum">     429 </span>            :   min_cluster_item (unsigned count, unsigned start, unsigned non_jt_cases):
<span class="lineNum">     430 </span>            :     m_count (count), m_start (start), m_non_jt_cases (non_jt_cases)
<span class="lineNum">     431 </span>            :   {}
<span class="lineNum">     432 </span>            : 
<span class="lineNum">     433 </span>            :   /* Count of clusters.  */
<span class="lineNum">     434 </span>            :   unsigned m_count;
<span class="lineNum">     435 </span>            : 
<span class="lineNum">     436 </span>            :   /* Index where is cluster boundary.  */
<span class="lineNum">     437 </span>            :   unsigned m_start;
<span class="lineNum">     438 </span>            : 
<span class="lineNum">     439 </span>            :   /* Total number of cases that will not be in a jump table.  */
<span class="lineNum">     440 </span>            :   unsigned m_non_jt_cases;
<span class="lineNum">     441 </span>            : };
<span class="lineNum">     442 </span>            : 
<span class="lineNum">     443 </span>            : /* Helper struct to represent switch decision tree.  */
<span class="lineNum">     444 </span>            : 
<span class="lineNum">     445 </span>            : struct case_tree_node
<span class="lineNum">     446 </span>            : {
<span class="lineNum">     447 </span>            :   /* Empty Constructor.  */
<span class="lineNum">     448 </span>            :   case_tree_node ();
<a name="449"><span class="lineNum">     449 </span>            : </a>
<span class="lineNum">     450 </span>            :   /* Return true when it has a child.  */
<span class="lineNum">     451 </span>            :   bool has_child ()
<span class="lineNum">     452 </span>            :   {
<span class="lineNum">     453 </span>            :     return m_left != NULL || m_right != NULL;
<span class="lineNum">     454 </span>            :   }
<span class="lineNum">     455 </span>            : 
<span class="lineNum">     456 </span>            :   /* Left son in binary tree.  */
<span class="lineNum">     457 </span>            :   case_tree_node *m_left;
<span class="lineNum">     458 </span>            : 
<span class="lineNum">     459 </span><span class="lineNoCov">          0 :   /* Right son in binary tree; also node chain.  */</span>
<span class="lineNum">     460 </span>            :   case_tree_node *m_right;
<span class="lineNum">     461 </span><span class="lineCov">      21328 : </span>
<span class="lineNum">     462 </span>            :   /* Parent of node in binary tree.  */
<span class="lineNum">     463 </span>            :   case_tree_node *m_parent;
<span class="lineNum">     464 </span>            : 
<span class="lineNum">     465 </span>            :   /* Cluster represented by this tree node.  */
<span class="lineNum">     466 </span>            :   cluster *m_c;
<span class="lineNum">     467 </span>            : };
<span class="lineNum">     468 </span>            : 
<span class="lineNum">     469 </span>            : inline
<span class="lineNum">     470 </span>            : case_tree_node::case_tree_node ():
<span class="lineNum">     471 </span>            :   m_left (NULL), m_right (NULL), m_parent (NULL), m_c (NULL)
<span class="lineNum">     472 </span>            : {
<span class="lineNum">     473 </span>            : }
<span class="lineNum">     474 </span>            : 
<span class="lineNum">     475 </span>            : unsigned int
<span class="lineNum">     476 </span>            : jump_table_cluster::case_values_threshold (void)
<span class="lineNum">     477 </span>            : {
<span class="lineNum">     478 </span><span class="lineCov">      46586 :   unsigned int threshold = PARAM_VALUE (PARAM_CASE_VALUES_THRESHOLD);</span>
<span class="lineNum">     479 </span><span class="lineCov">      46586 : </span>
<span class="lineNum">     480 </span>            :   if (threshold == 0)
<span class="lineNum">     481 </span>            :     threshold = targetm.case_values_threshold ();
<span class="lineNum">     482 </span>            : 
<span class="lineNum">     483 </span>            :   return threshold;
<span class="lineNum">     484 </span>            : }
<a name="485"><span class="lineNum">     485 </span>            : </a>
<span class="lineNum">     486 </span><span class="lineCov">    2295090 : /* Return whether jump table expansion is allowed.  */</span>
<span class="lineNum">     487 </span>            : bool jump_table_cluster::is_enabled (void)
<span class="lineNum">     488 </span><span class="lineCov">    2295090 : {</span>
<span class="lineNum">     489 </span><span class="lineCov">    2294912 :   /* If neither casesi or tablejump is available, or flag_jump_tables</span>
<span class="lineNum">     490 </span>            :      over-ruled us, we really have no choice.  */
<span class="lineNum">     491 </span><span class="lineCov">    2295090 :   if (!targetm.have_casesi () &amp;&amp; !targetm.have_tablejump ())</span>
<span class="lineNum">     492 </span>            :     return false;
<span class="lineNum">     493 </span>            :   if (!flag_jump_tables)
<span class="lineNum">     494 </span>            :     return false;
<span class="lineNum">     495 </span><span class="lineCov">      22599 : #ifndef ASM_OUTPUT_ADDR_DIFF_ELT</span>
<span class="lineNum">     496 </span>            :   if (flag_pic)
<span class="lineNum">     497 </span>            :     return false;
<span class="lineNum">     498 </span>            : #endif
<span class="lineNum">     499 </span><span class="lineCov">      22599 : </span>
<span class="lineNum">     500 </span>            :   return true;
<span class="lineNum">     501 </span><span class="lineCov">      22599 : }</span>
<span class="lineNum">     502 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">     503 </span>            : /* A case_bit_test represents a set of case nodes that may be
<span class="lineNum">     504 </span>            :    selected from using a bit-wise comparison.  HI and LO hold
<span class="lineNum">     505 </span>            :    the integer to be tested against, TARGET_EDGE contains the
<span class="lineNum">     506 </span>            :    edge to the basic block to jump to upon success and BITS
<span class="lineNum">     507 </span>            :    counts the number of case nodes handled by this test,
<span class="lineNum">     508 </span>            :    typically the number of bits set in HI:LO.  The LABEL field
<span class="lineNum">     509 </span>            :    is used to quickly identify all cases in this set without
<span class="lineNum">     510 </span>            :    looking at label_to_block for every case label.  */
<span class="lineNum">     511 </span>            : 
<span class="lineNum">     512 </span>            : struct case_bit_test
<span class="lineNum">     513 </span>            : {
<span class="lineNum">     514 </span>            :   wide_int mask;
<span class="lineNum">     515 </span>            :   basic_block target_bb;
<span class="lineNum">     516 </span>            :   tree label;
<span class="lineNum">     517 </span>            :   int bits;
<span class="lineNum">     518 </span>            : 
<span class="lineNum">     519 </span>            :   /* Comparison function for qsort to order bit tests by decreasing
<span class="lineNum">     520 </span>            :      probability of execution.  */
<span class="lineNum">     521 </span>            :   static int cmp (const void *p1, const void *p2);
<span class="lineNum">     522 </span>            : };
<span class="lineNum">     523 </span>            : 
<span class="lineNum">     524 </span>            : struct switch_decision_tree
<span class="lineNum">     525 </span>            : {
<span class="lineNum">     526 </span>            :   /* Constructor.  */
<span class="lineNum">     527 </span>            :   switch_decision_tree (gswitch *swtch): m_switch (swtch), m_phi_mapping (),
<span class="lineNum">     528 </span>            :     m_case_bbs (), m_case_node_pool (&quot;struct case_node pool&quot;),
<span class="lineNum">     529 </span>            :     m_case_list (NULL)
<span class="lineNum">     530 </span>            :   {
<span class="lineNum">     531 </span>            :   }
<span class="lineNum">     532 </span>            : 
<span class="lineNum">     533 </span>            :   /* Analyze switch statement and return true when the statement is expanded
<span class="lineNum">     534 </span>            :      as decision tree.  */
<span class="lineNum">     535 </span><span class="lineCov">      22599 :   bool analyze_switch_statement ();</span>
<span class="lineNum">     536 </span>            : 
<span class="lineNum">     537 </span><span class="lineCov">      22599 :   /* Attempt to expand CLUSTERS as a decision tree.  Return true when</span>
<span class="lineNum">     538 </span>            :      expanded.  */
<span class="lineNum">     539 </span><span class="lineCov">      22599 :   bool try_switch_expansion (vec&lt;cluster *&gt; &amp;clusters);</span>
<span class="lineNum">     540 </span>            :   /* Compute the number of case labels that correspond to each outgoing edge of
<span class="lineNum">     541 </span>            :      switch statement.  Record this information in the aux field of the edge.
<span class="lineNum">     542 </span>            :      */
<span class="lineNum">     543 </span>            :   void compute_cases_per_edge ();
<span class="lineNum">     544 </span>            : 
<span class="lineNum">     545 </span>            :   /* Before switch transformation, record all SSA_NAMEs defined in switch BB
<span class="lineNum">     546 </span>            :      and used in a label basic block.  */
<span class="lineNum">     547 </span>            :   void record_phi_operand_mapping ();
<span class="lineNum">     548 </span>            : 
<span class="lineNum">     549 </span>            :   /* Append new operands to PHI statements that were introduced due to
<span class="lineNum">     550 </span>            :      addition of new edges to case labels.  */
<span class="lineNum">     551 </span>            :   void fix_phi_operands_for_edges ();
<span class="lineNum">     552 </span>            : 
<span class="lineNum">     553 </span>            :   /* Generate a decision tree, switching on INDEX_EXPR and jumping to
<span class="lineNum">     554 </span>            :      one of the labels in CASE_LIST or to the DEFAULT_LABEL.
<span class="lineNum">     555 </span>            : 
<span class="lineNum">     556 </span>            :      We generate a binary decision tree to select the appropriate target
<span class="lineNum">     557 </span>            :      code.  */
<span class="lineNum">     558 </span>            :   void emit (basic_block bb, tree index_expr,
<span class="lineNum">     559 </span>            :              profile_probability default_prob, tree index_type);
<span class="lineNum">     560 </span>            : 
<span class="lineNum">     561 </span>            :   /* Emit step-by-step code to select a case for the value of INDEX.
<span class="lineNum">     562 </span>            :      The thus generated decision tree follows the form of the
<span class="lineNum">     563 </span>            :      case-node binary tree NODE, whose nodes represent test conditions.
<span class="lineNum">     564 </span>            :      DEFAULT_PROB is probability of cases leading to default BB.
<span class="lineNum">     565 </span>            :      INDEX_TYPE is the type of the index of the switch.  */
<span class="lineNum">     566 </span>            :   basic_block emit_case_nodes (basic_block bb, tree index,
<span class="lineNum">     567 </span>            :                                case_tree_node *node,
<span class="lineNum">     568 </span>            :                                profile_probability default_prob,
<span class="lineNum">     569 </span>            :                                tree index_type);
<span class="lineNum">     570 </span>            : 
<span class="lineNum">     571 </span>            :   /* Take an ordered list of case nodes
<span class="lineNum">     572 </span>            :      and transform them into a near optimal binary tree,
<span class="lineNum">     573 </span>            :      on the assumption that any target code selection value is as
<span class="lineNum">     574 </span>            :      likely as any other.
<span class="lineNum">     575 </span>            : 
<span class="lineNum">     576 </span>            :      The transformation is performed by splitting the ordered
<span class="lineNum">     577 </span>            :      list into two equal sections plus a pivot.  The parts are
<span class="lineNum">     578 </span>            :      then attached to the pivot as left and right branches.  Each
<span class="lineNum">     579 </span>            :      branch is then transformed recursively.  */
<span class="lineNum">     580 </span>            :   static void balance_case_nodes (case_tree_node **head,
<span class="lineNum">     581 </span>            :                                   case_tree_node *parent);
<span class="lineNum">     582 </span>            : 
<span class="lineNum">     583 </span>            :   /* Dump ROOT, a list or tree of case nodes, to file F.  */
<span class="lineNum">     584 </span>            :   static void dump_case_nodes (FILE *f, case_tree_node *root, int indent_step,
<span class="lineNum">     585 </span>            :                                int indent_level);
<span class="lineNum">     586 </span>            : 
<span class="lineNum">     587 </span>            :   /* Add an unconditional jump to CASE_BB that happens in basic block BB.  */
<span class="lineNum">     588 </span>            :   static void emit_jump (basic_block bb, basic_block case_bb);
<span class="lineNum">     589 </span>            : 
<span class="lineNum">     590 </span>            :   /* Generate code to compare OP0 with OP1 so that the condition codes are
<span class="lineNum">     591 </span>            :      set and to jump to LABEL_BB if the condition is true.
<span class="lineNum">     592 </span>            :      COMPARISON is the GIMPLE comparison (EQ, NE, GT, etc.).
<span class="lineNum">     593 </span>            :      PROB is the probability of jumping to LABEL_BB.  */
<span class="lineNum">     594 </span>            :   static basic_block emit_cmp_and_jump_insns (basic_block bb, tree op0,
<span class="lineNum">     595 </span>            :                                               tree op1, tree_code comparison,
<span class="lineNum">     596 </span>            :                                               basic_block label_bb,
<span class="lineNum">     597 </span>            :                                               profile_probability prob);
<span class="lineNum">     598 </span>            : 
<span class="lineNum">     599 </span>            :   /* Generate code to jump to LABEL if OP0 and OP1 are equal in mode MODE.
<span class="lineNum">     600 </span>            :      PROB is the probability of jumping to LABEL_BB.  */
<span class="lineNum">     601 </span>            :   static basic_block do_jump_if_equal (basic_block bb, tree op0, tree op1,
<span class="lineNum">     602 </span>            :                                        basic_block label_bb,
<span class="lineNum">     603 </span>            :                                        profile_probability prob);
<span class="lineNum">     604 </span>            : 
<span class="lineNum">     605 </span>            :   /* Reset the aux field of all outgoing edges of switch basic block.  */
<span class="lineNum">     606 </span>            :   static inline void reset_out_edges_aux (gswitch *swtch);
<span class="lineNum">     607 </span>            : 
<span class="lineNum">     608 </span>            :   /* Switch statement.  */
<span class="lineNum">     609 </span>            :   gswitch *m_switch;
<span class="lineNum">     610 </span>            : 
<span class="lineNum">     611 </span>            :   /* Map of PHI nodes that have to be fixed after expansion.  */
<span class="lineNum">     612 </span>            :   hash_map&lt;tree, tree&gt; m_phi_mapping;
<span class="lineNum">     613 </span>            : 
<span class="lineNum">     614 </span>            :   /* List of basic blocks that belong to labels of the switch.  */
<span class="lineNum">     615 </span>            :   auto_vec&lt;basic_block&gt; m_case_bbs;
<span class="lineNum">     616 </span>            : 
<span class="lineNum">     617 </span>            :   /* Basic block with default label.  */
<span class="lineNum">     618 </span>            :   basic_block m_default_bb;
<span class="lineNum">     619 </span>            : 
<span class="lineNum">     620 </span>            :   /* A pool for case nodes.  */
<span class="lineNum">     621 </span>            :   object_allocator&lt;case_tree_node&gt; m_case_node_pool;
<span class="lineNum">     622 </span>            : 
<span class="lineNum">     623 </span>            :   /* Balanced tree of case nodes.  */
<span class="lineNum">     624 </span>            :   case_tree_node *m_case_list;
<span class="lineNum">     625 </span>            : };
<span class="lineNum">     626 </span>            : 
<span class="lineNum">     627 </span>            : /*
<span class="lineNum">     628 </span>            :      Switch initialization conversion
<span class="lineNum">     629 </span>            : 
<span class="lineNum">     630 </span>            : The following pass changes simple initializations of scalars in a switch
<span class="lineNum">     631 </span>            : statement into initializations from a static array.  Obviously, the values
<span class="lineNum">     632 </span>            : must be constant and known at compile time and a default branch must be
<span class="lineNum">     633 </span>            : provided.  For example, the following code:
<span class="lineNum">     634 </span>            : 
<span class="lineNum">     635 </span>            :         int a,b;
<span class="lineNum">     636 </span>            : 
<span class="lineNum">     637 </span>            :         switch (argc)
<span class="lineNum">     638 </span>            :         {
<span class="lineNum">     639 </span>            :          case 1:
<span class="lineNum">     640 </span>            :          case 2:
<span class="lineNum">     641 </span>            :                 a_1 = 8;
<span class="lineNum">     642 </span>            :                 b_1 = 6;
<span class="lineNum">     643 </span>            :                 break;
<span class="lineNum">     644 </span>            :          case 3:
<span class="lineNum">     645 </span>            :                 a_2 = 9;
<span class="lineNum">     646 </span>            :                 b_2 = 5;
<span class="lineNum">     647 </span>            :                 break;
<span class="lineNum">     648 </span>            :          case 12:
<span class="lineNum">     649 </span>            :                 a_3 = 10;
<span class="lineNum">     650 </span>            :                 b_3 = 4;
<span class="lineNum">     651 </span>            :                 break;
<span class="lineNum">     652 </span>            :          default:
<span class="lineNum">     653 </span>            :                 a_4 = 16;
<span class="lineNum">     654 </span>            :                 b_4 = 1;
<span class="lineNum">     655 </span>            :                 break;
<span class="lineNum">     656 </span>            :         }
<span class="lineNum">     657 </span>            :         a_5 = PHI &lt;a_1, a_2, a_3, a_4&gt;
<span class="lineNum">     658 </span>            :         b_5 = PHI &lt;b_1, b_2, b_3, b_4&gt;
<span class="lineNum">     659 </span>            : 
<span class="lineNum">     660 </span>            : 
<span class="lineNum">     661 </span>            : is changed into:
<span class="lineNum">     662 </span>            : 
<span class="lineNum">     663 </span>            :         static const int = CSWTCH01[] = {6, 6, 5, 1, 1, 1, 1, 1, 1, 1, 1, 4};
<span class="lineNum">     664 </span>            :         static const int = CSWTCH02[] = {8, 8, 9, 16, 16, 16, 16, 16, 16, 16,
<span class="lineNum">     665 </span>            :                                  16, 16, 10};
<span class="lineNum">     666 </span>            : 
<span class="lineNum">     667 </span>            :         if (((unsigned) argc) - 1 &lt; 11)
<span class="lineNum">     668 </span>            :           {
<span class="lineNum">     669 </span>            :             a_6 = CSWTCH02[argc - 1];
<span class="lineNum">     670 </span>            :             b_6 = CSWTCH01[argc - 1];
<span class="lineNum">     671 </span>            :           }
<span class="lineNum">     672 </span>            :         else
<span class="lineNum">     673 </span>            :           {
<span class="lineNum">     674 </span>            :             a_7 = 16;
<span class="lineNum">     675 </span>            :             b_7 = 1;
<span class="lineNum">     676 </span>            :           }
<span class="lineNum">     677 </span>            :         a_5 = PHI &lt;a_6, a_7&gt;
<span class="lineNum">     678 </span>            :         b_b = PHI &lt;b_6, b_7&gt;
<span class="lineNum">     679 </span>            : 
<span class="lineNum">     680 </span>            : There are further constraints.  Specifically, the range of values across all
<span class="lineNum">     681 </span>            : case labels must not be bigger than SWITCH_CONVERSION_BRANCH_RATIO (default
<span class="lineNum">     682 </span>            : eight) times the number of the actual switch branches.
<span class="lineNum">     683 </span>            : 
<span class="lineNum">     684 </span>            : This transformation was contributed by Martin Jambor, see this e-mail:
<span class="lineNum">     685 </span>            :    http://gcc.gnu.org/ml/gcc-patches/2008-07/msg00011.html  */
<span class="lineNum">     686 </span>            : 
<span class="lineNum">     687 </span>            : /* The main structure of the pass.  */
<span class="lineNum">     688 </span>            : struct switch_conversion
<span class="lineNum">     689 </span>            : {
<span class="lineNum">     690 </span>            :   /* Constructor.  */
<span class="lineNum">     691 </span>            :   switch_conversion ();
<span class="lineNum">     692 </span>            : 
<span class="lineNum">     693 </span>            :   /* Destructor.  */
<span class="lineNum">     694 </span>            :   ~switch_conversion ();
<span class="lineNum">     695 </span>            : 
<span class="lineNum">     696 </span>            :   /* The following function is invoked on every switch statement (the current
<span class="lineNum">     697 </span>            :      one is given in SWTCH) and runs the individual phases of switch
<span class="lineNum">     698 </span>            :      conversion on it one after another until one fails or the conversion
<span class="lineNum">     699 </span>            :      is completed.  On success, NULL is in m_reason, otherwise points
<span class="lineNum">     700 </span>            :      to a string with the reason why the conversion failed.  */
<span class="lineNum">     701 </span>            :   void expand (gswitch *swtch);
<span class="lineNum">     702 </span>            : 
<span class="lineNum">     703 </span>            :   /* Collection information about SWTCH statement.  */
<span class="lineNum">     704 </span>            :   void collect (gswitch *swtch);
<span class="lineNum">     705 </span>            : 
<span class="lineNum">     706 </span>            :   /* Checks whether the range given by individual case statements of the switch
<span class="lineNum">     707 </span>            :      switch statement isn't too big and whether the number of branches actually
<span class="lineNum">     708 </span>            :      satisfies the size of the new array.  */
<span class="lineNum">     709 </span>            :   bool check_range ();
<span class="lineNum">     710 </span>            : 
<span class="lineNum">     711 </span>            :   /* Checks whether all but the final BB basic blocks are empty.  */
<span class="lineNum">     712 </span>            :   bool check_all_empty_except_final ();
<span class="lineNum">     713 </span>            : 
<span class="lineNum">     714 </span>            :   /* This function checks whether all required values in phi nodes in final_bb
<span class="lineNum">     715 </span>            :      are constants.  Required values are those that correspond to a basic block
<span class="lineNum">     716 </span>            :      which is a part of the examined switch statement.  It returns true if the
<span class="lineNum">     717 </span>            :      phi nodes are OK, otherwise false.  */
<span class="lineNum">     718 </span>            :   bool check_final_bb ();
<span class="lineNum">     719 </span>            : 
<span class="lineNum">     720 </span>            :   /* The following function allocates default_values, target_{in,out}_names and
<span class="lineNum">     721 </span>            :      constructors arrays.  The last one is also populated with pointers to
<span class="lineNum">     722 </span>            :      vectors that will become constructors of new arrays.  */
<span class="lineNum">     723 </span>            :   void create_temp_arrays ();
<span class="lineNum">     724 </span>            : 
<span class="lineNum">     725 </span>            :   /* Populate the array of default values in the order of phi nodes.
<span class="lineNum">     726 </span>            :      DEFAULT_CASE is the CASE_LABEL_EXPR for the default switch branch
<span class="lineNum">     727 </span>            :      if the range is non-contiguous or the default case has standard
<span class="lineNum">     728 </span>            :      structure, otherwise it is the first non-default case instead.  */
<span class="lineNum">     729 </span>            :   void gather_default_values (tree default_case);
<span class="lineNum">     730 </span>            : 
<span class="lineNum">     731 </span>            :   /* The following function populates the vectors in the constructors array with
<span class="lineNum">     732 </span>            :      future contents of the static arrays.  The vectors are populated in the
<span class="lineNum">     733 </span>            :      order of phi nodes.  */
<span class="lineNum">     734 </span>            :   void build_constructors ();
<span class="lineNum">     735 </span>            : 
<span class="lineNum">     736 </span>            :   /* If all values in the constructor vector are the same, return the value.
<span class="lineNum">     737 </span>            :      Otherwise return NULL_TREE.  Not supposed to be called for empty
<span class="lineNum">     738 </span>            :      vectors.  */
<span class="lineNum">     739 </span>            :   tree contains_same_values_p (vec&lt;constructor_elt, va_gc&gt; *vec);
<span class="lineNum">     740 </span>            : 
<span class="lineNum">     741 </span>            :   /* Return type which should be used for array elements, either TYPE's
<span class="lineNum">     742 </span>            :      main variant or, for integral types, some smaller integral type
<span class="lineNum">     743 </span>            :      that can still hold all the constants.  */
<span class="lineNum">     744 </span>            :   tree array_value_type (tree type, int num);
<span class="lineNum">     745 </span>            : 
<span class="lineNum">     746 </span>            :   /* Create an appropriate array type and declaration and assemble a static
<span class="lineNum">     747 </span>            :      array variable.  Also create a load statement that initializes
<span class="lineNum">     748 </span>            :      the variable in question with a value from the static array.  SWTCH is
<span class="lineNum">     749 </span>            :      the switch statement being converted, NUM is the index to
<span class="lineNum">     750 </span>            :      arrays of constructors, default values and target SSA names
<span class="lineNum">     751 </span>            :      for this particular array.  ARR_INDEX_TYPE is the type of the index
<span class="lineNum">     752 </span>            :      of the new array, PHI is the phi node of the final BB that corresponds
<span class="lineNum">     753 </span>            :      to the value that will be loaded from the created array.  TIDX
<span class="lineNum">     754 </span>            :      is an ssa name of a temporary variable holding the index for loads from the
<span class="lineNum">     755 </span>            :      new array.  */
<span class="lineNum">     756 </span>            :   void build_one_array (int num, tree arr_index_type,
<span class="lineNum">     757 </span>            :                         gphi *phi, tree tidx);
<span class="lineNum">     758 </span>            : 
<span class="lineNum">     759 </span>            :   /* Builds and initializes static arrays initialized with values gathered from
<span class="lineNum">     760 </span>            :      the switch statement.  Also creates statements that load values from
<span class="lineNum">     761 </span>            :      them.  */
<span class="lineNum">     762 </span>            :   void build_arrays ();
<span class="lineNum">     763 </span>            : 
<span class="lineNum">     764 </span>            :   /* Generates and appropriately inserts loads of default values at the position
<span class="lineNum">     765 </span>            :      given by GSI.  Returns the last inserted statement.  */
<span class="lineNum">     766 </span>            :   gassign *gen_def_assigns (gimple_stmt_iterator *gsi);
<span class="lineNum">     767 </span>            : 
<span class="lineNum">     768 </span>            :   /* Deletes the unused bbs and edges that now contain the switch statement and
<span class="lineNum">     769 </span>            :      its empty branch bbs.  BBD is the now dead BB containing
<span class="lineNum">     770 </span>            :      the original switch statement, FINAL is the last BB of the converted
<span class="lineNum">     771 </span>            :      switch statement (in terms of succession).  */
<span class="lineNum">     772 </span>            :   void prune_bbs (basic_block bbd, basic_block final, basic_block default_bb);
<span class="lineNum">     773 </span>            : 
<span class="lineNum">     774 </span>            :   /* Add values to phi nodes in final_bb for the two new edges.  E1F is the edge
<span class="lineNum">     775 </span>            :      from the basic block loading values from an array and E2F from the basic
<span class="lineNum">     776 </span>            :      block loading default values.  BBF is the last switch basic block (see the
<span class="lineNum">     777 </span>            :      bbf description in the comment below).  */
<span class="lineNum">     778 </span>            :   void fix_phi_nodes (edge e1f, edge e2f, basic_block bbf);
<span class="lineNum">     779 </span>            : 
<span class="lineNum">     780 </span>            :   /* Creates a check whether the switch expression value actually falls into the
<span class="lineNum">     781 </span>            :      range given by all the cases.  If it does not, the temporaries are loaded
<span class="lineNum">     782 </span>            :      with default values instead.  */
<span class="lineNum">     783 </span>            :   void gen_inbound_check ();
<span class="lineNum">     784 </span>            : 
<span class="lineNum">     785 </span>            :   /* Switch statement for which switch conversion takes place.  */
<span class="lineNum">     786 </span>            :   gswitch *m_switch;
<span class="lineNum">     787 </span>            : 
<span class="lineNum">     788 </span>            :   /* The expression used to decide the switch branch.  */
<span class="lineNum">     789 </span>            :   tree m_index_expr;
<span class="lineNum">     790 </span>            : 
<span class="lineNum">     791 </span>            :   /* The following integer constants store the minimum and maximum value
<span class="lineNum">     792 </span>            :      covered by the case labels.  */
<span class="lineNum">     793 </span>            :   tree m_range_min;
<span class="lineNum">     794 </span>            :   tree m_range_max;
<span class="lineNum">     795 </span>            : 
<span class="lineNum">     796 </span>            :   /* The difference between the above two numbers.  Stored here because it
<span class="lineNum">     797 </span>            :      is used in all the conversion heuristics, as well as for some of the
<span class="lineNum">     798 </span>            :      transformation, and it is expensive to re-compute it all the time.  */
<span class="lineNum">     799 </span>            :   tree m_range_size;
<span class="lineNum">     800 </span>            : 
<span class="lineNum">     801 </span>            :   /* Basic block that contains the actual GIMPLE_SWITCH.  */
<span class="lineNum">     802 </span>            :   basic_block m_switch_bb;
<span class="lineNum">     803 </span>            : 
<span class="lineNum">     804 </span>            :   /* Basic block that is the target of the default case.  */
<span class="lineNum">     805 </span>            :   basic_block m_default_bb;
<span class="lineNum">     806 </span>            : 
<span class="lineNum">     807 </span>            :   /* The single successor block of all branches out of the GIMPLE_SWITCH,
<span class="lineNum">     808 </span>            :      if such a block exists.  Otherwise NULL.  */
<span class="lineNum">     809 </span>            :   basic_block m_final_bb;
<span class="lineNum">     810 </span>            : 
<span class="lineNum">     811 </span>            :   /* The probability of the default edge in the replaced switch.  */
<span class="lineNum">     812 </span>            :   profile_probability m_default_prob;
<span class="lineNum">     813 </span>            : 
<span class="lineNum">     814 </span>            :   /* The count of the default edge in the replaced switch.  */
<span class="lineNum">     815 </span>            :   profile_count m_default_count;
<span class="lineNum">     816 </span>            : 
<span class="lineNum">     817 </span>            :   /* Combined count of all other (non-default) edges in the replaced switch.  */
<span class="lineNum">     818 </span>            :   profile_count m_other_count;
<span class="lineNum">     819 </span>            : 
<span class="lineNum">     820 </span>            :   /* Number of phi nodes in the final bb (that we'll be replacing).  */
<span class="lineNum">     821 </span>            :   int m_phi_count;
<span class="lineNum">     822 </span>            : 
<span class="lineNum">     823 </span>            :   /* Constructors of new static arrays.  */
<span class="lineNum">     824 </span>            :   vec&lt;constructor_elt, va_gc&gt; **m_constructors;
<span class="lineNum">     825 </span>            : 
<span class="lineNum">     826 </span>            :   /* Array of default values, in the same order as phi nodes.  */
<span class="lineNum">     827 </span>            :   tree *m_default_values;
<span class="lineNum">     828 </span>            : 
<span class="lineNum">     829 </span>            :   /* Array of ssa names that are initialized with a value from a new static
<span class="lineNum">     830 </span>            :      array.  */
<span class="lineNum">     831 </span>            :   tree *m_target_inbound_names;
<span class="lineNum">     832 </span>            : 
<span class="lineNum">     833 </span>            :   /* Array of ssa names that are initialized with the default value if the
<span class="lineNum">     834 </span>            :      switch expression is out of range.  */
<span class="lineNum">     835 </span>            :   tree *m_target_outbound_names;
<span class="lineNum">     836 </span>            : 
<span class="lineNum">     837 </span>            :   /* VOP SSA_NAME.  */
<span class="lineNum">     838 </span>            :   tree m_target_vop;
<span class="lineNum">     839 </span>            : 
<span class="lineNum">     840 </span>            :   /* The first load statement that loads a temporary from a new static array.
<span class="lineNum">     841 </span>            :    */
<span class="lineNum">     842 </span>            :   gimple *m_arr_ref_first;
<span class="lineNum">     843 </span>            : 
<span class="lineNum">     844 </span>            :   /* The last load statement that loads a temporary from a new static array.  */
<span class="lineNum">     845 </span>            :   gimple *m_arr_ref_last;
<span class="lineNum">     846 </span>            : 
<span class="lineNum">     847 </span>            :   /* String reason why the case wasn't a good candidate that is written to the
<span class="lineNum">     848 </span>            :      dump file, if there is one.  */
<span class="lineNum">     849 </span>            :   const char *m_reason;
<span class="lineNum">     850 </span>            : 
<span class="lineNum">     851 </span>            :   /* True if default case is not used for any value between range_min and
<span class="lineNum">     852 </span>            :      range_max inclusive.  */
<span class="lineNum">     853 </span>            :   bool m_contiguous_range;
<span class="lineNum">     854 </span>            : 
<span class="lineNum">     855 </span>            :   /* True if default case does not have the required shape for other case
<span class="lineNum">     856 </span>            :      labels.  */
<span class="lineNum">     857 </span>            :   bool m_default_case_nonstandard;
<span class="lineNum">     858 </span>            : 
<span class="lineNum">     859 </span>            :   /* Number of uniq labels for non-default edges.  */
<span class="lineNum">     860 </span>            :   unsigned int m_uniq;
<span class="lineNum">     861 </span>            : 
<span class="lineNum">     862 </span>            :   /* Count is number of non-default edges.  */
<span class="lineNum">     863 </span>            :   unsigned int m_count;
<span class="lineNum">     864 </span>            : 
<span class="lineNum">     865 </span>            :   /* True if CFG has been changed.  */
<span class="lineNum">     866 </span>            :   bool m_cfg_altered;
<span class="lineNum">     867 </span>            : };
<a name="868"><span class="lineNum">     868 </span>            : </a>
<span class="lineNum">     869 </span>            : void
<span class="lineNum">     870 </span>            : switch_decision_tree::reset_out_edges_aux (gswitch *swtch)
<span class="lineNum">     871 </span>            : {
<span class="lineNum">     872 </span>            :   basic_block bb = gimple_bb (swtch);
<span class="lineNum">     873 </span>            :   edge e;
<span class="lineNum">     874 </span>            :   edge_iterator ei;
<span class="lineNum">     875 </span>            :   FOR_EACH_EDGE (e, ei, bb-&gt;succs)
<span class="lineNum">     876 </span>            :     e-&gt;aux = (void *) 0;
<span class="lineNum">     877 </span>            : }
<span class="lineNum">     878 </span><span class="lineCov">      54636 : </span>
<span class="lineNum">     879 </span>            : } // tree_switch_conversion namespace
<span class="lineNum">     880 </span><span class="lineCov">      54636 : </span>
<span class="lineNum">     881 </span><span class="lineCov">      54636 : #endif // TREE_SWITCH_CONVERSION_H</span>
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.0</a></td></tr>
  </table>
  <br>
<h3>LCOV profile is generated on x86_64 machine using following configure options: configure --disable-bootstrap --enable-coverage=opt --enable-languages=c,c++,fortran,go,jit,lto --enable-host-shared. GCC test suite is run with the built compiler.</h3></body></html>
