<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - gcc.info - gcc/tree-ssa-reassoc.c</title>
  <link rel="stylesheet" type="text/css" href="../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../index.html">top level</a> - <a href="index.html">gcc</a> - tree-ssa-reassoc.c<span style="font-size: 80%;"> (source / <a href="tree-ssa-reassoc.c.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">gcc.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">2715</td>
            <td class="headerCovTableEntry">2945</td>
            <td class="headerCovTableEntryHi">92.2 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2018-09-22 10:58:49</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">90</td>
            <td class="headerCovTableEntry">93</td>
            <td class="headerCovTableEntryHi">96.8 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /* Reassociation for trees.</a>
<span class="lineNum">       2 </span>            :    Copyright (C) 2005-2018 Free Software Foundation, Inc.
<span class="lineNum">       3 </span>            :    Contributed by Daniel Berlin &lt;dan@dberlin.org&gt;
<span class="lineNum">       4 </span>            : 
<span class="lineNum">       5 </span>            : This file is part of GCC.
<span class="lineNum">       6 </span>            : 
<span class="lineNum">       7 </span>            : GCC is free software; you can redistribute it and/or modify
<span class="lineNum">       8 </span>            : it under the terms of the GNU General Public License as published by
<span class="lineNum">       9 </span>            : the Free Software Foundation; either version 3, or (at your option)
<span class="lineNum">      10 </span>            : any later version.
<span class="lineNum">      11 </span>            : 
<span class="lineNum">      12 </span>            : GCC is distributed in the hope that it will be useful,
<span class="lineNum">      13 </span>            : but WITHOUT ANY WARRANTY; without even the implied warranty of
<span class="lineNum">      14 </span>            : MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
<span class="lineNum">      15 </span>            : GNU General Public License for more details.
<span class="lineNum">      16 </span>            : 
<span class="lineNum">      17 </span>            : You should have received a copy of the GNU General Public License
<span class="lineNum">      18 </span>            : along with GCC; see the file COPYING3.  If not see
<span class="lineNum">      19 </span>            : &lt;http://www.gnu.org/licenses/&gt;.  */
<span class="lineNum">      20 </span>            : 
<span class="lineNum">      21 </span>            : #include &quot;config.h&quot;
<span class="lineNum">      22 </span>            : #include &quot;system.h&quot;
<span class="lineNum">      23 </span>            : #include &quot;coretypes.h&quot;
<span class="lineNum">      24 </span>            : #include &quot;backend.h&quot;
<span class="lineNum">      25 </span>            : #include &quot;target.h&quot;
<span class="lineNum">      26 </span>            : #include &quot;rtl.h&quot;
<span class="lineNum">      27 </span>            : #include &quot;tree.h&quot;
<span class="lineNum">      28 </span>            : #include &quot;gimple.h&quot;
<span class="lineNum">      29 </span>            : #include &quot;cfghooks.h&quot;
<span class="lineNum">      30 </span>            : #include &quot;alloc-pool.h&quot;
<span class="lineNum">      31 </span>            : #include &quot;tree-pass.h&quot;
<span class="lineNum">      32 </span>            : #include &quot;memmodel.h&quot;
<span class="lineNum">      33 </span>            : #include &quot;tm_p.h&quot;
<span class="lineNum">      34 </span>            : #include &quot;ssa.h&quot;
<span class="lineNum">      35 </span>            : #include &quot;optabs-tree.h&quot;
<span class="lineNum">      36 </span>            : #include &quot;gimple-pretty-print.h&quot;
<span class="lineNum">      37 </span>            : #include &quot;diagnostic-core.h&quot;
<span class="lineNum">      38 </span>            : #include &quot;fold-const.h&quot;
<span class="lineNum">      39 </span>            : #include &quot;stor-layout.h&quot;
<span class="lineNum">      40 </span>            : #include &quot;cfganal.h&quot;
<span class="lineNum">      41 </span>            : #include &quot;gimple-fold.h&quot;
<span class="lineNum">      42 </span>            : #include &quot;tree-eh.h&quot;
<span class="lineNum">      43 </span>            : #include &quot;gimple-iterator.h&quot;
<span class="lineNum">      44 </span>            : #include &quot;gimplify-me.h&quot;
<span class="lineNum">      45 </span>            : #include &quot;tree-cfg.h&quot;
<span class="lineNum">      46 </span>            : #include &quot;tree-ssa-loop.h&quot;
<span class="lineNum">      47 </span>            : #include &quot;flags.h&quot;
<span class="lineNum">      48 </span>            : #include &quot;tree-ssa.h&quot;
<span class="lineNum">      49 </span>            : #include &quot;langhooks.h&quot;
<span class="lineNum">      50 </span>            : #include &quot;cfgloop.h&quot;
<span class="lineNum">      51 </span>            : #include &quot;params.h&quot;
<span class="lineNum">      52 </span>            : #include &quot;builtins.h&quot;
<span class="lineNum">      53 </span>            : #include &quot;gimplify.h&quot;
<span class="lineNum">      54 </span>            : #include &quot;case-cfn-macros.h&quot;
<span class="lineNum">      55 </span>            : 
<span class="lineNum">      56 </span>            : /*  This is a simple global reassociation pass.  It is, in part, based
<span class="lineNum">      57 </span>            :     on the LLVM pass of the same name (They do some things more/less
<span class="lineNum">      58 </span>            :     than we do, in different orders, etc).
<span class="lineNum">      59 </span>            : 
<span class="lineNum">      60 </span>            :     It consists of five steps:
<span class="lineNum">      61 </span>            : 
<span class="lineNum">      62 </span>            :     1. Breaking up subtract operations into addition + negate, where
<span class="lineNum">      63 </span>            :     it would promote the reassociation of adds.
<span class="lineNum">      64 </span>            : 
<span class="lineNum">      65 </span>            :     2. Left linearization of the expression trees, so that (A+B)+(C+D)
<span class="lineNum">      66 </span>            :     becomes (((A+B)+C)+D), which is easier for us to rewrite later.
<span class="lineNum">      67 </span>            :     During linearization, we place the operands of the binary
<span class="lineNum">      68 </span>            :     expressions into a vector of operand_entry_*
<span class="lineNum">      69 </span>            : 
<span class="lineNum">      70 </span>            :     3. Optimization of the operand lists, eliminating things like a +
<span class="lineNum">      71 </span>            :     -a, a &amp; a, etc.
<span class="lineNum">      72 </span>            : 
<span class="lineNum">      73 </span>            :     3a. Combine repeated factors with the same occurrence counts
<span class="lineNum">      74 </span>            :     into a __builtin_powi call that will later be optimized into
<span class="lineNum">      75 </span>            :     an optimal number of multiplies.
<span class="lineNum">      76 </span>            : 
<span class="lineNum">      77 </span>            :     4. Rewrite the expression trees we linearized and optimized so
<span class="lineNum">      78 </span>            :     they are in proper rank order.
<span class="lineNum">      79 </span>            : 
<span class="lineNum">      80 </span>            :     5. Repropagate negates, as nothing else will clean it up ATM.
<span class="lineNum">      81 </span>            : 
<span class="lineNum">      82 </span>            :     A bit of theory on #4, since nobody seems to write anything down
<span class="lineNum">      83 </span>            :     about why it makes sense to do it the way they do it:
<span class="lineNum">      84 </span>            : 
<span class="lineNum">      85 </span>            :     We could do this much nicer theoretically, but don't (for reasons
<span class="lineNum">      86 </span>            :     explained after how to do it theoretically nice :P).
<span class="lineNum">      87 </span>            : 
<span class="lineNum">      88 </span>            :     In order to promote the most redundancy elimination, you want
<span class="lineNum">      89 </span>            :     binary expressions whose operands are the same rank (or
<span class="lineNum">      90 </span>            :     preferably, the same value) exposed to the redundancy eliminator,
<span class="lineNum">      91 </span>            :     for possible elimination.
<span class="lineNum">      92 </span>            : 
<span class="lineNum">      93 </span>            :     So the way to do this if we really cared, is to build the new op
<span class="lineNum">      94 </span>            :     tree from the leaves to the roots, merging as you go, and putting the
<span class="lineNum">      95 </span>            :     new op on the end of the worklist, until you are left with one
<span class="lineNum">      96 </span>            :     thing on the worklist.
<span class="lineNum">      97 </span>            : 
<span class="lineNum">      98 </span>            :     IE if you have to rewrite the following set of operands (listed with
<span class="lineNum">      99 </span>            :     rank in parentheses), with opcode PLUS_EXPR:
<span class="lineNum">     100 </span>            : 
<span class="lineNum">     101 </span>            :     a (1),  b (1),  c (1),  d (2), e (2)
<span class="lineNum">     102 </span>            : 
<span class="lineNum">     103 </span>            : 
<span class="lineNum">     104 </span>            :     We start with our merge worklist empty, and the ops list with all of
<span class="lineNum">     105 </span>            :     those on it.
<span class="lineNum">     106 </span>            : 
<span class="lineNum">     107 </span>            :     You want to first merge all leaves of the same rank, as much as
<span class="lineNum">     108 </span>            :     possible.
<span class="lineNum">     109 </span>            : 
<span class="lineNum">     110 </span>            :     So first build a binary op of
<span class="lineNum">     111 </span>            : 
<span class="lineNum">     112 </span>            :     mergetmp = a + b, and put &quot;mergetmp&quot; on the merge worklist.
<span class="lineNum">     113 </span>            : 
<span class="lineNum">     114 </span>            :     Because there is no three operand form of PLUS_EXPR, c is not going to
<span class="lineNum">     115 </span>            :     be exposed to redundancy elimination as a rank 1 operand.
<span class="lineNum">     116 </span>            : 
<span class="lineNum">     117 </span>            :     So you might as well throw it on the merge worklist (you could also
<span class="lineNum">     118 </span>            :     consider it to now be a rank two operand, and merge it with d and e,
<span class="lineNum">     119 </span>            :     but in this case, you then have evicted e from a binary op. So at
<span class="lineNum">     120 </span>            :     least in this situation, you can't win.)
<span class="lineNum">     121 </span>            : 
<span class="lineNum">     122 </span>            :     Then build a binary op of d + e
<span class="lineNum">     123 </span>            :     mergetmp2 = d + e
<span class="lineNum">     124 </span>            : 
<span class="lineNum">     125 </span>            :     and put mergetmp2 on the merge worklist.
<span class="lineNum">     126 </span>            : 
<span class="lineNum">     127 </span>            :     so merge worklist = {mergetmp, c, mergetmp2}
<span class="lineNum">     128 </span>            : 
<span class="lineNum">     129 </span>            :     Continue building binary ops of these operations until you have only
<span class="lineNum">     130 </span>            :     one operation left on the worklist.
<span class="lineNum">     131 </span>            : 
<span class="lineNum">     132 </span>            :     So we have
<span class="lineNum">     133 </span>            : 
<span class="lineNum">     134 </span>            :     build binary op
<span class="lineNum">     135 </span>            :     mergetmp3 = mergetmp + c
<span class="lineNum">     136 </span>            : 
<span class="lineNum">     137 </span>            :     worklist = {mergetmp2, mergetmp3}
<span class="lineNum">     138 </span>            : 
<span class="lineNum">     139 </span>            :     mergetmp4 = mergetmp2 + mergetmp3
<span class="lineNum">     140 </span>            : 
<span class="lineNum">     141 </span>            :     worklist = {mergetmp4}
<span class="lineNum">     142 </span>            : 
<span class="lineNum">     143 </span>            :     because we have one operation left, we can now just set the original
<span class="lineNum">     144 </span>            :     statement equal to the result of that operation.
<span class="lineNum">     145 </span>            : 
<span class="lineNum">     146 </span>            :     This will at least expose a + b  and d + e to redundancy elimination
<span class="lineNum">     147 </span>            :     as binary operations.
<span class="lineNum">     148 </span>            : 
<span class="lineNum">     149 </span>            :     For extra points, you can reuse the old statements to build the
<span class="lineNum">     150 </span>            :     mergetmps, since you shouldn't run out.
<span class="lineNum">     151 </span>            : 
<span class="lineNum">     152 </span>            :     So why don't we do this?
<span class="lineNum">     153 </span>            : 
<span class="lineNum">     154 </span>            :     Because it's expensive, and rarely will help.  Most trees we are
<span class="lineNum">     155 </span>            :     reassociating have 3 or less ops.  If they have 2 ops, they already
<span class="lineNum">     156 </span>            :     will be written into a nice single binary op.  If you have 3 ops, a
<span class="lineNum">     157 </span>            :     single simple check suffices to tell you whether the first two are of the
<span class="lineNum">     158 </span>            :     same rank.  If so, you know to order it
<span class="lineNum">     159 </span>            : 
<span class="lineNum">     160 </span>            :     mergetmp = op1 + op2
<span class="lineNum">     161 </span>            :     newstmt = mergetmp + op3
<span class="lineNum">     162 </span>            : 
<span class="lineNum">     163 </span>            :     instead of
<span class="lineNum">     164 </span>            :     mergetmp = op2 + op3
<span class="lineNum">     165 </span>            :     newstmt = mergetmp + op1
<span class="lineNum">     166 </span>            : 
<span class="lineNum">     167 </span>            :     If all three are of the same rank, you can't expose them all in a
<span class="lineNum">     168 </span>            :     single binary operator anyway, so the above is *still* the best you
<span class="lineNum">     169 </span>            :     can do.
<span class="lineNum">     170 </span>            : 
<span class="lineNum">     171 </span>            :     Thus, this is what we do.  When we have three ops left, we check to see
<span class="lineNum">     172 </span>            :     what order to put them in, and call it a day.  As a nod to vector sum
<span class="lineNum">     173 </span>            :     reduction, we check if any of the ops are really a phi node that is a
<span class="lineNum">     174 </span>            :     destructive update for the associating op, and keep the destructive
<span class="lineNum">     175 </span>            :     update together for vector sum reduction recognition.  */
<span class="lineNum">     176 </span>            : 
<span class="lineNum">     177 </span>            : /* Enable insertion of __builtin_powi calls during execute_reassoc.  See
<span class="lineNum">     178 </span>            :    point 3a in the pass header comment.  */
<span class="lineNum">     179 </span>            : static bool reassoc_insert_powi_p;
<span class="lineNum">     180 </span>            : 
<span class="lineNum">     181 </span>            : /* Statistics */
<span class="lineNum">     182 </span>            : static struct
<span class="lineNum">     183 </span>            : {
<span class="lineNum">     184 </span>            :   int linearized;
<span class="lineNum">     185 </span>            :   int constants_eliminated;
<span class="lineNum">     186 </span>            :   int ops_eliminated;
<span class="lineNum">     187 </span>            :   int rewritten;
<span class="lineNum">     188 </span>            :   int pows_encountered;
<span class="lineNum">     189 </span>            :   int pows_created;
<span class="lineNum">     190 </span>            : } reassociate_stats;
<span class="lineNum">     191 </span>            : 
<span class="lineNum">     192 </span>            : /* Operator, rank pair.  */
<span class="lineNum">     193 </span>            : struct operand_entry
<span class="lineNum">     194 </span>            : {
<span class="lineNum">     195 </span>            :   unsigned int rank;
<span class="lineNum">     196 </span>            :   unsigned int id;
<span class="lineNum">     197 </span>            :   tree op;
<span class="lineNum">     198 </span>            :   unsigned int count;
<span class="lineNum">     199 </span>            :   gimple *stmt_to_insert;
<span class="lineNum">     200 </span>            : };
<span class="lineNum">     201 </span>            : 
<span class="lineNum">     202 </span>            : static object_allocator&lt;operand_entry&gt; operand_entry_pool
<span class="lineNum">     203 </span>            :   (&quot;operand entry pool&quot;);
<span class="lineNum">     204 </span>            : 
<span class="lineNum">     205 </span>            : /* This is used to assign a unique ID to each struct operand_entry
<span class="lineNum">     206 </span>            :    so that qsort results are identical on different hosts.  */
<span class="lineNum">     207 </span>            : static unsigned int next_operand_entry_id;
<span class="lineNum">     208 </span>            : 
<span class="lineNum">     209 </span>            : /* Starting rank number for a given basic block, so that we can rank
<span class="lineNum">     210 </span>            :    operations using unmovable instructions in that BB based on the bb
<span class="lineNum">     211 </span>            :    depth.  */
<span class="lineNum">     212 </span>            : static long *bb_rank;
<span class="lineNum">     213 </span>            : 
<span class="lineNum">     214 </span>            : /* Operand-&gt;rank hashtable.  */
<span class="lineNum">     215 </span>            : static hash_map&lt;tree, long&gt; *operand_rank;
<span class="lineNum">     216 </span>            : 
<span class="lineNum">     217 </span>            : /* Vector of SSA_NAMEs on which after reassociate_bb is done with
<span class="lineNum">     218 </span>            :    all basic blocks the CFG should be adjusted - basic blocks
<span class="lineNum">     219 </span>            :    split right after that SSA_NAME's definition statement and before
<span class="lineNum">     220 </span>            :    the only use, which must be a bit ior.  */
<span class="lineNum">     221 </span>            : static vec&lt;tree&gt; reassoc_branch_fixups;
<span class="lineNum">     222 </span>            : 
<span class="lineNum">     223 </span>            : /* Forward decls.  */
<span class="lineNum">     224 </span>            : static long get_rank (tree);
<span class="lineNum">     225 </span>            : static bool reassoc_stmt_dominates_stmt_p (gimple *, gimple *);
<span class="lineNum">     226 </span>            : 
<span class="lineNum">     227 </span>            : /* Wrapper around gsi_remove, which adjusts gimple_uid of debug stmts
<span class="lineNum">     228 </span>            :    possibly added by gsi_remove.  */
<a name="229"><span class="lineNum">     229 </span>            : </a>
<span class="lineNum">     230 </span>            : bool
<span class="lineNum">     231 </span><span class="lineCov">     107126 : reassoc_remove_stmt (gimple_stmt_iterator *gsi)</span>
<span class="lineNum">     232 </span>            : {
<span class="lineNum">     233 </span><span class="lineCov">     107126 :   gimple *stmt = gsi_stmt (*gsi);</span>
<span class="lineNum">     234 </span>            : 
<span class="lineNum">     235 </span><span class="lineCov">     107126 :   if (!MAY_HAVE_DEBUG_BIND_STMTS || gimple_code (stmt) == GIMPLE_PHI)</span>
<span class="lineNum">     236 </span><span class="lineCov">      51428 :     return gsi_remove (gsi, true);</span>
<span class="lineNum">     237 </span>            : 
<span class="lineNum">     238 </span><span class="lineCov">      55698 :   gimple_stmt_iterator prev = *gsi;</span>
<span class="lineNum">     239 </span><span class="lineCov">      55698 :   gsi_prev (&amp;prev);</span>
<span class="lineNum">     240 </span><span class="lineCov">      55698 :   unsigned uid = gimple_uid (stmt);</span>
<span class="lineNum">     241 </span><span class="lineCov">      55698 :   basic_block bb = gimple_bb (stmt);</span>
<span class="lineNum">     242 </span><span class="lineCov">      55698 :   bool ret = gsi_remove (gsi, true);</span>
<span class="lineNum">     243 </span><span class="lineCov">     111396 :   if (!gsi_end_p (prev))</span>
<span class="lineNum">     244 </span><span class="lineCov">      54947 :     gsi_next (&amp;prev);</span>
<span class="lineNum">     245 </span>            :   else
<span class="lineNum">     246 </span><span class="lineCov">       1502 :     prev = gsi_start_bb (bb);</span>
<span class="lineNum">     247 </span><span class="lineCov">     111396 :   gimple *end_stmt = gsi_stmt (*gsi);</span>
<span class="lineNum">     248 </span><span class="lineCov">     115060 :   while ((stmt = gsi_stmt (prev)) != end_stmt)</span>
<span class="lineNum">     249 </span>            :     {
<span class="lineNum">     250 </span><span class="lineCov">       1832 :       gcc_assert (stmt &amp;&amp; is_gimple_debug (stmt) &amp;&amp; gimple_uid (stmt) == 0);</span>
<span class="lineNum">     251 </span><span class="lineCov">       1832 :       gimple_set_uid (stmt, uid);</span>
<span class="lineNum">     252 </span><span class="lineCov">       1832 :       gsi_next (&amp;prev);</span>
<span class="lineNum">     253 </span>            :     }
<span class="lineNum">     254 </span>            :   return ret;
<span class="lineNum">     255 </span>            : }
<span class="lineNum">     256 </span>            : 
<span class="lineNum">     257 </span>            : /* Bias amount for loop-carried phis.  We want this to be larger than
<span class="lineNum">     258 </span>            :    the depth of any reassociation tree we can see, but not larger than
<span class="lineNum">     259 </span>            :    the rank difference between two blocks.  */
<span class="lineNum">     260 </span>            : #define PHI_LOOP_BIAS (1 &lt;&lt; 15)
<span class="lineNum">     261 </span>            : 
<span class="lineNum">     262 </span>            : /* Rank assigned to a phi statement.  If STMT is a loop-carried phi of
<span class="lineNum">     263 </span>            :    an innermost loop, and the phi has only a single use which is inside
<span class="lineNum">     264 </span>            :    the loop, then the rank is the block rank of the loop latch plus an
<span class="lineNum">     265 </span>            :    extra bias for the loop-carried dependence.  This causes expressions
<span class="lineNum">     266 </span>            :    calculated into an accumulator variable to be independent for each
<span class="lineNum">     267 </span>            :    iteration of the loop.  If STMT is some other phi, the rank is the
<a name="268"><span class="lineNum">     268 </span>            :    block rank of its containing block.  */</a>
<span class="lineNum">     269 </span>            : static long
<span class="lineNum">     270 </span><span class="lineCov">    1885876 : phi_rank (gimple *stmt)</span>
<span class="lineNum">     271 </span>            : {
<span class="lineNum">     272 </span><span class="lineCov">    1885876 :   basic_block bb = gimple_bb (stmt);</span>
<span class="lineNum">     273 </span><span class="lineCov">    1885876 :   struct loop *father = bb-&gt;loop_father;</span>
<span class="lineNum">     274 </span><span class="lineCov">    1885876 :   tree res;</span>
<span class="lineNum">     275 </span><span class="lineCov">    1885876 :   unsigned i;</span>
<span class="lineNum">     276 </span><span class="lineCov">    1885876 :   use_operand_p use;</span>
<span class="lineNum">     277 </span><span class="lineCov">    1885876 :   gimple *use_stmt;</span>
<span class="lineNum">     278 </span>            : 
<span class="lineNum">     279 </span>            :   /* We only care about real loops (those with a latch).  */
<span class="lineNum">     280 </span><span class="lineCov">    1885876 :   if (!father-&gt;latch)</span>
<span class="lineNum">     281 </span><span class="lineCov">      17231 :     return bb_rank[bb-&gt;index];</span>
<span class="lineNum">     282 </span>            : 
<span class="lineNum">     283 </span>            :   /* Interesting phis must be in headers of innermost loops.  */
<span class="lineNum">     284 </span><span class="lineCov">    1868645 :   if (bb != father-&gt;header</span>
<span class="lineNum">     285 </span><span class="lineCov">    1300782 :       || father-&gt;inner)</span>
<span class="lineNum">     286 </span><span class="lineCov">     929464 :     return bb_rank[bb-&gt;index];</span>
<span class="lineNum">     287 </span>            : 
<span class="lineNum">     288 </span>            :   /* Ignore virtual SSA_NAMEs.  */
<span class="lineNum">     289 </span><span class="lineCov">     939181 :   res = gimple_phi_result (stmt);</span>
<span class="lineNum">     290 </span><span class="lineCov">    1878362 :   if (virtual_operand_p (res))</span>
<span class="lineNum">     291 </span><span class="lineNoCov">          0 :     return bb_rank[bb-&gt;index];</span>
<span class="lineNum">     292 </span>            : 
<span class="lineNum">     293 </span>            :   /* The phi definition must have a single use, and that use must be
<span class="lineNum">     294 </span>            :      within the loop.  Otherwise this isn't an accumulator pattern.  */
<span class="lineNum">     295 </span><span class="lineCov">     939181 :   if (!single_imm_use (res, &amp;use, &amp;use_stmt)</span>
<span class="lineNum">     296 </span><span class="lineCov">     939181 :       || gimple_bb (use_stmt)-&gt;loop_father != father)</span>
<span class="lineNum">     297 </span><span class="lineCov">     861693 :     return bb_rank[bb-&gt;index];</span>
<span class="lineNum">     298 </span>            : 
<span class="lineNum">     299 </span>            :   /* Look for phi arguments from within the loop.  If found, bias this phi.  */
<span class="lineNum">     300 </span><span class="lineCov">     141514 :   for (i = 0; i &lt; gimple_phi_num_args (stmt); i++)</span>
<span class="lineNum">     301 </span>            :     {
<span class="lineNum">     302 </span><span class="lineCov">     141232 :       tree arg = gimple_phi_arg_def (stmt, i);</span>
<span class="lineNum">     303 </span><span class="lineCov">     141232 :       if (TREE_CODE (arg) == SSA_NAME</span>
<span class="lineNum">     304 </span><span class="lineCov">     141232 :           &amp;&amp; !SSA_NAME_IS_DEFAULT_DEF (arg))</span>
<span class="lineNum">     305 </span>            :         {
<span class="lineNum">     306 </span><span class="lineCov">     111360 :           gimple *def_stmt = SSA_NAME_DEF_STMT (arg);</span>
<span class="lineNum">     307 </span><span class="lineCov">     222720 :           if (gimple_bb (def_stmt)-&gt;loop_father == father)</span>
<span class="lineNum">     308 </span><span class="lineCov">      77206 :             return bb_rank[father-&gt;latch-&gt;index] + PHI_LOOP_BIAS;</span>
<span class="lineNum">     309 </span>            :         }
<span class="lineNum">     310 </span>            :     }
<span class="lineNum">     311 </span>            : 
<span class="lineNum">     312 </span>            :   /* Must be an uninteresting phi.  */
<span class="lineNum">     313 </span><span class="lineCov">        282 :   return bb_rank[bb-&gt;index];</span>
<span class="lineNum">     314 </span>            : }
<span class="lineNum">     315 </span>            : 
<span class="lineNum">     316 </span>            : /* If EXP is an SSA_NAME defined by a PHI statement that represents a
<span class="lineNum">     317 </span>            :    loop-carried dependence of an innermost loop, return TRUE; else
<a name="318"><span class="lineNum">     318 </span>            :    return FALSE.  */</a>
<span class="lineNum">     319 </span>            : static bool
<span class="lineNum">     320 </span><span class="lineCov">    4213806 : loop_carried_phi (tree exp)</span>
<span class="lineNum">     321 </span>            : {
<span class="lineNum">     322 </span><span class="lineCov">    4213806 :   gimple *phi_stmt;</span>
<span class="lineNum">     323 </span><span class="lineCov">    4213806 :   long block_rank;</span>
<span class="lineNum">     324 </span>            : 
<span class="lineNum">     325 </span><span class="lineCov">    4213806 :   if (TREE_CODE (exp) != SSA_NAME</span>
<span class="lineNum">     326 </span><span class="lineCov">    4213806 :       || SSA_NAME_IS_DEFAULT_DEF (exp))</span>
<span class="lineNum">     327 </span>            :     return false;
<span class="lineNum">     328 </span>            : 
<span class="lineNum">     329 </span><span class="lineCov">    3767655 :   phi_stmt = SSA_NAME_DEF_STMT (exp);</span>
<span class="lineNum">     330 </span>            : 
<span class="lineNum">     331 </span><span class="lineCov">   11302965 :   if (gimple_code (SSA_NAME_DEF_STMT (exp)) != GIMPLE_PHI)</span>
<span class="lineNum">     332 </span>            :     return false;
<span class="lineNum">     333 </span>            : 
<span class="lineNum">     334 </span>            :   /* Non-loop-carried phis have block rank.  Loop-carried phis have
<span class="lineNum">     335 </span>            :      an additional bias added in.  If this phi doesn't have block rank,
<span class="lineNum">     336 </span>            :      it's biased and should not be propagated.  */
<span class="lineNum">     337 </span><span class="lineCov">     667449 :   block_rank = bb_rank[gimple_bb (phi_stmt)-&gt;index];</span>
<span class="lineNum">     338 </span>            : 
<span class="lineNum">     339 </span><span class="lineCov">     667449 :   if (phi_rank (phi_stmt) != block_rank)</span>
<span class="lineNum">     340 </span><span class="lineCov">      25061 :     return true;</span>
<span class="lineNum">     341 </span>            : 
<span class="lineNum">     342 </span>            :   return false;
<span class="lineNum">     343 </span>            : }
<span class="lineNum">     344 </span>            : 
<span class="lineNum">     345 </span>            : /* Return the maximum of RANK and the rank that should be propagated
<span class="lineNum">     346 </span>            :    from expression OP.  For most operands, this is just the rank of OP.
<span class="lineNum">     347 </span>            :    For loop-carried phis, the value is zero to avoid undoing the bias
<a name="348"><span class="lineNum">     348 </span>            :    in favor of the phi.  */</a>
<span class="lineNum">     349 </span>            : static long
<span class="lineNum">     350 </span><span class="lineCov">    4213806 : propagate_rank (long rank, tree op)</span>
<span class="lineNum">     351 </span>            : {
<span class="lineNum">     352 </span><span class="lineCov">    4213806 :   long op_rank;</span>
<span class="lineNum">     353 </span>            : 
<span class="lineNum">     354 </span><span class="lineCov">    4213806 :   if (loop_carried_phi (op))</span>
<span class="lineNum">     355 </span>            :     return rank;
<span class="lineNum">     356 </span>            : 
<span class="lineNum">     357 </span><span class="lineCov">    4188745 :   op_rank = get_rank (op);</span>
<span class="lineNum">     358 </span>            : 
<span class="lineNum">     359 </span><span class="lineCov">    4188745 :   return MAX (rank, op_rank);</span>
<span class="lineNum">     360 </span>            : }
<span class="lineNum">     361 </span>            : 
<span class="lineNum">     362 </span>            : /* Look up the operand rank structure for expression E.  */
<a name="363"><span class="lineNum">     363 </span>            : </a>
<span class="lineNum">     364 </span>            : static inline long
<span class="lineNum">     365 </span><span class="lineCov">    6077968 : find_operand_rank (tree e)</span>
<span class="lineNum">     366 </span>            : {
<span class="lineNum">     367 </span><span class="lineCov">    6077968 :   long *slot = operand_rank-&gt;get (e);</span>
<span class="lineNum">     368 </span><span class="lineCov">    2242432 :   return slot ? *slot : -1;</span>
<span class="lineNum">     369 </span>            : }
<span class="lineNum">     370 </span>            : 
<span class="lineNum">     371 </span>            : /* Insert {E,RANK} into the operand rank hashtable.  */
<a name="372"><span class="lineNum">     372 </span>            : </a>
<span class="lineNum">     373 </span>            : static inline void
<span class="lineNum">     374 </span><span class="lineCov">    7227526 : insert_operand_rank (tree e, long rank)</span>
<span class="lineNum">     375 </span>            : {
<span class="lineNum">     376 </span><span class="lineCov">    7227526 :   gcc_assert (rank &gt; 0);</span>
<span class="lineNum">     377 </span><span class="lineCov">    7227526 :   gcc_assert (!operand_rank-&gt;put (e, rank));</span>
<span class="lineNum">     378 </span><span class="lineCov">    7227526 : }</span>
<span class="lineNum">     379 </span>            : 
<span class="lineNum">     380 </span>            : /* Given an expression E, return the rank of the expression.  */
<a name="381"><span class="lineNum">     381 </span>            : </a>
<span class="lineNum">     382 </span>            : static long
<span class="lineNum">     383 </span><span class="lineCov">    9222536 : get_rank (tree e)</span>
<span class="lineNum">     384 </span>            : {
<span class="lineNum">     385 </span>            :   /* SSA_NAME's have the rank of the expression they are the result
<span class="lineNum">     386 </span>            :      of.
<span class="lineNum">     387 </span>            :      For globals and uninitialized values, the rank is 0.
<span class="lineNum">     388 </span>            :      For function arguments, use the pre-setup rank.
<span class="lineNum">     389 </span>            :      For PHI nodes, stores, asm statements, etc, we use the rank of
<span class="lineNum">     390 </span>            :      the BB.
<span class="lineNum">     391 </span>            :      For simple operations, the rank is the maximum rank of any of
<span class="lineNum">     392 </span>            :      its operands, or the bb_rank, whichever is less.
<span class="lineNum">     393 </span>            :      I make no claims that this is optimal, however, it gives good
<span class="lineNum">     394 </span>            :      results.  */
<span class="lineNum">     395 </span>            : 
<span class="lineNum">     396 </span>            :   /* We make an exception to the normal ranking system to break
<span class="lineNum">     397 </span>            :      dependences of accumulator variables in loops.  Suppose we
<span class="lineNum">     398 </span>            :      have a simple one-block loop containing:
<span class="lineNum">     399 </span>            : 
<span class="lineNum">     400 </span>            :        x_1 = phi(x_0, x_2)
<span class="lineNum">     401 </span>            :        b = a + x_1
<span class="lineNum">     402 </span>            :        c = b + d
<span class="lineNum">     403 </span>            :        x_2 = c + e
<span class="lineNum">     404 </span>            : 
<span class="lineNum">     405 </span>            :      As shown, each iteration of the calculation into x is fully
<span class="lineNum">     406 </span>            :      dependent upon the iteration before it.  We would prefer to
<span class="lineNum">     407 </span>            :      see this in the form:
<span class="lineNum">     408 </span>            : 
<span class="lineNum">     409 </span>            :        x_1 = phi(x_0, x_2)
<span class="lineNum">     410 </span>            :        b = a + d
<span class="lineNum">     411 </span>            :        c = b + e
<span class="lineNum">     412 </span>            :        x_2 = c + x_1
<span class="lineNum">     413 </span>            : 
<span class="lineNum">     414 </span>            :      If the loop is unrolled, the calculations of b and c from
<span class="lineNum">     415 </span>            :      different iterations can be interleaved.
<span class="lineNum">     416 </span>            : 
<span class="lineNum">     417 </span>            :      To obtain this result during reassociation, we bias the rank
<span class="lineNum">     418 </span>            :      of the phi definition x_1 upward, when it is recognized as an
<span class="lineNum">     419 </span>            :      accumulator pattern.  The artificial rank causes it to be 
<span class="lineNum">     420 </span>            :      added last, providing the desired independence.  */
<span class="lineNum">     421 </span>            : 
<span class="lineNum">     422 </span><span class="lineCov">    9222536 :   if (TREE_CODE (e) == SSA_NAME)</span>
<span class="lineNum">     423 </span>            :     {
<span class="lineNum">     424 </span><span class="lineCov">    7504112 :       ssa_op_iter iter;</span>
<span class="lineNum">     425 </span><span class="lineCov">    7504112 :       gimple *stmt;</span>
<span class="lineNum">     426 </span><span class="lineCov">    7504112 :       long rank;</span>
<span class="lineNum">     427 </span><span class="lineCov">    7504112 :       tree op;</span>
<span class="lineNum">     428 </span>            : 
<span class="lineNum">     429 </span><span class="lineCov">   15008224 :       if (SSA_NAME_IS_DEFAULT_DEF (e))</span>
<span class="lineNum">     430 </span><span class="lineCov">     533232 :         return find_operand_rank (e);</span>
<span class="lineNum">     431 </span>            : 
<span class="lineNum">     432 </span><span class="lineCov">    6970880 :       stmt = SSA_NAME_DEF_STMT (e);</span>
<span class="lineNum">     433 </span><span class="lineCov">   13941760 :       if (gimple_code (stmt) == GIMPLE_PHI)</span>
<span class="lineNum">     434 </span><span class="lineCov">    1218427 :         return phi_rank (stmt);</span>
<span class="lineNum">     435 </span>            : 
<span class="lineNum">     436 </span><span class="lineCov">   11504906 :       if (!is_gimple_assign (stmt))</span>
<span class="lineNum">     437 </span><span class="lineCov">     415434 :         return bb_rank[gimple_bb (stmt)-&gt;index];</span>
<span class="lineNum">     438 </span>            : 
<span class="lineNum">     439 </span>            :       /* If we already have a rank for this expression, use that.  */
<span class="lineNum">     440 </span><span class="lineCov">    5544736 :       rank = find_operand_rank (e);</span>
<span class="lineNum">     441 </span><span class="lineCov">    5544736 :       if (rank != -1)</span>
<span class="lineNum">     442 </span>            :         return rank;
<span class="lineNum">     443 </span>            : 
<span class="lineNum">     444 </span>            :       /* Otherwise, find the maximum rank for the operands.  As an
<span class="lineNum">     445 </span>            :          exception, remove the bias from loop-carried phis when propagating
<span class="lineNum">     446 </span>            :          the rank so that dependent operations are not also biased.  */
<span class="lineNum">     447 </span>            :       /* Simply walk over all SSA uses - this takes advatage of the
<span class="lineNum">     448 </span>            :          fact that non-SSA operands are is_gimple_min_invariant and
<span class="lineNum">     449 </span>            :          thus have rank 0.  */
<span class="lineNum">     450 </span><span class="lineCov">    3835536 :       rank = 0;</span>
<span class="lineNum">     451 </span><span class="lineCov">   12263148 :       FOR_EACH_SSA_TREE_OPERAND (op, stmt, iter, SSA_OP_USE)</span>
<span class="lineNum">     452 </span><span class="lineCov">    4213806 :         rank = propagate_rank (rank, op);</span>
<span class="lineNum">     453 </span>            : 
<span class="lineNum">     454 </span><span class="lineCov">    3835536 :       if (dump_file &amp;&amp; (dump_flags &amp; TDF_DETAILS))</span>
<span class="lineNum">     455 </span>            :         {
<span class="lineNum">     456 </span><span class="lineCov">        161 :           fprintf (dump_file, &quot;Rank for &quot;);</span>
<span class="lineNum">     457 </span><span class="lineCov">        161 :           print_generic_expr (dump_file, e);</span>
<span class="lineNum">     458 </span><span class="lineCov">        161 :           fprintf (dump_file, &quot; is %ld\n&quot;, (rank + 1));</span>
<span class="lineNum">     459 </span>            :         }
<span class="lineNum">     460 </span>            : 
<span class="lineNum">     461 </span>            :       /* Note the rank in the hashtable so we don't recompute it.  */
<span class="lineNum">     462 </span><span class="lineCov">    3835536 :       insert_operand_rank (e, (rank + 1));</span>
<span class="lineNum">     463 </span><span class="lineCov">    3835536 :       return (rank + 1);</span>
<span class="lineNum">     464 </span>            :     }
<span class="lineNum">     465 </span>            : 
<span class="lineNum">     466 </span>            :   /* Constants, globals, etc., are rank 0 */
<span class="lineNum">     467 </span>            :   return 0;
<span class="lineNum">     468 </span>            : }
<span class="lineNum">     469 </span>            : 
<span class="lineNum">     470 </span>            : 
<span class="lineNum">     471 </span>            : /* We want integer ones to end up last no matter what, since they are
<span class="lineNum">     472 </span>            :    the ones we can do the most with.  */
<span class="lineNum">     473 </span>            : #define INTEGER_CONST_TYPE 1 &lt;&lt; 4
<span class="lineNum">     474 </span>            : #define FLOAT_ONE_CONST_TYPE 1 &lt;&lt; 3
<span class="lineNum">     475 </span>            : #define FLOAT_CONST_TYPE 1 &lt;&lt; 2
<span class="lineNum">     476 </span>            : #define OTHER_CONST_TYPE 1 &lt;&lt; 1
<span class="lineNum">     477 </span>            : 
<span class="lineNum">     478 </span>            : /* Classify an invariant tree into integer, float, or other, so that
<a name="479"><span class="lineNum">     479 </span>            :    we can sort them to be near other constants of the same type.  */</a>
<span class="lineNum">     480 </span>            : static inline int
<span class="lineNum">     481 </span><span class="lineCov">     679390 : constant_type (tree t)</span>
<span class="lineNum">     482 </span>            : {
<span class="lineNum">     483 </span><span class="lineCov">     679390 :   if (INTEGRAL_TYPE_P (TREE_TYPE (t)))</span>
<span class="lineNum">     484 </span>            :     return INTEGER_CONST_TYPE;
<span class="lineNum">     485 </span><span class="lineCov">       5772 :   else if (SCALAR_FLOAT_TYPE_P (TREE_TYPE (t)))</span>
<span class="lineNum">     486 </span>            :     {
<span class="lineNum">     487 </span>            :       /* Sort -1.0 and 1.0 constants last, while in some cases
<span class="lineNum">     488 </span>            :          const_binop can't optimize some inexact operations, multiplication
<span class="lineNum">     489 </span>            :          by -1.0 or 1.0 can be always merged with others.  */
<span class="lineNum">     490 </span><span class="lineCov">       2774 :       if (real_onep (t) || real_minus_onep (t))</span>
<span class="lineNum">     491 </span><span class="lineCov">        124 :         return FLOAT_ONE_CONST_TYPE;</span>
<span class="lineNum">     492 </span>            :       return FLOAT_CONST_TYPE;
<span class="lineNum">     493 </span>            :     }
<span class="lineNum">     494 </span>            :   else
<span class="lineNum">     495 </span>            :     return OTHER_CONST_TYPE;
<span class="lineNum">     496 </span>            : }
<span class="lineNum">     497 </span>            : 
<span class="lineNum">     498 </span>            : /* qsort comparison function to sort operand entries PA and PB by rank
<a name="499"><span class="lineNum">     499 </span>            :    so that the sorted array is ordered by rank in decreasing order.  */</a>
<span class="lineNum">     500 </span>            : static int
<span class="lineNum">     501 </span><span class="lineCov">   11397897 : sort_by_operand_rank (const void *pa, const void *pb)</span>
<span class="lineNum">     502 </span>            : {
<span class="lineNum">     503 </span><span class="lineCov">   11397897 :   const operand_entry *oea = *(const operand_entry *const *)pa;</span>
<span class="lineNum">     504 </span><span class="lineCov">   11397897 :   const operand_entry *oeb = *(const operand_entry *const *)pb;</span>
<span class="lineNum">     505 </span>            : 
<span class="lineNum">     506 </span><span class="lineCov">   11397897 :   if (oeb-&gt;rank != oea-&gt;rank)</span>
<span class="lineNum">     507 </span><span class="lineCov">   16219785 :     return oeb-&gt;rank &gt; oea-&gt;rank ? 1 : -1;</span>
<span class="lineNum">     508 </span>            : 
<span class="lineNum">     509 </span>            :   /* It's nicer for optimize_expression if constants that are likely
<span class="lineNum">     510 </span>            :      to fold when added/multiplied/whatever are put next to each
<span class="lineNum">     511 </span>            :      other.  Since all constants have rank 0, order them by type.  */
<span class="lineNum">     512 </span><span class="lineCov">    1870780 :   if (oea-&gt;rank == 0)</span>
<span class="lineNum">     513 </span>            :     {
<span class="lineNum">     514 </span><span class="lineCov">     339637 :       if (constant_type (oeb-&gt;op) != constant_type (oea-&gt;op))</span>
<span class="lineNum">     515 </span><span class="lineCov">         58 :         return constant_type (oea-&gt;op) - constant_type (oeb-&gt;op);</span>
<span class="lineNum">     516 </span>            :       else
<span class="lineNum">     517 </span>            :         /* To make sorting result stable, we use unique IDs to determine
<span class="lineNum">     518 </span>            :            order.  */
<span class="lineNum">     519 </span><span class="lineCov">     555697 :         return oeb-&gt;id &gt; oea-&gt;id ? 1 : -1;</span>
<span class="lineNum">     520 </span>            :     }
<span class="lineNum">     521 </span>            : 
<span class="lineNum">     522 </span><span class="lineCov">    1531143 :   if (TREE_CODE (oea-&gt;op) != SSA_NAME)</span>
<span class="lineNum">     523 </span>            :     {
<span class="lineNum">     524 </span><span class="lineNoCov">          0 :       if (TREE_CODE (oeb-&gt;op) != SSA_NAME)</span>
<span class="lineNum">     525 </span><span class="lineNoCov">          0 :         return oeb-&gt;id &gt; oea-&gt;id ? 1 : -1;</span>
<span class="lineNum">     526 </span>            :       else
<span class="lineNum">     527 </span>            :         return 1;
<span class="lineNum">     528 </span>            :     }
<span class="lineNum">     529 </span><span class="lineCov">    1531143 :   else if (TREE_CODE (oeb-&gt;op) != SSA_NAME)</span>
<span class="lineNum">     530 </span>            :     return -1;
<span class="lineNum">     531 </span>            : 
<span class="lineNum">     532 </span>            :   /* Lastly, make sure the versions that are the same go next to each
<span class="lineNum">     533 </span>            :      other.  */
<span class="lineNum">     534 </span><span class="lineCov">    4593429 :   if (SSA_NAME_VERSION (oeb-&gt;op) != SSA_NAME_VERSION (oea-&gt;op))</span>
<span class="lineNum">     535 </span>            :     {
<span class="lineNum">     536 </span>            :       /* As SSA_NAME_VERSION is assigned pretty randomly, because we reuse
<span class="lineNum">     537 </span>            :          versions of removed SSA_NAMEs, so if possible, prefer to sort
<span class="lineNum">     538 </span>            :          based on basic block and gimple_uid of the SSA_NAME_DEF_STMT.
<span class="lineNum">     539 </span>            :          See PR60418.  */
<span class="lineNum">     540 </span><span class="lineCov">    1514554 :       gimple *stmta = SSA_NAME_DEF_STMT (oea-&gt;op);</span>
<span class="lineNum">     541 </span><span class="lineCov">    1514554 :       gimple *stmtb = SSA_NAME_DEF_STMT (oeb-&gt;op);</span>
<span class="lineNum">     542 </span><span class="lineCov">    1514554 :       basic_block bba = gimple_bb (stmta);</span>
<span class="lineNum">     543 </span><span class="lineCov">    1514554 :       basic_block bbb = gimple_bb (stmtb);</span>
<span class="lineNum">     544 </span><span class="lineCov">    1514554 :       if (bbb != bba)</span>
<span class="lineNum">     545 </span>            :         {
<span class="lineNum">     546 </span>            :           /* One of the SSA_NAMEs can be defined in oeN-&gt;stmt_to_insert
<span class="lineNum">     547 </span>            :              but the other might not.  */
<span class="lineNum">     548 </span><span class="lineCov">      72285 :           if (!bba)</span>
<span class="lineNum">     549 </span>            :             return 1;
<span class="lineNum">     550 </span><span class="lineCov">      70059 :           if (!bbb)</span>
<span class="lineNum">     551 </span>            :             return -1;
<span class="lineNum">     552 </span>            :           /* If neither is, compare bb_rank.  */
<span class="lineNum">     553 </span><span class="lineCov">      66984 :           if (bb_rank[bbb-&gt;index] != bb_rank[bba-&gt;index])</span>
<span class="lineNum">     554 </span><span class="lineCov">      66984 :             return (bb_rank[bbb-&gt;index] &gt;&gt; 16) - (bb_rank[bba-&gt;index] &gt;&gt; 16);</span>
<span class="lineNum">     555 </span>            :         }
<span class="lineNum">     556 </span>            : 
<span class="lineNum">     557 </span><span class="lineCov">    1442269 :       bool da = reassoc_stmt_dominates_stmt_p (stmta, stmtb);</span>
<span class="lineNum">     558 </span><span class="lineCov">    1442269 :       bool db = reassoc_stmt_dominates_stmt_p (stmtb, stmta);</span>
<span class="lineNum">     559 </span><span class="lineCov">    1442269 :       if (da != db)</span>
<span class="lineNum">     560 </span><span class="lineCov">    2232012 :         return da ? 1 : -1;</span>
<span class="lineNum">     561 </span>            : 
<span class="lineNum">     562 </span><span class="lineCov">      22734 :       return SSA_NAME_VERSION (oeb-&gt;op) &gt; SSA_NAME_VERSION (oea-&gt;op) ? 1 : -1;</span>
<span class="lineNum">     563 </span>            :     }
<span class="lineNum">     564 </span>            : 
<span class="lineNum">     565 </span><span class="lineCov">      16589 :   return oeb-&gt;id &gt; oea-&gt;id ? 1 : -1;</span>
<span class="lineNum">     566 </span>            : }
<span class="lineNum">     567 </span>            : 
<span class="lineNum">     568 </span>            : /* Add an operand entry to *OPS for the tree operand OP.  */
<a name="569"><span class="lineNum">     569 </span>            : </a>
<span class="lineNum">     570 </span>            : static void
<span class="lineNum">     571 </span><span class="lineCov">    5033652 : add_to_ops_vec (vec&lt;operand_entry *&gt; *ops, tree op, gimple *stmt_to_insert = NULL)</span>
<span class="lineNum">     572 </span>            : {
<span class="lineNum">     573 </span><span class="lineCov">    5033652 :   operand_entry *oe = operand_entry_pool.allocate ();</span>
<span class="lineNum">     574 </span>            : 
<span class="lineNum">     575 </span><span class="lineCov">    5033652 :   oe-&gt;op = op;</span>
<span class="lineNum">     576 </span><span class="lineCov">    5033652 :   oe-&gt;rank = get_rank (op);</span>
<span class="lineNum">     577 </span><span class="lineCov">    5033652 :   oe-&gt;id = next_operand_entry_id++;</span>
<span class="lineNum">     578 </span><span class="lineCov">    5033652 :   oe-&gt;count = 1;</span>
<span class="lineNum">     579 </span><span class="lineCov">    5033652 :   oe-&gt;stmt_to_insert = stmt_to_insert;</span>
<span class="lineNum">     580 </span><span class="lineCov">    5033652 :   ops-&gt;safe_push (oe);</span>
<span class="lineNum">     581 </span><span class="lineCov">    5033652 : }</span>
<span class="lineNum">     582 </span>            : 
<span class="lineNum">     583 </span>            : /* Add an operand entry to *OPS for the tree operand OP with repeat
<span class="lineNum">     584 </span>            :    count REPEAT.  */
<a name="585"><span class="lineNum">     585 </span>            : </a>
<span class="lineNum">     586 </span>            : static void
<span class="lineNum">     587 </span><span class="lineCov">         18 : add_repeat_to_ops_vec (vec&lt;operand_entry *&gt; *ops, tree op,</span>
<span class="lineNum">     588 </span>            :                        HOST_WIDE_INT repeat)
<span class="lineNum">     589 </span>            : {
<span class="lineNum">     590 </span><span class="lineCov">         18 :   operand_entry *oe = operand_entry_pool.allocate ();</span>
<span class="lineNum">     591 </span>            : 
<span class="lineNum">     592 </span><span class="lineCov">         18 :   oe-&gt;op = op;</span>
<span class="lineNum">     593 </span><span class="lineCov">         18 :   oe-&gt;rank = get_rank (op);</span>
<span class="lineNum">     594 </span><span class="lineCov">         18 :   oe-&gt;id = next_operand_entry_id++;</span>
<span class="lineNum">     595 </span><span class="lineCov">         18 :   oe-&gt;count = repeat;</span>
<span class="lineNum">     596 </span><span class="lineCov">         18 :   oe-&gt;stmt_to_insert = NULL;</span>
<span class="lineNum">     597 </span><span class="lineCov">         18 :   ops-&gt;safe_push (oe);</span>
<span class="lineNum">     598 </span>            : 
<span class="lineNum">     599 </span><span class="lineCov">         18 :   reassociate_stats.pows_encountered++;</span>
<span class="lineNum">     600 </span><span class="lineCov">         18 : }</span>
<span class="lineNum">     601 </span>            : 
<span class="lineNum">     602 </span>            : /* Return true if STMT is reassociable operation containing a binary
<span class="lineNum">     603 </span>            :    operation with tree code CODE, and is inside LOOP.  */
<a name="604"><span class="lineNum">     604 </span>            : </a>
<span class="lineNum">     605 </span>            : static bool
<span class="lineNum">     606 </span><span class="lineCov">    4140257 : is_reassociable_op (gimple *stmt, enum tree_code code, struct loop *loop)</span>
<span class="lineNum">     607 </span>            : {
<span class="lineNum">     608 </span><span class="lineCov">    4140257 :   basic_block bb = gimple_bb (stmt);</span>
<span class="lineNum">     609 </span>            : 
<span class="lineNum">     610 </span><span class="lineCov">    8280514 :   if (gimple_bb (stmt) == NULL)</span>
<span class="lineNum">     611 </span>            :     return false;
<span class="lineNum">     612 </span>            : 
<span class="lineNum">     613 </span><span class="lineCov">    4038206 :   if (!flow_bb_inside_loop_p (loop, bb))</span>
<span class="lineNum">     614 </span>            :     return false;
<span class="lineNum">     615 </span>            : 
<span class="lineNum">     616 </span><span class="lineCov">    3905375 :   if (is_gimple_assign (stmt)</span>
<span class="lineNum">     617 </span><span class="lineCov">    3179860 :       &amp;&amp; gimple_assign_rhs_code (stmt) == code</span>
<span class="lineNum">     618 </span><span class="lineCov">    4751521 :       &amp;&amp; has_single_use (gimple_assign_lhs (stmt)))</span>
<span class="lineNum">     619 </span>            :     {
<span class="lineNum">     620 </span><span class="lineCov">     317310 :       tree rhs1 = gimple_assign_rhs1 (stmt);</span>
<span class="lineNum">     621 </span><span class="lineCov">     317310 :       tree rhs2 = gimple_assign_rhs2 (stmt);</span>
<span class="lineNum">     622 </span><span class="lineCov">     317310 :       if (TREE_CODE (rhs1) == SSA_NAME</span>
<span class="lineNum">     623 </span><span class="lineCov">     317310 :           &amp;&amp; SSA_NAME_OCCURS_IN_ABNORMAL_PHI (rhs1))</span>
<span class="lineNum">     624 </span>            :         return false;
<span class="lineNum">     625 </span><span class="lineCov">     317280 :       if (rhs2</span>
<span class="lineNum">     626 </span><span class="lineCov">     317280 :           &amp;&amp; TREE_CODE (rhs2) == SSA_NAME</span>
<span class="lineNum">     627 </span><span class="lineCov">     750378 :           &amp;&amp; SSA_NAME_OCCURS_IN_ABNORMAL_PHI (rhs2))</span>
<span class="lineNum">     628 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">     629 </span>            :       return true;
<span class="lineNum">     630 </span>            :     }
<span class="lineNum">     631 </span>            : 
<span class="lineNum">     632 </span>            :   return false;
<span class="lineNum">     633 </span>            : }
<span class="lineNum">     634 </span>            : 
<span class="lineNum">     635 </span>            : 
<span class="lineNum">     636 </span>            : /* Return true if STMT is a nop-conversion.  */
<a name="637"><span class="lineNum">     637 </span>            : </a>
<span class="lineNum">     638 </span>            : static bool
<span class="lineNum">     639 </span><span class="lineCov">    3881394 : gimple_nop_conversion_p (gimple *stmt)</span>
<span class="lineNum">     640 </span>            : {
<span class="lineNum">     641 </span><span class="lineCov">    3881394 :   if (gassign *ass = dyn_cast &lt;gassign *&gt; (stmt))</span>
<span class="lineNum">     642 </span>            :     {
<span class="lineNum">     643 </span><span class="lineCov">    6677435 :       if (CONVERT_EXPR_CODE_P (gimple_assign_rhs_code (ass))</span>
<span class="lineNum">     644 </span><span class="lineCov">    3497728 :           &amp;&amp; tree_nop_conversion_p (TREE_TYPE (gimple_assign_lhs (ass)),</span>
<span class="lineNum">     645 </span><span class="lineCov">    1526786 :                                     TREE_TYPE (gimple_assign_rhs1 (ass))))</span>
<span class="lineNum">     646 </span><span class="lineCov">     552749 :         return true;</span>
<span class="lineNum">     647 </span>            :     }
<span class="lineNum">     648 </span>            :   return false;
<span class="lineNum">     649 </span>            : }
<span class="lineNum">     650 </span>            : 
<span class="lineNum">     651 </span>            : /* Given NAME, if NAME is defined by a unary operation OPCODE, return the
<span class="lineNum">     652 </span>            :    operand of the negate operation.  Otherwise, return NULL.  */
<a name="653"><span class="lineNum">     653 </span>            : </a>
<span class="lineNum">     654 </span>            : static tree
<span class="lineNum">     655 </span><span class="lineCov">    3823423 : get_unary_op (tree name, enum tree_code opcode)</span>
<span class="lineNum">     656 </span>            : {
<span class="lineNum">     657 </span><span class="lineCov">    3823423 :   gimple *stmt = SSA_NAME_DEF_STMT (name);</span>
<span class="lineNum">     658 </span>            : 
<span class="lineNum">     659 </span>            :   /* Look through nop conversions (sign changes).  */
<span class="lineNum">     660 </span><span class="lineCov">    3823423 :   if (gimple_nop_conversion_p (stmt)</span>
<span class="lineNum">     661 </span><span class="lineCov">    3823423 :       &amp;&amp; TREE_CODE (gimple_assign_rhs1 (stmt)) == SSA_NAME)</span>
<span class="lineNum">     662 </span><span class="lineCov">    1422189 :     stmt = SSA_NAME_DEF_STMT (gimple_assign_rhs1 (stmt));</span>
<span class="lineNum">     663 </span>            : 
<span class="lineNum">     664 </span><span class="lineCov">    7646846 :   if (!is_gimple_assign (stmt))</span>
<span class="lineNum">     665 </span>            :     return NULL_TREE;
<span class="lineNum">     666 </span>            : 
<span class="lineNum">     667 </span><span class="lineCov">    2425025 :   if (gimple_assign_rhs_code (stmt) == opcode)</span>
<span class="lineNum">     668 </span><span class="lineCov">     123872 :     return gimple_assign_rhs1 (stmt);</span>
<span class="lineNum">     669 </span>            :   return NULL_TREE;
<span class="lineNum">     670 </span>            : }
<span class="lineNum">     671 </span>            : 
<span class="lineNum">     672 </span>            : /* Return true if OP1 and OP2 have the same value if casted to either type.  */
<a name="673"><span class="lineNum">     673 </span>            : </a>
<span class="lineNum">     674 </span>            : static bool
<span class="lineNum">     675 </span><span class="lineCov">      29705 : ops_equal_values_p (tree op1, tree op2)</span>
<span class="lineNum">     676 </span>            : {
<span class="lineNum">     677 </span><span class="lineCov">      29705 :   if (op1 == op2)</span>
<span class="lineNum">     678 </span>            :     return true;
<span class="lineNum">     679 </span>            : 
<span class="lineNum">     680 </span><span class="lineCov">      29362 :   tree orig_op1 = op1;</span>
<span class="lineNum">     681 </span><span class="lineCov">      29362 :   if (TREE_CODE (op1) == SSA_NAME)</span>
<span class="lineNum">     682 </span>            :     {
<span class="lineNum">     683 </span><span class="lineCov">      29361 :       gimple *stmt = SSA_NAME_DEF_STMT (op1);</span>
<span class="lineNum">     684 </span><span class="lineCov">      29361 :       if (gimple_nop_conversion_p (stmt))</span>
<span class="lineNum">     685 </span>            :         {
<span class="lineNum">     686 </span><span class="lineCov">      10163 :           op1 = gimple_assign_rhs1 (stmt);</span>
<span class="lineNum">     687 </span><span class="lineCov">      10163 :           if (op1 == op2)</span>
<span class="lineNum">     688 </span>            :             return true;
<span class="lineNum">     689 </span>            :         }
<span class="lineNum">     690 </span>            :     }
<span class="lineNum">     691 </span>            : 
<span class="lineNum">     692 </span><span class="lineCov">      28610 :   if (TREE_CODE (op2) == SSA_NAME)</span>
<span class="lineNum">     693 </span>            :     {
<span class="lineNum">     694 </span><span class="lineCov">      28610 :       gimple *stmt = SSA_NAME_DEF_STMT (op2);</span>
<span class="lineNum">     695 </span><span class="lineCov">      28610 :       if (gimple_nop_conversion_p (stmt))</span>
<span class="lineNum">     696 </span>            :         {
<span class="lineNum">     697 </span><span class="lineCov">      10157 :           op2 = gimple_assign_rhs1 (stmt);</span>
<span class="lineNum">     698 </span><span class="lineCov">      10157 :           if (op1 == op2</span>
<span class="lineNum">     699 </span><span class="lineCov">       9678 :               || orig_op1 == op2)</span>
<span class="lineNum">     700 </span><span class="lineCov">        479 :             return true;</span>
<span class="lineNum">     701 </span>            :         }
<span class="lineNum">     702 </span>            :     }
<span class="lineNum">     703 </span>            : 
<span class="lineNum">     704 </span>            :   return false;
<span class="lineNum">     705 </span>            : }
<span class="lineNum">     706 </span>            : 
<span class="lineNum">     707 </span>            : 
<span class="lineNum">     708 </span>            : /* If CURR and LAST are a pair of ops that OPCODE allows us to
<span class="lineNum">     709 </span>            :    eliminate through equivalences, do so, remove them from OPS, and
<span class="lineNum">     710 </span>            :    return true.  Otherwise, return false.  */
<span class="lineNum">     711 </span>            : 
<span class="lineNum">     712 </span>            : static bool
<span class="lineNum">     713 </span><span class="lineCov">    4913171 : eliminate_duplicate_pair (enum tree_code opcode,</span>
<span class="lineNum">     714 </span>            :                           vec&lt;operand_entry *&gt; *ops,
<span class="lineNum">     715 </span>            :                           bool *all_done,
<span class="lineNum">     716 </span>            :                           unsigned int i,
<span class="lineNum">     717 </span>            :                           operand_entry *curr,
<span class="lineNum">     718 </span>            :                           operand_entry *last)
<span class="lineNum">     719 </span>            : {
<span class="lineNum">     720 </span>            : 
<span class="lineNum">     721 </span>            :   /* If we have two of the same op, and the opcode is &amp; |, min, or max,
<span class="lineNum">     722 </span>            :      we can eliminate one of them.
<span class="lineNum">     723 </span>            :      If we have two of the same op, and the opcode is ^, we can
<span class="lineNum">     724 </span>            :      eliminate both of them.  */
<span class="lineNum">     725 </span>            : 
<span class="lineNum">     726 </span><span class="lineCov">    4913171 :   if (last &amp;&amp; last-&gt;op == curr-&gt;op)</span>
<span class="lineNum">     727 </span>            :     {
<span class="lineNum">     728 </span><span class="lineCov">       3475 :       switch (opcode)</span>
<span class="lineNum">     729 </span>            :         {
<span class="lineNum">     730 </span><span class="lineCov">         48 :         case MAX_EXPR:</span>
<span class="lineNum">     731 </span><span class="lineCov">         48 :         case MIN_EXPR:</span>
<span class="lineNum">     732 </span><span class="lineCov">         48 :         case BIT_IOR_EXPR:</span>
<span class="lineNum">     733 </span><span class="lineCov">         48 :         case BIT_AND_EXPR:</span>
<span class="lineNum">     734 </span><span class="lineCov">         48 :           if (dump_file &amp;&amp; (dump_flags &amp; TDF_DETAILS))</span>
<span class="lineNum">     735 </span>            :             {
<span class="lineNum">     736 </span><span class="lineCov">          1 :               fprintf (dump_file, &quot;Equivalence: &quot;);</span>
<span class="lineNum">     737 </span><span class="lineCov">          1 :               print_generic_expr (dump_file, curr-&gt;op);</span>
<span class="lineNum">     738 </span><span class="lineCov">          1 :               fprintf (dump_file, &quot; [&amp;|minmax] &quot;);</span>
<span class="lineNum">     739 </span><span class="lineCov">          1 :               print_generic_expr (dump_file, last-&gt;op);</span>
<span class="lineNum">     740 </span><span class="lineCov">          1 :               fprintf (dump_file, &quot; -&gt; &quot;);</span>
<span class="lineNum">     741 </span><span class="lineCov">          1 :               print_generic_stmt (dump_file, last-&gt;op);</span>
<span class="lineNum">     742 </span>            :             }
<span class="lineNum">     743 </span>            : 
<span class="lineNum">     744 </span><span class="lineCov">         48 :           ops-&gt;ordered_remove (i);</span>
<span class="lineNum">     745 </span><span class="lineCov">         48 :           reassociate_stats.ops_eliminated ++;</span>
<span class="lineNum">     746 </span>            : 
<span class="lineNum">     747 </span><span class="lineCov">         48 :           return true;</span>
<span class="lineNum">     748 </span>            : 
<span class="lineNum">     749 </span><span class="lineCov">         16 :         case BIT_XOR_EXPR:</span>
<span class="lineNum">     750 </span><span class="lineCov">         16 :           if (dump_file &amp;&amp; (dump_flags &amp; TDF_DETAILS))</span>
<span class="lineNum">     751 </span>            :             {
<span class="lineNum">     752 </span><span class="lineNoCov">          0 :               fprintf (dump_file, &quot;Equivalence: &quot;);</span>
<span class="lineNum">     753 </span><span class="lineNoCov">          0 :               print_generic_expr (dump_file, curr-&gt;op);</span>
<span class="lineNum">     754 </span><span class="lineNoCov">          0 :               fprintf (dump_file, &quot; ^ &quot;);</span>
<span class="lineNum">     755 </span><span class="lineNoCov">          0 :               print_generic_expr (dump_file, last-&gt;op);</span>
<span class="lineNum">     756 </span><span class="lineNoCov">          0 :               fprintf (dump_file, &quot; -&gt; nothing\n&quot;);</span>
<span class="lineNum">     757 </span>            :             }
<span class="lineNum">     758 </span>            : 
<span class="lineNum">     759 </span><span class="lineCov">         16 :           reassociate_stats.ops_eliminated += 2;</span>
<span class="lineNum">     760 </span>            : 
<span class="lineNum">     761 </span><span class="lineCov">         16 :           if (ops-&gt;length () == 2)</span>
<span class="lineNum">     762 </span>            :             {
<span class="lineNum">     763 </span><span class="lineCov">          1 :               ops-&gt;truncate (0);</span>
<span class="lineNum">     764 </span><span class="lineCov">          1 :               add_to_ops_vec (ops, build_zero_cst (TREE_TYPE (last-&gt;op)));</span>
<span class="lineNum">     765 </span><span class="lineCov">          1 :               *all_done = true;</span>
<span class="lineNum">     766 </span>            :             }
<span class="lineNum">     767 </span>            :           else
<span class="lineNum">     768 </span>            :             {
<span class="lineNum">     769 </span><span class="lineCov">         15 :               ops-&gt;ordered_remove (i-1);</span>
<span class="lineNum">     770 </span><span class="lineCov">         15 :               ops-&gt;ordered_remove (i-1);</span>
<span class="lineNum">     771 </span>            :             }
<span class="lineNum">     772 </span>            : 
<span class="lineNum">     773 </span><span class="lineCov">         16 :           return true;</span>
<span class="lineNum">     774 </span>            : 
<span class="lineNum">     775 </span>            :         default:
<span class="lineNum">     776 </span>            :           break;
<span class="lineNum">     777 </span>            :         }
<span class="lineNum">     778 </span>            :     }
<span class="lineNum">     779 </span>            :   return false;
<span class="lineNum">     780 </span>            : }
<span class="lineNum">     781 </span>            : 
<span class="lineNum">     782 </span>            : static vec&lt;tree&gt; plus_negates;
<span class="lineNum">     783 </span>            : 
<span class="lineNum">     784 </span>            : /* If OPCODE is PLUS_EXPR, CURR-&gt;OP is a negate expression or a bitwise not
<span class="lineNum">     785 </span>            :    expression, look in OPS for a corresponding positive operation to cancel
<span class="lineNum">     786 </span>            :    it out.  If we find one, remove the other from OPS, replace
<span class="lineNum">     787 </span>            :    OPS[CURRINDEX] with 0 or -1, respectively, and return true.  Otherwise,
<span class="lineNum">     788 </span>            :    return false. */
<span class="lineNum">     789 </span>            : 
<span class="lineNum">     790 </span>            : static bool
<span class="lineNum">     791 </span><span class="lineCov">    4913107 : eliminate_plus_minus_pair (enum tree_code opcode,</span>
<span class="lineNum">     792 </span>            :                            vec&lt;operand_entry *&gt; *ops,
<span class="lineNum">     793 </span>            :                            unsigned int currindex,
<span class="lineNum">     794 </span>            :                            operand_entry *curr)
<span class="lineNum">     795 </span>            : {
<span class="lineNum">     796 </span><span class="lineCov">    4913107 :   tree negateop;</span>
<span class="lineNum">     797 </span><span class="lineCov">    4913107 :   tree notop;</span>
<span class="lineNum">     798 </span><span class="lineCov">    4913107 :   unsigned int i;</span>
<span class="lineNum">     799 </span><span class="lineCov">    4913107 :   operand_entry *oe;</span>
<span class="lineNum">     800 </span>            : 
<span class="lineNum">     801 </span><span class="lineCov">    4913107 :   if (opcode != PLUS_EXPR || TREE_CODE (curr-&gt;op) != SSA_NAME)</span>
<span class="lineNum">     802 </span>            :     return false;
<span class="lineNum">     803 </span>            : 
<span class="lineNum">     804 </span><span class="lineCov">    1445599 :   negateop = get_unary_op (curr-&gt;op, NEGATE_EXPR);</span>
<span class="lineNum">     805 </span><span class="lineCov">    1445599 :   notop = get_unary_op (curr-&gt;op, BIT_NOT_EXPR);</span>
<span class="lineNum">     806 </span><span class="lineCov">    1445599 :   if (negateop == NULL_TREE &amp;&amp; notop == NULL_TREE)</span>
<span class="lineNum">     807 </span>            :     return false;
<span class="lineNum">     808 </span>            : 
<span class="lineNum">     809 </span>            :   /* Any non-negated version will have a rank that is one less than
<span class="lineNum">     810 </span>            :      the current rank.  So once we hit those ranks, if we don't find
<span class="lineNum">     811 </span>            :      one, we can stop.  */
<span class="lineNum">     812 </span>            : 
<span class="lineNum">     813 </span><span class="lineCov">      80110 :   for (i = currindex + 1;</span>
<span class="lineNum">     814 </span><span class="lineCov">      80110 :        ops-&gt;iterate (i, &amp;oe)</span>
<span class="lineNum">     815 </span><span class="lineCov">      59742 :        &amp;&amp; oe-&gt;rank &gt;= curr-&gt;rank - 1 ;</span>
<span class="lineNum">     816 </span>            :        i++)
<span class="lineNum">     817 </span>            :     {
<span class="lineNum">     818 </span><span class="lineCov">      29705 :       if (negateop</span>
<span class="lineNum">     819 </span><span class="lineCov">      29705 :           &amp;&amp; ops_equal_values_p (oe-&gt;op, negateop))</span>
<span class="lineNum">     820 </span>            :         {
<span class="lineNum">     821 </span><span class="lineCov">        825 :           if (dump_file &amp;&amp; (dump_flags &amp; TDF_DETAILS))</span>
<span class="lineNum">     822 </span>            :             {
<span class="lineNum">     823 </span><span class="lineNoCov">          0 :               fprintf (dump_file, &quot;Equivalence: &quot;);</span>
<span class="lineNum">     824 </span><span class="lineNoCov">          0 :               print_generic_expr (dump_file, negateop);</span>
<span class="lineNum">     825 </span><span class="lineNoCov">          0 :               fprintf (dump_file, &quot; + -&quot;);</span>
<span class="lineNum">     826 </span><span class="lineNoCov">          0 :               print_generic_expr (dump_file, oe-&gt;op);</span>
<span class="lineNum">     827 </span><span class="lineNoCov">          0 :               fprintf (dump_file, &quot; -&gt; 0\n&quot;);</span>
<span class="lineNum">     828 </span>            :             }
<span class="lineNum">     829 </span>            : 
<span class="lineNum">     830 </span><span class="lineCov">        825 :           ops-&gt;ordered_remove (i);</span>
<span class="lineNum">     831 </span><span class="lineCov">        825 :           add_to_ops_vec (ops, build_zero_cst (TREE_TYPE (oe-&gt;op)));</span>
<span class="lineNum">     832 </span><span class="lineCov">        825 :           ops-&gt;ordered_remove (currindex);</span>
<span class="lineNum">     833 </span><span class="lineCov">        825 :           reassociate_stats.ops_eliminated ++;</span>
<span class="lineNum">     834 </span>            : 
<span class="lineNum">     835 </span><span class="lineCov">        825 :           return true;</span>
<span class="lineNum">     836 </span>            :         }
<span class="lineNum">     837 </span><span class="lineCov">      28880 :       else if (notop</span>
<span class="lineNum">     838 </span><span class="lineCov">      28880 :                &amp;&amp; ops_equal_values_p (oe-&gt;op, notop))</span>
<span class="lineNum">     839 </span>            :         {
<span class="lineNum">     840 </span><span class="lineCov">        749 :           tree op_type = TREE_TYPE (oe-&gt;op);</span>
<span class="lineNum">     841 </span>            : 
<span class="lineNum">     842 </span><span class="lineCov">        749 :           if (dump_file &amp;&amp; (dump_flags &amp; TDF_DETAILS))</span>
<span class="lineNum">     843 </span>            :             {
<span class="lineNum">     844 </span><span class="lineNoCov">          0 :               fprintf (dump_file, &quot;Equivalence: &quot;);</span>
<span class="lineNum">     845 </span><span class="lineNoCov">          0 :               print_generic_expr (dump_file, notop);</span>
<span class="lineNum">     846 </span><span class="lineNoCov">          0 :               fprintf (dump_file, &quot; + ~&quot;);</span>
<span class="lineNum">     847 </span><span class="lineNoCov">          0 :               print_generic_expr (dump_file, oe-&gt;op);</span>
<span class="lineNum">     848 </span><span class="lineNoCov">          0 :               fprintf (dump_file, &quot; -&gt; -1\n&quot;);</span>
<span class="lineNum">     849 </span>            :             }
<span class="lineNum">     850 </span>            : 
<span class="lineNum">     851 </span><span class="lineCov">        749 :           ops-&gt;ordered_remove (i);</span>
<span class="lineNum">     852 </span><span class="lineCov">        749 :           add_to_ops_vec (ops, build_all_ones_cst (op_type));</span>
<span class="lineNum">     853 </span><span class="lineCov">        749 :           ops-&gt;ordered_remove (currindex);</span>
<span class="lineNum">     854 </span><span class="lineCov">        749 :           reassociate_stats.ops_eliminated ++;</span>
<span class="lineNum">     855 </span>            : 
<span class="lineNum">     856 </span><span class="lineCov">        749 :           return true;</span>
<span class="lineNum">     857 </span>            :         }
<span class="lineNum">     858 </span>            :     }
<span class="lineNum">     859 </span>            : 
<span class="lineNum">     860 </span>            :   /* If CURR-&gt;OP is a negate expr without nop conversion in a plus expr: 
<span class="lineNum">     861 </span>            :      save it for later inspection in repropagate_negates().  */
<span class="lineNum">     862 </span><span class="lineCov">      50405 :   if (negateop != NULL_TREE</span>
<span class="lineNum">     863 </span><span class="lineCov">      50405 :       &amp;&amp; gimple_assign_rhs_code (SSA_NAME_DEF_STMT (curr-&gt;op)) == NEGATE_EXPR)</span>
<span class="lineNum">     864 </span><span class="lineCov">      50018 :     plus_negates.safe_push (curr-&gt;op);</span>
<span class="lineNum">     865 </span>            : 
<span class="lineNum">     866 </span>            :   return false;
<span class="lineNum">     867 </span>            : }
<span class="lineNum">     868 </span>            : 
<span class="lineNum">     869 </span>            : /* If OPCODE is BIT_IOR_EXPR, BIT_AND_EXPR, and, CURR-&gt;OP is really a
<span class="lineNum">     870 </span>            :    bitwise not expression, look in OPS for a corresponding operand to
<span class="lineNum">     871 </span>            :    cancel it out.  If we find one, remove the other from OPS, replace
<span class="lineNum">     872 </span>            :    OPS[CURRINDEX] with 0, and return true.  Otherwise, return
<span class="lineNum">     873 </span>            :    false. */
<span class="lineNum">     874 </span>            : 
<span class="lineNum">     875 </span>            : static bool
<span class="lineNum">     876 </span><span class="lineCov">    4913172 : eliminate_not_pairs (enum tree_code opcode,</span>
<span class="lineNum">     877 </span>            :                      vec&lt;operand_entry *&gt; *ops,
<span class="lineNum">     878 </span>            :                      unsigned int currindex,
<span class="lineNum">     879 </span>            :                      operand_entry *curr)
<span class="lineNum">     880 </span>            : {
<span class="lineNum">     881 </span><span class="lineCov">    4913172 :   tree notop;</span>
<span class="lineNum">     882 </span><span class="lineCov">    4913172 :   unsigned int i;</span>
<span class="lineNum">     883 </span><span class="lineCov">    4913172 :   operand_entry *oe;</span>
<span class="lineNum">     884 </span>            : 
<span class="lineNum">     885 </span><span class="lineCov">    4913172 :   if ((opcode != BIT_IOR_EXPR &amp;&amp; opcode != BIT_AND_EXPR)</span>
<span class="lineNum">     886 </span><span class="lineCov">    1226511 :       || TREE_CODE (curr-&gt;op) != SSA_NAME)</span>
<span class="lineNum">     887 </span>            :     return false;
<span class="lineNum">     888 </span>            : 
<span class="lineNum">     889 </span><span class="lineCov">     932225 :   notop = get_unary_op (curr-&gt;op, BIT_NOT_EXPR);</span>
<span class="lineNum">     890 </span><span class="lineCov">     932225 :   if (notop == NULL_TREE)</span>
<span class="lineNum">     891 </span>            :     return false;
<span class="lineNum">     892 </span>            : 
<span class="lineNum">     893 </span>            :   /* Any non-not version will have a rank that is one less than
<span class="lineNum">     894 </span>            :      the current rank.  So once we hit those ranks, if we don't find
<span class="lineNum">     895 </span>            :      one, we can stop.  */
<span class="lineNum">     896 </span>            : 
<span class="lineNum">     897 </span><span class="lineCov">      11898 :   for (i = currindex + 1;</span>
<span class="lineNum">     898 </span><span class="lineCov">      11898 :        ops-&gt;iterate (i, &amp;oe)</span>
<span class="lineNum">     899 </span><span class="lineCov">       5770 :        &amp;&amp; oe-&gt;rank &gt;= curr-&gt;rank - 1;</span>
<span class="lineNum">     900 </span>            :        i++)
<span class="lineNum">     901 </span>            :     {
<span class="lineNum">     902 </span><span class="lineCov">       1942 :       if (oe-&gt;op == notop)</span>
<span class="lineNum">     903 </span>            :         {
<span class="lineNum">     904 </span><span class="lineCov">          1 :           if (dump_file &amp;&amp; (dump_flags &amp; TDF_DETAILS))</span>
<span class="lineNum">     905 </span>            :             {
<span class="lineNum">     906 </span><span class="lineNoCov">          0 :               fprintf (dump_file, &quot;Equivalence: &quot;);</span>
<span class="lineNum">     907 </span><span class="lineNoCov">          0 :               print_generic_expr (dump_file, notop);</span>
<span class="lineNum">     908 </span><span class="lineNoCov">          0 :               if (opcode == BIT_AND_EXPR)</span>
<span class="lineNum">     909 </span><span class="lineNoCov">          0 :                 fprintf (dump_file, &quot; &amp; ~&quot;);</span>
<span class="lineNum">     910 </span><span class="lineNoCov">          0 :               else if (opcode == BIT_IOR_EXPR)</span>
<span class="lineNum">     911 </span><span class="lineNoCov">          0 :                 fprintf (dump_file, &quot; | ~&quot;);</span>
<span class="lineNum">     912 </span><span class="lineNoCov">          0 :               print_generic_expr (dump_file, oe-&gt;op);</span>
<span class="lineNum">     913 </span><span class="lineNoCov">          0 :               if (opcode == BIT_AND_EXPR)</span>
<span class="lineNum">     914 </span><span class="lineNoCov">          0 :                 fprintf (dump_file, &quot; -&gt; 0\n&quot;);</span>
<span class="lineNum">     915 </span><span class="lineNoCov">          0 :               else if (opcode == BIT_IOR_EXPR)</span>
<span class="lineNum">     916 </span><span class="lineNoCov">          0 :                 fprintf (dump_file, &quot; -&gt; -1\n&quot;);</span>
<span class="lineNum">     917 </span>            :             }
<span class="lineNum">     918 </span>            : 
<span class="lineNum">     919 </span><span class="lineCov">          1 :           if (opcode == BIT_AND_EXPR)</span>
<span class="lineNum">     920 </span><span class="lineCov">          1 :             oe-&gt;op = build_zero_cst (TREE_TYPE (oe-&gt;op));</span>
<span class="lineNum">     921 </span><span class="lineNoCov">          0 :           else if (opcode == BIT_IOR_EXPR)</span>
<span class="lineNum">     922 </span><span class="lineNoCov">          0 :             oe-&gt;op = build_all_ones_cst (TREE_TYPE (oe-&gt;op));</span>
<span class="lineNum">     923 </span>            : 
<span class="lineNum">     924 </span><span class="lineCov">          1 :           reassociate_stats.ops_eliminated += ops-&gt;length () - 1;</span>
<span class="lineNum">     925 </span><span class="lineCov">          1 :           ops-&gt;truncate (0);</span>
<span class="lineNum">     926 </span><span class="lineCov">          1 :           ops-&gt;quick_push (oe);</span>
<span class="lineNum">     927 </span><span class="lineCov">          1 :           return true;</span>
<span class="lineNum">     928 </span>            :         }
<span class="lineNum">     929 </span>            :     }
<span class="lineNum">     930 </span>            : 
<span class="lineNum">     931 </span>            :   return false;
<span class="lineNum">     932 </span>            : }
<span class="lineNum">     933 </span>            : 
<span class="lineNum">     934 </span>            : /* Use constant value that may be present in OPS to try to eliminate
<span class="lineNum">     935 </span>            :    operands.  Note that this function is only really used when we've
<span class="lineNum">     936 </span>            :    eliminated ops for other reasons, or merged constants.  Across
<span class="lineNum">     937 </span>            :    single statements, fold already does all of this, plus more.  There
<span class="lineNum">     938 </span>            :    is little point in duplicating logic, so I've only included the
<span class="lineNum">     939 </span>            :    identities that I could ever construct testcases to trigger.  */
<span class="lineNum">     940 </span>            : 
<span class="lineNum">     941 </span>            : static void
<span class="lineNum">     942 </span><span class="lineCov">    2390163 : eliminate_using_constants (enum tree_code opcode,</span>
<span class="lineNum">     943 </span>            :                            vec&lt;operand_entry *&gt; *ops)
<span class="lineNum">     944 </span>            : {
<span class="lineNum">     945 </span><span class="lineCov">    2390163 :   operand_entry *oelast = ops-&gt;last ();</span>
<span class="lineNum">     946 </span><span class="lineCov">    2390163 :   tree type = TREE_TYPE (oelast-&gt;op);</span>
<span class="lineNum">     947 </span>            : 
<span class="lineNum">     948 </span><span class="lineCov">    2390163 :   if (oelast-&gt;rank == 0</span>
<span class="lineNum">     949 </span><span class="lineCov">    2390163 :       &amp;&amp; (ANY_INTEGRAL_TYPE_P (type) || FLOAT_TYPE_P (type)))</span>
<span class="lineNum">     950 </span>            :     {
<span class="lineNum">     951 </span><span class="lineCov">    1649648 :       switch (opcode)</span>
<span class="lineNum">     952 </span>            :         {
<span class="lineNum">     953 </span><span class="lineCov">     260406 :         case BIT_AND_EXPR:</span>
<span class="lineNum">     954 </span><span class="lineCov">     260406 :           if (integer_zerop (oelast-&gt;op))</span>
<span class="lineNum">     955 </span>            :             {
<span class="lineNum">     956 </span><span class="lineNoCov">          0 :               if (ops-&gt;length () != 1)</span>
<span class="lineNum">     957 </span>            :                 {
<span class="lineNum">     958 </span><span class="lineNoCov">          0 :                   if (dump_file &amp;&amp; (dump_flags &amp; TDF_DETAILS))</span>
<span class="lineNum">     959 </span><span class="lineNoCov">          0 :                     fprintf (dump_file, &quot;Found &amp; 0, removing all other ops\n&quot;);</span>
<span class="lineNum">     960 </span>            : 
<span class="lineNum">     961 </span><span class="lineNoCov">          0 :                   reassociate_stats.ops_eliminated += ops-&gt;length () - 1;</span>
<span class="lineNum">     962 </span>            : 
<span class="lineNum">     963 </span><span class="lineNoCov">          0 :                   ops-&gt;truncate (0);</span>
<span class="lineNum">     964 </span><span class="lineNoCov">          0 :                   ops-&gt;quick_push (oelast);</span>
<span class="lineNum">     965 </span><span class="lineNoCov">          0 :                   return;</span>
<span class="lineNum">     966 </span>            :                 }
<span class="lineNum">     967 </span>            :             }
<span class="lineNum">     968 </span><span class="lineCov">     260406 :           else if (integer_all_onesp (oelast-&gt;op))</span>
<span class="lineNum">     969 </span>            :             {
<span class="lineNum">     970 </span><span class="lineCov">         23 :               if (ops-&gt;length () != 1)</span>
<span class="lineNum">     971 </span>            :                 {
<span class="lineNum">     972 </span><span class="lineCov">         23 :                   if (dump_file &amp;&amp; (dump_flags &amp; TDF_DETAILS))</span>
<span class="lineNum">     973 </span><span class="lineNoCov">          0 :                     fprintf (dump_file, &quot;Found &amp; -1, removing\n&quot;);</span>
<span class="lineNum">     974 </span><span class="lineCov">         23 :                   ops-&gt;pop ();</span>
<span class="lineNum">     975 </span><span class="lineCov">         23 :                   reassociate_stats.ops_eliminated++;</span>
<span class="lineNum">     976 </span>            :                 }
<span class="lineNum">     977 </span>            :             }
<span class="lineNum">     978 </span>            :           break;
<span class="lineNum">     979 </span><span class="lineCov">      33575 :         case BIT_IOR_EXPR:</span>
<span class="lineNum">     980 </span><span class="lineCov">      33575 :           if (integer_all_onesp (oelast-&gt;op))</span>
<span class="lineNum">     981 </span>            :             {
<span class="lineNum">     982 </span><span class="lineCov">          5 :               if (ops-&gt;length () != 1)</span>
<span class="lineNum">     983 </span>            :                 {
<span class="lineNum">     984 </span><span class="lineCov">          5 :                   if (dump_file &amp;&amp; (dump_flags &amp; TDF_DETAILS))</span>
<span class="lineNum">     985 </span><span class="lineNoCov">          0 :                     fprintf (dump_file, &quot;Found | -1, removing all other ops\n&quot;);</span>
<span class="lineNum">     986 </span>            : 
<span class="lineNum">     987 </span><span class="lineCov">          5 :                   reassociate_stats.ops_eliminated += ops-&gt;length () - 1;</span>
<span class="lineNum">     988 </span>            : 
<span class="lineNum">     989 </span><span class="lineCov">          5 :                   ops-&gt;truncate (0);</span>
<span class="lineNum">     990 </span><span class="lineCov">          5 :                   ops-&gt;quick_push (oelast);</span>
<span class="lineNum">     991 </span><span class="lineCov">          5 :                   return;</span>
<span class="lineNum">     992 </span>            :                 }
<span class="lineNum">     993 </span>            :             }
<span class="lineNum">     994 </span><span class="lineCov">      33570 :           else if (integer_zerop (oelast-&gt;op))</span>
<span class="lineNum">     995 </span>            :             {
<span class="lineNum">     996 </span><span class="lineCov">         28 :               if (ops-&gt;length () != 1)</span>
<span class="lineNum">     997 </span>            :                 {
<span class="lineNum">     998 </span><span class="lineCov">         28 :                   if (dump_file &amp;&amp; (dump_flags &amp; TDF_DETAILS))</span>
<span class="lineNum">     999 </span><span class="lineNoCov">          0 :                     fprintf (dump_file, &quot;Found | 0, removing\n&quot;);</span>
<span class="lineNum">    1000 </span><span class="lineCov">         28 :                   ops-&gt;pop ();</span>
<span class="lineNum">    1001 </span><span class="lineCov">         28 :                   reassociate_stats.ops_eliminated++;</span>
<span class="lineNum">    1002 </span>            :                 }
<span class="lineNum">    1003 </span>            :             }
<span class="lineNum">    1004 </span>            :           break;
<span class="lineNum">    1005 </span><span class="lineCov">     499208 :         case MULT_EXPR:</span>
<span class="lineNum">    1006 </span><span class="lineCov">     499208 :           if (integer_zerop (oelast-&gt;op)</span>
<span class="lineNum">    1007 </span><span class="lineCov">     499208 :               || (FLOAT_TYPE_P (type)</span>
<span class="lineNum">    1008 </span><span class="lineCov">       1155 :                   &amp;&amp; !HONOR_NANS (type)</span>
<span class="lineNum">    1009 </span><span class="lineCov">       1138 :                   &amp;&amp; !HONOR_SIGNED_ZEROS (type)</span>
<span class="lineNum">    1010 </span><span class="lineCov">       1138 :                   &amp;&amp; real_zerop (oelast-&gt;op)))</span>
<span class="lineNum">    1011 </span>            :             {
<span class="lineNum">    1012 </span><span class="lineNoCov">          0 :               if (ops-&gt;length () != 1)</span>
<span class="lineNum">    1013 </span>            :                 {
<span class="lineNum">    1014 </span><span class="lineNoCov">          0 :                   if (dump_file &amp;&amp; (dump_flags &amp; TDF_DETAILS))</span>
<span class="lineNum">    1015 </span><span class="lineNoCov">          0 :                     fprintf (dump_file, &quot;Found * 0, removing all other ops\n&quot;);</span>
<span class="lineNum">    1016 </span>            : 
<span class="lineNum">    1017 </span><span class="lineNoCov">          0 :                   reassociate_stats.ops_eliminated += ops-&gt;length () - 1;</span>
<span class="lineNum">    1018 </span><span class="lineNoCov">          0 :                   ops-&gt;truncate (1);</span>
<span class="lineNum">    1019 </span><span class="lineNoCov">          0 :                   ops-&gt;quick_push (oelast);</span>
<span class="lineNum">    1020 </span><span class="lineNoCov">          0 :                   return;</span>
<span class="lineNum">    1021 </span>            :                 }
<span class="lineNum">    1022 </span>            :             }
<span class="lineNum">    1023 </span><span class="lineCov">     499208 :           else if (integer_onep (oelast-&gt;op)</span>
<span class="lineNum">    1024 </span><span class="lineCov">     499208 :                    || (FLOAT_TYPE_P (type)</span>
<span class="lineNum">    1025 </span><span class="lineCov">       1155 :                        &amp;&amp; !HONOR_SNANS (type)</span>
<span class="lineNum">    1026 </span><span class="lineCov">       1155 :                        &amp;&amp; real_onep (oelast-&gt;op)))</span>
<span class="lineNum">    1027 </span>            :             {
<span class="lineNum">    1028 </span><span class="lineCov">          9 :               if (ops-&gt;length () != 1)</span>
<span class="lineNum">    1029 </span>            :                 {
<span class="lineNum">    1030 </span><span class="lineCov">          9 :                   if (dump_file &amp;&amp; (dump_flags &amp; TDF_DETAILS))</span>
<span class="lineNum">    1031 </span><span class="lineNoCov">          0 :                     fprintf (dump_file, &quot;Found * 1, removing\n&quot;);</span>
<span class="lineNum">    1032 </span><span class="lineCov">          9 :                   ops-&gt;pop ();</span>
<span class="lineNum">    1033 </span><span class="lineCov">          9 :                   reassociate_stats.ops_eliminated++;</span>
<span class="lineNum">    1034 </span><span class="lineCov">          9 :                   return;</span>
<span class="lineNum">    1035 </span>            :                 }
<span class="lineNum">    1036 </span>            :             }
<span class="lineNum">    1037 </span>            :           break;
<span class="lineNum">    1038 </span><span class="lineCov">     806633 :         case BIT_XOR_EXPR:</span>
<span class="lineNum">    1039 </span><span class="lineCov">     806633 :         case PLUS_EXPR:</span>
<span class="lineNum">    1040 </span><span class="lineCov">     806633 :         case MINUS_EXPR:</span>
<span class="lineNum">    1041 </span><span class="lineCov">     806633 :           if (integer_zerop (oelast-&gt;op)</span>
<span class="lineNum">    1042 </span><span class="lineCov">     806633 :               || (FLOAT_TYPE_P (type)</span>
<span class="lineNum">    1043 </span><span class="lineCov">        613 :                   &amp;&amp; (opcode == PLUS_EXPR || opcode == MINUS_EXPR)</span>
<span class="lineNum">    1044 </span><span class="lineCov">        613 :                   &amp;&amp; fold_real_zero_addition_p (type, oelast-&gt;op,</span>
<span class="lineNum">    1045 </span>            :                                                 opcode == MINUS_EXPR)))
<span class="lineNum">    1046 </span>            :             {
<span class="lineNum">    1047 </span><span class="lineCov">        976 :               if (ops-&gt;length () != 1)</span>
<span class="lineNum">    1048 </span>            :                 {
<span class="lineNum">    1049 </span><span class="lineCov">        976 :                   if (dump_file &amp;&amp; (dump_flags &amp; TDF_DETAILS))</span>
<span class="lineNum">    1050 </span><span class="lineNoCov">          0 :                     fprintf (dump_file, &quot;Found [|^+] 0, removing\n&quot;);</span>
<span class="lineNum">    1051 </span><span class="lineCov">        976 :                   ops-&gt;pop ();</span>
<span class="lineNum">    1052 </span><span class="lineCov">        976 :                   reassociate_stats.ops_eliminated++;</span>
<span class="lineNum">    1053 </span><span class="lineCov">        976 :                   return;</span>
<span class="lineNum">    1054 </span>            :                 }
<span class="lineNum">    1055 </span>            :             }
<span class="lineNum">    1056 </span>            :           break;
<span class="lineNum">    1057 </span>            :         default:
<span class="lineNum">    1058 </span>            :           break;
<span class="lineNum">    1059 </span>            :         }
<span class="lineNum">    1060 </span>            :     }
<span class="lineNum">    1061 </span>            : }
<span class="lineNum">    1062 </span>            : 
<span class="lineNum">    1063 </span>            : 
<span class="lineNum">    1064 </span>            : static void linearize_expr_tree (vec&lt;operand_entry *&gt; *, gimple *,
<span class="lineNum">    1065 </span>            :                                  bool, bool);
<span class="lineNum">    1066 </span>            : 
<span class="lineNum">    1067 </span>            : /* Structure for tracking and counting operands.  */
<span class="lineNum">    1068 </span>            : struct oecount {
<span class="lineNum">    1069 </span>            :   unsigned int cnt;
<span class="lineNum">    1070 </span>            :   unsigned int id;
<span class="lineNum">    1071 </span>            :   enum tree_code oecode;
<span class="lineNum">    1072 </span>            :   tree op;
<span class="lineNum">    1073 </span>            : };
<span class="lineNum">    1074 </span>            : 
<span class="lineNum">    1075 </span>            : 
<span class="lineNum">    1076 </span>            : /* The heap for the oecount hashtable and the sorted list of operands.  */
<span class="lineNum">    1077 </span>            : static vec&lt;oecount&gt; cvec;
<span class="lineNum">    1078 </span>            : 
<span class="lineNum">    1079 </span>            : 
<span class="lineNum">    1080 </span>            : /* Oecount hashtable helpers.  */
<span class="lineNum">    1081 </span>            : 
<span class="lineNum">    1082 </span>            : struct oecount_hasher : int_hash &lt;int, 0, 1&gt;
<span class="lineNum">    1083 </span>            : {
<span class="lineNum">    1084 </span>            :   static inline hashval_t hash (int);
<span class="lineNum">    1085 </span>            :   static inline bool equal (int, int);
<span class="lineNum">    1086 </span>            : };
<span class="lineNum">    1087 </span>            : 
<span class="lineNum">    1088 </span>            : /* Hash function for oecount.  */
<span class="lineNum">    1089 </span>            : 
<span class="lineNum">    1090 </span>            : inline hashval_t
<span class="lineNum">    1091 </span><span class="lineCov">      57098 : oecount_hasher::hash (int p)</span>
<span class="lineNum">    1092 </span>            : {
<span class="lineNum">    1093 </span><span class="lineCov">      57098 :   const oecount *c = &amp;cvec[p - 42];</span>
<span class="lineNum">    1094 </span><span class="lineCov">      57098 :   return htab_hash_pointer (c-&gt;op) ^ (hashval_t)c-&gt;oecode;</span>
<span class="lineNum">    1095 </span>            : }
<span class="lineNum">    1096 </span>            : 
<span class="lineNum">    1097 </span>            : /* Comparison function for oecount.  */
<span class="lineNum">    1098 </span>            : 
<span class="lineNum">    1099 </span>            : inline bool
<span class="lineNum">    1100 </span><span class="lineCov">       6972 : oecount_hasher::equal (int p1, int p2)</span>
<span class="lineNum">    1101 </span>            : {
<span class="lineNum">    1102 </span><span class="lineCov">       6972 :   const oecount *c1 = &amp;cvec[p1 - 42];</span>
<span class="lineNum">    1103 </span><span class="lineCov">       6972 :   const oecount *c2 = &amp;cvec[p2 - 42];</span>
<span class="lineNum">    1104 </span><span class="lineCov">       6972 :   return c1-&gt;oecode == c2-&gt;oecode &amp;&amp; c1-&gt;op == c2-&gt;op;</span>
<span class="lineNum">    1105 </span>            : }
<span class="lineNum">    1106 </span>            : 
<span class="lineNum">    1107 </span>            : /* Comparison function for qsort sorting oecount elements by count.  */
<a name="1108"><span class="lineNum">    1108 </span>            : </a>
<span class="lineNum">    1109 </span>            : static int
<span class="lineNum">    1110 </span><span class="lineCov">     411378 : oecount_cmp (const void *p1, const void *p2)</span>
<span class="lineNum">    1111 </span>            : {
<span class="lineNum">    1112 </span><span class="lineCov">     411378 :   const oecount *c1 = (const oecount *)p1;</span>
<span class="lineNum">    1113 </span><span class="lineCov">     411378 :   const oecount *c2 = (const oecount *)p2;</span>
<span class="lineNum">    1114 </span><span class="lineCov">     411378 :   if (c1-&gt;cnt != c2-&gt;cnt)</span>
<span class="lineNum">    1115 </span><span class="lineCov">      12518 :     return c1-&gt;cnt &gt; c2-&gt;cnt ? 1 : -1;</span>
<span class="lineNum">    1116 </span>            :   else
<span class="lineNum">    1117 </span>            :     /* If counts are identical, use unique IDs to stabilize qsort.  */
<span class="lineNum">    1118 </span><span class="lineCov">     589853 :     return c1-&gt;id &gt; c2-&gt;id ? 1 : -1;</span>
<span class="lineNum">    1119 </span>            : }
<span class="lineNum">    1120 </span>            : 
<span class="lineNum">    1121 </span>            : /* Return TRUE iff STMT represents a builtin call that raises OP
<span class="lineNum">    1122 </span>            :    to some exponent.  */
<a name="1123"><span class="lineNum">    1123 </span>            : </a>
<span class="lineNum">    1124 </span>            : static bool
<span class="lineNum">    1125 </span><span class="lineCov">        648 : stmt_is_power_of_op (gimple *stmt, tree op)</span>
<span class="lineNum">    1126 </span>            : {
<span class="lineNum">    1127 </span><span class="lineCov">       1296 :   if (!is_gimple_call (stmt))</span>
<span class="lineNum">    1128 </span>            :     return false;
<span class="lineNum">    1129 </span>            : 
<span class="lineNum">    1130 </span><span class="lineCov">         12 :   switch (gimple_call_combined_fn (stmt))</span>
<span class="lineNum">    1131 </span>            :     {
<span class="lineNum">    1132 </span><span class="lineCov">          7 :     CASE_CFN_POW:</span>
<span class="lineNum">    1133 </span><span class="lineCov">          7 :     CASE_CFN_POWI:</span>
<span class="lineNum">    1134 </span><span class="lineCov">          7 :       return (operand_equal_p (gimple_call_arg (stmt, 0), op, 0));</span>
<span class="lineNum">    1135 </span>            :       
<span class="lineNum">    1136 </span>            :     default:
<span class="lineNum">    1137 </span>            :       return false;
<span class="lineNum">    1138 </span>            :     }
<span class="lineNum">    1139 </span>            : }
<span class="lineNum">    1140 </span>            : 
<span class="lineNum">    1141 </span>            : /* Given STMT which is a __builtin_pow* call, decrement its exponent
<span class="lineNum">    1142 </span>            :    in place and return the result.  Assumes that stmt_is_power_of_op
<span class="lineNum">    1143 </span>            :    was previously called for STMT and returned TRUE.  */
<a name="1144"><span class="lineNum">    1144 </span>            : </a>
<span class="lineNum">    1145 </span>            : static HOST_WIDE_INT
<span class="lineNum">    1146 </span><span class="lineCov">          7 : decrement_power (gimple *stmt)</span>
<span class="lineNum">    1147 </span>            : {
<span class="lineNum">    1148 </span><span class="lineCov">          7 :   REAL_VALUE_TYPE c, cint;</span>
<span class="lineNum">    1149 </span><span class="lineCov">          7 :   HOST_WIDE_INT power;</span>
<span class="lineNum">    1150 </span><span class="lineCov">          7 :   tree arg1;</span>
<span class="lineNum">    1151 </span>            : 
<span class="lineNum">    1152 </span><span class="lineCov">          7 :   switch (gimple_call_combined_fn (stmt))</span>
<span class="lineNum">    1153 </span>            :     {
<span class="lineNum">    1154 </span><span class="lineNoCov">          0 :     CASE_CFN_POW:</span>
<span class="lineNum">    1155 </span><span class="lineNoCov">          0 :       arg1 = gimple_call_arg (stmt, 1);</span>
<span class="lineNum">    1156 </span><span class="lineNoCov">          0 :       c = TREE_REAL_CST (arg1);</span>
<span class="lineNum">    1157 </span><span class="lineNoCov">          0 :       power = real_to_integer (&amp;c) - 1;</span>
<span class="lineNum">    1158 </span><span class="lineNoCov">          0 :       real_from_integer (&amp;cint, VOIDmode, power, SIGNED);</span>
<span class="lineNum">    1159 </span><span class="lineNoCov">          0 :       gimple_call_set_arg (stmt, 1, build_real (TREE_TYPE (arg1), cint));</span>
<span class="lineNum">    1160 </span><span class="lineNoCov">          0 :       return power;</span>
<span class="lineNum">    1161 </span>            : 
<span class="lineNum">    1162 </span><span class="lineCov">          7 :     CASE_CFN_POWI:</span>
<span class="lineNum">    1163 </span><span class="lineCov">          7 :       arg1 = gimple_call_arg (stmt, 1);</span>
<span class="lineNum">    1164 </span><span class="lineCov">          7 :       power = TREE_INT_CST_LOW (arg1) - 1;</span>
<span class="lineNum">    1165 </span><span class="lineCov">         14 :       gimple_call_set_arg (stmt, 1, build_int_cst (TREE_TYPE (arg1), power));</span>
<span class="lineNum">    1166 </span><span class="lineCov">          7 :       return power;</span>
<span class="lineNum">    1167 </span>            : 
<span class="lineNum">    1168 </span><span class="lineNoCov">          0 :     default:</span>
<span class="lineNum">    1169 </span><span class="lineNoCov">          0 :       gcc_unreachable ();</span>
<span class="lineNum">    1170 </span>            :     }
<span class="lineNum">    1171 </span>            : }
<span class="lineNum">    1172 </span>            : 
<span class="lineNum">    1173 </span>            : /* Replace SSA defined by STMT and replace all its uses with new
<span class="lineNum">    1174 </span>            :    SSA.  Also return the new SSA.  */
<a name="1175"><span class="lineNum">    1175 </span>            : </a>
<span class="lineNum">    1176 </span>            : static tree
<span class="lineNum">    1177 </span><span class="lineCov">        215 : make_new_ssa_for_def (gimple *stmt, enum tree_code opcode, tree op)</span>
<span class="lineNum">    1178 </span>            : {
<span class="lineNum">    1179 </span><span class="lineCov">        215 :   gimple *use_stmt;</span>
<span class="lineNum">    1180 </span><span class="lineCov">        215 :   use_operand_p use;</span>
<span class="lineNum">    1181 </span><span class="lineCov">        215 :   imm_use_iterator iter;</span>
<span class="lineNum">    1182 </span><span class="lineCov">        215 :   tree new_lhs, new_debug_lhs = NULL_TREE;</span>
<span class="lineNum">    1183 </span><span class="lineCov">        215 :   tree lhs = gimple_get_lhs (stmt);</span>
<span class="lineNum">    1184 </span>            : 
<span class="lineNum">    1185 </span><span class="lineCov">        215 :   new_lhs = make_ssa_name (TREE_TYPE (lhs));</span>
<span class="lineNum">    1186 </span><span class="lineCov">        215 :   gimple_set_lhs (stmt, new_lhs);</span>
<span class="lineNum">    1187 </span>            : 
<span class="lineNum">    1188 </span>            :   /* Also need to update GIMPLE_DEBUGs.  */
<span class="lineNum">    1189 </span><span class="lineCov">        671 :   FOR_EACH_IMM_USE_STMT (use_stmt, iter, lhs)</span>
<span class="lineNum">    1190 </span>            :     {
<span class="lineNum">    1191 </span><span class="lineCov">        228 :       tree repl = new_lhs;</span>
<span class="lineNum">    1192 </span><span class="lineCov">        456 :       if (is_gimple_debug (use_stmt))</span>
<span class="lineNum">    1193 </span>            :         {
<span class="lineNum">    1194 </span><span class="lineCov">         13 :           if (new_debug_lhs == NULL_TREE)</span>
<span class="lineNum">    1195 </span>            :             {
<span class="lineNum">    1196 </span><span class="lineCov">          7 :               new_debug_lhs = make_node (DEBUG_EXPR_DECL);</span>
<span class="lineNum">    1197 </span><span class="lineCov">          7 :               gdebug *def_temp</span>
<span class="lineNum">    1198 </span><span class="lineCov">          7 :                 = gimple_build_debug_bind (new_debug_lhs,</span>
<span class="lineNum">    1199 </span><span class="lineCov">          7 :                                            build2 (opcode, TREE_TYPE (lhs),</span>
<span class="lineNum">    1200 </span>            :                                                    new_lhs, op),
<span class="lineNum">    1201 </span>            :                                            stmt);
<span class="lineNum">    1202 </span><span class="lineCov">          7 :               DECL_ARTIFICIAL (new_debug_lhs) = 1;</span>
<span class="lineNum">    1203 </span><span class="lineCov">          7 :               TREE_TYPE (new_debug_lhs) = TREE_TYPE (lhs);</span>
<span class="lineNum">    1204 </span><span class="lineCov">          7 :               SET_DECL_MODE (new_debug_lhs, TYPE_MODE (TREE_TYPE (lhs)));</span>
<span class="lineNum">    1205 </span><span class="lineCov">         14 :               gimple_set_uid (def_temp, gimple_uid (stmt));</span>
<span class="lineNum">    1206 </span><span class="lineCov">          7 :               gimple_stmt_iterator gsi = gsi_for_stmt (stmt);</span>
<span class="lineNum">    1207 </span><span class="lineCov">          7 :               gsi_insert_after (&amp;gsi, def_temp, GSI_SAME_STMT);</span>
<span class="lineNum">    1208 </span>            :             }
<span class="lineNum">    1209 </span>            :           repl = new_debug_lhs;
<span class="lineNum">    1210 </span>            :         }
<span class="lineNum">    1211 </span><span class="lineCov">       1368 :       FOR_EACH_IMM_USE_ON_STMT (use, iter)</span>
<span class="lineNum">    1212 </span><span class="lineCov">        228 :         SET_USE (use, repl);</span>
<span class="lineNum">    1213 </span><span class="lineCov">        456 :       update_stmt (use_stmt);</span>
<span class="lineNum">    1214 </span>            :     }
<span class="lineNum">    1215 </span><span class="lineCov">        215 :   return new_lhs;</span>
<span class="lineNum">    1216 </span>            : }
<span class="lineNum">    1217 </span>            : 
<span class="lineNum">    1218 </span>            : /* Replace all SSAs defined in STMTS_TO_FIX and replace its
<span class="lineNum">    1219 </span>            :    uses with new SSAs.  Also do this for the stmt that defines DEF
<span class="lineNum">    1220 </span>            :    if *DEF is not OP.  */
<span class="lineNum">    1221 </span>            : 
<span class="lineNum">    1222 </span>            : static void
<span class="lineNum">    1223 </span><span class="lineCov">        154 : make_new_ssa_for_all_defs (tree *def, enum tree_code opcode, tree op,</span>
<span class="lineNum">    1224 </span>            :                            vec&lt;gimple *&gt; &amp;stmts_to_fix)
<span class="lineNum">    1225 </span>            : {
<span class="lineNum">    1226 </span><span class="lineCov">        154 :   unsigned i;</span>
<span class="lineNum">    1227 </span><span class="lineCov">        154 :   gimple *stmt;</span>
<span class="lineNum">    1228 </span>            : 
<span class="lineNum">    1229 </span><span class="lineCov">        154 :   if (*def != op</span>
<span class="lineNum">    1230 </span><span class="lineCov">        154 :       &amp;&amp; TREE_CODE (*def) == SSA_NAME</span>
<span class="lineNum">    1231 </span><span class="lineCov">        308 :       &amp;&amp; (stmt = SSA_NAME_DEF_STMT (*def))</span>
<span class="lineNum">    1232 </span><span class="lineCov">        462 :       &amp;&amp; gimple_code (stmt) != GIMPLE_NOP)</span>
<span class="lineNum">    1233 </span><span class="lineCov">        154 :     *def = make_new_ssa_for_def (stmt, opcode, op);</span>
<span class="lineNum">    1234 </span>            : 
<span class="lineNum">    1235 </span><span class="lineCov">        215 :   FOR_EACH_VEC_ELT (stmts_to_fix, i, stmt)</span>
<span class="lineNum">    1236 </span><span class="lineCov">         61 :     make_new_ssa_for_def (stmt, opcode, op);</span>
<span class="lineNum">    1237 </span><span class="lineCov">        154 : }</span>
<span class="lineNum">    1238 </span>            : 
<span class="lineNum">    1239 </span>            : /* Find the single immediate use of STMT's LHS, and replace it
<span class="lineNum">    1240 </span>            :    with OP.  Remove STMT.  If STMT's LHS is the same as *DEF,
<span class="lineNum">    1241 </span>            :    replace *DEF with OP as well.  */
<a name="1242"><span class="lineNum">    1242 </span>            : </a>
<span class="lineNum">    1243 </span>            : static void
<span class="lineNum">    1244 </span><span class="lineCov">        423 : propagate_op_to_single_use (tree op, gimple *stmt, tree *def)</span>
<span class="lineNum">    1245 </span>            : {
<span class="lineNum">    1246 </span><span class="lineCov">        423 :   tree lhs;</span>
<span class="lineNum">    1247 </span><span class="lineCov">        423 :   gimple *use_stmt;</span>
<span class="lineNum">    1248 </span><span class="lineCov">        423 :   use_operand_p use;</span>
<span class="lineNum">    1249 </span><span class="lineCov">        423 :   gimple_stmt_iterator gsi;</span>
<span class="lineNum">    1250 </span>            : 
<span class="lineNum">    1251 </span><span class="lineCov">        846 :   if (is_gimple_call (stmt))</span>
<span class="lineNum">    1252 </span><span class="lineCov">          4 :     lhs = gimple_call_lhs (stmt);</span>
<span class="lineNum">    1253 </span>            :   else
<span class="lineNum">    1254 </span><span class="lineCov">        421 :     lhs = gimple_assign_lhs (stmt);</span>
<span class="lineNum">    1255 </span>            : 
<span class="lineNum">    1256 </span><span class="lineCov">        423 :   gcc_assert (has_single_use (lhs));</span>
<span class="lineNum">    1257 </span><span class="lineCov">        423 :   single_imm_use (lhs, &amp;use, &amp;use_stmt);</span>
<span class="lineNum">    1258 </span><span class="lineCov">        423 :   if (lhs == *def)</span>
<span class="lineNum">    1259 </span><span class="lineCov">        278 :     *def = op;</span>
<span class="lineNum">    1260 </span><span class="lineCov">        423 :   SET_USE (use, op);</span>
<span class="lineNum">    1261 </span><span class="lineCov">        423 :   if (TREE_CODE (op) != SSA_NAME)</span>
<span class="lineNum">    1262 </span><span class="lineCov">         35 :     update_stmt (use_stmt);</span>
<span class="lineNum">    1263 </span><span class="lineCov">        423 :   gsi = gsi_for_stmt (stmt);</span>
<span class="lineNum">    1264 </span><span class="lineCov">        423 :   unlink_stmt_vdef (stmt);</span>
<span class="lineNum">    1265 </span><span class="lineCov">        423 :   reassoc_remove_stmt (&amp;gsi);</span>
<span class="lineNum">    1266 </span><span class="lineCov">        423 :   release_defs (stmt);</span>
<span class="lineNum">    1267 </span><span class="lineCov">        423 : }</span>
<span class="lineNum">    1268 </span>            : 
<span class="lineNum">    1269 </span>            : /* Walks the linear chain with result *DEF searching for an operation
<span class="lineNum">    1270 </span>            :    with operand OP and code OPCODE removing that from the chain.  *DEF
<span class="lineNum">    1271 </span>            :    is updated if there is only one operand but no operation left.  */
<span class="lineNum">    1272 </span>            : 
<span class="lineNum">    1273 </span>            : static void
<span class="lineNum">    1274 </span><span class="lineCov">        432 : zero_one_operation (tree *def, enum tree_code opcode, tree op)</span>
<span class="lineNum">    1275 </span>            : {
<span class="lineNum">    1276 </span><span class="lineCov">        432 :   tree orig_def = *def;</span>
<span class="lineNum">    1277 </span><span class="lineCov">        432 :   gimple *stmt = SSA_NAME_DEF_STMT (*def);</span>
<span class="lineNum">    1278 </span>            :   /* PR72835 - Record the stmt chain that has to be updated such that
<span class="lineNum">    1279 </span>            :      we dont use the same LHS when the values computed are different.  */
<span class="lineNum">    1280 </span><span class="lineCov">        864 :   auto_vec&lt;gimple *, 64&gt; stmts_to_fix;</span>
<span class="lineNum">    1281 </span>            : 
<span class="lineNum">    1282 </span><span class="lineCov">        622 :   do</span>
<span class="lineNum">    1283 </span>            :     {
<span class="lineNum">    1284 </span><span class="lineCov">        622 :       tree name;</span>
<span class="lineNum">    1285 </span>            : 
<span class="lineNum">    1286 </span><span class="lineCov">        622 :       if (opcode == MULT_EXPR)</span>
<span class="lineNum">    1287 </span>            :         {
<span class="lineNum">    1288 </span><span class="lineCov">        620 :           if (stmt_is_power_of_op (stmt, op))</span>
<span class="lineNum">    1289 </span>            :             {
<span class="lineNum">    1290 </span><span class="lineNoCov">          0 :               if (decrement_power (stmt) == 1)</span>
<span class="lineNum">    1291 </span>            :                 {
<span class="lineNum">    1292 </span><span class="lineNoCov">          0 :                   if (stmts_to_fix.length () &gt; 0)</span>
<span class="lineNum">    1293 </span><span class="lineNoCov">          0 :                     stmts_to_fix.pop ();</span>
<span class="lineNum">    1294 </span><span class="lineNoCov">          0 :                   propagate_op_to_single_use (op, stmt, def);</span>
<span class="lineNum">    1295 </span>            :                 }
<span class="lineNum">    1296 </span><span class="lineCov">        432 :               break;</span>
<span class="lineNum">    1297 </span>            :             }
<span class="lineNum">    1298 </span><span class="lineCov">        620 :           else if (gimple_assign_rhs_code (stmt) == NEGATE_EXPR)</span>
<span class="lineNum">    1299 </span>            :             {
<span class="lineNum">    1300 </span><span class="lineCov">          7 :               if (gimple_assign_rhs1 (stmt) == op)</span>
<span class="lineNum">    1301 </span>            :                 {
<span class="lineNum">    1302 </span><span class="lineCov">          5 :                   tree cst = build_minus_one_cst (TREE_TYPE (op));</span>
<span class="lineNum">    1303 </span><span class="lineCov">          5 :                   if (stmts_to_fix.length () &gt; 0)</span>
<span class="lineNum">    1304 </span><span class="lineCov">          5 :                     stmts_to_fix.pop ();</span>
<span class="lineNum">    1305 </span><span class="lineCov">          5 :                   propagate_op_to_single_use (cst, stmt, def);</span>
<span class="lineNum">    1306 </span><span class="lineCov">          5 :                   break;</span>
<span class="lineNum">    1307 </span>            :                 }
<span class="lineNum">    1308 </span><span class="lineCov">          2 :               else if (integer_minus_onep (op)</span>
<span class="lineNum">    1309 </span><span class="lineCov">          2 :                        || real_minus_onep (op))</span>
<span class="lineNum">    1310 </span>            :                 {
<span class="lineNum">    1311 </span><span class="lineCov">          2 :                   gimple_assign_set_rhs_code</span>
<span class="lineNum">    1312 </span><span class="lineCov">          2 :                     (stmt, TREE_CODE (gimple_assign_rhs1 (stmt)));</span>
<span class="lineNum">    1313 </span>            :                   break;
<span class="lineNum">    1314 </span>            :                 }
<span class="lineNum">    1315 </span>            :             }
<span class="lineNum">    1316 </span>            :         }
<span class="lineNum">    1317 </span>            : 
<span class="lineNum">    1318 </span><span class="lineCov">        615 :       name = gimple_assign_rhs1 (stmt);</span>
<span class="lineNum">    1319 </span>            : 
<span class="lineNum">    1320 </span>            :       /* If this is the operation we look for and one of the operands
<span class="lineNum">    1321 </span>            :          is ours simply propagate the other operand into the stmts
<span class="lineNum">    1322 </span>            :          single use.  */
<span class="lineNum">    1323 </span><span class="lineCov">        615 :       if (gimple_assign_rhs_code (stmt) == opcode</span>
<span class="lineNum">    1324 </span><span class="lineCov">        615 :           &amp;&amp; (name == op</span>
<span class="lineNum">    1325 </span><span class="lineCov">        529 :               || gimple_assign_rhs2 (stmt) == op))</span>
<span class="lineNum">    1326 </span>            :         {
<span class="lineNum">    1327 </span><span class="lineCov">        409 :           if (name == op)</span>
<span class="lineNum">    1328 </span><span class="lineCov">         86 :             name = gimple_assign_rhs2 (stmt);</span>
<span class="lineNum">    1329 </span><span class="lineCov">        409 :           if (stmts_to_fix.length () &gt; 0)</span>
<span class="lineNum">    1330 </span><span class="lineCov">        131 :             stmts_to_fix.pop ();</span>
<span class="lineNum">    1331 </span><span class="lineCov">        409 :           propagate_op_to_single_use (name, stmt, def);</span>
<span class="lineNum">    1332 </span><span class="lineCov">        409 :           break;</span>
<span class="lineNum">    1333 </span>            :         }
<span class="lineNum">    1334 </span>            : 
<span class="lineNum">    1335 </span>            :       /* We might have a multiply of two __builtin_pow* calls, and
<span class="lineNum">    1336 </span>            :          the operand might be hiding in the rightmost one.  Likewise
<span class="lineNum">    1337 </span>            :          this can happen for a negate.  */
<span class="lineNum">    1338 </span><span class="lineCov">        206 :       if (opcode == MULT_EXPR</span>
<span class="lineNum">    1339 </span><span class="lineCov">        206 :           &amp;&amp; gimple_assign_rhs_code (stmt) == opcode</span>
<span class="lineNum">    1340 </span><span class="lineCov">        206 :           &amp;&amp; TREE_CODE (gimple_assign_rhs2 (stmt)) == SSA_NAME</span>
<span class="lineNum">    1341 </span><span class="lineCov">        366 :           &amp;&amp; has_single_use (gimple_assign_rhs2 (stmt)))</span>
<span class="lineNum">    1342 </span>            :         {
<span class="lineNum">    1343 </span><span class="lineCov">         28 :           gimple *stmt2 = SSA_NAME_DEF_STMT (gimple_assign_rhs2 (stmt));</span>
<span class="lineNum">    1344 </span><span class="lineCov">         28 :           if (stmt_is_power_of_op (stmt2, op))</span>
<span class="lineNum">    1345 </span>            :             {
<span class="lineNum">    1346 </span><span class="lineCov">          7 :               if (decrement_power (stmt2) == 1)</span>
<span class="lineNum">    1347 </span><span class="lineCov">          2 :                 propagate_op_to_single_use (op, stmt2, def);</span>
<span class="lineNum">    1348 </span>            :               else
<span class="lineNum">    1349 </span><span class="lineCov">          5 :                 stmts_to_fix.safe_push (stmt2);</span>
<span class="lineNum">    1350 </span><span class="lineCov">         16 :               break;</span>
<span class="lineNum">    1351 </span>            :             }
<span class="lineNum">    1352 </span><span class="lineCov">         21 :           else if (is_gimple_assign (stmt2)</span>
<span class="lineNum">    1353 </span><span class="lineCov">         21 :                    &amp;&amp; gimple_assign_rhs_code (stmt2) == NEGATE_EXPR)</span>
<span class="lineNum">    1354 </span>            :             {
<span class="lineNum">    1355 </span><span class="lineCov">         18 :               if (gimple_assign_rhs1 (stmt2) == op)</span>
<span class="lineNum">    1356 </span>            :                 {
<span class="lineNum">    1357 </span><span class="lineCov">          7 :                   tree cst = build_minus_one_cst (TREE_TYPE (op));</span>
<span class="lineNum">    1358 </span><span class="lineCov">          7 :                   propagate_op_to_single_use (cst, stmt2, def);</span>
<span class="lineNum">    1359 </span><span class="lineCov">          7 :                   break;</span>
<span class="lineNum">    1360 </span>            :                 }
<span class="lineNum">    1361 </span><span class="lineCov">          2 :               else if (integer_minus_onep (op)</span>
<span class="lineNum">    1362 </span><span class="lineCov">          2 :                        || real_minus_onep (op))</span>
<span class="lineNum">    1363 </span>            :                 {
<span class="lineNum">    1364 </span><span class="lineCov">          2 :                   stmts_to_fix.safe_push (stmt2);</span>
<span class="lineNum">    1365 </span><span class="lineCov">          2 :                   gimple_assign_set_rhs_code</span>
<span class="lineNum">    1366 </span><span class="lineCov">          2 :                     (stmt2, TREE_CODE (gimple_assign_rhs1 (stmt2)));</span>
<span class="lineNum">    1367 </span>            :                   break;
<span class="lineNum">    1368 </span>            :                 }
<span class="lineNum">    1369 </span>            :             }
<span class="lineNum">    1370 </span>            :         }
<span class="lineNum">    1371 </span>            : 
<span class="lineNum">    1372 </span>            :       /* Continue walking the chain.  */
<span class="lineNum">    1373 </span><span class="lineCov">        190 :       gcc_assert (name != op</span>
<span class="lineNum">    1374 </span>            :                   &amp;&amp; TREE_CODE (name) == SSA_NAME);
<span class="lineNum">    1375 </span><span class="lineCov">        190 :       stmt = SSA_NAME_DEF_STMT (name);</span>
<span class="lineNum">    1376 </span><span class="lineCov">        190 :       stmts_to_fix.safe_push (stmt);</span>
<span class="lineNum">    1377 </span>            :     }
<span class="lineNum">    1378 </span>            :   while (1);
<span class="lineNum">    1379 </span>            : 
<span class="lineNum">    1380 </span><span class="lineCov">        432 :   if (stmts_to_fix.length () &gt; 0 || *def == orig_def)</span>
<span class="lineNum">    1381 </span><span class="lineCov">        154 :     make_new_ssa_for_all_defs (def, opcode, op, stmts_to_fix);</span>
<span class="lineNum">    1382 </span><span class="lineCov">        432 : }</span>
<span class="lineNum">    1383 </span>            : 
<span class="lineNum">    1384 </span>            : /* Returns true if statement S1 dominates statement S2.  Like
<span class="lineNum">    1385 </span>            :    stmt_dominates_stmt_p, but uses stmt UIDs to optimize.  */
<a name="1386"><span class="lineNum">    1386 </span>            : </a>
<span class="lineNum">    1387 </span>            : static bool
<span class="lineNum">    1388 </span><span class="lineCov">    3891689 : reassoc_stmt_dominates_stmt_p (gimple *s1, gimple *s2)</span>
<span class="lineNum">    1389 </span>            : {
<span class="lineNum">    1390 </span><span class="lineCov">    7783378 :   basic_block bb1 = gimple_bb (s1), bb2 = gimple_bb (s2);</span>
<span class="lineNum">    1391 </span>            : 
<span class="lineNum">    1392 </span>            :   /* If bb1 is NULL, it should be a GIMPLE_NOP def stmt of an (D)
<span class="lineNum">    1393 </span>            :      SSA_NAME.  Assume it lives at the beginning of function and
<span class="lineNum">    1394 </span>            :      thus dominates everything.  */
<span class="lineNum">    1395 </span><span class="lineCov">    3891689 :   if (!bb1 || s1 == s2)</span>
<span class="lineNum">    1396 </span>            :     return true;
<span class="lineNum">    1397 </span>            : 
<span class="lineNum">    1398 </span>            :   /* If bb2 is NULL, it doesn't dominate any stmt with a bb.  */
<span class="lineNum">    1399 </span><span class="lineCov">    3888901 :   if (!bb2)</span>
<span class="lineNum">    1400 </span>            :     return false;
<span class="lineNum">    1401 </span>            : 
<span class="lineNum">    1402 </span><span class="lineCov">    3876168 :   if (bb1 == bb2)</span>
<span class="lineNum">    1403 </span>            :     {
<span class="lineNum">    1404 </span>            :       /* PHIs in the same basic block are assumed to be
<span class="lineNum">    1405 </span>            :          executed all in parallel, if only one stmt is a PHI,
<span class="lineNum">    1406 </span>            :          it dominates the other stmt in the same basic block.  */
<span class="lineNum">    1407 </span><span class="lineCov">    7489994 :       if (gimple_code (s1) == GIMPLE_PHI)</span>
<span class="lineNum">    1408 </span>            :         return true;
<span class="lineNum">    1409 </span>            : 
<span class="lineNum">    1410 </span><span class="lineCov">    7395410 :       if (gimple_code (s2) == GIMPLE_PHI)</span>
<span class="lineNum">    1411 </span>            :         return false;
<span class="lineNum">    1412 </span>            : 
<span class="lineNum">    1413 </span><span class="lineCov">    7311848 :       gcc_assert (gimple_uid (s1) &amp;&amp; gimple_uid (s2));</span>
<span class="lineNum">    1414 </span>            : 
<span class="lineNum">    1415 </span><span class="lineCov">   10967772 :       if (gimple_uid (s1) &lt; gimple_uid (s2))</span>
<span class="lineNum">    1416 </span>            :         return true;
<span class="lineNum">    1417 </span>            : 
<span class="lineNum">    1418 </span><span class="lineCov">    6667032 :       if (gimple_uid (s1) &gt; gimple_uid (s2))</span>
<span class="lineNum">    1419 </span>            :         return false;
<span class="lineNum">    1420 </span>            : 
<span class="lineNum">    1421 </span><span class="lineCov">      25452 :       gimple_stmt_iterator gsi = gsi_for_stmt (s1);</span>
<span class="lineNum">    1422 </span><span class="lineCov">      25452 :       unsigned int uid = gimple_uid (s1);</span>
<span class="lineNum">    1423 </span><span class="lineCov">      45457 :       for (gsi_next (&amp;gsi); !gsi_end_p (gsi); gsi_next (&amp;gsi))</span>
<span class="lineNum">    1424 </span>            :         {
<span class="lineNum">    1425 </span><span class="lineCov">      43677 :           gimple *s = gsi_stmt (gsi);</span>
<span class="lineNum">    1426 </span><span class="lineCov">      87354 :           if (gimple_uid (s) != uid)</span>
<span class="lineNum">    1427 </span>            :             break;
<span class="lineNum">    1428 </span><span class="lineCov">      20469 :           if (s == s2)</span>
<span class="lineNum">    1429 </span>            :             return true;
<span class="lineNum">    1430 </span>            :         }
<span class="lineNum">    1431 </span>            : 
<span class="lineNum">    1432 </span>            :       return false;
<span class="lineNum">    1433 </span>            :     }
<span class="lineNum">    1434 </span>            : 
<span class="lineNum">    1435 </span><span class="lineCov">     131171 :   return dominated_by_p (CDI_DOMINATORS, bb2, bb1);</span>
<span class="lineNum">    1436 </span>            : }
<span class="lineNum">    1437 </span>            : 
<span class="lineNum">    1438 </span>            : /* Insert STMT after INSERT_POINT.  */
<a name="1439"><span class="lineNum">    1439 </span>            : </a>
<span class="lineNum">    1440 </span>            : static void
<span class="lineNum">    1441 </span><span class="lineCov">      24231 : insert_stmt_after (gimple *stmt, gimple *insert_point)</span>
<span class="lineNum">    1442 </span>            : {
<span class="lineNum">    1443 </span><span class="lineCov">      24231 :   gimple_stmt_iterator gsi;</span>
<span class="lineNum">    1444 </span><span class="lineCov">      24231 :   basic_block bb;</span>
<span class="lineNum">    1445 </span>            : 
<span class="lineNum">    1446 </span><span class="lineCov">      48462 :   if (gimple_code (insert_point) == GIMPLE_PHI)</span>
<span class="lineNum">    1447 </span><span class="lineCov">        104 :     bb = gimple_bb (insert_point);</span>
<span class="lineNum">    1448 </span><span class="lineCov">      24179 :   else if (!stmt_ends_bb_p (insert_point))</span>
<span class="lineNum">    1449 </span>            :     {
<span class="lineNum">    1450 </span><span class="lineCov">      24160 :       gsi = gsi_for_stmt (insert_point);</span>
<span class="lineNum">    1451 </span><span class="lineCov">      48320 :       gimple_set_uid (stmt, gimple_uid (insert_point));</span>
<span class="lineNum">    1452 </span><span class="lineCov">      24160 :       gsi_insert_after (&amp;gsi, stmt, GSI_NEW_STMT);</span>
<span class="lineNum">    1453 </span><span class="lineCov">      24160 :       return;</span>
<span class="lineNum">    1454 </span>            :     }
<span class="lineNum">    1455 </span>            :   else
<span class="lineNum">    1456 </span>            :     /* We assume INSERT_POINT is a SSA_NAME_DEF_STMT of some SSA_NAME,
<span class="lineNum">    1457 </span>            :        thus if it must end a basic block, it should be a call that can
<span class="lineNum">    1458 </span>            :        throw, or some assignment that can throw.  If it throws, the LHS
<span class="lineNum">    1459 </span>            :        of it will not be initialized though, so only valid places using
<span class="lineNum">    1460 </span>            :        the SSA_NAME should be dominated by the fallthru edge.  */
<span class="lineNum">    1461 </span><span class="lineCov">         38 :     bb = find_fallthru_edge (gimple_bb (insert_point)-&gt;succs)-&gt;dest;</span>
<span class="lineNum">    1462 </span><span class="lineCov">         71 :   gsi = gsi_after_labels (bb);</span>
<span class="lineNum">    1463 </span><span class="lineCov">        142 :   if (gsi_end_p (gsi))</span>
<span class="lineNum">    1464 </span>            :     {
<span class="lineNum">    1465 </span><span class="lineNoCov">          0 :       gimple_stmt_iterator gsi2 = gsi_last_bb (bb);</span>
<span class="lineNum">    1466 </span><span class="lineNoCov">          0 :       gimple_set_uid (stmt,</span>
<span class="lineNum">    1467 </span><span class="lineNoCov">          0 :                       gsi_end_p (gsi2) ? 1 : gimple_uid (gsi_stmt (gsi2)));</span>
<span class="lineNum">    1468 </span>            :     }
<span class="lineNum">    1469 </span>            :   else
<span class="lineNum">    1470 </span><span class="lineCov">        213 :     gimple_set_uid (stmt, gimple_uid (gsi_stmt (gsi)));</span>
<span class="lineNum">    1471 </span><span class="lineCov">         71 :   gsi_insert_before (&amp;gsi, stmt, GSI_SAME_STMT);</span>
<span class="lineNum">    1472 </span>            : }
<span class="lineNum">    1473 </span>            : 
<span class="lineNum">    1474 </span>            : /* Builds one statement performing OP1 OPCODE OP2 using TMPVAR for
<span class="lineNum">    1475 </span>            :    the result.  Places the statement after the definition of either
<span class="lineNum">    1476 </span>            :    OP1 or OP2.  Returns the new statement.  */
<a name="1477"><span class="lineNum">    1477 </span>            : </a>
<span class="lineNum">    1478 </span>            : static gimple *
<span class="lineNum">    1479 </span><span class="lineCov">       8249 : build_and_add_sum (tree type, tree op1, tree op2, enum tree_code opcode)</span>
<span class="lineNum">    1480 </span>            : {
<span class="lineNum">    1481 </span><span class="lineCov">       8249 :   gimple *op1def = NULL, *op2def = NULL;</span>
<span class="lineNum">    1482 </span><span class="lineCov">       8249 :   gimple_stmt_iterator gsi;</span>
<span class="lineNum">    1483 </span><span class="lineCov">       8249 :   tree op;</span>
<span class="lineNum">    1484 </span><span class="lineCov">       8249 :   gassign *sum;</span>
<span class="lineNum">    1485 </span>            : 
<span class="lineNum">    1486 </span>            :   /* Create the addition statement.  */
<span class="lineNum">    1487 </span><span class="lineCov">       8249 :   op = make_ssa_name (type);</span>
<span class="lineNum">    1488 </span><span class="lineCov">       8249 :   sum = gimple_build_assign (op, opcode, op1, op2);</span>
<span class="lineNum">    1489 </span>            : 
<span class="lineNum">    1490 </span>            :   /* Find an insertion place and insert.  */
<span class="lineNum">    1491 </span><span class="lineCov">       8249 :   if (TREE_CODE (op1) == SSA_NAME)</span>
<span class="lineNum">    1492 </span><span class="lineCov">      16496 :     op1def = SSA_NAME_DEF_STMT (op1);</span>
<span class="lineNum">    1493 </span><span class="lineCov">       8249 :   if (TREE_CODE (op2) == SSA_NAME)</span>
<span class="lineNum">    1494 </span><span class="lineCov">      13240 :     op2def = SSA_NAME_DEF_STMT (op2);</span>
<span class="lineNum">    1495 </span><span class="lineCov">      16496 :   if ((!op1def || gimple_nop_p (op1def))</span>
<span class="lineNum">    1496 </span><span class="lineCov">       8436 :       &amp;&amp; (!op2def || gimple_nop_p (op2def)))</span>
<span class="lineNum">    1497 </span>            :     {
<span class="lineNum">    1498 </span><span class="lineCov">        149 :       gsi = gsi_after_labels (single_succ (ENTRY_BLOCK_PTR_FOR_FN (cfun)));</span>
<span class="lineNum">    1499 </span><span class="lineCov">        298 :       if (gsi_end_p (gsi))</span>
<span class="lineNum">    1500 </span>            :         {
<span class="lineNum">    1501 </span><span class="lineNoCov">          0 :           gimple_stmt_iterator gsi2</span>
<span class="lineNum">    1502 </span><span class="lineNoCov">          0 :             = gsi_last_bb (single_succ (ENTRY_BLOCK_PTR_FOR_FN (cfun)));</span>
<span class="lineNum">    1503 </span><span class="lineNoCov">          0 :           gimple_set_uid (sum,</span>
<span class="lineNum">    1504 </span><span class="lineNoCov">          0 :                           gsi_end_p (gsi2) ? 1 : gimple_uid (gsi_stmt (gsi2)));</span>
<span class="lineNum">    1505 </span>            :         }
<span class="lineNum">    1506 </span>            :       else
<span class="lineNum">    1507 </span><span class="lineCov">        447 :         gimple_set_uid (sum, gimple_uid (gsi_stmt (gsi)));</span>
<span class="lineNum">    1508 </span><span class="lineCov">        149 :       gsi_insert_before (&amp;gsi, sum, GSI_NEW_STMT);</span>
<span class="lineNum">    1509 </span>            :     }
<span class="lineNum">    1510 </span>            :   else
<span class="lineNum">    1511 </span>            :     {
<span class="lineNum">    1512 </span><span class="lineCov">       8100 :       gimple *insert_point;</span>
<span class="lineNum">    1513 </span><span class="lineCov">      16198 :       if ((!op1def || gimple_nop_p (op1def))</span>
<span class="lineNum">    1514 </span><span class="lineCov">      16161 :            || (op2def &amp;&amp; !gimple_nop_p (op2def)</span>
<span class="lineNum">    1515 </span><span class="lineCov">       6350 :                &amp;&amp; reassoc_stmt_dominates_stmt_p (op1def, op2def)))</span>
<span class="lineNum">    1516 </span>            :         insert_point = op2def;
<span class="lineNum">    1517 </span>            :       else
<span class="lineNum">    1518 </span>            :         insert_point = op1def;
<span class="lineNum">    1519 </span><span class="lineCov">       8100 :       insert_stmt_after (sum, insert_point);</span>
<span class="lineNum">    1520 </span>            :     }
<span class="lineNum">    1521 </span><span class="lineCov">       8249 :   update_stmt (sum);</span>
<span class="lineNum">    1522 </span>            : 
<span class="lineNum">    1523 </span><span class="lineCov">       8249 :   return sum;</span>
<span class="lineNum">    1524 </span>            : }
<span class="lineNum">    1525 </span>            : 
<span class="lineNum">    1526 </span>            : /* Perform un-distribution of divisions and multiplications.
<span class="lineNum">    1527 </span>            :    A * X + B * X is transformed into (A + B) * X and A / X + B / X
<span class="lineNum">    1528 </span>            :    to (A + B) / X for real X.
<span class="lineNum">    1529 </span>            : 
<span class="lineNum">    1530 </span>            :    The algorithm is organized as follows.
<span class="lineNum">    1531 </span>            : 
<span class="lineNum">    1532 </span>            :     - First we walk the addition chain *OPS looking for summands that
<span class="lineNum">    1533 </span>            :       are defined by a multiplication or a real division.  This results
<span class="lineNum">    1534 </span>            :       in the candidates bitmap with relevant indices into *OPS.
<span class="lineNum">    1535 </span>            : 
<span class="lineNum">    1536 </span>            :     - Second we build the chains of multiplications or divisions for
<span class="lineNum">    1537 </span>            :       these candidates, counting the number of occurrences of (operand, code)
<span class="lineNum">    1538 </span>            :       pairs in all of the candidates chains.
<span class="lineNum">    1539 </span>            : 
<span class="lineNum">    1540 </span>            :     - Third we sort the (operand, code) pairs by number of occurrence and
<span class="lineNum">    1541 </span>            :       process them starting with the pair with the most uses.
<span class="lineNum">    1542 </span>            : 
<span class="lineNum">    1543 </span>            :       * For each such pair we walk the candidates again to build a
<span class="lineNum">    1544 </span>            :         second candidate bitmap noting all multiplication/division chains
<span class="lineNum">    1545 </span>            :         that have at least one occurrence of (operand, code).
<span class="lineNum">    1546 </span>            : 
<span class="lineNum">    1547 </span>            :       * We build an alternate addition chain only covering these
<span class="lineNum">    1548 </span>            :         candidates with one (operand, code) operation removed from their
<span class="lineNum">    1549 </span>            :         multiplication/division chain.
<span class="lineNum">    1550 </span>            : 
<span class="lineNum">    1551 </span>            :       * The first candidate gets replaced by the alternate addition chain
<span class="lineNum">    1552 </span>            :         multiplied/divided by the operand.
<span class="lineNum">    1553 </span>            : 
<span class="lineNum">    1554 </span>            :       * All candidate chains get disabled for further processing and
<span class="lineNum">    1555 </span>            :         processing of (operand, code) pairs continues.
<span class="lineNum">    1556 </span>            : 
<span class="lineNum">    1557 </span>            :   The alternate addition chains built are re-processed by the main
<span class="lineNum">    1558 </span>            :   reassociation algorithm which allows optimizing a * x * y + b * y * x
<span class="lineNum">    1559 </span>            :   to (a + b ) * x * y in one invocation of the reassociation pass.  */
<span class="lineNum">    1560 </span>            : 
<span class="lineNum">    1561 </span>            : static bool
<span class="lineNum">    1562 </span><span class="lineCov">    2389141 : undistribute_ops_list (enum tree_code opcode,</span>
<span class="lineNum">    1563 </span>            :                        vec&lt;operand_entry *&gt; *ops, struct loop *loop)
<span class="lineNum">    1564 </span>            : {
<span class="lineNum">    1565 </span><span class="lineCov">    2389141 :   unsigned int length = ops-&gt;length ();</span>
<span class="lineNum">    1566 </span><span class="lineCov">    2389141 :   operand_entry *oe1;</span>
<span class="lineNum">    1567 </span><span class="lineCov">    2389141 :   unsigned i, j;</span>
<span class="lineNum">    1568 </span><span class="lineCov">    2389141 :   unsigned nr_candidates, nr_candidates2;</span>
<span class="lineNum">    1569 </span><span class="lineCov">    2389141 :   sbitmap_iterator sbi0;</span>
<span class="lineNum">    1570 </span><span class="lineCov">    2389141 :   vec&lt;operand_entry *&gt; *subops;</span>
<span class="lineNum">    1571 </span><span class="lineCov">    2389141 :   bool changed = false;</span>
<span class="lineNum">    1572 </span><span class="lineCov">    2389141 :   unsigned int next_oecount_id = 0;</span>
<span class="lineNum">    1573 </span>            : 
<span class="lineNum">    1574 </span><span class="lineCov">    4778282 :   if (length &lt;= 1</span>
<span class="lineNum">    1575 </span><span class="lineCov">    2389141 :       || opcode != PLUS_EXPR)</span>
<span class="lineNum">    1576 </span>            :     return false;
<span class="lineNum">    1577 </span>            : 
<span class="lineNum">    1578 </span>            :   /* Build a list of candidates to process.  */
<span class="lineNum">    1579 </span><span class="lineCov">    2152148 :   auto_sbitmap candidates (length);</span>
<span class="lineNum">    1580 </span><span class="lineCov">    2152148 :   bitmap_clear (candidates);</span>
<span class="lineNum">    1581 </span><span class="lineCov">    1076074 :   nr_candidates = 0;</span>
<span class="lineNum">    1582 </span><span class="lineCov">    3317021 :   FOR_EACH_VEC_ELT (*ops, i, oe1)</span>
<span class="lineNum">    1583 </span>            :     {
<span class="lineNum">    1584 </span><span class="lineCov">    2240947 :       enum tree_code dcode;</span>
<span class="lineNum">    1585 </span><span class="lineCov">    2240947 :       gimple *oe1def;</span>
<span class="lineNum">    1586 </span>            : 
<span class="lineNum">    1587 </span><span class="lineCov">    2240947 :       if (TREE_CODE (oe1-&gt;op) != SSA_NAME)</span>
<span class="lineNum">    1588 </span>            :         continue;
<span class="lineNum">    1589 </span><span class="lineCov">    1441880 :       oe1def = SSA_NAME_DEF_STMT (oe1-&gt;op);</span>
<span class="lineNum">    1590 </span><span class="lineCov">    2883760 :       if (!is_gimple_assign (oe1def))</span>
<span class="lineNum">    1591 </span>            :         continue;
<span class="lineNum">    1592 </span><span class="lineCov">     920788 :       dcode = gimple_assign_rhs_code (oe1def);</span>
<span class="lineNum">    1593 </span><span class="lineCov">     920788 :       if ((dcode != MULT_EXPR</span>
<span class="lineNum">    1594 </span><span class="lineCov">     920788 :            &amp;&amp; dcode != RDIV_EXPR)</span>
<span class="lineNum">    1595 </span><span class="lineCov">     920788 :           || !is_reassociable_op (oe1def, dcode, loop))</span>
<span class="lineNum">    1596 </span><span class="lineCov">     802635 :         continue;</span>
<span class="lineNum">    1597 </span>            : 
<span class="lineNum">    1598 </span><span class="lineCov">     236306 :       bitmap_set_bit (candidates, i);</span>
<span class="lineNum">    1599 </span><span class="lineCov">     118153 :       nr_candidates++;</span>
<span class="lineNum">    1600 </span>            :     }
<span class="lineNum">    1601 </span>            : 
<span class="lineNum">    1602 </span><span class="lineCov">    1076074 :   if (nr_candidates &lt; 2)</span>
<span class="lineNum">    1603 </span>            :     return false;
<span class="lineNum">    1604 </span>            : 
<span class="lineNum">    1605 </span><span class="lineCov">      11640 :   if (dump_file &amp;&amp; (dump_flags &amp; TDF_DETAILS))</span>
<span class="lineNum">    1606 </span>            :     {
<span class="lineNum">    1607 </span><span class="lineNoCov">          0 :       fprintf (dump_file, &quot;searching for un-distribute opportunities &quot;);</span>
<span class="lineNum">    1608 </span><span class="lineNoCov">          0 :       print_generic_expr (dump_file,</span>
<span class="lineNum">    1609 </span><span class="lineNoCov">          0 :         (*ops)[bitmap_first_set_bit (candidates)]-&gt;op, TDF_NONE);</span>
<span class="lineNum">    1610 </span><span class="lineNoCov">          0 :       fprintf (dump_file, &quot; %d\n&quot;, nr_candidates);</span>
<span class="lineNum">    1611 </span>            :     }
<span class="lineNum">    1612 </span>            : 
<span class="lineNum">    1613 </span>            :   /* Build linearized sub-operand lists and the counting table.  */
<span class="lineNum">    1614 </span><span class="lineCov">      11640 :   cvec.create (0);</span>
<span class="lineNum">    1615 </span>            : 
<span class="lineNum">    1616 </span><span class="lineCov">      11640 :   hash_table&lt;oecount_hasher&gt; ctable (15);</span>
<span class="lineNum">    1617 </span>            : 
<span class="lineNum">    1618 </span>            :   /* ??? Macro arguments cannot have multi-argument template types in
<span class="lineNum">    1619 </span>            :      them.  This typedef is needed to workaround that limitation.  */
<span class="lineNum">    1620 </span><span class="lineCov">      11640 :   typedef vec&lt;operand_entry *&gt; vec_operand_entry_t_heap;</span>
<span class="lineNum">    1621 </span><span class="lineCov">      23280 :   subops = XCNEWVEC (vec_operand_entry_t_heap, ops-&gt;length ());</span>
<span class="lineNum">    1622 </span><span class="lineCov">      62626 :   EXECUTE_IF_SET_IN_BITMAP (candidates, 0, i, sbi0)</span>
<span class="lineNum">    1623 </span>            :     {
<span class="lineNum">    1624 </span><span class="lineCov">      27706 :       gimple *oedef;</span>
<span class="lineNum">    1625 </span><span class="lineCov">      27706 :       enum tree_code oecode;</span>
<span class="lineNum">    1626 </span><span class="lineCov">      27706 :       unsigned j;</span>
<span class="lineNum">    1627 </span>            : 
<span class="lineNum">    1628 </span><span class="lineCov">      27706 :       oedef = SSA_NAME_DEF_STMT ((*ops)[i]-&gt;op);</span>
<span class="lineNum">    1629 </span><span class="lineCov">      27706 :       oecode = gimple_assign_rhs_code (oedef);</span>
<span class="lineNum">    1630 </span><span class="lineCov">      55412 :       linearize_expr_tree (&amp;subops[i], oedef,</span>
<span class="lineNum">    1631 </span><span class="lineCov">      27706 :                            associative_tree_code (oecode), false);</span>
<span class="lineNum">    1632 </span>            : 
<span class="lineNum">    1633 </span><span class="lineCov">      83908 :       FOR_EACH_VEC_ELT (subops[i], j, oe1)</span>
<span class="lineNum">    1634 </span>            :         {
<span class="lineNum">    1635 </span><span class="lineCov">      56202 :           oecount c;</span>
<span class="lineNum">    1636 </span><span class="lineCov">      56202 :           int *slot;</span>
<span class="lineNum">    1637 </span><span class="lineCov">      56202 :           int idx;</span>
<span class="lineNum">    1638 </span><span class="lineCov">      56202 :           c.oecode = oecode;</span>
<span class="lineNum">    1639 </span><span class="lineCov">      56202 :           c.cnt = 1;</span>
<span class="lineNum">    1640 </span><span class="lineCov">      56202 :           c.id = next_oecount_id++;</span>
<span class="lineNum">    1641 </span><span class="lineCov">      56202 :           c.op = oe1-&gt;op;</span>
<span class="lineNum">    1642 </span><span class="lineCov">      56202 :           cvec.safe_push (c);</span>
<span class="lineNum">    1643 </span><span class="lineCov">      56202 :           idx = cvec.length () + 41;</span>
<span class="lineNum">    1644 </span><span class="lineCov">      56202 :           slot = ctable.find_slot (idx, INSERT);</span>
<span class="lineNum">    1645 </span><span class="lineCov">      56202 :           if (!*slot)</span>
<span class="lineNum">    1646 </span>            :             {
<span class="lineNum">    1647 </span><span class="lineCov">      55507 :               *slot = idx;</span>
<span class="lineNum">    1648 </span>            :             }
<span class="lineNum">    1649 </span>            :           else
<span class="lineNum">    1650 </span>            :             {
<span class="lineNum">    1651 </span><span class="lineCov">        695 :               cvec.pop ();</span>
<span class="lineNum">    1652 </span><span class="lineCov">        695 :               cvec[*slot - 42].cnt++;</span>
<span class="lineNum">    1653 </span>            :             }
<span class="lineNum">    1654 </span>            :         }
<span class="lineNum">    1655 </span>            :     }
<span class="lineNum">    1656 </span>            : 
<span class="lineNum">    1657 </span>            :   /* Sort the counting table.  */
<span class="lineNum">    1658 </span><span class="lineCov">      11640 :   cvec.qsort (oecount_cmp);</span>
<span class="lineNum">    1659 </span>            : 
<span class="lineNum">    1660 </span><span class="lineCov">      11640 :   if (dump_file &amp;&amp; (dump_flags &amp; TDF_DETAILS))</span>
<span class="lineNum">    1661 </span>            :     {
<span class="lineNum">    1662 </span><span class="lineNoCov">          0 :       oecount *c;</span>
<span class="lineNum">    1663 </span><span class="lineNoCov">          0 :       fprintf (dump_file, &quot;Candidates:\n&quot;);</span>
<span class="lineNum">    1664 </span><span class="lineNoCov">          0 :       FOR_EACH_VEC_ELT (cvec, j, c)</span>
<span class="lineNum">    1665 </span>            :         {
<span class="lineNum">    1666 </span><span class="lineNoCov">          0 :           fprintf (dump_file, &quot;  %u %s: &quot;, c-&gt;cnt,</span>
<span class="lineNum">    1667 </span><span class="lineNoCov">          0 :                    c-&gt;oecode == MULT_EXPR</span>
<span class="lineNum">    1668 </span>            :                    ? &quot;*&quot; : c-&gt;oecode == RDIV_EXPR ? &quot;/&quot; : &quot;?&quot;);
<span class="lineNum">    1669 </span><span class="lineNoCov">          0 :           print_generic_expr (dump_file, c-&gt;op);</span>
<span class="lineNum">    1670 </span><span class="lineNoCov">          0 :           fprintf (dump_file, &quot;\n&quot;);</span>
<span class="lineNum">    1671 </span>            :         }
<span class="lineNum">    1672 </span>            :     }
<span class="lineNum">    1673 </span>            : 
<span class="lineNum">    1674 </span>            :   /* Process the (operand, code) pairs in order of most occurrence.  */
<span class="lineNum">    1675 </span><span class="lineCov">      23280 :   auto_sbitmap candidates2 (length);</span>
<span class="lineNum">    1676 </span><span class="lineCov">      12061 :   while (!cvec.is_empty ())</span>
<span class="lineNum">    1677 </span>            :     {
<span class="lineNum">    1678 </span><span class="lineCov">      12028 :       oecount *c = &amp;cvec.last ();</span>
<span class="lineNum">    1679 </span><span class="lineCov">      12028 :       if (c-&gt;cnt &lt; 2)</span>
<span class="lineNum">    1680 </span>            :         break;
<span class="lineNum">    1681 </span>            : 
<span class="lineNum">    1682 </span>            :       /* Now collect the operands in the outer chain that contain
<span class="lineNum">    1683 </span>            :          the common operand in their inner chain.  */
<span class="lineNum">    1684 </span><span class="lineCov">        842 :       bitmap_clear (candidates2);</span>
<span class="lineNum">    1685 </span><span class="lineCov">        421 :       nr_candidates2 = 0;</span>
<span class="lineNum">    1686 </span><span class="lineCov">       4009 :       EXECUTE_IF_SET_IN_BITMAP (candidates, 0, i, sbi0)</span>
<span class="lineNum">    1687 </span>            :         {
<span class="lineNum">    1688 </span><span class="lineCov">       2746 :           gimple *oedef;</span>
<span class="lineNum">    1689 </span><span class="lineCov">       2746 :           enum tree_code oecode;</span>
<span class="lineNum">    1690 </span><span class="lineCov">       2746 :           unsigned j;</span>
<span class="lineNum">    1691 </span><span class="lineCov">       2746 :           tree op = (*ops)[i]-&gt;op;</span>
<span class="lineNum">    1692 </span>            : 
<span class="lineNum">    1693 </span>            :           /* If we undistributed in this chain already this may be
<span class="lineNum">    1694 </span>            :              a constant.  */
<span class="lineNum">    1695 </span><span class="lineCov">       2746 :           if (TREE_CODE (op) != SSA_NAME)</span>
<span class="lineNum">    1696 </span>            :             continue;
<span class="lineNum">    1697 </span>            : 
<span class="lineNum">    1698 </span><span class="lineCov">       1946 :           oedef = SSA_NAME_DEF_STMT (op);</span>
<span class="lineNum">    1699 </span><span class="lineCov">       1946 :           oecode = gimple_assign_rhs_code (oedef);</span>
<span class="lineNum">    1700 </span><span class="lineCov">       1946 :           if (oecode != c-&gt;oecode)</span>
<span class="lineNum">    1701 </span>            :             continue;
<span class="lineNum">    1702 </span>            : 
<span class="lineNum">    1703 </span><span class="lineCov">       5213 :           FOR_EACH_VEC_ELT (subops[i], j, oe1)</span>
<span class="lineNum">    1704 </span>            :             {
<span class="lineNum">    1705 </span><span class="lineCov">       3950 :               if (oe1-&gt;op == c-&gt;op)</span>
<span class="lineNum">    1706 </span>            :                 {
<span class="lineNum">    1707 </span><span class="lineCov">       1366 :                   bitmap_set_bit (candidates2, i);</span>
<span class="lineNum">    1708 </span><span class="lineCov">        683 :                   ++nr_candidates2;</span>
<span class="lineNum">    1709 </span><span class="lineCov">        683 :                   break;</span>
<span class="lineNum">    1710 </span>            :                 }
<span class="lineNum">    1711 </span>            :             }
<span class="lineNum">    1712 </span>            :         }
<span class="lineNum">    1713 </span>            : 
<span class="lineNum">    1714 </span><span class="lineCov">        421 :       if (nr_candidates2 &gt;= 2)</span>
<span class="lineNum">    1715 </span>            :         {
<span class="lineNum">    1716 </span><span class="lineCov">        121 :           operand_entry *oe1, *oe2;</span>
<span class="lineNum">    1717 </span><span class="lineCov">        121 :           gimple *prod;</span>
<span class="lineNum">    1718 </span><span class="lineCov">        242 :           int first = bitmap_first_set_bit (candidates2);</span>
<span class="lineNum">    1719 </span>            : 
<span class="lineNum">    1720 </span>            :           /* Build the new addition chain.  */
<span class="lineNum">    1721 </span><span class="lineCov">        121 :           oe1 = (*ops)[first];</span>
<span class="lineNum">    1722 </span><span class="lineCov">        121 :           if (dump_file &amp;&amp; (dump_flags &amp; TDF_DETAILS))</span>
<span class="lineNum">    1723 </span>            :             {
<span class="lineNum">    1724 </span><span class="lineNoCov">          0 :               fprintf (dump_file, &quot;Building (&quot;);</span>
<span class="lineNum">    1725 </span><span class="lineNoCov">          0 :               print_generic_expr (dump_file, oe1-&gt;op);</span>
<span class="lineNum">    1726 </span>            :             }
<span class="lineNum">    1727 </span><span class="lineCov">        121 :           zero_one_operation (&amp;oe1-&gt;op, c-&gt;oecode, c-&gt;op);</span>
<span class="lineNum">    1728 </span><span class="lineCov">        674 :           EXECUTE_IF_SET_IN_BITMAP (candidates2, first+1, i, sbi0)</span>
<span class="lineNum">    1729 </span>            :             {
<span class="lineNum">    1730 </span><span class="lineCov">        311 :               gimple *sum;</span>
<span class="lineNum">    1731 </span><span class="lineCov">        311 :               oe2 = (*ops)[i];</span>
<span class="lineNum">    1732 </span><span class="lineCov">        311 :               if (dump_file &amp;&amp; (dump_flags &amp; TDF_DETAILS))</span>
<span class="lineNum">    1733 </span>            :                 {
<span class="lineNum">    1734 </span><span class="lineNoCov">          0 :                   fprintf (dump_file, &quot; + &quot;);</span>
<span class="lineNum">    1735 </span><span class="lineNoCov">          0 :                   print_generic_expr (dump_file, oe2-&gt;op);</span>
<span class="lineNum">    1736 </span>            :                 }
<span class="lineNum">    1737 </span><span class="lineCov">        311 :               zero_one_operation (&amp;oe2-&gt;op, c-&gt;oecode, c-&gt;op);</span>
<span class="lineNum">    1738 </span><span class="lineCov">        311 :               sum = build_and_add_sum (TREE_TYPE (oe1-&gt;op),</span>
<span class="lineNum">    1739 </span>            :                                        oe1-&gt;op, oe2-&gt;op, opcode);
<span class="lineNum">    1740 </span><span class="lineCov">        311 :               oe2-&gt;op = build_zero_cst (TREE_TYPE (oe2-&gt;op));</span>
<span class="lineNum">    1741 </span><span class="lineCov">        311 :               oe2-&gt;rank = 0;</span>
<span class="lineNum">    1742 </span><span class="lineCov">        311 :               oe1-&gt;op = gimple_get_lhs (sum);</span>
<span class="lineNum">    1743 </span>            :             }
<span class="lineNum">    1744 </span>            : 
<span class="lineNum">    1745 </span>            :           /* Apply the multiplication/division.  */
<span class="lineNum">    1746 </span><span class="lineCov">        121 :           prod = build_and_add_sum (TREE_TYPE (oe1-&gt;op),</span>
<span class="lineNum">    1747 </span>            :                                     oe1-&gt;op, c-&gt;op, c-&gt;oecode);
<span class="lineNum">    1748 </span><span class="lineCov">        121 :           if (dump_file &amp;&amp; (dump_flags &amp; TDF_DETAILS))</span>
<span class="lineNum">    1749 </span>            :             {
<span class="lineNum">    1750 </span><span class="lineNoCov">          0 :               fprintf (dump_file, &quot;) %s &quot;, c-&gt;oecode == MULT_EXPR ? &quot;*&quot; : &quot;/&quot;);</span>
<span class="lineNum">    1751 </span><span class="lineNoCov">          0 :               print_generic_expr (dump_file, c-&gt;op);</span>
<span class="lineNum">    1752 </span><span class="lineNoCov">          0 :               fprintf (dump_file, &quot;\n&quot;);</span>
<span class="lineNum">    1753 </span>            :             }
<span class="lineNum">    1754 </span>            : 
<span class="lineNum">    1755 </span>            :           /* Record it in the addition chain and disable further
<span class="lineNum">    1756 </span>            :              undistribution with this op.  */
<span class="lineNum">    1757 </span><span class="lineCov">        121 :           oe1-&gt;op = gimple_assign_lhs (prod);</span>
<span class="lineNum">    1758 </span><span class="lineCov">        121 :           oe1-&gt;rank = get_rank (oe1-&gt;op);</span>
<span class="lineNum">    1759 </span><span class="lineCov">        121 :           subops[first].release ();</span>
<span class="lineNum">    1760 </span>            : 
<span class="lineNum">    1761 </span>            :           changed = true;
<span class="lineNum">    1762 </span>            :         }
<span class="lineNum">    1763 </span>            : 
<span class="lineNum">    1764 </span><span class="lineCov">        421 :       cvec.pop ();</span>
<span class="lineNum">    1765 </span>            :     }
<span class="lineNum">    1766 </span>            : 
<span class="lineNum">    1767 </span><span class="lineCov">      94420 :   for (i = 0; i &lt; ops-&gt;length (); ++i)</span>
<span class="lineNum">    1768 </span><span class="lineCov">      63155 :     subops[i].release ();</span>
<span class="lineNum">    1769 </span><span class="lineCov">      11640 :   free (subops);</span>
<span class="lineNum">    1770 </span><span class="lineCov">      11640 :   cvec.release ();</span>
<span class="lineNum">    1771 </span>            : 
<span class="lineNum">    1772 </span><span class="lineCov">      11640 :   return changed;</span>
<span class="lineNum">    1773 </span>            : }
<span class="lineNum">    1774 </span>            : 
<span class="lineNum">    1775 </span>            : /* If OPCODE is BIT_IOR_EXPR or BIT_AND_EXPR and CURR is a comparison
<span class="lineNum">    1776 </span>            :    expression, examine the other OPS to see if any of them are comparisons
<span class="lineNum">    1777 </span>            :    of the same values, which we may be able to combine or eliminate.
<span class="lineNum">    1778 </span>            :    For example, we can rewrite (a &lt; b) | (a == b) as (a &lt;= b).  */
<span class="lineNum">    1779 </span>            : 
<span class="lineNum">    1780 </span>            : static bool
<span class="lineNum">    1781 </span><span class="lineCov">    4911533 : eliminate_redundant_comparison (enum tree_code opcode,</span>
<span class="lineNum">    1782 </span>            :                                 vec&lt;operand_entry *&gt; *ops,
<span class="lineNum">    1783 </span>            :                                 unsigned int currindex,
<span class="lineNum">    1784 </span>            :                                 operand_entry *curr)
<span class="lineNum">    1785 </span>            : {
<span class="lineNum">    1786 </span><span class="lineCov">    4911533 :   tree op1, op2;</span>
<span class="lineNum">    1787 </span><span class="lineCov">    4911533 :   enum tree_code lcode, rcode;</span>
<span class="lineNum">    1788 </span><span class="lineCov">    4911533 :   gimple *def1, *def2;</span>
<span class="lineNum">    1789 </span><span class="lineCov">    4911533 :   int i;</span>
<span class="lineNum">    1790 </span><span class="lineCov">    4911533 :   operand_entry *oe;</span>
<span class="lineNum">    1791 </span>            : 
<span class="lineNum">    1792 </span><span class="lineCov">    4911533 :   if (opcode != BIT_IOR_EXPR &amp;&amp; opcode != BIT_AND_EXPR)</span>
<span class="lineNum">    1793 </span>            :     return false;
<span class="lineNum">    1794 </span>            : 
<span class="lineNum">    1795 </span>            :   /* Check that CURR is a comparison.  */
<span class="lineNum">    1796 </span><span class="lineCov">    1226463 :   if (TREE_CODE (curr-&gt;op) != SSA_NAME)</span>
<span class="lineNum">    1797 </span>            :     return false;
<span class="lineNum">    1798 </span><span class="lineCov">     932177 :   def1 = SSA_NAME_DEF_STMT (curr-&gt;op);</span>
<span class="lineNum">    1799 </span><span class="lineCov">    1864354 :   if (!is_gimple_assign (def1))</span>
<span class="lineNum">    1800 </span>            :     return false;
<span class="lineNum">    1801 </span><span class="lineCov">     829666 :   lcode = gimple_assign_rhs_code (def1);</span>
<span class="lineNum">    1802 </span><span class="lineCov">     829666 :   if (TREE_CODE_CLASS (lcode) != tcc_comparison)</span>
<span class="lineNum">    1803 </span>            :     return false;
<span class="lineNum">    1804 </span><span class="lineCov">     438547 :   op1 = gimple_assign_rhs1 (def1);</span>
<span class="lineNum">    1805 </span><span class="lineCov">     438547 :   op2 = gimple_assign_rhs2 (def1);</span>
<span class="lineNum">    1806 </span>            : 
<span class="lineNum">    1807 </span>            :   /* Now look for a similar comparison in the remaining OPS.  */
<span class="lineNum">    1808 </span><span class="lineCov">     686652 :   for (i = currindex + 1; ops-&gt;iterate (i, &amp;oe); i++)</span>
<span class="lineNum">    1809 </span>            :     {
<span class="lineNum">    1810 </span><span class="lineCov">     249587 :       tree t;</span>
<span class="lineNum">    1811 </span>            : 
<span class="lineNum">    1812 </span><span class="lineCov">     249587 :       if (TREE_CODE (oe-&gt;op) != SSA_NAME)</span>
<span class="lineNum">    1813 </span><span class="lineCov">     248105 :         continue;</span>
<span class="lineNum">    1814 </span><span class="lineCov">     249582 :       def2 = SSA_NAME_DEF_STMT (oe-&gt;op);</span>
<span class="lineNum">    1815 </span><span class="lineCov">     499164 :       if (!is_gimple_assign (def2))</span>
<span class="lineNum">    1816 </span>            :         continue;
<span class="lineNum">    1817 </span><span class="lineCov">     247143 :       rcode = gimple_assign_rhs_code (def2);</span>
<span class="lineNum">    1818 </span><span class="lineCov">     247143 :       if (TREE_CODE_CLASS (rcode) != tcc_comparison)</span>
<span class="lineNum">    1819 </span>            :         continue;
<span class="lineNum">    1820 </span>            : 
<span class="lineNum">    1821 </span>            :       /* If we got here, we have a match.  See if we can combine the
<span class="lineNum">    1822 </span>            :          two comparisons.  */
<span class="lineNum">    1823 </span><span class="lineCov">     243655 :       if (opcode == BIT_IOR_EXPR)</span>
<span class="lineNum">    1824 </span><span class="lineCov">     195513 :         t = maybe_fold_or_comparisons (lcode, op1, op2,</span>
<span class="lineNum">    1825 </span>            :                                        rcode, gimple_assign_rhs1 (def2),
<span class="lineNum">    1826 </span>            :                                        gimple_assign_rhs2 (def2));
<span class="lineNum">    1827 </span>            :       else
<span class="lineNum">    1828 </span><span class="lineCov">      48142 :         t = maybe_fold_and_comparisons (lcode, op1, op2,</span>
<span class="lineNum">    1829 </span>            :                                         rcode, gimple_assign_rhs1 (def2),
<span class="lineNum">    1830 </span>            :                                         gimple_assign_rhs2 (def2));
<span class="lineNum">    1831 </span><span class="lineCov">     243655 :       if (!t)</span>
<span class="lineNum">    1832 </span>            :         continue;
<span class="lineNum">    1833 </span>            : 
<span class="lineNum">    1834 </span>            :       /* maybe_fold_and_comparisons and maybe_fold_or_comparisons
<span class="lineNum">    1835 </span>            :          always give us a boolean_type_node value back.  If the original
<span class="lineNum">    1836 </span>            :          BIT_AND_EXPR or BIT_IOR_EXPR was of a wider integer type,
<span class="lineNum">    1837 </span>            :          we need to convert.  */
<span class="lineNum">    1838 </span><span class="lineCov">       1482 :       if (!useless_type_conversion_p (TREE_TYPE (curr-&gt;op), TREE_TYPE (t)))</span>
<span class="lineNum">    1839 </span><span class="lineCov">          1 :         t = fold_convert (TREE_TYPE (curr-&gt;op), t);</span>
<span class="lineNum">    1840 </span>            : 
<span class="lineNum">    1841 </span><span class="lineCov">       1482 :       if (TREE_CODE (t) != INTEGER_CST</span>
<span class="lineNum">    1842 </span><span class="lineCov">       1482 :           &amp;&amp; !operand_equal_p (t, curr-&gt;op, 0))</span>
<span class="lineNum">    1843 </span>            :         {
<span class="lineNum">    1844 </span><span class="lineCov">       1477 :           enum tree_code subcode;</span>
<span class="lineNum">    1845 </span><span class="lineCov">       1477 :           tree newop1, newop2;</span>
<span class="lineNum">    1846 </span><span class="lineCov">       1477 :           if (!COMPARISON_CLASS_P (t))</span>
<span class="lineNum">    1847 </span><span class="lineNoCov">          0 :             continue;</span>
<span class="lineNum">    1848 </span><span class="lineCov">       1477 :           extract_ops_from_tree (t, &amp;subcode, &amp;newop1, &amp;newop2);</span>
<span class="lineNum">    1849 </span><span class="lineCov">       1477 :           STRIP_USELESS_TYPE_CONVERSION (newop1);</span>
<span class="lineNum">    1850 </span><span class="lineCov">       1477 :           STRIP_USELESS_TYPE_CONVERSION (newop2);</span>
<span class="lineNum">    1851 </span><span class="lineCov">       1477 :           if (!is_gimple_val (newop1) || !is_gimple_val (newop2))</span>
<span class="lineNum">    1852 </span><span class="lineNoCov">          0 :             continue;</span>
<span class="lineNum">    1853 </span>            :         }
<span class="lineNum">    1854 </span>            : 
<span class="lineNum">    1855 </span><span class="lineCov">       1482 :       if (dump_file &amp;&amp; (dump_flags &amp; TDF_DETAILS))</span>
<span class="lineNum">    1856 </span>            :         {
<span class="lineNum">    1857 </span><span class="lineNoCov">          0 :           fprintf (dump_file, &quot;Equivalence: &quot;);</span>
<span class="lineNum">    1858 </span><span class="lineNoCov">          0 :           print_generic_expr (dump_file, curr-&gt;op);</span>
<span class="lineNum">    1859 </span><span class="lineNoCov">          0 :           fprintf (dump_file, &quot; %s &quot;, op_symbol_code (opcode));</span>
<span class="lineNum">    1860 </span><span class="lineNoCov">          0 :           print_generic_expr (dump_file, oe-&gt;op);</span>
<span class="lineNum">    1861 </span><span class="lineNoCov">          0 :           fprintf (dump_file, &quot; -&gt; &quot;);</span>
<span class="lineNum">    1862 </span><span class="lineNoCov">          0 :           print_generic_expr (dump_file, t);</span>
<span class="lineNum">    1863 </span><span class="lineNoCov">          0 :           fprintf (dump_file, &quot;\n&quot;);</span>
<span class="lineNum">    1864 </span>            :         }
<span class="lineNum">    1865 </span>            : 
<span class="lineNum">    1866 </span>            :       /* Now we can delete oe, as it has been subsumed by the new combined
<span class="lineNum">    1867 </span>            :          expression t.  */
<span class="lineNum">    1868 </span><span class="lineCov">       1482 :       ops-&gt;ordered_remove (i);</span>
<span class="lineNum">    1869 </span><span class="lineCov">       1482 :       reassociate_stats.ops_eliminated ++;</span>
<span class="lineNum">    1870 </span>            : 
<span class="lineNum">    1871 </span>            :       /* If t is the same as curr-&gt;op, we're done.  Otherwise we must
<span class="lineNum">    1872 </span>            :          replace curr-&gt;op with t.  Special case is if we got a constant
<span class="lineNum">    1873 </span>            :          back, in which case we add it to the end instead of in place of
<span class="lineNum">    1874 </span>            :          the current entry.  */
<span class="lineNum">    1875 </span><span class="lineCov">       1482 :       if (TREE_CODE (t) == INTEGER_CST)</span>
<span class="lineNum">    1876 </span>            :         {
<span class="lineNum">    1877 </span><span class="lineCov">          5 :           ops-&gt;ordered_remove (currindex);</span>
<span class="lineNum">    1878 </span><span class="lineCov">          5 :           add_to_ops_vec (ops, t);</span>
<span class="lineNum">    1879 </span>            :         }
<span class="lineNum">    1880 </span><span class="lineCov">       1477 :       else if (!operand_equal_p (t, curr-&gt;op, 0))</span>
<span class="lineNum">    1881 </span>            :         {
<span class="lineNum">    1882 </span><span class="lineCov">       1477 :           gimple *sum;</span>
<span class="lineNum">    1883 </span><span class="lineCov">       1477 :           enum tree_code subcode;</span>
<span class="lineNum">    1884 </span><span class="lineCov">       1477 :           tree newop1;</span>
<span class="lineNum">    1885 </span><span class="lineCov">       1477 :           tree newop2;</span>
<span class="lineNum">    1886 </span><span class="lineCov">       1477 :           gcc_assert (COMPARISON_CLASS_P (t));</span>
<span class="lineNum">    1887 </span><span class="lineCov">       1477 :           extract_ops_from_tree (t, &amp;subcode, &amp;newop1, &amp;newop2);</span>
<span class="lineNum">    1888 </span><span class="lineCov">       1477 :           STRIP_USELESS_TYPE_CONVERSION (newop1);</span>
<span class="lineNum">    1889 </span><span class="lineCov">       1477 :           STRIP_USELESS_TYPE_CONVERSION (newop2);</span>
<span class="lineNum">    1890 </span><span class="lineCov">       1477 :           gcc_checking_assert (is_gimple_val (newop1)</span>
<span class="lineNum">    1891 </span>            :                                &amp;&amp; is_gimple_val (newop2));
<span class="lineNum">    1892 </span><span class="lineCov">       1477 :           sum = build_and_add_sum (TREE_TYPE (t), newop1, newop2, subcode);</span>
<span class="lineNum">    1893 </span><span class="lineCov">       1477 :           curr-&gt;op = gimple_get_lhs (sum);</span>
<span class="lineNum">    1894 </span>            :         }
<span class="lineNum">    1895 </span>            :       return true;
<span class="lineNum">    1896 </span>            :     }
<span class="lineNum">    1897 </span>            : 
<span class="lineNum">    1898 </span>            :   return false;
<span class="lineNum">    1899 </span>            : }
<span class="lineNum">    1900 </span>            : 
<span class="lineNum">    1901 </span>            : 
<span class="lineNum">    1902 </span>            : /* Transform repeated addition of same values into multiply with
<span class="lineNum">    1903 </span>            :    constant.  */
<span class="lineNum">    1904 </span>            : static bool
<span class="lineNum">    1905 </span><span class="lineCov">    1077623 : transform_add_to_multiply (vec&lt;operand_entry *&gt; *ops)</span>
<span class="lineNum">    1906 </span>            : {
<span class="lineNum">    1907 </span><span class="lineCov">    1077623 :   operand_entry *oe;</span>
<span class="lineNum">    1908 </span><span class="lineCov">    1077623 :   tree op = NULL_TREE;</span>
<span class="lineNum">    1909 </span><span class="lineCov">    1077623 :   int j;</span>
<span class="lineNum">    1910 </span><span class="lineCov">    1077623 :   int i, start = -1, end = 0, count = 0;</span>
<span class="lineNum">    1911 </span><span class="lineCov">    2155246 :   auto_vec&lt;std::pair &lt;int, int&gt; &gt; indxs;</span>
<span class="lineNum">    1912 </span><span class="lineCov">    1077623 :   bool changed = false;</span>
<span class="lineNum">    1913 </span>            : 
<span class="lineNum">    1914 </span><span class="lineCov">    4306724 :   if (!INTEGRAL_TYPE_P (TREE_TYPE ((*ops)[0]-&gt;op))</span>
<span class="lineNum">    1915 </span><span class="lineCov">    1198952 :       &amp;&amp; (!SCALAR_FLOAT_TYPE_P (TREE_TYPE ((*ops)[0]-&gt;op))</span>
<span class="lineNum">    1916 </span><span class="lineCov">      31533 :           || !flag_unsafe_math_optimizations))</span>
<span class="lineNum">    1917 </span>            :     return false;
<span class="lineNum">    1918 </span>            : 
<span class="lineNum">    1919 </span>            :   /* Look for repeated operands.  */
<span class="lineNum">    1920 </span><span class="lineCov">    3288836 :   FOR_EACH_VEC_ELT (*ops, i, oe)</span>
<span class="lineNum">    1921 </span>            :     {
<span class="lineNum">    1922 </span><span class="lineCov">    2220137 :       if (start == -1)</span>
<span class="lineNum">    1923 </span>            :         {
<span class="lineNum">    1924 </span><span class="lineCov">    1068699 :           count = 1;</span>
<span class="lineNum">    1925 </span><span class="lineCov">    1068699 :           op = oe-&gt;op;</span>
<span class="lineNum">    1926 </span><span class="lineCov">    1068699 :           start = i;</span>
<span class="lineNum">    1927 </span>            :         }
<span class="lineNum">    1928 </span><span class="lineCov">    1151438 :       else if (operand_equal_p (oe-&gt;op, op, 0))</span>
<span class="lineNum">    1929 </span>            :         {
<span class="lineNum">    1930 </span><span class="lineCov">        134 :           count++;</span>
<span class="lineNum">    1931 </span><span class="lineCov">        134 :           end = i;</span>
<span class="lineNum">    1932 </span>            :         }
<span class="lineNum">    1933 </span>            :       else
<span class="lineNum">    1934 </span>            :         {
<span class="lineNum">    1935 </span><span class="lineCov">    1151304 :           if (count &gt; 1)</span>
<span class="lineNum">    1936 </span><span class="lineCov">         88 :             indxs.safe_push (std::make_pair (start, end));</span>
<span class="lineNum">    1937 </span><span class="lineCov">    1151304 :           count = 1;</span>
<span class="lineNum">    1938 </span><span class="lineCov">    1151304 :           op = oe-&gt;op;</span>
<span class="lineNum">    1939 </span><span class="lineCov">    1151304 :           start = i;</span>
<span class="lineNum">    1940 </span>            :         }
<span class="lineNum">    1941 </span>            :     }
<span class="lineNum">    1942 </span>            : 
<span class="lineNum">    1943 </span><span class="lineCov">    1068699 :   if (count &gt; 1)</span>
<span class="lineNum">    1944 </span><span class="lineCov">         58 :     indxs.safe_push (std::make_pair (start, end));</span>
<span class="lineNum">    1945 </span>            : 
<span class="lineNum">    1946 </span><span class="lineCov">    1068835 :   for (j = indxs.length () - 1; j &gt;= 0; --j)</span>
<span class="lineNum">    1947 </span>            :     {
<span class="lineNum">    1948 </span>            :       /* Convert repeated operand addition to multiplication.  */
<span class="lineNum">    1949 </span><span class="lineCov">         73 :       start = indxs[j].first;</span>
<span class="lineNum">    1950 </span><span class="lineCov">         73 :       end = indxs[j].second;</span>
<span class="lineNum">    1951 </span><span class="lineCov">         73 :       op = (*ops)[start]-&gt;op;</span>
<span class="lineNum">    1952 </span><span class="lineCov">         73 :       count = end - start + 1;</span>
<span class="lineNum">    1953 </span><span class="lineCov">        280 :       for (i = end; i &gt;= start; --i)</span>
<span class="lineNum">    1954 </span><span class="lineCov">        207 :         ops-&gt;unordered_remove (i);</span>
<span class="lineNum">    1955 </span><span class="lineCov">         73 :       tree tmp = make_ssa_name (TREE_TYPE (op));</span>
<span class="lineNum">    1956 </span><span class="lineCov">        146 :       tree cst = build_int_cst (integer_type_node, count);</span>
<span class="lineNum">    1957 </span><span class="lineCov">         73 :       gassign *mul_stmt</span>
<span class="lineNum">    1958 </span><span class="lineCov">         73 :         = gimple_build_assign (tmp, MULT_EXPR,</span>
<span class="lineNum">    1959 </span><span class="lineCov">         73 :                                op, fold_convert (TREE_TYPE (op), cst));</span>
<span class="lineNum">    1960 </span><span class="lineCov">         73 :       gimple_set_visited (mul_stmt, true);</span>
<span class="lineNum">    1961 </span><span class="lineCov">         73 :       add_to_ops_vec (ops, tmp, mul_stmt);</span>
<span class="lineNum">    1962 </span><span class="lineCov">         73 :       changed = true;</span>
<span class="lineNum">    1963 </span>            :     }
<span class="lineNum">    1964 </span>            : 
<span class="lineNum">    1965 </span>            :   return changed;
<span class="lineNum">    1966 </span>            : }
<span class="lineNum">    1967 </span>            : 
<span class="lineNum">    1968 </span>            : 
<span class="lineNum">    1969 </span>            : /* Perform various identities and other optimizations on the list of
<span class="lineNum">    1970 </span>            :    operand entries, stored in OPS.  The tree code for the binary
<span class="lineNum">    1971 </span>            :    operation between all the operands is OPCODE.  */
<span class="lineNum">    1972 </span>            : 
<span class="lineNum">    1973 </span>            : static void
<span class="lineNum">    1974 </span><span class="lineCov">    2424604 : optimize_ops_list (enum tree_code opcode,</span>
<span class="lineNum">    1975 </span>            :                    vec&lt;operand_entry *&gt; *ops)
<span class="lineNum">    1976 </span>            : {
<span class="lineNum">    1977 </span><span class="lineCov">    2424604 :   unsigned int length = ops-&gt;length ();</span>
<span class="lineNum">    1978 </span><span class="lineCov">    2424604 :   unsigned int i;</span>
<span class="lineNum">    1979 </span><span class="lineCov">    2424604 :   operand_entry *oe;</span>
<span class="lineNum">    1980 </span><span class="lineCov">    2424604 :   operand_entry *oelast = NULL;</span>
<span class="lineNum">    1981 </span><span class="lineCov">    2424604 :   bool iterate = false;</span>
<span class="lineNum">    1982 </span>            : 
<span class="lineNum">    1983 </span><span class="lineCov">    2424604 :   if (length == 1)</span>
<span class="lineNum">    1984 </span>            :     return;
<span class="lineNum">    1985 </span>            : 
<span class="lineNum">    1986 </span><span class="lineCov">    2422455 :   oelast = ops-&gt;last ();</span>
<span class="lineNum">    1987 </span>            : 
<span class="lineNum">    1988 </span>            :   /* If the last two are constants, pop the constants off, merge them
<span class="lineNum">    1989 </span>            :      and try the next two.  */
<span class="lineNum">    1990 </span><span class="lineCov">    2422455 :   if (oelast-&gt;rank == 0 &amp;&amp; is_gimple_min_invariant (oelast-&gt;op))</span>
<span class="lineNum">    1991 </span>            :     {
<span class="lineNum">    1992 </span><span class="lineCov">    1682293 :       operand_entry *oelm1 = (*ops)[length - 2];</span>
<span class="lineNum">    1993 </span>            : 
<span class="lineNum">    1994 </span><span class="lineCov">    1682293 :       if (oelm1-&gt;rank == 0</span>
<span class="lineNum">    1995 </span><span class="lineCov">      32306 :           &amp;&amp; is_gimple_min_invariant (oelm1-&gt;op)</span>
<span class="lineNum">    1996 </span><span class="lineCov">    1714599 :           &amp;&amp; useless_type_conversion_p (TREE_TYPE (oelm1-&gt;op),</span>
<span class="lineNum">    1997 </span><span class="lineCov">      32306 :                                        TREE_TYPE (oelast-&gt;op)))</span>
<span class="lineNum">    1998 </span>            :         {
<span class="lineNum">    1999 </span><span class="lineCov">      32306 :           tree folded = fold_binary (opcode, TREE_TYPE (oelm1-&gt;op),</span>
<span class="lineNum">    2000 </span>            :                                      oelm1-&gt;op, oelast-&gt;op);
<span class="lineNum">    2001 </span>            : 
<span class="lineNum">    2002 </span><span class="lineCov">      32306 :           if (folded &amp;&amp; is_gimple_min_invariant (folded))</span>
<span class="lineNum">    2003 </span>            :             {
<span class="lineNum">    2004 </span><span class="lineCov">      32292 :               if (dump_file &amp;&amp; (dump_flags &amp; TDF_DETAILS))</span>
<span class="lineNum">    2005 </span><span class="lineNoCov">          0 :                 fprintf (dump_file, &quot;Merging constants\n&quot;);</span>
<span class="lineNum">    2006 </span>            : 
<span class="lineNum">    2007 </span><span class="lineCov">      32292 :               ops-&gt;pop ();</span>
<span class="lineNum">    2008 </span><span class="lineCov">      32292 :               ops-&gt;pop ();</span>
<span class="lineNum">    2009 </span>            : 
<span class="lineNum">    2010 </span><span class="lineCov">      32292 :               add_to_ops_vec (ops, folded);</span>
<span class="lineNum">    2011 </span><span class="lineCov">      32292 :               reassociate_stats.constants_eliminated++;</span>
<span class="lineNum">    2012 </span>            : 
<span class="lineNum">    2013 </span><span class="lineCov">      32292 :               optimize_ops_list (opcode, ops);</span>
<span class="lineNum">    2014 </span><span class="lineCov">      32292 :               return;</span>
<span class="lineNum">    2015 </span>            :             }
<span class="lineNum">    2016 </span>            :         }
<span class="lineNum">    2017 </span>            :     }
<span class="lineNum">    2018 </span>            : 
<span class="lineNum">    2019 </span><span class="lineCov">    2390163 :   eliminate_using_constants (opcode, ops);</span>
<span class="lineNum">    2020 </span><span class="lineCov">    2390163 :   oelast = NULL;</span>
<span class="lineNum">    2021 </span>            : 
<span class="lineNum">    2022 </span><span class="lineCov">    7303333 :   for (i = 0; ops-&gt;iterate (i, &amp;oe);)</span>
<span class="lineNum">    2023 </span>            :     {
<span class="lineNum">    2024 </span><span class="lineCov">    4913172 :       bool done = false;</span>
<span class="lineNum">    2025 </span>            : 
<span class="lineNum">    2026 </span><span class="lineCov">    4913172 :       if (eliminate_not_pairs (opcode, ops, i, oe))</span>
<span class="lineNum">    2027 </span><span class="lineCov">          2 :         return;</span>
<span class="lineNum">    2028 </span><span class="lineCov">    4913171 :       if (eliminate_duplicate_pair (opcode, ops, &amp;done, i, oe, oelast)</span>
<span class="lineNum">    2029 </span><span class="lineCov">    4913107 :           || (!done &amp;&amp; eliminate_plus_minus_pair (opcode, ops, i, oe))</span>
<span class="lineNum">    2030 </span><span class="lineCov">    9824704 :           || (!done &amp;&amp; eliminate_redundant_comparison (opcode, ops, i, oe)))</span>
<span class="lineNum">    2031 </span>            :         {
<span class="lineNum">    2032 </span><span class="lineCov">       3120 :           if (done)</span>
<span class="lineNum">    2033 </span>            :             return;
<span class="lineNum">    2034 </span><span class="lineCov">       3119 :           iterate = true;</span>
<span class="lineNum">    2035 </span><span class="lineCov">       3119 :           oelast = NULL;</span>
<span class="lineNum">    2036 </span><span class="lineCov">       3119 :           continue;</span>
<span class="lineNum">    2037 </span>            :         }
<span class="lineNum">    2038 </span><span class="lineCov">    4910051 :       oelast = oe;</span>
<span class="lineNum">    2039 </span><span class="lineCov">    4910051 :       i++;</span>
<span class="lineNum">    2040 </span>            :     }
<span class="lineNum">    2041 </span>            : 
<span class="lineNum">    2042 </span><span class="lineCov">    2390161 :   length = ops-&gt;length ();</span>
<span class="lineNum">    2043 </span><span class="lineCov">    2390161 :   oelast = ops-&gt;last ();</span>
<span class="lineNum">    2044 </span>            : 
<span class="lineNum">    2045 </span><span class="lineCov">    2390161 :   if (iterate)</span>
<span class="lineNum">    2046 </span><span class="lineCov">       3073 :     optimize_ops_list (opcode, ops);</span>
<span class="lineNum">    2047 </span>            : }
<span class="lineNum">    2048 </span>            : 
<span class="lineNum">    2049 </span>            : /* The following functions are subroutines to optimize_range_tests and allow
<span class="lineNum">    2050 </span>            :    it to try to change a logical combination of comparisons into a range
<span class="lineNum">    2051 </span>            :    test.
<span class="lineNum">    2052 </span>            : 
<span class="lineNum">    2053 </span>            :    For example, both
<span class="lineNum">    2054 </span>            :         X == 2 || X == 5 || X == 3 || X == 4
<span class="lineNum">    2055 </span>            :    and
<span class="lineNum">    2056 </span>            :         X &gt;= 2 &amp;&amp; X &lt;= 5
<span class="lineNum">    2057 </span>            :    are converted to
<span class="lineNum">    2058 </span>            :         (unsigned) (X - 2) &lt;= 3
<span class="lineNum">    2059 </span>            : 
<span class="lineNum">    2060 </span>            :    For more information see comments above fold_test_range in fold-const.c,
<span class="lineNum">    2061 </span>            :    this implementation is for GIMPLE.  */
<span class="lineNum">    2062 </span>            : 
<span class="lineNum">    2063 </span>            : struct range_entry
<span class="lineNum">    2064 </span>            : {
<span class="lineNum">    2065 </span>            :   tree exp;
<span class="lineNum">    2066 </span>            :   tree low;
<span class="lineNum">    2067 </span>            :   tree high;
<span class="lineNum">    2068 </span>            :   bool in_p;
<span class="lineNum">    2069 </span>            :   bool strict_overflow_p;
<span class="lineNum">    2070 </span>            :   unsigned int idx, next;
<span class="lineNum">    2071 </span>            : };
<span class="lineNum">    2072 </span>            : 
<span class="lineNum">    2073 </span>            : /* This is similar to make_range in fold-const.c, but on top of
<span class="lineNum">    2074 </span>            :    GIMPLE instead of trees.  If EXP is non-NULL, it should be
<span class="lineNum">    2075 </span>            :    an SSA_NAME and STMT argument is ignored, otherwise STMT
<span class="lineNum">    2076 </span>            :    argument should be a GIMPLE_COND.  */
<a name="2077"><span class="lineNum">    2077 </span>            : </a>
<span class="lineNum">    2078 </span>            : static void
<span class="lineNum">    2079 </span><span class="lineCov">    1426812 : init_range_entry (struct range_entry *r, tree exp, gimple *stmt)</span>
<span class="lineNum">    2080 </span>            : {
<span class="lineNum">    2081 </span><span class="lineCov">    1426812 :   int in_p;</span>
<span class="lineNum">    2082 </span><span class="lineCov">    1426812 :   tree low, high;</span>
<span class="lineNum">    2083 </span><span class="lineCov">    1426812 :   bool is_bool, strict_overflow_p;</span>
<span class="lineNum">    2084 </span>            : 
<span class="lineNum">    2085 </span><span class="lineCov">    1426812 :   r-&gt;exp = NULL_TREE;</span>
<span class="lineNum">    2086 </span><span class="lineCov">    1426812 :   r-&gt;in_p = false;</span>
<span class="lineNum">    2087 </span><span class="lineCov">    1426812 :   r-&gt;strict_overflow_p = false;</span>
<span class="lineNum">    2088 </span><span class="lineCov">    1426812 :   r-&gt;low = NULL_TREE;</span>
<span class="lineNum">    2089 </span><span class="lineCov">    1426812 :   r-&gt;high = NULL_TREE;</span>
<span class="lineNum">    2090 </span><span class="lineCov">    1426812 :   if (exp != NULL_TREE</span>
<span class="lineNum">    2091 </span><span class="lineCov">    1426812 :       &amp;&amp; (TREE_CODE (exp) != SSA_NAME || !INTEGRAL_TYPE_P (TREE_TYPE (exp))))</span>
<span class="lineNum">    2092 </span><span class="lineCov">     433498 :     return;</span>
<span class="lineNum">    2093 </span>            : 
<span class="lineNum">    2094 </span>            :   /* Start with simply saying &quot;EXP != 0&quot; and then look at the code of EXP
<span class="lineNum">    2095 </span>            :      and see if we can refine the range.  Some of the cases below may not
<span class="lineNum">    2096 </span>            :      happen, but it doesn't seem worth worrying about this.  We &quot;continue&quot;
<span class="lineNum">    2097 </span>            :      the outer loop when we've changed something; otherwise we &quot;break&quot;
<span class="lineNum">    2098 </span>            :      the switch, which will &quot;break&quot; the while.  */
<span class="lineNum">    2099 </span><span class="lineCov">    1131745 :   low = exp ? build_int_cst (TREE_TYPE (exp), 0) : boolean_false_node;</span>
<span class="lineNum">    2100 </span><span class="lineCov">    1131745 :   high = low;</span>
<span class="lineNum">    2101 </span><span class="lineCov">    1131745 :   in_p = 0;</span>
<span class="lineNum">    2102 </span><span class="lineCov">    1131745 :   strict_overflow_p = false;</span>
<span class="lineNum">    2103 </span><span class="lineCov">    1131745 :   is_bool = false;</span>
<span class="lineNum">    2104 </span><span class="lineCov">    1131745 :   if (exp == NULL_TREE)</span>
<span class="lineNum">    2105 </span>            :     is_bool = true;
<span class="lineNum">    2106 </span><span class="lineCov">     945453 :   else if (TYPE_PRECISION (TREE_TYPE (exp)) == 1)</span>
<span class="lineNum">    2107 </span>            :     {
<span class="lineNum">    2108 </span><span class="lineCov">    1445124 :       if (TYPE_UNSIGNED (TREE_TYPE (exp)))</span>
<span class="lineNum">    2109 </span>            :         is_bool = true;
<span class="lineNum">    2110 </span>            :       else
<span class="lineNum">    2111 </span>            :         return;
<span class="lineNum">    2112 </span>            :     }
<span class="lineNum">    2113 </span><span class="lineCov">     927490 :   else if (TREE_CODE (TREE_TYPE (exp)) == BOOLEAN_TYPE)</span>
<span class="lineNum">    2114 </span><span class="lineNoCov">          0 :     is_bool = true;</span>
<span class="lineNum">    2115 </span>            : 
<span class="lineNum">    2116 </span><span class="lineCov">    1611041 :   while (1)</span>
<span class="lineNum">    2117 </span>            :     {
<span class="lineNum">    2118 </span><span class="lineCov">    1611041 :       enum tree_code code;</span>
<span class="lineNum">    2119 </span><span class="lineCov">    1611041 :       tree arg0, arg1, exp_type;</span>
<span class="lineNum">    2120 </span><span class="lineCov">    1611041 :       tree nexp;</span>
<span class="lineNum">    2121 </span><span class="lineCov">    1611041 :       location_t loc;</span>
<span class="lineNum">    2122 </span>            : 
<span class="lineNum">    2123 </span><span class="lineCov">    1611041 :       if (exp != NULL_TREE)</span>
<span class="lineNum">    2124 </span>            :         {
<span class="lineNum">    2125 </span><span class="lineCov">    1424749 :           if (TREE_CODE (exp) != SSA_NAME</span>
<span class="lineNum">    2126 </span><span class="lineCov">    1424749 :               || SSA_NAME_OCCURS_IN_ABNORMAL_PHI (exp))</span>
<span class="lineNum">    2127 </span>            :             break;
<span class="lineNum">    2128 </span>            : 
<span class="lineNum">    2129 </span><span class="lineCov">    1424673 :           stmt = SSA_NAME_DEF_STMT (exp);</span>
<span class="lineNum">    2130 </span><span class="lineCov">    2849346 :           if (!is_gimple_assign (stmt))</span>
<span class="lineNum">    2131 </span>            :             break;
<span class="lineNum">    2132 </span>            : 
<span class="lineNum">    2133 </span><span class="lineCov">    1193037 :           code = gimple_assign_rhs_code (stmt);</span>
<span class="lineNum">    2134 </span><span class="lineCov">    1193037 :           arg0 = gimple_assign_rhs1 (stmt);</span>
<span class="lineNum">    2135 </span><span class="lineCov">    1193037 :           arg1 = gimple_assign_rhs2 (stmt);</span>
<span class="lineNum">    2136 </span><span class="lineCov">    1193037 :           exp_type = TREE_TYPE (exp);</span>
<span class="lineNum">    2137 </span>            :         }
<span class="lineNum">    2138 </span>            :       else
<span class="lineNum">    2139 </span>            :         {
<span class="lineNum">    2140 </span><span class="lineCov">     186292 :           code = gimple_cond_code (stmt);</span>
<span class="lineNum">    2141 </span><span class="lineCov">     186292 :           arg0 = gimple_cond_lhs (stmt);</span>
<span class="lineNum">    2142 </span><span class="lineCov">     186292 :           arg1 = gimple_cond_rhs (stmt);</span>
<span class="lineNum">    2143 </span><span class="lineCov">     186292 :           exp_type = boolean_type_node;</span>
<span class="lineNum">    2144 </span>            :         }
<span class="lineNum">    2145 </span>            : 
<span class="lineNum">    2146 </span><span class="lineCov">    1379329 :       if (TREE_CODE (arg0) != SSA_NAME)</span>
<span class="lineNum">    2147 </span>            :         break;
<span class="lineNum">    2148 </span><span class="lineCov">    1072025 :       loc = gimple_location (stmt);</span>
<span class="lineNum">    2149 </span><span class="lineCov">    1072025 :       switch (code)</span>
<span class="lineNum">    2150 </span>            :         {
<span class="lineNum">    2151 </span><span class="lineCov">      10880 :         case BIT_NOT_EXPR:</span>
<span class="lineNum">    2152 </span><span class="lineCov">      10880 :           if (TREE_CODE (TREE_TYPE (exp)) == BOOLEAN_TYPE</span>
<span class="lineNum">    2153 </span>            :               /* Ensure the range is either +[-,0], +[0,0],
<span class="lineNum">    2154 </span>            :                  -[-,0], -[0,0] or +[1,-], +[1,1], -[1,-] or
<span class="lineNum">    2155 </span>            :                  -[1,1].  If it is e.g. +[-,-] or -[-,-]
<span class="lineNum">    2156 </span>            :                  or similar expression of unconditional true or
<span class="lineNum">    2157 </span>            :                  false, it should not be negated.  */
<span class="lineNum">    2158 </span><span class="lineCov">      10880 :               &amp;&amp; ((high &amp;&amp; integer_zerop (high))</span>
<span class="lineNum">    2159 </span><span class="lineNoCov">          0 :                   || (low &amp;&amp; integer_onep (low))))</span>
<span class="lineNum">    2160 </span>            :             {
<span class="lineNum">    2161 </span><span class="lineCov">       4345 :               in_p = !in_p;</span>
<span class="lineNum">    2162 </span><span class="lineCov">       4345 :               exp = arg0;</span>
<span class="lineNum">    2163 </span><span class="lineCov">       4345 :               continue;</span>
<span class="lineNum">    2164 </span>            :             }
<span class="lineNum">    2165 </span>            :           break;
<span class="lineNum">    2166 </span>            :         case SSA_NAME:
<span class="lineNum">    2167 </span>            :           exp = arg0;
<span class="lineNum">    2168 </span>            :           continue;
<span class="lineNum">    2169 </span><span class="lineCov">     146588 :         CASE_CONVERT:</span>
<span class="lineNum">    2170 </span><span class="lineCov">     146588 :           if (is_bool)</span>
<span class="lineNum">    2171 </span>            :             {
<span class="lineNum">    2172 </span><span class="lineCov">      52650 :               if ((TYPE_PRECISION (exp_type) == 1</span>
<span class="lineNum">    2173 </span><span class="lineCov">      49094 :                    || TREE_CODE (exp_type) == BOOLEAN_TYPE)</span>
<span class="lineNum">    2174 </span><span class="lineCov">      52650 :                   &amp;&amp; TYPE_PRECISION (TREE_TYPE (arg0)) &gt; 1)</span>
<span class="lineNum">    2175 </span>            :                 return;
<span class="lineNum">    2176 </span>            :             }
<span class="lineNum">    2177 </span><span class="lineCov">      93938 :           else if (TYPE_PRECISION (TREE_TYPE (arg0)) == 1)</span>
<span class="lineNum">    2178 </span>            :             {
<span class="lineNum">    2179 </span><span class="lineCov">       5076 :               if (TYPE_UNSIGNED (TREE_TYPE (arg0)))</span>
<span class="lineNum">    2180 </span>            :                 is_bool = true;
<span class="lineNum">    2181 </span>            :               else
<span class="lineNum">    2182 </span>            :                 return;
<span class="lineNum">    2183 </span>            :             }
<span class="lineNum">    2184 </span><span class="lineCov">     184492 :           else if (TREE_CODE (TREE_TYPE (arg0)) == BOOLEAN_TYPE)</span>
<span class="lineNum">    2185 </span><span class="lineNoCov">          0 :             is_bool = true;</span>
<span class="lineNum">    2186 </span><span class="lineCov">     145299 :           goto do_default;</span>
<span class="lineNum">    2187 </span>            :         case EQ_EXPR:
<span class="lineNum">    2188 </span>            :         case NE_EXPR:
<span class="lineNum">    2189 </span>            :         case LT_EXPR:
<span class="lineNum">    2190 </span>            :         case LE_EXPR:
<span class="lineNum">    2191 </span>            :         case GE_EXPR:
<span class="lineNum">    2192 </span>            :         case GT_EXPR:
<span class="lineNum">    2193 </span>            :           is_bool = true;
<span class="lineNum">    2194 </span>            :           /* FALLTHRU */
<span class="lineNum">    2195 </span><span class="lineCov">     305862 :         default:</span>
<span class="lineNum">    2196 </span><span class="lineCov">     305862 :           if (!is_bool)</span>
<span class="lineNum">    2197 </span>            :             return;
<span class="lineNum">    2198 </span><span class="lineCov">     168720 :         do_default:</span>
<span class="lineNum">    2199 </span><span class="lineCov">     921012 :           nexp = make_range_step (loc, code, arg0, arg1, exp_type,</span>
<span class="lineNum">    2200 </span>            :                                   &amp;low, &amp;high, &amp;in_p,
<span class="lineNum">    2201 </span>            :                                   &amp;strict_overflow_p);
<span class="lineNum">    2202 </span><span class="lineCov">     921012 :           if (nexp != NULL_TREE)</span>
<span class="lineNum">    2203 </span>            :             {
<span class="lineNum">    2204 </span><span class="lineCov">     473249 :               exp = nexp;</span>
<span class="lineNum">    2205 </span><span class="lineCov">     473249 :               gcc_assert (TREE_CODE (exp) == SSA_NAME);</span>
<span class="lineNum">    2206 </span>            :               continue;
<span class="lineNum">    2207 </span>            :             }
<span class="lineNum">    2208 </span>            :           break;
<span class="lineNum">    2209 </span>            :         }
<span class="lineNum">    2210 </span>            :       break;
<span class="lineNum">    2211 </span>            :     }
<span class="lineNum">    2212 </span><span class="lineCov">     993314 :   if (is_bool)</span>
<span class="lineNum">    2213 </span>            :     {
<span class="lineNum">    2214 </span><span class="lineCov">     668403 :       r-&gt;exp = exp;</span>
<span class="lineNum">    2215 </span><span class="lineCov">     668403 :       r-&gt;in_p = in_p;</span>
<span class="lineNum">    2216 </span><span class="lineCov">     668403 :       r-&gt;low = low;</span>
<span class="lineNum">    2217 </span><span class="lineCov">     668403 :       r-&gt;high = high;</span>
<span class="lineNum">    2218 </span><span class="lineCov">     668403 :       r-&gt;strict_overflow_p = strict_overflow_p;</span>
<span class="lineNum">    2219 </span>            :     }
<span class="lineNum">    2220 </span>            : }
<span class="lineNum">    2221 </span>            : 
<span class="lineNum">    2222 </span>            : /* Comparison function for qsort.  Sort entries
<span class="lineNum">    2223 </span>            :    without SSA_NAME exp first, then with SSA_NAMEs sorted
<span class="lineNum">    2224 </span>            :    by increasing SSA_NAME_VERSION, and for the same SSA_NAMEs
<span class="lineNum">    2225 </span>            :    by increasing -&gt;low and if -&gt;low is the same, by increasing
<span class="lineNum">    2226 </span>            :    -&gt;high.  -&gt;low == NULL_TREE means minimum, -&gt;high == NULL_TREE
<span class="lineNum">    2227 </span>            :    maximum.  */
<a name="2228"><span class="lineNum">    2228 </span>            : </a>
<span class="lineNum">    2229 </span>            : static int
<span class="lineNum">    2230 </span><span class="lineCov">    3545644 : range_entry_cmp (const void *a, const void *b)</span>
<span class="lineNum">    2231 </span>            : {
<span class="lineNum">    2232 </span><span class="lineCov">    3545644 :   const struct range_entry *p = (const struct range_entry *) a;</span>
<span class="lineNum">    2233 </span><span class="lineCov">    3545644 :   const struct range_entry *q = (const struct range_entry *) b;</span>
<span class="lineNum">    2234 </span>            : 
<span class="lineNum">    2235 </span><span class="lineCov">    3545644 :   if (p-&gt;exp != NULL_TREE &amp;&amp; TREE_CODE (p-&gt;exp) == SSA_NAME)</span>
<span class="lineNum">    2236 </span>            :     {
<span class="lineNum">    2237 </span><span class="lineCov">    1592523 :       if (q-&gt;exp != NULL_TREE &amp;&amp; TREE_CODE (q-&gt;exp) == SSA_NAME)</span>
<span class="lineNum">    2238 </span>            :         {
<span class="lineNum">    2239 </span>            :           /* Group range_entries for the same SSA_NAME together.  */
<span class="lineNum">    2240 </span><span class="lineCov">    4565448 :           if (SSA_NAME_VERSION (p-&gt;exp) &lt; SSA_NAME_VERSION (q-&gt;exp))</span>
<span class="lineNum">    2241 </span>            :             return -1;
<span class="lineNum">    2242 </span><span class="lineCov">    1886823 :           else if (SSA_NAME_VERSION (p-&gt;exp) &gt; SSA_NAME_VERSION (q-&gt;exp))</span>
<span class="lineNum">    2243 </span>            :             return 1;
<span class="lineNum">    2244 </span>            :           /* If -&gt;low is different, NULL low goes first, then by
<span class="lineNum">    2245 </span>            :              ascending low.  */
<span class="lineNum">    2246 </span><span class="lineCov">     153898 :           if (p-&gt;low != NULL_TREE)</span>
<span class="lineNum">    2247 </span>            :             {
<span class="lineNum">    2248 </span><span class="lineCov">     143005 :               if (q-&gt;low != NULL_TREE)</span>
<span class="lineNum">    2249 </span>            :                 {
<span class="lineNum">    2250 </span><span class="lineCov">     138549 :                   tree tem = fold_binary (LT_EXPR, boolean_type_node,</span>
<span class="lineNum">    2251 </span>            :                                           p-&gt;low, q-&gt;low);
<span class="lineNum">    2252 </span><span class="lineCov">     138549 :                   if (tem &amp;&amp; integer_onep (tem))</span>
<span class="lineNum">    2253 </span>            :                     return -1;
<span class="lineNum">    2254 </span><span class="lineCov">      61661 :                   tem = fold_binary (GT_EXPR, boolean_type_node,</span>
<span class="lineNum">    2255 </span>            :                                      p-&gt;low, q-&gt;low);
<span class="lineNum">    2256 </span><span class="lineCov">      61661 :                   if (tem &amp;&amp; integer_onep (tem))</span>
<span class="lineNum">    2257 </span>            :                     return 1;
<span class="lineNum">    2258 </span>            :                 }
<span class="lineNum">    2259 </span>            :               else
<span class="lineNum">    2260 </span>            :                 return 1;
<span class="lineNum">    2261 </span>            :             }
<span class="lineNum">    2262 </span><span class="lineCov">      10893 :           else if (q-&gt;low != NULL_TREE)</span>
<span class="lineNum">    2263 </span>            :             return -1;
<span class="lineNum">    2264 </span>            :           /* If -&gt;high is different, NULL high goes last, before that by
<span class="lineNum">    2265 </span>            :              ascending high.  */
<span class="lineNum">    2266 </span><span class="lineCov">      12161 :           if (p-&gt;high != NULL_TREE)</span>
<span class="lineNum">    2267 </span>            :             {
<span class="lineNum">    2268 </span><span class="lineCov">      12152 :               if (q-&gt;high != NULL_TREE)</span>
<span class="lineNum">    2269 </span>            :                 {
<span class="lineNum">    2270 </span><span class="lineCov">      12133 :                   tree tem = fold_binary (LT_EXPR, boolean_type_node,</span>
<span class="lineNum">    2271 </span>            :                                           p-&gt;high, q-&gt;high);
<span class="lineNum">    2272 </span><span class="lineCov">      12133 :                   if (tem &amp;&amp; integer_onep (tem))</span>
<span class="lineNum">    2273 </span>            :                     return -1;
<span class="lineNum">    2274 </span><span class="lineCov">       3302 :                   tem = fold_binary (GT_EXPR, boolean_type_node,</span>
<span class="lineNum">    2275 </span>            :                                      p-&gt;high, q-&gt;high);
<span class="lineNum">    2276 </span><span class="lineCov">       3302 :                   if (tem &amp;&amp; integer_onep (tem))</span>
<span class="lineNum">    2277 </span>            :                     return 1;
<span class="lineNum">    2278 </span>            :                 }
<span class="lineNum">    2279 </span>            :               else
<span class="lineNum">    2280 </span>            :                 return -1;
<span class="lineNum">    2281 </span>            :             }
<span class="lineNum">    2282 </span><span class="lineCov">          9 :           else if (q-&gt;high != NULL_TREE)</span>
<span class="lineNum">    2283 </span>            :             return 1;
<span class="lineNum">    2284 </span>            :           /* If both ranges are the same, sort below by ascending idx.  */
<span class="lineNum">    2285 </span>            :         }
<span class="lineNum">    2286 </span>            :       else
<span class="lineNum">    2287 </span>            :         return 1;
<span class="lineNum">    2288 </span>            :     }
<span class="lineNum">    2289 </span><span class="lineCov">    1953121 :   else if (q-&gt;exp != NULL_TREE &amp;&amp; TREE_CODE (q-&gt;exp) == SSA_NAME)</span>
<span class="lineNum">    2290 </span>            :     return -1;
<span class="lineNum">    2291 </span>            : 
<span class="lineNum">    2292 </span><span class="lineCov">    1866076 :   if (p-&gt;idx &lt; q-&gt;idx)</span>
<span class="lineNum">    2293 </span>            :     return -1;
<span class="lineNum">    2294 </span>            :   else
<span class="lineNum">    2295 </span>            :     {
<span class="lineNum">    2296 </span><span class="lineCov">     940662 :       gcc_checking_assert (p-&gt;idx &gt; q-&gt;idx);</span>
<span class="lineNum">    2297 </span>            :       return 1;
<span class="lineNum">    2298 </span>            :     }
<span class="lineNum">    2299 </span>            : }
<span class="lineNum">    2300 </span>            : 
<span class="lineNum">    2301 </span>            : /* Helper function for update_range_test.  Force EXPR into an SSA_NAME,
<span class="lineNum">    2302 </span>            :    insert needed statements BEFORE or after GSI.  */
<a name="2303"><span class="lineNum">    2303 </span>            : </a>
<span class="lineNum">    2304 </span>            : static tree
<span class="lineNum">    2305 </span><span class="lineCov">      13574 : force_into_ssa_name (gimple_stmt_iterator *gsi, tree expr, bool before)</span>
<span class="lineNum">    2306 </span>            : {
<span class="lineNum">    2307 </span><span class="lineCov">      13574 :   enum gsi_iterator_update m = before ? GSI_SAME_STMT : GSI_CONTINUE_LINKING;</span>
<span class="lineNum">    2308 </span><span class="lineCov">      13574 :   tree ret = force_gimple_operand_gsi (gsi, expr, true, NULL_TREE, before, m);</span>
<span class="lineNum">    2309 </span><span class="lineCov">      13574 :   if (TREE_CODE (ret) != SSA_NAME)</span>
<span class="lineNum">    2310 </span>            :     {
<span class="lineNum">    2311 </span><span class="lineCov">         50 :       gimple *g = gimple_build_assign (make_ssa_name (TREE_TYPE (ret)), ret);</span>
<span class="lineNum">    2312 </span><span class="lineCov">         50 :       if (before)</span>
<span class="lineNum">    2313 </span><span class="lineCov">         50 :         gsi_insert_before (gsi, g, GSI_SAME_STMT);</span>
<span class="lineNum">    2314 </span>            :       else
<span class="lineNum">    2315 </span><span class="lineNoCov">          0 :         gsi_insert_after (gsi, g, GSI_CONTINUE_LINKING);</span>
<span class="lineNum">    2316 </span><span class="lineCov">         50 :       ret = gimple_assign_lhs (g);</span>
<span class="lineNum">    2317 </span>            :     }
<span class="lineNum">    2318 </span><span class="lineCov">      13574 :   return ret;</span>
<span class="lineNum">    2319 </span>            : }
<span class="lineNum">    2320 </span>            : 
<span class="lineNum">    2321 </span>            : /* Helper routine of optimize_range_test.
<span class="lineNum">    2322 </span>            :    [EXP, IN_P, LOW, HIGH, STRICT_OVERFLOW_P] is a merged range for
<span class="lineNum">    2323 </span>            :    RANGE and OTHERRANGE through OTHERRANGE + COUNT - 1 ranges,
<span class="lineNum">    2324 </span>            :    OPCODE and OPS are arguments of optimize_range_tests.  If OTHERRANGE
<span class="lineNum">    2325 </span>            :    is NULL, OTHERRANGEP should not be and then OTHERRANGEP points to
<span class="lineNum">    2326 </span>            :    an array of COUNT pointers to other ranges.  Return
<span class="lineNum">    2327 </span>            :    true if the range merge has been successful.
<span class="lineNum">    2328 </span>            :    If OPCODE is ERROR_MARK, this is called from within
<span class="lineNum">    2329 </span>            :    maybe_optimize_range_tests and is performing inter-bb range optimization.
<span class="lineNum">    2330 </span>            :    In that case, whether an op is BIT_AND_EXPR or BIT_IOR_EXPR is found in
<span class="lineNum">    2331 </span>            :    oe-&gt;rank.  */
<span class="lineNum">    2332 </span>            : 
<span class="lineNum">    2333 </span>            : static bool
<span class="lineNum">    2334 </span><span class="lineCov">      13574 : update_range_test (struct range_entry *range, struct range_entry *otherrange,</span>
<span class="lineNum">    2335 </span>            :                    struct range_entry **otherrangep,
<span class="lineNum">    2336 </span>            :                    unsigned int count, enum tree_code opcode,
<span class="lineNum">    2337 </span>            :                    vec&lt;operand_entry *&gt; *ops, tree exp, gimple_seq seq,
<span class="lineNum">    2338 </span>            :                    bool in_p, tree low, tree high, bool strict_overflow_p)
<span class="lineNum">    2339 </span>            : {
<span class="lineNum">    2340 </span><span class="lineCov">      13574 :   operand_entry *oe = (*ops)[range-&gt;idx];</span>
<span class="lineNum">    2341 </span><span class="lineCov">      13574 :   tree op = oe-&gt;op;</span>
<span class="lineNum">    2342 </span><span class="lineCov">      13574 :   gimple *stmt = op ? SSA_NAME_DEF_STMT (op)</span>
<span class="lineNum">    2343 </span><span class="lineCov">       5777 :                     : last_stmt (BASIC_BLOCK_FOR_FN (cfun, oe-&gt;id));</span>
<span class="lineNum">    2344 </span><span class="lineCov">      13574 :   location_t loc = gimple_location (stmt);</span>
<span class="lineNum">    2345 </span><span class="lineCov">      13574 :   tree optype = op ? TREE_TYPE (op) : boolean_type_node;</span>
<span class="lineNum">    2346 </span><span class="lineCov">      13574 :   tree tem = build_range_check (loc, optype, unshare_expr (exp),</span>
<span class="lineNum">    2347 </span><span class="lineCov">      13574 :                                 in_p, low, high);</span>
<span class="lineNum">    2348 </span><span class="lineCov">      13574 :   enum warn_strict_overflow_code wc = WARN_STRICT_OVERFLOW_COMPARISON;</span>
<span class="lineNum">    2349 </span><span class="lineCov">      13574 :   gimple_stmt_iterator gsi;</span>
<span class="lineNum">    2350 </span><span class="lineCov">      13574 :   unsigned int i, uid;</span>
<span class="lineNum">    2351 </span>            : 
<span class="lineNum">    2352 </span><span class="lineCov">      13574 :   if (tem == NULL_TREE)</span>
<span class="lineNum">    2353 </span>            :     return false;
<span class="lineNum">    2354 </span>            : 
<span class="lineNum">    2355 </span>            :   /* If op is default def SSA_NAME, there is no place to insert the
<span class="lineNum">    2356 </span>            :      new comparison.  Give up, unless we can use OP itself as the
<span class="lineNum">    2357 </span>            :      range test.  */
<span class="lineNum">    2358 </span><span class="lineCov">      13574 :   if (op &amp;&amp; SSA_NAME_IS_DEFAULT_DEF (op))</span>
<span class="lineNum">    2359 </span>            :     {
<span class="lineNum">    2360 </span><span class="lineNoCov">          0 :       if (op == range-&gt;exp</span>
<span class="lineNum">    2361 </span><span class="lineNoCov">          0 :           &amp;&amp; ((TYPE_PRECISION (optype) == 1 &amp;&amp; TYPE_UNSIGNED (optype))</span>
<span class="lineNum">    2362 </span><span class="lineNoCov">          0 :               || TREE_CODE (optype) == BOOLEAN_TYPE)</span>
<span class="lineNum">    2363 </span><span class="lineNoCov">          0 :           &amp;&amp; (op == tem</span>
<span class="lineNum">    2364 </span><span class="lineNoCov">          0 :               || (TREE_CODE (tem) == EQ_EXPR</span>
<span class="lineNum">    2365 </span><span class="lineNoCov">          0 :                   &amp;&amp; TREE_OPERAND (tem, 0) == op</span>
<span class="lineNum">    2366 </span><span class="lineNoCov">          0 :                   &amp;&amp; integer_onep (TREE_OPERAND (tem, 1))))</span>
<span class="lineNum">    2367 </span><span class="lineNoCov">          0 :           &amp;&amp; opcode != BIT_IOR_EXPR</span>
<span class="lineNum">    2368 </span><span class="lineNoCov">          0 :           &amp;&amp; (opcode != ERROR_MARK || oe-&gt;rank != BIT_IOR_EXPR))</span>
<span class="lineNum">    2369 </span>            :         {
<span class="lineNum">    2370 </span>            :           stmt = NULL;
<span class="lineNum">    2371 </span>            :           tem = op;
<span class="lineNum">    2372 </span>            :         }
<span class="lineNum">    2373 </span>            :       else
<span class="lineNum">    2374 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">    2375 </span>            :     }
<span class="lineNum">    2376 </span>            : 
<span class="lineNum">    2377 </span><span class="lineCov">      13574 :   if (strict_overflow_p &amp;&amp; issue_strict_overflow_warning (wc))</span>
<span class="lineNum">    2378 </span><span class="lineNoCov">          0 :     warning_at (loc, OPT_Wstrict_overflow,</span>
<span class="lineNum">    2379 </span>            :                 &quot;assuming signed overflow does not occur &quot;
<span class="lineNum">    2380 </span>            :                 &quot;when simplifying range test&quot;);
<span class="lineNum">    2381 </span>            : 
<span class="lineNum">    2382 </span><span class="lineCov">      13574 :   if (dump_file &amp;&amp; (dump_flags &amp; TDF_DETAILS))</span>
<span class="lineNum">    2383 </span>            :     {
<span class="lineNum">    2384 </span><span class="lineCov">         45 :       struct range_entry *r;</span>
<span class="lineNum">    2385 </span><span class="lineCov">         45 :       fprintf (dump_file, &quot;Optimizing range tests &quot;);</span>
<span class="lineNum">    2386 </span><span class="lineCov">         45 :       print_generic_expr (dump_file, range-&gt;exp);</span>
<span class="lineNum">    2387 </span><span class="lineCov">         79 :       fprintf (dump_file, &quot; %c[&quot;, range-&gt;in_p ? '+' : '-');</span>
<span class="lineNum">    2388 </span><span class="lineCov">         45 :       print_generic_expr (dump_file, range-&gt;low);</span>
<span class="lineNum">    2389 </span><span class="lineCov">         45 :       fprintf (dump_file, &quot;, &quot;);</span>
<span class="lineNum">    2390 </span><span class="lineCov">         45 :       print_generic_expr (dump_file, range-&gt;high);</span>
<span class="lineNum">    2391 </span><span class="lineCov">         45 :       fprintf (dump_file, &quot;]&quot;);</span>
<span class="lineNum">    2392 </span><span class="lineCov">        153 :       for (i = 0; i &lt; count; i++)</span>
<span class="lineNum">    2393 </span>            :         {
<span class="lineNum">    2394 </span><span class="lineCov">        108 :           if (otherrange)</span>
<span class="lineNum">    2395 </span><span class="lineCov">         88 :             r = otherrange + i;</span>
<span class="lineNum">    2396 </span>            :           else
<span class="lineNum">    2397 </span><span class="lineCov">         20 :             r = otherrangep[i];</span>
<span class="lineNum">    2398 </span><span class="lineCov">        108 :           if (r-&gt;exp</span>
<span class="lineNum">    2399 </span><span class="lineCov">        108 :               &amp;&amp; r-&gt;exp != range-&gt;exp</span>
<span class="lineNum">    2400 </span><span class="lineCov">         20 :               &amp;&amp; TREE_CODE (r-&gt;exp) == SSA_NAME)</span>
<span class="lineNum">    2401 </span>            :             {
<span class="lineNum">    2402 </span><span class="lineCov">         20 :               fprintf (dump_file, &quot; and &quot;);</span>
<span class="lineNum">    2403 </span><span class="lineCov">         20 :               print_generic_expr (dump_file, r-&gt;exp);</span>
<span class="lineNum">    2404 </span>            :             }
<span class="lineNum">    2405 </span>            :           else
<span class="lineNum">    2406 </span><span class="lineCov">         88 :             fprintf (dump_file, &quot; and&quot;);</span>
<span class="lineNum">    2407 </span><span class="lineCov">        196 :           fprintf (dump_file, &quot; %c[&quot;, r-&gt;in_p ? '+' : '-');</span>
<span class="lineNum">    2408 </span><span class="lineCov">        108 :           print_generic_expr (dump_file, r-&gt;low);</span>
<span class="lineNum">    2409 </span><span class="lineCov">        108 :           fprintf (dump_file, &quot;, &quot;);</span>
<span class="lineNum">    2410 </span><span class="lineCov">        108 :           print_generic_expr (dump_file, r-&gt;high);</span>
<span class="lineNum">    2411 </span><span class="lineCov">        108 :           fprintf (dump_file, &quot;]&quot;);</span>
<span class="lineNum">    2412 </span>            :         }
<span class="lineNum">    2413 </span><span class="lineCov">         45 :       fprintf (dump_file, &quot;\n into &quot;);</span>
<span class="lineNum">    2414 </span><span class="lineCov">         45 :       print_generic_expr (dump_file, tem);</span>
<span class="lineNum">    2415 </span><span class="lineCov">         45 :       fprintf (dump_file, &quot;\n&quot;);</span>
<span class="lineNum">    2416 </span>            :     }
<span class="lineNum">    2417 </span>            : 
<span class="lineNum">    2418 </span><span class="lineCov">      13574 :   if (opcode == BIT_IOR_EXPR</span>
<span class="lineNum">    2419 </span><span class="lineCov">       9775 :       || (opcode == ERROR_MARK &amp;&amp; oe-&gt;rank == BIT_IOR_EXPR))</span>
<span class="lineNum">    2420 </span><span class="lineCov">       8910 :     tem = invert_truthvalue_loc (loc, tem);</span>
<span class="lineNum">    2421 </span>            : 
<span class="lineNum">    2422 </span><span class="lineCov">      13574 :   tem = fold_convert_loc (loc, optype, tem);</span>
<span class="lineNum">    2423 </span><span class="lineCov">      13574 :   if (stmt)</span>
<span class="lineNum">    2424 </span>            :     {
<span class="lineNum">    2425 </span><span class="lineCov">      13574 :       gsi = gsi_for_stmt (stmt);</span>
<span class="lineNum">    2426 </span><span class="lineCov">      27148 :       uid = gimple_uid (stmt);</span>
<span class="lineNum">    2427 </span>            :     }
<span class="lineNum">    2428 </span>            :   else
<span class="lineNum">    2429 </span>            :     {
<span class="lineNum">    2430 </span><span class="lineNoCov">          0 :       gsi = gsi_none ();</span>
<span class="lineNum">    2431 </span><span class="lineNoCov">          0 :       uid = 0;</span>
<span class="lineNum">    2432 </span>            :     }
<span class="lineNum">    2433 </span><span class="lineCov">      13574 :   if (stmt == NULL)</span>
<span class="lineNum">    2434 </span><span class="lineNoCov">          0 :     gcc_checking_assert (tem == op);</span>
<span class="lineNum">    2435 </span>            :   /* In rare cases range-&gt;exp can be equal to lhs of stmt.
<span class="lineNum">    2436 </span>            :      In that case we have to insert after the stmt rather then before
<span class="lineNum">    2437 </span>            :      it.  If stmt is a PHI, insert it at the start of the basic block.  */
<span class="lineNum">    2438 </span><span class="lineCov">      13574 :   else if (op != range-&gt;exp)</span>
<span class="lineNum">    2439 </span>            :     {
<span class="lineNum">    2440 </span><span class="lineCov">      13574 :       gsi_insert_seq_before (&amp;gsi, seq, GSI_SAME_STMT);</span>
<span class="lineNum">    2441 </span><span class="lineCov">      13574 :       tem = force_into_ssa_name (&amp;gsi, tem, true);</span>
<span class="lineNum">    2442 </span><span class="lineCov">      13574 :       gsi_prev (&amp;gsi);</span>
<span class="lineNum">    2443 </span>            :     }
<span class="lineNum">    2444 </span><span class="lineNoCov">          0 :   else if (gimple_code (stmt) != GIMPLE_PHI)</span>
<span class="lineNum">    2445 </span>            :     {
<span class="lineNum">    2446 </span><span class="lineNoCov">          0 :       gsi_insert_seq_after (&amp;gsi, seq, GSI_CONTINUE_LINKING);</span>
<span class="lineNum">    2447 </span><span class="lineNoCov">          0 :       tem = force_into_ssa_name (&amp;gsi, tem, false);</span>
<span class="lineNum">    2448 </span>            :     }
<span class="lineNum">    2449 </span>            :   else
<span class="lineNum">    2450 </span>            :     {
<span class="lineNum">    2451 </span><span class="lineNoCov">          0 :       gsi = gsi_after_labels (gimple_bb (stmt));</span>
<span class="lineNum">    2452 </span><span class="lineNoCov">          0 :       if (!gsi_end_p (gsi))</span>
<span class="lineNum">    2453 </span><span class="lineNoCov">          0 :         uid = gimple_uid (gsi_stmt (gsi));</span>
<span class="lineNum">    2454 </span>            :       else
<span class="lineNum">    2455 </span>            :         {
<span class="lineNum">    2456 </span><span class="lineNoCov">          0 :           gsi = gsi_start_bb (gimple_bb (stmt));</span>
<span class="lineNum">    2457 </span><span class="lineNoCov">          0 :           uid = 1;</span>
<span class="lineNum">    2458 </span><span class="lineNoCov">          0 :           while (!gsi_end_p (gsi))</span>
<span class="lineNum">    2459 </span>            :             {
<span class="lineNum">    2460 </span><span class="lineNoCov">          0 :               uid = gimple_uid (gsi_stmt (gsi));</span>
<span class="lineNum">    2461 </span><span class="lineNoCov">          0 :               gsi_next (&amp;gsi);</span>
<span class="lineNum">    2462 </span>            :             }
<span class="lineNum">    2463 </span>            :         }
<span class="lineNum">    2464 </span><span class="lineNoCov">          0 :       gsi_insert_seq_before (&amp;gsi, seq, GSI_SAME_STMT);</span>
<span class="lineNum">    2465 </span><span class="lineNoCov">          0 :       tem = force_into_ssa_name (&amp;gsi, tem, true);</span>
<span class="lineNum">    2466 </span><span class="lineNoCov">          0 :       if (gsi_end_p (gsi))</span>
<span class="lineNum">    2467 </span><span class="lineNoCov">          0 :         gsi = gsi_last_bb (gimple_bb (stmt));</span>
<span class="lineNum">    2468 </span>            :       else
<span class="lineNum">    2469 </span><span class="lineNoCov">          0 :         gsi_prev (&amp;gsi);</span>
<span class="lineNum">    2470 </span>            :     }
<span class="lineNum">    2471 </span><span class="lineCov">     103248 :   for (; !gsi_end_p (gsi); gsi_prev (&amp;gsi))</span>
<span class="lineNum">    2472 </span><span class="lineCov">     147858 :     if (gimple_uid (gsi_stmt (gsi)))</span>
<span class="lineNum">    2473 </span>            :       break;
<span class="lineNum">    2474 </span>            :     else
<span class="lineNum">    2475 </span><span class="lineCov">     114150 :       gimple_set_uid (gsi_stmt (gsi), uid);</span>
<span class="lineNum">    2476 </span>            : 
<span class="lineNum">    2477 </span><span class="lineCov">      13574 :   oe-&gt;op = tem;</span>
<span class="lineNum">    2478 </span><span class="lineCov">      13574 :   range-&gt;exp = exp;</span>
<span class="lineNum">    2479 </span><span class="lineCov">      13574 :   range-&gt;low = low;</span>
<span class="lineNum">    2480 </span><span class="lineCov">      13574 :   range-&gt;high = high;</span>
<span class="lineNum">    2481 </span><span class="lineCov">      13574 :   range-&gt;in_p = in_p;</span>
<span class="lineNum">    2482 </span><span class="lineCov">      13574 :   range-&gt;strict_overflow_p = false;</span>
<span class="lineNum">    2483 </span>            : 
<span class="lineNum">    2484 </span><span class="lineCov">      29251 :   for (i = 0; i &lt; count; i++)</span>
<span class="lineNum">    2485 </span>            :     {
<span class="lineNum">    2486 </span><span class="lineCov">      15677 :       if (otherrange)</span>
<span class="lineNum">    2487 </span><span class="lineCov">      11592 :         range = otherrange + i;</span>
<span class="lineNum">    2488 </span>            :       else
<span class="lineNum">    2489 </span><span class="lineCov">       4085 :         range = otherrangep[i];</span>
<span class="lineNum">    2490 </span><span class="lineCov">      15677 :       oe = (*ops)[range-&gt;idx];</span>
<span class="lineNum">    2491 </span>            :       /* Now change all the other range test immediate uses, so that
<span class="lineNum">    2492 </span>            :          those tests will be optimized away.  */
<span class="lineNum">    2493 </span><span class="lineCov">      15677 :       if (opcode == ERROR_MARK)</span>
<span class="lineNum">    2494 </span>            :         {
<span class="lineNum">    2495 </span><span class="lineCov">      10562 :           if (oe-&gt;op)</span>
<span class="lineNum">    2496 </span><span class="lineCov">       3674 :             oe-&gt;op = build_int_cst (TREE_TYPE (oe-&gt;op),</span>
<span class="lineNum">    2497 </span><span class="lineCov">       3674 :                                     oe-&gt;rank == BIT_IOR_EXPR ? 0 : 1);</span>
<span class="lineNum">    2498 </span>            :           else
<span class="lineNum">    2499 </span><span class="lineCov">       6888 :             oe-&gt;op = (oe-&gt;rank == BIT_IOR_EXPR</span>
<span class="lineNum">    2500 </span><span class="lineCov">       6888 :                       ? boolean_false_node : boolean_true_node);</span>
<span class="lineNum">    2501 </span>            :         }
<span class="lineNum">    2502 </span>            :       else
<span class="lineNum">    2503 </span><span class="lineCov">       5115 :         oe-&gt;op = error_mark_node;</span>
<span class="lineNum">    2504 </span><span class="lineCov">      15677 :       range-&gt;exp = NULL_TREE;</span>
<span class="lineNum">    2505 </span><span class="lineCov">      15677 :       range-&gt;low = NULL_TREE;</span>
<span class="lineNum">    2506 </span><span class="lineCov">      15677 :       range-&gt;high = NULL_TREE;</span>
<span class="lineNum">    2507 </span>            :     }
<span class="lineNum">    2508 </span>            :   return true;
<span class="lineNum">    2509 </span>            : }
<span class="lineNum">    2510 </span>            : 
<span class="lineNum">    2511 </span>            : /* Optimize X == CST1 || X == CST2
<span class="lineNum">    2512 </span>            :    if popcount (CST1 ^ CST2) == 1 into
<span class="lineNum">    2513 </span>            :    (X &amp; ~(CST1 ^ CST2)) == (CST1 &amp; ~(CST1 ^ CST2)).
<span class="lineNum">    2514 </span>            :    Similarly for ranges.  E.g.
<span class="lineNum">    2515 </span>            :    X != 2 &amp;&amp; X != 3 &amp;&amp; X != 10 &amp;&amp; X != 11
<span class="lineNum">    2516 </span>            :    will be transformed by the previous optimization into
<span class="lineNum">    2517 </span>            :    !((X - 2U) &lt;= 1U || (X - 10U) &lt;= 1U)
<span class="lineNum">    2518 </span>            :    and this loop can transform that into
<span class="lineNum">    2519 </span>            :    !(((X &amp; ~8) - 2U) &lt;= 1U).  */
<a name="2520"><span class="lineNum">    2520 </span>            : </a>
<span class="lineNum">    2521 </span>            : static bool
<span class="lineNum">    2522 </span><span class="lineCov">      25070 : optimize_range_tests_xor (enum tree_code opcode, tree type,</span>
<span class="lineNum">    2523 </span>            :                           tree lowi, tree lowj, tree highi, tree highj,
<span class="lineNum">    2524 </span>            :                           vec&lt;operand_entry *&gt; *ops,
<span class="lineNum">    2525 </span>            :                           struct range_entry *rangei,
<span class="lineNum">    2526 </span>            :                           struct range_entry *rangej)
<span class="lineNum">    2527 </span>            : {
<span class="lineNum">    2528 </span><span class="lineCov">      25070 :   tree lowxor, highxor, tem, exp;</span>
<span class="lineNum">    2529 </span>            :   /* Check lowi ^ lowj == highi ^ highj and
<span class="lineNum">    2530 </span>            :      popcount (lowi ^ lowj) == 1.  */
<span class="lineNum">    2531 </span><span class="lineCov">      25070 :   lowxor = fold_binary (BIT_XOR_EXPR, type, lowi, lowj);</span>
<span class="lineNum">    2532 </span><span class="lineCov">      25070 :   if (lowxor == NULL_TREE || TREE_CODE (lowxor) != INTEGER_CST)</span>
<span class="lineNum">    2533 </span>            :     return false;
<span class="lineNum">    2534 </span><span class="lineCov">      25070 :   if (!integer_pow2p (lowxor))</span>
<span class="lineNum">    2535 </span>            :     return false;
<span class="lineNum">    2536 </span><span class="lineCov">       2447 :   highxor = fold_binary (BIT_XOR_EXPR, type, highi, highj);</span>
<span class="lineNum">    2537 </span><span class="lineCov">       2447 :   if (!tree_int_cst_equal (lowxor, highxor))</span>
<span class="lineNum">    2538 </span>            :     return false;
<span class="lineNum">    2539 </span>            : 
<span class="lineNum">    2540 </span><span class="lineCov">       1953 :   tem = fold_build1 (BIT_NOT_EXPR, type, lowxor);</span>
<span class="lineNum">    2541 </span><span class="lineCov">       1953 :   exp = fold_build2 (BIT_AND_EXPR, type, rangei-&gt;exp, tem);</span>
<span class="lineNum">    2542 </span><span class="lineCov">       1953 :   lowj = fold_build2 (BIT_AND_EXPR, type, lowi, tem);</span>
<span class="lineNum">    2543 </span><span class="lineCov">       1953 :   highj = fold_build2 (BIT_AND_EXPR, type, highi, tem);</span>
<span class="lineNum">    2544 </span><span class="lineCov">       1953 :   if (update_range_test (rangei, rangej, NULL, 1, opcode, ops, exp,</span>
<span class="lineNum">    2545 </span><span class="lineCov">       1953 :                          NULL, rangei-&gt;in_p, lowj, highj,</span>
<span class="lineNum">    2546 </span><span class="lineCov">       1953 :                          rangei-&gt;strict_overflow_p</span>
<span class="lineNum">    2547 </span><span class="lineCov">       1953 :                          || rangej-&gt;strict_overflow_p))</span>
<span class="lineNum">    2548 </span><span class="lineCov">       1953 :     return true;</span>
<span class="lineNum">    2549 </span>            :   return false;
<span class="lineNum">    2550 </span>            : }
<span class="lineNum">    2551 </span>            : 
<span class="lineNum">    2552 </span>            : /* Optimize X == CST1 || X == CST2
<span class="lineNum">    2553 </span>            :    if popcount (CST2 - CST1) == 1 into
<span class="lineNum">    2554 </span>            :    ((X - CST1) &amp; ~(CST2 - CST1)) == 0.
<span class="lineNum">    2555 </span>            :    Similarly for ranges.  E.g.
<span class="lineNum">    2556 </span>            :    X == 43 || X == 76 || X == 44 || X == 78 || X == 77 || X == 46
<span class="lineNum">    2557 </span>            :    || X == 75 || X == 45
<span class="lineNum">    2558 </span>            :    will be transformed by the previous optimization into
<span class="lineNum">    2559 </span>            :    (X - 43U) &lt;= 3U || (X - 75U) &lt;= 3U
<span class="lineNum">    2560 </span>            :    and this loop can transform that into
<a name="2561"><span class="lineNum">    2561 </span>            :    ((X - 43U) &amp; ~(75U - 43U)) &lt;= 3U.  */</a>
<span class="lineNum">    2562 </span>            : static bool
<span class="lineNum">    2563 </span><span class="lineCov">      17127 : optimize_range_tests_diff (enum tree_code opcode, tree type,</span>
<span class="lineNum">    2564 </span>            :                            tree lowi, tree lowj, tree highi, tree highj,
<span class="lineNum">    2565 </span>            :                            vec&lt;operand_entry *&gt; *ops,
<span class="lineNum">    2566 </span>            :                            struct range_entry *rangei,
<span class="lineNum">    2567 </span>            :                            struct range_entry *rangej)
<span class="lineNum">    2568 </span>            : {
<span class="lineNum">    2569 </span><span class="lineCov">      17127 :   tree tem1, tem2, mask;</span>
<span class="lineNum">    2570 </span>            :   /* Check highi - lowi == highj - lowj.  */
<span class="lineNum">    2571 </span><span class="lineCov">      17127 :   tem1 = fold_binary (MINUS_EXPR, type, highi, lowi);</span>
<span class="lineNum">    2572 </span><span class="lineCov">      17127 :   if (tem1 == NULL_TREE || TREE_CODE (tem1) != INTEGER_CST)</span>
<span class="lineNum">    2573 </span>            :     return false;
<span class="lineNum">    2574 </span><span class="lineCov">      17127 :   tem2 = fold_binary (MINUS_EXPR, type, highj, lowj);</span>
<span class="lineNum">    2575 </span><span class="lineCov">      17127 :   if (!tree_int_cst_equal (tem1, tem2))</span>
<span class="lineNum">    2576 </span>            :     return false;
<span class="lineNum">    2577 </span>            :   /* Check popcount (lowj - lowi) == 1.  */
<span class="lineNum">    2578 </span><span class="lineCov">      10658 :   tem1 = fold_binary (MINUS_EXPR, type, lowj, lowi);</span>
<span class="lineNum">    2579 </span><span class="lineCov">      10658 :   if (tem1 == NULL_TREE || TREE_CODE (tem1) != INTEGER_CST)</span>
<span class="lineNum">    2580 </span>            :     return false;
<span class="lineNum">    2581 </span><span class="lineCov">      10658 :   if (!integer_pow2p (tem1))</span>
<span class="lineNum">    2582 </span>            :     return false;
<span class="lineNum">    2583 </span>            : 
<span class="lineNum">    2584 </span><span class="lineCov">       1566 :   type = unsigned_type_for (type);</span>
<span class="lineNum">    2585 </span><span class="lineCov">       1566 :   tem1 = fold_convert (type, tem1);</span>
<span class="lineNum">    2586 </span><span class="lineCov">       1566 :   tem2 = fold_convert (type, tem2);</span>
<span class="lineNum">    2587 </span><span class="lineCov">       1566 :   lowi = fold_convert (type, lowi);</span>
<span class="lineNum">    2588 </span><span class="lineCov">       1566 :   mask = fold_build1 (BIT_NOT_EXPR, type, tem1);</span>
<span class="lineNum">    2589 </span><span class="lineCov">       1566 :   tem1 = fold_build2 (MINUS_EXPR, type,</span>
<span class="lineNum">    2590 </span>            :                       fold_convert (type, rangei-&gt;exp), lowi);
<span class="lineNum">    2591 </span><span class="lineCov">       1566 :   tem1 = fold_build2 (BIT_AND_EXPR, type, tem1, mask);</span>
<span class="lineNum">    2592 </span><span class="lineCov">       3132 :   lowj = build_int_cst (type, 0);</span>
<span class="lineNum">    2593 </span><span class="lineCov">       1566 :   if (update_range_test (rangei, rangej, NULL, 1, opcode, ops, tem1,</span>
<span class="lineNum">    2594 </span><span class="lineCov">       1566 :                          NULL, rangei-&gt;in_p, lowj, tem2,</span>
<span class="lineNum">    2595 </span><span class="lineCov">       1566 :                          rangei-&gt;strict_overflow_p</span>
<span class="lineNum">    2596 </span><span class="lineCov">       1566 :                          || rangej-&gt;strict_overflow_p))</span>
<span class="lineNum">    2597 </span><span class="lineCov">       1566 :     return true;</span>
<span class="lineNum">    2598 </span>            :   return false;
<span class="lineNum">    2599 </span>            : }
<span class="lineNum">    2600 </span>            : 
<span class="lineNum">    2601 </span>            : /* It does some common checks for function optimize_range_tests_xor and
<span class="lineNum">    2602 </span>            :    optimize_range_tests_diff.
<span class="lineNum">    2603 </span>            :    If OPTIMIZE_XOR is TRUE, it calls optimize_range_tests_xor.
<span class="lineNum">    2604 </span>            :    Else it calls optimize_range_tests_diff.  */
<a name="2605"><span class="lineNum">    2605 </span>            : </a>
<span class="lineNum">    2606 </span>            : static bool
<span class="lineNum">    2607 </span><span class="lineCov">    1364627 : optimize_range_tests_1 (enum tree_code opcode, int first, int length,</span>
<span class="lineNum">    2608 </span>            :                         bool optimize_xor, vec&lt;operand_entry *&gt; *ops,
<span class="lineNum">    2609 </span>            :                         struct range_entry *ranges)
<span class="lineNum">    2610 </span>            : {
<span class="lineNum">    2611 </span><span class="lineCov">    1364627 :   int i, j;</span>
<span class="lineNum">    2612 </span><span class="lineCov">    1364627 :   bool any_changes = false;</span>
<span class="lineNum">    2613 </span><span class="lineCov">    2607897 :   for (i = first; i &lt; length; i++)</span>
<span class="lineNum">    2614 </span>            :     {
<span class="lineNum">    2615 </span><span class="lineCov">    1243270 :       tree lowi, highi, lowj, highj, type, tem;</span>
<span class="lineNum">    2616 </span>            : 
<span class="lineNum">    2617 </span><span class="lineCov">    1243270 :       if (ranges[i].exp == NULL_TREE || ranges[i].in_p)</span>
<span class="lineNum">    2618 </span>            :         continue;
<span class="lineNum">    2619 </span><span class="lineCov">     355498 :       type = TREE_TYPE (ranges[i].exp);</span>
<span class="lineNum">    2620 </span><span class="lineCov">     355498 :       if (!INTEGRAL_TYPE_P (type))</span>
<span class="lineNum">    2621 </span>            :         continue;
<span class="lineNum">    2622 </span><span class="lineCov">     330600 :       lowi = ranges[i].low;</span>
<span class="lineNum">    2623 </span><span class="lineCov">     330600 :       if (lowi == NULL_TREE)</span>
<span class="lineNum">    2624 </span><span class="lineCov">      27632 :         lowi = TYPE_MIN_VALUE (type);</span>
<span class="lineNum">    2625 </span><span class="lineCov">     330600 :       highi = ranges[i].high;</span>
<span class="lineNum">    2626 </span><span class="lineCov">     330600 :       if (highi == NULL_TREE)</span>
<span class="lineNum">    2627 </span>            :         continue;
<span class="lineNum">    2628 </span><span class="lineCov">     561425 :       for (j = i + 1; j &lt; length &amp;&amp; j &lt; i + 64; j++)</span>
<span class="lineNum">    2629 </span>            :         {
<span class="lineNum">    2630 </span><span class="lineCov">     237532 :           bool changes;</span>
<span class="lineNum">    2631 </span><span class="lineCov">     237532 :           if (ranges[i].exp != ranges[j].exp || ranges[j].in_p)</span>
<span class="lineNum">    2632 </span>            :             continue;
<span class="lineNum">    2633 </span><span class="lineCov">      42197 :           lowj = ranges[j].low;</span>
<span class="lineNum">    2634 </span><span class="lineCov">      42197 :           if (lowj == NULL_TREE)</span>
<span class="lineNum">    2635 </span>            :             continue;
<span class="lineNum">    2636 </span><span class="lineCov">      42197 :           highj = ranges[j].high;</span>
<span class="lineNum">    2637 </span><span class="lineCov">      42197 :           if (highj == NULL_TREE)</span>
<span class="lineNum">    2638 </span><span class="lineCov">         48 :             highj = TYPE_MAX_VALUE (type);</span>
<span class="lineNum">    2639 </span>            :           /* Check lowj &gt; highi.  */
<span class="lineNum">    2640 </span><span class="lineCov">      42197 :           tem = fold_binary (GT_EXPR, boolean_type_node,</span>
<span class="lineNum">    2641 </span>            :                              lowj, highi);
<span class="lineNum">    2642 </span><span class="lineCov">      42197 :           if (tem == NULL_TREE || !integer_onep (tem))</span>
<span class="lineNum">    2643 </span><span class="lineNoCov">          0 :             continue;</span>
<span class="lineNum">    2644 </span><span class="lineCov">      42197 :           if (optimize_xor)</span>
<span class="lineNum">    2645 </span><span class="lineCov">      25070 :             changes = optimize_range_tests_xor (opcode, type, lowi, lowj,</span>
<span class="lineNum">    2646 </span>            :                                                 highi, highj, ops,
<span class="lineNum">    2647 </span>            :                                                 ranges + i, ranges + j);
<span class="lineNum">    2648 </span>            :           else
<span class="lineNum">    2649 </span><span class="lineCov">      17127 :             changes = optimize_range_tests_diff (opcode, type, lowi, lowj,</span>
<span class="lineNum">    2650 </span>            :                                                  highi, highj, ops,
<span class="lineNum">    2651 </span>            :                                                  ranges + i, ranges + j);
<span class="lineNum">    2652 </span><span class="lineCov">      42197 :           if (changes)</span>
<span class="lineNum">    2653 </span>            :             {
<span class="lineNum">    2654 </span>            :               any_changes = true;
<span class="lineNum">    2655 </span>            :               break;
<span class="lineNum">    2656 </span>            :             }
<span class="lineNum">    2657 </span>            :         }
<span class="lineNum">    2658 </span>            :     }
<span class="lineNum">    2659 </span><span class="lineCov">    1364627 :   return any_changes;</span>
<span class="lineNum">    2660 </span>            : }
<span class="lineNum">    2661 </span>            : 
<span class="lineNum">    2662 </span>            : /* Helper function of optimize_range_tests_to_bit_test.  Handle a single
<span class="lineNum">    2663 </span>            :    range, EXP, LOW, HIGH, compute bit mask of bits to test and return
<span class="lineNum">    2664 </span>            :    EXP on success, NULL otherwise.  */
<a name="2665"><span class="lineNum">    2665 </span>            : </a>
<span class="lineNum">    2666 </span>            : static tree
<span class="lineNum">    2667 </span><span class="lineCov">      25065 : extract_bit_test_mask (tree exp, int prec, tree totallow, tree low, tree high,</span>
<span class="lineNum">    2668 </span>            :                        wide_int *mask, tree *totallowp)
<span class="lineNum">    2669 </span>            : {
<span class="lineNum">    2670 </span><span class="lineCov">      25065 :   tree tem = int_const_binop (MINUS_EXPR, high, low);</span>
<span class="lineNum">    2671 </span><span class="lineCov">      25065 :   if (tem == NULL_TREE</span>
<span class="lineNum">    2672 </span><span class="lineCov">      25065 :       || TREE_CODE (tem) != INTEGER_CST</span>
<span class="lineNum">    2673 </span><span class="lineCov">      25065 :       || TREE_OVERFLOW (tem)</span>
<span class="lineNum">    2674 </span><span class="lineCov">      22277 :       || tree_int_cst_sgn (tem) == -1</span>
<span class="lineNum">    2675 </span><span class="lineCov">      47342 :       || compare_tree_int (tem, prec) != -1)</span>
<span class="lineNum">    2676 </span><span class="lineCov">       3187 :     return NULL_TREE;</span>
<span class="lineNum">    2677 </span>            : 
<span class="lineNum">    2678 </span><span class="lineCov">      21878 :   unsigned HOST_WIDE_INT max = tree_to_uhwi (tem) + 1;</span>
<span class="lineNum">    2679 </span><span class="lineCov">      21878 :   *mask = wi::shifted_mask (0, max, false, prec);</span>
<span class="lineNum">    2680 </span><span class="lineCov">      21878 :   if (TREE_CODE (exp) == BIT_AND_EXPR</span>
<span class="lineNum">    2681 </span><span class="lineCov">      21878 :       &amp;&amp; TREE_CODE (TREE_OPERAND (exp, 1)) == INTEGER_CST)</span>
<span class="lineNum">    2682 </span>            :     {
<span class="lineNum">    2683 </span><span class="lineCov">       3273 :       widest_int msk = wi::to_widest (TREE_OPERAND (exp, 1));</span>
<span class="lineNum">    2684 </span><span class="lineCov">       6546 :       msk = wi::zext (~msk, TYPE_PRECISION (TREE_TYPE (exp)));</span>
<span class="lineNum">    2685 </span><span class="lineCov">       6546 :       if (wi::popcount (msk) == 1</span>
<span class="lineNum">    2686 </span><span class="lineCov">       3273 :           &amp;&amp; wi::ltu_p (msk, prec - max))</span>
<span class="lineNum">    2687 </span>            :         {
<span class="lineNum">    2688 </span><span class="lineCov">       4562 :           *mask |= wi::shifted_mask (msk.to_uhwi (), max, false, prec);</span>
<span class="lineNum">    2689 </span><span class="lineCov">       2281 :           max += msk.to_uhwi ();</span>
<span class="lineNum">    2690 </span><span class="lineCov">       2281 :           exp = TREE_OPERAND (exp, 0);</span>
<span class="lineNum">    2691 </span><span class="lineCov">       2281 :           if (integer_zerop (low)</span>
<span class="lineNum">    2692 </span><span class="lineCov">       1135 :               &amp;&amp; TREE_CODE (exp) == PLUS_EXPR</span>
<span class="lineNum">    2693 </span><span class="lineCov">       3386 :               &amp;&amp; TREE_CODE (TREE_OPERAND (exp, 1)) == INTEGER_CST)</span>
<span class="lineNum">    2694 </span>            :             {
<span class="lineNum">    2695 </span><span class="lineCov">       1105 :               tree ret = TREE_OPERAND (exp, 0);</span>
<span class="lineNum">    2696 </span><span class="lineCov">       1105 :               STRIP_NOPS (ret);</span>
<span class="lineNum">    2697 </span><span class="lineCov">       1105 :               widest_int bias</span>
<span class="lineNum">    2698 </span><span class="lineCov">       1105 :                 = wi::neg (wi::sext (wi::to_widest (TREE_OPERAND (exp, 1)),</span>
<span class="lineNum">    2699 </span><span class="lineCov">       2210 :                                      TYPE_PRECISION (TREE_TYPE (low))));</span>
<span class="lineNum">    2700 </span><span class="lineCov">       2210 :               tree tbias = wide_int_to_tree (TREE_TYPE (ret), bias);</span>
<span class="lineNum">    2701 </span><span class="lineCov">       1105 :               if (totallowp)</span>
<span class="lineNum">    2702 </span>            :                 {
<span class="lineNum">    2703 </span><span class="lineCov">        585 :                   *totallowp = tbias;</span>
<span class="lineNum">    2704 </span><span class="lineCov">       1037 :                   return ret;</span>
<span class="lineNum">    2705 </span>            :                 }
<span class="lineNum">    2706 </span><span class="lineCov">        520 :               else if (!tree_int_cst_lt (totallow, tbias))</span>
<span class="lineNum">    2707 </span>            :                 return NULL_TREE;
<span class="lineNum">    2708 </span><span class="lineCov">        520 :               bias = wi::to_widest (tbias);</span>
<span class="lineNum">    2709 </span><span class="lineCov">        520 :               bias -= wi::to_widest (totallow);</span>
<span class="lineNum">    2710 </span><span class="lineCov">       1040 :               if (bias &gt;= 0 &amp;&amp; bias &lt; prec - max)</span>
<span class="lineNum">    2711 </span>            :                 {
<span class="lineNum">    2712 </span><span class="lineCov">        452 :                   *mask = wi::lshift (*mask, bias);</span>
<span class="lineNum">    2713 </span><span class="lineCov">        452 :                   return ret;</span>
<span class="lineNum">    2714 </span>            :                 }
<span class="lineNum">    2715 </span>            :             }
<span class="lineNum">    2716 </span>            :         }
<span class="lineNum">    2717 </span>            :     }
<span class="lineNum">    2718 </span><span class="lineCov">      20841 :   if (totallowp)</span>
<span class="lineNum">    2719 </span>            :     return exp;
<span class="lineNum">    2720 </span><span class="lineCov">       9822 :   if (!tree_int_cst_lt (totallow, low))</span>
<span class="lineNum">    2721 </span>            :     return exp;
<span class="lineNum">    2722 </span><span class="lineCov">       9774 :   tem = int_const_binop (MINUS_EXPR, low, totallow);</span>
<span class="lineNum">    2723 </span><span class="lineCov">       9774 :   if (tem == NULL_TREE</span>
<span class="lineNum">    2724 </span><span class="lineCov">       9774 :       || TREE_CODE (tem) != INTEGER_CST</span>
<span class="lineNum">    2725 </span><span class="lineCov">       9774 :       || TREE_OVERFLOW (tem)</span>
<span class="lineNum">    2726 </span><span class="lineCov">      18912 :       || compare_tree_int (tem, prec - max) == 1)</span>
<span class="lineNum">    2727 </span><span class="lineCov">       6972 :     return NULL_TREE;</span>
<span class="lineNum">    2728 </span>            : 
<span class="lineNum">    2729 </span><span class="lineCov">       2802 :   *mask = wi::lshift (*mask, wi::to_widest (tem));</span>
<span class="lineNum">    2730 </span><span class="lineCov">       2802 :   return exp;</span>
<span class="lineNum">    2731 </span>            : }
<span class="lineNum">    2732 </span>            : 
<span class="lineNum">    2733 </span>            : /* Attempt to optimize small range tests using bit test.
<span class="lineNum">    2734 </span>            :    E.g.
<span class="lineNum">    2735 </span>            :    X != 43 &amp;&amp; X != 76 &amp;&amp; X != 44 &amp;&amp; X != 78 &amp;&amp; X != 49
<span class="lineNum">    2736 </span>            :    &amp;&amp; X != 77 &amp;&amp; X != 46 &amp;&amp; X != 75 &amp;&amp; X != 45 &amp;&amp; X != 82
<span class="lineNum">    2737 </span>            :    has been by earlier optimizations optimized into:
<span class="lineNum">    2738 </span>            :    ((X - 43U) &amp; ~32U) &gt; 3U &amp;&amp; X != 49 &amp;&amp; X != 82
<span class="lineNum">    2739 </span>            :    As all the 43 through 82 range is less than 64 numbers,
<span class="lineNum">    2740 </span>            :    for 64-bit word targets optimize that into:
<span class="lineNum">    2741 </span>            :    (X - 43U) &gt; 40U &amp;&amp; ((1 &lt;&lt; (X - 43U)) &amp; 0x8F0000004FULL) == 0  */
<span class="lineNum">    2742 </span>            : 
<span class="lineNum">    2743 </span>            : static bool
<span class="lineNum">    2744 </span><span class="lineCov">     682329 : optimize_range_tests_to_bit_test (enum tree_code opcode, int first, int length,</span>
<span class="lineNum">    2745 </span>            :                                   vec&lt;operand_entry *&gt; *ops,
<span class="lineNum">    2746 </span>            :                                   struct range_entry *ranges)
<span class="lineNum">    2747 </span>            : {
<span class="lineNum">    2748 </span><span class="lineCov">     682329 :   int i, j;</span>
<span class="lineNum">    2749 </span><span class="lineCov">     682329 :   bool any_changes = false;</span>
<span class="lineNum">    2750 </span><span class="lineCov">     682329 :   int prec = GET_MODE_BITSIZE (word_mode);</span>
<span class="lineNum">    2751 </span><span class="lineCov">     682329 :   auto_vec&lt;struct range_entry *, 64&gt; candidates;</span>
<span class="lineNum">    2752 </span>            : 
<span class="lineNum">    2753 </span><span class="lineCov">     723885 :   for (i = first; i &lt; length - 2; i++)</span>
<span class="lineNum">    2754 </span>            :     {
<span class="lineNum">    2755 </span><span class="lineCov">      41556 :       tree lowi, highi, lowj, highj, type;</span>
<span class="lineNum">    2756 </span>            : 
<span class="lineNum">    2757 </span><span class="lineCov">      41556 :       if (ranges[i].exp == NULL_TREE || ranges[i].in_p)</span>
<span class="lineNum">    2758 </span><span class="lineCov">      29952 :         continue;</span>
<span class="lineNum">    2759 </span><span class="lineCov">      15008 :       type = TREE_TYPE (ranges[i].exp);</span>
<span class="lineNum">    2760 </span><span class="lineCov">      15008 :       if (!INTEGRAL_TYPE_P (type))</span>
<span class="lineNum">    2761 </span>            :         continue;
<span class="lineNum">    2762 </span><span class="lineCov">      14796 :       lowi = ranges[i].low;</span>
<span class="lineNum">    2763 </span><span class="lineCov">      14796 :       if (lowi == NULL_TREE)</span>
<span class="lineNum">    2764 </span><span class="lineCov">       2792 :         lowi = TYPE_MIN_VALUE (type);</span>
<span class="lineNum">    2765 </span><span class="lineCov">      14796 :       highi = ranges[i].high;</span>
<span class="lineNum">    2766 </span><span class="lineCov">      14796 :       if (highi == NULL_TREE)</span>
<span class="lineNum">    2767 </span>            :         continue;
<span class="lineNum">    2768 </span><span class="lineCov">      14765 :       wide_int mask;</span>
<span class="lineNum">    2769 </span><span class="lineCov">      14765 :       tree exp = extract_bit_test_mask (ranges[i].exp, prec, lowi, lowi,</span>
<span class="lineNum">    2770 </span><span class="lineCov">      14765 :                                         highi, &amp;mask, &amp;lowi);</span>
<span class="lineNum">    2771 </span><span class="lineCov">      14765 :       if (exp == NULL_TREE)</span>
<span class="lineNum">    2772 </span>            :         continue;
<span class="lineNum">    2773 </span><span class="lineCov">      11604 :       bool strict_overflow_p = ranges[i].strict_overflow_p;</span>
<span class="lineNum">    2774 </span><span class="lineCov">      11604 :       candidates.truncate (0);</span>
<span class="lineNum">    2775 </span><span class="lineCov">      11604 :       int end = MIN (i + 64, length);</span>
<span class="lineNum">    2776 </span><span class="lineCov">      57274 :       for (j = i + 1; j &lt; end; j++)</span>
<span class="lineNum">    2777 </span>            :         {
<span class="lineNum">    2778 </span><span class="lineCov">      45670 :           tree exp2;</span>
<span class="lineNum">    2779 </span><span class="lineCov">      45670 :           if (ranges[j].exp == NULL_TREE || ranges[j].in_p)</span>
<span class="lineNum">    2780 </span><span class="lineCov">      42434 :             continue;</span>
<span class="lineNum">    2781 </span><span class="lineCov">      33788 :           if (ranges[j].exp == exp)</span>
<span class="lineNum">    2782 </span>            :             ;
<span class="lineNum">    2783 </span><span class="lineCov">      25503 :           else if (TREE_CODE (ranges[j].exp) == BIT_AND_EXPR)</span>
<span class="lineNum">    2784 </span>            :             {
<span class="lineNum">    2785 </span><span class="lineCov">       3206 :               exp2 = TREE_OPERAND (ranges[j].exp, 0);</span>
<span class="lineNum">    2786 </span><span class="lineCov">       3206 :               if (exp2 == exp)</span>
<span class="lineNum">    2787 </span>            :                 ;
<span class="lineNum">    2788 </span><span class="lineCov">       1793 :               else if (TREE_CODE (exp2) == PLUS_EXPR)</span>
<span class="lineNum">    2789 </span>            :                 {
<span class="lineNum">    2790 </span><span class="lineCov">       1240 :                   exp2 = TREE_OPERAND (exp2, 0);</span>
<span class="lineNum">    2791 </span><span class="lineCov">       1240 :                   STRIP_NOPS (exp2);</span>
<span class="lineNum">    2792 </span><span class="lineCov">       1240 :                   if (exp2 != exp)</span>
<span class="lineNum">    2793 </span>            :                     continue;
<span class="lineNum">    2794 </span>            :                 }
<span class="lineNum">    2795 </span>            :               else
<span class="lineNum">    2796 </span>            :                 continue;
<span class="lineNum">    2797 </span>            :             }
<span class="lineNum">    2798 </span>            :           else
<span class="lineNum">    2799 </span>            :             continue;
<span class="lineNum">    2800 </span><span class="lineCov">      10300 :           lowj = ranges[j].low;</span>
<span class="lineNum">    2801 </span><span class="lineCov">      10300 :           if (lowj == NULL_TREE)</span>
<span class="lineNum">    2802 </span>            :             continue;
<span class="lineNum">    2803 </span><span class="lineCov">      10300 :           highj = ranges[j].high;</span>
<span class="lineNum">    2804 </span><span class="lineCov">      10300 :           if (highj == NULL_TREE)</span>
<span class="lineNum">    2805 </span><span class="lineCov">          8 :             highj = TYPE_MAX_VALUE (type);</span>
<span class="lineNum">    2806 </span><span class="lineCov">      10300 :           wide_int mask2;</span>
<span class="lineNum">    2807 </span><span class="lineCov">      10300 :           exp2 = extract_bit_test_mask (ranges[j].exp, prec, lowi, lowj,</span>
<span class="lineNum">    2808 </span>            :                                         highj, &amp;mask2, NULL);
<span class="lineNum">    2809 </span><span class="lineCov">      10300 :           if (exp2 != exp)</span>
<span class="lineNum">    2810 </span>            :             continue;
<span class="lineNum">    2811 </span><span class="lineCov">       3236 :           mask |= mask2;</span>
<span class="lineNum">    2812 </span><span class="lineCov">       3236 :           strict_overflow_p |= ranges[j].strict_overflow_p;</span>
<span class="lineNum">    2813 </span><span class="lineCov">       3236 :           candidates.safe_push (&amp;ranges[j]);</span>
<span class="lineNum">    2814 </span>            :         }
<span class="lineNum">    2815 </span>            : 
<span class="lineNum">    2816 </span>            :       /* If we need otherwise 3 or more comparisons, use a bit test.  */
<span class="lineNum">    2817 </span><span class="lineCov">      11604 :       if (candidates.length () &gt;= 2)</span>
<span class="lineNum">    2818 </span>            :         {
<span class="lineNum">    2819 </span><span class="lineCov">        728 :           tree high = wide_int_to_tree (TREE_TYPE (lowi),</span>
<span class="lineNum">    2820 </span><span class="lineCov">       2184 :                                         wi::to_widest (lowi)</span>
<span class="lineNum">    2821 </span><span class="lineCov">       1456 :                                         + prec - 1 - wi::clz (mask));</span>
<span class="lineNum">    2822 </span><span class="lineCov">        728 :           operand_entry *oe = (*ops)[ranges[i].idx];</span>
<span class="lineNum">    2823 </span><span class="lineCov">        728 :           tree op = oe-&gt;op;</span>
<span class="lineNum">    2824 </span><span class="lineCov">        728 :           gimple *stmt = op ? SSA_NAME_DEF_STMT (op)</span>
<span class="lineNum">    2825 </span><span class="lineCov">         67 :                             : last_stmt (BASIC_BLOCK_FOR_FN (cfun, oe-&gt;id));</span>
<span class="lineNum">    2826 </span><span class="lineCov">        728 :           location_t loc = gimple_location (stmt);</span>
<span class="lineNum">    2827 </span><span class="lineCov">        728 :           tree optype = op ? TREE_TYPE (op) : boolean_type_node;</span>
<span class="lineNum">    2828 </span>            : 
<span class="lineNum">    2829 </span>            :           /* See if it isn't cheaper to pretend the minimum value of the
<span class="lineNum">    2830 </span>            :              range is 0, if maximum value is small enough.
<span class="lineNum">    2831 </span>            :              We can avoid then subtraction of the minimum value, but the
<span class="lineNum">    2832 </span>            :              mask constant could be perhaps more expensive.  */
<span class="lineNum">    2833 </span><span class="lineCov">        728 :           if (compare_tree_int (lowi, 0) &gt; 0</span>
<span class="lineNum">    2834 </span><span class="lineCov">        728 :               &amp;&amp; compare_tree_int (high, prec) &lt; 0)</span>
<span class="lineNum">    2835 </span>            :             {
<span class="lineNum">    2836 </span><span class="lineCov">        203 :               int cost_diff;</span>
<span class="lineNum">    2837 </span><span class="lineCov">        203 :               HOST_WIDE_INT m = tree_to_uhwi (lowi);</span>
<span class="lineNum">    2838 </span><span class="lineCov">        406 :               rtx reg = gen_raw_REG (word_mode, 10000);</span>
<span class="lineNum">    2839 </span><span class="lineCov">        406 :               bool speed_p = optimize_bb_for_speed_p (gimple_bb (stmt));</span>
<span class="lineNum">    2840 </span><span class="lineCov">        203 :               cost_diff = set_rtx_cost (gen_rtx_PLUS (word_mode, reg,</span>
<span class="lineNum">    2841 </span>            :                                                       GEN_INT (-m)), speed_p);
<span class="lineNum">    2842 </span><span class="lineCov">        609 :               rtx r = immed_wide_int_const (mask, word_mode);</span>
<span class="lineNum">    2843 </span><span class="lineCov">        609 :               cost_diff += set_src_cost (gen_rtx_AND (word_mode, reg, r),</span>
<span class="lineNum">    2844 </span>            :                                          word_mode, speed_p);
<span class="lineNum">    2845 </span><span class="lineCov">        406 :               r = immed_wide_int_const (wi::lshift (mask, m), word_mode);</span>
<span class="lineNum">    2846 </span><span class="lineCov">        609 :               cost_diff -= set_src_cost (gen_rtx_AND (word_mode, reg, r),</span>
<span class="lineNum">    2847 </span>            :                                          word_mode, speed_p);
<span class="lineNum">    2848 </span><span class="lineCov">        203 :               if (cost_diff &gt; 0)</span>
<span class="lineNum">    2849 </span>            :                 {
<span class="lineNum">    2850 </span><span class="lineCov">        203 :                   mask = wi::lshift (mask, m);</span>
<span class="lineNum">    2851 </span><span class="lineCov">        203 :                   lowi = build_zero_cst (TREE_TYPE (lowi));</span>
<span class="lineNum">    2852 </span>            :                 }
<span class="lineNum">    2853 </span>            :             }
<span class="lineNum">    2854 </span>            : 
<span class="lineNum">    2855 </span><span class="lineCov">        728 :           tree tem = build_range_check (loc, optype, unshare_expr (exp),</span>
<span class="lineNum">    2856 </span><span class="lineCov">        728 :                                         false, lowi, high);</span>
<span class="lineNum">    2857 </span><span class="lineCov">        728 :           if (tem == NULL_TREE || is_gimple_val (tem))</span>
<span class="lineNum">    2858 </span><span class="lineNoCov">          0 :             continue;</span>
<span class="lineNum">    2859 </span><span class="lineCov">        728 :           tree etype = unsigned_type_for (TREE_TYPE (exp));</span>
<span class="lineNum">    2860 </span><span class="lineCov">        728 :           exp = fold_build2_loc (loc, MINUS_EXPR, etype,</span>
<span class="lineNum">    2861 </span>            :                                  fold_convert_loc (loc, etype, exp),
<span class="lineNum">    2862 </span>            :                                  fold_convert_loc (loc, etype, lowi));
<span class="lineNum">    2863 </span><span class="lineCov">        728 :           exp = fold_convert_loc (loc, integer_type_node, exp);</span>
<span class="lineNum">    2864 </span><span class="lineCov">       1456 :           tree word_type = lang_hooks.types.type_for_mode (word_mode, 1);</span>
<span class="lineNum">    2865 </span><span class="lineCov">        728 :           exp = fold_build2_loc (loc, LSHIFT_EXPR, word_type,</span>
<span class="lineNum">    2866 </span><span class="lineCov">        728 :                                  build_int_cst (word_type, 1), exp);</span>
<span class="lineNum">    2867 </span><span class="lineCov">       1456 :           exp = fold_build2_loc (loc, BIT_AND_EXPR, word_type, exp,</span>
<span class="lineNum">    2868 </span>            :                                  wide_int_to_tree (word_type, mask));
<span class="lineNum">    2869 </span><span class="lineCov">        728 :           exp = fold_build2_loc (loc, EQ_EXPR, optype, exp,</span>
<span class="lineNum">    2870 </span>            :                                  build_zero_cst (word_type));
<span class="lineNum">    2871 </span><span class="lineCov">        728 :           if (is_gimple_val (exp))</span>
<span class="lineNum">    2872 </span>            :             continue;
<span class="lineNum">    2873 </span>            : 
<span class="lineNum">    2874 </span>            :           /* The shift might have undefined behavior if TEM is true,
<span class="lineNum">    2875 </span>            :              but reassociate_bb isn't prepared to have basic blocks
<span class="lineNum">    2876 </span>            :              split when it is running.  So, temporarily emit a code
<span class="lineNum">    2877 </span>            :              with BIT_IOR_EXPR instead of &amp;&amp;, and fix it up in
<span class="lineNum">    2878 </span>            :              branch_fixup.  */
<span class="lineNum">    2879 </span><span class="lineCov">        728 :           gimple_seq seq;</span>
<span class="lineNum">    2880 </span><span class="lineCov">        728 :           tem = force_gimple_operand (tem, &amp;seq, true, NULL_TREE);</span>
<span class="lineNum">    2881 </span><span class="lineCov">        728 :           gcc_assert (TREE_CODE (tem) == SSA_NAME);</span>
<span class="lineNum">    2882 </span><span class="lineCov">       1456 :           gimple_set_visited (SSA_NAME_DEF_STMT (tem), true);</span>
<span class="lineNum">    2883 </span><span class="lineCov">        728 :           gimple_seq seq2;</span>
<span class="lineNum">    2884 </span><span class="lineCov">        728 :           exp = force_gimple_operand (exp, &amp;seq2, true, NULL_TREE);</span>
<span class="lineNum">    2885 </span><span class="lineCov">        728 :           gimple_seq_add_seq_without_update (&amp;seq, seq2);</span>
<span class="lineNum">    2886 </span><span class="lineCov">        728 :           gcc_assert (TREE_CODE (exp) == SSA_NAME);</span>
<span class="lineNum">    2887 </span><span class="lineCov">       1456 :           gimple_set_visited (SSA_NAME_DEF_STMT (exp), true);</span>
<span class="lineNum">    2888 </span><span class="lineCov">        728 :           gimple *g = gimple_build_assign (make_ssa_name (optype),</span>
<span class="lineNum">    2889 </span>            :                                            BIT_IOR_EXPR, tem, exp);
<span class="lineNum">    2890 </span><span class="lineCov">        728 :           gimple_set_location (g, loc);</span>
<span class="lineNum">    2891 </span><span class="lineCov">        728 :           gimple_seq_add_stmt_without_update (&amp;seq, g);</span>
<span class="lineNum">    2892 </span><span class="lineCov">        728 :           exp = gimple_assign_lhs (g);</span>
<span class="lineNum">    2893 </span><span class="lineCov">        728 :           tree val = build_zero_cst (optype);</span>
<span class="lineNum">    2894 </span><span class="lineCov">       2184 :           if (update_range_test (&amp;ranges[i], NULL, candidates.address (),</span>
<span class="lineNum">    2895 </span>            :                                  candidates.length (), opcode, ops, exp,
<span class="lineNum">    2896 </span>            :                                  seq, false, val, val, strict_overflow_p))
<span class="lineNum">    2897 </span>            :             {
<span class="lineNum">    2898 </span><span class="lineCov">        728 :               any_changes = true;</span>
<span class="lineNum">    2899 </span><span class="lineCov">        728 :               reassoc_branch_fixups.safe_push (tem);</span>
<span class="lineNum">    2900 </span>            :             }
<span class="lineNum">    2901 </span>            :           else
<span class="lineNum">    2902 </span><span class="lineNoCov">          0 :             gimple_seq_discard (seq);</span>
<span class="lineNum">    2903 </span>            :         }
<span class="lineNum">    2904 </span>            :     }
<span class="lineNum">    2905 </span><span class="lineCov">     682329 :   return any_changes;</span>
<span class="lineNum">    2906 </span>            : }
<span class="lineNum">    2907 </span>            : 
<span class="lineNum">    2908 </span>            : /* Optimize x != 0 &amp;&amp; y != 0 &amp;&amp; z != 0 into (x | y | z) != 0
<span class="lineNum">    2909 </span>            :    and similarly x != -1 &amp;&amp; y != -1 &amp;&amp; y != -1 into (x &amp; y &amp; z) != -1.  */
<span class="lineNum">    2910 </span>            : 
<span class="lineNum">    2911 </span>            : static bool
<span class="lineNum">    2912 </span><span class="lineCov">     682329 : optimize_range_tests_cmp_bitwise (enum tree_code opcode, int first, int length,</span>
<span class="lineNum">    2913 </span>            :                                   vec&lt;operand_entry *&gt; *ops,
<span class="lineNum">    2914 </span>            :                                   struct range_entry *ranges)
<span class="lineNum">    2915 </span>            : {
<span class="lineNum">    2916 </span><span class="lineCov">     682329 :   int i;</span>
<span class="lineNum">    2917 </span><span class="lineCov">     682329 :   unsigned int b;</span>
<span class="lineNum">    2918 </span><span class="lineCov">     682329 :   bool any_changes = false;</span>
<span class="lineNum">    2919 </span><span class="lineCov">     682329 :   auto_vec&lt;int, 128&gt; buckets;</span>
<span class="lineNum">    2920 </span><span class="lineCov">    1364658 :   auto_vec&lt;int, 32&gt; chains;</span>
<span class="lineNum">    2921 </span><span class="lineCov">    1364658 :   auto_vec&lt;struct range_entry *, 32&gt; candidates;</span>
<span class="lineNum">    2922 </span>            : 
<span class="lineNum">    2923 </span><span class="lineCov">    1303976 :   for (i = first; i &lt; length; i++)</span>
<span class="lineNum">    2924 </span>            :     {
<span class="lineNum">    2925 </span><span class="lineCov">     621647 :       if (ranges[i].exp == NULL_TREE</span>
<span class="lineNum">    2926 </span><span class="lineCov">     608364 :           || TREE_CODE (ranges[i].exp) != SSA_NAME</span>
<span class="lineNum">    2927 </span><span class="lineCov">     605345 :           || !ranges[i].in_p</span>
<span class="lineNum">    2928 </span><span class="lineCov">     433085 :           || TYPE_PRECISION (TREE_TYPE (ranges[i].exp)) &lt;= 1</span>
<span class="lineNum">    2929 </span><span class="lineCov">     371260 :           || TREE_CODE (TREE_TYPE (ranges[i].exp)) == BOOLEAN_TYPE</span>
<span class="lineNum">    2930 </span><span class="lineCov">     185630 :           || ranges[i].low == NULL_TREE</span>
<span class="lineNum">    2931 </span><span class="lineCov">     801968 :           || ranges[i].low != ranges[i].high)</span>
<span class="lineNum">    2932 </span>            :         continue;
<span class="lineNum">    2933 </span>            : 
<span class="lineNum">    2934 </span><span class="lineCov">      85311 :       bool zero_p = integer_zerop (ranges[i].low);</span>
<span class="lineNum">    2935 </span><span class="lineCov">      85311 :       if (!zero_p &amp;&amp; !integer_all_onesp (ranges[i].low))</span>
<span class="lineNum">    2936 </span>            :         continue;
<span class="lineNum">    2937 </span>            : 
<span class="lineNum">    2938 </span><span class="lineCov">      36350 :       b = TYPE_PRECISION (TREE_TYPE (ranges[i].exp)) * 2 + !zero_p;</span>
<span class="lineNum">    2939 </span><span class="lineCov">      72700 :       if (buckets.length () &lt;= b)</span>
<span class="lineNum">    2940 </span><span class="lineCov">      29789 :         buckets.safe_grow_cleared (b + 1);</span>
<span class="lineNum">    2941 </span><span class="lineCov">      72700 :       if (chains.length () &lt;= (unsigned) i)</span>
<span class="lineNum">    2942 </span><span class="lineCov">      36350 :         chains.safe_grow (i + 1);</span>
<span class="lineNum">    2943 </span><span class="lineCov">      36350 :       chains[i] = buckets[b];</span>
<span class="lineNum">    2944 </span><span class="lineCov">      36350 :       buckets[b] = i + 1;</span>
<span class="lineNum">    2945 </span>            :     }
<span class="lineNum">    2946 </span>            : 
<span class="lineNum">    2947 </span><span class="lineCov">    3042201 :   FOR_EACH_VEC_ELT (buckets, b, i)</span>
<span class="lineNum">    2948 </span><span class="lineCov">    2359872 :     if (i &amp;&amp; chains[i - 1])</span>
<span class="lineNum">    2949 </span>            :       {
<span class="lineNum">    2950 </span>            :         int j, k = i;
<span class="lineNum">    2951 </span><span class="lineCov">       4300 :         for (j = chains[i - 1]; j; j = chains[j - 1])</span>
<span class="lineNum">    2952 </span>            :           {
<span class="lineNum">    2953 </span><span class="lineCov">       2394 :             gimple *gk = SSA_NAME_DEF_STMT (ranges[k - 1].exp);</span>
<span class="lineNum">    2954 </span><span class="lineCov">       2394 :             gimple *gj = SSA_NAME_DEF_STMT (ranges[j - 1].exp);</span>
<span class="lineNum">    2955 </span><span class="lineCov">       2394 :             if (reassoc_stmt_dominates_stmt_p (gk, gj))</span>
<span class="lineNum">    2956 </span><span class="lineCov">        595 :               k = j;</span>
<span class="lineNum">    2957 </span>            :           }
<span class="lineNum">    2958 </span><span class="lineCov">       1906 :         tree type1 = TREE_TYPE (ranges[k - 1].exp);</span>
<span class="lineNum">    2959 </span><span class="lineCov">       1906 :         tree type2 = NULL_TREE;</span>
<span class="lineNum">    2960 </span><span class="lineCov">       1906 :         bool strict_overflow_p = false;</span>
<span class="lineNum">    2961 </span><span class="lineCov">       1906 :         candidates.truncate (0);</span>
<span class="lineNum">    2962 </span><span class="lineCov">       6206 :         for (j = i; j; j = chains[j - 1])</span>
<span class="lineNum">    2963 </span>            :           {
<span class="lineNum">    2964 </span><span class="lineCov">       4300 :             tree type = TREE_TYPE (ranges[j - 1].exp);</span>
<span class="lineNum">    2965 </span><span class="lineCov">       4300 :             strict_overflow_p |= ranges[j - 1].strict_overflow_p;</span>
<span class="lineNum">    2966 </span><span class="lineCov">       4300 :             if (j == k</span>
<span class="lineNum">    2967 </span><span class="lineCov">       4300 :                 || useless_type_conversion_p (type1, type))</span>
<span class="lineNum">    2968 </span>            :               ;
<span class="lineNum">    2969 </span><span class="lineCov">        225 :             else if (type2 == NULL_TREE</span>
<span class="lineNum">    2970 </span><span class="lineCov">        225 :                      || useless_type_conversion_p (type2, type))</span>
<span class="lineNum">    2971 </span>            :               {
<span class="lineNum">    2972 </span><span class="lineCov">        225 :                 if (type2 == NULL_TREE)</span>
<span class="lineNum">    2973 </span><span class="lineCov">        223 :                   type2 = type;</span>
<span class="lineNum">    2974 </span><span class="lineCov">        225 :                 candidates.safe_push (&amp;ranges[j - 1]);</span>
<span class="lineNum">    2975 </span>            :               }
<span class="lineNum">    2976 </span>            :           }
<span class="lineNum">    2977 </span><span class="lineCov">       1906 :         unsigned l = candidates.length ();</span>
<span class="lineNum">    2978 </span><span class="lineCov">       6206 :         for (j = i; j; j = chains[j - 1])</span>
<span class="lineNum">    2979 </span>            :           {
<span class="lineNum">    2980 </span><span class="lineCov">       4300 :             tree type = TREE_TYPE (ranges[j - 1].exp);</span>
<span class="lineNum">    2981 </span><span class="lineCov">       4300 :             if (j == k)</span>
<span class="lineNum">    2982 </span>            :               continue;
<span class="lineNum">    2983 </span><span class="lineCov">       2394 :             if (useless_type_conversion_p (type1, type))</span>
<span class="lineNum">    2984 </span>            :               ;
<span class="lineNum">    2985 </span><span class="lineCov">        225 :             else if (type2 == NULL_TREE</span>
<span class="lineNum">    2986 </span><span class="lineCov">        225 :                      || useless_type_conversion_p (type2, type))</span>
<span class="lineNum">    2987 </span><span class="lineCov">        225 :               continue;</span>
<span class="lineNum">    2988 </span><span class="lineCov">       2169 :             candidates.safe_push (&amp;ranges[j - 1]);</span>
<span class="lineNum">    2989 </span>            :           }
<span class="lineNum">    2990 </span><span class="lineCov">       1906 :         gimple_seq seq = NULL;</span>
<span class="lineNum">    2991 </span><span class="lineCov">       1906 :         tree op = NULL_TREE;</span>
<span class="lineNum">    2992 </span><span class="lineCov">       1906 :         unsigned int id;</span>
<span class="lineNum">    2993 </span><span class="lineCov">       1906 :         struct range_entry *r;</span>
<span class="lineNum">    2994 </span><span class="lineCov">       1906 :         candidates.safe_push (&amp;ranges[k - 1]);</span>
<span class="lineNum">    2995 </span><span class="lineCov">       6206 :         FOR_EACH_VEC_ELT (candidates, id, r)</span>
<span class="lineNum">    2996 </span>            :           {
<span class="lineNum">    2997 </span><span class="lineCov">       4300 :             gimple *g;</span>
<span class="lineNum">    2998 </span><span class="lineCov">       4300 :             if (id == 0)</span>
<span class="lineNum">    2999 </span>            :               {
<span class="lineNum">    3000 </span><span class="lineCov">       1906 :                 op = r-&gt;exp;</span>
<span class="lineNum">    3001 </span><span class="lineCov">       1906 :                 continue;</span>
<span class="lineNum">    3002 </span>            :               }
<span class="lineNum">    3003 </span><span class="lineCov">       2394 :             if (id == l)</span>
<span class="lineNum">    3004 </span>            :               {
<span class="lineNum">    3005 </span><span class="lineCov">        223 :                 g = gimple_build_assign (make_ssa_name (type1), NOP_EXPR, op);</span>
<span class="lineNum">    3006 </span><span class="lineCov">        223 :                 gimple_seq_add_stmt_without_update (&amp;seq, g);</span>
<span class="lineNum">    3007 </span><span class="lineCov">        223 :                 op = gimple_assign_lhs (g);</span>
<span class="lineNum">    3008 </span>            :               }
<span class="lineNum">    3009 </span><span class="lineCov">       2394 :             tree type = TREE_TYPE (r-&gt;exp);</span>
<span class="lineNum">    3010 </span><span class="lineCov">       2394 :             tree exp = r-&gt;exp;</span>
<span class="lineNum">    3011 </span><span class="lineCov">       2394 :             if (id &gt;= l &amp;&amp; !useless_type_conversion_p (type1, type))</span>
<span class="lineNum">    3012 </span>            :               {
<span class="lineNum">    3013 </span><span class="lineNoCov">          0 :                 g = gimple_build_assign (make_ssa_name (type1), NOP_EXPR, exp);</span>
<span class="lineNum">    3014 </span><span class="lineNoCov">          0 :                 gimple_seq_add_stmt_without_update (&amp;seq, g);</span>
<span class="lineNum">    3015 </span><span class="lineNoCov">          0 :                 exp = gimple_assign_lhs (g);</span>
<span class="lineNum">    3016 </span>            :               }
<span class="lineNum">    3017 </span><span class="lineCov">       2396 :             g = gimple_build_assign (make_ssa_name (id &gt;= l ? type1 : type2),</span>
<span class="lineNum">    3018 </span><span class="lineCov">       2394 :                                      (b &amp; 1) ? BIT_AND_EXPR : BIT_IOR_EXPR,</span>
<span class="lineNum">    3019 </span>            :                                      op, exp);
<span class="lineNum">    3020 </span><span class="lineCov">       2394 :             gimple_seq_add_stmt_without_update (&amp;seq, g);</span>
<span class="lineNum">    3021 </span><span class="lineCov">       2394 :             op = gimple_assign_lhs (g);</span>
<span class="lineNum">    3022 </span>            :           }
<span class="lineNum">    3023 </span><span class="lineCov">       1906 :         candidates.pop ();</span>
<span class="lineNum">    3024 </span><span class="lineCov">       5718 :         if (update_range_test (&amp;ranges[k - 1], NULL, candidates.address (),</span>
<span class="lineNum">    3025 </span>            :                                candidates.length (), opcode, ops, op,
<span class="lineNum">    3026 </span>            :                                seq, true, ranges[k - 1].low,
<span class="lineNum">    3027 </span>            :                                ranges[k - 1].low, strict_overflow_p))
<span class="lineNum">    3028 </span>            :           any_changes = true;
<span class="lineNum">    3029 </span>            :         else
<span class="lineNum">    3030 </span><span class="lineNoCov">          0 :           gimple_seq_discard (seq);</span>
<span class="lineNum">    3031 </span>            :       }
<span class="lineNum">    3032 </span>            : 
<span class="lineNum">    3033 </span><span class="lineCov">     682329 :   return any_changes;</span>
<span class="lineNum">    3034 </span>            : }
<span class="lineNum">    3035 </span>            : 
<span class="lineNum">    3036 </span>            : /* Attempt to optimize for signed a and b where b is known to be &gt;= 0:
<span class="lineNum">    3037 </span>            :    a &gt;= 0 &amp;&amp; a &lt; b into (unsigned) a &lt; (unsigned) b
<span class="lineNum">    3038 </span>            :    a &gt;= 0 &amp;&amp; a &lt;= b into (unsigned) a &lt;= (unsigned) b  */
<span class="lineNum">    3039 </span>            : 
<span class="lineNum">    3040 </span>            : static bool
<span class="lineNum">    3041 </span><span class="lineCov">     682329 : optimize_range_tests_var_bound (enum tree_code opcode, int first, int length,</span>
<span class="lineNum">    3042 </span>            :                                 vec&lt;operand_entry *&gt; *ops,
<span class="lineNum">    3043 </span>            :                                 struct range_entry *ranges,
<span class="lineNum">    3044 </span>            :                                 basic_block first_bb)
<span class="lineNum">    3045 </span>            : {
<span class="lineNum">    3046 </span><span class="lineCov">     682329 :   int i;</span>
<span class="lineNum">    3047 </span><span class="lineCov">     682329 :   bool any_changes = false;</span>
<span class="lineNum">    3048 </span><span class="lineCov">     682329 :   hash_map&lt;tree, int&gt; *map = NULL;</span>
<span class="lineNum">    3049 </span>            : 
<span class="lineNum">    3050 </span><span class="lineCov">    1303976 :   for (i = first; i &lt; length; i++)</span>
<span class="lineNum">    3051 </span>            :     {
<span class="lineNum">    3052 </span><span class="lineCov">     621647 :       if (ranges[i].exp == NULL_TREE</span>
<span class="lineNum">    3053 </span><span class="lineCov">     605970 :           || TREE_CODE (ranges[i].exp) != SSA_NAME</span>
<span class="lineNum">    3054 </span><span class="lineCov">     602951 :           || !ranges[i].in_p)</span>
<span class="lineNum">    3055 </span>            :         continue;
<span class="lineNum">    3056 </span>            : 
<span class="lineNum">    3057 </span><span class="lineCov">     430691 :       tree type = TREE_TYPE (ranges[i].exp);</span>
<span class="lineNum">    3058 </span><span class="lineCov">     430691 :       if (!INTEGRAL_TYPE_P (type)</span>
<span class="lineNum">    3059 </span><span class="lineCov">     425610 :           || TYPE_UNSIGNED (type)</span>
<span class="lineNum">    3060 </span><span class="lineCov">     142755 :           || ranges[i].low == NULL_TREE</span>
<span class="lineNum">    3061 </span><span class="lineCov">     137446 :           || !integer_zerop (ranges[i].low)</span>
<span class="lineNum">    3062 </span><span class="lineCov">     518686 :           || ranges[i].high != NULL_TREE)</span>
<span class="lineNum">    3063 </span><span class="lineCov">     356773 :         continue;</span>
<span class="lineNum">    3064 </span>            :       /* EXP &gt;= 0 here.  */
<span class="lineNum">    3065 </span><span class="lineCov">      73918 :       if (map == NULL)</span>
<span class="lineNum">    3066 </span><span class="lineCov">      71483 :         map = new hash_map &lt;tree, int&gt;;</span>
<span class="lineNum">    3067 </span><span class="lineCov">      73918 :       map-&gt;put (ranges[i].exp, i);</span>
<span class="lineNum">    3068 </span>            :     }
<span class="lineNum">    3069 </span>            : 
<span class="lineNum">    3070 </span><span class="lineCov">     682329 :   if (map == NULL)</span>
<span class="lineNum">    3071 </span>            :     return false;
<span class="lineNum">    3072 </span>            : 
<span class="lineNum">    3073 </span><span class="lineCov">     220476 :   for (i = 0; i &lt; length; i++)</span>
<span class="lineNum">    3074 </span>            :     {
<span class="lineNum">    3075 </span><span class="lineCov">     148993 :       bool in_p = ranges[i].in_p;</span>
<span class="lineNum">    3076 </span><span class="lineCov">     148993 :       if (ranges[i].low == NULL_TREE</span>
<span class="lineNum">    3077 </span><span class="lineCov">     148230 :           || ranges[i].high == NULL_TREE)</span>
<span class="lineNum">    3078 </span><span class="lineCov">     148632 :         continue;</span>
<span class="lineNum">    3079 </span><span class="lineCov">      74075 :       if (!integer_zerop (ranges[i].low)</span>
<span class="lineNum">    3080 </span><span class="lineCov">      74075 :           || !integer_zerop (ranges[i].high))</span>
<span class="lineNum">    3081 </span>            :         {
<span class="lineNum">    3082 </span><span class="lineCov">        955 :           if (ranges[i].exp</span>
<span class="lineNum">    3083 </span><span class="lineCov">        955 :               &amp;&amp; TYPE_PRECISION (TREE_TYPE (ranges[i].exp)) == 1</span>
<span class="lineNum">    3084 </span><span class="lineNoCov">          0 :               &amp;&amp; TYPE_UNSIGNED (TREE_TYPE (ranges[i].exp))</span>
<span class="lineNum">    3085 </span><span class="lineNoCov">          0 :               &amp;&amp; integer_onep (ranges[i].low)</span>
<span class="lineNum">    3086 </span><span class="lineCov">        955 :               &amp;&amp; integer_onep (ranges[i].high))</span>
<span class="lineNum">    3087 </span><span class="lineNoCov">          0 :             in_p = !in_p;</span>
<span class="lineNum">    3088 </span>            :           else
<span class="lineNum">    3089 </span><span class="lineCov">        955 :             continue;</span>
<span class="lineNum">    3090 </span>            :         }
<span class="lineNum">    3091 </span>            : 
<span class="lineNum">    3092 </span><span class="lineCov">      73120 :       gimple *stmt;</span>
<span class="lineNum">    3093 </span><span class="lineCov">      73120 :       tree_code ccode;</span>
<span class="lineNum">    3094 </span><span class="lineCov">      73120 :       tree rhs1, rhs2;</span>
<span class="lineNum">    3095 </span><span class="lineCov">      73120 :       if (ranges[i].exp)</span>
<span class="lineNum">    3096 </span>            :         {
<span class="lineNum">    3097 </span><span class="lineCov">      72590 :           if (TREE_CODE (ranges[i].exp) != SSA_NAME)</span>
<span class="lineNum">    3098 </span>            :             continue;
<span class="lineNum">    3099 </span><span class="lineCov">      72585 :           stmt = SSA_NAME_DEF_STMT (ranges[i].exp);</span>
<span class="lineNum">    3100 </span><span class="lineCov">     145170 :           if (!is_gimple_assign (stmt))</span>
<span class="lineNum">    3101 </span>            :             continue;
<span class="lineNum">    3102 </span><span class="lineCov">      72164 :           ccode = gimple_assign_rhs_code (stmt);</span>
<span class="lineNum">    3103 </span><span class="lineCov">      72164 :           rhs1 = gimple_assign_rhs1 (stmt);</span>
<span class="lineNum">    3104 </span><span class="lineCov">      72164 :           rhs2 = gimple_assign_rhs2 (stmt);</span>
<span class="lineNum">    3105 </span>            :         }
<span class="lineNum">    3106 </span>            :       else
<span class="lineNum">    3107 </span>            :         {
<span class="lineNum">    3108 </span><span class="lineCov">        530 :           operand_entry *oe = (*ops)[ranges[i].idx];</span>
<span class="lineNum">    3109 </span><span class="lineCov">        530 :           stmt = last_stmt (BASIC_BLOCK_FOR_FN (cfun, oe-&gt;id));</span>
<span class="lineNum">    3110 </span><span class="lineCov">       1060 :           if (gimple_code (stmt) != GIMPLE_COND)</span>
<span class="lineNum">    3111 </span>            :             continue;
<span class="lineNum">    3112 </span><span class="lineCov">        530 :           ccode = gimple_cond_code (stmt);</span>
<span class="lineNum">    3113 </span><span class="lineCov">        530 :           rhs1 = gimple_cond_lhs (stmt);</span>
<span class="lineNum">    3114 </span><span class="lineCov">       1060 :           rhs2 = gimple_cond_rhs (stmt);</span>
<span class="lineNum">    3115 </span>            :         }
<span class="lineNum">    3116 </span>            : 
<span class="lineNum">    3117 </span><span class="lineCov">      72694 :       if (TREE_CODE (rhs1) != SSA_NAME</span>
<span class="lineNum">    3118 </span><span class="lineCov">      72552 :           || rhs2 == NULL_TREE</span>
<span class="lineNum">    3119 </span><span class="lineCov">      72552 :           || TREE_CODE (rhs2) != SSA_NAME)</span>
<span class="lineNum">    3120 </span>            :         continue;
<span class="lineNum">    3121 </span>            : 
<span class="lineNum">    3122 </span><span class="lineCov">      72519 :       switch (ccode)</span>
<span class="lineNum">    3123 </span>            :         {
<span class="lineNum">    3124 </span><span class="lineCov">      69309 :         case GT_EXPR:</span>
<span class="lineNum">    3125 </span><span class="lineCov">      69309 :         case GE_EXPR:</span>
<span class="lineNum">    3126 </span><span class="lineCov">      69309 :         case LT_EXPR:</span>
<span class="lineNum">    3127 </span><span class="lineCov">      69309 :         case LE_EXPR:</span>
<span class="lineNum">    3128 </span><span class="lineCov">      69309 :           break;</span>
<span class="lineNum">    3129 </span>            :         default:
<span class="lineNum">    3130 </span>            :           continue;
<span class="lineNum">    3131 </span>            :         }
<span class="lineNum">    3132 </span><span class="lineCov">      69309 :       if (in_p)</span>
<span class="lineNum">    3133 </span><span class="lineCov">      67649 :         ccode = invert_tree_comparison (ccode, false);</span>
<span class="lineNum">    3134 </span><span class="lineCov">      69309 :       switch (ccode)</span>
<span class="lineNum">    3135 </span>            :         {
<span class="lineNum">    3136 </span><span class="lineCov">      34172 :         case GT_EXPR:</span>
<span class="lineNum">    3137 </span><span class="lineCov">      34172 :         case GE_EXPR:</span>
<span class="lineNum">    3138 </span><span class="lineCov">      34172 :           std::swap (rhs1, rhs2);</span>
<span class="lineNum">    3139 </span><span class="lineCov">      34172 :           ccode = swap_tree_comparison (ccode);</span>
<span class="lineNum">    3140 </span><span class="lineCov">      34172 :           break;</span>
<span class="lineNum">    3141 </span>            :         case LT_EXPR:
<span class="lineNum">    3142 </span>            :         case LE_EXPR:
<span class="lineNum">    3143 </span>            :           break;
<span class="lineNum">    3144 </span><span class="lineNoCov">          0 :         default:</span>
<span class="lineNum">    3145 </span><span class="lineNoCov">          0 :           gcc_unreachable ();</span>
<span class="lineNum">    3146 </span>            :         }
<span class="lineNum">    3147 </span>            : 
<span class="lineNum">    3148 </span><span class="lineCov">      69309 :       int *idx = map-&gt;get (rhs1);</span>
<span class="lineNum">    3149 </span><span class="lineCov">      65725 :       if (idx == NULL)</span>
<span class="lineNum">    3150 </span>            :         continue;
<span class="lineNum">    3151 </span>            : 
<span class="lineNum">    3152 </span>            :       /* maybe_optimize_range_tests allows statements without side-effects
<span class="lineNum">    3153 </span>            :          in the basic blocks as long as they are consumed in the same bb.
<span class="lineNum">    3154 </span>            :          Make sure rhs2's def stmt is not among them, otherwise we can't
<span class="lineNum">    3155 </span>            :          use safely get_nonzero_bits on it.  E.g. in:
<span class="lineNum">    3156 </span>            :           # RANGE [-83, 1] NONZERO 173
<span class="lineNum">    3157 </span>            :           # k_32 = PHI &lt;k_47(13), k_12(9)&gt;
<span class="lineNum">    3158 </span>            :          ...
<span class="lineNum">    3159 </span>            :           if (k_32 &gt;= 0)
<span class="lineNum">    3160 </span>            :             goto &lt;bb 5&gt;; [26.46%]
<span class="lineNum">    3161 </span>            :           else
<span class="lineNum">    3162 </span>            :             goto &lt;bb 9&gt;; [73.54%]
<span class="lineNum">    3163 </span>            : 
<span class="lineNum">    3164 </span>            :           &lt;bb 5&gt; [local count: 140323371]:
<span class="lineNum">    3165 </span>            :           # RANGE [0, 1] NONZERO 1
<span class="lineNum">    3166 </span>            :           _5 = (int) k_32;
<span class="lineNum">    3167 </span>            :           # RANGE [0, 4] NONZERO 4
<span class="lineNum">    3168 </span>            :           _21 = _5 &lt;&lt; 2;
<span class="lineNum">    3169 </span>            :           # RANGE [0, 4] NONZERO 4
<span class="lineNum">    3170 </span>            :           iftmp.0_44 = (char) _21;
<span class="lineNum">    3171 </span>            :           if (k_32 &lt; iftmp.0_44)
<span class="lineNum">    3172 </span>            :             goto &lt;bb 6&gt;; [84.48%]
<span class="lineNum">    3173 </span>            :           else
<span class="lineNum">    3174 </span>            :             goto &lt;bb 9&gt;; [15.52%]
<span class="lineNum">    3175 </span>            :          the ranges on _5/_21/iftmp.0_44 are flow sensitive, assume that
<span class="lineNum">    3176 </span>            :          k_32 &gt;= 0.  If we'd optimize k_32 &gt;= 0 to true and k_32 &lt; iftmp.0_44
<span class="lineNum">    3177 </span>            :          to (unsigned) k_32 &lt; (unsigned) iftmp.0_44, then we would execute
<span class="lineNum">    3178 </span>            :          those stmts even for negative k_32 and the value ranges would be no
<span class="lineNum">    3179 </span>            :          longer guaranteed and so the optimization would be invalid.  */
<span class="lineNum">    3180 </span><span class="lineCov">      65726 :       while (opcode == ERROR_MARK)</span>
<span class="lineNum">    3181 </span>            :         {
<span class="lineNum">    3182 </span><span class="lineCov">        575 :           gimple *g = SSA_NAME_DEF_STMT (rhs2);</span>
<span class="lineNum">    3183 </span><span class="lineCov">        575 :           basic_block bb2 = gimple_bb (g);</span>
<span class="lineNum">    3184 </span><span class="lineCov">        575 :           if (bb2</span>
<span class="lineNum">    3185 </span><span class="lineCov">        575 :               &amp;&amp; bb2 != first_bb</span>
<span class="lineNum">    3186 </span><span class="lineCov">        575 :               &amp;&amp; dominated_by_p (CDI_DOMINATORS, bb2, first_bb))</span>
<span class="lineNum">    3187 </span>            :             {
<span class="lineNum">    3188 </span>            :               /* As an exception, handle a few common cases.  */
<span class="lineNum">    3189 </span><span class="lineCov">        206 :               if (gimple_assign_cast_p (g)</span>
<span class="lineNum">    3190 </span><span class="lineCov">        206 :                   &amp;&amp; INTEGRAL_TYPE_P (TREE_TYPE (gimple_assign_rhs1 (g))))</span>
<span class="lineNum">    3191 </span>            :                 {
<span class="lineNum">    3192 </span><span class="lineCov">         29 :                   tree op0 = gimple_assign_rhs1 (g);</span>
<span class="lineNum">    3193 </span><span class="lineCov">         58 :                   if (TYPE_UNSIGNED (TREE_TYPE (op0))</span>
<span class="lineNum">    3194 </span><span class="lineCov">         14 :                       &amp;&amp; (TYPE_PRECISION (TREE_TYPE (rhs2))</span>
<span class="lineNum">    3195 </span><span class="lineCov">         71 :                           &gt; TYPE_PRECISION (TREE_TYPE (op0))))</span>
<span class="lineNum">    3196 </span>            :                     /* Zero-extension is always ok.  */
<span class="lineNum">    3197 </span>            :                     break;
<span class="lineNum">    3198 </span><span class="lineCov">         16 :                   else if (TYPE_PRECISION (TREE_TYPE (rhs2))</span>
<span class="lineNum">    3199 </span><span class="lineCov">         32 :                            == TYPE_PRECISION (TREE_TYPE (op0))</span>
<span class="lineNum">    3200 </span><span class="lineCov">         16 :                            &amp;&amp; TREE_CODE (op0) == SSA_NAME)</span>
<span class="lineNum">    3201 </span>            :                     {
<span class="lineNum">    3202 </span>            :                       /* Cast from signed to unsigned or vice versa.  Retry
<span class="lineNum">    3203 </span>            :                          with the op0 as new rhs2.  */
<span class="lineNum">    3204 </span>            :                       rhs2 = op0;
<span class="lineNum">    3205 </span>            :                       continue;
<span class="lineNum">    3206 </span>            :                     }
<span class="lineNum">    3207 </span>            :                 }
<span class="lineNum">    3208 </span><span class="lineCov">        177 :               else if (is_gimple_assign (g)</span>
<span class="lineNum">    3209 </span><span class="lineCov">        177 :                        &amp;&amp; gimple_assign_rhs_code (g) == BIT_AND_EXPR</span>
<span class="lineNum">    3210 </span><span class="lineNoCov">          0 :                        &amp;&amp; TREE_CODE (gimple_assign_rhs2 (g)) == INTEGER_CST</span>
<span class="lineNum">    3211 </span><span class="lineCov">        354 :                        &amp;&amp; !wi::neg_p (wi::to_wide (gimple_assign_rhs2 (g))))</span>
<span class="lineNum">    3212 </span>            :                 /* Masking with INTEGER_CST with MSB clear is always ok
<span class="lineNum">    3213 </span>            :                    too.  */
<span class="lineNum">    3214 </span>            :                 break;
<span class="lineNum">    3215 </span>            :               rhs2 = NULL_TREE;
<span class="lineNum">    3216 </span>            :             }
<span class="lineNum">    3217 </span>            :           break;
<span class="lineNum">    3218 </span>            :         }
<span class="lineNum">    3219 </span><span class="lineCov">      65533 :       if (rhs2 == NULL_TREE)</span>
<span class="lineNum">    3220 </span><span class="lineCov">        192 :         continue;</span>
<span class="lineNum">    3221 </span>            : 
<span class="lineNum">    3222 </span><span class="lineCov">      65533 :       wide_int nz = get_nonzero_bits (rhs2);</span>
<span class="lineNum">    3223 </span><span class="lineCov">      65533 :       if (wi::neg_p (nz))</span>
<span class="lineNum">    3224 </span>            :         continue;
<span class="lineNum">    3225 </span>            : 
<span class="lineNum">    3226 </span>            :       /* We have EXP &lt; RHS2 or EXP &lt;= RHS2 where EXP &gt;= 0
<span class="lineNum">    3227 </span>            :          and RHS2 is known to be RHS2 &gt;= 0.  */
<span class="lineNum">    3228 </span><span class="lineCov">        361 :       tree utype = unsigned_type_for (TREE_TYPE (rhs1));</span>
<span class="lineNum">    3229 </span>            : 
<span class="lineNum">    3230 </span><span class="lineCov">        361 :       enum warn_strict_overflow_code wc = WARN_STRICT_OVERFLOW_COMPARISON;</span>
<span class="lineNum">    3231 </span><span class="lineCov">        361 :       if ((ranges[*idx].strict_overflow_p</span>
<span class="lineNum">    3232 </span><span class="lineCov">        361 :            || ranges[i].strict_overflow_p)</span>
<span class="lineNum">    3233 </span><span class="lineNoCov">          0 :           &amp;&amp; issue_strict_overflow_warning (wc))</span>
<span class="lineNum">    3234 </span><span class="lineNoCov">          0 :         warning_at (gimple_location (stmt), OPT_Wstrict_overflow,</span>
<span class="lineNum">    3235 </span>            :                     &quot;assuming signed overflow does not occur &quot;
<span class="lineNum">    3236 </span>            :                     &quot;when simplifying range test&quot;);
<span class="lineNum">    3237 </span>            : 
<span class="lineNum">    3238 </span><span class="lineCov">        361 :       if (dump_file &amp;&amp; (dump_flags &amp; TDF_DETAILS))</span>
<span class="lineNum">    3239 </span>            :         {
<span class="lineNum">    3240 </span><span class="lineCov">          7 :           struct range_entry *r = &amp;ranges[*idx];</span>
<span class="lineNum">    3241 </span><span class="lineCov">          7 :           fprintf (dump_file, &quot;Optimizing range test &quot;);</span>
<span class="lineNum">    3242 </span><span class="lineCov">          7 :           print_generic_expr (dump_file, r-&gt;exp);</span>
<span class="lineNum">    3243 </span><span class="lineCov">          7 :           fprintf (dump_file, &quot; +[&quot;);</span>
<span class="lineNum">    3244 </span><span class="lineCov">          7 :           print_generic_expr (dump_file, r-&gt;low);</span>
<span class="lineNum">    3245 </span><span class="lineCov">          7 :           fprintf (dump_file, &quot;, &quot;);</span>
<span class="lineNum">    3246 </span><span class="lineCov">          7 :           print_generic_expr (dump_file, r-&gt;high);</span>
<span class="lineNum">    3247 </span><span class="lineCov">          7 :           fprintf (dump_file, &quot;] and comparison &quot;);</span>
<span class="lineNum">    3248 </span><span class="lineCov">          7 :           print_generic_expr (dump_file, rhs1);</span>
<span class="lineNum">    3249 </span><span class="lineCov">          7 :           fprintf (dump_file, &quot; %s &quot;, op_symbol_code (ccode));</span>
<span class="lineNum">    3250 </span><span class="lineCov">          7 :           print_generic_expr (dump_file, rhs2);</span>
<span class="lineNum">    3251 </span><span class="lineCov">          7 :           fprintf (dump_file, &quot;\n into (&quot;);</span>
<span class="lineNum">    3252 </span><span class="lineCov">          7 :           print_generic_expr (dump_file, utype);</span>
<span class="lineNum">    3253 </span><span class="lineCov">          7 :           fprintf (dump_file, &quot;) &quot;);</span>
<span class="lineNum">    3254 </span><span class="lineCov">          7 :           print_generic_expr (dump_file, rhs1);</span>
<span class="lineNum">    3255 </span><span class="lineCov">          7 :           fprintf (dump_file, &quot; %s (&quot;, op_symbol_code (ccode));</span>
<span class="lineNum">    3256 </span><span class="lineCov">          7 :           print_generic_expr (dump_file, utype);</span>
<span class="lineNum">    3257 </span><span class="lineCov">          7 :           fprintf (dump_file, &quot;) &quot;);</span>
<span class="lineNum">    3258 </span><span class="lineCov">          7 :           print_generic_expr (dump_file, rhs2);</span>
<span class="lineNum">    3259 </span><span class="lineCov">          7 :           fprintf (dump_file, &quot;\n&quot;);</span>
<span class="lineNum">    3260 </span>            :         }
<span class="lineNum">    3261 </span>            : 
<span class="lineNum">    3262 </span><span class="lineCov">        361 :       operand_entry *oe = (*ops)[ranges[i].idx];</span>
<span class="lineNum">    3263 </span><span class="lineCov">        361 :       ranges[i].in_p = 0;</span>
<span class="lineNum">    3264 </span><span class="lineCov">        361 :       if (opcode == BIT_IOR_EXPR</span>
<span class="lineNum">    3265 </span><span class="lineCov">         37 :           || (opcode == ERROR_MARK &amp;&amp; oe-&gt;rank == BIT_IOR_EXPR))</span>
<span class="lineNum">    3266 </span>            :         {
<span class="lineNum">    3267 </span><span class="lineCov">        328 :           ranges[i].in_p = 1;</span>
<span class="lineNum">    3268 </span><span class="lineCov">        328 :           ccode = invert_tree_comparison (ccode, false);</span>
<span class="lineNum">    3269 </span>            :         }
<span class="lineNum">    3270 </span>            : 
<span class="lineNum">    3271 </span><span class="lineCov">        361 :       unsigned int uid = gimple_uid (stmt);</span>
<span class="lineNum">    3272 </span><span class="lineCov">        361 :       gimple_stmt_iterator gsi = gsi_for_stmt (stmt);</span>
<span class="lineNum">    3273 </span><span class="lineCov">        361 :       gimple *g = gimple_build_assign (make_ssa_name (utype), NOP_EXPR, rhs1);</span>
<span class="lineNum">    3274 </span><span class="lineCov">        361 :       gimple_set_uid (g, uid);</span>
<span class="lineNum">    3275 </span><span class="lineCov">        361 :       rhs1 = gimple_assign_lhs (g);</span>
<span class="lineNum">    3276 </span><span class="lineCov">        361 :       gsi_insert_before (&amp;gsi, g, GSI_SAME_STMT);</span>
<span class="lineNum">    3277 </span><span class="lineCov">        361 :       if (!useless_type_conversion_p (utype, TREE_TYPE (rhs2)))</span>
<span class="lineNum">    3278 </span>            :         {
<span class="lineNum">    3279 </span><span class="lineCov">        360 :           g = gimple_build_assign (make_ssa_name (utype), NOP_EXPR, rhs2);</span>
<span class="lineNum">    3280 </span><span class="lineCov">        360 :           gimple_set_uid (g, uid);</span>
<span class="lineNum">    3281 </span><span class="lineCov">        360 :           rhs2 = gimple_assign_lhs (g);</span>
<span class="lineNum">    3282 </span><span class="lineCov">        360 :           gsi_insert_before (&amp;gsi, g, GSI_SAME_STMT);</span>
<span class="lineNum">    3283 </span>            :         }
<span class="lineNum">    3284 </span><span class="lineCov">        361 :       if (tree_swap_operands_p (rhs1, rhs2))</span>
<span class="lineNum">    3285 </span>            :         {
<span class="lineNum">    3286 </span><span class="lineCov">        143 :           std::swap (rhs1, rhs2);</span>
<span class="lineNum">    3287 </span><span class="lineCov">        143 :           ccode = swap_tree_comparison (ccode);</span>
<span class="lineNum">    3288 </span>            :         }
<span class="lineNum">    3289 </span><span class="lineCov">        722 :       if (gimple_code (stmt) == GIMPLE_COND)</span>
<span class="lineNum">    3290 </span>            :         {
<span class="lineNum">    3291 </span><span class="lineCov">         14 :           gcond *c = as_a &lt;gcond *&gt; (stmt);</span>
<span class="lineNum">    3292 </span><span class="lineCov">         14 :           gimple_cond_set_code (c, ccode);</span>
<span class="lineNum">    3293 </span><span class="lineCov">         14 :           gimple_cond_set_lhs (c, rhs1);</span>
<span class="lineNum">    3294 </span><span class="lineCov">         14 :           gimple_cond_set_rhs (c, rhs2);</span>
<span class="lineNum">    3295 </span><span class="lineCov">         14 :           update_stmt (stmt);</span>
<span class="lineNum">    3296 </span>            :         }
<span class="lineNum">    3297 </span>            :       else
<span class="lineNum">    3298 </span>            :         {
<span class="lineNum">    3299 </span><span class="lineCov">        347 :           tree ctype = oe-&gt;op ? TREE_TYPE (oe-&gt;op) : boolean_type_node;</span>
<span class="lineNum">    3300 </span><span class="lineCov">        347 :           if (!INTEGRAL_TYPE_P (ctype)</span>
<span class="lineNum">    3301 </span><span class="lineCov">        347 :               || (TREE_CODE (ctype) != BOOLEAN_TYPE</span>
<span class="lineNum">    3302 </span><span class="lineCov">          5 :                   &amp;&amp; TYPE_PRECISION (ctype) != 1))</span>
<span class="lineNum">    3303 </span><span class="lineCov">          5 :             ctype = boolean_type_node;</span>
<span class="lineNum">    3304 </span><span class="lineCov">        347 :           g = gimple_build_assign (make_ssa_name (ctype), ccode, rhs1, rhs2);</span>
<span class="lineNum">    3305 </span><span class="lineCov">        347 :           gimple_set_uid (g, uid);</span>
<span class="lineNum">    3306 </span><span class="lineCov">        347 :           gsi_insert_before (&amp;gsi, g, GSI_SAME_STMT);</span>
<span class="lineNum">    3307 </span><span class="lineCov">        347 :           if (oe-&gt;op &amp;&amp; ctype != TREE_TYPE (oe-&gt;op))</span>
<span class="lineNum">    3308 </span>            :             {
<span class="lineNum">    3309 </span><span class="lineCov">          5 :               g = gimple_build_assign (make_ssa_name (TREE_TYPE (oe-&gt;op)),</span>
<span class="lineNum">    3310 </span>            :                                        NOP_EXPR, gimple_assign_lhs (g));
<span class="lineNum">    3311 </span><span class="lineCov">          5 :               gimple_set_uid (g, uid);</span>
<span class="lineNum">    3312 </span><span class="lineCov">          5 :               gsi_insert_before (&amp;gsi, g, GSI_SAME_STMT);</span>
<span class="lineNum">    3313 </span>            :             }
<span class="lineNum">    3314 </span><span class="lineCov">        347 :           ranges[i].exp = gimple_assign_lhs (g);</span>
<span class="lineNum">    3315 </span><span class="lineCov">        347 :           oe-&gt;op = ranges[i].exp;</span>
<span class="lineNum">    3316 </span><span class="lineCov">        347 :           ranges[i].low = build_zero_cst (TREE_TYPE (ranges[i].exp));</span>
<span class="lineNum">    3317 </span><span class="lineCov">        347 :           ranges[i].high = ranges[i].low;</span>
<span class="lineNum">    3318 </span>            :         }
<span class="lineNum">    3319 </span><span class="lineCov">        361 :       ranges[i].strict_overflow_p = false;</span>
<span class="lineNum">    3320 </span><span class="lineCov">        361 :       oe = (*ops)[ranges[*idx].idx];</span>
<span class="lineNum">    3321 </span>            :       /* Now change all the other range test immediate uses, so that
<span class="lineNum">    3322 </span>            :          those tests will be optimized away.  */
<span class="lineNum">    3323 </span><span class="lineCov">        361 :       if (opcode == ERROR_MARK)</span>
<span class="lineNum">    3324 </span>            :         {
<span class="lineNum">    3325 </span><span class="lineCov">         20 :           if (oe-&gt;op)</span>
<span class="lineNum">    3326 </span><span class="lineCov">          4 :             oe-&gt;op = build_int_cst (TREE_TYPE (oe-&gt;op),</span>
<span class="lineNum">    3327 </span><span class="lineCov">          4 :                                     oe-&gt;rank == BIT_IOR_EXPR ? 0 : 1);</span>
<span class="lineNum">    3328 </span>            :           else
<span class="lineNum">    3329 </span><span class="lineCov">         16 :             oe-&gt;op = (oe-&gt;rank == BIT_IOR_EXPR</span>
<span class="lineNum">    3330 </span><span class="lineCov">         16 :                       ? boolean_false_node : boolean_true_node);</span>
<span class="lineNum">    3331 </span>            :         }
<span class="lineNum">    3332 </span>            :       else
<span class="lineNum">    3333 </span><span class="lineCov">        341 :         oe-&gt;op = error_mark_node;</span>
<span class="lineNum">    3334 </span><span class="lineCov">        361 :       ranges[*idx].exp = NULL_TREE;</span>
<span class="lineNum">    3335 </span><span class="lineCov">        361 :       ranges[*idx].low = NULL_TREE;</span>
<span class="lineNum">    3336 </span><span class="lineCov">        361 :       ranges[*idx].high = NULL_TREE;</span>
<span class="lineNum">    3337 </span><span class="lineCov">        361 :       any_changes = true;</span>
<span class="lineNum">    3338 </span>            :     }
<span class="lineNum">    3339 </span>            : 
<span class="lineNum">    3340 </span><span class="lineCov">      71483 :   delete map;</span>
<span class="lineNum">    3341 </span><span class="lineCov">      71483 :   return any_changes;</span>
<span class="lineNum">    3342 </span>            : }
<span class="lineNum">    3343 </span>            : 
<span class="lineNum">    3344 </span>            : /* Optimize range tests, similarly how fold_range_test optimizes
<span class="lineNum">    3345 </span>            :    it on trees.  The tree code for the binary
<span class="lineNum">    3346 </span>            :    operation between all the operands is OPCODE.
<span class="lineNum">    3347 </span>            :    If OPCODE is ERROR_MARK, optimize_range_tests is called from within
<span class="lineNum">    3348 </span>            :    maybe_optimize_range_tests for inter-bb range optimization.
<span class="lineNum">    3349 </span>            :    In that case if oe-&gt;op is NULL, oe-&gt;id is bb-&gt;index whose
<span class="lineNum">    3350 </span>            :    GIMPLE_COND is &amp;&amp; or ||ed into the test, and oe-&gt;rank says
<span class="lineNum">    3351 </span>            :    the actual opcode.
<span class="lineNum">    3352 </span>            :    FIRST_BB is the first basic block if OPCODE is ERROR_MARK.  */
<span class="lineNum">    3353 </span>            : 
<span class="lineNum">    3354 </span>            : static bool
<span class="lineNum">    3355 </span><span class="lineCov">     683859 : optimize_range_tests (enum tree_code opcode,</span>
<span class="lineNum">    3356 </span>            :                       vec&lt;operand_entry *&gt; *ops, basic_block first_bb)
<span class="lineNum">    3357 </span>            : {
<span class="lineNum">    3358 </span><span class="lineCov">     683859 :   unsigned int length = ops-&gt;length (), i, j, first;</span>
<span class="lineNum">    3359 </span><span class="lineCov">     683859 :   operand_entry *oe;</span>
<span class="lineNum">    3360 </span><span class="lineCov">     683859 :   struct range_entry *ranges;</span>
<span class="lineNum">    3361 </span><span class="lineCov">     683859 :   bool any_changes = false;</span>
<span class="lineNum">    3362 </span>            : 
<span class="lineNum">    3363 </span><span class="lineCov">     683859 :   if (length == 1)</span>
<span class="lineNum">    3364 </span>            :     return false;
<span class="lineNum">    3365 </span>            : 
<span class="lineNum">    3366 </span><span class="lineCov">     682329 :   ranges = XNEWVEC (struct range_entry, length);</span>
<span class="lineNum">    3367 </span><span class="lineCov">    2109141 :   for (i = 0; i &lt; length; i++)</span>
<span class="lineNum">    3368 </span>            :     {
<span class="lineNum">    3369 </span><span class="lineCov">    1426812 :       oe = (*ops)[i];</span>
<span class="lineNum">    3370 </span><span class="lineCov">    1426812 :       ranges[i].idx = i;</span>
<span class="lineNum">    3371 </span><span class="lineCov">    1426812 :       init_range_entry (ranges + i, oe-&gt;op,</span>
<span class="lineNum">    3372 </span><span class="lineCov">    1426812 :                         oe-&gt;op</span>
<span class="lineNum">    3373 </span>            :                         ? NULL
<span class="lineNum">    3374 </span><span class="lineCov">     186292 :                         : last_stmt (BASIC_BLOCK_FOR_FN (cfun, oe-&gt;id)));</span>
<span class="lineNum">    3375 </span>            :       /* For | invert it now, we will invert it again before emitting
<span class="lineNum">    3376 </span>            :          the optimized expression.  */
<span class="lineNum">    3377 </span><span class="lineCov">    1426812 :       if (opcode == BIT_IOR_EXPR</span>
<span class="lineNum">    3378 </span><span class="lineCov">     891708 :           || (opcode == ERROR_MARK &amp;&amp; oe-&gt;rank == BIT_IOR_EXPR))</span>
<span class="lineNum">    3379 </span><span class="lineCov">     632987 :         ranges[i].in_p = !ranges[i].in_p;</span>
<span class="lineNum">    3380 </span>            :     }
<span class="lineNum">    3381 </span>            : 
<span class="lineNum">    3382 </span><span class="lineCov">     682329 :   qsort (ranges, length, sizeof (*ranges), range_entry_cmp);</span>
<span class="lineNum">    3383 </span><span class="lineCov">    1487494 :   for (i = 0; i &lt; length; i++)</span>
<span class="lineNum">    3384 </span><span class="lineCov">    1111437 :     if (ranges[i].exp != NULL_TREE &amp;&amp; TREE_CODE (ranges[i].exp) == SSA_NAME)</span>
<span class="lineNum">    3385 </span>            :       break;
<span class="lineNum">    3386 </span>            : 
<span class="lineNum">    3387 </span>            :   /* Try to merge ranges.  */
<span class="lineNum">    3388 </span><span class="lineCov">    1295903 :   for (first = i; i &lt; length; i++)</span>
<span class="lineNum">    3389 </span>            :     {
<span class="lineNum">    3390 </span><span class="lineCov">     613574 :       tree low = ranges[i].low;</span>
<span class="lineNum">    3391 </span><span class="lineCov">     613574 :       tree high = ranges[i].high;</span>
<span class="lineNum">    3392 </span><span class="lineCov">     613574 :       int in_p = ranges[i].in_p;</span>
<span class="lineNum">    3393 </span><span class="lineCov">     613574 :       bool strict_overflow_p = ranges[i].strict_overflow_p;</span>
<span class="lineNum">    3394 </span><span class="lineCov">     613574 :       int update_fail_count = 0;</span>
<span class="lineNum">    3395 </span>            : 
<span class="lineNum">    3396 </span><span class="lineCov">     621647 :       for (j = i + 1; j &lt; length; j++)</span>
<span class="lineNum">    3397 </span>            :         {
<span class="lineNum">    3398 </span><span class="lineCov">     315375 :           if (ranges[i].exp != ranges[j].exp)</span>
<span class="lineNum">    3399 </span>            :             break;
<span class="lineNum">    3400 </span><span class="lineCov">      22371 :           if (!merge_ranges (&amp;in_p, &amp;low, &amp;high, in_p, low, high,</span>
<span class="lineNum">    3401 </span><span class="lineCov">      22371 :                              ranges[j].in_p, ranges[j].low, ranges[j].high))</span>
<span class="lineNum">    3402 </span>            :             break;
<span class="lineNum">    3403 </span><span class="lineCov">       8073 :           strict_overflow_p |= ranges[j].strict_overflow_p;</span>
<span class="lineNum">    3404 </span>            :         }
<span class="lineNum">    3405 </span>            : 
<span class="lineNum">    3406 </span><span class="lineCov">     613574 :       if (j == i + 1)</span>
<span class="lineNum">    3407 </span><span class="lineCov">     606153 :         continue;</span>
<span class="lineNum">    3408 </span>            : 
<span class="lineNum">    3409 </span><span class="lineCov">       7421 :       if (update_range_test (ranges + i, ranges + i + 1, NULL, j - i - 1,</span>
<span class="lineNum">    3410 </span>            :                              opcode, ops, ranges[i].exp, NULL, in_p,
<span class="lineNum">    3411 </span>            :                              low, high, strict_overflow_p))
<span class="lineNum">    3412 </span>            :         {
<span class="lineNum">    3413 </span><span class="lineCov">       7421 :           i = j - 1;</span>
<span class="lineNum">    3414 </span><span class="lineCov">       7421 :           any_changes = true;</span>
<span class="lineNum">    3415 </span>            :         }
<span class="lineNum">    3416 </span>            :       /* Avoid quadratic complexity if all merge_ranges calls would succeed,
<span class="lineNum">    3417 </span>            :          while update_range_test would fail.  */
<span class="lineNum">    3418 </span>            :       else if (update_fail_count == 64)
<span class="lineNum">    3419 </span>            :         i = j - 1;
<span class="lineNum">    3420 </span>            :       else
<span class="lineNum">    3421 </span>            :         ++update_fail_count;
<span class="lineNum">    3422 </span>            :     }
<span class="lineNum">    3423 </span>            : 
<span class="lineNum">    3424 </span><span class="lineCov">     682329 :   any_changes |= optimize_range_tests_1 (opcode, first, length, true,</span>
<span class="lineNum">    3425 </span>            :                                          ops, ranges);
<span class="lineNum">    3426 </span>            : 
<span class="lineNum">    3427 </span><span class="lineCov">     682329 :   if (BRANCH_COST (optimize_function_for_speed_p (cfun), false) &gt;= 2)</span>
<span class="lineNum">    3428 </span><span class="lineCov">     682298 :     any_changes |= optimize_range_tests_1 (opcode, first, length, false,</span>
<span class="lineNum">    3429 </span>            :                                            ops, ranges);
<span class="lineNum">    3430 </span><span class="lineCov">     682329 :   if (lshift_cheap_p (optimize_function_for_speed_p (cfun)))</span>
<span class="lineNum">    3431 </span><span class="lineCov">     682329 :     any_changes |= optimize_range_tests_to_bit_test (opcode, first, length,</span>
<span class="lineNum">    3432 </span>            :                                                      ops, ranges);
<span class="lineNum">    3433 </span><span class="lineCov">     682329 :   any_changes |= optimize_range_tests_cmp_bitwise (opcode, first, length,</span>
<span class="lineNum">    3434 </span>            :                                                    ops, ranges);
<span class="lineNum">    3435 </span><span class="lineCov">     682329 :   any_changes |= optimize_range_tests_var_bound (opcode, first, length, ops,</span>
<span class="lineNum">    3436 </span>            :                                                  ranges, first_bb);
<span class="lineNum">    3437 </span>            : 
<span class="lineNum">    3438 </span><span class="lineCov">     682329 :   if (any_changes &amp;&amp; opcode != ERROR_MARK)</span>
<span class="lineNum">    3439 </span>            :     {
<span class="lineNum">    3440 </span>            :       j = 0;
<span class="lineNum">    3441 </span><span class="lineCov">      17465 :       FOR_EACH_VEC_ELT (*ops, i, oe)</span>
<span class="lineNum">    3442 </span>            :         {
<span class="lineNum">    3443 </span><span class="lineCov">      12268 :           if (oe-&gt;op == error_mark_node)</span>
<span class="lineNum">    3444 </span>            :             continue;
<span class="lineNum">    3445 </span><span class="lineCov">       6812 :           else if (i != j)</span>
<span class="lineNum">    3446 </span><span class="lineCov">       3803 :             (*ops)[j] = oe;</span>
<span class="lineNum">    3447 </span><span class="lineCov">       6812 :           j++;</span>
<span class="lineNum">    3448 </span>            :         }
<span class="lineNum">    3449 </span><span class="lineCov">       5197 :       ops-&gt;truncate (j);</span>
<span class="lineNum">    3450 </span>            :     }
<span class="lineNum">    3451 </span>            : 
<span class="lineNum">    3452 </span><span class="lineCov">     682329 :   XDELETEVEC (ranges);</span>
<span class="lineNum">    3453 </span><span class="lineCov">     682329 :   return any_changes;</span>
<span class="lineNum">    3454 </span>            : }
<span class="lineNum">    3455 </span>            : 
<span class="lineNum">    3456 </span>            : /* A subroutine of optimize_vec_cond_expr to extract and canonicalize
<span class="lineNum">    3457 </span>            :    the operands of the VEC_COND_EXPR.  Returns ERROR_MARK on failure,
<span class="lineNum">    3458 </span>            :    otherwise the comparison code.  */
<a name="3459"><span class="lineNum">    3459 </span>            : </a>
<span class="lineNum">    3460 </span>            : static tree_code
<span class="lineNum">    3461 </span><span class="lineCov">       7281 : ovce_extract_ops (tree var, gassign **rets, bool *reti)</span>
<span class="lineNum">    3462 </span>            : {
<span class="lineNum">    3463 </span><span class="lineCov">       7281 :   if (TREE_CODE (var) != SSA_NAME)</span>
<span class="lineNum">    3464 </span>            :     return ERROR_MARK;
<span class="lineNum">    3465 </span>            : 
<span class="lineNum">    3466 </span><span class="lineCov">      13264 :   gassign *stmt = dyn_cast &lt;gassign *&gt; (SSA_NAME_DEF_STMT (var));</span>
<span class="lineNum">    3467 </span><span class="lineCov">       6127 :   if (stmt == NULL)</span>
<span class="lineNum">    3468 </span>            :     return ERROR_MARK;
<span class="lineNum">    3469 </span>            : 
<span class="lineNum">    3470 </span>            :   /* ??? If we start creating more COND_EXPR, we could perform
<span class="lineNum">    3471 </span>            :      this same optimization with them.  For now, simplify.  */
<span class="lineNum">    3472 </span><span class="lineCov">       9282 :   if (gimple_assign_rhs_code (stmt) != VEC_COND_EXPR)</span>
<span class="lineNum">    3473 </span>            :     return ERROR_MARK;
<span class="lineNum">    3474 </span>            : 
<span class="lineNum">    3475 </span><span class="lineCov">         54 :   tree cond = gimple_assign_rhs1 (stmt);</span>
<span class="lineNum">    3476 </span><span class="lineCov">         54 :   tree_code cmp = TREE_CODE (cond);</span>
<span class="lineNum">    3477 </span><span class="lineCov">         54 :   if (TREE_CODE_CLASS (cmp) != tcc_comparison)</span>
<span class="lineNum">    3478 </span>            :     return ERROR_MARK;
<span class="lineNum">    3479 </span>            : 
<span class="lineNum">    3480 </span>            :   /* ??? For now, allow only canonical true and false result vectors.
<span class="lineNum">    3481 </span>            :      We could expand this to other constants should the need arise,
<span class="lineNum">    3482 </span>            :      but at the moment we don't create them.  */
<span class="lineNum">    3483 </span><span class="lineCov">         44 :   tree t = gimple_assign_rhs2 (stmt);</span>
<span class="lineNum">    3484 </span><span class="lineCov">         44 :   tree f = gimple_assign_rhs3 (stmt);</span>
<span class="lineNum">    3485 </span><span class="lineCov">         44 :   bool inv;</span>
<span class="lineNum">    3486 </span><span class="lineCov">         44 :   if (integer_all_onesp (t))</span>
<span class="lineNum">    3487 </span>            :     inv = false;
<span class="lineNum">    3488 </span><span class="lineCov">          8 :   else if (integer_all_onesp (f))</span>
<span class="lineNum">    3489 </span>            :     {
<span class="lineNum">    3490 </span><span class="lineNoCov">          0 :       cmp = invert_tree_comparison (cmp, false);</span>
<span class="lineNum">    3491 </span><span class="lineNoCov">          0 :       inv = true;</span>
<span class="lineNum">    3492 </span>            :     }
<span class="lineNum">    3493 </span>            :   else
<span class="lineNum">    3494 </span>            :     return ERROR_MARK;
<span class="lineNum">    3495 </span><span class="lineCov">         36 :   if (!integer_zerop (f))</span>
<span class="lineNum">    3496 </span>            :     return ERROR_MARK;
<span class="lineNum">    3497 </span>            : 
<span class="lineNum">    3498 </span>            :   /* Success!  */
<span class="lineNum">    3499 </span><span class="lineCov">         36 :   if (rets)</span>
<span class="lineNum">    3500 </span><span class="lineCov">         36 :     *rets = stmt;</span>
<span class="lineNum">    3501 </span><span class="lineCov">         36 :   if (reti)</span>
<span class="lineNum">    3502 </span><span class="lineCov">         21 :     *reti = inv;</span>
<span class="lineNum">    3503 </span>            :   return cmp;
<span class="lineNum">    3504 </span>            : }
<span class="lineNum">    3505 </span>            : 
<span class="lineNum">    3506 </span>            : /* Optimize the condition of VEC_COND_EXPRs which have been combined
<span class="lineNum">    3507 </span>            :    with OPCODE (either BIT_AND_EXPR or BIT_IOR_EXPR).  */
<span class="lineNum">    3508 </span>            : 
<span class="lineNum">    3509 </span>            : static bool
<span class="lineNum">    3510 </span><span class="lineCov">       3483 : optimize_vec_cond_expr (tree_code opcode, vec&lt;operand_entry *&gt; *ops)</span>
<span class="lineNum">    3511 </span>            : {
<span class="lineNum">    3512 </span><span class="lineCov">       3483 :   unsigned int length = ops-&gt;length (), i, j;</span>
<span class="lineNum">    3513 </span><span class="lineCov">       3483 :   bool any_changes = false;</span>
<span class="lineNum">    3514 </span>            : 
<span class="lineNum">    3515 </span><span class="lineCov">       3483 :   if (length == 1)</span>
<span class="lineNum">    3516 </span>            :     return false;
<span class="lineNum">    3517 </span>            : 
<span class="lineNum">    3518 </span><span class="lineCov">      10749 :   for (i = 0; i &lt; length; ++i)</span>
<span class="lineNum">    3519 </span>            :     {
<span class="lineNum">    3520 </span><span class="lineCov">       7266 :       tree elt0 = (*ops)[i]-&gt;op;</span>
<span class="lineNum">    3521 </span>            : 
<span class="lineNum">    3522 </span><span class="lineCov">       7266 :       gassign *stmt0;</span>
<span class="lineNum">    3523 </span><span class="lineCov">       7266 :       bool invert;</span>
<span class="lineNum">    3524 </span><span class="lineCov">       7266 :       tree_code cmp0 = ovce_extract_ops (elt0, &amp;stmt0, &amp;invert);</span>
<span class="lineNum">    3525 </span><span class="lineCov">       7266 :       if (cmp0 == ERROR_MARK)</span>
<span class="lineNum">    3526 </span><span class="lineCov">       7245 :         continue;</span>
<span class="lineNum">    3527 </span>            : 
<span class="lineNum">    3528 </span><span class="lineCov">         36 :       for (j = i + 1; j &lt; length; ++j)</span>
<span class="lineNum">    3529 </span>            :         {
<span class="lineNum">    3530 </span><span class="lineCov">         15 :           tree &amp;elt1 = (*ops)[j]-&gt;op;</span>
<span class="lineNum">    3531 </span>            : 
<span class="lineNum">    3532 </span><span class="lineCov">         15 :           gassign *stmt1;</span>
<span class="lineNum">    3533 </span><span class="lineCov">         15 :           tree_code cmp1 = ovce_extract_ops (elt1, &amp;stmt1, NULL);</span>
<span class="lineNum">    3534 </span><span class="lineCov">         15 :           if (cmp1 == ERROR_MARK)</span>
<span class="lineNum">    3535 </span><span class="lineCov">          6 :             continue;</span>
<span class="lineNum">    3536 </span>            : 
<span class="lineNum">    3537 </span><span class="lineCov">         15 :           tree cond0 = gimple_assign_rhs1 (stmt0);</span>
<span class="lineNum">    3538 </span><span class="lineCov">         15 :           tree x0 = TREE_OPERAND (cond0, 0);</span>
<span class="lineNum">    3539 </span><span class="lineCov">         15 :           tree y0 = TREE_OPERAND (cond0, 1);</span>
<span class="lineNum">    3540 </span>            : 
<span class="lineNum">    3541 </span><span class="lineCov">         15 :           tree cond1 = gimple_assign_rhs1 (stmt1);</span>
<span class="lineNum">    3542 </span><span class="lineCov">         15 :           tree x1 = TREE_OPERAND (cond1, 0);</span>
<span class="lineNum">    3543 </span><span class="lineCov">         15 :           tree y1 = TREE_OPERAND (cond1, 1);</span>
<span class="lineNum">    3544 </span>            : 
<span class="lineNum">    3545 </span><span class="lineCov">         15 :           tree comb;</span>
<span class="lineNum">    3546 </span><span class="lineCov">         15 :           if (opcode == BIT_AND_EXPR)</span>
<span class="lineNum">    3547 </span><span class="lineCov">         10 :             comb = maybe_fold_and_comparisons (cmp0, x0, y0, cmp1, x1, y1);</span>
<span class="lineNum">    3548 </span><span class="lineCov">          5 :           else if (opcode == BIT_IOR_EXPR)</span>
<span class="lineNum">    3549 </span><span class="lineCov">          5 :             comb = maybe_fold_or_comparisons (cmp0, x0, y0, cmp1, x1, y1);</span>
<span class="lineNum">    3550 </span>            :           else
<span class="lineNum">    3551 </span><span class="lineNoCov">          0 :             gcc_unreachable ();</span>
<span class="lineNum">    3552 </span><span class="lineCov">         15 :           if (comb == NULL)</span>
<span class="lineNum">    3553 </span>            :             continue;
<span class="lineNum">    3554 </span>            : 
<span class="lineNum">    3555 </span>            :           /* Success! */
<span class="lineNum">    3556 </span><span class="lineCov">          9 :           if (dump_file &amp;&amp; (dump_flags &amp; TDF_DETAILS))</span>
<span class="lineNum">    3557 </span>            :             {
<span class="lineNum">    3558 </span><span class="lineNoCov">          0 :               fprintf (dump_file, &quot;Transforming &quot;);</span>
<span class="lineNum">    3559 </span><span class="lineNoCov">          0 :               print_generic_expr (dump_file, cond0);</span>
<span class="lineNum">    3560 </span><span class="lineNoCov">          0 :               fprintf (dump_file, &quot; %c &quot;, opcode == BIT_AND_EXPR ? '&amp;' : '|');</span>
<span class="lineNum">    3561 </span><span class="lineNoCov">          0 :               print_generic_expr (dump_file, cond1);</span>
<span class="lineNum">    3562 </span><span class="lineNoCov">          0 :               fprintf (dump_file, &quot; into &quot;);</span>
<span class="lineNum">    3563 </span><span class="lineNoCov">          0 :               print_generic_expr (dump_file, comb);</span>
<span class="lineNum">    3564 </span><span class="lineNoCov">          0 :               fputc ('\n', dump_file);</span>
<span class="lineNum">    3565 </span>            :             }
<span class="lineNum">    3566 </span>            : 
<span class="lineNum">    3567 </span><span class="lineCov">          9 :           gimple_assign_set_rhs1 (stmt0, comb);</span>
<span class="lineNum">    3568 </span><span class="lineCov">          9 :           if (invert)</span>
<span class="lineNum">    3569 </span><span class="lineNoCov">          0 :             std::swap (*gimple_assign_rhs2_ptr (stmt0),</span>
<span class="lineNum">    3570 </span><span class="lineNoCov">          0 :                        *gimple_assign_rhs3_ptr (stmt0));</span>
<span class="lineNum">    3571 </span><span class="lineCov">          9 :           update_stmt (stmt0);</span>
<span class="lineNum">    3572 </span>            : 
<span class="lineNum">    3573 </span><span class="lineCov">          9 :           elt1 = error_mark_node;</span>
<span class="lineNum">    3574 </span><span class="lineCov">          9 :           any_changes = true;</span>
<span class="lineNum">    3575 </span>            :         }
<span class="lineNum">    3576 </span>            :     }
<span class="lineNum">    3577 </span>            : 
<span class="lineNum">    3578 </span><span class="lineCov">       3483 :   if (any_changes)</span>
<span class="lineNum">    3579 </span>            :     {
<span class="lineNum">    3580 </span>            :       operand_entry *oe;
<span class="lineNum">    3581 </span>            :       j = 0;
<span class="lineNum">    3582 </span><span class="lineCov">         27 :       FOR_EACH_VEC_ELT (*ops, i, oe)</span>
<span class="lineNum">    3583 </span>            :         {
<span class="lineNum">    3584 </span><span class="lineCov">         18 :           if (oe-&gt;op == error_mark_node)</span>
<span class="lineNum">    3585 </span>            :             continue;
<span class="lineNum">    3586 </span><span class="lineCov">          9 :           else if (i != j)</span>
<span class="lineNum">    3587 </span><span class="lineNoCov">          0 :             (*ops)[j] = oe;</span>
<span class="lineNum">    3588 </span><span class="lineCov">          9 :           j++;</span>
<span class="lineNum">    3589 </span>            :         }
<span class="lineNum">    3590 </span><span class="lineCov">          9 :       ops-&gt;truncate (j);</span>
<span class="lineNum">    3591 </span>            :     }
<span class="lineNum">    3592 </span>            : 
<span class="lineNum">    3593 </span>            :   return any_changes;
<span class="lineNum">    3594 </span>            : }
<span class="lineNum">    3595 </span>            : 
<span class="lineNum">    3596 </span>            : /* Return true if STMT is a cast like:
<span class="lineNum">    3597 </span>            :    &lt;bb N&gt;:
<span class="lineNum">    3598 </span>            :    ...
<span class="lineNum">    3599 </span>            :    _123 = (int) _234;
<span class="lineNum">    3600 </span>            : 
<span class="lineNum">    3601 </span>            :    &lt;bb M&gt;:
<span class="lineNum">    3602 </span>            :    # _345 = PHI &lt;_123(N), 1(...), 1(...)&gt;
<span class="lineNum">    3603 </span>            :    where _234 has bool type, _123 has single use and
<span class="lineNum">    3604 </span>            :    bb N has a single successor M.  This is commonly used in
<span class="lineNum">    3605 </span>            :    the last block of a range test.
<span class="lineNum">    3606 </span>            : 
<span class="lineNum">    3607 </span>            :    Also Return true if STMT is tcc_compare like:
<span class="lineNum">    3608 </span>            :    &lt;bb N&gt;:
<span class="lineNum">    3609 </span>            :    ...
<span class="lineNum">    3610 </span>            :    _234 = a_2(D) == 2;
<span class="lineNum">    3611 </span>            : 
<span class="lineNum">    3612 </span>            :    &lt;bb M&gt;:
<span class="lineNum">    3613 </span>            :    # _345 = PHI &lt;_234(N), 1(...), 1(...)&gt;
<span class="lineNum">    3614 </span>            :    _346 = (int) _345;
<span class="lineNum">    3615 </span>            :    where _234 has booltype, single use and
<span class="lineNum">    3616 </span>            :    bb N has a single successor M.  This is commonly used in
<span class="lineNum">    3617 </span>            :    the last block of a range test.  */
<span class="lineNum">    3618 </span>            : 
<span class="lineNum">    3619 </span>            : static bool
<span class="lineNum">    3620 </span><span class="lineCov">    9254483 : final_range_test_p (gimple *stmt)</span>
<span class="lineNum">    3621 </span>            : {
<span class="lineNum">    3622 </span><span class="lineCov">    9254483 :   basic_block bb, rhs_bb, lhs_bb;</span>
<span class="lineNum">    3623 </span><span class="lineCov">    9254483 :   edge e;</span>
<span class="lineNum">    3624 </span><span class="lineCov">    9254483 :   tree lhs, rhs;</span>
<span class="lineNum">    3625 </span><span class="lineCov">    9254483 :   use_operand_p use_p;</span>
<span class="lineNum">    3626 </span><span class="lineCov">    9254483 :   gimple *use_stmt;</span>
<span class="lineNum">    3627 </span>            : 
<span class="lineNum">    3628 </span><span class="lineCov">    9254483 :   if (!gimple_assign_cast_p (stmt)</span>
<span class="lineNum">    3629 </span><span class="lineCov">    9254483 :       &amp;&amp; (!is_gimple_assign (stmt)</span>
<span class="lineNum">    3630 </span><span class="lineCov">    2605573 :           || (TREE_CODE_CLASS (gimple_assign_rhs_code (stmt))</span>
<span class="lineNum">    3631 </span>            :               != tcc_comparison)))
<span class="lineNum">    3632 </span>            :     return false;
<span class="lineNum">    3633 </span><span class="lineCov">     370880 :   bb = gimple_bb (stmt);</span>
<span class="lineNum">    3634 </span><span class="lineCov">     370880 :   if (!single_succ_p (bb))</span>
<span class="lineNum">    3635 </span>            :     return false;
<span class="lineNum">    3636 </span><span class="lineCov">     370186 :   e = single_succ_edge (bb);</span>
<span class="lineNum">    3637 </span><span class="lineCov">     370186 :   if (e-&gt;flags &amp; EDGE_COMPLEX)</span>
<span class="lineNum">    3638 </span>            :     return false;
<span class="lineNum">    3639 </span>            : 
<span class="lineNum">    3640 </span><span class="lineCov">     370186 :   lhs = gimple_assign_lhs (stmt);</span>
<span class="lineNum">    3641 </span><span class="lineCov">     370186 :   rhs = gimple_assign_rhs1 (stmt);</span>
<span class="lineNum">    3642 </span><span class="lineCov">     370186 :   if (gimple_assign_cast_p (stmt)</span>
<span class="lineNum">    3643 </span><span class="lineCov">     370186 :       &amp;&amp; (!INTEGRAL_TYPE_P (TREE_TYPE (lhs))</span>
<span class="lineNum">    3644 </span><span class="lineCov">     286363 :           || TREE_CODE (rhs) != SSA_NAME</span>
<span class="lineNum">    3645 </span><span class="lineCov">     279804 :           || TREE_CODE (TREE_TYPE (rhs)) != BOOLEAN_TYPE))</span>
<span class="lineNum">    3646 </span>            :     return false;
<span class="lineNum">    3647 </span>            : 
<span class="lineNum">    3648 </span><span class="lineCov">     151481 :   if (!gimple_assign_cast_p (stmt)</span>
<span class="lineNum">    3649 </span><span class="lineCov">     151481 :       &amp;&amp; (TREE_CODE (TREE_TYPE (lhs)) != BOOLEAN_TYPE))</span>
<span class="lineNum">    3650 </span>            :       return false;
<span class="lineNum">    3651 </span>            : 
<span class="lineNum">    3652 </span>            :   /* Test whether lhs is consumed only by a PHI in the only successor bb.  */
<span class="lineNum">    3653 </span><span class="lineCov">     151481 :   if (!single_imm_use (lhs, &amp;use_p, &amp;use_stmt))</span>
<span class="lineNum">    3654 </span>            :     return false;
<span class="lineNum">    3655 </span>            : 
<span class="lineNum">    3656 </span><span class="lineCov">     148667 :   if (gimple_code (use_stmt) != GIMPLE_PHI</span>
<span class="lineNum">    3657 </span><span class="lineCov">     148667 :       || gimple_bb (use_stmt) != e-&gt;dest)</span>
<span class="lineNum">    3658 </span>            :     return false;
<span class="lineNum">    3659 </span>            : 
<span class="lineNum">    3660 </span>            :   /* And that the rhs is defined in the same loop.  */
<span class="lineNum">    3661 </span><span class="lineCov">     148217 :   if (gimple_assign_cast_p (stmt))</span>
<span class="lineNum">    3662 </span>            :     {
<span class="lineNum">    3663 </span><span class="lineCov">      80706 :       if (TREE_CODE (rhs) != SSA_NAME</span>
<span class="lineNum">    3664 </span><span class="lineCov">     242118 :           || !(rhs_bb = gimple_bb (SSA_NAME_DEF_STMT (rhs)))</span>
<span class="lineNum">    3665 </span><span class="lineCov">     242102 :           || !flow_bb_inside_loop_p (loop_containing_stmt (stmt), rhs_bb))</span>
<span class="lineNum">    3666 </span><span class="lineCov">         72 :         return false;</span>
<span class="lineNum">    3667 </span>            :     }
<span class="lineNum">    3668 </span>            :   else
<span class="lineNum">    3669 </span>            :     {
<span class="lineNum">    3670 </span><span class="lineCov">      67511 :       if (TREE_CODE (lhs) != SSA_NAME</span>
<span class="lineNum">    3671 </span><span class="lineCov">     202533 :           || !(lhs_bb = gimple_bb (SSA_NAME_DEF_STMT (lhs)))</span>
<span class="lineNum">    3672 </span><span class="lineCov">     202533 :           || !flow_bb_inside_loop_p (loop_containing_stmt (stmt), lhs_bb))</span>
<span class="lineNum">    3673 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">    3674 </span>            :     }
<span class="lineNum">    3675 </span>            : 
<span class="lineNum">    3676 </span>            :   return true;
<span class="lineNum">    3677 </span>            : }
<span class="lineNum">    3678 </span>            : 
<span class="lineNum">    3679 </span>            : /* Return true if BB is suitable basic block for inter-bb range test
<span class="lineNum">    3680 </span>            :    optimization.  If BACKWARD is true, BB should be the only predecessor
<span class="lineNum">    3681 </span>            :    of TEST_BB, and *OTHER_BB is either NULL and filled by the routine,
<span class="lineNum">    3682 </span>            :    or compared with to find a common basic block to which all conditions
<span class="lineNum">    3683 </span>            :    branch to if true resp. false.  If BACKWARD is false, TEST_BB should
<span class="lineNum">    3684 </span>            :    be the only predecessor of BB.  */
<span class="lineNum">    3685 </span>            : 
<span class="lineNum">    3686 </span>            : static bool
<span class="lineNum">    3687 </span><span class="lineCov">    5875863 : suitable_cond_bb (basic_block bb, basic_block test_bb, basic_block *other_bb,</span>
<span class="lineNum">    3688 </span>            :                   bool backward)
<span class="lineNum">    3689 </span>            : {
<span class="lineNum">    3690 </span><span class="lineCov">    5875863 :   edge_iterator ei, ei2;</span>
<span class="lineNum">    3691 </span><span class="lineCov">    5875863 :   edge e, e2;</span>
<span class="lineNum">    3692 </span><span class="lineCov">    5875863 :   gimple *stmt;</span>
<span class="lineNum">    3693 </span><span class="lineCov">    5875863 :   gphi_iterator gsi;</span>
<span class="lineNum">    3694 </span><span class="lineCov">    5875863 :   bool other_edge_seen = false;</span>
<span class="lineNum">    3695 </span><span class="lineCov">    5875863 :   bool is_cond;</span>
<span class="lineNum">    3696 </span>            : 
<span class="lineNum">    3697 </span><span class="lineCov">    5875863 :   if (test_bb == bb)</span>
<span class="lineNum">    3698 </span>            :     return false;
<span class="lineNum">    3699 </span>            :   /* Check last stmt first.  */
<span class="lineNum">    3700 </span><span class="lineCov">    5875863 :   stmt = last_stmt (bb);</span>
<span class="lineNum">    3701 </span><span class="lineCov">    5875863 :   if (stmt == NULL</span>
<span class="lineNum">    3702 </span><span class="lineCov">   10666716 :       || (gimple_code (stmt) != GIMPLE_COND</span>
<span class="lineNum">    3703 </span><span class="lineCov">     376619 :           &amp;&amp; (backward || !final_range_test_p (stmt)))</span>
<span class="lineNum">    3704 </span><span class="lineCov">    9946292 :       || gimple_visited_p (stmt)</span>
<span class="lineNum">    3705 </span><span class="lineCov">    4958940 :       || stmt_could_throw_p (stmt)</span>
<span class="lineNum">    3706 </span><span class="lineCov">   10834739 :       || *other_bb == bb)</span>
<span class="lineNum">    3707 </span><span class="lineCov">     917011 :     return false;</span>
<span class="lineNum">    3708 </span><span class="lineCov">    4958852 :   is_cond = gimple_code (stmt) == GIMPLE_COND;</span>
<span class="lineNum">    3709 </span><span class="lineCov">    4958852 :   if (is_cond)</span>
<span class="lineNum">    3710 </span>            :     {
<span class="lineNum">    3711 </span>            :       /* If last stmt is GIMPLE_COND, verify that one of the succ edges
<span class="lineNum">    3712 </span>            :          goes to the next bb (if BACKWARD, it is TEST_BB), and the other
<span class="lineNum">    3713 </span>            :          to *OTHER_BB (if not set yet, try to find it out).  */
<span class="lineNum">    3714 </span><span class="lineCov">    4942509 :       if (EDGE_COUNT (bb-&gt;succs) != 2)</span>
<span class="lineNum">    3715 </span>            :         return false;
<span class="lineNum">    3716 </span><span class="lineCov">   14923709 :       FOR_EACH_EDGE (e, ei, bb-&gt;succs)</span>
<span class="lineNum">    3717 </span>            :         {
<span class="lineNum">    3718 </span><span class="lineCov">    8011513 :           if (!(e-&gt;flags &amp; (EDGE_TRUE_VALUE | EDGE_FALSE_VALUE)))</span>
<span class="lineNum">    3719 </span>            :             return false;
<span class="lineNum">    3720 </span><span class="lineCov">    8011513 :           if (e-&gt;dest == test_bb)</span>
<span class="lineNum">    3721 </span>            :             {
<span class="lineNum">    3722 </span><span class="lineCov">    2676277 :               if (backward)</span>
<span class="lineNum">    3723 </span>            :                 continue;
<span class="lineNum">    3724 </span>            :               else
<span class="lineNum">    3725 </span>            :                 return false;
<span class="lineNum">    3726 </span>            :             }
<span class="lineNum">    3727 </span><span class="lineCov">    5335236 :           if (e-&gt;dest == bb)</span>
<span class="lineNum">    3728 </span>            :             return false;
<span class="lineNum">    3729 </span><span class="lineCov">    5260945 :           if (*other_bb == NULL)</span>
<span class="lineNum">    3730 </span>            :             {
<span class="lineNum">    3731 </span><span class="lineCov">   17349888 :               FOR_EACH_EDGE (e2, ei2, test_bb-&gt;succs)</span>
<span class="lineNum">    3732 </span><span class="lineCov">    8674944 :                 if (!(e2-&gt;flags &amp; (EDGE_TRUE_VALUE | EDGE_FALSE_VALUE)))</span>
<span class="lineNum">    3733 </span>            :                   return false;
<span class="lineNum">    3734 </span><span class="lineCov">    8674944 :                 else if (e-&gt;dest == e2-&gt;dest)</span>
<span class="lineNum">    3735 </span><span class="lineCov">    1521759 :                   *other_bb = e-&gt;dest;</span>
<span class="lineNum">    3736 </span><span class="lineCov">    4337472 :               if (*other_bb == NULL)</span>
<span class="lineNum">    3737 </span>            :                 return false;
<span class="lineNum">    3738 </span>            :             }
<span class="lineNum">    3739 </span><span class="lineCov">    2445232 :           if (e-&gt;dest == *other_bb)</span>
<span class="lineNum">    3740 </span>            :             other_edge_seen = true;
<span class="lineNum">    3741 </span><span class="lineCov">     492978 :           else if (backward)</span>
<span class="lineNum">    3742 </span>            :             return false;
<span class="lineNum">    3743 </span>            :         }
<span class="lineNum">    3744 </span><span class="lineCov">    1969687 :       if (*other_bb == NULL || !other_edge_seen)</span>
<span class="lineNum">    3745 </span>            :         return false;
<span class="lineNum">    3746 </span>            :     }
<span class="lineNum">    3747 </span><span class="lineCov">      16343 :   else if (single_succ (bb) != *other_bb)</span>
<span class="lineNum">    3748 </span>            :     return false;
<span class="lineNum">    3749 </span>            : 
<span class="lineNum">    3750 </span>            :   /* Now check all PHIs of *OTHER_BB.  */
<span class="lineNum">    3751 </span><span class="lineCov">    1967934 :   e = find_edge (bb, *other_bb);</span>
<span class="lineNum">    3752 </span><span class="lineCov">    1967934 :   e2 = find_edge (test_bb, *other_bb);</span>
<span class="lineNum">    3753 </span><span class="lineCov">    2650322 :   for (gsi = gsi_start_phis (e-&gt;dest); !gsi_end_p (gsi); gsi_next (&amp;gsi))</span>
<span class="lineNum">    3754 </span>            :     {
<span class="lineNum">    3755 </span><span class="lineCov">    1373789 :       gphi *phi = gsi.phi ();</span>
<span class="lineNum">    3756 </span>            :       /* If both BB and TEST_BB end with GIMPLE_COND, all PHI arguments
<span class="lineNum">    3757 </span>            :          corresponding to BB and TEST_BB predecessor must be the same.  */
<span class="lineNum">    3758 </span><span class="lineCov">    1373789 :       if (!operand_equal_p (gimple_phi_arg_def (phi, e-&gt;dest_idx),</span>
<span class="lineNum">    3759 </span><span class="lineCov">    1373789 :                             gimple_phi_arg_def (phi, e2-&gt;dest_idx), 0))</span>
<span class="lineNum">    3760 </span>            :         {
<span class="lineNum">    3761 </span>            :           /* Otherwise, if one of the blocks doesn't end with GIMPLE_COND,
<span class="lineNum">    3762 </span>            :              one of the PHIs should have the lhs of the last stmt in
<span class="lineNum">    3763 </span>            :              that block as PHI arg and that PHI should have 0 or 1
<span class="lineNum">    3764 </span>            :              corresponding to it in all other range test basic blocks
<span class="lineNum">    3765 </span>            :              considered.  */
<span class="lineNum">    3766 </span><span class="lineCov">     722819 :           if (!is_cond)</span>
<span class="lineNum">    3767 </span>            :             {
<span class="lineNum">    3768 </span><span class="lineCov">      17661 :               if (gimple_phi_arg_def (phi, e-&gt;dest_idx)</span>
<span class="lineNum">    3769 </span><span class="lineCov">      17661 :                   == gimple_assign_lhs (stmt)</span>
<span class="lineNum">    3770 </span><span class="lineCov">      17661 :                   &amp;&amp; (integer_zerop (gimple_phi_arg_def (phi, e2-&gt;dest_idx))</span>
<span class="lineNum">    3771 </span><span class="lineCov">       7221 :                       || integer_onep (gimple_phi_arg_def (phi,</span>
<span class="lineNum">    3772 </span><span class="lineCov">       7221 :                                                            e2-&gt;dest_idx))))</span>
<span class="lineNum">    3773 </span><span class="lineCov">      13775 :                 continue;</span>
<span class="lineNum">    3774 </span>            :             }
<span class="lineNum">    3775 </span>            :           else
<span class="lineNum">    3776 </span>            :             {
<span class="lineNum">    3777 </span><span class="lineCov">     705158 :               gimple *test_last = last_stmt (test_bb);</span>
<span class="lineNum">    3778 </span><span class="lineCov">     705158 :               if (gimple_code (test_last) != GIMPLE_COND</span>
<span class="lineNum">    3779 </span><span class="lineCov">      21527 :                   &amp;&amp; gimple_phi_arg_def (phi, e2-&gt;dest_idx)</span>
<span class="lineNum">    3780 </span><span class="lineCov">      21527 :                      == gimple_assign_lhs (test_last)</span>
<span class="lineNum">    3781 </span><span class="lineCov">     725059 :                   &amp;&amp; (integer_zerop (gimple_phi_arg_def (phi, e-&gt;dest_idx))</span>
<span class="lineNum">    3782 </span><span class="lineCov">       9840 :                       || integer_onep (gimple_phi_arg_def (phi, e-&gt;dest_idx))))</span>
<span class="lineNum">    3783 </span><span class="lineCov">      17643 :                 continue;</span>
<span class="lineNum">    3784 </span>            :             }
<span class="lineNum">    3785 </span>            : 
<span class="lineNum">    3786 </span><span class="lineCov">     691401 :           return false;</span>
<span class="lineNum">    3787 </span>            :         }
<span class="lineNum">    3788 </span>            :     }
<span class="lineNum">    3789 </span>            :   return true;
<span class="lineNum">    3790 </span>            : }
<span class="lineNum">    3791 </span>            : 
<span class="lineNum">    3792 </span>            : /* Return true if BB doesn't have side-effects that would disallow
<span class="lineNum">    3793 </span>            :    range test optimization, all SSA_NAMEs set in the bb are consumed
<span class="lineNum">    3794 </span>            :    in the bb and there are no PHIs.  */
<a name="3795"><span class="lineNum">    3795 </span>            : </a>
<span class="lineNum">    3796 </span>            : static bool
<span class="lineNum">    3797 </span><span class="lineCov">     903351 : no_side_effect_bb (basic_block bb)</span>
<span class="lineNum">    3798 </span>            : {
<span class="lineNum">    3799 </span><span class="lineCov">     903351 :   gimple_stmt_iterator gsi;</span>
<span class="lineNum">    3800 </span><span class="lineCov">     903351 :   gimple *last;</span>
<span class="lineNum">    3801 </span>            : 
<span class="lineNum">    3802 </span><span class="lineCov">     903351 :   if (!gimple_seq_empty_p (phi_nodes (bb)))</span>
<span class="lineNum">    3803 </span>            :     return false;
<span class="lineNum">    3804 </span><span class="lineCov">     901551 :   last = last_stmt (bb);</span>
<span class="lineNum">    3805 </span><span class="lineCov">    3114377 :   for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&amp;gsi))</span>
<span class="lineNum">    3806 </span>            :     {
<span class="lineNum">    3807 </span><span class="lineCov">    2212826 :       gimple *stmt = gsi_stmt (gsi);</span>
<span class="lineNum">    3808 </span><span class="lineCov">    2212826 :       tree lhs;</span>
<span class="lineNum">    3809 </span><span class="lineCov">    2212826 :       imm_use_iterator imm_iter;</span>
<span class="lineNum">    3810 </span><span class="lineCov">    2212826 :       use_operand_p use_p;</span>
<span class="lineNum">    3811 </span>            : 
<span class="lineNum">    3812 </span><span class="lineCov">    4425652 :       if (is_gimple_debug (stmt))</span>
<span class="lineNum">    3813 </span><span class="lineCov">     950785 :         continue;</span>
<span class="lineNum">    3814 </span><span class="lineCov">    1262041 :       if (gimple_has_side_effects (stmt))</span>
<span class="lineNum">    3815 </span><span class="lineCov">     901551 :         return false;</span>
<span class="lineNum">    3816 </span><span class="lineCov">     900659 :       if (stmt == last)</span>
<span class="lineNum">    3817 </span>            :         return true;
<span class="lineNum">    3818 </span><span class="lineCov">    1537910 :       if (!is_gimple_assign (stmt))</span>
<span class="lineNum">    3819 </span>            :         return false;
<span class="lineNum">    3820 </span><span class="lineCov">     677524 :       lhs = gimple_assign_lhs (stmt);</span>
<span class="lineNum">    3821 </span><span class="lineCov">     677524 :       if (TREE_CODE (lhs) != SSA_NAME)</span>
<span class="lineNum">    3822 </span>            :         return false;
<span class="lineNum">    3823 </span><span class="lineCov">     677524 :       if (gimple_assign_rhs_could_trap_p (stmt))</span>
<span class="lineNum">    3824 </span>            :         return false;
<span class="lineNum">    3825 </span><span class="lineCov">     862646 :       FOR_EACH_IMM_USE_FAST (use_p, imm_iter, lhs)</span>
<span class="lineNum">    3826 </span>            :         {
<span class="lineNum">    3827 </span><span class="lineCov">     502156 :           gimple *use_stmt = USE_STMT (use_p);</span>
<span class="lineNum">    3828 </span><span class="lineCov">    1004312 :           if (is_gimple_debug (use_stmt))</span>
<span class="lineNum">    3829 </span>            :             continue;
<span class="lineNum">    3830 </span><span class="lineCov">     933410 :           if (gimple_bb (use_stmt) != bb)</span>
<span class="lineNum">    3831 </span>            :             return false;
<span class="lineNum">    3832 </span>            :         }
<span class="lineNum">    3833 </span>            :     }
<span class="lineNum">    3834 </span>            :   return false;
<span class="lineNum">    3835 </span>            : }
<span class="lineNum">    3836 </span>            : 
<span class="lineNum">    3837 </span>            : /* If VAR is set by CODE (BIT_{AND,IOR}_EXPR) which is reassociable,
<span class="lineNum">    3838 </span>            :    return true and fill in *OPS recursively.  */
<a name="3839"><span class="lineNum">    3839 </span>            : </a>
<span class="lineNum">    3840 </span>            : static bool
<span class="lineNum">    3841 </span><span class="lineCov">      69994 : get_ops (tree var, enum tree_code code, vec&lt;operand_entry *&gt; *ops,</span>
<span class="lineNum">    3842 </span>            :          struct loop *loop)
<span class="lineNum">    3843 </span>            : {
<span class="lineNum">    3844 </span><span class="lineCov">      69994 :   gimple *stmt = SSA_NAME_DEF_STMT (var);</span>
<span class="lineNum">    3845 </span><span class="lineCov">      69994 :   tree rhs[2];</span>
<span class="lineNum">    3846 </span><span class="lineCov">      69994 :   int i;</span>
<span class="lineNum">    3847 </span>            : 
<span class="lineNum">    3848 </span><span class="lineCov">      69994 :   if (!is_reassociable_op (stmt, code, loop))</span>
<span class="lineNum">    3849 </span>            :     return false;
<span class="lineNum">    3850 </span>            : 
<span class="lineNum">    3851 </span><span class="lineCov">      10757 :   rhs[0] = gimple_assign_rhs1 (stmt);</span>
<span class="lineNum">    3852 </span><span class="lineCov">      10757 :   rhs[1] = gimple_assign_rhs2 (stmt);</span>
<span class="lineNum">    3853 </span><span class="lineCov">      10757 :   gimple_set_visited (stmt, true);</span>
<span class="lineNum">    3854 </span><span class="lineCov">      32271 :   for (i = 0; i &lt; 2; i++)</span>
<span class="lineNum">    3855 </span><span class="lineCov">      21514 :     if (TREE_CODE (rhs[i]) == SSA_NAME</span>
<span class="lineNum">    3856 </span><span class="lineCov">      21514 :         &amp;&amp; !get_ops (rhs[i], code, ops, loop)</span>
<span class="lineNum">    3857 </span><span class="lineCov">      42630 :         &amp;&amp; has_single_use (rhs[i]))</span>
<span class="lineNum">    3858 </span>            :       {
<span class="lineNum">    3859 </span><span class="lineCov">      20750 :         operand_entry *oe = operand_entry_pool.allocate ();</span>
<span class="lineNum">    3860 </span>            : 
<span class="lineNum">    3861 </span><span class="lineCov">      20750 :         oe-&gt;op = rhs[i];</span>
<span class="lineNum">    3862 </span><span class="lineCov">      20750 :         oe-&gt;rank = code;</span>
<span class="lineNum">    3863 </span><span class="lineCov">      20750 :         oe-&gt;id = 0;</span>
<span class="lineNum">    3864 </span><span class="lineCov">      20750 :         oe-&gt;count = 1;</span>
<span class="lineNum">    3865 </span><span class="lineCov">      20750 :         oe-&gt;stmt_to_insert = NULL;</span>
<span class="lineNum">    3866 </span><span class="lineCov">      20750 :         ops-&gt;safe_push (oe);</span>
<span class="lineNum">    3867 </span>            :       }
<span class="lineNum">    3868 </span>            :   return true;
<span class="lineNum">    3869 </span>            : }
<span class="lineNum">    3870 </span>            : 
<span class="lineNum">    3871 </span>            : /* Find the ops that were added by get_ops starting from VAR, see if
<span class="lineNum">    3872 </span>            :    they were changed during update_range_test and if yes, create new
<span class="lineNum">    3873 </span>            :    stmts.  */
<span class="lineNum">    3874 </span>            : 
<span class="lineNum">    3875 </span>            : static tree
<span class="lineNum">    3876 </span><span class="lineCov">      11416 : update_ops (tree var, enum tree_code code, vec&lt;operand_entry *&gt; ops,</span>
<span class="lineNum">    3877 </span>            :             unsigned int *pidx, struct loop *loop)
<span class="lineNum">    3878 </span>            : {
<span class="lineNum">    3879 </span><span class="lineCov">      11416 :   gimple *stmt = SSA_NAME_DEF_STMT (var);</span>
<span class="lineNum">    3880 </span><span class="lineCov">      11416 :   tree rhs[4];</span>
<span class="lineNum">    3881 </span><span class="lineCov">      11416 :   int i;</span>
<span class="lineNum">    3882 </span>            : 
<span class="lineNum">    3883 </span><span class="lineCov">      11416 :   if (!is_reassociable_op (stmt, code, loop))</span>
<span class="lineNum">    3884 </span>            :     return NULL;
<span class="lineNum">    3885 </span>            : 
<span class="lineNum">    3886 </span><span class="lineCov">       3713 :   rhs[0] = gimple_assign_rhs1 (stmt);</span>
<span class="lineNum">    3887 </span><span class="lineCov">       3713 :   rhs[1] = gimple_assign_rhs2 (stmt);</span>
<span class="lineNum">    3888 </span><span class="lineCov">       3713 :   rhs[2] = rhs[0];</span>
<span class="lineNum">    3889 </span><span class="lineCov">       3713 :   rhs[3] = rhs[1];</span>
<span class="lineNum">    3890 </span><span class="lineCov">      11139 :   for (i = 0; i &lt; 2; i++)</span>
<span class="lineNum">    3891 </span><span class="lineCov">       7426 :     if (TREE_CODE (rhs[i]) == SSA_NAME)</span>
<span class="lineNum">    3892 </span>            :       {
<span class="lineNum">    3893 </span><span class="lineCov">       7426 :         rhs[2 + i] = update_ops (rhs[i], code, ops, pidx, loop);</span>
<span class="lineNum">    3894 </span><span class="lineCov">       7426 :         if (rhs[2 + i] == NULL_TREE)</span>
<span class="lineNum">    3895 </span>            :           {
<span class="lineNum">    3896 </span><span class="lineCov">       7308 :             if (has_single_use (rhs[i]))</span>
<span class="lineNum">    3897 </span><span class="lineCov">       7308 :               rhs[2 + i] = ops[(*pidx)++]-&gt;op;</span>
<span class="lineNum">    3898 </span>            :             else
<span class="lineNum">    3899 </span><span class="lineNoCov">          0 :               rhs[2 + i] = rhs[i];</span>
<span class="lineNum">    3900 </span>            :           }
<span class="lineNum">    3901 </span>            :       }
<span class="lineNum">    3902 </span><span class="lineCov">       3713 :   if ((rhs[2] != rhs[0] || rhs[3] != rhs[1])</span>
<span class="lineNum">    3903 </span><span class="lineCov">       3517 :       &amp;&amp; (rhs[2] != rhs[1] || rhs[3] != rhs[0]))</span>
<span class="lineNum">    3904 </span>            :     {
<span class="lineNum">    3905 </span><span class="lineCov">       3517 :       gimple_stmt_iterator gsi = gsi_for_stmt (stmt);</span>
<span class="lineNum">    3906 </span><span class="lineCov">       3517 :       var = make_ssa_name (TREE_TYPE (var));</span>
<span class="lineNum">    3907 </span><span class="lineCov">       3517 :       gassign *g = gimple_build_assign (var, gimple_assign_rhs_code (stmt),</span>
<span class="lineNum">    3908 </span>            :                                         rhs[2], rhs[3]);
<span class="lineNum">    3909 </span><span class="lineCov">       7034 :       gimple_set_uid (g, gimple_uid (stmt));</span>
<span class="lineNum">    3910 </span><span class="lineCov">       3517 :       gimple_set_visited (g, true);</span>
<span class="lineNum">    3911 </span><span class="lineCov">       3517 :       gsi_insert_before (&amp;gsi, g, GSI_SAME_STMT);</span>
<span class="lineNum">    3912 </span>            :     }
<span class="lineNum">    3913 </span>            :   return var;
<span class="lineNum">    3914 </span>            : }
<span class="lineNum">    3915 </span>            : 
<span class="lineNum">    3916 </span>            : /* Structure to track the initial value passed to get_ops and
<span class="lineNum">    3917 </span>            :    the range in the ops vector for each basic block.  */
<span class="lineNum">    3918 </span>            : 
<span class="lineNum">    3919 </span>            : struct inter_bb_range_test_entry
<span class="lineNum">    3920 </span>            : {
<span class="lineNum">    3921 </span>            :   tree op;
<span class="lineNum">    3922 </span>            :   unsigned int first_idx, last_idx;
<span class="lineNum">    3923 </span>            : };
<span class="lineNum">    3924 </span>            : 
<span class="lineNum">    3925 </span>            : /* Inter-bb range test optimization.
<span class="lineNum">    3926 </span>            : 
<span class="lineNum">    3927 </span>            :    Returns TRUE if a gimple conditional is optimized to a true/false,
<span class="lineNum">    3928 </span>            :    otherwise return FALSE.
<span class="lineNum">    3929 </span>            : 
<span class="lineNum">    3930 </span>            :    This indicates to the caller that it should run a CFG cleanup pass
<span class="lineNum">    3931 </span>            :    once reassociation is completed.  */
<span class="lineNum">    3932 </span>            : 
<span class="lineNum">    3933 </span>            : static bool
<span class="lineNum">    3934 </span><span class="lineCov">   10855556 : maybe_optimize_range_tests (gimple *stmt)</span>
<span class="lineNum">    3935 </span>            : {
<span class="lineNum">    3936 </span><span class="lineCov">   10855556 :   basic_block first_bb = gimple_bb (stmt);</span>
<span class="lineNum">    3937 </span><span class="lineCov">   10855556 :   basic_block last_bb = first_bb;</span>
<span class="lineNum">    3938 </span><span class="lineCov">   10855556 :   basic_block other_bb = NULL;</span>
<span class="lineNum">    3939 </span><span class="lineCov">   10855556 :   basic_block bb;</span>
<span class="lineNum">    3940 </span><span class="lineCov">   10855556 :   edge_iterator ei;</span>
<span class="lineNum">    3941 </span><span class="lineCov">   10855556 :   edge e;</span>
<span class="lineNum">    3942 </span><span class="lineCov">   10855556 :   auto_vec&lt;operand_entry *&gt; ops;</span>
<span class="lineNum">    3943 </span><span class="lineCov">   21816592 :   auto_vec&lt;inter_bb_range_test_entry&gt; bbinfo;</span>
<span class="lineNum">    3944 </span><span class="lineCov">   10855556 :   bool any_changes = false;</span>
<span class="lineNum">    3945 </span><span class="lineCov">   10855556 :   bool cfg_cleanup_needed = false;</span>
<span class="lineNum">    3946 </span>            : 
<span class="lineNum">    3947 </span>            :   /* Consider only basic blocks that end with GIMPLE_COND or
<span class="lineNum">    3948 </span>            :      a cast statement satisfying final_range_test_p.  All
<span class="lineNum">    3949 </span>            :      but the last bb in the first_bb .. last_bb range
<span class="lineNum">    3950 </span>            :      should end with GIMPLE_COND.  */
<span class="lineNum">    3951 </span><span class="lineCov">   21711112 :   if (gimple_code (stmt) == GIMPLE_COND)</span>
<span class="lineNum">    3952 </span>            :     {
<span class="lineNum">    3953 </span><span class="lineCov">    4574010 :       if (EDGE_COUNT (first_bb-&gt;succs) != 2)</span>
<span class="lineNum">    3954 </span>            :         return cfg_cleanup_needed;
<span class="lineNum">    3955 </span>            :     }
<span class="lineNum">    3956 </span><span class="lineCov">    6281546 :   else if (final_range_test_p (stmt))</span>
<span class="lineNum">    3957 </span><span class="lineCov">      70400 :     other_bb = single_succ (first_bb);</span>
<span class="lineNum">    3958 </span>            :   else
<span class="lineNum">    3959 </span>            :     return cfg_cleanup_needed;
<span class="lineNum">    3960 </span>            : 
<span class="lineNum">    3961 </span><span class="lineCov">    4644410 :   if (stmt_could_throw_p (stmt))</span>
<span class="lineNum">    3962 </span>            :     return cfg_cleanup_needed;
<span class="lineNum">    3963 </span>            : 
<span class="lineNum">    3964 </span>            :   /* As relative ordering of post-dominator sons isn't fixed,
<span class="lineNum">    3965 </span>            :      maybe_optimize_range_tests can be called first on any
<span class="lineNum">    3966 </span>            :      bb in the range we want to optimize.  So, start searching
<span class="lineNum">    3967 </span>            :      backwards, if first_bb can be set to a predecessor.  */
<span class="lineNum">    3968 </span><span class="lineCov">    4773142 :   while (single_pred_p (first_bb))</span>
<span class="lineNum">    3969 </span>            :     {
<span class="lineNum">    3970 </span><span class="lineCov">    3274179 :       basic_block pred_bb = single_pred (first_bb);</span>
<span class="lineNum">    3971 </span><span class="lineCov">    3274179 :       if (!suitable_cond_bb (pred_bb, first_bb, &amp;other_bb, true))</span>
<span class="lineNum">    3972 </span>            :         break;
<span class="lineNum">    3973 </span><span class="lineCov">     517942 :       if (!no_side_effect_bb (first_bb))</span>
<span class="lineNum">    3974 </span>            :         break;
<span class="lineNum">    3975 </span>            :       first_bb = pred_bb;
<span class="lineNum">    3976 </span>            :     }
<span class="lineNum">    3977 </span>            :   /* If first_bb is last_bb, other_bb hasn't been computed yet.
<span class="lineNum">    3978 </span>            :      Before starting forward search in last_bb successors, find
<span class="lineNum">    3979 </span>            :      out the other_bb.  */
<span class="lineNum">    3980 </span><span class="lineCov">    4644316 :   if (first_bb == last_bb)</span>
<span class="lineNum">    3981 </span>            :     {
<span class="lineNum">    3982 </span><span class="lineCov">    4540335 :       other_bb = NULL;</span>
<span class="lineNum">    3983 </span>            :       /* As non-GIMPLE_COND last stmt always terminates the range,
<span class="lineNum">    3984 </span>            :          if forward search didn't discover anything, just give up.  */
<span class="lineNum">    3985 </span><span class="lineCov">    9080670 :       if (gimple_code (stmt) != GIMPLE_COND)</span>
<span class="lineNum">    3986 </span>            :         return cfg_cleanup_needed;
<span class="lineNum">    3987 </span>            :       /* Look at both successors.  Either it ends with a GIMPLE_COND
<span class="lineNum">    3988 </span>            :          and satisfies suitable_cond_bb, or ends with a cast and
<span class="lineNum">    3989 </span>            :          other_bb is that cast's successor.  */
<span class="lineNum">    3990 </span><span class="lineCov">   17138884 :       FOR_EACH_EDGE (e, ei, first_bb-&gt;succs)</span>
<span class="lineNum">    3991 </span><span class="lineCov">    8769885 :         if (!(e-&gt;flags &amp; (EDGE_TRUE_VALUE | EDGE_FALSE_VALUE))</span>
<span class="lineNum">    3992 </span><span class="lineCov">    8769885 :             || e-&gt;dest == first_bb)</span>
<span class="lineNum">    3993 </span>            :           return cfg_cleanup_needed;
<span class="lineNum">    3994 </span><span class="lineCov">    8563884 :         else if (single_pred_p (e-&gt;dest))</span>
<span class="lineNum">    3995 </span>            :           {
<span class="lineNum">    3996 </span><span class="lineCov">    5191036 :             stmt = last_stmt (e-&gt;dest);</span>
<span class="lineNum">    3997 </span><span class="lineCov">    5191036 :             if (stmt</span>
<span class="lineNum">    3998 </span><span class="lineCov">   10164862 :                 &amp;&amp; gimple_code (stmt) == GIMPLE_COND</span>
<span class="lineNum">    3999 </span><span class="lineCov">    7342674 :                 &amp;&amp; EDGE_COUNT (e-&gt;dest-&gt;succs) == 2)</span>
<span class="lineNum">    4000 </span>            :               {
<span class="lineNum">    4001 </span><span class="lineCov">    2151638 :                 if (suitable_cond_bb (first_bb, e-&gt;dest, &amp;other_bb, true))</span>
<span class="lineNum">    4002 </span>            :                   break;
<span class="lineNum">    4003 </span>            :                 else
<span class="lineNum">    4004 </span><span class="lineCov">    1778456 :                   other_bb = NULL;</span>
<span class="lineNum">    4005 </span>            :               }
<span class="lineNum">    4006 </span><span class="lineCov">    3039398 :             else if (stmt</span>
<span class="lineNum">    4007 </span><span class="lineCov">    2930793 :                      &amp;&amp; final_range_test_p (stmt)</span>
<span class="lineNum">    4008 </span><span class="lineCov">    3100736 :                      &amp;&amp; find_edge (first_bb, single_succ (e-&gt;dest)))</span>
<span class="lineNum">    4009 </span>            :               {
<span class="lineNum">    4010 </span><span class="lineCov">      15691 :                 other_bb = single_succ (e-&gt;dest);</span>
<span class="lineNum">    4011 </span><span class="lineCov">      15691 :                 if (other_bb == first_bb)</span>
<span class="lineNum">    4012 </span><span class="lineNoCov">          0 :                   other_bb = NULL;</span>
<span class="lineNum">    4013 </span>            :               }
<span class="lineNum">    4014 </span>            :           }
<span class="lineNum">    4015 </span><span class="lineCov">    4268090 :       if (other_bb == NULL)</span>
<span class="lineNum">    4016 </span>            :         return cfg_cleanup_needed;
<span class="lineNum">    4017 </span>            :     }
<span class="lineNum">    4018 </span>            :   /* Now do the forward search, moving last_bb to successor bbs
<span class="lineNum">    4019 </span>            :      that aren't other_bb.  */
<span class="lineNum">    4020 </span><span class="lineCov">     495732 :   while (EDGE_COUNT (last_bb-&gt;succs) == 2)</span>
<span class="lineNum">    4021 </span>            :     {
<span class="lineNum">    4022 </span><span class="lineCov">    1381341 :       FOR_EACH_EDGE (e, ei, last_bb-&gt;succs)</span>
<span class="lineNum">    4023 </span><span class="lineCov">     889853 :         if (e-&gt;dest != other_bb)</span>
<span class="lineNum">    4024 </span>            :           break;
<span class="lineNum">    4025 </span><span class="lineCov">     491488 :       if (e == NULL)</span>
<span class="lineNum">    4026 </span>            :         break;
<span class="lineNum">    4027 </span><span class="lineCov">     491488 :       if (!single_pred_p (e-&gt;dest))</span>
<span class="lineNum">    4028 </span>            :         break;
<span class="lineNum">    4029 </span><span class="lineCov">     450046 :       if (!suitable_cond_bb (e-&gt;dest, last_bb, &amp;other_bb, false))</span>
<span class="lineNum">    4030 </span>            :         break;
<span class="lineNum">    4031 </span><span class="lineCov">     385409 :       if (!no_side_effect_bb (e-&gt;dest))</span>
<span class="lineNum">    4032 </span>            :         break;
<span class="lineNum">    4033 </span><span class="lineCov">       2878 :       last_bb = e-&gt;dest;</span>
<span class="lineNum">    4034 </span>            :     }
<span class="lineNum">    4035 </span><span class="lineCov">     492854 :   if (first_bb == last_bb)</span>
<span class="lineNum">    4036 </span>            :     return cfg_cleanup_needed;
<span class="lineNum">    4037 </span>            :   /* Here basic blocks first_bb through last_bb's predecessor
<span class="lineNum">    4038 </span>            :      end with GIMPLE_COND, all of them have one of the edges to
<span class="lineNum">    4039 </span>            :      other_bb and another to another block in the range,
<span class="lineNum">    4040 </span>            :      all blocks except first_bb don't have side-effects and
<span class="lineNum">    4041 </span>            :      last_bb ends with either GIMPLE_COND, or cast satisfying
<span class="lineNum">    4042 </span>            :      final_range_test_p.  */
<span class="lineNum">    4043 </span><span class="lineCov">     131704 :   for (bb = last_bb; ; bb = single_pred (bb))</span>
<span class="lineNum">    4044 </span>            :     {
<span class="lineNum">    4045 </span><span class="lineCov">     237184 :       enum tree_code code;</span>
<span class="lineNum">    4046 </span><span class="lineCov">     237184 :       tree lhs, rhs;</span>
<span class="lineNum">    4047 </span><span class="lineCov">     237184 :       inter_bb_range_test_entry bb_ent;</span>
<span class="lineNum">    4048 </span>            : 
<span class="lineNum">    4049 </span><span class="lineCov">     237184 :       bb_ent.op = NULL_TREE;</span>
<span class="lineNum">    4050 </span><span class="lineCov">     237184 :       bb_ent.first_idx = ops.length ();</span>
<span class="lineNum">    4051 </span><span class="lineCov">     237184 :       bb_ent.last_idx = bb_ent.first_idx;</span>
<span class="lineNum">    4052 </span><span class="lineCov">     237184 :       e = find_edge (bb, other_bb);</span>
<span class="lineNum">    4053 </span><span class="lineCov">     237184 :       stmt = last_stmt (bb);</span>
<span class="lineNum">    4054 </span><span class="lineCov">     237184 :       gimple_set_visited (stmt, true);</span>
<span class="lineNum">    4055 </span><span class="lineCov">     474368 :       if (gimple_code (stmt) != GIMPLE_COND)</span>
<span class="lineNum">    4056 </span>            :         {
<span class="lineNum">    4057 </span><span class="lineCov">       4244 :           use_operand_p use_p;</span>
<span class="lineNum">    4058 </span><span class="lineCov">       4244 :           gimple *phi;</span>
<span class="lineNum">    4059 </span><span class="lineCov">       4244 :           edge e2;</span>
<span class="lineNum">    4060 </span><span class="lineCov">       4244 :           unsigned int d;</span>
<span class="lineNum">    4061 </span>            : 
<span class="lineNum">    4062 </span><span class="lineCov">       4244 :           lhs = gimple_assign_lhs (stmt);</span>
<span class="lineNum">    4063 </span><span class="lineCov">       4244 :           rhs = gimple_assign_rhs1 (stmt);</span>
<span class="lineNum">    4064 </span><span class="lineCov">       4244 :           gcc_assert (bb == last_bb);</span>
<span class="lineNum">    4065 </span>            : 
<span class="lineNum">    4066 </span>            :           /* stmt is
<span class="lineNum">    4067 </span>            :              _123 = (int) _234;
<span class="lineNum">    4068 </span>            :              OR
<span class="lineNum">    4069 </span>            :              _234 = a_2(D) == 2;
<span class="lineNum">    4070 </span>            : 
<span class="lineNum">    4071 </span>            :              followed by:
<span class="lineNum">    4072 </span>            :              &lt;bb M&gt;:
<span class="lineNum">    4073 </span>            :              # _345 = PHI &lt;_123(N), 1(...), 1(...)&gt;
<span class="lineNum">    4074 </span>            : 
<span class="lineNum">    4075 </span>            :              or 0 instead of 1.  If it is 0, the _234
<span class="lineNum">    4076 </span>            :              range test is anded together with all the
<span class="lineNum">    4077 </span>            :              other range tests, if it is 1, it is ored with
<span class="lineNum">    4078 </span>            :              them.  */
<span class="lineNum">    4079 </span><span class="lineCov">       4244 :           single_imm_use (lhs, &amp;use_p, &amp;phi);</span>
<span class="lineNum">    4080 </span><span class="lineCov">       8488 :           gcc_assert (gimple_code (phi) == GIMPLE_PHI);</span>
<span class="lineNum">    4081 </span><span class="lineCov">       4244 :           e2 = find_edge (first_bb, other_bb);</span>
<span class="lineNum">    4082 </span><span class="lineCov">       4244 :           d = e2-&gt;dest_idx;</span>
<span class="lineNum">    4083 </span><span class="lineCov">       4244 :           gcc_assert (gimple_phi_arg_def (phi, e-&gt;dest_idx) == lhs);</span>
<span class="lineNum">    4084 </span><span class="lineCov">       4244 :           if (integer_zerop (gimple_phi_arg_def (phi, d)))</span>
<span class="lineNum">    4085 </span>            :             code = BIT_AND_EXPR;
<span class="lineNum">    4086 </span>            :           else
<span class="lineNum">    4087 </span>            :             {
<span class="lineNum">    4088 </span><span class="lineCov">       2927 :               gcc_checking_assert (integer_onep (gimple_phi_arg_def (phi, d)));</span>
<span class="lineNum">    4089 </span>            :               code = BIT_IOR_EXPR;
<span class="lineNum">    4090 </span>            :             }
<span class="lineNum">    4091 </span>            : 
<span class="lineNum">    4092 </span>            :           /* If _234 SSA_NAME_DEF_STMT is
<span class="lineNum">    4093 </span>            :              _234 = _567 | _789;
<span class="lineNum">    4094 </span>            :              (or &amp;, corresponding to 1/0 in the phi arguments,
<span class="lineNum">    4095 </span>            :              push into ops the individual range test arguments
<span class="lineNum">    4096 </span>            :              of the bitwise or resp. and, recursively.  */
<span class="lineNum">    4097 </span><span class="lineCov">       4244 :           if (TREE_CODE (rhs) == SSA_NAME</span>
<span class="lineNum">    4098 </span><span class="lineCov">       4239 :               &amp;&amp; (TREE_CODE_CLASS (gimple_assign_rhs_code (stmt))</span>
<span class="lineNum">    4099 </span>            :                   != tcc_comparison)
<span class="lineNum">    4100 </span><span class="lineCov">       4710 :               &amp;&amp; !get_ops (rhs, code, &amp;ops,</span>
<span class="lineNum">    4101 </span>            :                         loop_containing_stmt (stmt))
<span class="lineNum">    4102 </span><span class="lineCov">       6535 :               &amp;&amp; has_single_use (rhs))</span>
<span class="lineNum">    4103 </span>            :             {
<span class="lineNum">    4104 </span>            :               /* Otherwise, push the _234 range test itself.  */
<span class="lineNum">    4105 </span><span class="lineCov">       2281 :               operand_entry *oe = operand_entry_pool.allocate ();</span>
<span class="lineNum">    4106 </span>            : 
<span class="lineNum">    4107 </span><span class="lineCov">       2281 :               oe-&gt;op = rhs;</span>
<span class="lineNum">    4108 </span><span class="lineCov">       2281 :               oe-&gt;rank = code;</span>
<span class="lineNum">    4109 </span><span class="lineCov">       2281 :               oe-&gt;id = 0;</span>
<span class="lineNum">    4110 </span><span class="lineCov">       2281 :               oe-&gt;count = 1;</span>
<span class="lineNum">    4111 </span><span class="lineCov">       2281 :               oe-&gt;stmt_to_insert = NULL;</span>
<span class="lineNum">    4112 </span><span class="lineCov">       2281 :               ops.safe_push (oe);</span>
<span class="lineNum">    4113 </span><span class="lineCov">       2281 :               bb_ent.last_idx++;</span>
<span class="lineNum">    4114 </span><span class="lineCov">       2281 :               bb_ent.op = rhs;</span>
<span class="lineNum">    4115 </span>            :             }
<span class="lineNum">    4116 </span><span class="lineCov">       1963 :           else if (is_gimple_assign (stmt)</span>
<span class="lineNum">    4117 </span><span class="lineCov">       1963 :                    &amp;&amp; (TREE_CODE_CLASS (gimple_assign_rhs_code (stmt))</span>
<span class="lineNum">    4118 </span>            :                        == tcc_comparison)
<span class="lineNum">    4119 </span><span class="lineCov">       3778 :                    &amp;&amp; !get_ops (lhs, code, &amp;ops,</span>
<span class="lineNum">    4120 </span>            :                                 loop_containing_stmt (stmt))
<span class="lineNum">    4121 </span><span class="lineCov">       3852 :                    &amp;&amp; has_single_use (lhs))</span>
<span class="lineNum">    4122 </span>            :             {
<span class="lineNum">    4123 </span><span class="lineCov">       1889 :               operand_entry *oe = operand_entry_pool.allocate ();</span>
<span class="lineNum">    4124 </span><span class="lineCov">       1889 :               oe-&gt;op = lhs;</span>
<span class="lineNum">    4125 </span><span class="lineCov">       1889 :               oe-&gt;rank = code;</span>
<span class="lineNum">    4126 </span><span class="lineCov">       1889 :               oe-&gt;id = 0;</span>
<span class="lineNum">    4127 </span><span class="lineCov">       1889 :               oe-&gt;count = 1;</span>
<span class="lineNum">    4128 </span><span class="lineCov">       1889 :               ops.safe_push (oe);</span>
<span class="lineNum">    4129 </span><span class="lineCov">       1889 :               bb_ent.last_idx++;</span>
<span class="lineNum">    4130 </span><span class="lineCov">       1889 :               bb_ent.op = lhs;</span>
<span class="lineNum">    4131 </span>            :             }
<span class="lineNum">    4132 </span>            :           else
<span class="lineNum">    4133 </span>            :             {
<span class="lineNum">    4134 </span><span class="lineCov">         74 :               bb_ent.last_idx = ops.length ();</span>
<span class="lineNum">    4135 </span><span class="lineCov">         74 :               bb_ent.op = rhs;</span>
<span class="lineNum">    4136 </span>            :             }
<span class="lineNum">    4137 </span><span class="lineCov">       4244 :           bbinfo.safe_push (bb_ent);</span>
<span class="lineNum">    4138 </span><span class="lineCov">       4244 :           continue;</span>
<span class="lineNum">    4139 </span>            :         }
<span class="lineNum">    4140 </span>            :       /* Otherwise stmt is GIMPLE_COND.  */
<span class="lineNum">    4141 </span><span class="lineCov">     232940 :       code = gimple_cond_code (stmt);</span>
<span class="lineNum">    4142 </span><span class="lineCov">     232940 :       lhs = gimple_cond_lhs (stmt);</span>
<span class="lineNum">    4143 </span><span class="lineCov">     232940 :       rhs = gimple_cond_rhs (stmt);</span>
<span class="lineNum">    4144 </span><span class="lineCov">     232940 :       if (TREE_CODE (lhs) == SSA_NAME</span>
<span class="lineNum">    4145 </span><span class="lineCov">     232413 :           &amp;&amp; INTEGRAL_TYPE_P (TREE_TYPE (lhs))</span>
<span class="lineNum">    4146 </span><span class="lineCov">     437829 :           &amp;&amp; ((code != EQ_EXPR &amp;&amp; code != NE_EXPR)</span>
<span class="lineNum">    4147 </span><span class="lineCov">     156832 :               || rhs != boolean_false_node</span>
<span class="lineNum">    4148 </span>            :                  /* Either push into ops the individual bitwise
<span class="lineNum">    4149 </span>            :                     or resp. and operands, depending on which
<span class="lineNum">    4150 </span>            :                     edge is other_bb.  */
<span class="lineNum">    4151 </span><span class="lineCov">      88472 :               || !get_ops (lhs, (((e-&gt;flags &amp; EDGE_TRUE_VALUE) == 0)</span>
<span class="lineNum">    4152 </span>            :                                  ^ (code == EQ_EXPR))
<span class="lineNum">    4153 </span><span class="lineCov">      44236 :                                 ? BIT_AND_EXPR : BIT_IOR_EXPR, &amp;ops,</span>
<span class="lineNum">    4154 </span>            :                            loop_containing_stmt (stmt))))
<span class="lineNum">    4155 </span>            :         {
<span class="lineNum">    4156 </span>            :           /* Or push the GIMPLE_COND stmt itself.  */
<span class="lineNum">    4157 </span><span class="lineCov">     194594 :           operand_entry *oe = operand_entry_pool.allocate ();</span>
<span class="lineNum">    4158 </span>            : 
<span class="lineNum">    4159 </span><span class="lineCov">     194594 :           oe-&gt;op = NULL;</span>
<span class="lineNum">    4160 </span><span class="lineCov">     389188 :           oe-&gt;rank = (e-&gt;flags &amp; EDGE_TRUE_VALUE)</span>
<span class="lineNum">    4161 </span><span class="lineCov">     194594 :                      ? BIT_IOR_EXPR : BIT_AND_EXPR;</span>
<span class="lineNum">    4162 </span>            :           /* oe-&gt;op = NULL signs that there is no SSA_NAME
<span class="lineNum">    4163 </span>            :              for the range test, and oe-&gt;id instead is the
<span class="lineNum">    4164 </span>            :              basic block number, at which's end the GIMPLE_COND
<span class="lineNum">    4165 </span>            :              is.  */
<span class="lineNum">    4166 </span><span class="lineCov">     194594 :           oe-&gt;id = bb-&gt;index;</span>
<span class="lineNum">    4167 </span><span class="lineCov">     194594 :           oe-&gt;count = 1;</span>
<span class="lineNum">    4168 </span><span class="lineCov">     194594 :           oe-&gt;stmt_to_insert = NULL;</span>
<span class="lineNum">    4169 </span><span class="lineCov">     194594 :           ops.safe_push (oe);</span>
<span class="lineNum">    4170 </span><span class="lineCov">     194594 :           bb_ent.op = NULL;</span>
<span class="lineNum">    4171 </span><span class="lineCov">     194594 :           bb_ent.last_idx++;</span>
<span class="lineNum">    4172 </span>            :         }
<span class="lineNum">    4173 </span><span class="lineCov">      52818 :       else if (ops.length () &gt; bb_ent.first_idx)</span>
<span class="lineNum">    4174 </span>            :         {
<span class="lineNum">    4175 </span><span class="lineCov">      10261 :           bb_ent.op = lhs;</span>
<span class="lineNum">    4176 </span><span class="lineCov">      10261 :           bb_ent.last_idx = ops.length ();</span>
<span class="lineNum">    4177 </span>            :         }
<span class="lineNum">    4178 </span><span class="lineCov">     232940 :       bbinfo.safe_push (bb_ent);</span>
<span class="lineNum">    4179 </span><span class="lineCov">     232940 :       if (bb == first_bb)</span>
<span class="lineNum">    4180 </span>            :         break;
<span class="lineNum">    4181 </span><span class="lineCov">     131704 :     }</span>
<span class="lineNum">    4182 </span><span class="lineCov">     105480 :   if (ops.length () &gt; 1)</span>
<span class="lineNum">    4183 </span><span class="lineCov">      89829 :     any_changes = optimize_range_tests (ERROR_MARK, &amp;ops, first_bb);</span>
<span class="lineNum">    4184 </span><span class="lineCov">      89829 :   if (any_changes)</span>
<span class="lineNum">    4185 </span>            :     {
<span class="lineNum">    4186 </span>            :       unsigned int idx, max_idx = 0;
<span class="lineNum">    4187 </span>            :       /* update_ops relies on has_single_use predicates returning the
<span class="lineNum">    4188 </span>            :          same values as it did during get_ops earlier.  Additionally it
<span class="lineNum">    4189 </span>            :          never removes statements, only adds new ones and it should walk
<span class="lineNum">    4190 </span>            :          from the single imm use and check the predicate already before
<span class="lineNum">    4191 </span>            :          making those changes.
<span class="lineNum">    4192 </span>            :          On the other side, the handling of GIMPLE_COND directly can turn
<span class="lineNum">    4193 </span>            :          previously multiply used SSA_NAMEs into single use SSA_NAMEs, so
<span class="lineNum">    4194 </span>            :          it needs to be done in a separate loop afterwards.  */
<span class="lineNum">    4195 </span><span class="lineCov">      11292 :       for (bb = last_bb, idx = 0; ; bb = single_pred (bb), idx++)</span>
<span class="lineNum">    4196 </span>            :         {
<span class="lineNum">    4197 </span><span class="lineCov">      18374 :           if (bbinfo[idx].first_idx &lt; bbinfo[idx].last_idx</span>
<span class="lineNum">    4198 </span><span class="lineCov">      18374 :               &amp;&amp; bbinfo[idx].op != NULL_TREE)</span>
<span class="lineNum">    4199 </span>            :             {
<span class="lineNum">    4200 </span><span class="lineCov">       3990 :               tree new_op;</span>
<span class="lineNum">    4201 </span>            : 
<span class="lineNum">    4202 </span><span class="lineCov">       3990 :               max_idx = idx;</span>
<span class="lineNum">    4203 </span><span class="lineCov">       3990 :               stmt = last_stmt (bb);</span>
<span class="lineNum">    4204 </span><span class="lineCov">       7980 :               new_op = update_ops (bbinfo[idx].op,</span>
<span class="lineNum">    4205 </span>            :                                    (enum tree_code)
<span class="lineNum">    4206 </span><span class="lineCov">       3990 :                                    ops[bbinfo[idx].first_idx]-&gt;rank,</span>
<span class="lineNum">    4207 </span><span class="lineCov">       3990 :                                    ops, &amp;bbinfo[idx].first_idx,</span>
<span class="lineNum">    4208 </span>            :                                    loop_containing_stmt (stmt));
<span class="lineNum">    4209 </span><span class="lineCov">       3990 :               if (new_op == NULL_TREE)</span>
<span class="lineNum">    4210 </span>            :                 {
<span class="lineNum">    4211 </span><span class="lineCov">        395 :                   gcc_assert (bb == last_bb);</span>
<span class="lineNum">    4212 </span><span class="lineCov">        395 :                   new_op = ops[bbinfo[idx].first_idx++]-&gt;op;</span>
<span class="lineNum">    4213 </span>            :                 }
<span class="lineNum">    4214 </span><span class="lineCov">       3990 :               if (bbinfo[idx].op != new_op)</span>
<span class="lineNum">    4215 </span>            :                 {
<span class="lineNum">    4216 </span><span class="lineCov">       3781 :                   imm_use_iterator iter;</span>
<span class="lineNum">    4217 </span><span class="lineCov">       3781 :                   use_operand_p use_p;</span>
<span class="lineNum">    4218 </span><span class="lineCov">       3781 :                   gimple *use_stmt, *cast_or_tcc_cmp_stmt = NULL;</span>
<span class="lineNum">    4219 </span>            : 
<span class="lineNum">    4220 </span><span class="lineCov">      11368 :                   FOR_EACH_IMM_USE_STMT (use_stmt, iter, bbinfo[idx].op)</span>
<span class="lineNum">    4221 </span><span class="lineCov">       7612 :                     if (is_gimple_debug (use_stmt))</span>
<span class="lineNum">    4222 </span>            :                       continue;
<span class="lineNum">    4223 </span><span class="lineCov">       3781 :                     else if (gimple_code (use_stmt) == GIMPLE_COND</span>
<span class="lineNum">    4224 </span><span class="lineCov">       3781 :                              || gimple_code (use_stmt) == GIMPLE_PHI)</span>
<span class="lineNum">    4225 </span><span class="lineCov">      21894 :                       FOR_EACH_IMM_USE_ON_STMT (use_p, iter)</span>
<span class="lineNum">    4226 </span><span class="lineCov">       3649 :                         SET_USE (use_p, new_op);</span>
<span class="lineNum">    4227 </span><span class="lineCov">        132 :                     else if ((is_gimple_assign (use_stmt)</span>
<span class="lineNum">    4228 </span><span class="lineCov">        132 :                               &amp;&amp; (TREE_CODE_CLASS</span>
<span class="lineNum">    4229 </span>            :                                   (gimple_assign_rhs_code (use_stmt))
<span class="lineNum">    4230 </span>            :                                   == tcc_comparison)))
<span class="lineNum">    4231 </span>            :                       cast_or_tcc_cmp_stmt = use_stmt;
<span class="lineNum">    4232 </span><span class="lineCov">        132 :                     else if (gimple_assign_cast_p (use_stmt))</span>
<span class="lineNum">    4233 </span>            :                       cast_or_tcc_cmp_stmt = use_stmt;
<span class="lineNum">    4234 </span>            :                     else
<span class="lineNum">    4235 </span><span class="lineNoCov">          0 :                       gcc_unreachable ();</span>
<span class="lineNum">    4236 </span>            : 
<span class="lineNum">    4237 </span><span class="lineCov">       3781 :                   if (cast_or_tcc_cmp_stmt)</span>
<span class="lineNum">    4238 </span>            :                     {
<span class="lineNum">    4239 </span><span class="lineCov">        132 :                       gcc_assert (bb == last_bb);</span>
<span class="lineNum">    4240 </span><span class="lineCov">        132 :                       tree lhs = gimple_assign_lhs (cast_or_tcc_cmp_stmt);</span>
<span class="lineNum">    4241 </span><span class="lineCov">        132 :                       tree new_lhs = make_ssa_name (TREE_TYPE (lhs));</span>
<span class="lineNum">    4242 </span><span class="lineCov">        132 :                       enum tree_code rhs_code</span>
<span class="lineNum">    4243 </span><span class="lineCov">        132 :                         = gimple_assign_cast_p (cast_or_tcc_cmp_stmt)</span>
<span class="lineNum">    4244 </span><span class="lineCov">        132 :                         ? gimple_assign_rhs_code (cast_or_tcc_cmp_stmt)</span>
<span class="lineNum">    4245 </span><span class="lineCov">        132 :                         : CONVERT_EXPR;</span>
<span class="lineNum">    4246 </span><span class="lineCov">        132 :                       gassign *g;</span>
<span class="lineNum">    4247 </span><span class="lineCov">        132 :                       if (is_gimple_min_invariant (new_op))</span>
<span class="lineNum">    4248 </span>            :                         {
<span class="lineNum">    4249 </span><span class="lineCov">         44 :                           new_op = fold_convert (TREE_TYPE (lhs), new_op);</span>
<span class="lineNum">    4250 </span><span class="lineCov">         44 :                           g = gimple_build_assign (new_lhs, new_op);</span>
<span class="lineNum">    4251 </span>            :                         }
<span class="lineNum">    4252 </span>            :                       else
<span class="lineNum">    4253 </span><span class="lineCov">         88 :                         g = gimple_build_assign (new_lhs, rhs_code, new_op);</span>
<span class="lineNum">    4254 </span><span class="lineCov">        132 :                       gimple_stmt_iterator gsi</span>
<span class="lineNum">    4255 </span><span class="lineCov">        132 :                         = gsi_for_stmt (cast_or_tcc_cmp_stmt);</span>
<span class="lineNum">    4256 </span><span class="lineCov">        264 :                       gimple_set_uid (g, gimple_uid (cast_or_tcc_cmp_stmt));</span>
<span class="lineNum">    4257 </span><span class="lineCov">        132 :                       gimple_set_visited (g, true);</span>
<span class="lineNum">    4258 </span><span class="lineCov">        132 :                       gsi_insert_before (&amp;gsi, g, GSI_SAME_STMT);</span>
<span class="lineNum">    4259 </span><span class="lineCov">        269 :                       FOR_EACH_IMM_USE_STMT (use_stmt, iter, lhs)</span>
<span class="lineNum">    4260 </span><span class="lineCov">        274 :                         if (is_gimple_debug (use_stmt))</span>
<span class="lineNum">    4261 </span>            :                           continue;
<span class="lineNum">    4262 </span><span class="lineCov">        132 :                         else if (gimple_code (use_stmt) == GIMPLE_COND</span>
<span class="lineNum">    4263 </span><span class="lineCov">        132 :                                  || gimple_code (use_stmt) == GIMPLE_PHI)</span>
<span class="lineNum">    4264 </span><span class="lineCov">        792 :                           FOR_EACH_IMM_USE_ON_STMT (use_p, iter)</span>
<span class="lineNum">    4265 </span><span class="lineCov">        132 :                             SET_USE (use_p, new_lhs);</span>
<span class="lineNum">    4266 </span>            :                         else
<span class="lineNum">    4267 </span><span class="lineNoCov">          0 :                           gcc_unreachable ();</span>
<span class="lineNum">    4268 </span>            :                     }
<span class="lineNum">    4269 </span>            :                 }
<span class="lineNum">    4270 </span>            :             }
<span class="lineNum">    4271 </span><span class="lineCov">      18374 :           if (bb == first_bb)</span>
<span class="lineNum">    4272 </span>            :             break;
<span class="lineNum">    4273 </span><span class="lineCov">      11292 :         }</span>
<span class="lineNum">    4274 </span><span class="lineCov">      11292 :       for (bb = last_bb, idx = 0; ; bb = single_pred (bb), idx++)</span>
<span class="lineNum">    4275 </span>            :         {
<span class="lineNum">    4276 </span><span class="lineCov">      18374 :           if (bbinfo[idx].first_idx &lt; bbinfo[idx].last_idx</span>
<span class="lineNum">    4277 </span><span class="lineCov">      28602 :               &amp;&amp; bbinfo[idx].op == NULL_TREE</span>
<span class="lineNum">    4278 </span><span class="lineCov">      46976 :               &amp;&amp; ops[bbinfo[idx].first_idx]-&gt;op != NULL_TREE)</span>
<span class="lineNum">    4279 </span>            :             {
<span class="lineNum">    4280 </span><span class="lineCov">      12687 :               gcond *cond_stmt = as_a &lt;gcond *&gt; (last_stmt (bb));</span>
<span class="lineNum">    4281 </span>            : 
<span class="lineNum">    4282 </span><span class="lineCov">      12687 :               if (idx &gt; max_idx)</span>
<span class="lineNum">    4283 </span><span class="lineCov">       7525 :                 max_idx = idx;</span>
<span class="lineNum">    4284 </span>            : 
<span class="lineNum">    4285 </span>            :               /* If we collapse the conditional to a true/false
<span class="lineNum">    4286 </span>            :                  condition, then bubble that knowledge up to our caller.  */
<span class="lineNum">    4287 </span><span class="lineCov">      12687 :               if (integer_zerop (ops[bbinfo[idx].first_idx]-&gt;op))</span>
<span class="lineNum">    4288 </span>            :                 {
<span class="lineNum">    4289 </span><span class="lineCov">       3830 :                   gimple_cond_make_false (cond_stmt);</span>
<span class="lineNum">    4290 </span><span class="lineCov">       3830 :                   cfg_cleanup_needed = true;</span>
<span class="lineNum">    4291 </span>            :                 }
<span class="lineNum">    4292 </span><span class="lineCov">       8857 :               else if (integer_onep (ops[bbinfo[idx].first_idx]-&gt;op))</span>
<span class="lineNum">    4293 </span>            :                 {
<span class="lineNum">    4294 </span><span class="lineCov">       3153 :                   gimple_cond_make_true (cond_stmt);</span>
<span class="lineNum">    4295 </span><span class="lineCov">       3153 :                   cfg_cleanup_needed = true;</span>
<span class="lineNum">    4296 </span>            :                 }
<span class="lineNum">    4297 </span>            :               else
<span class="lineNum">    4298 </span>            :                 {
<span class="lineNum">    4299 </span><span class="lineCov">       5704 :                   gimple_cond_set_code (cond_stmt, NE_EXPR);</span>
<span class="lineNum">    4300 </span><span class="lineCov">      17112 :                   gimple_cond_set_lhs (cond_stmt,</span>
<span class="lineNum">    4301 </span><span class="lineCov">       5704 :                                        ops[bbinfo[idx].first_idx]-&gt;op);</span>
<span class="lineNum">    4302 </span><span class="lineCov">       5704 :                   gimple_cond_set_rhs (cond_stmt, boolean_false_node);</span>
<span class="lineNum">    4303 </span>            :                 }
<span class="lineNum">    4304 </span><span class="lineCov">      12687 :               update_stmt (cond_stmt);</span>
<span class="lineNum">    4305 </span>            :             }
<span class="lineNum">    4306 </span><span class="lineCov">      18374 :           if (bb == first_bb)</span>
<span class="lineNum">    4307 </span>            :             break;
<span class="lineNum">    4308 </span><span class="lineCov">      11292 :         }</span>
<span class="lineNum">    4309 </span>            : 
<span class="lineNum">    4310 </span>            :       /* The above changes could result in basic blocks after the first
<span class="lineNum">    4311 </span>            :          modified one, up to and including last_bb, to be executed even if
<span class="lineNum">    4312 </span>            :          they would not be in the original program.  If the value ranges of
<span class="lineNum">    4313 </span>            :          assignment lhs' in those bbs were dependent on the conditions
<span class="lineNum">    4314 </span>            :          guarding those basic blocks which now can change, the VRs might
<span class="lineNum">    4315 </span>            :          be incorrect.  As no_side_effect_bb should ensure those SSA_NAMEs
<span class="lineNum">    4316 </span>            :          are only used within the same bb, it should be not a big deal if
<span class="lineNum">    4317 </span>            :          we just reset all the VRs in those bbs.  See PR68671.  */
<span class="lineNum">    4318 </span><span class="lineCov">      17831 :       for (bb = last_bb, idx = 0; idx &lt; max_idx; bb = single_pred (bb), idx++)</span>
<span class="lineNum">    4319 </span><span class="lineCov">      10749 :         reset_flow_sensitive_info_in_bb (bb);</span>
<span class="lineNum">    4320 </span>            :     }
<span class="lineNum">    4321 </span>            :   return cfg_cleanup_needed;
<span class="lineNum">    4322 </span>            : }
<span class="lineNum">    4323 </span>            : 
<span class="lineNum">    4324 </span>            : /* Return true if OPERAND is defined by a PHI node which uses the LHS
<span class="lineNum">    4325 </span>            :    of STMT in it's operands.  This is also known as a &quot;destructive
<span class="lineNum">    4326 </span>            :    update&quot; operation.  */
<a name="4327"><span class="lineNum">    4327 </span>            : </a>
<span class="lineNum">    4328 </span>            : static bool
<span class="lineNum">    4329 </span><span class="lineCov">     156979 : is_phi_for_stmt (gimple *stmt, tree operand)</span>
<span class="lineNum">    4330 </span>            : {
<span class="lineNum">    4331 </span><span class="lineCov">     156979 :   gimple *def_stmt;</span>
<span class="lineNum">    4332 </span><span class="lineCov">     156979 :   gphi *def_phi;</span>
<span class="lineNum">    4333 </span><span class="lineCov">     156979 :   tree lhs;</span>
<span class="lineNum">    4334 </span><span class="lineCov">     156979 :   use_operand_p arg_p;</span>
<span class="lineNum">    4335 </span><span class="lineCov">     156979 :   ssa_op_iter i;</span>
<span class="lineNum">    4336 </span>            : 
<span class="lineNum">    4337 </span><span class="lineCov">     156979 :   if (TREE_CODE (operand) != SSA_NAME)</span>
<span class="lineNum">    4338 </span>            :     return false;
<span class="lineNum">    4339 </span>            : 
<span class="lineNum">    4340 </span><span class="lineCov">     122507 :   lhs = gimple_assign_lhs (stmt);</span>
<span class="lineNum">    4341 </span>            : 
<span class="lineNum">    4342 </span><span class="lineCov">     122507 :   def_stmt = SSA_NAME_DEF_STMT (operand);</span>
<span class="lineNum">    4343 </span><span class="lineCov">     122507 :   def_phi = dyn_cast &lt;gphi *&gt; (def_stmt);</span>
<span class="lineNum">    4344 </span><span class="lineCov">       4470 :   if (!def_phi)</span>
<span class="lineNum">    4345 </span>            :     return false;
<span class="lineNum">    4346 </span>            : 
<span class="lineNum">    4347 </span><span class="lineCov">      14442 :   FOR_EACH_PHI_ARG (arg_p, def_phi, i, SSA_OP_USE)</span>
<span class="lineNum">    4348 </span><span class="lineCov">      20242 :     if (lhs == USE_FROM_PTR (arg_p))</span>
<span class="lineNum">    4349 </span>            :       return true;
<span class="lineNum">    4350 </span>            :   return false;
<span class="lineNum">    4351 </span>            : }
<span class="lineNum">    4352 </span>            : 
<span class="lineNum">    4353 </span>            : /* Remove def stmt of VAR if VAR has zero uses and recurse
<span class="lineNum">    4354 </span>            :    on rhs1 operand if so.  */
<a name="4355"><span class="lineNum">    4355 </span>            : </a>
<span class="lineNum">    4356 </span>            : static void
<span class="lineNum">    4357 </span><span class="lineCov">      41555 : remove_visited_stmt_chain (tree var)</span>
<span class="lineNum">    4358 </span>            : {
<span class="lineNum">    4359 </span><span class="lineCov">      82053 :   gimple *stmt;</span>
<span class="lineNum">    4360 </span><span class="lineCov">      82053 :   gimple_stmt_iterator gsi;</span>
<span class="lineNum">    4361 </span>            : 
<span class="lineNum">    4362 </span><span class="lineCov">      82053 :   while (1)</span>
<span class="lineNum">    4363 </span>            :     {
<span class="lineNum">    4364 </span><span class="lineCov">      82053 :       if (TREE_CODE (var) != SSA_NAME || !has_zero_uses (var))</span>
<span class="lineNum">    4365 </span>            :         return;
<span class="lineNum">    4366 </span><span class="lineCov">      46886 :       stmt = SSA_NAME_DEF_STMT (var);</span>
<span class="lineNum">    4367 </span><span class="lineCov">      93772 :       if (is_gimple_assign (stmt) &amp;&amp; gimple_visited_p (stmt))</span>
<span class="lineNum">    4368 </span>            :         {
<span class="lineNum">    4369 </span><span class="lineCov">      40498 :           var = gimple_assign_rhs1 (stmt);</span>
<span class="lineNum">    4370 </span><span class="lineCov">      40498 :           gsi = gsi_for_stmt (stmt);</span>
<span class="lineNum">    4371 </span><span class="lineCov">      40498 :           reassoc_remove_stmt (&amp;gsi);</span>
<span class="lineNum">    4372 </span><span class="lineCov">      40498 :           release_defs (stmt);</span>
<span class="lineNum">    4373 </span>            :         }
<span class="lineNum">    4374 </span>            :       else
<span class="lineNum">    4375 </span>            :         return;
<span class="lineNum">    4376 </span>            :     }
<span class="lineNum">    4377 </span>            : }
<span class="lineNum">    4378 </span>            : 
<span class="lineNum">    4379 </span>            : /* This function checks three consequtive operands in
<span class="lineNum">    4380 </span>            :    passed operands vector OPS starting from OPINDEX and
<span class="lineNum">    4381 </span>            :    swaps two operands if it is profitable for binary operation
<span class="lineNum">    4382 </span>            :    consuming OPINDEX + 1 abnd OPINDEX + 2 operands.
<span class="lineNum">    4383 </span>            : 
<span class="lineNum">    4384 </span>            :    We pair ops with the same rank if possible.
<span class="lineNum">    4385 </span>            : 
<span class="lineNum">    4386 </span>            :    The alternative we try is to see if STMT is a destructive
<span class="lineNum">    4387 </span>            :    update style statement, which is like:
<span class="lineNum">    4388 </span>            :    b = phi (a, ...)
<span class="lineNum">    4389 </span>            :    a = c + b;
<span class="lineNum">    4390 </span>            :    In that case, we want to use the destructive update form to
<span class="lineNum">    4391 </span>            :    expose the possible vectorizer sum reduction opportunity.
<span class="lineNum">    4392 </span>            :    In that case, the third operand will be the phi node. This
<span class="lineNum">    4393 </span>            :    check is not performed if STMT is null.
<span class="lineNum">    4394 </span>            : 
<span class="lineNum">    4395 </span>            :    We could, of course, try to be better as noted above, and do a
<span class="lineNum">    4396 </span>            :    lot of work to try to find these opportunities in &gt;3 operand
<span class="lineNum">    4397 </span>            :    cases, but it is unlikely to be worth it.  */
<span class="lineNum">    4398 </span>            : 
<span class="lineNum">    4399 </span>            : static void
<span class="lineNum">    4400 </span><span class="lineCov">      96764 : swap_ops_for_binary_stmt (vec&lt;operand_entry *&gt; ops,</span>
<span class="lineNum">    4401 </span>            :                           unsigned int opindex, gimple *stmt)
<span class="lineNum">    4402 </span>            : {
<span class="lineNum">    4403 </span><span class="lineCov">      96764 :   operand_entry *oe1, *oe2, *oe3;</span>
<span class="lineNum">    4404 </span>            : 
<span class="lineNum">    4405 </span><span class="lineCov">      96764 :   oe1 = ops[opindex];</span>
<span class="lineNum">    4406 </span><span class="lineCov">      96764 :   oe2 = ops[opindex + 1];</span>
<span class="lineNum">    4407 </span><span class="lineCov">      96764 :   oe3 = ops[opindex + 2];</span>
<span class="lineNum">    4408 </span>            : 
<span class="lineNum">    4409 </span><span class="lineCov">      96764 :   if ((oe1-&gt;rank == oe2-&gt;rank</span>
<span class="lineNum">    4410 </span><span class="lineCov">      23957 :        &amp;&amp; oe2-&gt;rank != oe3-&gt;rank)</span>
<span class="lineNum">    4411 </span><span class="lineCov">     105113 :       || (stmt &amp;&amp; is_phi_for_stmt (stmt, oe3-&gt;op)</span>
<span class="lineNum">    4412 </span><span class="lineCov">         47 :           &amp;&amp; !is_phi_for_stmt (stmt, oe1-&gt;op)</span>
<span class="lineNum">    4413 </span><span class="lineCov">         47 :           &amp;&amp; !is_phi_for_stmt (stmt, oe2-&gt;op)))</span>
<span class="lineNum">    4414 </span><span class="lineCov">      15655 :     std::swap (*oe1, *oe3);</span>
<span class="lineNum">    4415 </span><span class="lineCov">      81109 :   else if ((oe1-&gt;rank == oe3-&gt;rank</span>
<span class="lineNum">    4416 </span><span class="lineCov">       8357 :             &amp;&amp; oe2-&gt;rank != oe3-&gt;rank)</span>
<span class="lineNum">    4417 </span><span class="lineCov">      89458 :            || (stmt &amp;&amp; is_phi_for_stmt (stmt, oe2-&gt;op)</span>
<span class="lineNum">    4418 </span><span class="lineCov">        102 :                &amp;&amp; !is_phi_for_stmt (stmt, oe1-&gt;op)</span>
<span class="lineNum">    4419 </span><span class="lineCov">        102 :                &amp;&amp; !is_phi_for_stmt (stmt, oe3-&gt;op)))</span>
<span class="lineNum">    4420 </span><span class="lineCov">        110 :     std::swap (*oe1, *oe2);</span>
<span class="lineNum">    4421 </span><span class="lineCov">      96764 : }</span>
<span class="lineNum">    4422 </span>            : 
<span class="lineNum">    4423 </span>            : /* If definition of RHS1 or RHS2 dominates STMT, return the later of those
<span class="lineNum">    4424 </span>            :    two definitions, otherwise return STMT.  */
<a name="4425"><span class="lineNum">    4425 </span>            : </a>
<span class="lineNum">    4426 </span>            : static inline gimple *
<span class="lineNum">    4427 </span><span class="lineCov">     519097 : find_insert_point (gimple *stmt, tree rhs1, tree rhs2)</span>
<span class="lineNum">    4428 </span>            : {
<span class="lineNum">    4429 </span><span class="lineCov">     519097 :   if (TREE_CODE (rhs1) == SSA_NAME</span>
<span class="lineNum">    4430 </span><span class="lineCov">     519097 :       &amp;&amp; reassoc_stmt_dominates_stmt_p (stmt, SSA_NAME_DEF_STMT (rhs1)))</span>
<span class="lineNum">    4431 </span><span class="lineCov">       7848 :     stmt = SSA_NAME_DEF_STMT (rhs1);</span>
<span class="lineNum">    4432 </span><span class="lineCov">     519097 :   if (TREE_CODE (rhs2) == SSA_NAME</span>
<span class="lineNum">    4433 </span><span class="lineCov">     519097 :       &amp;&amp; reassoc_stmt_dominates_stmt_p (stmt, SSA_NAME_DEF_STMT (rhs2)))</span>
<span class="lineNum">    4434 </span><span class="lineCov">       8934 :     stmt = SSA_NAME_DEF_STMT (rhs2);</span>
<span class="lineNum">    4435 </span><span class="lineCov">     519097 :   return stmt;</span>
<span class="lineNum">    4436 </span>            : }
<span class="lineNum">    4437 </span>            : 
<span class="lineNum">    4438 </span>            : /* If the stmt that defines operand has to be inserted, insert it
<a name="4439"><span class="lineNum">    4439 </span>            :    before the use.  */</a>
<span class="lineNum">    4440 </span>            : static void
<span class="lineNum">    4441 </span><span class="lineCov">         73 : insert_stmt_before_use (gimple *stmt, gimple *stmt_to_insert)</span>
<span class="lineNum">    4442 </span>            : {
<span class="lineNum">    4443 </span><span class="lineCov">        146 :   gcc_assert (is_gimple_assign (stmt_to_insert));</span>
<span class="lineNum">    4444 </span><span class="lineCov">         73 :   tree rhs1 = gimple_assign_rhs1 (stmt_to_insert);</span>
<span class="lineNum">    4445 </span><span class="lineCov">         73 :   tree rhs2 = gimple_assign_rhs2 (stmt_to_insert);</span>
<span class="lineNum">    4446 </span><span class="lineCov">         73 :   gimple *insert_point = find_insert_point (stmt, rhs1, rhs2);</span>
<span class="lineNum">    4447 </span><span class="lineCov">         73 :   gimple_stmt_iterator gsi = gsi_for_stmt (insert_point);</span>
<span class="lineNum">    4448 </span><span class="lineCov">        146 :   gimple_set_uid (stmt_to_insert, gimple_uid (insert_point));</span>
<span class="lineNum">    4449 </span>            : 
<span class="lineNum">    4450 </span>            :   /* If the insert point is not stmt, then insert_point would be
<span class="lineNum">    4451 </span>            :      the point where operand rhs1 or rhs2 is defined. In this case,
<span class="lineNum">    4452 </span>            :      stmt_to_insert has to be inserted afterwards. This would
<span class="lineNum">    4453 </span>            :      only happen when the stmt insertion point is flexible. */
<span class="lineNum">    4454 </span><span class="lineCov">         73 :   if (stmt == insert_point)</span>
<span class="lineNum">    4455 </span><span class="lineCov">         72 :     gsi_insert_before (&amp;gsi, stmt_to_insert, GSI_NEW_STMT);</span>
<span class="lineNum">    4456 </span>            :   else
<span class="lineNum">    4457 </span><span class="lineCov">          1 :     insert_stmt_after (stmt_to_insert, insert_point);</span>
<span class="lineNum">    4458 </span><span class="lineCov">         73 : }</span>
<span class="lineNum">    4459 </span>            : 
<span class="lineNum">    4460 </span>            : 
<span class="lineNum">    4461 </span>            : /* Recursively rewrite our linearized statements so that the operators
<span class="lineNum">    4462 </span>            :    match those in OPS[OPINDEX], putting the computation in rank
<span class="lineNum">    4463 </span>            :    order.  Return new lhs.
<span class="lineNum">    4464 </span>            :    CHANGED is true if we shouldn't reuse the lhs SSA_NAME both in
<span class="lineNum">    4465 </span>            :    the current stmt and during recursive invocations.
<span class="lineNum">    4466 </span>            :    NEXT_CHANGED is true if we shouldn't reuse the lhs SSA_NAME in
<span class="lineNum">    4467 </span>            :    recursive invocations.  */
<span class="lineNum">    4468 </span>            : 
<span class="lineNum">    4469 </span>            : static tree
<span class="lineNum">    4470 </span><span class="lineCov">    2503132 : rewrite_expr_tree (gimple *stmt, unsigned int opindex,</span>
<span class="lineNum">    4471 </span>            :                    vec&lt;operand_entry *&gt; ops, bool changed, bool next_changed)
<span class="lineNum">    4472 </span>            : {
<span class="lineNum">    4473 </span><span class="lineCov">    2503132 :   tree rhs1 = gimple_assign_rhs1 (stmt);</span>
<span class="lineNum">    4474 </span><span class="lineCov">    2503132 :   tree rhs2 = gimple_assign_rhs2 (stmt);</span>
<span class="lineNum">    4475 </span><span class="lineCov">    2503132 :   tree lhs = gimple_assign_lhs (stmt);</span>
<span class="lineNum">    4476 </span><span class="lineCov">    2503132 :   operand_entry *oe;</span>
<span class="lineNum">    4477 </span>            : 
<span class="lineNum">    4478 </span>            :   /* The final recursion case for this function is that you have
<span class="lineNum">    4479 </span>            :      exactly two operations left.
<span class="lineNum">    4480 </span>            :      If we had exactly one op in the entire list to start with, we
<span class="lineNum">    4481 </span>            :      would have never called this function, and the tail recursion
<span class="lineNum">    4482 </span>            :      rewrites them one at a time.  */
<span class="lineNum">    4483 </span><span class="lineCov">    5006264 :   if (opindex + 2 == ops.length ())</span>
<span class="lineNum">    4484 </span>            :     {
<span class="lineNum">    4485 </span><span class="lineCov">    2379708 :       operand_entry *oe1, *oe2;</span>
<span class="lineNum">    4486 </span>            : 
<span class="lineNum">    4487 </span><span class="lineCov">    2379708 :       oe1 = ops[opindex];</span>
<span class="lineNum">    4488 </span><span class="lineCov">    2379708 :       oe2 = ops[opindex + 1];</span>
<span class="lineNum">    4489 </span>            : 
<span class="lineNum">    4490 </span><span class="lineCov">    2379708 :       if (rhs1 != oe1-&gt;op || rhs2 != oe2-&gt;op)</span>
<span class="lineNum">    4491 </span>            :         {
<span class="lineNum">    4492 </span><span class="lineCov">     462734 :           gimple_stmt_iterator gsi = gsi_for_stmt (stmt);</span>
<span class="lineNum">    4493 </span><span class="lineCov">     462734 :           unsigned int uid = gimple_uid (stmt);</span>
<span class="lineNum">    4494 </span>            : 
<span class="lineNum">    4495 </span><span class="lineCov">     462734 :           if (dump_file &amp;&amp; (dump_flags &amp; TDF_DETAILS))</span>
<span class="lineNum">    4496 </span>            :             {
<span class="lineNum">    4497 </span><span class="lineCov">         28 :               fprintf (dump_file, &quot;Transforming &quot;);</span>
<span class="lineNum">    4498 </span><span class="lineCov">         28 :               print_gimple_stmt (dump_file, stmt, 0);</span>
<span class="lineNum">    4499 </span>            :             }
<span class="lineNum">    4500 </span>            : 
<span class="lineNum">    4501 </span>            :           /* If the stmt that defines operand has to be inserted, insert it
<span class="lineNum">    4502 </span>            :              before the use.  */
<span class="lineNum">    4503 </span><span class="lineCov">     462734 :           if (oe1-&gt;stmt_to_insert)</span>
<span class="lineNum">    4504 </span><span class="lineCov">         20 :             insert_stmt_before_use (stmt, oe1-&gt;stmt_to_insert);</span>
<span class="lineNum">    4505 </span><span class="lineCov">     462734 :           if (oe2-&gt;stmt_to_insert)</span>
<span class="lineNum">    4506 </span><span class="lineCov">         51 :             insert_stmt_before_use (stmt, oe2-&gt;stmt_to_insert);</span>
<span class="lineNum">    4507 </span>            :           /* Even when changed is false, reassociation could have e.g. removed
<span class="lineNum">    4508 </span>            :              some redundant operations, so unless we are just swapping the
<span class="lineNum">    4509 </span>            :              arguments or unless there is no change at all (then we just
<span class="lineNum">    4510 </span>            :              return lhs), force creation of a new SSA_NAME.  */
<span class="lineNum">    4511 </span><span class="lineCov">     462734 :           if (changed || ((rhs1 != oe2-&gt;op || rhs2 != oe1-&gt;op) &amp;&amp; opindex))</span>
<span class="lineNum">    4512 </span>            :             {
<span class="lineNum">    4513 </span><span class="lineCov">      45572 :               gimple *insert_point</span>
<span class="lineNum">    4514 </span><span class="lineCov">      45572 :                 = find_insert_point (stmt, oe1-&gt;op, oe2-&gt;op);</span>
<span class="lineNum">    4515 </span><span class="lineCov">      45572 :               lhs = make_ssa_name (TREE_TYPE (lhs));</span>
<span class="lineNum">    4516 </span><span class="lineCov">      45572 :               stmt</span>
<span class="lineNum">    4517 </span><span class="lineCov">      45572 :                 = gimple_build_assign (lhs, gimple_assign_rhs_code (stmt),</span>
<span class="lineNum">    4518 </span>            :                                        oe1-&gt;op, oe2-&gt;op);
<span class="lineNum">    4519 </span><span class="lineCov">      45572 :               gimple_set_uid (stmt, uid);</span>
<span class="lineNum">    4520 </span><span class="lineCov">      45572 :               gimple_set_visited (stmt, true);</span>
<span class="lineNum">    4521 </span><span class="lineCov">      91144 :               if (insert_point == gsi_stmt (gsi))</span>
<span class="lineNum">    4522 </span><span class="lineCov">      33837 :                 gsi_insert_before (&amp;gsi, stmt, GSI_SAME_STMT);</span>
<span class="lineNum">    4523 </span>            :               else
<span class="lineNum">    4524 </span><span class="lineCov">      11735 :                 insert_stmt_after (stmt, insert_point);</span>
<span class="lineNum">    4525 </span>            :             }
<span class="lineNum">    4526 </span>            :           else
<span class="lineNum">    4527 </span>            :             {
<span class="lineNum">    4528 </span><span class="lineCov">     417162 :               gcc_checking_assert (find_insert_point (stmt, oe1-&gt;op, oe2-&gt;op)</span>
<span class="lineNum">    4529 </span>            :                                    == stmt);
<span class="lineNum">    4530 </span><span class="lineCov">     417162 :               gimple_assign_set_rhs1 (stmt, oe1-&gt;op);</span>
<span class="lineNum">    4531 </span><span class="lineCov">     417162 :               gimple_assign_set_rhs2 (stmt, oe2-&gt;op);</span>
<span class="lineNum">    4532 </span><span class="lineCov">     417162 :               update_stmt (stmt);</span>
<span class="lineNum">    4533 </span>            :             }
<span class="lineNum">    4534 </span>            : 
<span class="lineNum">    4535 </span><span class="lineCov">     462734 :           if (rhs1 != oe1-&gt;op &amp;&amp; rhs1 != oe2-&gt;op)</span>
<span class="lineNum">    4536 </span><span class="lineCov">      32122 :             remove_visited_stmt_chain (rhs1);</span>
<span class="lineNum">    4537 </span>            : 
<span class="lineNum">    4538 </span><span class="lineCov">     462734 :           if (dump_file &amp;&amp; (dump_flags &amp; TDF_DETAILS))</span>
<span class="lineNum">    4539 </span>            :             {
<span class="lineNum">    4540 </span><span class="lineCov">         28 :               fprintf (dump_file, &quot; into &quot;);</span>
<span class="lineNum">    4541 </span><span class="lineCov">         28 :               print_gimple_stmt (dump_file, stmt, 0);</span>
<span class="lineNum">    4542 </span>            :             }
<span class="lineNum">    4543 </span>            :         }
<span class="lineNum">    4544 </span><span class="lineCov">    2379708 :       return lhs;</span>
<span class="lineNum">    4545 </span>            :     }
<span class="lineNum">    4546 </span>            : 
<span class="lineNum">    4547 </span>            :   /* If we hit here, we should have 3 or more ops left.  */
<span class="lineNum">    4548 </span><span class="lineCov">     123424 :   gcc_assert (opindex + 2 &lt; ops.length ());</span>
<span class="lineNum">    4549 </span>            : 
<span class="lineNum">    4550 </span>            :   /* Rewrite the next operator.  */
<span class="lineNum">    4551 </span><span class="lineCov">     123424 :   oe = ops[opindex];</span>
<span class="lineNum">    4552 </span>            : 
<span class="lineNum">    4553 </span>            :   /* If the stmt that defines operand has to be inserted, insert it
<span class="lineNum">    4554 </span>            :      before the use.  */
<span class="lineNum">    4555 </span><span class="lineCov">     123424 :   if (oe-&gt;stmt_to_insert)</span>
<span class="lineNum">    4556 </span><span class="lineCov">          1 :     insert_stmt_before_use (stmt, oe-&gt;stmt_to_insert);</span>
<span class="lineNum">    4557 </span>            : 
<span class="lineNum">    4558 </span>            :   /* Recurse on the LHS of the binary operator, which is guaranteed to
<span class="lineNum">    4559 </span>            :      be the non-leaf side.  */
<span class="lineNum">    4560 </span><span class="lineCov">     123424 :   tree new_rhs1</span>
<span class="lineNum">    4561 </span><span class="lineCov">     123424 :     = rewrite_expr_tree (SSA_NAME_DEF_STMT (rhs1), opindex + 1, ops,</span>
<span class="lineNum">    4562 </span><span class="lineCov">     123424 :                          changed || oe-&gt;op != rhs2 || next_changed,</span>
<span class="lineNum">    4563 </span>            :                          false);
<span class="lineNum">    4564 </span>            : 
<span class="lineNum">    4565 </span><span class="lineCov">     123424 :   if (oe-&gt;op != rhs2 || new_rhs1 != rhs1)</span>
<span class="lineNum">    4566 </span>            :     {
<span class="lineNum">    4567 </span><span class="lineCov">      56290 :       if (dump_file &amp;&amp; (dump_flags &amp; TDF_DETAILS))</span>
<span class="lineNum">    4568 </span>            :         {
<span class="lineNum">    4569 </span><span class="lineCov">          6 :           fprintf (dump_file, &quot;Transforming &quot;);</span>
<span class="lineNum">    4570 </span><span class="lineCov">          6 :           print_gimple_stmt (dump_file, stmt, 0);</span>
<span class="lineNum">    4571 </span>            :         }
<span class="lineNum">    4572 </span>            : 
<span class="lineNum">    4573 </span>            :       /* If changed is false, this is either opindex == 0
<span class="lineNum">    4574 </span>            :          or all outer rhs2's were equal to corresponding oe-&gt;op,
<span class="lineNum">    4575 </span>            :          and powi_result is NULL.
<span class="lineNum">    4576 </span>            :          That means lhs is equivalent before and after reassociation.
<span class="lineNum">    4577 </span>            :          Otherwise ensure the old lhs SSA_NAME is not reused and
<span class="lineNum">    4578 </span>            :          create a new stmt as well, so that any debug stmts will be
<span class="lineNum">    4579 </span>            :          properly adjusted.  */
<span class="lineNum">    4580 </span><span class="lineCov">      56290 :       if (changed)</span>
<span class="lineNum">    4581 </span>            :         {
<span class="lineNum">    4582 </span><span class="lineCov">      10216 :           gimple_stmt_iterator gsi = gsi_for_stmt (stmt);</span>
<span class="lineNum">    4583 </span><span class="lineCov">      10216 :           unsigned int uid = gimple_uid (stmt);</span>
<span class="lineNum">    4584 </span><span class="lineCov">      10216 :           gimple *insert_point = find_insert_point (stmt, new_rhs1, oe-&gt;op);</span>
<span class="lineNum">    4585 </span>            : 
<span class="lineNum">    4586 </span><span class="lineCov">      10216 :           lhs = make_ssa_name (TREE_TYPE (lhs));</span>
<span class="lineNum">    4587 </span><span class="lineCov">      10216 :           stmt = gimple_build_assign (lhs, gimple_assign_rhs_code (stmt),</span>
<span class="lineNum">    4588 </span>            :                                       new_rhs1, oe-&gt;op);
<span class="lineNum">    4589 </span><span class="lineCov">      10216 :           gimple_set_uid (stmt, uid);</span>
<span class="lineNum">    4590 </span><span class="lineCov">      10216 :           gimple_set_visited (stmt, true);</span>
<span class="lineNum">    4591 </span><span class="lineCov">      20432 :           if (insert_point == gsi_stmt (gsi))</span>
<span class="lineNum">    4592 </span><span class="lineCov">       5844 :             gsi_insert_before (&amp;gsi, stmt, GSI_SAME_STMT);</span>
<span class="lineNum">    4593 </span>            :           else
<span class="lineNum">    4594 </span><span class="lineCov">       4372 :             insert_stmt_after (stmt, insert_point);</span>
<span class="lineNum">    4595 </span>            :         }
<span class="lineNum">    4596 </span>            :       else
<span class="lineNum">    4597 </span>            :         {
<span class="lineNum">    4598 </span><span class="lineCov">      46074 :           gcc_checking_assert (find_insert_point (stmt, new_rhs1, oe-&gt;op)</span>
<span class="lineNum">    4599 </span>            :                                == stmt);
<span class="lineNum">    4600 </span><span class="lineCov">      46074 :           gimple_assign_set_rhs1 (stmt, new_rhs1);</span>
<span class="lineNum">    4601 </span><span class="lineCov">      46074 :           gimple_assign_set_rhs2 (stmt, oe-&gt;op);</span>
<span class="lineNum">    4602 </span><span class="lineCov">      46074 :           update_stmt (stmt);</span>
<span class="lineNum">    4603 </span>            :         }
<span class="lineNum">    4604 </span>            : 
<span class="lineNum">    4605 </span><span class="lineCov">      56290 :       if (dump_file &amp;&amp; (dump_flags &amp; TDF_DETAILS))</span>
<span class="lineNum">    4606 </span>            :         {
<span class="lineNum">    4607 </span><span class="lineCov">          6 :           fprintf (dump_file, &quot; into &quot;);</span>
<span class="lineNum">    4608 </span><span class="lineCov">          6 :           print_gimple_stmt (dump_file, stmt, 0);</span>
<span class="lineNum">    4609 </span>            :         }
<span class="lineNum">    4610 </span>            :     }
<span class="lineNum">    4611 </span>            :   return lhs;
<span class="lineNum">    4612 </span>            : }
<span class="lineNum">    4613 </span>            : 
<span class="lineNum">    4614 </span>            : /* Find out how many cycles we need to compute statements chain.
<span class="lineNum">    4615 </span>            :    OPS_NUM holds number os statements in a chain.  CPU_WIDTH is a
<span class="lineNum">    4616 </span>            :    maximum number of independent statements we may execute per cycle.  */
<a name="4617"><span class="lineNum">    4617 </span>            : </a>
<span class="lineNum">    4618 </span>            : static int
<span class="lineNum">    4619 </span><span class="lineNoCov">          0 : get_required_cycles (int ops_num, int cpu_width)</span>
<span class="lineNum">    4620 </span>            : {
<span class="lineNum">    4621 </span><span class="lineCov">     244428 :   int res;</span>
<span class="lineNum">    4622 </span><span class="lineCov">     244428 :   int elog;</span>
<span class="lineNum">    4623 </span><span class="lineCov">     244428 :   unsigned int rest;</span>
<span class="lineNum">    4624 </span>            : 
<span class="lineNum">    4625 </span>            :   /* While we have more than 2 * cpu_width operands
<span class="lineNum">    4626 </span>            :      we may reduce number of operands by cpu_width
<span class="lineNum">    4627 </span>            :      per cycle.  */
<span class="lineNum">    4628 </span><span class="lineCov">     244428 :   res = ops_num / (2 * cpu_width);</span>
<span class="lineNum">    4629 </span>            : 
<span class="lineNum">    4630 </span>            :   /* Remained operands count may be reduced twice per cycle
<span class="lineNum">    4631 </span>            :      until we have only one operand.  */
<span class="lineNum">    4632 </span><span class="lineCov">     244428 :   rest = (unsigned)(ops_num - res * cpu_width);</span>
<span class="lineNum">    4633 </span><span class="lineNoCov">          0 :   elog = exact_log2 (rest);</span>
<span class="lineNum">    4634 </span><span class="lineCov">     224166 :   if (elog &gt;= 0)</span>
<span class="lineNum">    4635 </span><span class="lineCov">     224166 :     res += elog;</span>
<span class="lineNum">    4636 </span>            :   else
<span class="lineNum">    4637 </span><span class="lineCov">      40524 :     res += floor_log2 (rest) + 1;</span>
<span class="lineNum">    4638 </span>            : 
<span class="lineNum">    4639 </span><span class="lineCov">     244428 :   return res;</span>
<span class="lineNum">    4640 </span>            : }
<span class="lineNum">    4641 </span>            : 
<span class="lineNum">    4642 </span>            : /* Returns an optimal number of registers to use for computation of
<span class="lineNum">    4643 </span>            :    given statements.  */
<a name="4644"><span class="lineNum">    4644 </span>            : </a>
<span class="lineNum">    4645 </span>            : static int
<span class="lineNum">    4646 </span><span class="lineCov">    2381441 : get_reassociation_width (int ops_num, enum tree_code opc,</span>
<span class="lineNum">    4647 </span>            :                          machine_mode mode)
<span class="lineNum">    4648 </span>            : {
<span class="lineNum">    4649 </span><span class="lineCov">    2381441 :   int param_width = PARAM_VALUE (PARAM_TREE_REASSOC_WIDTH);</span>
<span class="lineNum">    4650 </span><span class="lineCov">    2381441 :   int width;</span>
<span class="lineNum">    4651 </span><span class="lineCov">    2381441 :   int width_min;</span>
<span class="lineNum">    4652 </span><span class="lineCov">    2381441 :   int cycles_best;</span>
<span class="lineNum">    4653 </span>            : 
<span class="lineNum">    4654 </span><span class="lineCov">    2381441 :   if (param_width &gt; 0)</span>
<span class="lineNum">    4655 </span>            :     width = param_width;
<span class="lineNum">    4656 </span>            :   else
<span class="lineNum">    4657 </span><span class="lineCov">    2380859 :     width = targetm.sched.reassociation_width (opc, mode);</span>
<span class="lineNum">    4658 </span>            : 
<span class="lineNum">    4659 </span><span class="lineCov">    2381441 :   if (width == 1)</span>
<span class="lineNum">    4660 </span>            :     return width;
<span class="lineNum">    4661 </span>            : 
<span class="lineNum">    4662 </span>            :   /* Get the minimal time required for sequence computation.  */
<span class="lineNum">    4663 </span><span class="lineCov">      94094 :   cycles_best = get_required_cycles (ops_num, width);</span>
<span class="lineNum">    4664 </span>            : 
<span class="lineNum">    4665 </span>            :   /* Check if we may use less width and still compute sequence for
<span class="lineNum">    4666 </span>            :      the same time.  It will allow us to reduce registers usage.
<span class="lineNum">    4667 </span>            :      get_required_cycles is monotonically increasing with lower width
<span class="lineNum">    4668 </span>            :      so we can perform a binary search for the minimal width that still
<span class="lineNum">    4669 </span>            :      results in the optimal cycle count.  */
<span class="lineNum">    4670 </span><span class="lineCov">      94094 :   width_min = 1;</span>
<span class="lineNum">    4671 </span><span class="lineCov">     242695 :   while (width &gt; width_min)</span>
<span class="lineNum">    4672 </span>            :     {
<span class="lineNum">    4673 </span><span class="lineCov">     150334 :       int width_mid = (width + width_min) / 2;</span>
<span class="lineNum">    4674 </span>            : 
<span class="lineNum">    4675 </span><span class="lineCov">     300668 :       if (get_required_cycles (ops_num, width_mid) == cycles_best)</span>
<span class="lineNum">    4676 </span>            :         width = width_mid;
<span class="lineNum">    4677 </span><span class="lineCov">       2155 :       else if (width_min &lt; width_mid)</span>
<span class="lineNum">    4678 </span>            :         width_min = width_mid;
<span class="lineNum">    4679 </span>            :       else
<span class="lineNum">    4680 </span>            :         break;
<span class="lineNum">    4681 </span>            :     }
<span class="lineNum">    4682 </span>            : 
<span class="lineNum">    4683 </span>            :   return width;
<span class="lineNum">    4684 </span>            : }
<span class="lineNum">    4685 </span>            : 
<span class="lineNum">    4686 </span>            : /* Recursively rewrite our linearized statements so that the operators
<span class="lineNum">    4687 </span>            :    match those in OPS[OPINDEX], putting the computation in rank
<span class="lineNum">    4688 </span>            :    order and trying to allow operations to be executed in
<span class="lineNum">    4689 </span>            :    parallel.  */
<span class="lineNum">    4690 </span>            : 
<span class="lineNum">    4691 </span>            : static void
<span class="lineNum">    4692 </span><span class="lineCov">       1733 : rewrite_expr_tree_parallel (gassign *stmt, int width,</span>
<span class="lineNum">    4693 </span>            :                             vec&lt;operand_entry *&gt; ops)
<span class="lineNum">    4694 </span>            : {
<span class="lineNum">    4695 </span><span class="lineCov">       1733 :   enum tree_code opcode = gimple_assign_rhs_code (stmt);</span>
<span class="lineNum">    4696 </span><span class="lineCov">       1733 :   int op_num = ops.length ();</span>
<span class="lineNum">    4697 </span><span class="lineCov">       1733 :   gcc_assert (op_num &gt; 0);</span>
<span class="lineNum">    4698 </span><span class="lineCov">       1733 :   int stmt_num = op_num - 1;</span>
<span class="lineNum">    4699 </span><span class="lineCov">       1733 :   gimple **stmts = XALLOCAVEC (gimple *, stmt_num);</span>
<span class="lineNum">    4700 </span><span class="lineCov">       1733 :   int op_index = op_num - 1;</span>
<span class="lineNum">    4701 </span><span class="lineCov">       1733 :   int stmt_index = 0;</span>
<span class="lineNum">    4702 </span><span class="lineCov">       1733 :   int ready_stmts_end = 0;</span>
<span class="lineNum">    4703 </span><span class="lineCov">       1733 :   int i = 0;</span>
<span class="lineNum">    4704 </span><span class="lineCov">       1733 :   gimple *stmt1 = NULL, *stmt2 = NULL;</span>
<span class="lineNum">    4705 </span><span class="lineCov">       1733 :   tree last_rhs1 = gimple_assign_rhs1 (stmt);</span>
<span class="lineNum">    4706 </span>            : 
<span class="lineNum">    4707 </span>            :   /* We start expression rewriting from the top statements.
<span class="lineNum">    4708 </span>            :      So, in this loop we create a full list of statements
<span class="lineNum">    4709 </span>            :      we will work with.  */
<span class="lineNum">    4710 </span><span class="lineCov">       1733 :   stmts[stmt_num - 1] = stmt;</span>
<span class="lineNum">    4711 </span><span class="lineCov">       8073 :   for (i = stmt_num - 2; i &gt;= 0; i--)</span>
<span class="lineNum">    4712 </span><span class="lineCov">       6340 :     stmts[i] = SSA_NAME_DEF_STMT (gimple_assign_rhs1 (stmts[i+1]));</span>
<span class="lineNum">    4713 </span>            : 
<span class="lineNum">    4714 </span><span class="lineCov">       9806 :   for (i = 0; i &lt; stmt_num; i++)</span>
<span class="lineNum">    4715 </span>            :     {
<span class="lineNum">    4716 </span><span class="lineCov">       8073 :       tree op1, op2;</span>
<span class="lineNum">    4717 </span>            : 
<span class="lineNum">    4718 </span>            :       /* Determine whether we should use results of
<span class="lineNum">    4719 </span>            :          already handled statements or not.  */
<span class="lineNum">    4720 </span><span class="lineCov">       8073 :       if (ready_stmts_end == 0</span>
<span class="lineNum">    4721 </span><span class="lineCov">       7497 :           &amp;&amp; (i - stmt_index &gt;= width || op_index &lt; 1))</span>
<span class="lineNum">    4722 </span><span class="lineCov">       2846 :         ready_stmts_end = i;</span>
<span class="lineNum">    4723 </span>            : 
<span class="lineNum">    4724 </span>            :       /* Now we choose operands for the next statement.  Non zero
<span class="lineNum">    4725 </span>            :          value in ready_stmts_end means here that we should use
<span class="lineNum">    4726 </span>            :          the result of already generated statements as new operand.  */
<span class="lineNum">    4727 </span><span class="lineCov">       8073 :       if (ready_stmts_end &gt; 0)</span>
<span class="lineNum">    4728 </span>            :         {
<span class="lineNum">    4729 </span><span class="lineCov">       3422 :           op1 = gimple_assign_lhs (stmts[stmt_index++]);</span>
<span class="lineNum">    4730 </span><span class="lineCov">       3422 :           if (ready_stmts_end &gt; stmt_index)</span>
<span class="lineNum">    4731 </span><span class="lineCov">       2911 :             op2 = gimple_assign_lhs (stmts[stmt_index++]);</span>
<span class="lineNum">    4732 </span><span class="lineCov">        511 :           else if (op_index &gt;= 0)</span>
<span class="lineNum">    4733 </span>            :             {
<span class="lineNum">    4734 </span><span class="lineCov">        504 :               operand_entry *oe = ops[op_index--];</span>
<span class="lineNum">    4735 </span><span class="lineCov">        504 :               stmt2 = oe-&gt;stmt_to_insert;</span>
<span class="lineNum">    4736 </span><span class="lineCov">        504 :               op2 = oe-&gt;op;</span>
<span class="lineNum">    4737 </span>            :             }
<span class="lineNum">    4738 </span>            :           else
<span class="lineNum">    4739 </span>            :             {
<span class="lineNum">    4740 </span><span class="lineCov">          7 :               gcc_assert (stmt_index &lt; i);</span>
<span class="lineNum">    4741 </span><span class="lineCov">          7 :               op2 = gimple_assign_lhs (stmts[stmt_index++]);</span>
<span class="lineNum">    4742 </span>            :             }
<span class="lineNum">    4743 </span>            : 
<span class="lineNum">    4744 </span><span class="lineCov">       3422 :           if (stmt_index &gt;= ready_stmts_end)</span>
<span class="lineNum">    4745 </span><span class="lineCov">       2846 :             ready_stmts_end = 0;</span>
<span class="lineNum">    4746 </span>            :         }
<span class="lineNum">    4747 </span>            :       else
<span class="lineNum">    4748 </span>            :         {
<span class="lineNum">    4749 </span><span class="lineCov">       4651 :           if (op_index &gt; 1)</span>
<span class="lineNum">    4750 </span><span class="lineCov">       3290 :             swap_ops_for_binary_stmt (ops, op_index - 2, NULL);</span>
<span class="lineNum">    4751 </span><span class="lineCov">       4651 :           operand_entry *oe2 = ops[op_index--];</span>
<span class="lineNum">    4752 </span><span class="lineCov">       4651 :           operand_entry *oe1 = ops[op_index--];</span>
<span class="lineNum">    4753 </span><span class="lineCov">       4651 :           op2 = oe2-&gt;op;</span>
<span class="lineNum">    4754 </span><span class="lineCov">       4651 :           stmt2 = oe2-&gt;stmt_to_insert;</span>
<span class="lineNum">    4755 </span><span class="lineCov">       4651 :           op1 = oe1-&gt;op;</span>
<span class="lineNum">    4756 </span><span class="lineCov">       4651 :           stmt1 = oe1-&gt;stmt_to_insert;</span>
<span class="lineNum">    4757 </span>            :         }
<span class="lineNum">    4758 </span>            : 
<span class="lineNum">    4759 </span>            :       /* If we emit the last statement then we should put
<span class="lineNum">    4760 </span>            :          operands into the last statement.  It will also
<span class="lineNum">    4761 </span>            :          break the loop.  */
<span class="lineNum">    4762 </span><span class="lineCov">       8073 :       if (op_index &lt; 0 &amp;&amp; stmt_index == i)</span>
<span class="lineNum">    4763 </span><span class="lineCov">       1733 :         i = stmt_num - 1;</span>
<span class="lineNum">    4764 </span>            : 
<span class="lineNum">    4765 </span><span class="lineCov">       8073 :       if (dump_file &amp;&amp; (dump_flags &amp; TDF_DETAILS))</span>
<span class="lineNum">    4766 </span>            :         {
<span class="lineNum">    4767 </span><span class="lineCov">          3 :           fprintf (dump_file, &quot;Transforming &quot;);</span>
<span class="lineNum">    4768 </span><span class="lineCov">          3 :           print_gimple_stmt (dump_file, stmts[i], 0);</span>
<span class="lineNum">    4769 </span>            :         }
<span class="lineNum">    4770 </span>            : 
<span class="lineNum">    4771 </span>            :       /* If the stmt that defines operand has to be inserted, insert it
<span class="lineNum">    4772 </span>            :          before the use.  */
<span class="lineNum">    4773 </span><span class="lineCov">       8073 :       if (stmt1)</span>
<span class="lineNum">    4774 </span><span class="lineNoCov">          0 :         insert_stmt_before_use (stmts[i], stmt1);</span>
<span class="lineNum">    4775 </span><span class="lineCov">       8073 :       if (stmt2)</span>
<span class="lineNum">    4776 </span><span class="lineCov">          1 :         insert_stmt_before_use (stmts[i], stmt2);</span>
<span class="lineNum">    4777 </span><span class="lineCov">       8073 :       stmt1 = stmt2 = NULL;</span>
<span class="lineNum">    4778 </span>            : 
<span class="lineNum">    4779 </span>            :       /* We keep original statement only for the last one.  All
<span class="lineNum">    4780 </span>            :          others are recreated.  */
<span class="lineNum">    4781 </span><span class="lineCov">       8073 :       if (i == stmt_num - 1)</span>
<span class="lineNum">    4782 </span>            :         {
<span class="lineNum">    4783 </span><span class="lineCov">       1733 :           gimple_assign_set_rhs1 (stmts[i], op1);</span>
<span class="lineNum">    4784 </span><span class="lineCov">       1733 :           gimple_assign_set_rhs2 (stmts[i], op2);</span>
<span class="lineNum">    4785 </span><span class="lineCov">       1733 :           update_stmt (stmts[i]);</span>
<span class="lineNum">    4786 </span>            :         }
<span class="lineNum">    4787 </span>            :       else
<span class="lineNum">    4788 </span>            :         {
<span class="lineNum">    4789 </span><span class="lineCov">       6340 :           stmts[i] = build_and_add_sum (TREE_TYPE (last_rhs1), op1, op2, opcode);</span>
<span class="lineNum">    4790 </span>            :         }
<span class="lineNum">    4791 </span><span class="lineCov">       8073 :       if (dump_file &amp;&amp; (dump_flags &amp; TDF_DETAILS))</span>
<span class="lineNum">    4792 </span>            :         {
<span class="lineNum">    4793 </span><span class="lineCov">          3 :           fprintf (dump_file, &quot; into &quot;);</span>
<span class="lineNum">    4794 </span><span class="lineCov">          3 :           print_gimple_stmt (dump_file, stmts[i], 0);</span>
<span class="lineNum">    4795 </span>            :         }
<span class="lineNum">    4796 </span>            :     }
<span class="lineNum">    4797 </span>            : 
<span class="lineNum">    4798 </span><span class="lineCov">       1733 :   remove_visited_stmt_chain (last_rhs1);</span>
<span class="lineNum">    4799 </span><span class="lineCov">       1733 : }</span>
<span class="lineNum">    4800 </span>            : 
<span class="lineNum">    4801 </span>            : /* Transform STMT, which is really (A +B) + (C + D) into the left
<span class="lineNum">    4802 </span>            :    linear form, ((A+B)+C)+D.
<span class="lineNum">    4803 </span>            :    Recurse on D if necessary.  */
<a name="4804"><span class="lineNum">    4804 </span>            : </a>
<span class="lineNum">    4805 </span>            : static void
<span class="lineNum">    4806 </span><span class="lineCov">       3597 : linearize_expr (gimple *stmt)</span>
<span class="lineNum">    4807 </span>            : {
<span class="lineNum">    4808 </span><span class="lineCov">       3597 :   gimple_stmt_iterator gsi;</span>
<span class="lineNum">    4809 </span><span class="lineCov">       3597 :   gimple *binlhs = SSA_NAME_DEF_STMT (gimple_assign_rhs1 (stmt));</span>
<span class="lineNum">    4810 </span><span class="lineCov">       3597 :   gimple *binrhs = SSA_NAME_DEF_STMT (gimple_assign_rhs2 (stmt));</span>
<span class="lineNum">    4811 </span><span class="lineCov">       3597 :   gimple *oldbinrhs = binrhs;</span>
<span class="lineNum">    4812 </span><span class="lineCov">       3597 :   enum tree_code rhscode = gimple_assign_rhs_code (stmt);</span>
<span class="lineNum">    4813 </span><span class="lineCov">       3597 :   gimple *newbinrhs = NULL;</span>
<span class="lineNum">    4814 </span><span class="lineCov">       3597 :   struct loop *loop = loop_containing_stmt (stmt);</span>
<span class="lineNum">    4815 </span><span class="lineCov">       3597 :   tree lhs = gimple_assign_lhs (stmt);</span>
<span class="lineNum">    4816 </span>            : 
<span class="lineNum">    4817 </span><span class="lineCov">       3597 :   gcc_assert (is_reassociable_op (binlhs, rhscode, loop)</span>
<span class="lineNum">    4818 </span>            :               &amp;&amp; is_reassociable_op (binrhs, rhscode, loop));
<span class="lineNum">    4819 </span>            : 
<span class="lineNum">    4820 </span><span class="lineCov">       3597 :   gsi = gsi_for_stmt (stmt);</span>
<span class="lineNum">    4821 </span>            : 
<span class="lineNum">    4822 </span><span class="lineCov">       3597 :   gimple_assign_set_rhs2 (stmt, gimple_assign_rhs1 (binrhs));</span>
<span class="lineNum">    4823 </span><span class="lineCov">       3597 :   binrhs = gimple_build_assign (make_ssa_name (TREE_TYPE (lhs)),</span>
<span class="lineNum">    4824 </span>            :                                 gimple_assign_rhs_code (binrhs),
<span class="lineNum">    4825 </span>            :                                 gimple_assign_lhs (binlhs),
<span class="lineNum">    4826 </span>            :                                 gimple_assign_rhs2 (binrhs));
<span class="lineNum">    4827 </span><span class="lineCov">       3597 :   gimple_assign_set_rhs1 (stmt, gimple_assign_lhs (binrhs));</span>
<span class="lineNum">    4828 </span><span class="lineCov">       3597 :   gsi_insert_before (&amp;gsi, binrhs, GSI_SAME_STMT);</span>
<span class="lineNum">    4829 </span><span class="lineCov">       7194 :   gimple_set_uid (binrhs, gimple_uid (stmt));</span>
<span class="lineNum">    4830 </span>            : 
<span class="lineNum">    4831 </span><span class="lineCov">       3597 :   if (TREE_CODE (gimple_assign_rhs2 (stmt)) == SSA_NAME)</span>
<span class="lineNum">    4832 </span><span class="lineCov">       7192 :     newbinrhs = SSA_NAME_DEF_STMT (gimple_assign_rhs2 (stmt));</span>
<span class="lineNum">    4833 </span>            : 
<span class="lineNum">    4834 </span><span class="lineCov">       3597 :   if (dump_file &amp;&amp; (dump_flags &amp; TDF_DETAILS))</span>
<span class="lineNum">    4835 </span>            :     {
<span class="lineNum">    4836 </span><span class="lineNoCov">          0 :       fprintf (dump_file, &quot;Linearized: &quot;);</span>
<span class="lineNum">    4837 </span><span class="lineNoCov">          0 :       print_gimple_stmt (dump_file, stmt, 0);</span>
<span class="lineNum">    4838 </span>            :     }
<span class="lineNum">    4839 </span>            : 
<span class="lineNum">    4840 </span><span class="lineCov">       3597 :   reassociate_stats.linearized++;</span>
<span class="lineNum">    4841 </span><span class="lineCov">       3597 :   update_stmt (stmt);</span>
<span class="lineNum">    4842 </span>            : 
<span class="lineNum">    4843 </span><span class="lineCov">       3597 :   gsi = gsi_for_stmt (oldbinrhs);</span>
<span class="lineNum">    4844 </span><span class="lineCov">       3597 :   reassoc_remove_stmt (&amp;gsi);</span>
<span class="lineNum">    4845 </span><span class="lineCov">       3597 :   release_defs (oldbinrhs);</span>
<span class="lineNum">    4846 </span>            : 
<span class="lineNum">    4847 </span><span class="lineCov">       3597 :   gimple_set_visited (stmt, true);</span>
<span class="lineNum">    4848 </span><span class="lineCov">       3597 :   gimple_set_visited (binlhs, true);</span>
<span class="lineNum">    4849 </span><span class="lineCov">       3597 :   gimple_set_visited (binrhs, true);</span>
<span class="lineNum">    4850 </span>            : 
<span class="lineNum">    4851 </span>            :   /* Tail recurse on the new rhs if it still needs reassociation.  */
<span class="lineNum">    4852 </span><span class="lineCov">       3597 :   if (newbinrhs &amp;&amp; is_reassociable_op (newbinrhs, rhscode, loop))</span>
<span class="lineNum">    4853 </span>            :     /* ??? This should probably be linearize_expr (newbinrhs) but I don't
<span class="lineNum">    4854 </span>            :            want to change the algorithm while converting to tuples.  */
<span class="lineNum">    4855 </span><span class="lineCov">        745 :     linearize_expr (stmt);</span>
<span class="lineNum">    4856 </span><span class="lineCov">       3597 : }</span>
<span class="lineNum">    4857 </span>            : 
<span class="lineNum">    4858 </span>            : /* If LHS has a single immediate use that is a GIMPLE_ASSIGN statement, return
<span class="lineNum">    4859 </span>            :    it.  Otherwise, return NULL.  */
<a name="4860"><span class="lineNum">    4860 </span>            : </a>
<span class="lineNum">    4861 </span>            : static gimple *
<span class="lineNum">    4862 </span><span class="lineCov">     239699 : get_single_immediate_use (tree lhs)</span>
<span class="lineNum">    4863 </span>            : {
<span class="lineNum">    4864 </span><span class="lineCov">     239699 :   use_operand_p immuse;</span>
<span class="lineNum">    4865 </span><span class="lineCov">     239699 :   gimple *immusestmt;</span>
<span class="lineNum">    4866 </span>            : 
<span class="lineNum">    4867 </span><span class="lineCov">     239699 :   if (TREE_CODE (lhs) == SSA_NAME</span>
<span class="lineNum">    4868 </span><span class="lineCov">     239699 :       &amp;&amp; single_imm_use (lhs, &amp;immuse, &amp;immusestmt)</span>
<span class="lineNum">    4869 </span><span class="lineCov">     627213 :       &amp;&amp; is_gimple_assign (immusestmt))</span>
<span class="lineNum">    4870 </span><span class="lineCov">     154417 :     return immusestmt;</span>
<span class="lineNum">    4871 </span>            : 
<span class="lineNum">    4872 </span>            :   return NULL;
<span class="lineNum">    4873 </span>            : }
<span class="lineNum">    4874 </span>            : 
<span class="lineNum">    4875 </span>            : /* Recursively negate the value of TONEGATE, and return the SSA_NAME
<span class="lineNum">    4876 </span>            :    representing the negated value.  Insertions of any necessary
<span class="lineNum">    4877 </span>            :    instructions go before GSI.
<span class="lineNum">    4878 </span>            :    This function is recursive in that, if you hand it &quot;a_5&quot; as the
<span class="lineNum">    4879 </span>            :    value to negate, and a_5 is defined by &quot;a_5 = b_3 + b_4&quot;, it will
<span class="lineNum">    4880 </span>            :    transform b_3 + b_4 into a_5 = -b_3 + -b_4.  */
<a name="4881"><span class="lineNum">    4881 </span>            : </a>
<span class="lineNum">    4882 </span>            : static tree
<span class="lineNum">    4883 </span><span class="lineCov">      47981 : negate_value (tree tonegate, gimple_stmt_iterator *gsip)</span>
<span class="lineNum">    4884 </span>            : {
<span class="lineNum">    4885 </span><span class="lineCov">      47981 :   gimple *negatedefstmt = NULL;</span>
<span class="lineNum">    4886 </span><span class="lineCov">      47981 :   tree resultofnegate;</span>
<span class="lineNum">    4887 </span><span class="lineCov">      47981 :   gimple_stmt_iterator gsi;</span>
<span class="lineNum">    4888 </span><span class="lineCov">      47981 :   unsigned int uid;</span>
<span class="lineNum">    4889 </span>            : 
<span class="lineNum">    4890 </span>            :   /* If we are trying to negate a name, defined by an add, negate the
<span class="lineNum">    4891 </span>            :      add operands instead.  */
<span class="lineNum">    4892 </span><span class="lineCov">      47981 :   if (TREE_CODE (tonegate) == SSA_NAME)</span>
<span class="lineNum">    4893 </span><span class="lineCov">      90808 :     negatedefstmt = SSA_NAME_DEF_STMT (tonegate);</span>
<span class="lineNum">    4894 </span><span class="lineCov">      47981 :   if (TREE_CODE (tonegate) == SSA_NAME</span>
<span class="lineNum">    4895 </span><span class="lineCov">      90808 :       &amp;&amp; is_gimple_assign (negatedefstmt)</span>
<span class="lineNum">    4896 </span><span class="lineCov">      81800 :       &amp;&amp; TREE_CODE (gimple_assign_lhs (negatedefstmt)) == SSA_NAME</span>
<span class="lineNum">    4897 </span><span class="lineCov">      81800 :       &amp;&amp; has_single_use (gimple_assign_lhs (negatedefstmt))</span>
<span class="lineNum">    4898 </span><span class="lineCov">      79440 :       &amp;&amp; gimple_assign_rhs_code (negatedefstmt) == PLUS_EXPR)</span>
<span class="lineNum">    4899 </span>            :     {
<span class="lineNum">    4900 </span><span class="lineCov">        619 :       tree rhs1 = gimple_assign_rhs1 (negatedefstmt);</span>
<span class="lineNum">    4901 </span><span class="lineCov">        619 :       tree rhs2 = gimple_assign_rhs2 (negatedefstmt);</span>
<span class="lineNum">    4902 </span><span class="lineCov">        619 :       tree lhs = gimple_assign_lhs (negatedefstmt);</span>
<span class="lineNum">    4903 </span><span class="lineCov">        619 :       gimple *g;</span>
<span class="lineNum">    4904 </span>            : 
<span class="lineNum">    4905 </span><span class="lineCov">        619 :       gsi = gsi_for_stmt (negatedefstmt);</span>
<span class="lineNum">    4906 </span><span class="lineCov">        619 :       rhs1 = negate_value (rhs1, &amp;gsi);</span>
<span class="lineNum">    4907 </span>            : 
<span class="lineNum">    4908 </span><span class="lineCov">        619 :       gsi = gsi_for_stmt (negatedefstmt);</span>
<span class="lineNum">    4909 </span><span class="lineCov">        619 :       rhs2 = negate_value (rhs2, &amp;gsi);</span>
<span class="lineNum">    4910 </span>            : 
<span class="lineNum">    4911 </span><span class="lineCov">        619 :       gsi = gsi_for_stmt (negatedefstmt);</span>
<span class="lineNum">    4912 </span><span class="lineCov">        619 :       lhs = make_ssa_name (TREE_TYPE (lhs));</span>
<span class="lineNum">    4913 </span><span class="lineCov">        619 :       gimple_set_visited (negatedefstmt, true);</span>
<span class="lineNum">    4914 </span><span class="lineCov">        619 :       g = gimple_build_assign (lhs, PLUS_EXPR, rhs1, rhs2);</span>
<span class="lineNum">    4915 </span><span class="lineCov">       1238 :       gimple_set_uid (g, gimple_uid (negatedefstmt));</span>
<span class="lineNum">    4916 </span><span class="lineCov">        619 :       gsi_insert_before (&amp;gsi, g, GSI_SAME_STMT);</span>
<span class="lineNum">    4917 </span><span class="lineCov">        619 :       return lhs;</span>
<span class="lineNum">    4918 </span>            :     }
<span class="lineNum">    4919 </span>            : 
<span class="lineNum">    4920 </span><span class="lineCov">      47362 :   tonegate = fold_build1 (NEGATE_EXPR, TREE_TYPE (tonegate), tonegate);</span>
<span class="lineNum">    4921 </span><span class="lineCov">      47362 :   resultofnegate = force_gimple_operand_gsi (gsip, tonegate, true,</span>
<span class="lineNum">    4922 </span>            :                                              NULL_TREE, true, GSI_SAME_STMT);
<span class="lineNum">    4923 </span><span class="lineCov">      47362 :   gsi = *gsip;</span>
<span class="lineNum">    4924 </span><span class="lineCov">      94724 :   uid = gimple_uid (gsi_stmt (gsi));</span>
<span class="lineNum">    4925 </span><span class="lineCov">     231656 :   for (gsi_prev (&amp;gsi); !gsi_end_p (gsi); gsi_prev (&amp;gsi))</span>
<span class="lineNum">    4926 </span>            :     {
<span class="lineNum">    4927 </span><span class="lineCov">      90403 :       gimple *stmt = gsi_stmt (gsi);</span>
<span class="lineNum">    4928 </span><span class="lineCov">     180806 :       if (gimple_uid (stmt) != 0)</span>
<span class="lineNum">    4929 </span>            :         break;
<span class="lineNum">    4930 </span><span class="lineCov">      89570 :       gimple_set_uid (stmt, uid);</span>
<span class="lineNum">    4931 </span>            :     }
<span class="lineNum">    4932 </span>            :   return resultofnegate;
<span class="lineNum">    4933 </span>            : }
<span class="lineNum">    4934 </span>            : 
<span class="lineNum">    4935 </span>            : /* Return true if we should break up the subtract in STMT into an add
<span class="lineNum">    4936 </span>            :    with negate.  This is true when we the subtract operands are really
<span class="lineNum">    4937 </span>            :    adds, or the subtract itself is used in an add expression.  In
<span class="lineNum">    4938 </span>            :    either case, breaking up the subtract into an add with negate
<span class="lineNum">    4939 </span>            :    exposes the adds to reassociation.  */
<a name="4940"><span class="lineNum">    4940 </span>            : </a>
<span class="lineNum">    4941 </span>            : static bool
<span class="lineNum">    4942 </span><span class="lineCov">     172703 : should_break_up_subtract (gimple *stmt)</span>
<span class="lineNum">    4943 </span>            : {
<span class="lineNum">    4944 </span><span class="lineCov">     172703 :   tree lhs = gimple_assign_lhs (stmt);</span>
<span class="lineNum">    4945 </span><span class="lineCov">     172703 :   tree binlhs = gimple_assign_rhs1 (stmt);</span>
<span class="lineNum">    4946 </span><span class="lineCov">     172703 :   tree binrhs = gimple_assign_rhs2 (stmt);</span>
<span class="lineNum">    4947 </span><span class="lineCov">     172703 :   gimple *immusestmt;</span>
<span class="lineNum">    4948 </span><span class="lineCov">     172703 :   struct loop *loop = loop_containing_stmt (stmt);</span>
<span class="lineNum">    4949 </span>            : 
<span class="lineNum">    4950 </span><span class="lineCov">     172703 :   if (TREE_CODE (binlhs) == SSA_NAME</span>
<span class="lineNum">    4951 </span><span class="lineCov">     172703 :       &amp;&amp; is_reassociable_op (SSA_NAME_DEF_STMT (binlhs), PLUS_EXPR, loop))</span>
<span class="lineNum">    4952 </span>            :     return true;
<span class="lineNum">    4953 </span>            : 
<span class="lineNum">    4954 </span><span class="lineCov">     165217 :   if (TREE_CODE (binrhs) == SSA_NAME</span>
<span class="lineNum">    4955 </span><span class="lineCov">     165217 :       &amp;&amp; is_reassociable_op (SSA_NAME_DEF_STMT (binrhs), PLUS_EXPR, loop))</span>
<span class="lineNum">    4956 </span>            :     return true;
<span class="lineNum">    4957 </span>            : 
<span class="lineNum">    4958 </span><span class="lineCov">     164761 :   if (TREE_CODE (lhs) == SSA_NAME</span>
<span class="lineNum">    4959 </span><span class="lineCov">     164761 :       &amp;&amp; (immusestmt = get_single_immediate_use (lhs))</span>
<span class="lineNum">    4960 </span><span class="lineCov">     179328 :       &amp;&amp; is_gimple_assign (immusestmt)</span>
<span class="lineNum">    4961 </span><span class="lineCov">     254425 :       &amp;&amp; (gimple_assign_rhs_code (immusestmt) == PLUS_EXPR</span>
<span class="lineNum">    4962 </span><span class="lineCov">      62973 :           || (gimple_assign_rhs_code (immusestmt) == MINUS_EXPR</span>
<span class="lineNum">    4963 </span><span class="lineCov">       4078 :               &amp;&amp; gimple_assign_rhs1 (immusestmt) == lhs)</span>
<span class="lineNum">    4964 </span><span class="lineCov">      60961 :           || gimple_assign_rhs_code (immusestmt) == MULT_EXPR))</span>
<span class="lineNum">    4965 </span><span class="lineCov">      38801 :     return true;</span>
<span class="lineNum">    4966 </span>            :   return false;
<span class="lineNum">    4967 </span>            : }
<span class="lineNum">    4968 </span>            : 
<span class="lineNum">    4969 </span>            : /* Transform STMT from A - B into A + -B.  */
<a name="4970"><span class="lineNum">    4970 </span>            : </a>
<span class="lineNum">    4971 </span>            : static void
<span class="lineNum">    4972 </span><span class="lineCov">      46743 : break_up_subtract (gimple *stmt, gimple_stmt_iterator *gsip)</span>
<span class="lineNum">    4973 </span>            : {
<span class="lineNum">    4974 </span><span class="lineCov">      46743 :   tree rhs1 = gimple_assign_rhs1 (stmt);</span>
<span class="lineNum">    4975 </span><span class="lineCov">      46743 :   tree rhs2 = gimple_assign_rhs2 (stmt);</span>
<span class="lineNum">    4976 </span>            : 
<span class="lineNum">    4977 </span><span class="lineCov">      46743 :   if (dump_file &amp;&amp; (dump_flags &amp; TDF_DETAILS))</span>
<span class="lineNum">    4978 </span>            :     {
<span class="lineNum">    4979 </span><span class="lineNoCov">          0 :       fprintf (dump_file, &quot;Breaking up subtract &quot;);</span>
<span class="lineNum">    4980 </span><span class="lineNoCov">          0 :       print_gimple_stmt (dump_file, stmt, 0);</span>
<span class="lineNum">    4981 </span>            :     }
<span class="lineNum">    4982 </span>            : 
<span class="lineNum">    4983 </span><span class="lineCov">      46743 :   rhs2 = negate_value (rhs2, gsip);</span>
<span class="lineNum">    4984 </span><span class="lineCov">      46743 :   gimple_assign_set_rhs_with_ops (gsip, PLUS_EXPR, rhs1, rhs2);</span>
<span class="lineNum">    4985 </span><span class="lineCov">      46743 :   update_stmt (stmt);</span>
<span class="lineNum">    4986 </span><span class="lineCov">      46743 : }</span>
<span class="lineNum">    4987 </span>            : 
<span class="lineNum">    4988 </span>            : /* Determine whether STMT is a builtin call that raises an SSA name
<span class="lineNum">    4989 </span>            :    to an integer power and has only one use.  If so, and this is early
<span class="lineNum">    4990 </span>            :    reassociation and unsafe math optimizations are permitted, place
<span class="lineNum">    4991 </span>            :    the SSA name in *BASE and the exponent in *EXPONENT, and return TRUE.
<span class="lineNum">    4992 </span>            :    If any of these conditions does not hold, return FALSE.  */
<a name="4993"><span class="lineNum">    4993 </span>            : </a>
<span class="lineNum">    4994 </span>            : static bool
<span class="lineNum">    4995 </span><span class="lineCov">        120 : acceptable_pow_call (gcall *stmt, tree *base, HOST_WIDE_INT *exponent)</span>
<span class="lineNum">    4996 </span>            : {
<span class="lineNum">    4997 </span><span class="lineCov">        120 :   tree arg1;</span>
<span class="lineNum">    4998 </span><span class="lineCov">        120 :   REAL_VALUE_TYPE c, cint;</span>
<span class="lineNum">    4999 </span>            : 
<span class="lineNum">    5000 </span><span class="lineCov">        120 :   switch (gimple_call_combined_fn (stmt))</span>
<span class="lineNum">    5001 </span>            :     {
<span class="lineNum">    5002 </span><span class="lineCov">         18 :     CASE_CFN_POW:</span>
<span class="lineNum">    5003 </span><span class="lineCov">         18 :       if (flag_errno_math)</span>
<span class="lineNum">    5004 </span>            :         return false;
<span class="lineNum">    5005 </span>            : 
<span class="lineNum">    5006 </span><span class="lineCov">         18 :       *base = gimple_call_arg (stmt, 0);</span>
<span class="lineNum">    5007 </span><span class="lineCov">         18 :       arg1 = gimple_call_arg (stmt, 1);</span>
<span class="lineNum">    5008 </span>            : 
<span class="lineNum">    5009 </span><span class="lineCov">         18 :       if (TREE_CODE (arg1) != REAL_CST)</span>
<span class="lineNum">    5010 </span>            :         return false;
<span class="lineNum">    5011 </span>            : 
<span class="lineNum">    5012 </span><span class="lineCov">         16 :       c = TREE_REAL_CST (arg1);</span>
<span class="lineNum">    5013 </span>            : 
<span class="lineNum">    5014 </span><span class="lineCov">         16 :       if (REAL_EXP (&amp;c) &gt; HOST_BITS_PER_WIDE_INT)</span>
<span class="lineNum">    5015 </span>            :         return false;
<span class="lineNum">    5016 </span>            : 
<span class="lineNum">    5017 </span><span class="lineCov">         16 :       *exponent = real_to_integer (&amp;c);</span>
<span class="lineNum">    5018 </span><span class="lineCov">         32 :       real_from_integer (&amp;cint, VOIDmode, *exponent, SIGNED);</span>
<span class="lineNum">    5019 </span><span class="lineCov">         16 :       if (!real_identical (&amp;c, &amp;cint))</span>
<span class="lineNum">    5020 </span>            :         return false;
<span class="lineNum">    5021 </span>            : 
<span class="lineNum">    5022 </span>            :       break;
<span class="lineNum">    5023 </span>            : 
<span class="lineNum">    5024 </span><span class="lineCov">         10 :     CASE_CFN_POWI:</span>
<span class="lineNum">    5025 </span><span class="lineCov">         10 :       *base = gimple_call_arg (stmt, 0);</span>
<span class="lineNum">    5026 </span><span class="lineCov">         10 :       arg1 = gimple_call_arg (stmt, 1);</span>
<span class="lineNum">    5027 </span>            : 
<span class="lineNum">    5028 </span><span class="lineCov">         10 :       if (!tree_fits_shwi_p (arg1))</span>
<span class="lineNum">    5029 </span>            :         return false;
<span class="lineNum">    5030 </span>            : 
<span class="lineNum">    5031 </span><span class="lineCov">         10 :       *exponent = tree_to_shwi (arg1);</span>
<span class="lineNum">    5032 </span><span class="lineCov">         10 :       break;</span>
<span class="lineNum">    5033 </span>            : 
<span class="lineNum">    5034 </span>            :     default:
<span class="lineNum">    5035 </span>            :       return false;
<span class="lineNum">    5036 </span>            :     }
<span class="lineNum">    5037 </span>            : 
<span class="lineNum">    5038 </span>            :   /* Expanding negative exponents is generally unproductive, so we don't
<span class="lineNum">    5039 </span>            :      complicate matters with those.  Exponents of zero and one should
<span class="lineNum">    5040 </span>            :      have been handled by expression folding.  */
<span class="lineNum">    5041 </span><span class="lineCov">         18 :   if (*exponent &lt; 2 || TREE_CODE (*base) != SSA_NAME)</span>
<span class="lineNum">    5042 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    5043 </span>            : 
<span class="lineNum">    5044 </span>            :   return true;
<span class="lineNum">    5045 </span>            : }
<span class="lineNum">    5046 </span>            : 
<span class="lineNum">    5047 </span>            : /* Try to derive and add operand entry for OP to *OPS.  Return false if
<span class="lineNum">    5048 </span>            :    unsuccessful.  */
<a name="5049"><span class="lineNum">    5049 </span>            : </a>
<span class="lineNum">    5050 </span>            : static bool
<span class="lineNum">    5051 </span><span class="lineCov">    4999600 : try_special_add_to_ops (vec&lt;operand_entry *&gt; *ops,</span>
<span class="lineNum">    5052 </span>            :                         enum tree_code code,
<span class="lineNum">    5053 </span>            :                         tree op, gimple* def_stmt)
<span class="lineNum">    5054 </span>            : {
<span class="lineNum">    5055 </span><span class="lineCov">    4999600 :   tree base = NULL_TREE;</span>
<span class="lineNum">    5056 </span><span class="lineCov">    4999600 :   HOST_WIDE_INT exponent = 0;</span>
<span class="lineNum">    5057 </span>            : 
<span class="lineNum">    5058 </span><span class="lineCov">    4999600 :   if (TREE_CODE (op) != SSA_NAME</span>
<span class="lineNum">    5059 </span><span class="lineCov">    4999600 :       || ! has_single_use (op))</span>
<span class="lineNum">    5060 </span>            :     return false;
<span class="lineNum">    5061 </span>            : 
<span class="lineNum">    5062 </span><span class="lineCov">    2009697 :   if (code == MULT_EXPR</span>
<span class="lineNum">    5063 </span><span class="lineCov">     421604 :       &amp;&amp; reassoc_insert_powi_p</span>
<span class="lineNum">    5064 </span><span class="lineCov">     172789 :       &amp;&amp; flag_unsafe_math_optimizations</span>
<span class="lineNum">    5065 </span><span class="lineCov">      58398 :       &amp;&amp; is_gimple_call (def_stmt)</span>
<span class="lineNum">    5066 </span><span class="lineCov">    2009937 :       &amp;&amp; acceptable_pow_call (as_a &lt;gcall *&gt; (def_stmt), &amp;base, &amp;exponent))</span>
<span class="lineNum">    5067 </span>            :     {
<span class="lineNum">    5068 </span><span class="lineCov">         18 :       add_repeat_to_ops_vec (ops, base, exponent);</span>
<span class="lineNum">    5069 </span><span class="lineCov">         18 :       gimple_set_visited (def_stmt, true);</span>
<span class="lineNum">    5070 </span><span class="lineCov">         18 :       return true;</span>
<span class="lineNum">    5071 </span>            :     }
<span class="lineNum">    5072 </span><span class="lineCov">    2009679 :   else if (code == MULT_EXPR</span>
<span class="lineNum">    5073 </span><span class="lineCov">     843172 :            &amp;&amp; is_gimple_assign (def_stmt)</span>
<span class="lineNum">    5074 </span><span class="lineCov">     407277 :            &amp;&amp; gimple_assign_rhs_code (def_stmt) == NEGATE_EXPR</span>
<span class="lineNum">    5075 </span><span class="lineCov">        116 :            &amp;&amp; !HONOR_SNANS (TREE_TYPE (op))</span>
<span class="lineNum">    5076 </span><span class="lineCov">    2009795 :            &amp;&amp; (!HONOR_SIGNED_ZEROS (TREE_TYPE (op))</span>
<span class="lineNum">    5077 </span><span class="lineNoCov">          0 :                || !COMPLEX_FLOAT_TYPE_P (TREE_TYPE (op))))</span>
<span class="lineNum">    5078 </span>            :     {
<span class="lineNum">    5079 </span><span class="lineCov">        116 :       tree rhs1 = gimple_assign_rhs1 (def_stmt);</span>
<span class="lineNum">    5080 </span><span class="lineCov">        116 :       tree cst = build_minus_one_cst (TREE_TYPE (op));</span>
<span class="lineNum">    5081 </span><span class="lineCov">        116 :       add_to_ops_vec (ops, rhs1);</span>
<span class="lineNum">    5082 </span><span class="lineCov">        116 :       add_to_ops_vec (ops, cst);</span>
<span class="lineNum">    5083 </span><span class="lineCov">        116 :       gimple_set_visited (def_stmt, true);</span>
<span class="lineNum">    5084 </span><span class="lineCov">        116 :       return true;</span>
<span class="lineNum">    5085 </span>            :     }
<span class="lineNum">    5086 </span>            : 
<span class="lineNum">    5087 </span>            :   return false;
<span class="lineNum">    5088 </span>            : }
<span class="lineNum">    5089 </span>            : 
<span class="lineNum">    5090 </span>            : /* Recursively linearize a binary expression that is the RHS of STMT.
<span class="lineNum">    5091 </span>            :    Place the operands of the expression tree in the vector named OPS.  */
<a name="5092"><span class="lineNum">    5092 </span>            : </a>
<span class="lineNum">    5093 </span>            : static void
<span class="lineNum">    5094 </span><span class="lineCov">    2582771 : linearize_expr_tree (vec&lt;operand_entry *&gt; *ops, gimple *stmt,</span>
<span class="lineNum">    5095 </span>            :                      bool is_associative, bool set_visited)
<span class="lineNum">    5096 </span>            : {
<span class="lineNum">    5097 </span><span class="lineCov">    2582771 :   tree binlhs = gimple_assign_rhs1 (stmt);</span>
<span class="lineNum">    5098 </span><span class="lineCov">    2582771 :   tree binrhs = gimple_assign_rhs2 (stmt);</span>
<span class="lineNum">    5099 </span><span class="lineCov">    2582771 :   gimple *binlhsdef = NULL, *binrhsdef = NULL;</span>
<span class="lineNum">    5100 </span><span class="lineCov">    2582771 :   bool binlhsisreassoc = false;</span>
<span class="lineNum">    5101 </span><span class="lineCov">    2582771 :   bool binrhsisreassoc = false;</span>
<span class="lineNum">    5102 </span><span class="lineCov">    2582771 :   enum tree_code rhscode = gimple_assign_rhs_code (stmt);</span>
<span class="lineNum">    5103 </span><span class="lineCov">    2582771 :   struct loop *loop = loop_containing_stmt (stmt);</span>
<span class="lineNum">    5104 </span>            : 
<span class="lineNum">    5105 </span><span class="lineCov">    2582771 :   if (set_visited)</span>
<span class="lineNum">    5106 </span><span class="lineCov">    2554282 :     gimple_set_visited (stmt, true);</span>
<span class="lineNum">    5107 </span>            : 
<span class="lineNum">    5108 </span><span class="lineCov">    2582771 :   if (TREE_CODE (binlhs) == SSA_NAME)</span>
<span class="lineNum">    5109 </span>            :     {
<span class="lineNum">    5110 </span><span class="lineCov">    2581072 :       binlhsdef = SSA_NAME_DEF_STMT (binlhs);</span>
<span class="lineNum">    5111 </span><span class="lineCov">    2581072 :       binlhsisreassoc = (is_reassociable_op (binlhsdef, rhscode, loop)</span>
<span class="lineNum">    5112 </span><span class="lineCov">    2581072 :                          &amp;&amp; !stmt_could_throw_p (binlhsdef));</span>
<span class="lineNum">    5113 </span>            :     }
<span class="lineNum">    5114 </span>            : 
<span class="lineNum">    5115 </span><span class="lineCov">    2582771 :   if (TREE_CODE (binrhs) == SSA_NAME)</span>
<span class="lineNum">    5116 </span>            :     {
<span class="lineNum">    5117 </span><span class="lineCov">     900031 :       binrhsdef = SSA_NAME_DEF_STMT (binrhs);</span>
<span class="lineNum">    5118 </span><span class="lineCov">     900031 :       binrhsisreassoc = (is_reassociable_op (binrhsdef, rhscode, loop)</span>
<span class="lineNum">    5119 </span><span class="lineCov">     900031 :                          &amp;&amp; !stmt_could_throw_p (binrhsdef));</span>
<span class="lineNum">    5120 </span>            :     }
<span class="lineNum">    5121 </span>            : 
<span class="lineNum">    5122 </span>            :   /* If the LHS is not reassociable, but the RHS is, we need to swap
<span class="lineNum">    5123 </span>            :      them.  If neither is reassociable, there is nothing we can do, so
<span class="lineNum">    5124 </span>            :      just put them in the ops vector.  If the LHS is reassociable,
<span class="lineNum">    5125 </span>            :      linearize it.  If both are reassociable, then linearize the RHS
<span class="lineNum">    5126 </span>            :      and the LHS.  */
<span class="lineNum">    5127 </span>            : 
<span class="lineNum">    5128 </span><span class="lineCov">    2582771 :   if (!binlhsisreassoc)</span>
<span class="lineNum">    5129 </span>            :     {
<span class="lineNum">    5130 </span>            :       /* If this is not a associative operation like division, give up.  */
<span class="lineNum">    5131 </span><span class="lineCov">    2454207 :       if (!is_associative)</span>
<span class="lineNum">    5132 </span>            :         {
<span class="lineNum">    5133 </span><span class="lineCov">          9 :           add_to_ops_vec (ops, binrhs);</span>
<span class="lineNum">    5134 </span><span class="lineCov">          9 :           return;</span>
<span class="lineNum">    5135 </span>            :         }
<span class="lineNum">    5136 </span>            : 
<span class="lineNum">    5137 </span><span class="lineCov">    2454198 :       if (!binrhsisreassoc)</span>
<span class="lineNum">    5138 </span>            :         {
<span class="lineNum">    5139 </span><span class="lineCov">    2416838 :           if (!try_special_add_to_ops (ops, rhscode, binrhs, binrhsdef))</span>
<span class="lineNum">    5140 </span><span class="lineCov">    2416794 :             add_to_ops_vec (ops, binrhs);</span>
<span class="lineNum">    5141 </span>            : 
<span class="lineNum">    5142 </span><span class="lineCov">    2416838 :           if (!try_special_add_to_ops (ops, rhscode, binlhs, binlhsdef))</span>
<span class="lineNum">    5143 </span><span class="lineCov">    2416752 :             add_to_ops_vec (ops, binlhs);</span>
<span class="lineNum">    5144 </span>            : 
<span class="lineNum">    5145 </span><span class="lineCov">    2416838 :           return;</span>
<span class="lineNum">    5146 </span>            :         }
<span class="lineNum">    5147 </span>            : 
<span class="lineNum">    5148 </span><span class="lineCov">      37360 :       if (dump_file &amp;&amp; (dump_flags &amp; TDF_DETAILS))</span>
<span class="lineNum">    5149 </span>            :         {
<span class="lineNum">    5150 </span><span class="lineCov">          9 :           fprintf (dump_file, &quot;swapping operands of &quot;);</span>
<span class="lineNum">    5151 </span><span class="lineCov">          9 :           print_gimple_stmt (dump_file, stmt, 0);</span>
<span class="lineNum">    5152 </span>            :         }
<span class="lineNum">    5153 </span>            : 
<span class="lineNum">    5154 </span><span class="lineCov">      37360 :       swap_ssa_operands (stmt,</span>
<span class="lineNum">    5155 </span>            :                          gimple_assign_rhs1_ptr (stmt),
<span class="lineNum">    5156 </span>            :                          gimple_assign_rhs2_ptr (stmt));
<span class="lineNum">    5157 </span><span class="lineCov">      37360 :       update_stmt (stmt);</span>
<span class="lineNum">    5158 </span>            : 
<span class="lineNum">    5159 </span><span class="lineCov">      37360 :       if (dump_file &amp;&amp; (dump_flags &amp; TDF_DETAILS))</span>
<span class="lineNum">    5160 </span>            :         {
<span class="lineNum">    5161 </span><span class="lineCov">          9 :           fprintf (dump_file, &quot; is now &quot;);</span>
<span class="lineNum">    5162 </span><span class="lineCov">          9 :           print_gimple_stmt (dump_file, stmt, 0);</span>
<span class="lineNum">    5163 </span>            :         }
<span class="lineNum">    5164 </span>            : 
<span class="lineNum">    5165 </span>            :       /* We want to make it so the lhs is always the reassociative op,
<span class="lineNum">    5166 </span>            :          so swap.  */
<span class="lineNum">    5167 </span>            :       std::swap (binlhs, binrhs);
<span class="lineNum">    5168 </span>            :     }
<span class="lineNum">    5169 </span><span class="lineCov">     128564 :   else if (binrhsisreassoc)</span>
<span class="lineNum">    5170 </span>            :     {
<span class="lineNum">    5171 </span><span class="lineCov">       2852 :       linearize_expr (stmt);</span>
<span class="lineNum">    5172 </span><span class="lineCov">       2852 :       binlhs = gimple_assign_rhs1 (stmt);</span>
<span class="lineNum">    5173 </span><span class="lineCov">       2852 :       binrhs = gimple_assign_rhs2 (stmt);</span>
<span class="lineNum">    5174 </span>            :     }
<span class="lineNum">    5175 </span>            : 
<span class="lineNum">    5176 </span><span class="lineCov">     165924 :   gcc_assert (TREE_CODE (binrhs) != SSA_NAME</span>
<span class="lineNum">    5177 </span>            :               || !is_reassociable_op (SSA_NAME_DEF_STMT (binrhs),
<span class="lineNum">    5178 </span>            :                                       rhscode, loop));
<span class="lineNum">    5179 </span><span class="lineCov">     165924 :   linearize_expr_tree (ops, SSA_NAME_DEF_STMT (binlhs),</span>
<span class="lineNum">    5180 </span>            :                        is_associative, set_visited);
<span class="lineNum">    5181 </span>            : 
<span class="lineNum">    5182 </span><span class="lineCov">     165924 :   if (!try_special_add_to_ops (ops, rhscode, binrhs, binrhsdef))</span>
<span class="lineNum">    5183 </span><span class="lineCov">     165920 :     add_to_ops_vec (ops, binrhs);</span>
<span class="lineNum">    5184 </span>            : }
<span class="lineNum">    5185 </span>            : 
<span class="lineNum">    5186 </span>            : /* Repropagate the negates back into subtracts, since no other pass
<span class="lineNum">    5187 </span>            :    currently does it.  */
<span class="lineNum">    5188 </span>            : 
<span class="lineNum">    5189 </span>            : static void
<span class="lineNum">    5190 </span><span class="lineCov">    1241803 : repropagate_negates (void)</span>
<span class="lineNum">    5191 </span>            : {
<span class="lineNum">    5192 </span><span class="lineCov">    1241803 :   unsigned int i = 0;</span>
<span class="lineNum">    5193 </span><span class="lineCov">    1241803 :   tree negate;</span>
<span class="lineNum">    5194 </span>            : 
<span class="lineNum">    5195 </span><span class="lineCov">    1316741 :   FOR_EACH_VEC_ELT (plus_negates, i, negate)</span>
<span class="lineNum">    5196 </span>            :     {
<span class="lineNum">    5197 </span><span class="lineCov">      74938 :       gimple *user = get_single_immediate_use (negate);</span>
<span class="lineNum">    5198 </span>            : 
<span class="lineNum">    5199 </span><span class="lineCov">      74938 :       if (!user || !is_gimple_assign (user))</span>
<span class="lineNum">    5200 </span>            :         continue;
<span class="lineNum">    5201 </span>            : 
<span class="lineNum">    5202 </span>            :       /* The negate operand can be either operand of a PLUS_EXPR
<span class="lineNum">    5203 </span>            :          (it can be the LHS if the RHS is a constant for example).
<span class="lineNum">    5204 </span>            : 
<span class="lineNum">    5205 </span>            :          Force the negate operand to the RHS of the PLUS_EXPR, then
<span class="lineNum">    5206 </span>            :          transform the PLUS_EXPR into a MINUS_EXPR.  */
<span class="lineNum">    5207 </span><span class="lineCov">      64753 :       if (gimple_assign_rhs_code (user) == PLUS_EXPR)</span>
<span class="lineNum">    5208 </span>            :         {
<span class="lineNum">    5209 </span>            :           /* If the negated operand appears on the LHS of the
<span class="lineNum">    5210 </span>            :              PLUS_EXPR, exchange the operands of the PLUS_EXPR
<span class="lineNum">    5211 </span>            :              to force the negated operand to the RHS of the PLUS_EXPR.  */
<span class="lineNum">    5212 </span><span class="lineCov">      96332 :           if (gimple_assign_rhs1 (user) == negate)</span>
<span class="lineNum">    5213 </span>            :             {
<span class="lineNum">    5214 </span><span class="lineCov">      23799 :               swap_ssa_operands (user,</span>
<span class="lineNum">    5215 </span>            :                                  gimple_assign_rhs1_ptr (user),
<span class="lineNum">    5216 </span>            :                                  gimple_assign_rhs2_ptr (user));
<span class="lineNum">    5217 </span>            :             }
<span class="lineNum">    5218 </span>            : 
<span class="lineNum">    5219 </span>            :           /* Now transform the PLUS_EXPR into a MINUS_EXPR and replace
<span class="lineNum">    5220 </span>            :              the RHS of the PLUS_EXPR with the operand of the NEGATE_EXPR.  */
<span class="lineNum">    5221 </span><span class="lineCov">      48166 :           if (gimple_assign_rhs2 (user) == negate)</span>
<span class="lineNum">    5222 </span>            :             {
<span class="lineNum">    5223 </span><span class="lineCov">      48166 :               tree rhs1 = gimple_assign_rhs1 (user);</span>
<span class="lineNum">    5224 </span><span class="lineCov">      48166 :               tree rhs2 = gimple_assign_rhs1 (SSA_NAME_DEF_STMT (negate));</span>
<span class="lineNum">    5225 </span><span class="lineCov">      48166 :               gimple_stmt_iterator gsi = gsi_for_stmt (user);</span>
<span class="lineNum">    5226 </span><span class="lineCov">      48166 :               gimple_assign_set_rhs_with_ops (&amp;gsi, MINUS_EXPR, rhs1, rhs2);</span>
<span class="lineNum">    5227 </span><span class="lineCov">      96332 :               update_stmt (user);</span>
<span class="lineNum">    5228 </span>            :             }
<span class="lineNum">    5229 </span>            :         }
<span class="lineNum">    5230 </span><span class="lineCov">      16587 :       else if (gimple_assign_rhs_code (user) == MINUS_EXPR)</span>
<span class="lineNum">    5231 </span>            :         {
<span class="lineNum">    5232 </span><span class="lineCov">       2450 :           if (gimple_assign_rhs1 (user) == negate)</span>
<span class="lineNum">    5233 </span>            :             {
<span class="lineNum">    5234 </span>            :               /* We have
<span class="lineNum">    5235 </span>            :                    x = -a
<span class="lineNum">    5236 </span>            :                    y = x - b
<span class="lineNum">    5237 </span>            :                  which we transform into
<span class="lineNum">    5238 </span>            :                    x = a + b
<span class="lineNum">    5239 </span>            :                    y = -x .
<span class="lineNum">    5240 </span>            :                  This pushes down the negate which we possibly can merge
<span class="lineNum">    5241 </span>            :                  into some other operation, hence insert it into the
<span class="lineNum">    5242 </span>            :                  plus_negates vector.  */
<span class="lineNum">    5243 </span><span class="lineCov">       1225 :               gimple *feed = SSA_NAME_DEF_STMT (negate);</span>
<span class="lineNum">    5244 </span><span class="lineCov">       1225 :               tree a = gimple_assign_rhs1 (feed);</span>
<span class="lineNum">    5245 </span><span class="lineCov">       1225 :               tree b = gimple_assign_rhs2 (user);</span>
<span class="lineNum">    5246 </span><span class="lineCov">       1225 :               gimple_stmt_iterator gsi = gsi_for_stmt (feed);</span>
<span class="lineNum">    5247 </span><span class="lineCov">       1225 :               gimple_stmt_iterator gsi2 = gsi_for_stmt (user);</span>
<span class="lineNum">    5248 </span><span class="lineCov">       1225 :               tree x = make_ssa_name (TREE_TYPE (gimple_assign_lhs (feed)));</span>
<span class="lineNum">    5249 </span><span class="lineCov">       1225 :               gimple *g = gimple_build_assign (x, PLUS_EXPR, a, b);</span>
<span class="lineNum">    5250 </span><span class="lineCov">       1225 :               gsi_insert_before (&amp;gsi2, g, GSI_SAME_STMT);</span>
<span class="lineNum">    5251 </span><span class="lineCov">       1225 :               gimple_assign_set_rhs_with_ops (&amp;gsi2, NEGATE_EXPR, x);</span>
<span class="lineNum">    5252 </span><span class="lineCov">       1225 :               user = gsi_stmt (gsi2);</span>
<span class="lineNum">    5253 </span><span class="lineCov">       1225 :               update_stmt (user);</span>
<span class="lineNum">    5254 </span><span class="lineCov">       1225 :               reassoc_remove_stmt (&amp;gsi);</span>
<span class="lineNum">    5255 </span><span class="lineCov">       1225 :               release_defs (feed);</span>
<span class="lineNum">    5256 </span><span class="lineCov">       1225 :               plus_negates.safe_push (gimple_assign_lhs (user));</span>
<span class="lineNum">    5257 </span>            :             }
<span class="lineNum">    5258 </span>            :           else
<span class="lineNum">    5259 </span>            :             {
<span class="lineNum">    5260 </span>            :               /* Transform &quot;x = -a; y = b - x&quot; into &quot;y = b + a&quot;, getting
<span class="lineNum">    5261 </span>            :                  rid of one operation.  */
<span class="lineNum">    5262 </span><span class="lineNoCov">          0 :               gimple *feed = SSA_NAME_DEF_STMT (negate);</span>
<span class="lineNum">    5263 </span><span class="lineNoCov">          0 :               tree a = gimple_assign_rhs1 (feed);</span>
<span class="lineNum">    5264 </span><span class="lineNoCov">          0 :               tree rhs1 = gimple_assign_rhs1 (user);</span>
<span class="lineNum">    5265 </span><span class="lineNoCov">          0 :               gimple_stmt_iterator gsi = gsi_for_stmt (user);</span>
<span class="lineNum">    5266 </span><span class="lineNoCov">          0 :               gimple_assign_set_rhs_with_ops (&amp;gsi, PLUS_EXPR, rhs1, a);</span>
<span class="lineNum">    5267 </span><span class="lineNoCov">          0 :               update_stmt (gsi_stmt (gsi));</span>
<span class="lineNum">    5268 </span>            :             }
<span class="lineNum">    5269 </span>            :         }
<span class="lineNum">    5270 </span>            :     }
<span class="lineNum">    5271 </span><span class="lineCov">    1241803 : }</span>
<span class="lineNum">    5272 </span>            : 
<span class="lineNum">    5273 </span>            : /* Returns true if OP is of a type for which we can do reassociation.
<span class="lineNum">    5274 </span>            :    That is for integral or non-saturating fixed-point types, and for
<span class="lineNum">    5275 </span>            :    floating point type when associative-math is enabled.  */
<a name="5276"><span class="lineNum">    5276 </span>            : </a>
<span class="lineNum">    5277 </span>            : static bool
<span class="lineNum">    5278 </span><span class="lineCov">   39252673 : can_reassociate_p (tree op)</span>
<span class="lineNum">    5279 </span>            : {
<span class="lineNum">    5280 </span><span class="lineCov">   39252673 :   tree type = TREE_TYPE (op);</span>
<span class="lineNum">    5281 </span><span class="lineCov">   39252673 :   if (TREE_CODE (op) == SSA_NAME &amp;&amp; SSA_NAME_OCCURS_IN_ABNORMAL_PHI (op))</span>
<span class="lineNum">    5282 </span>            :     return false;
<span class="lineNum">    5283 </span><span class="lineCov">   39804798 :   if ((ANY_INTEGRAL_TYPE_P (type) &amp;&amp; TYPE_OVERFLOW_WRAPS (type))</span>
<span class="lineNum">    5284 </span><span class="lineCov">   21947079 :       || NON_SAT_FIXED_POINT_TYPE_P (type)</span>
<span class="lineNum">    5285 </span><span class="lineCov">   61751877 :       || (flag_associative_math &amp;&amp; FLOAT_TYPE_P (type)))</span>
<span class="lineNum">    5286 </span><span class="lineCov">   17840780 :     return true;</span>
<span class="lineNum">    5287 </span>            :   return false;
<span class="lineNum">    5288 </span>            : }
<span class="lineNum">    5289 </span>            : 
<span class="lineNum">    5290 </span>            : /* Break up subtract operations in block BB.
<span class="lineNum">    5291 </span>            : 
<span class="lineNum">    5292 </span>            :    We do this top down because we don't know whether the subtract is
<span class="lineNum">    5293 </span>            :    part of a possible chain of reassociation except at the top.
<span class="lineNum">    5294 </span>            : 
<span class="lineNum">    5295 </span>            :    IE given
<span class="lineNum">    5296 </span>            :    d = f + g
<span class="lineNum">    5297 </span>            :    c = a + e
<span class="lineNum">    5298 </span>            :    b = c - d
<span class="lineNum">    5299 </span>            :    q = b - r
<span class="lineNum">    5300 </span>            :    k = t - q
<span class="lineNum">    5301 </span>            : 
<span class="lineNum">    5302 </span>            :    we want to break up k = t - q, but we won't until we've transformed q
<span class="lineNum">    5303 </span>            :    = b - r, which won't be broken up until we transform b = c - d.
<span class="lineNum">    5304 </span>            : 
<span class="lineNum">    5305 </span>            :    En passant, clear the GIMPLE visited flag on every statement
<span class="lineNum">    5306 </span>            :    and set UIDs within each basic block.  */
<a name="5307"><span class="lineNum">    5307 </span>            : </a>
<span class="lineNum">    5308 </span>            : static void
<span class="lineNum">    5309 </span><span class="lineCov">   12527300 : break_up_subtract_bb (basic_block bb)</span>
<span class="lineNum">    5310 </span>            : {
<span class="lineNum">    5311 </span><span class="lineCov">   12527300 :   gimple_stmt_iterator gsi;</span>
<span class="lineNum">    5312 </span><span class="lineCov">   12527300 :   basic_block son;</span>
<span class="lineNum">    5313 </span><span class="lineCov">   12527300 :   unsigned int uid = 1;</span>
<span class="lineNum">    5314 </span>            : 
<span class="lineNum">    5315 </span><span class="lineCov">  127836526 :   for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&amp;gsi))</span>
<span class="lineNum">    5316 </span>            :     {
<span class="lineNum">    5317 </span><span class="lineCov">  102781926 :       gimple *stmt = gsi_stmt (gsi);</span>
<span class="lineNum">    5318 </span><span class="lineCov">  102781926 :       gimple_set_visited (stmt, false);</span>
<span class="lineNum">    5319 </span><span class="lineCov">  102781926 :       gimple_set_uid (stmt, uid++);</span>
<span class="lineNum">    5320 </span>            : 
<span class="lineNum">    5321 </span><span class="lineCov">  102781926 :       if (!is_gimple_assign (stmt)</span>
<span class="lineNum">    5322 </span><span class="lineCov">  102781926 :           || !can_reassociate_p (gimple_assign_lhs (stmt)))</span>
<span class="lineNum">    5323 </span>            :         continue;
<span class="lineNum">    5324 </span>            : 
<span class="lineNum">    5325 </span>            :       /* Look for simple gimple subtract operations.  */
<span class="lineNum">    5326 </span><span class="lineCov">    9919461 :       if (gimple_assign_rhs_code (stmt) == MINUS_EXPR)</span>
<span class="lineNum">    5327 </span>            :         {
<span class="lineNum">    5328 </span><span class="lineCov">     345406 :           if (!can_reassociate_p (gimple_assign_rhs1 (stmt))</span>
<span class="lineNum">    5329 </span><span class="lineCov">     172703 :               || !can_reassociate_p (gimple_assign_rhs2 (stmt)))</span>
<span class="lineNum">    5330 </span>            :             continue;
<span class="lineNum">    5331 </span>            : 
<span class="lineNum">    5332 </span>            :           /* Check for a subtract used only in an addition.  If this
<span class="lineNum">    5333 </span>            :              is the case, transform it into add of a negate for better
<span class="lineNum">    5334 </span>            :              reassociation.  IE transform C = A-B into C = A + -B if C
<span class="lineNum">    5335 </span>            :              is only used in an addition.  */
<span class="lineNum">    5336 </span><span class="lineCov">     172703 :           if (should_break_up_subtract (stmt))</span>
<span class="lineNum">    5337 </span><span class="lineCov">      46743 :             break_up_subtract (stmt, &amp;gsi);</span>
<span class="lineNum">    5338 </span>            :         }
<span class="lineNum">    5339 </span><span class="lineCov">    9746758 :       else if (gimple_assign_rhs_code (stmt) == NEGATE_EXPR</span>
<span class="lineNum">    5340 </span><span class="lineCov">    9746758 :                &amp;&amp; can_reassociate_p (gimple_assign_rhs1 (stmt)))</span>
<span class="lineNum">    5341 </span><span class="lineCov">      47390 :         plus_negates.safe_push (gimple_assign_lhs (stmt));</span>
<span class="lineNum">    5342 </span>            :     }
<span class="lineNum">    5343 </span><span class="lineCov">   23812797 :   for (son = first_dom_son (CDI_DOMINATORS, bb);</span>
<span class="lineNum">    5344 </span><span class="lineCov">   23812797 :        son;</span>
<span class="lineNum">    5345 </span><span class="lineCov">   11285497 :        son = next_dom_son (CDI_DOMINATORS, son))</span>
<span class="lineNum">    5346 </span><span class="lineCov">   11285497 :     break_up_subtract_bb (son);</span>
<span class="lineNum">    5347 </span><span class="lineCov">   12527300 : }</span>
<span class="lineNum">    5348 </span>            : 
<span class="lineNum">    5349 </span>            : /* Used for repeated factor analysis.  */
<span class="lineNum">    5350 </span>            : struct repeat_factor
<span class="lineNum">    5351 </span>            : {
<span class="lineNum">    5352 </span>            :   /* An SSA name that occurs in a multiply chain.  */
<span class="lineNum">    5353 </span>            :   tree factor;
<span class="lineNum">    5354 </span>            : 
<span class="lineNum">    5355 </span>            :   /* Cached rank of the factor.  */
<span class="lineNum">    5356 </span>            :   unsigned rank;
<span class="lineNum">    5357 </span>            : 
<span class="lineNum">    5358 </span>            :   /* Number of occurrences of the factor in the chain.  */
<span class="lineNum">    5359 </span>            :   HOST_WIDE_INT count;
<span class="lineNum">    5360 </span>            : 
<span class="lineNum">    5361 </span>            :   /* An SSA name representing the product of this factor and
<span class="lineNum">    5362 </span>            :      all factors appearing later in the repeated factor vector.  */
<span class="lineNum">    5363 </span>            :   tree repr;
<span class="lineNum">    5364 </span>            : };
<span class="lineNum">    5365 </span>            : 
<span class="lineNum">    5366 </span>            : 
<span class="lineNum">    5367 </span>            : static vec&lt;repeat_factor&gt; repeat_factor_vec;
<span class="lineNum">    5368 </span>            : 
<span class="lineNum">    5369 </span>            : /* Used for sorting the repeat factor vector.  Sort primarily by
<span class="lineNum">    5370 </span>            :    ascending occurrence count, secondarily by descending rank.  */
<a name="5371"><span class="lineNum">    5371 </span>            : </a>
<span class="lineNum">    5372 </span>            : static int
<span class="lineNum">    5373 </span><span class="lineCov">      52912 : compare_repeat_factors (const void *x1, const void *x2)</span>
<span class="lineNum">    5374 </span>            : {
<span class="lineNum">    5375 </span><span class="lineCov">      52912 :   const repeat_factor *rf1 = (const repeat_factor *) x1;</span>
<span class="lineNum">    5376 </span><span class="lineCov">      52912 :   const repeat_factor *rf2 = (const repeat_factor *) x2;</span>
<span class="lineNum">    5377 </span>            : 
<span class="lineNum">    5378 </span><span class="lineCov">      52912 :   if (rf1-&gt;count != rf2-&gt;count)</span>
<span class="lineNum">    5379 </span><span class="lineCov">        558 :     return rf1-&gt;count - rf2-&gt;count;</span>
<span class="lineNum">    5380 </span>            : 
<span class="lineNum">    5381 </span><span class="lineCov">      52354 :   return rf2-&gt;rank - rf1-&gt;rank;</span>
<span class="lineNum">    5382 </span>            : }
<span class="lineNum">    5383 </span>            : 
<span class="lineNum">    5384 </span>            : /* Look for repeated operands in OPS in the multiply tree rooted at
<span class="lineNum">    5385 </span>            :    STMT.  Replace them with an optimal sequence of multiplies and powi
<span class="lineNum">    5386 </span>            :    builtin calls, and remove the used operands from OPS.  Return an
<span class="lineNum">    5387 </span>            :    SSA name representing the value of the replacement sequence.  */
<span class="lineNum">    5388 </span>            : 
<span class="lineNum">    5389 </span>            : static tree
<span class="lineNum">    5390 </span><span class="lineCov">      41060 : attempt_builtin_powi (gimple *stmt, vec&lt;operand_entry *&gt; *ops)</span>
<span class="lineNum">    5391 </span>            : {
<span class="lineNum">    5392 </span><span class="lineCov">      41060 :   unsigned i, j, vec_len;</span>
<span class="lineNum">    5393 </span><span class="lineCov">      41060 :   int ii;</span>
<span class="lineNum">    5394 </span><span class="lineCov">      41060 :   operand_entry *oe;</span>
<span class="lineNum">    5395 </span><span class="lineCov">      41060 :   repeat_factor *rf1, *rf2;</span>
<span class="lineNum">    5396 </span><span class="lineCov">      41060 :   repeat_factor rfnew;</span>
<span class="lineNum">    5397 </span><span class="lineCov">      41060 :   tree result = NULL_TREE;</span>
<span class="lineNum">    5398 </span><span class="lineCov">      41060 :   tree target_ssa, iter_result;</span>
<span class="lineNum">    5399 </span><span class="lineCov">      41060 :   tree type = TREE_TYPE (gimple_get_lhs (stmt));</span>
<span class="lineNum">    5400 </span><span class="lineCov">      41060 :   tree powi_fndecl = mathfn_built_in (type, BUILT_IN_POWI);</span>
<span class="lineNum">    5401 </span><span class="lineCov">      41060 :   gimple_stmt_iterator gsi = gsi_for_stmt (stmt);</span>
<span class="lineNum">    5402 </span><span class="lineCov">      41060 :   gimple *mul_stmt, *pow_stmt;</span>
<span class="lineNum">    5403 </span>            : 
<span class="lineNum">    5404 </span>            :   /* Nothing to do if BUILT_IN_POWI doesn't exist for this type and
<span class="lineNum">    5405 </span>            :      target.  */
<span class="lineNum">    5406 </span><span class="lineCov">      41060 :   if (!powi_fndecl)</span>
<span class="lineNum">    5407 </span>            :     return NULL_TREE;
<span class="lineNum">    5408 </span>            : 
<span class="lineNum">    5409 </span>            :   /* Allocate the repeated factor vector.  */
<span class="lineNum">    5410 </span><span class="lineCov">      13365 :   repeat_factor_vec.create (10);</span>
<span class="lineNum">    5411 </span>            : 
<span class="lineNum">    5412 </span>            :   /* Scan the OPS vector for all SSA names in the product and build
<span class="lineNum">    5413 </span>            :      up a vector of occurrence counts for each factor.  */
<span class="lineNum">    5414 </span><span class="lineCov">      41358 :   FOR_EACH_VEC_ELT (*ops, i, oe)</span>
<span class="lineNum">    5415 </span>            :     {
<span class="lineNum">    5416 </span><span class="lineCov">      27993 :       if (TREE_CODE (oe-&gt;op) == SSA_NAME)</span>
<span class="lineNum">    5417 </span>            :         {
<span class="lineNum">    5418 </span><span class="lineCov">      41343 :           FOR_EACH_VEC_ELT (repeat_factor_vec, j, rf1)</span>
<span class="lineNum">    5419 </span>            :             {
<span class="lineNum">    5420 </span><span class="lineCov">      14805 :               if (rf1-&gt;factor == oe-&gt;op)</span>
<span class="lineNum">    5421 </span>            :                 {
<span class="lineNum">    5422 </span><span class="lineCov">        876 :                   rf1-&gt;count += oe-&gt;count;</span>
<span class="lineNum">    5423 </span><span class="lineCov">        876 :                   break;</span>
<span class="lineNum">    5424 </span>            :                 }
<span class="lineNum">    5425 </span>            :             }
<span class="lineNum">    5426 </span>            : 
<span class="lineNum">    5427 </span><span class="lineCov">      54828 :           if (j &gt;= repeat_factor_vec.length ())</span>
<span class="lineNum">    5428 </span>            :             {
<span class="lineNum">    5429 </span><span class="lineCov">      26538 :               rfnew.factor = oe-&gt;op;</span>
<span class="lineNum">    5430 </span><span class="lineCov">      26538 :               rfnew.rank = oe-&gt;rank;</span>
<span class="lineNum">    5431 </span><span class="lineCov">      26538 :               rfnew.count = oe-&gt;count;</span>
<span class="lineNum">    5432 </span><span class="lineCov">      26538 :               rfnew.repr = NULL_TREE;</span>
<span class="lineNum">    5433 </span><span class="lineCov">      26538 :               repeat_factor_vec.safe_push (rfnew);</span>
<span class="lineNum">    5434 </span>            :             }
<span class="lineNum">    5435 </span>            :         }
<span class="lineNum">    5436 </span>            :     }
<span class="lineNum">    5437 </span>            : 
<span class="lineNum">    5438 </span>            :   /* Sort the repeated factor vector by (a) increasing occurrence count,
<span class="lineNum">    5439 </span>            :      and (b) decreasing rank.  */
<span class="lineNum">    5440 </span><span class="lineCov">      13365 :   repeat_factor_vec.qsort (compare_repeat_factors);</span>
<span class="lineNum">    5441 </span>            : 
<span class="lineNum">    5442 </span>            :   /* It is generally best to combine as many base factors as possible
<span class="lineNum">    5443 </span>            :      into a product before applying __builtin_powi to the result.
<span class="lineNum">    5444 </span>            :      However, the sort order chosen for the repeated factor vector
<span class="lineNum">    5445 </span>            :      allows us to cache partial results for the product of the base
<span class="lineNum">    5446 </span>            :      factors for subsequent use.  When we already have a cached partial
<span class="lineNum">    5447 </span>            :      result from a previous iteration, it is best to make use of it
<span class="lineNum">    5448 </span>            :      before looking for another __builtin_pow opportunity.
<span class="lineNum">    5449 </span>            : 
<span class="lineNum">    5450 </span>            :      As an example, consider x * x * y * y * y * z * z * z * z.
<span class="lineNum">    5451 </span>            :      We want to first compose the product x * y * z, raise it to the
<span class="lineNum">    5452 </span>            :      second power, then multiply this by y * z, and finally multiply
<span class="lineNum">    5453 </span>            :      by z.  This can be done in 5 multiplies provided we cache y * z
<span class="lineNum">    5454 </span>            :      for use in both expressions:
<span class="lineNum">    5455 </span>            : 
<span class="lineNum">    5456 </span>            :         t1 = y * z
<span class="lineNum">    5457 </span>            :         t2 = t1 * x
<span class="lineNum">    5458 </span>            :         t3 = t2 * t2
<span class="lineNum">    5459 </span>            :         t4 = t1 * t3
<span class="lineNum">    5460 </span>            :         result = t4 * z
<span class="lineNum">    5461 </span>            : 
<span class="lineNum">    5462 </span>            :      If we instead ignored the cached y * z and first multiplied by
<span class="lineNum">    5463 </span>            :      the __builtin_pow opportunity z * z, we would get the inferior:
<span class="lineNum">    5464 </span>            : 
<span class="lineNum">    5465 </span>            :         t1 = y * z
<span class="lineNum">    5466 </span>            :         t2 = t1 * x
<span class="lineNum">    5467 </span>            :         t3 = t2 * t2
<span class="lineNum">    5468 </span>            :         t4 = z * z
<span class="lineNum">    5469 </span>            :         t5 = t3 * t4
<span class="lineNum">    5470 </span>            :         result = t5 * y  */
<span class="lineNum">    5471 </span>            : 
<span class="lineNum">    5472 </span><span class="lineCov">      26730 :   vec_len = repeat_factor_vec.length ();</span>
<span class="lineNum">    5473 </span>            :   
<span class="lineNum">    5474 </span>            :   /* Repeatedly look for opportunities to create a builtin_powi call.  */
<span class="lineNum">    5475 </span><span class="lineCov">      13892 :   while (true)</span>
<span class="lineNum">    5476 </span>            :     {
<span class="lineNum">    5477 </span><span class="lineCov">      13892 :       HOST_WIDE_INT power;</span>
<span class="lineNum">    5478 </span>            : 
<span class="lineNum">    5479 </span>            :       /* First look for the largest cached product of factors from
<span class="lineNum">    5480 </span>            :          preceding iterations.  If found, create a builtin_powi for
<span class="lineNum">    5481 </span>            :          it if the minimum occurrence count for its factors is at
<span class="lineNum">    5482 </span>            :          least 2, or just use this cached product as our next 
<span class="lineNum">    5483 </span>            :          multiplicand if the minimum occurrence count is 1.  */
<span class="lineNum">    5484 </span><span class="lineCov">      41115 :       FOR_EACH_VEC_ELT (repeat_factor_vec, j, rf1)</span>
<span class="lineNum">    5485 </span>            :         {
<span class="lineNum">    5486 </span><span class="lineCov">      27232 :           if (rf1-&gt;repr &amp;&amp; rf1-&gt;count &gt; 0)</span>
<span class="lineNum">    5487 </span>            :             break;
<span class="lineNum">    5488 </span>            :         }
<span class="lineNum">    5489 </span>            : 
<span class="lineNum">    5490 </span><span class="lineCov">      13892 :       if (j &lt; vec_len)</span>
<span class="lineNum">    5491 </span>            :         {
<span class="lineNum">    5492 </span><span class="lineCov">          9 :           power = rf1-&gt;count;</span>
<span class="lineNum">    5493 </span>            : 
<span class="lineNum">    5494 </span><span class="lineCov">          9 :           if (power == 1)</span>
<span class="lineNum">    5495 </span>            :             {
<span class="lineNum">    5496 </span><span class="lineCov">          7 :               iter_result = rf1-&gt;repr;</span>
<span class="lineNum">    5497 </span>            : 
<span class="lineNum">    5498 </span><span class="lineCov">          7 :               if (dump_file &amp;&amp; (dump_flags &amp; TDF_DETAILS))</span>
<span class="lineNum">    5499 </span>            :                 {
<span class="lineNum">    5500 </span><span class="lineNoCov">          0 :                   unsigned elt;</span>
<span class="lineNum">    5501 </span><span class="lineNoCov">          0 :                   repeat_factor *rf;</span>
<span class="lineNum">    5502 </span><span class="lineNoCov">          0 :                   fputs (&quot;Multiplying by cached product &quot;, dump_file);</span>
<span class="lineNum">    5503 </span><span class="lineNoCov">          0 :                   for (elt = j; elt &lt; vec_len; elt++)</span>
<span class="lineNum">    5504 </span>            :                     {
<span class="lineNum">    5505 </span><span class="lineNoCov">          0 :                       rf = &amp;repeat_factor_vec[elt];</span>
<span class="lineNum">    5506 </span><span class="lineNoCov">          0 :                       print_generic_expr (dump_file, rf-&gt;factor);</span>
<span class="lineNum">    5507 </span><span class="lineNoCov">          0 :                       if (elt &lt; vec_len - 1)</span>
<span class="lineNum">    5508 </span><span class="lineNoCov">          0 :                         fputs (&quot; * &quot;, dump_file);</span>
<span class="lineNum">    5509 </span>            :                     }
<span class="lineNum">    5510 </span><span class="lineNoCov">          0 :                   fputs (&quot;\n&quot;, dump_file);</span>
<span class="lineNum">    5511 </span>            :                 }
<span class="lineNum">    5512 </span>            :             }
<span class="lineNum">    5513 </span>            :           else
<span class="lineNum">    5514 </span>            :             {
<span class="lineNum">    5515 </span><span class="lineCov">          2 :               iter_result = make_temp_ssa_name (type, NULL, &quot;reassocpow&quot;);</span>
<span class="lineNum">    5516 </span><span class="lineCov">          4 :               pow_stmt = gimple_build_call (powi_fndecl, 2, rf1-&gt;repr, </span>
<span class="lineNum">    5517 </span>            :                                             build_int_cst (integer_type_node,
<span class="lineNum">    5518 </span>            :                                                            power));
<span class="lineNum">    5519 </span><span class="lineCov">          2 :               gimple_call_set_lhs (pow_stmt, iter_result);</span>
<span class="lineNum">    5520 </span><span class="lineCov">          4 :               gimple_set_location (pow_stmt, gimple_location (stmt));</span>
<span class="lineNum">    5521 </span><span class="lineCov">          4 :               gimple_set_uid (pow_stmt, gimple_uid (stmt));</span>
<span class="lineNum">    5522 </span><span class="lineCov">          2 :               gsi_insert_before (&amp;gsi, pow_stmt, GSI_SAME_STMT);</span>
<span class="lineNum">    5523 </span>            : 
<span class="lineNum">    5524 </span><span class="lineCov">          2 :               if (dump_file &amp;&amp; (dump_flags &amp; TDF_DETAILS))</span>
<span class="lineNum">    5525 </span>            :                 {
<span class="lineNum">    5526 </span><span class="lineNoCov">          0 :                   unsigned elt;</span>
<span class="lineNum">    5527 </span><span class="lineNoCov">          0 :                   repeat_factor *rf;</span>
<span class="lineNum">    5528 </span><span class="lineNoCov">          0 :                   fputs (&quot;Building __builtin_pow call for cached product (&quot;,</span>
<span class="lineNum">    5529 </span>            :                          dump_file);
<span class="lineNum">    5530 </span><span class="lineNoCov">          0 :                   for (elt = j; elt &lt; vec_len; elt++)</span>
<span class="lineNum">    5531 </span>            :                     {
<span class="lineNum">    5532 </span><span class="lineNoCov">          0 :                       rf = &amp;repeat_factor_vec[elt];</span>
<span class="lineNum">    5533 </span><span class="lineNoCov">          0 :                       print_generic_expr (dump_file, rf-&gt;factor);</span>
<span class="lineNum">    5534 </span><span class="lineNoCov">          0 :                       if (elt &lt; vec_len - 1)</span>
<span class="lineNum">    5535 </span><span class="lineNoCov">          0 :                         fputs (&quot; * &quot;, dump_file);</span>
<span class="lineNum">    5536 </span>            :                     }
<span class="lineNum">    5537 </span><span class="lineNoCov">          0 :                   fprintf (dump_file, &quot;)^&quot; HOST_WIDE_INT_PRINT_DEC&quot;\n&quot;,</span>
<span class="lineNum">    5538 </span>            :                            power);
<span class="lineNum">    5539 </span>            :                 }
<span class="lineNum">    5540 </span>            :             }
<span class="lineNum">    5541 </span>            :         }
<span class="lineNum">    5542 </span>            :       else
<span class="lineNum">    5543 </span>            :         {
<span class="lineNum">    5544 </span>            :           /* Otherwise, find the first factor in the repeated factor
<span class="lineNum">    5545 </span>            :              vector whose occurrence count is at least 2.  If no such
<span class="lineNum">    5546 </span>            :              factor exists, there are no builtin_powi opportunities
<span class="lineNum">    5547 </span>            :              remaining.  */
<span class="lineNum">    5548 </span><span class="lineCov">      40542 :           FOR_EACH_VEC_ELT (repeat_factor_vec, j, rf1)</span>
<span class="lineNum">    5549 </span>            :             {
<span class="lineNum">    5550 </span><span class="lineCov">      27177 :               if (rf1-&gt;count &gt;= 2)</span>
<span class="lineNum">    5551 </span>            :                 break;
<span class="lineNum">    5552 </span>            :             }
<span class="lineNum">    5553 </span>            : 
<span class="lineNum">    5554 </span><span class="lineCov">      13883 :           if (j &gt;= vec_len)</span>
<span class="lineNum">    5555 </span>            :             break;
<span class="lineNum">    5556 </span>            : 
<span class="lineNum">    5557 </span><span class="lineCov">        518 :           power = rf1-&gt;count;</span>
<span class="lineNum">    5558 </span>            : 
<span class="lineNum">    5559 </span><span class="lineCov">        518 :           if (dump_file &amp;&amp; (dump_flags &amp; TDF_DETAILS))</span>
<span class="lineNum">    5560 </span>            :             {
<span class="lineNum">    5561 </span><span class="lineNoCov">          0 :               unsigned elt;</span>
<span class="lineNum">    5562 </span><span class="lineNoCov">          0 :               repeat_factor *rf;</span>
<span class="lineNum">    5563 </span><span class="lineNoCov">          0 :               fputs (&quot;Building __builtin_pow call for (&quot;, dump_file);</span>
<span class="lineNum">    5564 </span><span class="lineNoCov">          0 :               for (elt = j; elt &lt; vec_len; elt++)</span>
<span class="lineNum">    5565 </span>            :                 {
<span class="lineNum">    5566 </span><span class="lineNoCov">          0 :                   rf = &amp;repeat_factor_vec[elt];</span>
<span class="lineNum">    5567 </span><span class="lineNoCov">          0 :                   print_generic_expr (dump_file, rf-&gt;factor);</span>
<span class="lineNum">    5568 </span><span class="lineNoCov">          0 :                   if (elt &lt; vec_len - 1)</span>
<span class="lineNum">    5569 </span><span class="lineNoCov">          0 :                     fputs (&quot; * &quot;, dump_file);</span>
<span class="lineNum">    5570 </span>            :                 }
<span class="lineNum">    5571 </span><span class="lineNoCov">          0 :               fprintf (dump_file, &quot;)^&quot; HOST_WIDE_INT_PRINT_DEC&quot;\n&quot;, power);</span>
<span class="lineNum">    5572 </span>            :             }
<span class="lineNum">    5573 </span>            : 
<span class="lineNum">    5574 </span><span class="lineCov">        518 :           reassociate_stats.pows_created++;</span>
<span class="lineNum">    5575 </span>            : 
<span class="lineNum">    5576 </span>            :           /* Visit each element of the vector in reverse order (so that
<span class="lineNum">    5577 </span>            :              high-occurrence elements are visited first, and within the
<span class="lineNum">    5578 </span>            :              same occurrence count, lower-ranked elements are visited
<span class="lineNum">    5579 </span>            :              first).  Form a linear product of all elements in this order
<span class="lineNum">    5580 </span>            :              whose occurrencce count is at least that of element J.
<span class="lineNum">    5581 </span>            :              Record the SSA name representing the product of each element
<span class="lineNum">    5582 </span>            :              with all subsequent elements in the vector.  */
<span class="lineNum">    5583 </span><span class="lineCov">        518 :           if (j == vec_len - 1)</span>
<span class="lineNum">    5584 </span><span class="lineCov">        493 :             rf1-&gt;repr = rf1-&gt;factor;</span>
<span class="lineNum">    5585 </span>            :           else
<span class="lineNum">    5586 </span>            :             {
<span class="lineNum">    5587 </span><span class="lineCov">         56 :               for (ii = vec_len - 2; ii &gt;= (int)j; ii--)</span>
<span class="lineNum">    5588 </span>            :                 {
<span class="lineNum">    5589 </span><span class="lineCov">         31 :                   tree op1, op2;</span>
<span class="lineNum">    5590 </span>            : 
<span class="lineNum">    5591 </span><span class="lineCov">         31 :                   rf1 = &amp;repeat_factor_vec[ii];</span>
<span class="lineNum">    5592 </span><span class="lineCov">         31 :                   rf2 = &amp;repeat_factor_vec[ii + 1];</span>
<span class="lineNum">    5593 </span>            : 
<span class="lineNum">    5594 </span>            :                   /* Init the last factor's representative to be itself.  */
<span class="lineNum">    5595 </span><span class="lineCov">         31 :                   if (!rf2-&gt;repr)</span>
<span class="lineNum">    5596 </span><span class="lineCov">         25 :                     rf2-&gt;repr = rf2-&gt;factor;</span>
<span class="lineNum">    5597 </span>            : 
<span class="lineNum">    5598 </span><span class="lineCov">         31 :                   op1 = rf1-&gt;factor;</span>
<span class="lineNum">    5599 </span><span class="lineCov">         31 :                   op2 = rf2-&gt;repr;</span>
<span class="lineNum">    5600 </span>            : 
<span class="lineNum">    5601 </span><span class="lineCov">         31 :                   target_ssa = make_temp_ssa_name (type, NULL, &quot;reassocpow&quot;);</span>
<span class="lineNum">    5602 </span><span class="lineCov">         31 :                   mul_stmt = gimple_build_assign (target_ssa, MULT_EXPR,</span>
<span class="lineNum">    5603 </span>            :                                                   op1, op2);
<span class="lineNum">    5604 </span><span class="lineCov">         62 :                   gimple_set_location (mul_stmt, gimple_location (stmt));</span>
<span class="lineNum">    5605 </span><span class="lineCov">         62 :                   gimple_set_uid (mul_stmt, gimple_uid (stmt));</span>
<span class="lineNum">    5606 </span><span class="lineCov">         31 :                   gsi_insert_before (&amp;gsi, mul_stmt, GSI_SAME_STMT);</span>
<span class="lineNum">    5607 </span><span class="lineCov">         31 :                   rf1-&gt;repr = target_ssa;</span>
<span class="lineNum">    5608 </span>            : 
<span class="lineNum">    5609 </span>            :                   /* Don't reprocess the multiply we just introduced.  */
<span class="lineNum">    5610 </span><span class="lineCov">         62 :                   gimple_set_visited (mul_stmt, true);</span>
<span class="lineNum">    5611 </span>            :                 }
<span class="lineNum">    5612 </span>            :             }
<span class="lineNum">    5613 </span>            : 
<span class="lineNum">    5614 </span>            :           /* Form a call to __builtin_powi for the maximum product
<span class="lineNum">    5615 </span>            :              just formed, raised to the power obtained earlier.  */
<span class="lineNum">    5616 </span><span class="lineCov">        518 :           rf1 = &amp;repeat_factor_vec[j];</span>
<span class="lineNum">    5617 </span><span class="lineCov">        518 :           iter_result = make_temp_ssa_name (type, NULL, &quot;reassocpow&quot;);</span>
<span class="lineNum">    5618 </span><span class="lineCov">       1036 :           pow_stmt = gimple_build_call (powi_fndecl, 2, rf1-&gt;repr, </span>
<span class="lineNum">    5619 </span>            :                                         build_int_cst (integer_type_node,
<span class="lineNum">    5620 </span>            :                                                        power));
<span class="lineNum">    5621 </span><span class="lineCov">        518 :           gimple_call_set_lhs (pow_stmt, iter_result);</span>
<span class="lineNum">    5622 </span><span class="lineCov">       1036 :           gimple_set_location (pow_stmt, gimple_location (stmt));</span>
<span class="lineNum">    5623 </span><span class="lineCov">       1036 :           gimple_set_uid (pow_stmt, gimple_uid (stmt));</span>
<span class="lineNum">    5624 </span><span class="lineCov">        518 :           gsi_insert_before (&amp;gsi, pow_stmt, GSI_SAME_STMT);</span>
<span class="lineNum">    5625 </span>            :         }
<span class="lineNum">    5626 </span>            : 
<span class="lineNum">    5627 </span>            :       /* If we previously formed at least one other builtin_powi call,
<span class="lineNum">    5628 </span>            :          form the product of this one and those others.  */
<span class="lineNum">    5629 </span><span class="lineCov">        527 :       if (result)</span>
<span class="lineNum">    5630 </span>            :         {
<span class="lineNum">    5631 </span><span class="lineCov">          9 :           tree new_result = make_temp_ssa_name (type, NULL, &quot;reassocpow&quot;);</span>
<span class="lineNum">    5632 </span><span class="lineCov">          9 :           mul_stmt = gimple_build_assign (new_result, MULT_EXPR,</span>
<span class="lineNum">    5633 </span>            :                                           result, iter_result);
<span class="lineNum">    5634 </span><span class="lineCov">         18 :           gimple_set_location (mul_stmt, gimple_location (stmt));</span>
<span class="lineNum">    5635 </span><span class="lineCov">         18 :           gimple_set_uid (mul_stmt, gimple_uid (stmt));</span>
<span class="lineNum">    5636 </span><span class="lineCov">          9 :           gsi_insert_before (&amp;gsi, mul_stmt, GSI_SAME_STMT);</span>
<span class="lineNum">    5637 </span><span class="lineCov">          9 :           gimple_set_visited (mul_stmt, true);</span>
<span class="lineNum">    5638 </span><span class="lineCov">          9 :           result = new_result;</span>
<span class="lineNum">    5639 </span>            :         }
<span class="lineNum">    5640 </span>            :       else
<span class="lineNum">    5641 </span>            :         result = iter_result;
<span class="lineNum">    5642 </span>            : 
<span class="lineNum">    5643 </span>            :       /* Decrement the occurrence count of each element in the product
<span class="lineNum">    5644 </span>            :          by the count found above, and remove this many copies of each
<span class="lineNum">    5645 </span>            :          factor from OPS.  */
<span class="lineNum">    5646 </span><span class="lineCov">       1090 :       for (i = j; i &lt; vec_len; i++)</span>
<span class="lineNum">    5647 </span>            :         {
<span class="lineNum">    5648 </span><span class="lineCov">        563 :           unsigned k = power;</span>
<span class="lineNum">    5649 </span><span class="lineCov">        563 :           unsigned n;</span>
<span class="lineNum">    5650 </span>            : 
<span class="lineNum">    5651 </span><span class="lineCov">        563 :           rf1 = &amp;repeat_factor_vec[i];</span>
<span class="lineNum">    5652 </span><span class="lineCov">        563 :           rf1-&gt;count -= power;</span>
<span class="lineNum">    5653 </span>            :           
<span class="lineNum">    5654 </span><span class="lineCov">       2246 :           FOR_EACH_VEC_ELT_REVERSE (*ops, n, oe)</span>
<span class="lineNum">    5655 </span>            :             {
<span class="lineNum">    5656 </span><span class="lineCov">       1683 :               if (oe-&gt;op == rf1-&gt;factor)</span>
<span class="lineNum">    5657 </span>            :                 {
<span class="lineNum">    5658 </span><span class="lineCov">       1431 :                   if (oe-&gt;count &lt;= k)</span>
<span class="lineNum">    5659 </span>            :                     {
<span class="lineNum">    5660 </span><span class="lineCov">       1425 :                       ops-&gt;ordered_remove (n);</span>
<span class="lineNum">    5661 </span><span class="lineCov">       1425 :                       k -= oe-&gt;count;</span>
<span class="lineNum">    5662 </span>            : 
<span class="lineNum">    5663 </span><span class="lineCov">       1425 :                       if (k == 0)</span>
<span class="lineNum">    5664 </span>            :                         break;
<span class="lineNum">    5665 </span>            :                     }
<span class="lineNum">    5666 </span>            :                   else
<span class="lineNum">    5667 </span>            :                     {
<span class="lineNum">    5668 </span><span class="lineCov">          6 :                       oe-&gt;count -= k;</span>
<span class="lineNum">    5669 </span><span class="lineCov">          6 :                       break;</span>
<span class="lineNum">    5670 </span>            :                     }
<span class="lineNum">    5671 </span>            :                 }
<span class="lineNum">    5672 </span>            :             }
<span class="lineNum">    5673 </span>            :         }
<span class="lineNum">    5674 </span>            :     }
<span class="lineNum">    5675 </span>            : 
<span class="lineNum">    5676 </span>            :   /* At this point all elements in the repeated factor vector have a
<span class="lineNum">    5677 </span>            :      remaining occurrence count of 0 or 1, and those with a count of 1
<span class="lineNum">    5678 </span>            :      don't have cached representatives.  Re-sort the ops vector and
<span class="lineNum">    5679 </span>            :      clean up.  */
<span class="lineNum">    5680 </span><span class="lineCov">      13365 :   ops-&gt;qsort (sort_by_operand_rank);</span>
<span class="lineNum">    5681 </span><span class="lineCov">      13365 :   repeat_factor_vec.release ();</span>
<span class="lineNum">    5682 </span>            : 
<span class="lineNum">    5683 </span>            :   /* Return the final product computed herein.  Note that there may
<span class="lineNum">    5684 </span>            :      still be some elements with single occurrence count left in OPS;
<span class="lineNum">    5685 </span>            :      those will be handled by the normal reassociation logic.  */
<span class="lineNum">    5686 </span>            :   return result;
<span class="lineNum">    5687 </span>            : }
<span class="lineNum">    5688 </span>            : 
<span class="lineNum">    5689 </span>            : /* Attempt to optimize
<span class="lineNum">    5690 </span>            :    CST1 * copysign (CST2, y) -&gt; copysign (CST1 * CST2, y) if CST1 &gt; 0, or
<span class="lineNum">    5691 </span>            :    CST1 * copysign (CST2, y) -&gt; -copysign (CST1 * CST2, y) if CST1 &lt; 0.  */
<span class="lineNum">    5692 </span>            : 
<span class="lineNum">    5693 </span>            : static void
<span class="lineNum">    5694 </span><span class="lineCov">     594635 : attempt_builtin_copysign (vec&lt;operand_entry *&gt; *ops)</span>
<span class="lineNum">    5695 </span>            : {
<span class="lineNum">    5696 </span><span class="lineCov">     594635 :   operand_entry *oe;</span>
<span class="lineNum">    5697 </span><span class="lineCov">     594635 :   unsigned int i;</span>
<span class="lineNum">    5698 </span><span class="lineCov">     594635 :   unsigned int length = ops-&gt;length ();</span>
<span class="lineNum">    5699 </span><span class="lineCov">     594635 :   tree cst = ops-&gt;last ()-&gt;op;</span>
<span class="lineNum">    5700 </span>            : 
<span class="lineNum">    5701 </span><span class="lineCov">     594635 :   if (length == 1 || TREE_CODE (cst) != REAL_CST)</span>
<span class="lineNum">    5702 </span>            :     return;
<span class="lineNum">    5703 </span>            : 
<span class="lineNum">    5704 </span><span class="lineCov">       4055 :   FOR_EACH_VEC_ELT (*ops, i, oe)</span>
<span class="lineNum">    5705 </span>            :     {
<span class="lineNum">    5706 </span><span class="lineCov">       2918 :       if (TREE_CODE (oe-&gt;op) == SSA_NAME</span>
<span class="lineNum">    5707 </span><span class="lineCov">       2918 :           &amp;&amp; has_single_use (oe-&gt;op))</span>
<span class="lineNum">    5708 </span>            :         {
<span class="lineNum">    5709 </span><span class="lineCov">        816 :           gimple *def_stmt = SSA_NAME_DEF_STMT (oe-&gt;op);</span>
<span class="lineNum">    5710 </span><span class="lineCov">        816 :           if (gcall *old_call = dyn_cast &lt;gcall *&gt; (def_stmt))</span>
<span class="lineNum">    5711 </span>            :             {
<span class="lineNum">    5712 </span><span class="lineCov">         48 :               tree arg0, arg1;</span>
<span class="lineNum">    5713 </span><span class="lineCov">         48 :               switch (gimple_call_combined_fn (old_call))</span>
<span class="lineNum">    5714 </span>            :                 {
<span class="lineNum">    5715 </span><span class="lineCov">         20 :                 CASE_CFN_COPYSIGN:</span>
<span class="lineNum">    5716 </span><span class="lineCov">         20 :                 CASE_CFN_COPYSIGN_FN:</span>
<span class="lineNum">    5717 </span><span class="lineCov">         20 :                   arg0 = gimple_call_arg (old_call, 0);</span>
<span class="lineNum">    5718 </span><span class="lineCov">         20 :                   arg1 = gimple_call_arg (old_call, 1);</span>
<span class="lineNum">    5719 </span>            :                   /* The first argument of copysign must be a constant,
<span class="lineNum">    5720 </span>            :                      otherwise there's nothing to do.  */
<span class="lineNum">    5721 </span><span class="lineCov">         20 :                   if (TREE_CODE (arg0) == REAL_CST)</span>
<span class="lineNum">    5722 </span>            :                     {
<span class="lineNum">    5723 </span><span class="lineCov">         20 :                       tree type = TREE_TYPE (arg0);</span>
<span class="lineNum">    5724 </span><span class="lineCov">         20 :                       tree mul = const_binop (MULT_EXPR, type, cst, arg0);</span>
<span class="lineNum">    5725 </span>            :                       /* If we couldn't fold to a single constant, skip it.
<span class="lineNum">    5726 </span>            :                          That happens e.g. for inexact multiplication when
<span class="lineNum">    5727 </span>            :                          -frounding-math.  */
<span class="lineNum">    5728 </span><span class="lineCov">         20 :                       if (mul == NULL_TREE)</span>
<span class="lineNum">    5729 </span>            :                         break;
<span class="lineNum">    5730 </span>            :                       /* Instead of adjusting OLD_CALL, let's build a new
<span class="lineNum">    5731 </span>            :                          call to not leak the LHS and prevent keeping bogus
<span class="lineNum">    5732 </span>            :                          debug statements.  DCE will clean up the old call.  */
<span class="lineNum">    5733 </span><span class="lineCov">         16 :                       gcall *new_call;</span>
<span class="lineNum">    5734 </span><span class="lineCov">         32 :                       if (gimple_call_internal_p (old_call))</span>
<span class="lineNum">    5735 </span><span class="lineNoCov">          0 :                         new_call = gimple_build_call_internal</span>
<span class="lineNum">    5736 </span><span class="lineNoCov">          0 :                           (IFN_COPYSIGN, 2, mul, arg1);</span>
<span class="lineNum">    5737 </span>            :                       else
<span class="lineNum">    5738 </span><span class="lineCov">         16 :                         new_call = gimple_build_call</span>
<span class="lineNum">    5739 </span><span class="lineCov">         16 :                           (gimple_call_fndecl (old_call), 2, mul, arg1);</span>
<span class="lineNum">    5740 </span><span class="lineCov">         16 :                       tree lhs = make_ssa_name (type);</span>
<span class="lineNum">    5741 </span><span class="lineCov">         16 :                       gimple_call_set_lhs (new_call, lhs);</span>
<span class="lineNum">    5742 </span><span class="lineCov">         32 :                       gimple_set_location (new_call,</span>
<span class="lineNum">    5743 </span>            :                                            gimple_location (old_call));
<span class="lineNum">    5744 </span><span class="lineCov">         16 :                       insert_stmt_after (new_call, old_call);</span>
<span class="lineNum">    5745 </span>            :                       /* We've used the constant, get rid of it.  */
<span class="lineNum">    5746 </span><span class="lineCov">         16 :                       ops-&gt;pop ();</span>
<span class="lineNum">    5747 </span><span class="lineCov">         16 :                       bool cst1_neg = real_isneg (TREE_REAL_CST_PTR (cst));</span>
<span class="lineNum">    5748 </span>            :                       /* Handle the CST1 &lt; 0 case by negating the result.  */
<span class="lineNum">    5749 </span><span class="lineCov">         16 :                       if (cst1_neg)</span>
<span class="lineNum">    5750 </span>            :                         {
<span class="lineNum">    5751 </span><span class="lineCov">          7 :                           tree negrhs = make_ssa_name (TREE_TYPE (lhs));</span>
<span class="lineNum">    5752 </span><span class="lineCov">          7 :                           gimple *negate_stmt</span>
<span class="lineNum">    5753 </span><span class="lineCov">          7 :                             = gimple_build_assign (negrhs, NEGATE_EXPR, lhs);</span>
<span class="lineNum">    5754 </span><span class="lineCov">          7 :                           insert_stmt_after (negate_stmt, new_call);</span>
<span class="lineNum">    5755 </span><span class="lineCov">          7 :                           oe-&gt;op = negrhs;</span>
<span class="lineNum">    5756 </span>            :                         }
<span class="lineNum">    5757 </span>            :                       else
<span class="lineNum">    5758 </span><span class="lineCov">          9 :                         oe-&gt;op = lhs;</span>
<span class="lineNum">    5759 </span><span class="lineCov">         16 :                       if (dump_file &amp;&amp; (dump_flags &amp; TDF_DETAILS))</span>
<span class="lineNum">    5760 </span>            :                         {
<span class="lineNum">    5761 </span><span class="lineCov">         14 :                           fprintf (dump_file, &quot;Optimizing copysign: &quot;);</span>
<span class="lineNum">    5762 </span><span class="lineCov">         14 :                           print_generic_expr (dump_file, cst);</span>
<span class="lineNum">    5763 </span><span class="lineCov">         14 :                           fprintf (dump_file, &quot; * COPYSIGN (&quot;);</span>
<span class="lineNum">    5764 </span><span class="lineCov">         14 :                           print_generic_expr (dump_file, arg0);</span>
<span class="lineNum">    5765 </span><span class="lineCov">         14 :                           fprintf (dump_file, &quot;, &quot;);</span>
<span class="lineNum">    5766 </span><span class="lineCov">         14 :                           print_generic_expr (dump_file, arg1);</span>
<span class="lineNum">    5767 </span><span class="lineCov">         23 :                           fprintf (dump_file, &quot;) into %sCOPYSIGN (&quot;,</span>
<span class="lineNum">    5768 </span>            :                                    cst1_neg ? &quot;-&quot; : &quot;&quot;);
<span class="lineNum">    5769 </span><span class="lineCov">         14 :                           print_generic_expr (dump_file, mul);</span>
<span class="lineNum">    5770 </span><span class="lineCov">         14 :                           fprintf (dump_file, &quot;, &quot;);</span>
<span class="lineNum">    5771 </span><span class="lineCov">         14 :                           print_generic_expr (dump_file, arg1);</span>
<span class="lineNum">    5772 </span><span class="lineCov">         14 :                           fprintf (dump_file, &quot;\n&quot;);</span>
<span class="lineNum">    5773 </span>            :                         }
<span class="lineNum">    5774 </span><span class="lineCov">         16 :                       return;</span>
<span class="lineNum">    5775 </span><span class="lineNoCov">          0 :                     }</span>
<span class="lineNum">    5776 </span>            :                   break;
<span class="lineNum">    5777 </span>            :                 default:
<span class="lineNum">    5778 </span>            :                   break;
<span class="lineNum">    5779 </span>            :                 }
<span class="lineNum">    5780 </span>            :             }
<span class="lineNum">    5781 </span>            :         }
<span class="lineNum">    5782 </span>            :     }
<span class="lineNum">    5783 </span>            : }
<span class="lineNum">    5784 </span>            : 
<span class="lineNum">    5785 </span>            : /* Transform STMT at *GSI into a copy by replacing its rhs with NEW_RHS.  */
<a name="5786"><span class="lineNum">    5786 </span>            : </a>
<span class="lineNum">    5787 </span>            : static void
<span class="lineNum">    5788 </span><span class="lineCov">       7672 : transform_stmt_to_copy (gimple_stmt_iterator *gsi, gimple *stmt, tree new_rhs)</span>
<span class="lineNum">    5789 </span>            : {
<span class="lineNum">    5790 </span><span class="lineCov">       7672 :   tree rhs1;</span>
<span class="lineNum">    5791 </span>            : 
<span class="lineNum">    5792 </span><span class="lineCov">       7672 :   if (dump_file &amp;&amp; (dump_flags &amp; TDF_DETAILS))</span>
<span class="lineNum">    5793 </span>            :     {
<span class="lineNum">    5794 </span><span class="lineCov">         27 :       fprintf (dump_file, &quot;Transforming &quot;);</span>
<span class="lineNum">    5795 </span><span class="lineCov">         27 :       print_gimple_stmt (dump_file, stmt, 0);</span>
<span class="lineNum">    5796 </span>            :     }
<span class="lineNum">    5797 </span>            : 
<span class="lineNum">    5798 </span><span class="lineCov">       7672 :   rhs1 = gimple_assign_rhs1 (stmt);</span>
<span class="lineNum">    5799 </span><span class="lineCov">       7672 :   gimple_assign_set_rhs_from_tree (gsi, new_rhs);</span>
<span class="lineNum">    5800 </span><span class="lineCov">       7672 :   update_stmt (stmt);</span>
<span class="lineNum">    5801 </span><span class="lineCov">       7672 :   remove_visited_stmt_chain (rhs1);</span>
<span class="lineNum">    5802 </span>            : 
<span class="lineNum">    5803 </span><span class="lineCov">       7672 :   if (dump_file &amp;&amp; (dump_flags &amp; TDF_DETAILS))</span>
<span class="lineNum">    5804 </span>            :     {
<span class="lineNum">    5805 </span><span class="lineCov">         27 :       fprintf (dump_file, &quot; into &quot;);</span>
<span class="lineNum">    5806 </span><span class="lineCov">         27 :       print_gimple_stmt (dump_file, stmt, 0);</span>
<span class="lineNum">    5807 </span>            :     }
<span class="lineNum">    5808 </span><span class="lineCov">       7672 : }</span>
<span class="lineNum">    5809 </span>            : 
<span class="lineNum">    5810 </span>            : /* Transform STMT at *GSI into a multiply of RHS1 and RHS2.  */
<a name="5811"><span class="lineNum">    5811 </span>            : </a>
<span class="lineNum">    5812 </span>            : static void
<span class="lineNum">    5813 </span><span class="lineCov">         28 : transform_stmt_to_multiply (gimple_stmt_iterator *gsi, gimple *stmt,</span>
<span class="lineNum">    5814 </span>            :                             tree rhs1, tree rhs2)
<span class="lineNum">    5815 </span>            : {
<span class="lineNum">    5816 </span><span class="lineCov">         28 :   if (dump_file &amp;&amp; (dump_flags &amp; TDF_DETAILS))</span>
<span class="lineNum">    5817 </span>            :     {
<span class="lineNum">    5818 </span><span class="lineNoCov">          0 :       fprintf (dump_file, &quot;Transforming &quot;);</span>
<span class="lineNum">    5819 </span><span class="lineNoCov">          0 :       print_gimple_stmt (dump_file, stmt, 0);</span>
<span class="lineNum">    5820 </span>            :     }
<span class="lineNum">    5821 </span>            : 
<span class="lineNum">    5822 </span><span class="lineCov">         28 :   gimple_assign_set_rhs_with_ops (gsi, MULT_EXPR, rhs1, rhs2);</span>
<span class="lineNum">    5823 </span><span class="lineCov">         56 :   update_stmt (gsi_stmt (*gsi));</span>
<span class="lineNum">    5824 </span><span class="lineCov">         28 :   remove_visited_stmt_chain (rhs1);</span>
<span class="lineNum">    5825 </span>            : 
<span class="lineNum">    5826 </span><span class="lineCov">         28 :   if (dump_file &amp;&amp; (dump_flags &amp; TDF_DETAILS))</span>
<span class="lineNum">    5827 </span>            :     {
<span class="lineNum">    5828 </span><span class="lineNoCov">          0 :       fprintf (dump_file, &quot; into &quot;);</span>
<span class="lineNum">    5829 </span><span class="lineNoCov">          0 :       print_gimple_stmt (dump_file, stmt, 0);</span>
<span class="lineNum">    5830 </span>            :     }
<span class="lineNum">    5831 </span><span class="lineCov">         28 : }</span>
<span class="lineNum">    5832 </span>            : 
<span class="lineNum">    5833 </span>            : /* Reassociate expressions in basic block BB and its post-dominator as
<span class="lineNum">    5834 </span>            :    children.
<span class="lineNum">    5835 </span>            : 
<span class="lineNum">    5836 </span>            :    Bubble up return status from maybe_optimize_range_tests.  */
<span class="lineNum">    5837 </span>            : 
<span class="lineNum">    5838 </span>            : static bool
<span class="lineNum">    5839 </span><span class="lineCov">   12527300 : reassociate_bb (basic_block bb)</span>
<span class="lineNum">    5840 </span>            : {
<span class="lineNum">    5841 </span><span class="lineCov">   12527300 :   gimple_stmt_iterator gsi;</span>
<span class="lineNum">    5842 </span><span class="lineCov">   12527300 :   basic_block son;</span>
<span class="lineNum">    5843 </span><span class="lineCov">   12527300 :   gimple *stmt = last_stmt (bb);</span>
<span class="lineNum">    5844 </span><span class="lineCov">   12527300 :   bool cfg_cleanup_needed = false;</span>
<span class="lineNum">    5845 </span>            : 
<span class="lineNum">    5846 </span><span class="lineCov">   12527300 :   if (stmt &amp;&amp; !gimple_visited_p (stmt))</span>
<span class="lineNum">    5847 </span><span class="lineCov">   10855556 :     cfg_cleanup_needed |= maybe_optimize_range_tests (stmt);</span>
<span class="lineNum">    5848 </span>            : 
<span class="lineNum">    5849 </span><span class="lineCov">  333741274 :   for (gsi = gsi_last_bb (bb); !gsi_end_p (gsi); gsi_prev (&amp;gsi))</span>
<span class="lineNum">    5850 </span>            :     {
<span class="lineNum">    5851 </span><span class="lineCov">  102895722 :       stmt = gsi_stmt (gsi);</span>
<span class="lineNum">    5852 </span>            : 
<span class="lineNum">    5853 </span><span class="lineCov">  102895722 :       if (is_gimple_assign (stmt)</span>
<span class="lineNum">    5854 </span><span class="lineCov">  102895722 :           &amp;&amp; !stmt_could_throw_p (stmt))</span>
<span class="lineNum">    5855 </span>            :         {
<span class="lineNum">    5856 </span><span class="lineCov">   26994193 :           tree lhs, rhs1, rhs2;</span>
<span class="lineNum">    5857 </span><span class="lineCov">   26994193 :           enum tree_code rhs_code = gimple_assign_rhs_code (stmt);</span>
<span class="lineNum">    5858 </span>            : 
<span class="lineNum">    5859 </span>            :           /* If this is not a gimple binary expression, there is
<span class="lineNum">    5860 </span>            :              nothing for us to do with it.  */
<span class="lineNum">    5861 </span><span class="lineCov">   53988386 :           if (get_gimple_rhs_class (rhs_code) != GIMPLE_BINARY_RHS)</span>
<span class="lineNum">    5862 </span>            :             continue;
<span class="lineNum">    5863 </span>            : 
<span class="lineNum">    5864 </span>            :           /* If this was part of an already processed statement,
<span class="lineNum">    5865 </span>            :              we don't need to touch it again. */
<span class="lineNum">    5866 </span><span class="lineCov">   13271106 :           if (gimple_visited_p (stmt))</span>
<span class="lineNum">    5867 </span>            :             {
<span class="lineNum">    5868 </span>            :               /* This statement might have become dead because of previous
<span class="lineNum">    5869 </span>            :                  reassociations.  */
<span class="lineNum">    5870 </span><span class="lineCov">     198946 :               if (has_zero_uses (gimple_get_lhs (stmt)))</span>
<span class="lineNum">    5871 </span>            :                 {
<span class="lineNum">    5872 </span><span class="lineCov">      61383 :                   reassoc_remove_stmt (&amp;gsi);</span>
<span class="lineNum">    5873 </span><span class="lineCov">      61383 :                   release_defs (stmt);</span>
<span class="lineNum">    5874 </span>            :                   /* We might end up removing the last stmt above which
<span class="lineNum">    5875 </span>            :                      places the iterator to the end of the sequence.
<span class="lineNum">    5876 </span>            :                      Reset it to the last stmt in this case which might
<span class="lineNum">    5877 </span>            :                      be the end of the sequence as well if we removed
<span class="lineNum">    5878 </span>            :                      the last statement of the sequence.  In which case
<span class="lineNum">    5879 </span>            :                      we need to bail out.  */
<span class="lineNum">    5880 </span><span class="lineCov">     122766 :                   if (gsi_end_p (gsi))</span>
<span class="lineNum">    5881 </span>            :                     {
<span class="lineNum">    5882 </span><span class="lineCov">        281 :                       gsi = gsi_last_bb (bb);</span>
<span class="lineNum">    5883 </span><span class="lineCov">        562 :                       if (gsi_end_p (gsi))</span>
<span class="lineNum">    5884 </span>            :                         break;
<span class="lineNum">    5885 </span>            :                     }
<span class="lineNum">    5886 </span>            :                 }
<span class="lineNum">    5887 </span><span class="lineCov">     198782 :               continue;</span>
<span class="lineNum">    5888 </span>            :             }
<span class="lineNum">    5889 </span>            : 
<span class="lineNum">    5890 </span><span class="lineCov">    6436607 :           lhs = gimple_assign_lhs (stmt);</span>
<span class="lineNum">    5891 </span><span class="lineCov">    6436607 :           rhs1 = gimple_assign_rhs1 (stmt);</span>
<span class="lineNum">    5892 </span><span class="lineCov">    6436607 :           rhs2 = gimple_assign_rhs2 (stmt);</span>
<span class="lineNum">    5893 </span>            : 
<span class="lineNum">    5894 </span>            :           /* For non-bit or min/max operations we can't associate
<span class="lineNum">    5895 </span>            :              all types.  Verify that here.  */
<span class="lineNum">    5896 </span><span class="lineCov">    6436607 :           if (rhs_code != BIT_IOR_EXPR</span>
<span class="lineNum">    5897 </span><span class="lineCov">    6436607 :               &amp;&amp; rhs_code != BIT_AND_EXPR</span>
<span class="lineNum">    5898 </span><span class="lineCov">    5835678 :               &amp;&amp; rhs_code != BIT_XOR_EXPR</span>
<span class="lineNum">    5899 </span><span class="lineCov">    5835678 :               &amp;&amp; rhs_code != MIN_EXPR</span>
<span class="lineNum">    5900 </span><span class="lineCov">    5773676 :               &amp;&amp; rhs_code != MAX_EXPR</span>
<span class="lineNum">    5901 </span><span class="lineCov">   12161510 :               &amp;&amp; (!can_reassociate_p (lhs)</span>
<span class="lineNum">    5902 </span><span class="lineCov">    2767088 :                   || !can_reassociate_p (rhs1)</span>
<span class="lineNum">    5903 </span><span class="lineCov">    2440868 :                   || !can_reassociate_p (rhs2)))</span>
<span class="lineNum">    5904 </span>            :             continue;
<span class="lineNum">    5905 </span>            : 
<span class="lineNum">    5906 </span><span class="lineCov">    3055966 :           if (associative_tree_code (rhs_code))</span>
<span class="lineNum">    5907 </span>            :             {
<span class="lineNum">    5908 </span><span class="lineCov">    7194469 :               auto_vec&lt;operand_entry *&gt; ops;</span>
<span class="lineNum">    5909 </span><span class="lineCov">    2416187 :               tree powi_result = NULL_TREE;</span>
<span class="lineNum">    5910 </span><span class="lineCov">    2416187 :               bool is_vector = VECTOR_TYPE_P (TREE_TYPE (lhs));</span>
<span class="lineNum">    5911 </span>            : 
<span class="lineNum">    5912 </span>            :               /* There may be no immediate uses left by the time we
<span class="lineNum">    5913 </span>            :                  get here because we may have eliminated them all.  */
<span class="lineNum">    5914 </span><span class="lineCov">    2416187 :               if (TREE_CODE (lhs) == SSA_NAME &amp;&amp; has_zero_uses (lhs))</span>
<span class="lineNum">    5915 </span><span class="lineCov">      54092 :                 continue;</span>
<span class="lineNum">    5916 </span>            : 
<span class="lineNum">    5917 </span><span class="lineCov">    2389141 :               gimple_set_visited (stmt, true);</span>
<span class="lineNum">    5918 </span><span class="lineCov">    2389141 :               linearize_expr_tree (&amp;ops, stmt, true, true);</span>
<span class="lineNum">    5919 </span><span class="lineCov">    2389141 :               ops.qsort (sort_by_operand_rank);</span>
<span class="lineNum">    5920 </span><span class="lineCov">    2389141 :               int orig_len = ops.length ();</span>
<span class="lineNum">    5921 </span><span class="lineCov">    2389141 :               optimize_ops_list (rhs_code, &amp;ops);</span>
<span class="lineNum">    5922 </span><span class="lineCov">    4778282 :               if (undistribute_ops_list (rhs_code, &amp;ops,</span>
<span class="lineNum">    5923 </span>            :                                          loop_containing_stmt (stmt)))
<span class="lineNum">    5924 </span>            :                 {
<span class="lineNum">    5925 </span><span class="lineCov">         98 :                   ops.qsort (sort_by_operand_rank);</span>
<span class="lineNum">    5926 </span><span class="lineCov">         98 :                   optimize_ops_list (rhs_code, &amp;ops);</span>
<span class="lineNum">    5927 </span>            :                 }
<span class="lineNum">    5928 </span>            : 
<span class="lineNum">    5929 </span><span class="lineCov">    2389141 :               if (rhs_code == PLUS_EXPR</span>
<span class="lineNum">    5930 </span><span class="lineCov">    2389141 :                   &amp;&amp; transform_add_to_multiply (&amp;ops))</span>
<span class="lineNum">    5931 </span><span class="lineCov">         63 :                 ops.qsort (sort_by_operand_rank);</span>
<span class="lineNum">    5932 </span>            : 
<span class="lineNum">    5933 </span><span class="lineCov">    2389141 :               if (rhs_code == BIT_IOR_EXPR || rhs_code == BIT_AND_EXPR)</span>
<span class="lineNum">    5934 </span>            :                 {
<span class="lineNum">    5935 </span><span class="lineCov">     597513 :                   if (is_vector)</span>
<span class="lineNum">    5936 </span><span class="lineCov">       3483 :                     optimize_vec_cond_expr (rhs_code, &amp;ops);</span>
<span class="lineNum">    5937 </span>            :                   else
<span class="lineNum">    5938 </span><span class="lineCov">     594030 :                     optimize_range_tests (rhs_code, &amp;ops, NULL);</span>
<span class="lineNum">    5939 </span>            :                 }
<span class="lineNum">    5940 </span>            : 
<span class="lineNum">    5941 </span><span class="lineCov">    2389141 :               if (rhs_code == MULT_EXPR &amp;&amp; !is_vector)</span>
<span class="lineNum">    5942 </span>            :                 {
<span class="lineNum">    5943 </span><span class="lineCov">     594635 :                   attempt_builtin_copysign (&amp;ops);</span>
<span class="lineNum">    5944 </span>            : 
<span class="lineNum">    5945 </span><span class="lineCov">     594635 :                   if (reassoc_insert_powi_p</span>
<span class="lineNum">    5946 </span><span class="lineCov">     248059 :                       &amp;&amp; flag_unsafe_math_optimizations)</span>
<span class="lineNum">    5947 </span><span class="lineCov">      41060 :                     powi_result = attempt_builtin_powi (stmt, &amp;ops);</span>
<span class="lineNum">    5948 </span>            :                 }
<span class="lineNum">    5949 </span>            : 
<span class="lineNum">    5950 </span><span class="lineCov">    2389141 :               operand_entry *last;</span>
<span class="lineNum">    5951 </span><span class="lineCov">    2389141 :               bool negate_result = false;</span>
<span class="lineNum">    5952 </span><span class="lineCov">    2389141 :               if (ops.length () &gt; 1</span>
<span class="lineNum">    5953 </span><span class="lineCov">    2389141 :                   &amp;&amp; rhs_code == MULT_EXPR)</span>
<span class="lineNum">    5954 </span>            :                 {
<span class="lineNum">    5955 </span><span class="lineCov">     602844 :                   last = ops.last ();</span>
<span class="lineNum">    5956 </span><span class="lineCov">     602844 :                   if ((integer_minus_onep (last-&gt;op)</span>
<span class="lineNum">    5957 </span><span class="lineCov">     602770 :                        || real_minus_onep (last-&gt;op))</span>
<span class="lineNum">    5958 </span><span class="lineCov">         96 :                       &amp;&amp; !HONOR_SNANS (TREE_TYPE (lhs))</span>
<span class="lineNum">    5959 </span><span class="lineCov">     602940 :                       &amp;&amp; (!HONOR_SIGNED_ZEROS (TREE_TYPE (lhs))</span>
<span class="lineNum">    5960 </span><span class="lineNoCov">          0 :                           || !COMPLEX_FLOAT_TYPE_P (TREE_TYPE (lhs))))</span>
<span class="lineNum">    5961 </span>            :                     {
<span class="lineNum">    5962 </span><span class="lineCov">         96 :                       ops.pop ();</span>
<span class="lineNum">    5963 </span><span class="lineCov">         96 :                       negate_result = true;</span>
<span class="lineNum">    5964 </span>            :                     }
<span class="lineNum">    5965 </span>            :                 }
<span class="lineNum">    5966 </span>            : 
<span class="lineNum">    5967 </span><span class="lineCov">    2389141 :               tree new_lhs = lhs;</span>
<span class="lineNum">    5968 </span>            :               /* If the operand vector is now empty, all operands were 
<span class="lineNum">    5969 </span>            :                  consumed by the __builtin_powi optimization.  */
<span class="lineNum">    5970 </span><span class="lineCov">    2389141 :               if (ops.length () == 0)</span>
<span class="lineNum">    5971 </span><span class="lineCov">        434 :                 transform_stmt_to_copy (&amp;gsi, stmt, powi_result);</span>
<span class="lineNum">    5972 </span><span class="lineCov">    4777414 :               else if (ops.length () == 1)</span>
<span class="lineNum">    5973 </span>            :                 {
<span class="lineNum">    5974 </span><span class="lineCov">       7266 :                   tree last_op = ops.last ()-&gt;op;</span>
<span class="lineNum">    5975 </span>            : 
<span class="lineNum">    5976 </span>            :                   /* If the stmt that defines operand has to be inserted, insert it
<span class="lineNum">    5977 </span>            :                      before the use.  */
<span class="lineNum">    5978 </span><span class="lineCov">      14532 :                   if (ops.last ()-&gt;stmt_to_insert)</span>
<span class="lineNum">    5979 </span><span class="lineNoCov">          0 :                     insert_stmt_before_use (stmt, ops.last ()-&gt;stmt_to_insert);</span>
<span class="lineNum">    5980 </span><span class="lineCov">       7266 :                   if (powi_result)</span>
<span class="lineNum">    5981 </span><span class="lineCov">         28 :                     transform_stmt_to_multiply (&amp;gsi, stmt, last_op,</span>
<span class="lineNum">    5982 </span>            :                                                 powi_result);
<span class="lineNum">    5983 </span>            :                   else
<span class="lineNum">    5984 </span><span class="lineCov">       7238 :                     transform_stmt_to_copy (&amp;gsi, stmt, last_op);</span>
<span class="lineNum">    5985 </span>            :                 }
<span class="lineNum">    5986 </span>            :               else
<span class="lineNum">    5987 </span>            :                 {
<span class="lineNum">    5988 </span><span class="lineCov">    2381441 :                   machine_mode mode = TYPE_MODE (TREE_TYPE (lhs));</span>
<span class="lineNum">    5989 </span><span class="lineCov">    2381441 :                   int ops_num = ops.length ();</span>
<span class="lineNum">    5990 </span><span class="lineCov">    2381441 :                   int width = get_reassociation_width (ops_num, rhs_code, mode);</span>
<span class="lineNum">    5991 </span>            : 
<span class="lineNum">    5992 </span><span class="lineCov">    2381441 :                   if (dump_file &amp;&amp; (dump_flags &amp; TDF_DETAILS))</span>
<span class="lineNum">    5993 </span><span class="lineCov">         96 :                     fprintf (dump_file,</span>
<span class="lineNum">    5994 </span>            :                              &quot;Width = %d was chosen for reassociation\n&quot;, width);
<span class="lineNum">    5995 </span>            : 
<span class="lineNum">    5996 </span>            : 
<span class="lineNum">    5997 </span>            :                   /* For binary bit operations, if there are at least 3
<span class="lineNum">    5998 </span>            :                      operands and the last last operand in OPS is a constant,
<span class="lineNum">    5999 </span>            :                      move it to the front.  This helps ensure that we generate
<span class="lineNum">    6000 </span>            :                      (X &amp; Y) &amp; C rather than (X &amp; C) &amp; Y.  The former will
<span class="lineNum">    6001 </span>            :                      often match a canonical bit test when we get to RTL.  */
<span class="lineNum">    6002 </span><span class="lineCov">    2381441 :                   if (ops.length () &gt; 2</span>
<span class="lineNum">    6003 </span><span class="lineCov">      95207 :                       &amp;&amp; (rhs_code == BIT_AND_EXPR</span>
<span class="lineNum">    6004 </span>            :                           || rhs_code == BIT_IOR_EXPR
<span class="lineNum">    6005 </span><span class="lineCov">      81137 :                           || rhs_code == BIT_XOR_EXPR)</span>
<span class="lineNum">    6006 </span><span class="lineCov">    2415329 :                       &amp;&amp; TREE_CODE (ops.last ()-&gt;op) == INTEGER_CST)</span>
<span class="lineNum">    6007 </span><span class="lineCov">       1052 :                     std::swap (*ops[0], *ops[ops_num - 1]);</span>
<span class="lineNum">    6008 </span>            : 
<span class="lineNum">    6009 </span><span class="lineCov">    2381441 :                   if (width &gt; 1</span>
<span class="lineNum">    6010 </span><span class="lineCov">    2381441 :                       &amp;&amp; ops.length () &gt; 3)</span>
<span class="lineNum">    6011 </span><span class="lineCov">       1733 :                     rewrite_expr_tree_parallel (as_a &lt;gassign *&gt; (stmt),</span>
<span class="lineNum">    6012 </span>            :                                                 width, ops);
<span class="lineNum">    6013 </span>            :                   else
<span class="lineNum">    6014 </span>            :                     {
<span class="lineNum">    6015 </span>            :                       /* When there are three operands left, we want
<span class="lineNum">    6016 </span>            :                          to make sure the ones that get the double
<span class="lineNum">    6017 </span>            :                          binary op are chosen wisely.  */
<span class="lineNum">    6018 </span><span class="lineCov">    2379708 :                       int len = ops.length ();</span>
<span class="lineNum">    6019 </span><span class="lineCov">    2379708 :                       if (len &gt;= 3)</span>
<span class="lineNum">    6020 </span><span class="lineCov">      93474 :                         swap_ops_for_binary_stmt (ops, len - 3, stmt);</span>
<span class="lineNum">    6021 </span>            : 
<span class="lineNum">    6022 </span><span class="lineCov">    4759416 :                       new_lhs = rewrite_expr_tree (stmt, 0, ops,</span>
<span class="lineNum">    6023 </span><span class="lineCov">    2379708 :                                                    powi_result != NULL</span>
<span class="lineNum">    6024 </span><span class="lineCov">    2379708 :                                                    || negate_result,</span>
<span class="lineNum">    6025 </span>            :                                                    len != orig_len);
<span class="lineNum">    6026 </span>            :                     }
<span class="lineNum">    6027 </span>            : 
<span class="lineNum">    6028 </span>            :                   /* If we combined some repeated factors into a 
<span class="lineNum">    6029 </span>            :                      __builtin_powi call, multiply that result by the
<span class="lineNum">    6030 </span>            :                      reassociated operands.  */
<span class="lineNum">    6031 </span><span class="lineCov">    2381441 :                   if (powi_result)</span>
<span class="lineNum">    6032 </span>            :                     {
<span class="lineNum">    6033 </span><span class="lineCov">         56 :                       gimple *mul_stmt, *lhs_stmt = SSA_NAME_DEF_STMT (lhs);</span>
<span class="lineNum">    6034 </span><span class="lineCov">         56 :                       tree type = TREE_TYPE (lhs);</span>
<span class="lineNum">    6035 </span><span class="lineCov">         56 :                       tree target_ssa = make_temp_ssa_name (type, NULL,</span>
<span class="lineNum">    6036 </span>            :                                                             &quot;reassocpow&quot;);
<span class="lineNum">    6037 </span><span class="lineCov">         56 :                       gimple_set_lhs (lhs_stmt, target_ssa);</span>
<span class="lineNum">    6038 </span><span class="lineCov">         56 :                       update_stmt (lhs_stmt);</span>
<span class="lineNum">    6039 </span><span class="lineCov">         56 :                       if (lhs != new_lhs)</span>
<span class="lineNum">    6040 </span>            :                         {
<span class="lineNum">    6041 </span><span class="lineCov">         55 :                           target_ssa = new_lhs;</span>
<span class="lineNum">    6042 </span><span class="lineCov">         55 :                           new_lhs = lhs;</span>
<span class="lineNum">    6043 </span>            :                         }
<span class="lineNum">    6044 </span><span class="lineCov">         56 :                       mul_stmt = gimple_build_assign (lhs, MULT_EXPR,</span>
<span class="lineNum">    6045 </span>            :                                                       powi_result, target_ssa);
<span class="lineNum">    6046 </span><span class="lineCov">        112 :                       gimple_set_location (mul_stmt, gimple_location (stmt));</span>
<span class="lineNum">    6047 </span><span class="lineCov">        112 :                       gimple_set_uid (mul_stmt, gimple_uid (stmt));</span>
<span class="lineNum">    6048 </span><span class="lineCov">         56 :                       gsi_insert_after (&amp;gsi, mul_stmt, GSI_NEW_STMT);</span>
<span class="lineNum">    6049 </span>            :                     }
<span class="lineNum">    6050 </span>            :                 }
<span class="lineNum">    6051 </span>            : 
<span class="lineNum">    6052 </span><span class="lineCov">    2389141 :               if (negate_result)</span>
<span class="lineNum">    6053 </span>            :                 {
<span class="lineNum">    6054 </span><span class="lineCov">         96 :                   stmt = SSA_NAME_DEF_STMT (lhs);</span>
<span class="lineNum">    6055 </span><span class="lineCov">         96 :                   tree tmp = make_ssa_name (TREE_TYPE (lhs));</span>
<span class="lineNum">    6056 </span><span class="lineCov">         96 :                   gimple_set_lhs (stmt, tmp);</span>
<span class="lineNum">    6057 </span><span class="lineCov">         96 :                   if (lhs != new_lhs)</span>
<span class="lineNum">    6058 </span><span class="lineCov">         86 :                     tmp = new_lhs;</span>
<span class="lineNum">    6059 </span><span class="lineCov">         96 :                   gassign *neg_stmt = gimple_build_assign (lhs, NEGATE_EXPR,</span>
<span class="lineNum">    6060 </span>            :                                                            tmp);
<span class="lineNum">    6061 </span><span class="lineCov">        192 :                   gimple_set_uid (neg_stmt, gimple_uid (stmt));</span>
<span class="lineNum">    6062 </span><span class="lineCov">         96 :                   gsi_insert_after (&amp;gsi, neg_stmt, GSI_NEW_STMT);</span>
<span class="lineNum">    6063 </span><span class="lineCov">         96 :                   update_stmt (stmt);</span>
<span class="lineNum">    6064 </span>            :                 }
<span class="lineNum">    6065 </span>            :             }
<span class="lineNum">    6066 </span>            :         }
<span class="lineNum">    6067 </span>            :     }
<span class="lineNum">    6068 </span><span class="lineCov">   23812797 :   for (son = first_dom_son (CDI_POST_DOMINATORS, bb);</span>
<span class="lineNum">    6069 </span><span class="lineCov">   23812797 :        son;</span>
<span class="lineNum">    6070 </span><span class="lineCov">   11285497 :        son = next_dom_son (CDI_POST_DOMINATORS, son))</span>
<span class="lineNum">    6071 </span><span class="lineCov">   11285497 :     cfg_cleanup_needed |= reassociate_bb (son);</span>
<span class="lineNum">    6072 </span>            : 
<span class="lineNum">    6073 </span><span class="lineCov">   12527300 :   return cfg_cleanup_needed;</span>
<span class="lineNum">    6074 </span>            : }
<span class="lineNum">    6075 </span>            : 
<span class="lineNum">    6076 </span>            : /* Add jumps around shifts for range tests turned into bit tests.
<span class="lineNum">    6077 </span>            :    For each SSA_NAME VAR we have code like:
<span class="lineNum">    6078 </span>            :    VAR = ...; // final stmt of range comparison
<span class="lineNum">    6079 </span>            :    // bit test here...;
<span class="lineNum">    6080 </span>            :    OTHERVAR = ...; // final stmt of the bit test sequence
<span class="lineNum">    6081 </span>            :    RES = VAR | OTHERVAR;
<span class="lineNum">    6082 </span>            :    Turn the above into:
<span class="lineNum">    6083 </span>            :    VAR = ...;
<span class="lineNum">    6084 </span>            :    if (VAR != 0)
<span class="lineNum">    6085 </span>            :      goto &lt;l3&gt;;
<span class="lineNum">    6086 </span>            :    else
<span class="lineNum">    6087 </span>            :      goto &lt;l2&gt;;
<span class="lineNum">    6088 </span>            :    &lt;l2&gt;:
<span class="lineNum">    6089 </span>            :    // bit test here...;
<span class="lineNum">    6090 </span>            :    OTHERVAR = ...;
<span class="lineNum">    6091 </span>            :    &lt;l3&gt;:
<span class="lineNum">    6092 </span>            :    # RES = PHI&lt;1(l1), OTHERVAR(l2)&gt;;  */
<span class="lineNum">    6093 </span>            : 
<span class="lineNum">    6094 </span>            : static void
<span class="lineNum">    6095 </span><span class="lineCov">    1241803 : branch_fixup (void)</span>
<span class="lineNum">    6096 </span>            : {
<span class="lineNum">    6097 </span><span class="lineCov">    1241803 :   tree var;</span>
<span class="lineNum">    6098 </span><span class="lineCov">    1241803 :   unsigned int i;</span>
<span class="lineNum">    6099 </span>            : 
<span class="lineNum">    6100 </span><span class="lineCov">    1242531 :   FOR_EACH_VEC_ELT (reassoc_branch_fixups, i, var)</span>
<span class="lineNum">    6101 </span>            :     {
<span class="lineNum">    6102 </span><span class="lineCov">        728 :       gimple *def_stmt = SSA_NAME_DEF_STMT (var);</span>
<span class="lineNum">    6103 </span><span class="lineCov">        728 :       gimple *use_stmt;</span>
<span class="lineNum">    6104 </span><span class="lineCov">        728 :       use_operand_p use;</span>
<span class="lineNum">    6105 </span><span class="lineCov">        728 :       bool ok = single_imm_use (var, &amp;use, &amp;use_stmt);</span>
<span class="lineNum">    6106 </span><span class="lineCov">        728 :       gcc_assert (ok</span>
<span class="lineNum">    6107 </span>            :                   &amp;&amp; is_gimple_assign (use_stmt)
<span class="lineNum">    6108 </span>            :                   &amp;&amp; gimple_assign_rhs_code (use_stmt) == BIT_IOR_EXPR
<span class="lineNum">    6109 </span>            :                   &amp;&amp; gimple_bb (def_stmt) == gimple_bb (use_stmt));
<span class="lineNum">    6110 </span>            : 
<span class="lineNum">    6111 </span><span class="lineCov">        728 :       basic_block cond_bb = gimple_bb (def_stmt);</span>
<span class="lineNum">    6112 </span><span class="lineCov">        728 :       basic_block then_bb = split_block (cond_bb, def_stmt)-&gt;dest;</span>
<span class="lineNum">    6113 </span><span class="lineCov">        728 :       basic_block merge_bb = split_block (then_bb, use_stmt)-&gt;dest;</span>
<span class="lineNum">    6114 </span>            : 
<span class="lineNum">    6115 </span><span class="lineCov">        728 :       gimple_stmt_iterator gsi = gsi_for_stmt (def_stmt);</span>
<span class="lineNum">    6116 </span><span class="lineCov">        728 :       gimple *g = gimple_build_cond (NE_EXPR, var,</span>
<span class="lineNum">    6117 </span><span class="lineCov">        728 :                                      build_zero_cst (TREE_TYPE (var)),</span>
<span class="lineNum">    6118 </span>            :                                      NULL_TREE, NULL_TREE);
<span class="lineNum">    6119 </span><span class="lineCov">        728 :       location_t loc = gimple_location (use_stmt);</span>
<span class="lineNum">    6120 </span><span class="lineCov">        728 :       gimple_set_location (g, loc);</span>
<span class="lineNum">    6121 </span><span class="lineCov">        728 :       gsi_insert_after (&amp;gsi, g, GSI_NEW_STMT);</span>
<span class="lineNum">    6122 </span>            : 
<span class="lineNum">    6123 </span><span class="lineCov">        728 :       edge etrue = make_edge (cond_bb, merge_bb, EDGE_TRUE_VALUE);</span>
<span class="lineNum">    6124 </span><span class="lineCov">        728 :       etrue-&gt;probability = profile_probability::even ();</span>
<span class="lineNum">    6125 </span><span class="lineCov">        728 :       edge efalse = find_edge (cond_bb, then_bb);</span>
<span class="lineNum">    6126 </span><span class="lineCov">        728 :       efalse-&gt;flags = EDGE_FALSE_VALUE;</span>
<span class="lineNum">    6127 </span><span class="lineCov">        728 :       efalse-&gt;probability -= etrue-&gt;probability;</span>
<span class="lineNum">    6128 </span><span class="lineCov">        728 :       then_bb-&gt;count -= etrue-&gt;count ();</span>
<span class="lineNum">    6129 </span>            : 
<span class="lineNum">    6130 </span><span class="lineCov">        728 :       tree othervar = NULL_TREE;</span>
<span class="lineNum">    6131 </span><span class="lineCov">        728 :       if (gimple_assign_rhs1 (use_stmt) == var)</span>
<span class="lineNum">    6132 </span><span class="lineNoCov">          0 :         othervar = gimple_assign_rhs2 (use_stmt);</span>
<span class="lineNum">    6133 </span><span class="lineCov">        728 :       else if (gimple_assign_rhs2 (use_stmt) == var)</span>
<span class="lineNum">    6134 </span>            :         othervar = gimple_assign_rhs1 (use_stmt);
<span class="lineNum">    6135 </span>            :       else
<span class="lineNum">    6136 </span><span class="lineNoCov">          0 :         gcc_unreachable ();</span>
<span class="lineNum">    6137 </span><span class="lineCov">        728 :       tree lhs = gimple_assign_lhs (use_stmt);</span>
<span class="lineNum">    6138 </span><span class="lineCov">        728 :       gphi *phi = create_phi_node (lhs, merge_bb);</span>
<span class="lineNum">    6139 </span><span class="lineCov">        728 :       add_phi_arg (phi, build_one_cst (TREE_TYPE (lhs)), etrue, loc);</span>
<span class="lineNum">    6140 </span><span class="lineCov">        728 :       add_phi_arg (phi, othervar, single_succ_edge (then_bb), loc);</span>
<span class="lineNum">    6141 </span><span class="lineCov">        728 :       gsi = gsi_for_stmt (use_stmt);</span>
<span class="lineNum">    6142 </span><span class="lineCov">        728 :       gsi_remove (&amp;gsi, true);</span>
<span class="lineNum">    6143 </span>            : 
<span class="lineNum">    6144 </span><span class="lineCov">        728 :       set_immediate_dominator (CDI_DOMINATORS, merge_bb, cond_bb);</span>
<span class="lineNum">    6145 </span><span class="lineCov">        728 :       set_immediate_dominator (CDI_POST_DOMINATORS, cond_bb, merge_bb);</span>
<span class="lineNum">    6146 </span>            :     }
<span class="lineNum">    6147 </span><span class="lineCov">    1241803 :   reassoc_branch_fixups.release ();</span>
<span class="lineNum">    6148 </span><span class="lineCov">    1241803 : }</span>
<span class="lineNum">    6149 </span>            : 
<span class="lineNum">    6150 </span>            : void dump_ops_vector (FILE *file, vec&lt;operand_entry *&gt; ops);
<span class="lineNum">    6151 </span>            : void debug_ops_vector (vec&lt;operand_entry *&gt; ops);
<span class="lineNum">    6152 </span>            : 
<span class="lineNum">    6153 </span>            : /* Dump the operand entry vector OPS to FILE.  */
<span class="lineNum">    6154 </span>            : 
<span class="lineNum">    6155 </span>            : void
<span class="lineNum">    6156 </span><span class="lineNoCov">          0 : dump_ops_vector (FILE *file, vec&lt;operand_entry *&gt; ops)</span>
<span class="lineNum">    6157 </span>            : {
<span class="lineNum">    6158 </span><span class="lineNoCov">          0 :   operand_entry *oe;</span>
<span class="lineNum">    6159 </span><span class="lineNoCov">          0 :   unsigned int i;</span>
<span class="lineNum">    6160 </span>            : 
<span class="lineNum">    6161 </span><span class="lineNoCov">          0 :   FOR_EACH_VEC_ELT (ops, i, oe)</span>
<span class="lineNum">    6162 </span>            :     {
<span class="lineNum">    6163 </span><span class="lineNoCov">          0 :       fprintf (file, &quot;Op %d -&gt; rank: %d, tree: &quot;, i, oe-&gt;rank);</span>
<span class="lineNum">    6164 </span><span class="lineNoCov">          0 :       print_generic_expr (file, oe-&gt;op);</span>
<span class="lineNum">    6165 </span><span class="lineNoCov">          0 :       fprintf (file, &quot;\n&quot;);</span>
<span class="lineNum">    6166 </span>            :     }
<span class="lineNum">    6167 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    6168 </span>            : 
<span class="lineNum">    6169 </span>            : /* Dump the operand entry vector OPS to STDERR.  */
<a name="6170"><span class="lineNum">    6170 </span>            : </a>
<span class="lineNum">    6171 </span>            : DEBUG_FUNCTION void
<span class="lineNum">    6172 </span><span class="lineNoCov">          0 : debug_ops_vector (vec&lt;operand_entry *&gt; ops)</span>
<span class="lineNum">    6173 </span>            : {
<span class="lineNum">    6174 </span><span class="lineNoCov">          0 :   dump_ops_vector (stderr, ops);</span>
<span class="lineNum">    6175 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    6176 </span>            : 
<span class="lineNum">    6177 </span>            : /* Bubble up return status from reassociate_bb.  */
<a name="6178"><span class="lineNum">    6178 </span>            : </a>
<span class="lineNum">    6179 </span>            : static bool
<span class="lineNum">    6180 </span><span class="lineCov">    1241803 : do_reassoc (void)</span>
<span class="lineNum">    6181 </span>            : {
<span class="lineNum">    6182 </span><span class="lineCov">    1241803 :   break_up_subtract_bb (ENTRY_BLOCK_PTR_FOR_FN (cfun));</span>
<span class="lineNum">    6183 </span><span class="lineCov">    1241803 :   return reassociate_bb (EXIT_BLOCK_PTR_FOR_FN (cfun));</span>
<span class="lineNum">    6184 </span>            : }
<span class="lineNum">    6185 </span>            : 
<span class="lineNum">    6186 </span>            : /* Initialize the reassociation pass.  */
<span class="lineNum">    6187 </span>            : 
<span class="lineNum">    6188 </span>            : static void
<span class="lineNum">    6189 </span><span class="lineCov">    1241803 : init_reassoc (void)</span>
<span class="lineNum">    6190 </span>            : {
<span class="lineNum">    6191 </span><span class="lineCov">    1241803 :   int i;</span>
<span class="lineNum">    6192 </span><span class="lineCov">    1241803 :   long rank = 2;</span>
<span class="lineNum">    6193 </span><span class="lineCov">    1241803 :   int *bbs = XNEWVEC (int, n_basic_blocks_for_fn (cfun) - NUM_FIXED_BLOCKS);</span>
<span class="lineNum">    6194 </span>            : 
<span class="lineNum">    6195 </span>            :   /* Find the loops, so that we can prevent moving calculations in
<span class="lineNum">    6196 </span>            :      them.  */
<span class="lineNum">    6197 </span><span class="lineCov">    1241803 :   loop_optimizer_init (AVOID_CFG_MODIFICATIONS);</span>
<span class="lineNum">    6198 </span>            : 
<span class="lineNum">    6199 </span><span class="lineCov">    1241803 :   memset (&amp;reassociate_stats, 0, sizeof (reassociate_stats));</span>
<span class="lineNum">    6200 </span>            : 
<span class="lineNum">    6201 </span><span class="lineCov">    1241803 :   next_operand_entry_id = 0;</span>
<span class="lineNum">    6202 </span>            : 
<span class="lineNum">    6203 </span>            :   /* Reverse RPO (Reverse Post Order) will give us something where
<span class="lineNum">    6204 </span>            :      deeper loops come later.  */
<span class="lineNum">    6205 </span><span class="lineCov">    1241803 :   pre_and_rev_post_order_compute (NULL, bbs, false);</span>
<span class="lineNum">    6206 </span><span class="lineCov">    1241803 :   bb_rank = XCNEWVEC (long, last_basic_block_for_fn (cfun));</span>
<span class="lineNum">    6207 </span><span class="lineCov">    1241803 :   operand_rank = new hash_map&lt;tree, long&gt;;</span>
<span class="lineNum">    6208 </span>            : 
<span class="lineNum">    6209 </span>            :   /* Give each default definition a distinct rank.  This includes
<span class="lineNum">    6210 </span>            :      parameters and the static chain.  Walk backwards over all
<span class="lineNum">    6211 </span>            :      SSA names so that we get proper rank ordering according
<span class="lineNum">    6212 </span>            :      to tree_swap_operands_p.  */
<span class="lineNum">    6213 </span><span class="lineCov">   58956968 :   for (i = num_ssa_names - 1; i &gt; 0; --i)</span>
<span class="lineNum">    6214 </span>            :     {
<span class="lineNum">    6215 </span><span class="lineCov">   56473362 :       tree name = ssa_name (i);</span>
<span class="lineNum">    6216 </span><span class="lineCov">   56473362 :       if (name &amp;&amp; SSA_NAME_IS_DEFAULT_DEF (name))</span>
<span class="lineNum">    6217 </span><span class="lineCov">    3391990 :         insert_operand_rank (name, ++rank);</span>
<span class="lineNum">    6218 </span>            :     }
<span class="lineNum">    6219 </span>            : 
<span class="lineNum">    6220 </span>            :   /* Set up rank for each BB  */
<span class="lineNum">    6221 </span><span class="lineCov">   12527300 :   for (i = 0; i &lt; n_basic_blocks_for_fn (cfun) - NUM_FIXED_BLOCKS; i++)</span>
<span class="lineNum">    6222 </span><span class="lineCov">   11285497 :     bb_rank[bbs[i]] = ++rank &lt;&lt; 16;</span>
<span class="lineNum">    6223 </span>            : 
<span class="lineNum">    6224 </span><span class="lineCov">    1241803 :   free (bbs);</span>
<span class="lineNum">    6225 </span><span class="lineCov">    1241803 :   calculate_dominance_info (CDI_POST_DOMINATORS);</span>
<span class="lineNum">    6226 </span><span class="lineCov">    1241803 :   plus_negates = vNULL;</span>
<span class="lineNum">    6227 </span><span class="lineCov">    1241803 : }</span>
<span class="lineNum">    6228 </span>            : 
<span class="lineNum">    6229 </span>            : /* Cleanup after the reassociation pass, and print stats if
<span class="lineNum">    6230 </span>            :    requested.  */
<span class="lineNum">    6231 </span>            : 
<span class="lineNum">    6232 </span>            : static void
<span class="lineNum">    6233 </span><span class="lineCov">    1241803 : fini_reassoc (void)</span>
<span class="lineNum">    6234 </span>            : {
<span class="lineNum">    6235 </span><span class="lineCov">    1241803 :   statistics_counter_event (cfun, &quot;Linearized&quot;,</span>
<span class="lineNum">    6236 </span>            :                             reassociate_stats.linearized);
<span class="lineNum">    6237 </span><span class="lineCov">    1241803 :   statistics_counter_event (cfun, &quot;Constants eliminated&quot;,</span>
<span class="lineNum">    6238 </span>            :                             reassociate_stats.constants_eliminated);
<span class="lineNum">    6239 </span><span class="lineCov">    1241803 :   statistics_counter_event (cfun, &quot;Ops eliminated&quot;,</span>
<span class="lineNum">    6240 </span>            :                             reassociate_stats.ops_eliminated);
<span class="lineNum">    6241 </span><span class="lineCov">    1241803 :   statistics_counter_event (cfun, &quot;Statements rewritten&quot;,</span>
<span class="lineNum">    6242 </span>            :                             reassociate_stats.rewritten);
<span class="lineNum">    6243 </span><span class="lineCov">    1241803 :   statistics_counter_event (cfun, &quot;Built-in pow[i] calls encountered&quot;,</span>
<span class="lineNum">    6244 </span>            :                             reassociate_stats.pows_encountered);
<span class="lineNum">    6245 </span><span class="lineCov">    1241803 :   statistics_counter_event (cfun, &quot;Built-in powi calls created&quot;,</span>
<span class="lineNum">    6246 </span>            :                             reassociate_stats.pows_created);
<span class="lineNum">    6247 </span>            : 
<span class="lineNum">    6248 </span><span class="lineCov">    1241803 :   delete operand_rank;</span>
<span class="lineNum">    6249 </span><span class="lineCov">    1241803 :   operand_entry_pool.release ();</span>
<span class="lineNum">    6250 </span><span class="lineCov">    1241803 :   free (bb_rank);</span>
<span class="lineNum">    6251 </span><span class="lineCov">    1241803 :   plus_negates.release ();</span>
<span class="lineNum">    6252 </span><span class="lineCov">    1241803 :   free_dominance_info (CDI_POST_DOMINATORS);</span>
<span class="lineNum">    6253 </span><span class="lineCov">    1241803 :   loop_optimizer_finalize ();</span>
<span class="lineNum">    6254 </span><span class="lineCov">    1241803 : }</span>
<span class="lineNum">    6255 </span>            : 
<span class="lineNum">    6256 </span>            : /* Gate and execute functions for Reassociation.  If INSERT_POWI_P, enable
<span class="lineNum">    6257 </span>            :    insertion of __builtin_powi calls.
<span class="lineNum">    6258 </span>            : 
<span class="lineNum">    6259 </span>            :    Returns TODO_cfg_cleanup if a CFG cleanup pass is desired due to
<span class="lineNum">    6260 </span>            :    optimization of a gimple conditional.  Otherwise returns zero.  */
<a name="6261"><span class="lineNum">    6261 </span>            : </a>
<span class="lineNum">    6262 </span>            : static unsigned int
<span class="lineNum">    6263 </span><span class="lineCov">    1241803 : execute_reassoc (bool insert_powi_p)</span>
<span class="lineNum">    6264 </span>            : {
<span class="lineNum">    6265 </span><span class="lineCov">    1241803 :   reassoc_insert_powi_p = insert_powi_p;</span>
<span class="lineNum">    6266 </span>            : 
<span class="lineNum">    6267 </span><span class="lineCov">    1241803 :   init_reassoc ();</span>
<span class="lineNum">    6268 </span>            : 
<span class="lineNum">    6269 </span><span class="lineCov">    1241803 :   bool cfg_cleanup_needed;</span>
<span class="lineNum">    6270 </span><span class="lineCov">    1241803 :   cfg_cleanup_needed = do_reassoc ();</span>
<span class="lineNum">    6271 </span><span class="lineCov">    1241803 :   repropagate_negates ();</span>
<span class="lineNum">    6272 </span><span class="lineCov">    1241803 :   branch_fixup ();</span>
<span class="lineNum">    6273 </span>            : 
<span class="lineNum">    6274 </span><span class="lineCov">    1241803 :   fini_reassoc ();</span>
<span class="lineNum">    6275 </span><span class="lineCov">    1241803 :   return cfg_cleanup_needed ? TODO_cleanup_cfg : 0;</span>
<span class="lineNum">    6276 </span>            : }
<span class="lineNum">    6277 </span>            : 
<span class="lineNum">    6278 </span>            : namespace {
<span class="lineNum">    6279 </span>            : 
<span class="lineNum">    6280 </span>            : const pass_data pass_data_reassoc =
<span class="lineNum">    6281 </span>            : {
<span class="lineNum">    6282 </span>            :   GIMPLE_PASS, /* type */
<span class="lineNum">    6283 </span>            :   &quot;reassoc&quot;, /* name */
<span class="lineNum">    6284 </span>            :   OPTGROUP_NONE, /* optinfo_flags */
<span class="lineNum">    6285 </span>            :   TV_TREE_REASSOC, /* tv_id */
<span class="lineNum">    6286 </span>            :   ( PROP_cfg | PROP_ssa ), /* properties_required */
<span class="lineNum">    6287 </span>            :   0, /* properties_provided */
<span class="lineNum">    6288 </span>            :   0, /* properties_destroyed */
<span class="lineNum">    6289 </span>            :   0, /* todo_flags_start */
<span class="lineNum">    6290 </span>            :   TODO_update_ssa_only_virtuals, /* todo_flags_finish */
<span class="lineNum">    6291 </span>            : };
<span class="lineNum">    6292 </span>            : 
<span class="lineNum">    6293 </span>            : class pass_reassoc : public gimple_opt_pass
<span class="lineNum">    6294 </span>            : {
<span class="lineNum">    6295 </span>            : public:
<span class="lineNum">    6296 </span>            :   pass_reassoc (gcc::context *ctxt)
<span class="lineNum">    6297 </span><span class="lineCov">     681248 :     : gimple_opt_pass (pass_data_reassoc, ctxt), insert_powi_p (false)</span>
<span class="lineNum">    6298 </span>            :   {}
<a name="6299"><span class="lineNum">    6299 </span>            : </a>
<a name="6300"><span class="lineNum">    6300 </span>            :   /* opt_pass methods: */</a>
<span class="lineNum">    6301 </span><span class="lineCov">     170312 :   opt_pass * clone () { return new pass_reassoc (m_ctxt); }</span>
<span class="lineNum">    6302 </span><span class="lineCov">     340624 :   void set_pass_param (unsigned int n, bool param)</span>
<span class="lineNum">    6303 </span>            :     {
<span class="lineNum">    6304 </span><span class="lineCov">     340624 :       gcc_assert (n == 0);</span>
<a name="6305"><span class="lineNum">    6305 </span><span class="lineCov">     340624 :       insert_powi_p = param;</span></a>
<a name="6306"><span class="lineNum">    6306 </span><span class="lineCov">     340624 :     }</span></a>
<span class="lineNum">    6307 </span><span class="lineCov">    1241892 :   virtual bool gate (function *) { return flag_tree_reassoc != 0; }</span>
<span class="lineNum">    6308 </span><span class="lineCov">    1241803 :   virtual unsigned int execute (function *)</span>
<span class="lineNum">    6309 </span><span class="lineCov">    1241803 :     { return execute_reassoc (insert_powi_p); }</span>
<span class="lineNum">    6310 </span>            : 
<span class="lineNum">    6311 </span>            :  private:
<span class="lineNum">    6312 </span>            :   /* Enable insertion of __builtin_powi calls during execute_reassoc.  See
<span class="lineNum">    6313 </span>            :      point 3a in the pass header comment.  */
<span class="lineNum">    6314 </span>            :   bool insert_powi_p;
<span class="lineNum">    6315 </span>            : }; // class pass_reassoc
<span class="lineNum">    6316 </span>            : 
<span class="lineNum">    6317 </span>            : } // anon namespace
<a name="6318"><span class="lineNum">    6318 </span>            : </a>
<span class="lineNum">    6319 </span>            : gimple_opt_pass *
<span class="lineNum">    6320 </span><span class="lineCov">     170312 : make_pass_reassoc (gcc::context *ctxt)</span>
<span class="lineNum">    6321 </span>            : {
<span class="lineNum">    6322 </span><span class="lineCov">     170312 :   return new pass_reassoc (ctxt);</span>
<span class="lineNum">    6323 </span>            : }
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.0</a></td></tr>
  </table>
  <br>
<h3>LCOV profile is generated on x86_64 machine using following configure options: configure --disable-bootstrap --enable-coverage=opt --enable-languages=c,c++,fortran,go,jit,lto --enable-host-shared. GCC test suite is run with the built compiler.</h3></body></html>
