<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - gcc.info - gcc/fibonacci_heap.h</title>
  <link rel="stylesheet" type="text/css" href="../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../index.html">top level</a> - <a href="index.html">gcc</a> - fibonacci_heap.h<span style="font-size: 80%;"> (source / <a href="fibonacci_heap.h.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">gcc.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">363</td>
            <td class="headerCovTableEntry">467</td>
            <td class="headerCovTableEntryMed">77.7 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2018-09-22 10:58:49</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">41</td>
            <td class="headerCovTableEntry">85</td>
            <td class="headerCovTableEntryLo">48.2 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /* Fibonacci heap for GNU compiler.</a>
<span class="lineNum">       2 </span>            :    Copyright (C) 1998-2018 Free Software Foundation, Inc.
<span class="lineNum">       3 </span>            :    Contributed by Daniel Berlin (dan@cgsoftware.com).
<span class="lineNum">       4 </span>            :    Re-implemented in C++ by Martin Liska &lt;mliska@suse.cz&gt;
<span class="lineNum">       5 </span>            : 
<span class="lineNum">       6 </span>            : This file is part of GCC.
<span class="lineNum">       7 </span>            : 
<span class="lineNum">       8 </span>            : GCC is free software; you can redistribute it and/or modify it under
<span class="lineNum">       9 </span>            : the terms of the GNU General Public License as published by the Free
<span class="lineNum">      10 </span>            : Software Foundation; either version 3, or (at your option) any later
<span class="lineNum">      11 </span>            : version.
<span class="lineNum">      12 </span>            : 
<span class="lineNum">      13 </span>            : GCC is distributed in the hope that it will be useful, but WITHOUT ANY
<span class="lineNum">      14 </span>            : WARRANTY; without even the implied warranty of MERCHANTABILITY or
<span class="lineNum">      15 </span>            : FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
<span class="lineNum">      16 </span>            : for more details.
<span class="lineNum">      17 </span>            : 
<span class="lineNum">      18 </span>            : You should have received a copy of the GNU General Public License
<span class="lineNum">      19 </span>            : along with GCC; see the file COPYING3.  If not see
<span class="lineNum">      20 </span>            : &lt;http://www.gnu.org/licenses/&gt;.  */
<span class="lineNum">      21 </span>            : 
<span class="lineNum">      22 </span>            : /* Fibonacci heaps are somewhat complex, but, there's an article in
<span class="lineNum">      23 </span>            :    DDJ that explains them pretty well:
<span class="lineNum">      24 </span>            : 
<span class="lineNum">      25 </span>            :    http://www.ddj.com/articles/1997/9701/9701o/9701o.htm?topic=algoritms
<span class="lineNum">      26 </span>            : 
<span class="lineNum">      27 </span>            :    Introduction to algorithms by Corman and Rivest also goes over them.
<span class="lineNum">      28 </span>            : 
<span class="lineNum">      29 </span>            :    The original paper that introduced them is &quot;Fibonacci heaps and their
<span class="lineNum">      30 </span>            :    uses in improved network optimization algorithms&quot; by Tarjan and
<span class="lineNum">      31 </span>            :    Fredman (JACM 34(3), July 1987).
<span class="lineNum">      32 </span>            : 
<span class="lineNum">      33 </span>            :    Amortized and real worst case time for operations:
<span class="lineNum">      34 </span>            : 
<span class="lineNum">      35 </span>            :    ExtractMin: O(lg n) amortized. O(n) worst case.
<span class="lineNum">      36 </span>            :    DecreaseKey: O(1) amortized.  O(lg n) worst case.
<span class="lineNum">      37 </span>            :    Insert: O(1) amortized.
<span class="lineNum">      38 </span>            :    Union: O(1) amortized.  */
<span class="lineNum">      39 </span>            : 
<span class="lineNum">      40 </span>            : #ifndef GCC_FIBONACCI_HEAP_H
<span class="lineNum">      41 </span>            : #define GCC_FIBONACCI_HEAP_H
<span class="lineNum">      42 </span>            : 
<span class="lineNum">      43 </span>            : /* Forward definition.  */
<span class="lineNum">      44 </span>            : 
<span class="lineNum">      45 </span>            : template&lt;class K, class V&gt;
<span class="lineNum">      46 </span>            : class fibonacci_heap;
<span class="lineNum">      47 </span>            : 
<span class="lineNum">      48 </span>            : /* Fibonacci heap node class.  */
<span class="lineNum">      49 </span>            : 
<span class="lineNum">      50 </span>            : template&lt;class K, class V&gt;
<span class="lineNum">      51 </span>            : class fibonacci_node
<span class="lineNum">      52 </span>            : {
<span class="lineNum">      53 </span>            :   typedef fibonacci_node&lt;K,V&gt; fibonacci_node_t;
<span class="lineNum">      54 </span>            :   friend class fibonacci_heap&lt;K,V&gt;;
<span class="lineNum">      55 </span>            : 
<span class="lineNum">      56 </span>            : public:
<span class="lineNum">      57 </span>            :   /* Default constructor.  */
<span class="lineNum">      58 </span><span class="lineCov">         10 :   fibonacci_node (): m_parent (NULL), m_child (NULL), m_left (this),</span>
<span class="lineNum">      59 </span><span class="lineCov">         10 :     m_right (this), m_degree (0), m_mark (0)</span>
<span class="lineNum">      60 </span>            :   {
<span class="lineNum">      61 </span>            :   }
<span class="lineNum">      62 </span>            : 
<span class="lineNum">      63 </span>            :   /* Constructor for a node with given KEY.  */
<span class="lineNum">      64 </span><span class="lineCov">   10067750 :   fibonacci_node (K key, V *data = NULL): m_parent (NULL), m_child (NULL),</span>
<span class="lineNum">      65 </span>            :     m_left (this), m_right (this), m_key (key), m_data (data),
<span class="lineNum">      66 </span><span class="lineCov">   10067750 :     m_degree (0), m_mark (0)</span>
<span class="lineNum">      67 </span>            :   {
<span class="lineNum">      68 </span>            :   }
<a name="69"><span class="lineNum">      69 </span>            : </a>
<span class="lineNum">      70 </span>            :   /* Compare fibonacci node with OTHER node.  */
<span class="lineNum">      71 </span><span class="lineCov">    3753416 :   int compare (fibonacci_node_t *other)</span>
<span class="lineNum">      72 </span>            :   {
<span class="lineNum">      73 </span><span class="lineCov">    7506834 :     if (m_key &lt; other-&gt;m_key)</span>
<span class="lineNum">      74 </span><span class="lineNoCov">          0 :       return -1;</span>
<span class="lineNum">      75 </span><span class="lineCov">    9172468 :     if (m_key &gt; other-&gt;m_key)</span>
<span class="lineNum">      76 </span><span class="lineCov">    1529339 :       return 1;</span>
<span class="lineNum">      77 </span>            :     return 0;
<span class="lineNum">      78 </span>            :   }
<a name="79"><span class="lineNum">      79 </span>            : </a>
<span class="lineNum">      80 </span>            :   /* Compare the node with a given KEY.  */
<span class="lineNum">      81 </span><span class="lineCov">     101101 :   int compare_data (K key)</span>
<span class="lineNum">      82 </span>            :   {
<span class="lineNum">      83 </span><span class="lineCov">    1142527 :     return fibonacci_node_t (key).compare (this);</span>
<span class="lineNum">      84 </span>            :   }
<span class="lineNum">      85 </span>            : 
<span class="lineNum">      86 </span>            :   /* Remove fibonacci heap node.  */
<span class="lineNum">      87 </span>            :   fibonacci_node_t *remove ();
<span class="lineNum">      88 </span>            : 
<span class="lineNum">      89 </span>            :   /* Link the node with PARENT.  */
<span class="lineNum">      90 </span>            :   void link (fibonacci_node_t *parent);
<a name="91"><span class="lineNum">      91 </span>            : </a>
<span class="lineNum">      92 </span>            :   /* Return key associated with the node.  */
<span class="lineNum">      93 </span><span class="lineNoCov">          0 :   K get_key ()</span>
<span class="lineNum">      94 </span>            :   {
<span class="lineNum">      95 </span><span class="lineNoCov">          0 :     return m_key;</span>
<span class="lineNum">      96 </span>            :   }
<a name="97"><span class="lineNum">      97 </span>            : </a>
<span class="lineNum">      98 </span>            :   /* Return data associated with the node.  */
<span class="lineNum">      99 </span><span class="lineNoCov">          0 :   V *get_data ()</span>
<span class="lineNum">     100 </span>            :   {
<span class="lineNum">     101 </span><span class="lineNoCov">          0 :     return m_data;</span>
<span class="lineNum">     102 </span>            :   }
<span class="lineNum">     103 </span>            : 
<span class="lineNum">     104 </span>            : private:
<span class="lineNum">     105 </span>            :   /* Put node B after this node.  */
<span class="lineNum">     106 </span>            :   void insert_after (fibonacci_node_t *b);
<a name="107"><span class="lineNum">     107 </span>            : </a>
<span class="lineNum">     108 </span>            :   /* Insert fibonacci node B after this node.  */
<span class="lineNum">     109 </span><span class="lineNoCov">          0 :   void insert_before (fibonacci_node_t *b)</span>
<span class="lineNum">     110 </span>            :   {
<span class="lineNum">     111 </span><span class="lineCov">    9446785 :     m_left-&gt;insert_after (b);</span>
<span class="lineNum">     112 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     113 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">     114 </span>            :   /* Parent node.  */
<span class="lineNum">     115 </span><span class="lineNoCov">          0 :   fibonacci_node *m_parent;</span>
<span class="lineNum">     116 </span><span class="lineNoCov">          0 :   /* Child node.  */</span>
<span class="lineNum">     117 </span><span class="lineNoCov">          0 :   fibonacci_node *m_child;</span>
<span class="lineNum">     118 </span>            :   /* Left sibling.  */
<span class="lineNum">     119 </span><span class="lineNoCov">          0 :   fibonacci_node *m_left;</span>
<span class="lineNum">     120 </span><span class="lineNoCov">          0 :   /* Right node.  */</span>
<span class="lineNum">     121 </span>            :   fibonacci_node *m_right;
<span class="lineNum">     122 </span>            :   /* Key associated with node.  */
<span class="lineNum">     123 </span>            :   K m_key;
<span class="lineNum">     124 </span>            :   /* Data associated with node.  */
<span class="lineNum">     125 </span>            :   V *m_data;
<span class="lineNum">     126 </span>            : 
<span class="lineNum">     127 </span>            : #if defined (__GNUC__) &amp;&amp; (!defined (SIZEOF_INT) || SIZEOF_INT &lt; 4)
<span class="lineNum">     128 </span>            :   /* Degree of the node.  */
<span class="lineNum">     129 </span>            :   __extension__ unsigned long int m_degree : 31;
<span class="lineNum">     130 </span>            :   /* Mark of the node.  */
<span class="lineNum">     131 </span>            :   __extension__ unsigned long int m_mark : 1;
<span class="lineNum">     132 </span>            : #else
<span class="lineNum">     133 </span>            :   /* Degree of the node.  */
<span class="lineNum">     134 </span>            :   unsigned int m_degree : 31;
<span class="lineNum">     135 </span>            :   /* Mark of the node.  */
<span class="lineNum">     136 </span>            :   unsigned int m_mark : 1;
<span class="lineNum">     137 </span>            : #endif
<span class="lineNum">     138 </span>            : };
<span class="lineNum">     139 </span>            : 
<span class="lineNum">     140 </span>            : /* Fibonacci heap class. */
<span class="lineNum">     141 </span>            : template&lt;class K, class V&gt;
<span class="lineNum">     142 </span>            : class fibonacci_heap
<span class="lineNum">     143 </span>            : {
<span class="lineNum">     144 </span>            :   typedef fibonacci_node&lt;K,V&gt; fibonacci_node_t;
<span class="lineNum">     145 </span>            :   friend class fibonacci_node&lt;K,V&gt;;
<span class="lineNum">     146 </span>            : 
<span class="lineNum">     147 </span>            : public:
<span class="lineNum">     148 </span>            :   /* Default constructor.  */
<span class="lineNum">     149 </span><span class="lineCov">    2676917 :   fibonacci_heap (K global_min_key): m_nodes (0), m_min (NULL), m_root (NULL),</span>
<span class="lineNum">     150 </span><span class="lineCov">    2364456 :     m_global_min_key (global_min_key)</span>
<span class="lineNum">     151 </span>            :   {
<span class="lineNum">     152 </span>            :   }
<a name="153"><span class="lineNum">     153 </span>            : </a>
<span class="lineNum">     154 </span>            :   /* Destructor.  */
<span class="lineNum">     155 </span><span class="lineCov">    2676917 :   ~fibonacci_heap ()</span>
<span class="lineNum">     156 </span>            :   {
<span class="lineNum">     157 </span><span class="lineCov">    2729462 :     while (m_min != NULL)</span>
<span class="lineNum">     158 </span><span class="lineCov">      52545 :       delete (extract_minimum_node ());</span>
<span class="lineNum">     159 </span><span class="lineCov">    2676917 :   }</span>
<span class="lineNum">     160 </span>            : 
<span class="lineNum">     161 </span>            :   /* Insert new node given by KEY and DATA associated with the key.  */
<span class="lineNum">     162 </span>            :   fibonacci_node_t *insert (K key, V *data);
<a name="163"><span class="lineNum">     163 </span><span class="lineCov">         10 : </span></a>
<span class="lineNum">     164 </span>            :   /* Return true if no entry is present.  */
<span class="lineNum">     165 </span><span class="lineCov">        299 :   bool empty ()</span>
<span class="lineNum">     166 </span><span class="lineCov">        289 :   {</span>
<span class="lineNum">     167 </span><span class="lineCov">         10 :     return m_nodes == 0;</span>
<span class="lineNum">     168 </span><span class="lineCov">          1 :   }</span>
<a name="169"><span class="lineNum">     169 </span>            : </a>
<span class="lineNum">     170 </span><span class="lineCov">          1 :   /* Return the number of nodes.  */</span>
<span class="lineNum">     171 </span><span class="lineNoCov">          0 :   size_t nodes ()</span>
<span class="lineNum">     172 </span><span class="lineCov">          1 :   {</span>
<span class="lineNum">     173 </span><span class="lineCov">          9 :     return m_nodes;</span>
<span class="lineNum">     174 </span>            :   }
<a name="175"><span class="lineNum">     175 </span><span class="lineCov">        298 : </span></a>
<span class="lineNum">     176 </span><span class="lineCov">        289 :   /* Return minimal key presented in the heap.  */</span>
<span class="lineNum">     177 </span><span class="lineCov">          9 :   K min_key ()</span>
<span class="lineNum">     178 </span>            :   {
<span class="lineNum">     179 </span><span class="lineCov">     527984 :     if (m_min == NULL)</span>
<span class="lineNum">     180 </span><span class="lineNoCov">          0 :       gcc_unreachable ();</span>
<span class="lineNum">     181 </span>            : 
<span class="lineNum">     182 </span><span class="lineCov">     826819 :     return m_min-&gt;m_key;</span>
<span class="lineNum">     183 </span><span class="lineNoCov">          0 :   }</span>
<a name="184"><span class="lineNum">     184 </span>            : </a>
<span class="lineNum">     185 </span><span class="lineNoCov">          0 :   /* For given NODE, set new KEY value.  */</span>
<span class="lineNum">     186 </span><span class="lineCov">     280967 :   K replace_key (fibonacci_node_t *node, K key)</span>
<span class="lineNum">     187 </span><span class="lineNoCov">          0 :   {</span>
<span class="lineNum">     188 </span><span class="lineCov">    1041406 :     K okey = node-&gt;m_key;</span>
<span class="lineNum">     189 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">     190 </span><span class="lineCov">     945935 :     replace_key_data (node, key, node-&gt;m_data);</span>
<span class="lineNum">     191 </span><span class="lineCov">     280967 :     return okey;</span>
<span class="lineNum">     192 </span>            :   }
<a name="193"><span class="lineNum">     193 </span><span class="lineNoCov">          0 : </span></a>
<span class="lineNum">     194 </span>            :   /* For given NODE, decrease value to new KEY.  */
<span class="lineNum">     195 </span><span class="lineCov">      95471 :   K decrease_key (fibonacci_node_t *node, K key)</span>
<span class="lineNum">     196 </span>            :   {
<span class="lineNum">     197 </span><span class="lineCov">      95471 :     gcc_assert (key &lt;= node-&gt;m_key);</span>
<span class="lineNum">     198 </span><span class="lineCov">      95471 :     return replace_key (node, key);</span>
<span class="lineNum">     199 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     200 </span>            : 
<span class="lineNum">     201 </span><span class="lineNoCov">          0 :   /* For given NODE, set new KEY and DATA value.  */</span>
<span class="lineNum">     202 </span>            :   V *replace_key_data (fibonacci_node_t *node, K key, V *data);
<span class="lineNum">     203 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">     204 </span>            :   /* Extract minimum node in the heap. If RELEASE is specified,
<span class="lineNum">     205 </span><span class="lineNoCov">          0 :      memory is released.  */</span>
<span class="lineNum">     206 </span>            :   V *extract_min (bool release = true);
<a name="207"><span class="lineNum">     207 </span><span class="lineNoCov">          0 : </span></a>
<span class="lineNum">     208 </span>            :   /* Return value associated with minimum node in the heap.  */
<span class="lineNum">     209 </span><span class="lineNoCov">          0 :   V *min ()</span>
<span class="lineNum">     210 </span>            :   {
<span class="lineNum">     211 </span><span class="lineCov">     303235 :     if (m_min == NULL)</span>
<span class="lineNum">     212 </span><span class="lineNoCov">          0 :       return NULL;</span>
<span class="lineNum">     213 </span><span class="lineCov">        708 : </span>
<span class="lineNum">     214 </span><span class="lineCov">     298835 :     return m_min-&gt;m_data;</span>
<span class="lineNum">     215 </span>            :   }
<span class="lineNum">     216 </span><span class="lineCov">        708 : </span>
<span class="lineNum">     217 </span>            :   /* Replace data associated with NODE and replace it with DATA.  */
<span class="lineNum">     218 </span><span class="lineNoCov">          0 :   V *replace_data (fibonacci_node_t *node, V *data)</span>
<span class="lineNum">     219 </span>            :   {
<span class="lineNum">     220 </span><span class="lineNoCov">          0 :     return replace_key_data (node, node-&gt;m_key, data);</span>
<span class="lineNum">     221 </span><span class="lineNoCov">          0 :   }</span>
<span class="lineNum">     222 </span>            : 
<span class="lineNum">     223 </span><span class="lineNoCov">          0 :   /* Delete NODE in the heap.  */</span>
<span class="lineNum">     224 </span>            :   V *delete_node (fibonacci_node_t *node, bool release = true);
<span class="lineNum">     225 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">     226 </span>            :   /* Union the heap with HEAPB.  */
<span class="lineNum">     227 </span><span class="lineNoCov">          0 :   fibonacci_heap *union_with (fibonacci_heap *heapb);</span>
<span class="lineNum">     228 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">     229 </span>            : private:
<span class="lineNum">     230 </span><span class="lineNoCov">          0 :   /* Insert new NODE given by KEY and DATA associated with the key.  */</span>
<span class="lineNum">     231 </span>            :   fibonacci_node_t *insert (fibonacci_node_t *node, K key, V *data);
<span class="lineNum">     232 </span>            : 
<span class="lineNum">     233 </span>            :   /* Insert new NODE that has already filled key and value.  */
<span class="lineNum">     234 </span><span class="lineCov">         10 :   fibonacci_node_t *insert_node (fibonacci_node_t *node);</span>
<span class="lineNum">     235 </span>            : 
<span class="lineNum">     236 </span><span class="lineCov">         20 :   /* Insert it into the root list.  */</span>
<span class="lineNum">     237 </span>            :   void insert_root (fibonacci_node_t *node);
<span class="lineNum">     238 </span><span class="lineCov">         20 : </span>
<span class="lineNum">     239 </span><span class="lineCov">         10 :   /* Remove NODE from PARENT's child list.  */</span>
<span class="lineNum">     240 </span>            :   void cut (fibonacci_node_t *node, fibonacci_node_t *parent);
<span class="lineNum">     241 </span>            : 
<span class="lineNum">     242 </span>            :   /* Process cut of node Y and do it recursivelly.  */
<span class="lineNum">     243 </span>            :   void cascading_cut (fibonacci_node_t *y);
<span class="lineNum">     244 </span>            : 
<span class="lineNum">     245 </span>            :   /* Extract minimum node from the heap.  */
<span class="lineNum">     246 </span>            :   fibonacci_node_t * extract_minimum_node ();
<span class="lineNum">     247 </span>            : 
<span class="lineNum">     248 </span>            :   /* Remove root NODE from the heap.  */
<span class="lineNum">     249 </span>            :   void remove_root (fibonacci_node_t *node);
<span class="lineNum">     250 </span>            : 
<span class="lineNum">     251 </span>            :   /* Consolidate heap.  */
<span class="lineNum">     252 </span>            :   void consolidate ();
<span class="lineNum">     253 </span>            : 
<span class="lineNum">     254 </span>            :   /* Number of nodes.  */
<span class="lineNum">     255 </span>            :   size_t m_nodes;
<span class="lineNum">     256 </span>            :   /* Minimum node of the heap.  */
<span class="lineNum">     257 </span><span class="lineNoCov">          0 :   fibonacci_node_t *m_min;</span>
<span class="lineNum">     258 </span>            :   /* Root node of the heap.  */
<span class="lineNum">     259 </span><span class="lineCov">        205 :   fibonacci_node_t *m_root;</span>
<span class="lineNum">     260 </span><span class="lineNoCov">          0 :   /* Global minimum given in the heap construction.  */</span>
<span class="lineNum">     261 </span>            :   K m_global_min_key;
<span class="lineNum">     262 </span><span class="lineCov">        203 : };</span>
<span class="lineNum">     263 </span>            : 
<span class="lineNum">     264 </span><span class="lineNoCov">          0 : /* Remove fibonacci heap node.  */</span>
<span class="lineNum">     265 </span>            : 
<span class="lineNum">     266 </span><span class="lineNoCov">          0 : template&lt;class K, class V&gt;</span>
<span class="lineNum">     267 </span><span class="lineNoCov">          0 : fibonacci_node&lt;K,V&gt; *</span>
<span class="lineNum">     268 </span>            : fibonacci_node&lt;K,V&gt;::remove ()
<span class="lineNum">     269 </span><span class="lineNoCov">          0 : {</span>
<span class="lineNum">     270 </span>            :   fibonacci_node&lt;K,V&gt; *ret;
<span class="lineNum">     271 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">     272 </span><span class="lineCov">      63113 :   if (this == m_left)</span>
<span class="lineNum">     273 </span><span class="lineNoCov">          0 :     ret = NULL;</span>
<span class="lineNum">     274 </span><span class="lineNoCov">          0 :   else</span>
<span class="lineNum">     275 </span><span class="lineCov">      39092 :     ret = m_left;</span>
<span class="lineNum">     276 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">     277 </span><span class="lineCov">      63113 :   if (m_parent != NULL &amp;&amp; m_parent-&gt;m_child == this)</span>
<span class="lineNum">     278 </span><span class="lineCov">      35821 :     m_parent-&gt;m_child = ret;</span>
<span class="lineNum">     279 </span>            : 
<span class="lineNum">     280 </span><span class="lineCov">   32491355 :   m_right-&gt;m_left = m_left;</span>
<span class="lineNum">     281 </span><span class="lineCov">   32491355 :   m_left-&gt;m_right = m_right;</span>
<span class="lineNum">     282 </span>            : 
<span class="lineNum">     283 </span><span class="lineCov">   32491355 :   m_parent = NULL;</span>
<span class="lineNum">     284 </span><span class="lineCov">   32491355 :   m_left = this;</span>
<span class="lineNum">     285 </span><span class="lineCov">   32491355 :   m_right = this;</span>
<span class="lineNum">     286 </span>            : 
<span class="lineNum">     287 </span>            :   return ret;
<span class="lineNum">     288 </span>            : }
<span class="lineNum">     289 </span>            : 
<span class="lineNum">     290 </span>            : /* Link the node with PARENT.  */
<span class="lineNum">     291 </span>            : 
<span class="lineNum">     292 </span>            : template&lt;class K, class V&gt;
<span class="lineNum">     293 </span>            : void
<span class="lineNum">     294 </span>            : fibonacci_node&lt;K,V&gt;::link (fibonacci_node&lt;K,V&gt; *parent)
<span class="lineNum">     295 </span>            : {
<span class="lineNum">     296 </span><span class="lineCov">   14322241 :   if (parent-&gt;m_child == NULL)</span>
<span class="lineNum">     297 </span><span class="lineCov">    4878028 :     parent-&gt;m_child = this;</span>
<span class="lineNum">     298 </span>            :   else
<span class="lineNum">     299 </span><span class="lineCov">    9444213 :     parent-&gt;m_child-&gt;insert_before (this);</span>
<span class="lineNum">     300 </span><span class="lineCov">   14322241 :   m_parent = parent;</span>
<span class="lineNum">     301 </span><span class="lineCov">   14322241 :   parent-&gt;m_degree++;</span>
<span class="lineNum">     302 </span><span class="lineCov">   14322241 :   m_mark = 0;</span>
<span class="lineNum">     303 </span>            : }
<span class="lineNum">     304 </span>            : 
<span class="lineNum">     305 </span>            : /* Put node B after this node.  */
<span class="lineNum">     306 </span>            : 
<span class="lineNum">     307 </span>            : template&lt;class K, class V&gt;
<span class="lineNum">     308 </span>            : void
<span class="lineNum">     309 </span>            : fibonacci_node&lt;K,V&gt;::insert_after (fibonacci_node&lt;K,V&gt; *b)
<span class="lineNum">     310 </span>            : {
<span class="lineNum">     311 </span><span class="lineCov">   41872455 :   fibonacci_node&lt;K,V&gt; *a = this;</span>
<span class="lineNum">     312 </span>            : 
<span class="lineNum">     313 </span><span class="lineCov">    9444213 :   if (a == a-&gt;m_right)</span>
<span class="lineNum">     314 </span>            :     {
<span class="lineNum">     315 </span><span class="lineCov">   11087592 :       a-&gt;m_right = b;</span>
<span class="lineNum">     316 </span><span class="lineCov">   11087592 :       a-&gt;m_left = b;</span>
<span class="lineNum">     317 </span><span class="lineCov">   11087592 :       b-&gt;m_right = a;</span>
<span class="lineNum">     318 </span><span class="lineCov">   11087592 :       b-&gt;m_left = a;</span>
<span class="lineNum">     319 </span>            :     }
<span class="lineNum">     320 </span>            :   else
<span class="lineNum">     321 </span>            :     {
<span class="lineNum">     322 </span><span class="lineCov">   30784863 :       b-&gt;m_right = a-&gt;m_right;</span>
<span class="lineNum">     323 </span><span class="lineCov">   30784863 :       a-&gt;m_right-&gt;m_left = b;</span>
<span class="lineNum">     324 </span><span class="lineCov">   30784863 :       a-&gt;m_right = b;</span>
<span class="lineNum">     325 </span><span class="lineCov">   30784863 :       b-&gt;m_left = a;</span>
<span class="lineNum">     326 </span>            :     }
<span class="lineNum">     327 </span>            : }
<span class="lineNum">     328 </span>            : 
<span class="lineNum">     329 </span>            : /* Insert new node given by KEY and DATA associated with the key.  */
<span class="lineNum">     330 </span>            : 
<a name="331"><span class="lineNum">     331 </span>            : template&lt;class K, class V&gt;</a>
<span class="lineNum">     332 </span>            : fibonacci_node&lt;K,V&gt;*
<span class="lineNum">     333 </span><span class="lineCov">    9965645 : fibonacci_heap&lt;K,V&gt;::insert (K key, V *data)</span>
<span class="lineNum">     334 </span><span class="lineNoCov">          0 : {</span>
<span class="lineNum">     335 </span>            :   /* Create the new node.  */
<span class="lineNum">     336 </span><span class="lineCov">    9965645 :   fibonacci_node&lt;K,V&gt; *node = new fibonacci_node_t (key, data);</span>
<span class="lineNum">     337 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">     338 </span><span class="lineCov">    9965645 :   return insert_node (node);</span>
<span class="lineNum">     339 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     340 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">     341 </span>            : /* Insert new NODE given by DATA associated with the key.  */
<span class="lineNum">     342 </span><span class="lineCov">       7261 : </span>
<span class="lineNum">     343 </span><span class="lineCov">       7261 : template&lt;class K, class V&gt;</span>
<span class="lineNum">     344 </span>            : fibonacci_node&lt;K,V&gt;*
<span class="lineNum">     345 </span><span class="lineCov">       7261 : fibonacci_heap&lt;K,V&gt;::insert (fibonacci_node_t *node, K key, V *data)</span>
<span class="lineNum">     346 </span><span class="lineCov">       7261 : {</span>
<span class="lineNum">     347 </span><span class="lineCov">       7261 :   /* Set the node's data.  */</span>
<span class="lineNum">     348 </span><span class="lineNoCov">          0 :   node-&gt;m_data = data;</span>
<span class="lineNum">     349 </span><span class="lineNoCov">          0 :   node-&gt;m_key = key;</span>
<span class="lineNum">     350 </span>            : 
<span class="lineNum">     351 </span><span class="lineNoCov">          0 :   return insert_node (node);</span>
<span class="lineNum">     352 </span>            : }
<span class="lineNum">     353 </span>            : 
<span class="lineNum">     354 </span>            : /* Insert new NODE that has already filled key and value.  */
<span class="lineNum">     355 </span>            : 
<a name="356"><span class="lineNum">     356 </span>            : template&lt;class K, class V&gt;</a>
<span class="lineNum">     357 </span>            : fibonacci_node&lt;K,V&gt;*
<span class="lineNum">     358 </span><span class="lineCov">    9969138 : fibonacci_heap&lt;K,V&gt;::insert_node (fibonacci_node_t *node)</span>
<span class="lineNum">     359 </span><span class="lineCov">        921 : {</span>
<span class="lineNum">     360 </span>            :   /* Insert it into the root list.  */
<span class="lineNum">     361 </span><span class="lineCov">   19933862 :   insert_root (node);</span>
<span class="lineNum">     362 </span><span class="lineCov">       3493 : </span>
<span class="lineNum">     363 </span><span class="lineCov">       3493 :   /* If their was no minimum, or this key is less than the min,</span>
<span class="lineNum">     364 </span><span class="lineCov">       3493 :      it's the new min.  */</span>
<span class="lineNum">     365 </span><span class="lineCov">   10477683 :   if (m_min == NULL || node-&gt;m_key &lt; m_min-&gt;m_key)</span>
<span class="lineNum">     366 </span><span class="lineCov">    3528085 :     m_min = node;</span>
<span class="lineNum">     367 </span>            : 
<span class="lineNum">     368 </span><span class="lineCov">    9965645 :   m_nodes++;</span>
<span class="lineNum">     369 </span>            : 
<span class="lineNum">     370 </span><span class="lineCov">    9965645 :   return node;</span>
<span class="lineNum">     371 </span>            : }
<span class="lineNum">     372 </span>            : 
<span class="lineNum">     373 </span><span class="lineCov">       9831 : /* For given NODE, set new KEY and DATA value.  */</span>
<span class="lineNum">     374 </span>            : 
<a name="375"><span class="lineNum">     375 </span><span class="lineCov">       2572 : template&lt;class K, class V&gt;</span></a>
<span class="lineNum">     376 </span>            : V*
<span class="lineNum">     377 </span><span class="lineCov">    1043260 : fibonacci_heap&lt;K,V&gt;::replace_key_data (fibonacci_node&lt;K,V&gt; *node, K key,</span>
<span class="lineNum">     378 </span><span class="lineCov">       1854 :                                        V *data)</span>
<span class="lineNum">     379 </span><span class="lineCov">       1854 : {</span>
<span class="lineNum">     380 </span><span class="lineCov">     102955 :   K okey;</span>
<span class="lineNum">     381 </span>            :   fibonacci_node&lt;K,V&gt; *y;
<span class="lineNum">     382 </span><span class="lineCov">    1041406 :   V *odata = node-&gt;m_data;</span>
<span class="lineNum">     383 </span>            : 
<span class="lineNum">     384 </span><span class="lineCov">       7977 :   /* If we wanted to, we do a real increase by redeleting and</span>
<span class="lineNum">     385 </span><span class="lineCov">       7977 :      inserting.  */</span>
<span class="lineNum">     386 </span><span class="lineCov">    1049383 :   if (node-&gt;compare_data (key) &gt; 0)</span>
<span class="lineNum">     387 </span><span class="lineCov">       7977 :     {</span>
<span class="lineNum">     388 </span><span class="lineNoCov">          0 :       delete_node (node, false);</span>
<span class="lineNum">     389 </span>            : 
<span class="lineNum">     390 </span><span class="lineNoCov">          0 :       node = new (node) fibonacci_node_t ();</span>
<span class="lineNum">     391 </span><span class="lineNoCov">          0 :       insert (node, key, data);</span>
<span class="lineNum">     392 </span>            : 
<span class="lineNum">     393 </span><span class="lineNoCov">          0 :       return odata;</span>
<span class="lineNum">     394 </span>            :     }
<span class="lineNum">     395 </span><span class="lineCov">       1004 : </span>
<span class="lineNum">     396 </span><span class="lineCov">    1041406 :   okey = node-&gt;m_key;</span>
<span class="lineNum">     397 </span><span class="lineCov">    1041406 :   node-&gt;m_data = data;</span>
<span class="lineNum">     398 </span><span class="lineCov">    1042410 :   node-&gt;m_key = key;</span>
<span class="lineNum">     399 </span><span class="lineCov">    1041406 :   y = node-&gt;m_parent;</span>
<span class="lineNum">     400 </span><span class="lineCov">       1004 : </span>
<span class="lineNum">     401 </span>            :   /* Short-circuit if the key is the same, as we then don't have to
<span class="lineNum">     402 </span><span class="lineCov">          4 :      do anything.  Except if we're trying to force the new node to</span>
<span class="lineNum">     403 </span>            :      be the new minimum for delete.  */
<span class="lineNum">     404 </span><span class="lineCov">    1041406 :   if (okey == key &amp;&amp; okey != m_global_min_key)</span>
<span class="lineNum">     405 </span><span class="lineCov">          4 :     return odata;</span>
<span class="lineNum">     406 </span>            : 
<span class="lineNum">     407 </span><span class="lineCov">          4 :   /* These two compares are specifically &lt;= 0 to make sure that in the case</span>
<span class="lineNum">     408 </span>            :      of equality, a node we replaced the data on, becomes the new min.  This
<span class="lineNum">     409 </span><span class="lineCov">       1000 :      is needed so that delete's call to extractmin gets the right node.  */</span>
<span class="lineNum">     410 </span><span class="lineCov">    1041406 :   if (y != NULL &amp;&amp; node-&gt;compare (y) &lt;= 0)</span>
<span class="lineNum">     411 </span>            :     {
<span class="lineNum">     412 </span><span class="lineCov">      61096 :       cut (node, y);</span>
<span class="lineNum">     413 </span><span class="lineCov">      60096 :       cascading_cut (y);</span>
<span class="lineNum">     414 </span><span class="lineCov">       1000 :     }</span>
<span class="lineNum">     415 </span>            : 
<span class="lineNum">     416 </span><span class="lineCov">    1041406 :   if (node-&gt;compare (m_min) &lt;= 0)</span>
<span class="lineNum">     417 </span><span class="lineCov">     850071 :     m_min = node;</span>
<span class="lineNum">     418 </span>            : 
<span class="lineNum">     419 </span>            :   return odata;
<span class="lineNum">     420 </span>            : }
<span class="lineNum">     421 </span>            : 
<span class="lineNum">     422 </span>            : /* Extract minimum node in the heap.  Delete fibonacci node if RELEASE
<span class="lineNum">     423 </span>            :    is true.  */
<span class="lineNum">     424 </span><span class="lineCov">         10 : </span>
<a name="425"><span class="lineNum">     425 </span><span class="lineCov">         10 : template&lt;class K, class V&gt;</span></a>
<span class="lineNum">     426 </span>            : V*
<span class="lineNum">     427 </span><span class="lineCov">    9913120 : fibonacci_heap&lt;K,V&gt;::extract_min (bool release)</span>
<span class="lineNum">     428 </span>            : {
<span class="lineNum">     429 </span>            :   fibonacci_node&lt;K,V&gt; *z;
<span class="lineNum">     430 </span><span class="lineCov">    9913110 :   V *ret = NULL;</span>
<span class="lineNum">     431 </span>            : 
<span class="lineNum">     432 </span>            :   /* If we don't have a min set, it means we have no nodes.  */
<span class="lineNum">     433 </span><span class="lineCov">    9913110 :   if (m_min != NULL)</span>
<span class="lineNum">     434 </span><span class="lineCov">       1014 :     {</span>
<span class="lineNum">     435 </span>            :       /* Otherwise, extract the min node, free the node, and return the
<span class="lineNum">     436 </span>            :        node's data.  */
<span class="lineNum">     437 </span><span class="lineCov">    9915138 :       z = extract_minimum_node ();</span>
<span class="lineNum">     438 </span><span class="lineCov">    9913110 :       ret = z-&gt;m_data;</span>
<span class="lineNum">     439 </span>            : 
<span class="lineNum">     440 </span><span class="lineCov">    9913110 :       if (release)</span>
<span class="lineNum">     441 </span><span class="lineCov">    9914124 :         delete (z);</span>
<span class="lineNum">     442 </span><span class="lineCov">         11 :     }</span>
<span class="lineNum">     443 </span>            : 
<span class="lineNum">     444 </span><span class="lineCov">    9914124 :   return ret;</span>
<span class="lineNum">     445 </span>            : }
<span class="lineNum">     446 </span><span class="lineCov">       1014 : </span>
<span class="lineNum">     447 </span>            : /* Delete NODE in the heap, if RELEASE is specified memory is released.  */
<span class="lineNum">     448 </span><span class="lineCov">          4 : </span>
<a name="449"><span class="lineNum">     449 </span>            : template&lt;class K, class V&gt;</a>
<span class="lineNum">     450 </span>            : V*
<span class="lineNum">     451 </span><span class="lineCov">     280975 : fibonacci_heap&lt;K,V&gt;::delete_node (fibonacci_node&lt;K,V&gt; *node, bool release)</span>
<span class="lineNum">     452 </span>            : {
<span class="lineNum">     453 </span><span class="lineCov">     280967 :   V *ret = node-&gt;m_data;</span>
<span class="lineNum">     454 </span>            : 
<span class="lineNum">     455 </span><span class="lineCov">          4 :   /* To perform delete, we just make it the min key, and extract.  */</span>
<span class="lineNum">     456 </span><span class="lineCov">     280971 :   replace_key (node, m_global_min_key);</span>
<span class="lineNum">     457 </span><span class="lineCov">     280967 :   if (node != m_min)</span>
<span class="lineNum">     458 </span><span class="lineCov">          4 :     {</span>
<span class="lineNum">     459 </span><span class="lineNoCov">          0 :       fprintf (stderr, &quot;Can't force minimum on fibheap.\n&quot;);</span>
<span class="lineNum">     460 </span><span class="lineCov">          4 :       abort ();</span>
<span class="lineNum">     461 </span>            :     }
<span class="lineNum">     462 </span><span class="lineCov">     281977 :   extract_min (release);</span>
<span class="lineNum">     463 </span>            : 
<span class="lineNum">     464 </span><span class="lineCov">     280967 :   return ret;</span>
<span class="lineNum">     465 </span><span class="lineCov">       2020 : }</span>
<span class="lineNum">     466 </span>            : 
<span class="lineNum">     467 </span>            : /* Union the heap with HEAPB.  One of the heaps is going to be deleted.  */
<span class="lineNum">     468 </span>            : 
<a name="469"><span class="lineNum">     469 </span><span class="lineCov">       1010 : template&lt;class K, class V&gt;</span></a>
<span class="lineNum">     470 </span><span class="lineCov">          7 : fibonacci_heap&lt;K,V&gt;*</span>
<span class="lineNum">     471 </span>            : fibonacci_heap&lt;K,V&gt;::union_with (fibonacci_heap&lt;K,V&gt; *heapb)
<span class="lineNum">     472 </span><span class="lineCov">       1010 : {</span>
<span class="lineNum">     473 </span>            :   fibonacci_heap&lt;K,V&gt; *heapa = this;
<span class="lineNum">     474 </span><span class="lineCov">       1010 : </span>
<span class="lineNum">     475 </span>            :   fibonacci_node&lt;K,V&gt; *a_root, *b_root;
<span class="lineNum">     476 </span>            : 
<span class="lineNum">     477 </span>            :   /* If one of the heaps is empty, the union is just the other heap.  */
<span class="lineNum">     478 </span>            :   if ((a_root = heapa-&gt;m_root) == NULL)
<span class="lineNum">     479 </span>            :     {
<span class="lineNum">     480 </span>            :       delete (heapa);
<span class="lineNum">     481 </span><span class="lineCov">         20 :       return heapb;</span>
<span class="lineNum">     482 </span>            :     }
<span class="lineNum">     483 </span>            :   if ((b_root = heapb-&gt;m_root) == NULL)
<span class="lineNum">     484 </span>            :     {
<span class="lineNum">     485 </span>            :       delete (heapb);
<span class="lineNum">     486 </span><span class="lineCov">         20 :       return heapa;</span>
<span class="lineNum">     487 </span>            :     }
<span class="lineNum">     488 </span>            : 
<span class="lineNum">     489 </span>            :   /* Merge them to the next nodes on the opposite chain.  */
<span class="lineNum">     490 </span><span class="lineCov">         20 :   a_root-&gt;m_left-&gt;m_right = b_root;</span>
<span class="lineNum">     491 </span>            :   b_root-&gt;m_left-&gt;m_right = a_root;
<span class="lineNum">     492 </span><span class="lineCov">         10 :   std::swap (a_root-&gt;m_left, b_root-&gt;m_left);</span>
<span class="lineNum">     493 </span>            :   heapa-&gt;m_nodes += heapb-&gt;m_nodes;
<span class="lineNum">     494 </span><span class="lineCov">         10 : </span>
<span class="lineNum">     495 </span><span class="lineCov">         10 :   /* And set the new minimum, if it's changed.  */</span>
<span class="lineNum">     496 </span>            :   if (heapb-&gt;m_min-&gt;compare (heapa-&gt;m_min) &lt; 0)
<span class="lineNum">     497 </span><span class="lineCov">         10 :     heapa-&gt;m_min = heapb-&gt;m_min;</span>
<span class="lineNum">     498 </span>            : 
<span class="lineNum">     499 </span>            :   /* Set m_min to NULL to not to delete live fibonacci nodes.  */
<span class="lineNum">     500 </span><span class="lineCov">         10 :   heapb-&gt;m_min = NULL;</span>
<span class="lineNum">     501 </span><span class="lineCov">         10 :   delete (heapb);</span>
<span class="lineNum">     502 </span><span class="lineCov">         10 : </span>
<span class="lineNum">     503 </span><span class="lineCov">         10 :   return heapa;</span>
<span class="lineNum">     504 </span>            : }
<span class="lineNum">     505 </span>            : 
<span class="lineNum">     506 </span>            : /* Insert it into the root list.  */
<span class="lineNum">     507 </span>            : 
<a name="508"><span class="lineNum">     508 </span><span class="lineCov">         10 : template&lt;class K, class V&gt;</span></a>
<span class="lineNum">     509 </span>            : void
<span class="lineNum">     510 </span><span class="lineNoCov">          0 : fibonacci_heap&lt;K,V&gt;::insert_root (fibonacci_node_t *node)</span>
<span class="lineNum">     511 </span>            : {
<span class="lineNum">     512 </span>            :   /* If the heap is currently empty, the new node becomes the singleton
<span class="lineNum">     513 </span>            :      circular root list.  */
<span class="lineNum">     514 </span><span class="lineCov">    9965655 :   if (m_root == NULL)</span>
<span class="lineNum">     515 </span>            :     {
<span class="lineNum">     516 </span><span class="lineCov">    9965645 :       m_root = node;</span>
<span class="lineNum">     517 </span><span class="lineCov">    9965645 :       node-&gt;m_left = node;</span>
<span class="lineNum">     518 </span><span class="lineCov">    9965645 :       node-&gt;m_right = node;</span>
<span class="lineNum">     519 </span><span class="lineNoCov">          0 :       return;</span>
<span class="lineNum">     520 </span><span class="lineCov">         10 :     }</span>
<span class="lineNum">     521 </span><span class="lineCov">         10 : </span>
<span class="lineNum">     522 </span>            :   /* Otherwise, insert it in the circular root list between the root
<span class="lineNum">     523 </span>            :      and it's right node.  */
<span class="lineNum">     524 </span><span class="lineCov">   32428242 :   m_root-&gt;insert_after (node);</span>
<span class="lineNum">     525 </span>            : }
<span class="lineNum">     526 </span>            : 
<span class="lineNum">     527 </span>            : /* Remove NODE from PARENT's child list.  */
<span class="lineNum">     528 </span>            : 
<a name="529"><span class="lineNum">     529 </span>            : template&lt;class K, class V&gt;</a>
<span class="lineNum">     530 </span>            : void
<span class="lineNum">     531 </span><span class="lineCov">      63838 : fibonacci_heap&lt;K,V&gt;::cut (fibonacci_node&lt;K,V&gt; *node,</span>
<span class="lineNum">     532 </span>            :                           fibonacci_node&lt;K,V&gt; *parent)
<span class="lineNum">     533 </span>            : {
<span class="lineNum">     534 </span><span class="lineCov">      63838 :   node-&gt;remove ();</span>
<span class="lineNum">     535 </span><span class="lineCov">      63113 :   parent-&gt;m_degree--;</span>
<span class="lineNum">     536 </span><span class="lineCov">      63113 :   insert_root (node);</span>
<span class="lineNum">     537 </span><span class="lineCov">      63838 :   node-&gt;m_parent = NULL;</span>
<span class="lineNum">     538 </span><span class="lineCov">      63113 :   node-&gt;m_mark = 0;</span>
<span class="lineNum">     539 </span><span class="lineCov">      63113 : }</span>
<span class="lineNum">     540 </span>            : 
<span class="lineNum">     541 </span><span class="lineCov">        725 : /* Process cut of node Y and do it recursivelly.  */</span>
<span class="lineNum">     542 </span><span class="lineCov">        725 : </span>
<a name="543"><span class="lineNum">     543 </span>            : template&lt;class K, class V&gt;</a>
<span class="lineNum">     544 </span><span class="lineCov">        725 : void</span>
<span class="lineNum">     545 </span><span class="lineCov">      60811 : fibonacci_heap&lt;K,V&gt;::cascading_cut (fibonacci_node&lt;K,V&gt; *y)</span>
<span class="lineNum">     546 </span>            : {
<span class="lineNum">     547 </span>            :   fibonacci_node&lt;K,V&gt; *z;
<span class="lineNum">     548 </span><span class="lineCov">        725 : </span>
<span class="lineNum">     549 </span><span class="lineCov">      63113 :   while ((z = y-&gt;m_parent) != NULL)</span>
<span class="lineNum">     550 </span><span class="lineCov">          4 :     {</span>
<span class="lineNum">     551 </span><span class="lineCov">      24715 :       if (y-&gt;m_mark == 0)</span>
<span class="lineNum">     552 </span>            :         {
<span class="lineNum">     553 </span><span class="lineCov">      21702 :           y-&gt;m_mark = 1;</span>
<span class="lineNum">     554 </span><span class="lineCov">      21698 :           return;</span>
<span class="lineNum">     555 </span>            :         }
<span class="lineNum">     556 </span><span class="lineCov">          4 :       else</span>
<span class="lineNum">     557 </span>            :         {
<span class="lineNum">     558 </span><span class="lineCov">       3017 :           cut (y, z);</span>
<span class="lineNum">     559 </span><span class="lineCov">       3017 :           y = z;</span>
<span class="lineNum">     560 </span><span class="lineCov">          4 :         }</span>
<span class="lineNum">     561 </span><span class="lineCov">          4 :     }</span>
<span class="lineNum">     562 </span>            : }
<span class="lineNum">     563 </span><span class="lineCov">          4 : </span>
<span class="lineNum">     564 </span><span class="lineCov">          4 : /* Extract minimum node from the heap.  */</span>
<span class="lineNum">     565 </span>            : 
<a name="566"><span class="lineNum">     566 </span>            : template&lt;class K, class V&gt;</a>
<span class="lineNum">     567 </span><span class="lineCov">          4 : fibonacci_node&lt;K,V&gt;*</span>
<span class="lineNum">     568 </span><span class="lineCov">    9965645 : fibonacci_heap&lt;K,V&gt;::extract_minimum_node ()</span>
<span class="lineNum">     569 </span><span class="lineCov">        721 : {</span>
<span class="lineNum">     570 </span><span class="lineCov">    9965645 :   fibonacci_node&lt;K,V&gt; *ret = m_min;</span>
<span class="lineNum">     571 </span>            :   fibonacci_node&lt;K,V&gt; *x, *y, *orig;
<span class="lineNum">     572 </span><span class="lineCov">        721 : </span>
<span class="lineNum">     573 </span>            :   /* Attach the child list of the minimum node to the root list of the heap.
<span class="lineNum">     574 </span>            :      If there is no child list, we don't do squat.  */
<span class="lineNum">     575 </span><span class="lineCov">   24225494 :   for (x = ret-&gt;m_child, orig = NULL; x != orig &amp;&amp; x != NULL; x = y)</span>
<span class="lineNum">     576 </span>            :     {
<span class="lineNum">     577 </span><span class="lineCov">   14259128 :       if (orig == NULL)</span>
<span class="lineNum">     578 </span><span class="lineCov">    4854007 :         orig = x;</span>
<span class="lineNum">     579 </span><span class="lineCov">   14259849 :       y = x-&gt;m_right;</span>
<span class="lineNum">     580 </span><span class="lineCov">   14259849 :       x-&gt;m_parent = NULL;</span>
<span class="lineNum">     581 </span><span class="lineCov">   14259128 :       insert_root (x);</span>
<span class="lineNum">     582 </span><span class="lineCov">        721 :     }</span>
<span class="lineNum">     583 </span><span class="lineCov">        711 : </span>
<span class="lineNum">     584 </span>            :   /* Remove the old root.  */
<span class="lineNum">     585 </span><span class="lineCov">   19931290 :   remove_root (ret);</span>
<span class="lineNum">     586 </span><span class="lineCov">    9966366 :   m_nodes--;</span>
<span class="lineNum">     587 </span>            : 
<span class="lineNum">     588 </span>            :   /* If we are left with no nodes, then the min is NULL.  */
<span class="lineNum">     589 </span><span class="lineCov">    9965645 :   if (m_nodes == 0)</span>
<span class="lineNum">     590 </span><span class="lineCov">    2281076 :     m_min = NULL;</span>
<span class="lineNum">     591 </span>            :   else
<span class="lineNum">     592 </span>            :     {
<span class="lineNum">     593 </span><span class="lineCov">         10 :       /* Otherwise, consolidate to find new minimum, as well as do the reorg</span>
<span class="lineNum">     594 </span>            :        work that needs to be done.  */
<span class="lineNum">     595 </span><span class="lineCov">    7684579 :       m_min = ret-&gt;m_right;</span>
<span class="lineNum">     596 </span><span class="lineCov">    7684569 :       consolidate ();</span>
<span class="lineNum">     597 </span>            :     }
<span class="lineNum">     598 </span><span class="lineCov">         10 : </span>
<span class="lineNum">     599 </span><span class="lineCov">    9965655 :   return ret;</span>
<span class="lineNum">     600 </span>            : }
<span class="lineNum">     601 </span><span class="lineNoCov">          0 : </span>
<span class="lineNum">     602 </span><span class="lineNoCov">          0 : /* Remove root NODE from the heap.  */</span>
<span class="lineNum">     603 </span>            : 
<a name="604"><span class="lineNum">     604 </span><span class="lineCov">         10 : template&lt;class K, class V&gt;</span></a>
<span class="lineNum">     605 </span>            : void
<span class="lineNum">     606 </span><span class="lineCov">         10 : fibonacci_heap&lt;K,V&gt;::remove_root (fibonacci_node&lt;K,V&gt; *node)</span>
<span class="lineNum">     607 </span>            : {
<span class="lineNum">     608 </span><span class="lineCov">    9965645 :   if (node-&gt;m_left == node)</span>
<span class="lineNum">     609 </span><span class="lineCov">    9965645 :     m_root = NULL;</span>
<span class="lineNum">     610 </span>            :   else
<span class="lineNum">     611 </span><span class="lineCov">   32428242 :     m_root = node-&gt;remove ();</span>
<span class="lineNum">     612 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     613 </span><span class="lineCov">          3 : </span>
<span class="lineNum">     614 </span>            : /* Consolidate heap.  */
<a name="615"><span class="lineNum">     615 </span><span class="lineCov">          3 : </span></a>
<span class="lineNum">     616 </span>            : template&lt;class K, class V&gt;
<span class="lineNum">     617 </span><span class="lineCov">    7684569 : void fibonacci_heap&lt;K,V&gt;::consolidate ()</span>
<span class="lineNum">     618 </span>            : {
<span class="lineNum">     619 </span><span class="lineCov">    7684569 :   int D = 1 + 8 * sizeof (long);</span>
<span class="lineNum">     620 </span><span class="lineCov">   15369141 :   auto_vec&lt;fibonacci_node&lt;K,V&gt; *&gt; a (D);</span>
<span class="lineNum">     621 </span><span class="lineCov">    7684569 :   a.safe_grow_cleared (D);</span>
<span class="lineNum">     622 </span><span class="lineCov">          1 :   fibonacci_node&lt;K,V&gt; *w, *x, *y;</span>
<span class="lineNum">     623 </span><span class="lineCov">          1 :   int i, d;</span>
<span class="lineNum">     624 </span>            : 
<span class="lineNum">     625 </span><span class="lineCov">   40112813 :   while ((w = m_root) != NULL)</span>
<span class="lineNum">     626 </span>            :     {
<span class="lineNum">     627 </span><span class="lineCov">   32428242 :       x = w;</span>
<span class="lineNum">     628 </span><span class="lineCov">   32428242 :       remove_root (w);</span>
<span class="lineNum">     629 </span><span class="lineCov">   32428242 :       d = x-&gt;m_degree;</span>
<span class="lineNum">     630 </span><span class="lineCov">   46750483 :       while (a[d] != NULL)</span>
<span class="lineNum">     631 </span>            :         {
<span class="lineNum">     632 </span><span class="lineCov">   14322243 :           y = a[d];</span>
<span class="lineNum">     633 </span><span class="lineCov">   14322243 :           if (x-&gt;compare (y) &gt; 0)</span>
<span class="lineNum">     634 </span><span class="lineCov">    1026025 :             std::swap (x, y);</span>
<span class="lineNum">     635 </span><span class="lineCov">   14322243 :           y-&gt;link (x);</span>
<span class="lineNum">     636 </span><span class="lineCov">   14322241 :           a[d] = NULL;</span>
<span class="lineNum">     637 </span><span class="lineCov">   14322241 :           d++;</span>
<span class="lineNum">     638 </span><span class="lineCov">          2 :         }</span>
<span class="lineNum">     639 </span><span class="lineCov">   64856484 :       a[d] = x;</span>
<span class="lineNum">     640 </span>            :     }
<span class="lineNum">     641 </span><span class="lineCov">    7684569 :   m_min = NULL;</span>
<span class="lineNum">     642 </span><span class="lineCov">  507181556 :   for (i = 0; i &lt; D; i++)</span>
<span class="lineNum">     643 </span><span class="lineCov">  499496987 :     if (a[i] != NULL)</span>
<span class="lineNum">     644 </span>            :       {
<span class="lineNum">     645 </span><span class="lineCov">   36212004 :         insert_root (a[i]);</span>
<span class="lineNum">     646 </span><span class="lineCov">   18106001 :         if (m_min == NULL || a[i]-&gt;compare (m_min) &lt; 0)</span>
<span class="lineNum">     647 </span><span class="lineCov">   12083197 :           m_min = a[i];</span>
<span class="lineNum">     648 </span>            :       }
<span class="lineNum">     649 </span><span class="lineCov">    7684569 : }</span>
<span class="lineNum">     650 </span>            : 
<span class="lineNum">     651 </span>            : #endif  // GCC_FIBONACCI_HEAP_H
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.0</a></td></tr>
  </table>
  <br>
<h3>LCOV profile is generated on x86_64 machine using following configure options: configure --disable-bootstrap --enable-coverage=opt --enable-languages=c,c++,fortran,go,jit,lto --enable-host-shared. GCC test suite is run with the built compiler.</h3></body></html>
