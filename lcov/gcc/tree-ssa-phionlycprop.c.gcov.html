<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - gcc.info - gcc/tree-ssa-phionlycprop.c</title>
  <link rel="stylesheet" type="text/css" href="../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../index.html">top level</a> - <a href="index.html">gcc</a> - tree-ssa-phionlycprop.c<span style="font-size: 80%;"> (source / <a href="tree-ssa-phionlycprop.c.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">gcc.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">160</td>
            <td class="headerCovTableEntry">180</td>
            <td class="headerCovTableEntryMed">88.9 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2018-09-22 10:58:49</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">9</td>
            <td class="headerCovTableEntry">10</td>
            <td class="headerCovTableEntryHi">90.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /* Const/Copy propagation originating from degenerate PHIs</a>
<span class="lineNum">       2 </span>            :    Copyright (C) 2001-2018 Free Software Foundation, Inc.
<span class="lineNum">       3 </span>            : 
<span class="lineNum">       4 </span>            : This file is part of GCC.
<span class="lineNum">       5 </span>            : 
<span class="lineNum">       6 </span>            : GCC is free software; you can redistribute it and/or modify
<span class="lineNum">       7 </span>            : it under the terms of the GNU General Public License as published by
<span class="lineNum">       8 </span>            : the Free Software Foundation; either version 3, or (at your option)
<span class="lineNum">       9 </span>            : any later version.
<span class="lineNum">      10 </span>            : 
<span class="lineNum">      11 </span>            : GCC is distributed in the hope that it will be useful,
<span class="lineNum">      12 </span>            : but WITHOUT ANY WARRANTY; without even the implied warranty of
<span class="lineNum">      13 </span>            : MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
<span class="lineNum">      14 </span>            : GNU General Public License for more details.
<span class="lineNum">      15 </span>            : 
<span class="lineNum">      16 </span>            : You should have received a copy of the GNU General Public License
<span class="lineNum">      17 </span>            : along with GCC; see the file COPYING3.  If not see
<span class="lineNum">      18 </span>            : &lt;http://www.gnu.org/licenses/&gt;.  */
<span class="lineNum">      19 </span>            : 
<span class="lineNum">      20 </span>            : #include &quot;config.h&quot;
<span class="lineNum">      21 </span>            : #include &quot;system.h&quot;
<span class="lineNum">      22 </span>            : #include &quot;coretypes.h&quot;
<span class="lineNum">      23 </span>            : #include &quot;backend.h&quot;
<span class="lineNum">      24 </span>            : #include &quot;cfghooks.h&quot;
<span class="lineNum">      25 </span>            : #include &quot;tree.h&quot;
<span class="lineNum">      26 </span>            : #include &quot;gimple.h&quot;
<span class="lineNum">      27 </span>            : #include &quot;ssa.h&quot;
<span class="lineNum">      28 </span>            : #include &quot;fold-const.h&quot;
<span class="lineNum">      29 </span>            : #include &quot;cfgloop.h&quot;
<span class="lineNum">      30 </span>            : #include &quot;gimple-pretty-print.h&quot;
<span class="lineNum">      31 </span>            : #include &quot;gimple-fold.h&quot;
<span class="lineNum">      32 </span>            : #include &quot;tree-eh.h&quot;
<span class="lineNum">      33 </span>            : #include &quot;gimple-iterator.h&quot;
<span class="lineNum">      34 </span>            : #include &quot;tree-cfg.h&quot;
<span class="lineNum">      35 </span>            : #include &quot;tree-pass.h&quot;
<span class="lineNum">      36 </span>            : #include &quot;tree-ssa-propagate.h&quot;
<span class="lineNum">      37 </span>            : 
<span class="lineNum">      38 </span>            : 
<span class="lineNum">      39 </span>            : /* PHI-ONLY copy and constant propagation.  This pass is meant to clean
<span class="lineNum">      40 </span>            :    up degenerate PHIs created by or exposed by jump threading.  */
<span class="lineNum">      41 </span>            : 
<span class="lineNum">      42 </span>            : /* Given a statement STMT, which is either a PHI node or an assignment,
<span class="lineNum">      43 </span>            :    remove it from the IL.  */
<span class="lineNum">      44 </span>            : 
<span class="lineNum">      45 </span>            : static void
<span class="lineNum">      46 </span><span class="lineCov">    1108292 : remove_stmt_or_phi (gimple *stmt)</span>
<span class="lineNum">      47 </span>            : {
<span class="lineNum">      48 </span><span class="lineCov">    1108292 :   gimple_stmt_iterator gsi = gsi_for_stmt (stmt);</span>
<span class="lineNum">      49 </span>            : 
<span class="lineNum">      50 </span><span class="lineCov">    2216584 :   if (gimple_code (stmt) == GIMPLE_PHI)</span>
<span class="lineNum">      51 </span><span class="lineCov">    1075554 :     remove_phi_node (&amp;gsi, true);</span>
<span class="lineNum">      52 </span>            :   else
<span class="lineNum">      53 </span>            :     {
<span class="lineNum">      54 </span><span class="lineCov">      32738 :       gsi_remove (&amp;gsi, true);</span>
<span class="lineNum">      55 </span><span class="lineCov">      32738 :       release_defs (stmt);</span>
<span class="lineNum">      56 </span>            :     }
<span class="lineNum">      57 </span><span class="lineCov">    1108292 : }</span>
<span class="lineNum">      58 </span>            : 
<span class="lineNum">      59 </span>            : /* Given a statement STMT, which is either a PHI node or an assignment,
<span class="lineNum">      60 </span>            :    return the &quot;rhs&quot; of the node, in the case of a non-degenerate
<span class="lineNum">      61 </span>            :    phi, NULL is returned.  */
<span class="lineNum">      62 </span>            : 
<span class="lineNum">      63 </span>            : static tree
<span class="lineNum">      64 </span><span class="lineCov">    5008038 : get_rhs_or_phi_arg (gimple *stmt)</span>
<span class="lineNum">      65 </span>            : {
<span class="lineNum">      66 </span><span class="lineCov">   10016076 :   if (gimple_code (stmt) == GIMPLE_PHI)</span>
<span class="lineNum">      67 </span><span class="lineCov">    9991836 :     return degenerate_phi_result (as_a &lt;gphi *&gt; (stmt));</span>
<span class="lineNum">      68 </span><span class="lineCov">      12120 :   else if (gimple_assign_single_p (stmt))</span>
<span class="lineNum">      69 </span><span class="lineCov">      24240 :     return gimple_assign_rhs1 (stmt);</span>
<span class="lineNum">      70 </span>            :   else
<span class="lineNum">      71 </span><span class="lineNoCov">          0 :     gcc_unreachable ();</span>
<span class="lineNum">      72 </span>            : }
<span class="lineNum">      73 </span>            : 
<span class="lineNum">      74 </span>            : 
<span class="lineNum">      75 </span>            : /* Given a statement STMT, which is either a PHI node or an assignment,
<span class="lineNum">      76 </span>            :    return the &quot;lhs&quot; of the node.  */
<span class="lineNum">      77 </span>            : 
<span class="lineNum">      78 </span>            : static tree
<span class="lineNum">      79 </span><span class="lineNoCov">          0 : get_lhs_or_phi_result (gimple *stmt)</span>
<span class="lineNum">      80 </span>            : {
<span class="lineNum">      81 </span><span class="lineCov">    5787711 :   if (gimple_code (stmt) == GIMPLE_PHI)</span>
<span class="lineNum">      82 </span><span class="lineCov">   11443960 :     return gimple_phi_result (stmt);</span>
<span class="lineNum">      83 </span><span class="lineCov">     131462 :   else if (is_gimple_assign (stmt))</span>
<span class="lineNum">      84 </span><span class="lineCov">     131462 :     return gimple_assign_lhs (stmt);</span>
<span class="lineNum">      85 </span>            :   else
<span class="lineNum">      86 </span><span class="lineNoCov">          0 :     gcc_unreachable ();</span>
<span class="lineNum">      87 </span>            : }
<span class="lineNum">      88 </span>            : 
<span class="lineNum">      89 </span>            : /* Propagate RHS into all uses of LHS (when possible).
<span class="lineNum">      90 </span>            : 
<span class="lineNum">      91 </span>            :    RHS and LHS are derived from STMT, which is passed in solely so
<span class="lineNum">      92 </span>            :    that we can remove it if propagation is successful.
<span class="lineNum">      93 </span>            : 
<span class="lineNum">      94 </span>            :    When propagating into a PHI node or into a statement which turns
<span class="lineNum">      95 </span>            :    into a trivial copy or constant initialization, set the
<span class="lineNum">      96 </span>            :    appropriate bit in INTERESTING_NAMEs so that we will visit those
<span class="lineNum">      97 </span>            :    nodes as well in an effort to pick up secondary optimization
<span class="lineNum">      98 </span>            :    opportunities. 
<span class="lineNum">      99 </span>            : 
<span class="lineNum">     100 </span>            :    NEED_EH_CLEANUP tracks blocks that need their EH information
<span class="lineNum">     101 </span>            :    cleaned up after changing EH information on a statement.  */
<span class="lineNum">     102 </span>            : 
<span class="lineNum">     103 </span>            : static bool
<span class="lineNum">     104 </span><span class="lineCov">     407647 : propagate_rhs_into_lhs (gimple *stmt, tree lhs, tree rhs,</span>
<span class="lineNum">     105 </span>            :                         bitmap interesting_names, bitmap need_eh_cleanup)
<span class="lineNum">     106 </span>            : {
<span class="lineNum">     107 </span><span class="lineCov">     407647 :   bool cfg_altered = false;</span>
<span class="lineNum">     108 </span>            : 
<span class="lineNum">     109 </span>            :   /* First verify that propagation is valid.  */
<span class="lineNum">     110 </span><span class="lineCov">     407647 :   if (may_propagate_copy (lhs, rhs))</span>
<span class="lineNum">     111 </span>            :     {
<span class="lineNum">     112 </span><span class="lineCov">     407439 :       use_operand_p use_p;</span>
<span class="lineNum">     113 </span><span class="lineCov">     407439 :       imm_use_iterator iter;</span>
<span class="lineNum">     114 </span><span class="lineCov">     407439 :       gimple *use_stmt;</span>
<span class="lineNum">     115 </span><span class="lineCov">     407439 :       bool all = true;</span>
<span class="lineNum">     116 </span>            : 
<span class="lineNum">     117 </span>            :       /* Dump details.  */
<span class="lineNum">     118 </span><span class="lineCov">     407439 :       if (dump_file &amp;&amp; (dump_flags &amp; TDF_DETAILS))</span>
<span class="lineNum">     119 </span>            :         {
<span class="lineNum">     120 </span><span class="lineNoCov">          0 :           fprintf (dump_file, &quot;  Replacing '&quot;);</span>
<span class="lineNum">     121 </span><span class="lineNoCov">          0 :           print_generic_expr (dump_file, lhs, dump_flags);</span>
<span class="lineNum">     122 </span><span class="lineNoCov">          0 :           fprintf (dump_file, &quot;' with %s '&quot;,</span>
<span class="lineNum">     123 </span><span class="lineNoCov">          0 :                    (TREE_CODE (rhs) != SSA_NAME ? &quot;constant&quot; : &quot;variable&quot;));</span>
<span class="lineNum">     124 </span><span class="lineNoCov">          0 :                    print_generic_expr (dump_file, rhs, dump_flags);</span>
<span class="lineNum">     125 </span><span class="lineNoCov">          0 :           fprintf (dump_file, &quot;'\n&quot;);</span>
<span class="lineNum">     126 </span>            :         }
<span class="lineNum">     127 </span>            : 
<span class="lineNum">     128 </span>            :       /* Walk over every use of LHS and try to replace the use with RHS.
<span class="lineNum">     129 </span>            :          At this point the only reason why such a propagation would not
<span class="lineNum">     130 </span>            :          be successful would be if the use occurs in an ASM_EXPR.  */
<span class="lineNum">     131 </span><span class="lineCov">    1205616 :       FOR_EACH_IMM_USE_STMT (use_stmt, iter, lhs)</span>
<span class="lineNum">     132 </span>            :         {
<span class="lineNum">     133 </span>            :           /* Leave debug stmts alone.  If we succeed in propagating
<span class="lineNum">     134 </span>            :              all non-debug uses, we'll drop the DEF, and propagation
<span class="lineNum">     135 </span>            :              into debug stmts will occur then.  */
<span class="lineNum">     136 </span><span class="lineCov">     798177 :           if (gimple_debug_bind_p (use_stmt))</span>
<span class="lineNum">     137 </span>            :             continue;
<span class="lineNum">     138 </span>            : 
<span class="lineNum">     139 </span>            :           /* It's not always safe to propagate into an ASM_EXPR.  */
<span class="lineNum">     140 </span><span class="lineCov">     581293 :           if (gimple_code (use_stmt) == GIMPLE_ASM</span>
<span class="lineNum">     141 </span><span class="lineCov">     581293 :               &amp;&amp; ! may_propagate_copy_into_asm (lhs))</span>
<span class="lineNum">     142 </span>            :             {
<span class="lineNum">     143 </span>            :               all = false;
<span class="lineNum">     144 </span>            :               continue;
<span class="lineNum">     145 </span>            :             }
<span class="lineNum">     146 </span>            : 
<span class="lineNum">     147 </span>            :           /* It's not ok to propagate into the definition stmt of RHS.
<span class="lineNum">     148 </span>            :                 &lt;bb 9&gt;:
<span class="lineNum">     149 </span>            :                   # prephitmp.12_36 = PHI &lt;g_67.1_6(9)&gt;
<span class="lineNum">     150 </span>            :                   g_67.1_6 = prephitmp.12_36;
<span class="lineNum">     151 </span>            :                   goto &lt;bb 9&gt;;
<span class="lineNum">     152 </span>            :              While this is strictly all dead code we do not want to
<span class="lineNum">     153 </span>            :              deal with this here.  */
<span class="lineNum">     154 </span><span class="lineCov">     581293 :           if (TREE_CODE (rhs) == SSA_NAME</span>
<span class="lineNum">     155 </span><span class="lineCov">     581293 :               &amp;&amp; SSA_NAME_DEF_STMT (rhs) == use_stmt)</span>
<span class="lineNum">     156 </span>            :             {
<span class="lineNum">     157 </span>            :               all = false;
<span class="lineNum">     158 </span>            :               continue;
<span class="lineNum">     159 </span>            :             }
<span class="lineNum">     160 </span>            : 
<span class="lineNum">     161 </span>            :           /* Dump details.  */
<span class="lineNum">     162 </span><span class="lineCov">     580404 :           if (dump_file &amp;&amp; (dump_flags &amp; TDF_DETAILS))</span>
<span class="lineNum">     163 </span>            :             {
<span class="lineNum">     164 </span><span class="lineNoCov">          0 :               fprintf (dump_file, &quot;    Original statement:&quot;);</span>
<span class="lineNum">     165 </span><span class="lineNoCov">          0 :               print_gimple_stmt (dump_file, use_stmt, 0, dump_flags);</span>
<span class="lineNum">     166 </span>            :             }
<span class="lineNum">     167 </span>            : 
<span class="lineNum">     168 </span>            :           /* Propagate the RHS into this use of the LHS.  */
<span class="lineNum">     169 </span><span class="lineCov">    3506738 :           FOR_EACH_IMM_USE_ON_STMT (use_p, iter)</span>
<span class="lineNum">     170 </span><span class="lineCov">     592561 :             propagate_value (use_p, rhs);</span>
<span class="lineNum">     171 </span>            : 
<span class="lineNum">     172 </span>            :           /* Special cases to avoid useless calls into the folding
<span class="lineNum">     173 </span>            :              routines, operand scanning, etc.
<span class="lineNum">     174 </span>            : 
<span class="lineNum">     175 </span>            :              Propagation into a PHI may cause the PHI to become
<span class="lineNum">     176 </span>            :              a degenerate, so mark the PHI as interesting.  No other
<span class="lineNum">     177 </span>            :              actions are necessary.  */
<span class="lineNum">     178 </span><span class="lineCov">    1160808 :           if (gimple_code (use_stmt) == GIMPLE_PHI)</span>
<span class="lineNum">     179 </span>            :             {
<span class="lineNum">     180 </span><span class="lineCov">     262999 :               tree result;</span>
<span class="lineNum">     181 </span>            : 
<span class="lineNum">     182 </span>            :               /* Dump details.  */
<span class="lineNum">     183 </span><span class="lineCov">     262999 :               if (dump_file &amp;&amp; (dump_flags &amp; TDF_DETAILS))</span>
<span class="lineNum">     184 </span>            :                 {
<span class="lineNum">     185 </span><span class="lineNoCov">          0 :                   fprintf (dump_file, &quot;    Updated statement:&quot;);</span>
<span class="lineNum">     186 </span><span class="lineNoCov">          0 :                   print_gimple_stmt (dump_file, use_stmt, 0, dump_flags);</span>
<span class="lineNum">     187 </span>            :                 }
<span class="lineNum">     188 </span>            : 
<span class="lineNum">     189 </span><span class="lineCov">     262999 :               result = get_lhs_or_phi_result (use_stmt);</span>
<span class="lineNum">     190 </span><span class="lineCov">     262999 :               bitmap_set_bit (interesting_names, SSA_NAME_VERSION (result));</span>
<span class="lineNum">     191 </span><span class="lineCov">     262999 :               continue;</span>
<span class="lineNum">     192 </span>            :             }
<span class="lineNum">     193 </span>            : 
<span class="lineNum">     194 </span>            :           /* From this point onward we are propagating into a
<span class="lineNum">     195 </span>            :              real statement.  Folding may (or may not) be possible,
<span class="lineNum">     196 </span>            :              we may expose new operands, expose dead EH edges,
<span class="lineNum">     197 </span>            :              etc.  */
<span class="lineNum">     198 </span>            :           /* NOTE tuples. In the tuples world, fold_stmt_inplace
<span class="lineNum">     199 </span>            :              cannot fold a call that simplifies to a constant,
<span class="lineNum">     200 </span>            :              because the GIMPLE_CALL must be replaced by a
<span class="lineNum">     201 </span>            :              GIMPLE_ASSIGN, and there is no way to effect such a
<span class="lineNum">     202 </span>            :              transformation in-place.  We might want to consider
<span class="lineNum">     203 </span>            :              using the more general fold_stmt here.  */
<span class="lineNum">     204 </span><span class="lineCov">     317405 :             {</span>
<span class="lineNum">     205 </span><span class="lineCov">     317405 :               gimple_stmt_iterator gsi = gsi_for_stmt (use_stmt);</span>
<span class="lineNum">     206 </span><span class="lineCov">     317405 :               fold_stmt_inplace (&amp;gsi);</span>
<span class="lineNum">     207 </span>            :             }
<span class="lineNum">     208 </span>            : 
<span class="lineNum">     209 </span>            :           /* Sometimes propagation can expose new operands to the
<span class="lineNum">     210 </span>            :              renamer.  */
<span class="lineNum">     211 </span><span class="lineCov">     317405 :           update_stmt (use_stmt);</span>
<span class="lineNum">     212 </span>            : 
<span class="lineNum">     213 </span>            :           /* Dump details.  */
<span class="lineNum">     214 </span><span class="lineCov">     317405 :           if (dump_file &amp;&amp; (dump_flags &amp; TDF_DETAILS))</span>
<span class="lineNum">     215 </span>            :             {
<span class="lineNum">     216 </span><span class="lineNoCov">          0 :               fprintf (dump_file, &quot;    Updated statement:&quot;);</span>
<span class="lineNum">     217 </span><span class="lineNoCov">          0 :               print_gimple_stmt (dump_file, use_stmt, 0, dump_flags);</span>
<span class="lineNum">     218 </span>            :             }
<span class="lineNum">     219 </span>            : 
<span class="lineNum">     220 </span>            :           /* If we replaced a variable index with a constant, then
<span class="lineNum">     221 </span>            :              we would need to update the invariant flag for ADDR_EXPRs.  */
<span class="lineNum">     222 </span><span class="lineCov">     317405 :           if (gimple_assign_single_p (use_stmt)</span>
<span class="lineNum">     223 </span><span class="lineCov">     227242 :               &amp;&amp; TREE_CODE (gimple_assign_rhs1 (use_stmt)) == ADDR_EXPR)</span>
<span class="lineNum">     224 </span><span class="lineCov">       2289 :             recompute_tree_invariant_for_addr_expr</span>
<span class="lineNum">     225 </span><span class="lineCov">       4578 :                 (gimple_assign_rhs1 (use_stmt));</span>
<span class="lineNum">     226 </span>            : 
<span class="lineNum">     227 </span>            :           /* If we cleaned up EH information from the statement,
<span class="lineNum">     228 </span>            :              mark its containing block as needing EH cleanups.  */
<span class="lineNum">     229 </span><span class="lineCov">     317405 :           if (maybe_clean_or_replace_eh_stmt (use_stmt, use_stmt))</span>
<span class="lineNum">     230 </span>            :             {
<span class="lineNum">     231 </span><span class="lineNoCov">          0 :               bitmap_set_bit (need_eh_cleanup, gimple_bb (use_stmt)-&gt;index);</span>
<span class="lineNum">     232 </span><span class="lineNoCov">          0 :               if (dump_file &amp;&amp; (dump_flags &amp; TDF_DETAILS))</span>
<span class="lineNum">     233 </span><span class="lineNoCov">          0 :                 fprintf (dump_file, &quot;  Flagged to clear EH edges.\n&quot;);</span>
<span class="lineNum">     234 </span>            :             }
<span class="lineNum">     235 </span>            : 
<span class="lineNum">     236 </span>            :           /* Propagation may expose new trivial copy/constant propagation
<span class="lineNum">     237 </span>            :              opportunities.  */
<span class="lineNum">     238 </span><span class="lineCov">     317405 :           if (gimple_assign_single_p (use_stmt)</span>
<span class="lineNum">     239 </span><span class="lineCov">     227242 :               &amp;&amp; TREE_CODE (gimple_assign_lhs (use_stmt)) == SSA_NAME</span>
<span class="lineNum">     240 </span><span class="lineCov">     135508 :               &amp;&amp; (TREE_CODE (gimple_assign_rhs1 (use_stmt)) == SSA_NAME</span>
<span class="lineNum">     241 </span><span class="lineCov">     115498 :                   || is_gimple_min_invariant (gimple_assign_rhs1 (use_stmt))))</span>
<span class="lineNum">     242 </span>            :             {
<span class="lineNum">     243 </span><span class="lineCov">      32989 :               tree result = get_lhs_or_phi_result (use_stmt);</span>
<span class="lineNum">     244 </span><span class="lineCov">      32989 :               bitmap_set_bit (interesting_names, SSA_NAME_VERSION (result));</span>
<span class="lineNum">     245 </span>            :             }
<span class="lineNum">     246 </span>            : 
<span class="lineNum">     247 </span>            :           /* Propagation into these nodes may make certain edges in
<span class="lineNum">     248 </span>            :              the CFG unexecutable.  We want to identify them as PHI nodes
<span class="lineNum">     249 </span>            :              at the destination of those unexecutable edges may become
<span class="lineNum">     250 </span>            :              degenerates.  */
<span class="lineNum">     251 </span><span class="lineCov">     284416 :           else if (gimple_code (use_stmt) == GIMPLE_COND</span>
<span class="lineNum">     252 </span><span class="lineCov">     422704 :                    || gimple_code (use_stmt) == GIMPLE_SWITCH</span>
<span class="lineNum">     253 </span><span class="lineCov">     707044 :                    || gimple_code (use_stmt) == GIMPLE_GOTO)</span>
<span class="lineNum">     254 </span>            :             {
<span class="lineNum">     255 </span><span class="lineCov">      73104 :               tree val;</span>
<span class="lineNum">     256 </span>            : 
<span class="lineNum">     257 </span><span class="lineCov">     146208 :               if (gimple_code (use_stmt) == GIMPLE_COND)</span>
<span class="lineNum">     258 </span><span class="lineCov">      73064 :                 val = fold_binary_loc (gimple_location (use_stmt),</span>
<span class="lineNum">     259 </span>            :                                    gimple_cond_code (use_stmt),
<span class="lineNum">     260 </span>            :                                    boolean_type_node,
<span class="lineNum">     261 </span>            :                                    gimple_cond_lhs (use_stmt),
<span class="lineNum">     262 </span>            :                                    gimple_cond_rhs (use_stmt));
<span class="lineNum">     263 </span><span class="lineCov">         80 :               else if (gimple_code (use_stmt) == GIMPLE_SWITCH)</span>
<span class="lineNum">     264 </span><span class="lineCov">         38 :                 val = gimple_switch_index (as_a &lt;gswitch *&gt; (use_stmt));</span>
<span class="lineNum">     265 </span>            :               else
<span class="lineNum">     266 </span><span class="lineCov">          2 :                 val = gimple_goto_dest  (use_stmt);</span>
<span class="lineNum">     267 </span>            : 
<span class="lineNum">     268 </span><span class="lineCov">      73104 :               if (val &amp;&amp; is_gimple_min_invariant (val))</span>
<span class="lineNum">     269 </span>            :                 {
<span class="lineNum">     270 </span><span class="lineCov">       2495 :                   basic_block bb = gimple_bb (use_stmt);</span>
<span class="lineNum">     271 </span><span class="lineCov">       2495 :                   edge te = find_taken_edge (bb, val);</span>
<span class="lineNum">     272 </span><span class="lineCov">       2495 :                   if (!te)</span>
<span class="lineNum">     273 </span><span class="lineNoCov">          0 :                     continue;</span>
<span class="lineNum">     274 </span>            : 
<span class="lineNum">     275 </span><span class="lineCov">       2495 :                   edge_iterator ei;</span>
<span class="lineNum">     276 </span><span class="lineCov">       2495 :                   edge e;</span>
<span class="lineNum">     277 </span><span class="lineCov">       2495 :                   gimple_stmt_iterator gsi;</span>
<span class="lineNum">     278 </span><span class="lineCov">       2495 :                   gphi_iterator psi;</span>
<span class="lineNum">     279 </span>            : 
<span class="lineNum">     280 </span>            :                   /* Remove all outgoing edges except TE.  */
<span class="lineNum">     281 </span><span class="lineCov">       9985 :                   for (ei = ei_start (bb-&gt;succs); (e = ei_safe_edge (ei));)</span>
<span class="lineNum">     282 </span>            :                     {
<span class="lineNum">     283 </span><span class="lineCov">       4995 :                       if (e != te)</span>
<span class="lineNum">     284 </span>            :                         {
<span class="lineNum">     285 </span>            :                           /* Mark all the PHI nodes at the destination of
<span class="lineNum">     286 </span>            :                              the unexecutable edge as interesting.  */
<span class="lineNum">     287 </span><span class="lineCov">       2500 :                           for (psi = gsi_start_phis (e-&gt;dest);</span>
<span class="lineNum">     288 </span><span class="lineCov">      10202 :                                !gsi_end_p (psi);</span>
<span class="lineNum">     289 </span><span class="lineCov">       2601 :                                gsi_next (&amp;psi))</span>
<span class="lineNum">     290 </span>            :                             {
<span class="lineNum">     291 </span><span class="lineCov">       2601 :                               gphi *phi = psi.phi ();</span>
<span class="lineNum">     292 </span>            : 
<span class="lineNum">     293 </span><span class="lineCov">       2601 :                               tree result = gimple_phi_result (phi);</span>
<span class="lineNum">     294 </span><span class="lineCov">       2601 :                               int version = SSA_NAME_VERSION (result);</span>
<span class="lineNum">     295 </span>            : 
<span class="lineNum">     296 </span><span class="lineCov">       2601 :                               bitmap_set_bit (interesting_names, version);</span>
<span class="lineNum">     297 </span>            :                             }
<span class="lineNum">     298 </span>            : 
<span class="lineNum">     299 </span><span class="lineCov">       2500 :                           te-&gt;probability += e-&gt;probability;</span>
<span class="lineNum">     300 </span>            : 
<span class="lineNum">     301 </span><span class="lineCov">       2500 :                           remove_edge (e);</span>
<span class="lineNum">     302 </span><span class="lineCov">       2500 :                           cfg_altered = true;</span>
<span class="lineNum">     303 </span>            :                         }
<span class="lineNum">     304 </span>            :                       else
<span class="lineNum">     305 </span><span class="lineCov">       2495 :                         ei_next (&amp;ei);</span>
<span class="lineNum">     306 </span>            :                     }
<span class="lineNum">     307 </span>            : 
<span class="lineNum">     308 </span><span class="lineCov">       4990 :                   gsi = gsi_last_bb (gimple_bb (use_stmt));</span>
<span class="lineNum">     309 </span><span class="lineCov">       2495 :                   gsi_remove (&amp;gsi, true);</span>
<span class="lineNum">     310 </span>            : 
<span class="lineNum">     311 </span>            :                   /* And fixup the flags on the single remaining edge.  */
<span class="lineNum">     312 </span><span class="lineCov">       2495 :                   te-&gt;flags &amp;= ~(EDGE_TRUE_VALUE | EDGE_FALSE_VALUE);</span>
<span class="lineNum">     313 </span><span class="lineCov">       2495 :                   te-&gt;flags &amp;= ~EDGE_ABNORMAL;</span>
<span class="lineNum">     314 </span><span class="lineCov">       2495 :                   te-&gt;flags |= EDGE_FALLTHRU;</span>
<span class="lineNum">     315 </span>            :                 }
<span class="lineNum">     316 </span>            :             }
<span class="lineNum">     317 </span>            :         }
<span class="lineNum">     318 </span>            : 
<span class="lineNum">     319 </span>            :       /* Ensure there is nothing else to do. */
<span class="lineNum">     320 </span><span class="lineCov">     407439 :       gcc_assert (!all || has_zero_uses (lhs));</span>
<span class="lineNum">     321 </span>            : 
<span class="lineNum">     322 </span>            :       /* If we were able to propagate away all uses of LHS, then
<span class="lineNum">     323 </span>            :          we can remove STMT.  */
<span class="lineNum">     324 </span><span class="lineCov">     407439 :       if (all)</span>
<span class="lineNum">     325 </span><span class="lineCov">     406550 :         remove_stmt_or_phi (stmt);</span>
<span class="lineNum">     326 </span>            :     }
<span class="lineNum">     327 </span><span class="lineCov">     407647 :   return cfg_altered;</span>
<span class="lineNum">     328 </span>            : }
<span class="lineNum">     329 </span>            : 
<span class="lineNum">     330 </span>            : /* STMT is either a PHI node (potentially a degenerate PHI node) or
<span class="lineNum">     331 </span>            :    a statement that is a trivial copy or constant initialization.
<span class="lineNum">     332 </span>            : 
<span class="lineNum">     333 </span>            :    Attempt to eliminate STMT by propagating its RHS into all uses of
<span class="lineNum">     334 </span>            :    its LHS.  This may in turn set new bits in INTERESTING_NAMES
<span class="lineNum">     335 </span>            :    for nodes we want to revisit later.
<span class="lineNum">     336 </span>            : 
<span class="lineNum">     337 </span>            :    All exit paths should clear INTERESTING_NAMES for the result
<span class="lineNum">     338 </span>            :    of STMT.
<span class="lineNum">     339 </span>            : 
<span class="lineNum">     340 </span>            :    NEED_EH_CLEANUP tracks blocks that need their EH information
<span class="lineNum">     341 </span>            :    cleaned up after changing EH information on a statement.  It is
<span class="lineNum">     342 </span>            :    not set or queried here, but passed along to children.  */
<span class="lineNum">     343 </span>            : 
<span class="lineNum">     344 </span>            : static bool
<span class="lineNum">     345 </span><span class="lineCov">    5491723 : eliminate_const_or_copy (gimple *stmt, bitmap interesting_names,</span>
<span class="lineNum">     346 </span>            :                          bitmap need_eh_cleanup)
<span class="lineNum">     347 </span>            : {
<span class="lineNum">     348 </span><span class="lineCov">    5491723 :   tree lhs = get_lhs_or_phi_result (stmt);</span>
<span class="lineNum">     349 </span><span class="lineCov">    5491723 :   tree rhs;</span>
<span class="lineNum">     350 </span><span class="lineCov">    5491723 :   int version = SSA_NAME_VERSION (lhs);</span>
<span class="lineNum">     351 </span><span class="lineCov">    5491723 :   bool cfg_altered = false;</span>
<span class="lineNum">     352 </span>            : 
<span class="lineNum">     353 </span>            :   /* If the LHS of this statement or PHI has no uses, then we can
<span class="lineNum">     354 </span>            :      just eliminate it.  This can occur if, for example, the PHI
<span class="lineNum">     355 </span>            :      was created by block duplication due to threading and its only
<span class="lineNum">     356 </span>            :      use was in the conditional at the end of the block which was
<span class="lineNum">     357 </span>            :      deleted.  */
<span class="lineNum">     358 </span><span class="lineCov">    5491723 :   if (has_zero_uses (lhs))</span>
<span class="lineNum">     359 </span>            :     {
<span class="lineNum">     360 </span><span class="lineCov">     483685 :       bitmap_clear_bit (interesting_names, version);</span>
<span class="lineNum">     361 </span><span class="lineCov">     483685 :       remove_stmt_or_phi (stmt);</span>
<span class="lineNum">     362 </span><span class="lineCov">     483685 :       return cfg_altered;</span>
<span class="lineNum">     363 </span>            :     }
<span class="lineNum">     364 </span>            : 
<span class="lineNum">     365 </span>            :   /* Get the RHS of the assignment or PHI node if the PHI is a
<span class="lineNum">     366 </span>            :      degenerate.  */
<span class="lineNum">     367 </span><span class="lineCov">    5008038 :   rhs = get_rhs_or_phi_arg (stmt);</span>
<span class="lineNum">     368 </span><span class="lineCov">    5008038 :   if (!rhs)</span>
<span class="lineNum">     369 </span>            :     {
<span class="lineNum">     370 </span><span class="lineCov">    4382334 :       bitmap_clear_bit (interesting_names, version);</span>
<span class="lineNum">     371 </span><span class="lineCov">    4382334 :       return cfg_altered;</span>
<span class="lineNum">     372 </span>            :     }
<span class="lineNum">     373 </span>            : 
<span class="lineNum">     374 </span><span class="lineCov">    1251408 :   if (!virtual_operand_p (lhs))</span>
<span class="lineNum">     375 </span><span class="lineCov">     407647 :     cfg_altered = propagate_rhs_into_lhs (stmt, lhs, rhs,</span>
<span class="lineNum">     376 </span>            :                                           interesting_names, need_eh_cleanup);
<span class="lineNum">     377 </span>            :   else
<span class="lineNum">     378 </span>            :     {
<span class="lineNum">     379 </span><span class="lineCov">     218057 :       gimple *use_stmt;</span>
<span class="lineNum">     380 </span><span class="lineCov">     218057 :       imm_use_iterator iter;</span>
<span class="lineNum">     381 </span><span class="lineCov">     218057 :       use_operand_p use_p;</span>
<span class="lineNum">     382 </span>            :       /* For virtual operands we have to propagate into all uses as
<span class="lineNum">     383 </span>            :          otherwise we will create overlapping life-ranges.  */
<span class="lineNum">     384 </span><span class="lineCov">     663663 :       FOR_EACH_IMM_USE_STMT (use_stmt, iter, lhs)</span>
<span class="lineNum">     385 </span><span class="lineCov">    2688540 :         FOR_EACH_IMM_USE_ON_STMT (use_p, iter)</span>
<span class="lineNum">     386 </span><span class="lineCov">     453058 :           SET_USE (use_p, rhs);</span>
<span class="lineNum">     387 </span><span class="lineCov">     218057 :       if (SSA_NAME_OCCURS_IN_ABNORMAL_PHI (lhs))</span>
<span class="lineNum">     388 </span><span class="lineCov">         40 :         SSA_NAME_OCCURS_IN_ABNORMAL_PHI (rhs) = 1;</span>
<span class="lineNum">     389 </span><span class="lineCov">     218057 :       remove_stmt_or_phi (stmt);</span>
<span class="lineNum">     390 </span>            :     }
<span class="lineNum">     391 </span>            : 
<span class="lineNum">     392 </span>            :   /* Note that STMT may well have been deleted by now, so do
<span class="lineNum">     393 </span>            :      not access it, instead use the saved version # to clear
<span class="lineNum">     394 </span>            :      T's entry in the worklist.  */
<span class="lineNum">     395 </span><span class="lineCov">     625704 :   bitmap_clear_bit (interesting_names, version);</span>
<span class="lineNum">     396 </span><span class="lineCov">     625704 :   return cfg_altered;</span>
<span class="lineNum">     397 </span>            : }
<span class="lineNum">     398 </span>            : 
<span class="lineNum">     399 </span>            : /* The first phase in degenerate PHI elimination.
<span class="lineNum">     400 </span>            : 
<span class="lineNum">     401 </span>            :    Eliminate the degenerate PHIs in BB, then recurse on the
<span class="lineNum">     402 </span>            :    dominator children of BB. 
<span class="lineNum">     403 </span>            : 
<span class="lineNum">     404 </span>            :    INTERESTING_NAMES tracks SSA_NAMEs that we may want to revisit
<span class="lineNum">     405 </span>            :    in the future.  It is not set or queried here, but passed along
<span class="lineNum">     406 </span>            :    to children. 
<span class="lineNum">     407 </span>            : 
<span class="lineNum">     408 </span>            :    NEED_EH_CLEANUP tracks blocks that need their EH information
<span class="lineNum">     409 </span>            :    cleaned up after changing EH information on a statement.  It is
<span class="lineNum">     410 </span>            :    not set or queried here, but passed along to children.  */
<span class="lineNum">     411 </span>            : 
<span class="lineNum">     412 </span>            : static bool
<span class="lineNum">     413 </span><span class="lineCov">   12601591 : eliminate_degenerate_phis_1 (basic_block bb, bitmap interesting_names,</span>
<span class="lineNum">     414 </span>            :                              bitmap need_eh_cleanup)
<span class="lineNum">     415 </span>            : {
<span class="lineNum">     416 </span><span class="lineCov">   12601591 :   gphi_iterator gsi;</span>
<span class="lineNum">     417 </span><span class="lineCov">   12601591 :   basic_block son;</span>
<span class="lineNum">     418 </span><span class="lineCov">   12601591 :   bool cfg_altered = false;</span>
<span class="lineNum">     419 </span>            : 
<span class="lineNum">     420 </span><span class="lineCov">   23319369 :   for (gsi = gsi_start_phis (bb); !gsi_end_p (gsi);)</span>
<span class="lineNum">     421 </span>            :     {
<span class="lineNum">     422 </span><span class="lineCov">    5358889 :       gphi *phi = gsi.phi ();</span>
<span class="lineNum">     423 </span>            :       /* We might end up removing PHI so advance the iterator now.  */
<span class="lineNum">     424 </span><span class="lineCov">    5358889 :       gsi_next (&amp;gsi);</span>
<span class="lineNum">     425 </span><span class="lineCov">    5358889 :       cfg_altered |= eliminate_const_or_copy (phi, interesting_names,</span>
<span class="lineNum">     426 </span>            :                                               need_eh_cleanup);
<span class="lineNum">     427 </span>            :     }
<span class="lineNum">     428 </span>            : 
<span class="lineNum">     429 </span>            :   /* Recurse into the dominator children of BB.  */
<span class="lineNum">     430 </span><span class="lineCov">   23961580 :   for (son = first_dom_son (CDI_DOMINATORS, bb);</span>
<span class="lineNum">     431 </span><span class="lineCov">   23961580 :        son;</span>
<span class="lineNum">     432 </span><span class="lineCov">   11359989 :        son = next_dom_son (CDI_DOMINATORS, son))</span>
<span class="lineNum">     433 </span><span class="lineCov">   11359989 :     cfg_altered |= eliminate_degenerate_phis_1 (son, interesting_names,</span>
<span class="lineNum">     434 </span>            :                                                 need_eh_cleanup);
<span class="lineNum">     435 </span>            : 
<span class="lineNum">     436 </span><span class="lineCov">   12601591 :   return cfg_altered;</span>
<span class="lineNum">     437 </span>            : }
<span class="lineNum">     438 </span>            : 
<span class="lineNum">     439 </span>            : 
<span class="lineNum">     440 </span>            : /* A very simple pass to eliminate degenerate PHI nodes from the
<span class="lineNum">     441 </span>            :    IL.  This is meant to be fast enough to be able to be run several
<span class="lineNum">     442 </span>            :    times in the optimization pipeline.
<span class="lineNum">     443 </span>            : 
<span class="lineNum">     444 </span>            :    Certain optimizations, particularly those which duplicate blocks
<span class="lineNum">     445 </span>            :    or remove edges from the CFG can create or expose PHIs which are
<span class="lineNum">     446 </span>            :    trivial copies or constant initializations.
<span class="lineNum">     447 </span>            : 
<span class="lineNum">     448 </span>            :    While we could pick up these optimizations in DOM or with the
<span class="lineNum">     449 </span>            :    combination of copy-prop and CCP, those solutions are far too
<span class="lineNum">     450 </span>            :    heavy-weight for our needs.
<span class="lineNum">     451 </span>            : 
<span class="lineNum">     452 </span>            :    This implementation has two phases so that we can efficiently
<span class="lineNum">     453 </span>            :    eliminate the first order degenerate PHIs and second order
<span class="lineNum">     454 </span>            :    degenerate PHIs.
<span class="lineNum">     455 </span>            : 
<span class="lineNum">     456 </span>            :    The first phase performs a dominator walk to identify and eliminate
<span class="lineNum">     457 </span>            :    the vast majority of the degenerate PHIs.  When a degenerate PHI
<span class="lineNum">     458 </span>            :    is identified and eliminated any affected statements or PHIs
<span class="lineNum">     459 </span>            :    are put on a worklist.
<span class="lineNum">     460 </span>            : 
<span class="lineNum">     461 </span>            :    The second phase eliminates degenerate PHIs and trivial copies
<span class="lineNum">     462 </span>            :    or constant initializations using the worklist.  This is how we
<span class="lineNum">     463 </span>            :    pick up the secondary optimization opportunities with minimal
<span class="lineNum">     464 </span>            :    cost.  */
<span class="lineNum">     465 </span>            : 
<span class="lineNum">     466 </span>            : namespace {
<span class="lineNum">     467 </span>            : 
<span class="lineNum">     468 </span>            : const pass_data pass_data_phi_only_cprop =
<span class="lineNum">     469 </span>            : {
<span class="lineNum">     470 </span>            :   GIMPLE_PASS, /* type */
<span class="lineNum">     471 </span>            :   &quot;phicprop&quot;, /* name */
<span class="lineNum">     472 </span>            :   OPTGROUP_NONE, /* optinfo_flags */
<span class="lineNum">     473 </span>            :   TV_TREE_PHI_CPROP, /* tv_id */
<span class="lineNum">     474 </span>            :   ( PROP_cfg | PROP_ssa ), /* properties_required */
<span class="lineNum">     475 </span>            :   0, /* properties_provided */
<span class="lineNum">     476 </span>            :   0, /* properties_destroyed */
<span class="lineNum">     477 </span>            :   0, /* todo_flags_start */
<span class="lineNum">     478 </span>            :   ( TODO_cleanup_cfg | TODO_update_ssa ), /* todo_flags_finish */
<span class="lineNum">     479 </span>            : };
<span class="lineNum">     480 </span>            : 
<span class="lineNum">     481 </span>            : class pass_phi_only_cprop : public gimple_opt_pass
<span class="lineNum">     482 </span>            : {
<span class="lineNum">     483 </span>            : public:
<span class="lineNum">     484 </span>            :   pass_phi_only_cprop (gcc::context *ctxt)
<span class="lineNum">     485 </span><span class="lineCov">     681248 :     : gimple_opt_pass (pass_data_phi_only_cprop, ctxt)</span>
<span class="lineNum">     486 </span>            :   {}
<a name="487"><span class="lineNum">     487 </span>            : </a>
<a name="488"><span class="lineNum">     488 </span>            :   /* opt_pass methods: */</a>
<span class="lineNum">     489 </span><span class="lineCov">     170312 :   opt_pass * clone () { return new pass_phi_only_cprop (m_ctxt); }</span>
<span class="lineNum">     490 </span><span class="lineCov">    1241892 :   virtual bool gate (function *) { return flag_tree_dom != 0; }</span>
<span class="lineNum">     491 </span>            :   virtual unsigned int execute (function *);
<span class="lineNum">     492 </span>            : 
<span class="lineNum">     493 </span>            : }; // class pass_phi_only_cprop
<a name="494"><span class="lineNum">     494 </span>            : </a>
<span class="lineNum">     495 </span>            : unsigned int
<span class="lineNum">     496 </span><span class="lineCov">    1241602 : pass_phi_only_cprop::execute (function *fun)</span>
<span class="lineNum">     497 </span>            : {
<span class="lineNum">     498 </span><span class="lineCov">    1241602 :   bool cfg_altered = false;</span>
<span class="lineNum">     499 </span>            : 
<span class="lineNum">     500 </span>            :   /* Bitmap of blocks which need EH information updated.  We can not
<span class="lineNum">     501 </span>            :      update it on-the-fly as doing so invalidates the dominator tree.  */
<span class="lineNum">     502 </span><span class="lineCov">    1241602 :   auto_bitmap need_eh_cleanup;</span>
<span class="lineNum">     503 </span>            : 
<span class="lineNum">     504 </span>            :   /* INTERESTING_NAMES is effectively our worklist, indexed by
<span class="lineNum">     505 </span>            :      SSA_NAME_VERSION.
<span class="lineNum">     506 </span>            : 
<span class="lineNum">     507 </span>            :      A set bit indicates that the statement or PHI node which
<span class="lineNum">     508 </span>            :      defines the SSA_NAME should be (re)examined to determine if
<span class="lineNum">     509 </span>            :      it has become a degenerate PHI or trivial const/copy propagation
<span class="lineNum">     510 </span>            :      opportunity.
<span class="lineNum">     511 </span>            : 
<span class="lineNum">     512 </span>            :      Experiments have show we generally get better compilation
<span class="lineNum">     513 </span>            :      time behavior with bitmaps rather than sbitmaps.  */
<span class="lineNum">     514 </span><span class="lineCov">    2483204 :   auto_bitmap interesting_names;</span>
<span class="lineNum">     515 </span><span class="lineCov">    2483204 :   auto_bitmap interesting_names1;</span>
<span class="lineNum">     516 </span>            : 
<span class="lineNum">     517 </span><span class="lineCov">    1241602 :   calculate_dominance_info (CDI_DOMINATORS);</span>
<span class="lineNum">     518 </span><span class="lineCov">    1241602 :   cfg_altered = false;</span>
<span class="lineNum">     519 </span>            : 
<span class="lineNum">     520 </span>            :   /* First phase.  Eliminate degenerate PHIs via a dominator
<span class="lineNum">     521 </span>            :      walk of the CFG.
<span class="lineNum">     522 </span>            : 
<span class="lineNum">     523 </span>            :      Experiments have indicated that we generally get better
<span class="lineNum">     524 </span>            :      compile-time behavior by visiting blocks in the first
<span class="lineNum">     525 </span>            :      phase in dominator order.  Presumably this is because walking
<span class="lineNum">     526 </span>            :      in dominator order leaves fewer PHIs for later examination
<span class="lineNum">     527 </span>            :      by the worklist phase.  */
<span class="lineNum">     528 </span><span class="lineCov">    3724806 :   cfg_altered = eliminate_degenerate_phis_1 (ENTRY_BLOCK_PTR_FOR_FN (fun),</span>
<span class="lineNum">     529 </span>            :                                              interesting_names,
<span class="lineNum">     530 </span>            :                                              need_eh_cleanup);
<span class="lineNum">     531 </span>            : 
<span class="lineNum">     532 </span>            :   /* Second phase.  Eliminate second order degenerate PHIs as well
<span class="lineNum">     533 </span>            :      as trivial copies or constant initializations identified by
<span class="lineNum">     534 </span>            :      the first phase or this phase.  Basically we keep iterating
<span class="lineNum">     535 </span>            :      until our set of INTERESTING_NAMEs is empty.   */
<span class="lineNum">     536 </span><span class="lineCov">    3767114 :   while (!bitmap_empty_p (interesting_names))</span>
<span class="lineNum">     537 </span>            :     {
<span class="lineNum">     538 </span><span class="lineCov">      42308 :       unsigned int i;</span>
<span class="lineNum">     539 </span><span class="lineCov">      42308 :       bitmap_iterator bi;</span>
<span class="lineNum">     540 </span>            : 
<span class="lineNum">     541 </span>            :       /* EXECUTE_IF_SET_IN_BITMAP does not like its bitmap
<span class="lineNum">     542 </span>            :          changed during the loop.  Copy it to another bitmap and
<span class="lineNum">     543 </span>            :          use that.  */
<span class="lineNum">     544 </span><span class="lineCov">     126924 :       bitmap_copy (interesting_names1, interesting_names);</span>
<span class="lineNum">     545 </span>            : 
<span class="lineNum">     546 </span><span class="lineCov">     217450 :       EXECUTE_IF_SET_IN_BITMAP (interesting_names1, 0, i, bi)</span>
<span class="lineNum">     547 </span>            :         {
<span class="lineNum">     548 </span><span class="lineCov">     132834 :           tree name = ssa_name (i);</span>
<span class="lineNum">     549 </span>            : 
<span class="lineNum">     550 </span>            :           /* Ignore SSA_NAMEs that have been released because
<span class="lineNum">     551 </span>            :              their defining statement was deleted (unreachable).  */
<span class="lineNum">     552 </span><span class="lineCov">     132834 :           if (name)</span>
<span class="lineNum">     553 </span><span class="lineCov">     132834 :             cfg_altered</span>
<span class="lineNum">     554 </span><span class="lineCov">     398502 :               |= eliminate_const_or_copy (SSA_NAME_DEF_STMT (ssa_name (i)),</span>
<span class="lineNum">     555 </span>            :                                           interesting_names, need_eh_cleanup);
<span class="lineNum">     556 </span>            :         }
<span class="lineNum">     557 </span>            :     }
<span class="lineNum">     558 </span>            : 
<span class="lineNum">     559 </span><span class="lineCov">    1241602 :   if (cfg_altered)</span>
<span class="lineNum">     560 </span>            :     {
<span class="lineNum">     561 </span><span class="lineCov">       2138 :       free_dominance_info (CDI_DOMINATORS);</span>
<span class="lineNum">     562 </span>            :       /* If we changed the CFG schedule loops for fixup by cfgcleanup.  */
<span class="lineNum">     563 </span><span class="lineCov">       2138 :       loops_state_set (LOOPS_NEED_FIXUP);</span>
<span class="lineNum">     564 </span>            :     }
<span class="lineNum">     565 </span>            : 
<span class="lineNum">     566 </span>            :   /* Propagation of const and copies may make some EH edges dead.  Purge
<span class="lineNum">     567 </span>            :      such edges from the CFG as needed.  */
<span class="lineNum">     568 </span><span class="lineCov">    3724806 :   if (!bitmap_empty_p (need_eh_cleanup))</span>
<span class="lineNum">     569 </span><span class="lineNoCov">          0 :     gimple_purge_all_dead_eh_edges (need_eh_cleanup);</span>
<span class="lineNum">     570 </span>            : 
<span class="lineNum">     571 </span><span class="lineCov">    1241602 :   return 0;</span>
<span class="lineNum">     572 </span>            : }
<span class="lineNum">     573 </span>            : 
<span class="lineNum">     574 </span>            : } // anon namespace
<a name="575"><span class="lineNum">     575 </span>            : </a>
<span class="lineNum">     576 </span>            : gimple_opt_pass *
<span class="lineNum">     577 </span><span class="lineCov">     170312 : make_pass_phi_only_cprop (gcc::context *ctxt)</span>
<span class="lineNum">     578 </span>            : {
<span class="lineNum">     579 </span><span class="lineCov">     170312 :   return new pass_phi_only_cprop (ctxt);</span>
<span class="lineNum">     580 </span>            : }
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.0</a></td></tr>
  </table>
  <br>
<h3>LCOV profile is generated on x86_64 machine using following configure options: configure --disable-bootstrap --enable-coverage=opt --enable-languages=c,c++,fortran,go,jit,lto --enable-host-shared. GCC test suite is run with the built compiler.</h3></body></html>
