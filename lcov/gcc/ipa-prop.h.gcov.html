<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - gcc.info - gcc/ipa-prop.h</title>
  <link rel="stylesheet" type="text/css" href="../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../index.html">top level</a> - <a href="index.html">gcc</a> - ipa-prop.h<span style="font-size: 80%;"> (source / <a href="ipa-prop.h.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">gcc.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">66</td>
            <td class="headerCovTableEntry">113</td>
            <td class="headerCovTableEntryLo">58.4 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2018-09-22 10:58:49</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">7</td>
            <td class="headerCovTableEntry">28</td>
            <td class="headerCovTableEntryLo">25.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /* Interprocedural analyses.</a>
<span class="lineNum">       2 </span>            :    Copyright (C) 2005-2018 Free Software Foundation, Inc.
<span class="lineNum">       3 </span>            : 
<span class="lineNum">       4 </span>            : This file is part of GCC.
<span class="lineNum">       5 </span>            : 
<span class="lineNum">       6 </span>            : GCC is free software; you can redistribute it and/or modify it under
<span class="lineNum">       7 </span>            : the terms of the GNU General Public License as published by the Free
<span class="lineNum">       8 </span>            : Software Foundation; either version 3, or (at your option) any later
<span class="lineNum">       9 </span>            : version.
<span class="lineNum">      10 </span>            : 
<span class="lineNum">      11 </span>            : GCC is distributed in the hope that it will be useful, but WITHOUT ANY
<span class="lineNum">      12 </span>            : WARRANTY; without even the implied warranty of MERCHANTABILITY or
<span class="lineNum">      13 </span>            : FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
<span class="lineNum">      14 </span>            : for more details.
<span class="lineNum">      15 </span>            : 
<span class="lineNum">      16 </span>            : You should have received a copy of the GNU General Public License
<span class="lineNum">      17 </span>            : along with GCC; see the file COPYING3.  If not see
<span class="lineNum">      18 </span>            : &lt;http://www.gnu.org/licenses/&gt;.  */
<span class="lineNum">      19 </span>            : 
<span class="lineNum">      20 </span>            : #ifndef IPA_PROP_H
<span class="lineNum">      21 </span>            : #define IPA_PROP_H
<span class="lineNum">      22 </span>            : 
<span class="lineNum">      23 </span>            : /* The following definitions and interfaces are used by
<span class="lineNum">      24 </span>            :    interprocedural analyses or parameters.  */
<span class="lineNum">      25 </span>            : 
<span class="lineNum">      26 </span>            : #define IPA_UNDESCRIBED_USE -1
<span class="lineNum">      27 </span>            : 
<span class="lineNum">      28 </span>            : /* ipa-prop.c stuff (ipa-cp, indirect inlining):  */
<span class="lineNum">      29 </span>            : 
<span class="lineNum">      30 </span>            : /* A jump function for a callsite represents the values passed as actual
<span class="lineNum">      31 </span>            :    arguments of the callsite.  They were originally proposed in a paper called
<span class="lineNum">      32 </span>            :    &quot;Interprocedural Constant Propagation&quot;, by David Callahan, Keith D Cooper,
<span class="lineNum">      33 </span>            :    Ken Kennedy, Linda Torczon in Comp86, pg 152-161.  There are three main
<span class="lineNum">      34 </span>            :    types of values :
<span class="lineNum">      35 </span>            : 
<span class="lineNum">      36 </span>            :    Pass-through - the caller's formal parameter is passed as an actual
<span class="lineNum">      37 </span>            :                   argument, possibly one simple operation performed on it.
<span class="lineNum">      38 </span>            :    Constant     - a constant (is_gimple_ip_invariant)is passed as an actual
<span class="lineNum">      39 </span>            :                   argument.
<span class="lineNum">      40 </span>            :    Unknown      - neither of the above.
<span class="lineNum">      41 </span>            : 
<span class="lineNum">      42 </span>            :    IPA_JF_ANCESTOR is a special pass-through jump function, which means that
<span class="lineNum">      43 </span>            :    the result is an address of a part of the object pointed to by the formal
<span class="lineNum">      44 </span>            :    parameter to which the function refers.  It is mainly intended to represent
<span class="lineNum">      45 </span>            :    getting addresses of ancestor fields in C++
<span class="lineNum">      46 </span>            :    (e.g. &amp;this_1(D)-&gt;D.1766.D.1756).  Note that if the original pointer is
<span class="lineNum">      47 </span>            :    NULL, ancestor jump function must behave like a simple pass-through.
<span class="lineNum">      48 </span>            : 
<span class="lineNum">      49 </span>            :    Other pass-through functions can either simply pass on an unchanged formal
<span class="lineNum">      50 </span>            :    parameter or can apply one simple binary operation to it (such jump
<span class="lineNum">      51 </span>            :    functions are called polynomial).
<span class="lineNum">      52 </span>            : 
<span class="lineNum">      53 </span>            :    Jump functions are computed in ipa-prop.c by function
<span class="lineNum">      54 </span>            :    update_call_notes_after_inlining.  Some information can be lost and jump
<span class="lineNum">      55 </span>            :    functions degraded accordingly when inlining, see
<span class="lineNum">      56 </span>            :    update_call_notes_after_inlining in the same file.  */
<span class="lineNum">      57 </span>            : 
<span class="lineNum">      58 </span>            : enum jump_func_type
<span class="lineNum">      59 </span>            : {
<span class="lineNum">      60 </span>            :   IPA_JF_UNKNOWN = 0,  /* newly allocated and zeroed jump functions default */
<span class="lineNum">      61 </span>            :   IPA_JF_CONST,             /* represented by field costant */
<span class="lineNum">      62 </span>            :   IPA_JF_PASS_THROUGH,      /* represented by field pass_through */
<span class="lineNum">      63 </span>            :   IPA_JF_ANCESTOR           /* represented by field ancestor */
<span class="lineNum">      64 </span>            : };
<span class="lineNum">      65 </span>            : 
<span class="lineNum">      66 </span>            : struct ipa_cst_ref_desc;
<span class="lineNum">      67 </span>            : 
<span class="lineNum">      68 </span>            : /* Structure holding data required to describe a constant jump function.  */
<span class="lineNum">      69 </span>            : struct GTY(()) ipa_constant_data
<span class="lineNum">      70 </span>            : {
<span class="lineNum">      71 </span>            :   /* THe value of the constant.  */
<span class="lineNum">      72 </span>            :   tree value;
<span class="lineNum">      73 </span>            :   /* Pointer to the structure that describes the reference.  */
<span class="lineNum">      74 </span>            :   struct ipa_cst_ref_desc GTY((skip)) *rdesc;
<span class="lineNum">      75 </span>            : };
<span class="lineNum">      76 </span>            : 
<span class="lineNum">      77 </span>            : /* Structure holding data required to describe a pass-through jump function.  */
<span class="lineNum">      78 </span>            : 
<span class="lineNum">      79 </span>            : struct GTY(()) ipa_pass_through_data
<span class="lineNum">      80 </span>            : {
<span class="lineNum">      81 </span>            :   /* If an operation is to be performed on the original parameter, this is the
<span class="lineNum">      82 </span>            :      second (constant) operand.  */
<span class="lineNum">      83 </span>            :   tree operand;
<span class="lineNum">      84 </span>            :   /* Number of the caller's formal parameter being passed.  */
<span class="lineNum">      85 </span>            :   int formal_id;
<span class="lineNum">      86 </span>            :   /* Operation that is performed on the argument before it is passed on.
<span class="lineNum">      87 </span>            :      NOP_EXPR means no operation.  Otherwise oper must be a simple binary
<span class="lineNum">      88 </span>            :      arithmetic operation where the caller's parameter is the first operand and
<span class="lineNum">      89 </span>            :      operand field from this structure is the second one.  */
<span class="lineNum">      90 </span>            :   enum tree_code operation;
<span class="lineNum">      91 </span>            :   /* When the passed value is a pointer, it is set to true only when we are
<span class="lineNum">      92 </span>            :      certain that no write to the object it points to has occurred since the
<span class="lineNum">      93 </span>            :      caller functions started execution, except for changes noted in the
<span class="lineNum">      94 </span>            :      aggregate part of the jump function (see description of
<span class="lineNum">      95 </span>            :      ipa_agg_jump_function).  The flag is used only when the operation is
<span class="lineNum">      96 </span>            :      NOP_EXPR.  */
<span class="lineNum">      97 </span>            :   unsigned agg_preserved : 1;
<span class="lineNum">      98 </span>            : };
<span class="lineNum">      99 </span>            : 
<span class="lineNum">     100 </span>            : /* Structure holding data required to describe an ancestor pass-through
<span class="lineNum">     101 </span>            :    jump function.  */
<span class="lineNum">     102 </span>            : 
<span class="lineNum">     103 </span>            : struct GTY(()) ipa_ancestor_jf_data
<span class="lineNum">     104 </span>            : {
<span class="lineNum">     105 </span>            :   /* Offset of the field representing the ancestor.  */
<span class="lineNum">     106 </span>            :   HOST_WIDE_INT offset;
<span class="lineNum">     107 </span>            :   /* Number of the caller's formal parameter being passed.  */
<span class="lineNum">     108 </span>            :   int formal_id;
<span class="lineNum">     109 </span>            :   /* Flag with the same meaning like agg_preserve in ipa_pass_through_data.  */
<span class="lineNum">     110 </span>            :   unsigned agg_preserved : 1;
<span class="lineNum">     111 </span>            : };
<span class="lineNum">     112 </span>            : 
<span class="lineNum">     113 </span>            : /* An element in an aggegate part of a jump function describing a known value
<span class="lineNum">     114 </span>            :    at a given offset.  When it is part of a pass-through jump function with
<span class="lineNum">     115 </span>            :    agg_preserved set or an ancestor jump function with agg_preserved set, all
<span class="lineNum">     116 </span>            :    unlisted positions are assumed to be preserved but the value can be a type
<span class="lineNum">     117 </span>            :    node, which means that the particular piece (starting at offset and having
<span class="lineNum">     118 </span>            :    the size of the type) is clobbered with an unknown value.  When
<span class="lineNum">     119 </span>            :    agg_preserved is false or the type of the containing jump function is
<span class="lineNum">     120 </span>            :    different, all unlisted parts are assumed to be unknown and all values must
<span class="lineNum">     121 </span>            :    fulfill is_gimple_ip_invariant.  */
<span class="lineNum">     122 </span>            : 
<span class="lineNum">     123 </span>            : struct GTY(()) ipa_agg_jf_item
<span class="lineNum">     124 </span>            : {
<span class="lineNum">     125 </span>            :   /* The offset at which the known value is located within the aggregate.  */
<span class="lineNum">     126 </span>            :   HOST_WIDE_INT offset;
<span class="lineNum">     127 </span>            : 
<span class="lineNum">     128 </span>            :   /* The known constant or type if this is a clobber.  */
<span class="lineNum">     129 </span>            :   tree value;
<span class="lineNum">     130 </span>            : };
<span class="lineNum">     131 </span>            : 
<span class="lineNum">     132 </span>            : 
<span class="lineNum">     133 </span>            : /* Aggregate jump function - i.e. description of contents of aggregates passed
<span class="lineNum">     134 </span>            :    either by reference or value.  */
<span class="lineNum">     135 </span>            : 
<span class="lineNum">     136 </span>            : struct GTY(()) ipa_agg_jump_function
<span class="lineNum">     137 </span>            : {
<span class="lineNum">     138 </span>            :   /* Description of the individual items.  */
<span class="lineNum">     139 </span>            :   vec&lt;ipa_agg_jf_item, va_gc&gt; *items;
<span class="lineNum">     140 </span>            :   /* True if the data was passed by reference (as opposed to by value). */
<span class="lineNum">     141 </span>            :   bool by_ref;
<span class="lineNum">     142 </span>            : };
<span class="lineNum">     143 </span>            : 
<span class="lineNum">     144 </span>            : typedef struct ipa_agg_jump_function *ipa_agg_jump_function_p;
<span class="lineNum">     145 </span>            : 
<span class="lineNum">     146 </span>            : /* Information about zero/non-zero bits.  */
<span class="lineNum">     147 </span><span class="lineCov">    5473884 : struct GTY(()) ipa_bits</span>
<span class="lineNum">     148 </span>            : {
<span class="lineNum">     149 </span>            :   /* The propagated value.  */
<span class="lineNum">     150 </span>            :   widest_int value;
<span class="lineNum">     151 </span>            :   /* Mask corresponding to the value.
<span class="lineNum">     152 </span>            :      Similar to ccp_lattice_t, if xth bit of mask is 0,
<span class="lineNum">     153 </span>            :      implies xth bit of value is constant.  */
<span class="lineNum">     154 </span>            :   widest_int mask;
<span class="lineNum">     155 </span>            : };
<span class="lineNum">     156 </span>            : 
<span class="lineNum">     157 </span>            : /* Info about value ranges.  */
<span class="lineNum">     158 </span>            : 
<span class="lineNum">     159 </span><span class="lineCov">     302748 : struct GTY(()) ipa_vr</span>
<span class="lineNum">     160 </span>            : {
<span class="lineNum">     161 </span>            :   /* The data fields below are valid only if known is true.  */
<span class="lineNum">     162 </span>            :   bool known;
<span class="lineNum">     163 </span>            :   enum value_range_type type;
<span class="lineNum">     164 </span>            :   wide_int min;
<span class="lineNum">     165 </span>            :   wide_int max;
<span class="lineNum">     166 </span>            : };
<span class="lineNum">     167 </span>            : 
<span class="lineNum">     168 </span>            : /* A jump function for a callsite represents the values passed as actual
<span class="lineNum">     169 </span>            :    arguments of the callsite. See enum jump_func_type for the various
<span class="lineNum">     170 </span>            :    types of jump functions supported.  */
<span class="lineNum">     171 </span>            : struct GTY (()) ipa_jump_func
<span class="lineNum">     172 </span>            : {
<span class="lineNum">     173 </span>            :   /* Aggregate contants description.  See struct ipa_agg_jump_function and its
<span class="lineNum">     174 </span>            :      description.  */
<span class="lineNum">     175 </span>            :   struct ipa_agg_jump_function agg;
<span class="lineNum">     176 </span>            : 
<span class="lineNum">     177 </span>            :   /* Information about zero/non-zero bits.  The pointed to structure is shared
<span class="lineNum">     178 </span>            :      betweed different jump functions.  Use ipa_set_jfunc_bits to set this
<span class="lineNum">     179 </span>            :      field.  */
<span class="lineNum">     180 </span>            :   struct ipa_bits *bits;
<span class="lineNum">     181 </span>            : 
<span class="lineNum">     182 </span>            :   /* Information about value range, containing valid data only when vr_known is
<span class="lineNum">     183 </span>            :      true.  The pointed to structure is shared betweed different jump
<span class="lineNum">     184 </span>            :      functions.  Use ipa_set_jfunc_vr to set this field.  */
<span class="lineNum">     185 </span>            :   struct value_range *m_vr;
<span class="lineNum">     186 </span>            : 
<span class="lineNum">     187 </span>            :   enum jump_func_type type;
<span class="lineNum">     188 </span>            :   /* Represents a value of a jump function.  pass_through is used only in jump
<span class="lineNum">     189 </span>            :      function context.  constant represents the actual constant in constant jump
<span class="lineNum">     190 </span>            :      functions and member_cst holds constant c++ member functions.  */
<span class="lineNum">     191 </span>            :   union jump_func_value
<span class="lineNum">     192 </span>            :   {
<span class="lineNum">     193 </span>            :     struct ipa_constant_data GTY ((tag (&quot;IPA_JF_CONST&quot;))) constant;
<span class="lineNum">     194 </span>            :     struct ipa_pass_through_data GTY ((tag (&quot;IPA_JF_PASS_THROUGH&quot;))) pass_through;
<span class="lineNum">     195 </span>            :     struct ipa_ancestor_jf_data GTY ((tag (&quot;IPA_JF_ANCESTOR&quot;))) ancestor;
<span class="lineNum">     196 </span>            :   } GTY ((desc (&quot;%1.type&quot;))) value;
<span class="lineNum">     197 </span>            : };
<span class="lineNum">     198 </span>            : 
<span class="lineNum">     199 </span>            : 
<span class="lineNum">     200 </span>            : /* Return the constant stored in a constant jump functin JFUNC.  */
<a name="201"><span class="lineNum">     201 </span>            : </a>
<span class="lineNum">     202 </span>            : static inline tree
<span class="lineNum">     203 </span><span class="lineNoCov">          0 : ipa_get_jf_constant (struct ipa_jump_func *jfunc)</span>
<span class="lineNum">     204 </span>            : {
<span class="lineNum">     205 </span><span class="lineCov">         77 :   gcc_checking_assert (jfunc-&gt;type == IPA_JF_CONST);</span>
<span class="lineNum">     206 </span><span class="lineCov">    1659479 :   return jfunc-&gt;value.constant.value;</span>
<span class="lineNum">     207 </span>            : }
<a name="208"><span class="lineNum">     208 </span>            : </a>
<span class="lineNum">     209 </span>            : static inline struct ipa_cst_ref_desc *
<span class="lineNum">     210 </span><span class="lineNoCov">          0 : ipa_get_jf_constant_rdesc (struct ipa_jump_func *jfunc)</span>
<span class="lineNum">     211 </span>            : {
<span class="lineNum">     212 </span><span class="lineCov">     147766 :   gcc_checking_assert (jfunc-&gt;type == IPA_JF_CONST);</span>
<span class="lineNum">     213 </span><span class="lineCov">     147766 :   return jfunc-&gt;value.constant.rdesc;</span>
<span class="lineNum">     214 </span>            : }
<span class="lineNum">     215 </span>            : 
<span class="lineNum">     216 </span>            : /* Return the operand of a pass through jmp function JFUNC.  */
<a name="217"><span class="lineNum">     217 </span>            : </a>
<span class="lineNum">     218 </span>            : static inline tree
<span class="lineNum">     219 </span><span class="lineNoCov">          0 : ipa_get_jf_pass_through_operand (struct ipa_jump_func *jfunc)</span>
<span class="lineNum">     220 </span>            : {
<span class="lineNum">     221 </span><span class="lineCov">        501 :   gcc_checking_assert (jfunc-&gt;type == IPA_JF_PASS_THROUGH);</span>
<span class="lineNum">     222 </span><span class="lineCov">       2641 :   return jfunc-&gt;value.pass_through.operand;</span>
<span class="lineNum">     223 </span>            : }
<span class="lineNum">     224 </span>            : 
<span class="lineNum">     225 </span>            : /* Return the number of the caller's formal parameter that a pass through jump
<span class="lineNum">     226 </span>            :    function JFUNC refers to.  */
<a name="227"><span class="lineNum">     227 </span>            : </a>
<span class="lineNum">     228 </span>            : static inline int
<span class="lineNum">     229 </span><span class="lineNoCov">          0 : ipa_get_jf_pass_through_formal_id (struct ipa_jump_func *jfunc)</span>
<span class="lineNum">     230 </span>            : {
<span class="lineNum">     231 </span><span class="lineCov">     373086 :   gcc_checking_assert (jfunc-&gt;type == IPA_JF_PASS_THROUGH);</span>
<span class="lineNum">     232 </span><span class="lineCov">    3073959 :   return jfunc-&gt;value.pass_through.formal_id;</span>
<span class="lineNum">     233 </span>            : }
<span class="lineNum">     234 </span>            : 
<span class="lineNum">     235 </span>            : /* Return operation of a pass through jump function JFUNC.  */
<a name="236"><span class="lineNum">     236 </span>            : </a>
<span class="lineNum">     237 </span>            : static inline enum tree_code
<span class="lineNum">     238 </span><span class="lineNoCov">          0 : ipa_get_jf_pass_through_operation (struct ipa_jump_func *jfunc)</span>
<span class="lineNum">     239 </span>            : {
<span class="lineNum">     240 </span><span class="lineCov">     140245 :   gcc_checking_assert (jfunc-&gt;type == IPA_JF_PASS_THROUGH);</span>
<span class="lineNum">     241 </span><span class="lineCov">    1746391 :   return jfunc-&gt;value.pass_through.operation;</span>
<span class="lineNum">     242 </span>            : }
<span class="lineNum">     243 </span>            : 
<span class="lineNum">     244 </span>            : /* Return the agg_preserved flag of a pass through jump function JFUNC.  */
<span class="lineNum">     245 </span>            : 
<span class="lineNum">     246 </span>            : static inline bool
<span class="lineNum">     247 </span>            : ipa_get_jf_pass_through_agg_preserved (struct ipa_jump_func *jfunc)
<span class="lineNum">     248 </span>            : {
<span class="lineNum">     249 </span><span class="lineCov">      80732 :   gcc_checking_assert (jfunc-&gt;type == IPA_JF_PASS_THROUGH);</span>
<span class="lineNum">     250 </span><span class="lineCov">     548195 :   return jfunc-&gt;value.pass_through.agg_preserved;</span>
<span class="lineNum">     251 </span>            : }
<span class="lineNum">     252 </span>            : 
<span class="lineNum">     253 </span>            : /* Return true if pass through jump function JFUNC preserves type
<span class="lineNum">     254 </span>            :    information.  */
<span class="lineNum">     255 </span>            : 
<span class="lineNum">     256 </span>            : static inline bool
<span class="lineNum">     257 </span>            : ipa_get_jf_pass_through_type_preserved (struct ipa_jump_func *jfunc)
<span class="lineNum">     258 </span>            : {
<span class="lineNum">     259 </span><span class="lineCov">    1258730 :   gcc_checking_assert (jfunc-&gt;type == IPA_JF_PASS_THROUGH);</span>
<span class="lineNum">     260 </span><span class="lineCov">    1258730 :   return jfunc-&gt;value.pass_through.agg_preserved;</span>
<span class="lineNum">     261 </span>            : }
<span class="lineNum">     262 </span>            : 
<span class="lineNum">     263 </span>            : /* Return the offset of an ancestor jump function JFUNC.  */
<a name="264"><span class="lineNum">     264 </span>            : </a>
<span class="lineNum">     265 </span>            : static inline HOST_WIDE_INT
<span class="lineNum">     266 </span><span class="lineNoCov">          0 : ipa_get_jf_ancestor_offset (struct ipa_jump_func *jfunc)</span>
<span class="lineNum">     267 </span>            : {
<span class="lineNum">     268 </span><span class="lineCov">      19477 :   gcc_checking_assert (jfunc-&gt;type == IPA_JF_ANCESTOR);</span>
<span class="lineNum">     269 </span><span class="lineCov">      29848 :   return jfunc-&gt;value.ancestor.offset;</span>
<span class="lineNum">     270 </span>            : }
<span class="lineNum">     271 </span>            : 
<span class="lineNum">     272 </span>            : /* Return the number of the caller's formal parameter that an ancestor jump
<span class="lineNum">     273 </span>            :    function JFUNC refers to.  */
<a name="274"><span class="lineNum">     274 </span>            : </a>
<span class="lineNum">     275 </span>            : static inline int
<span class="lineNum">     276 </span><span class="lineNoCov">          0 : ipa_get_jf_ancestor_formal_id (struct ipa_jump_func *jfunc)</span>
<span class="lineNum">     277 </span>            : {
<span class="lineNum">     278 </span><span class="lineCov">      50573 :   gcc_checking_assert (jfunc-&gt;type == IPA_JF_ANCESTOR);</span>
<span class="lineNum">     279 </span><span class="lineCov">     610522 :   return jfunc-&gt;value.ancestor.formal_id;</span>
<span class="lineNum">     280 </span>            : }
<span class="lineNum">     281 </span>            : 
<span class="lineNum">     282 </span>            : /* Return the agg_preserved flag of an ancestor jump function JFUNC.  */
<a name="283"><span class="lineNum">     283 </span>            : </a>
<span class="lineNum">     284 </span>            : static inline bool
<span class="lineNum">     285 </span><span class="lineNoCov">          0 : ipa_get_jf_ancestor_agg_preserved (struct ipa_jump_func *jfunc)</span>
<span class="lineNum">     286 </span>            : {
<span class="lineNum">     287 </span><span class="lineCov">      69067 :   gcc_checking_assert (jfunc-&gt;type == IPA_JF_ANCESTOR);</span>
<span class="lineNum">     288 </span><span class="lineCov">      90444 :   return jfunc-&gt;value.ancestor.agg_preserved;</span>
<span class="lineNum">     289 </span>            : }
<span class="lineNum">     290 </span>            : 
<span class="lineNum">     291 </span>            : /* Return true if ancestor jump function JFUNC presrves type information.  */
<a name="292"><span class="lineNum">     292 </span>            : </a>
<span class="lineNum">     293 </span>            : static inline bool
<span class="lineNum">     294 </span><span class="lineNoCov">          0 : ipa_get_jf_ancestor_type_preserved (struct ipa_jump_func *jfunc)</span>
<span class="lineNum">     295 </span>            : {
<span class="lineNum">     296 </span><span class="lineCov">      15791 :   gcc_checking_assert (jfunc-&gt;type == IPA_JF_ANCESTOR);</span>
<span class="lineNum">     297 </span><span class="lineCov">     275765 :   return jfunc-&gt;value.ancestor.agg_preserved;</span>
<span class="lineNum">     298 </span>            : }
<span class="lineNum">     299 </span>            : 
<span class="lineNum">     300 </span>            : /* Summary describing a single formal parameter.  */
<span class="lineNum">     301 </span>            : 
<span class="lineNum">     302 </span>            : struct GTY(()) ipa_param_descriptor
<span class="lineNum">     303 </span>            : {
<span class="lineNum">     304 </span>            :   /* In analysis and modification phase, this is the PARAM_DECL of this
<span class="lineNum">     305 </span>            :      parameter, in IPA LTO phase, this is the type of the the described
<span class="lineNum">     306 </span>            :      parameter or NULL if not known.  Do not read this field directly but
<span class="lineNum">     307 </span>            :      through ipa_get_param and ipa_get_type as appropriate.  */
<span class="lineNum">     308 </span>            :   tree decl_or_type;
<span class="lineNum">     309 </span>            :   /* If all uses of the parameter are described by ipa-prop structures, this
<span class="lineNum">     310 </span>            :      says how many there are.  If any use could not be described by means of
<span class="lineNum">     311 </span>            :      ipa-prop structures, this is IPA_UNDESCRIBED_USE.  */
<span class="lineNum">     312 </span>            :   int controlled_uses;
<span class="lineNum">     313 </span>            :   unsigned int move_cost : 31;
<span class="lineNum">     314 </span>            :   /* The parameter is used.  */
<span class="lineNum">     315 </span>            :   unsigned used : 1;
<span class="lineNum">     316 </span>            : };
<span class="lineNum">     317 </span>            : 
<span class="lineNum">     318 </span>            : /* ipa_node_params stores information related to formal parameters of functions
<span class="lineNum">     319 </span>            :    and some other information for interprocedural passes that operate on
<span class="lineNum">     320 </span>            :    parameters (such as ipa-cp).  */
<span class="lineNum">     321 </span>            : 
<span class="lineNum">     322 </span>            : struct GTY((for_user)) ipa_node_params
<span class="lineNum">     323 </span>            : {
<span class="lineNum">     324 </span>            :   /* Default constructor.  */
<span class="lineNum">     325 </span>            :   ipa_node_params ();
<span class="lineNum">     326 </span>            : 
<span class="lineNum">     327 </span>            :   /* Default destructor.  */
<span class="lineNum">     328 </span>            :   ~ipa_node_params ();
<span class="lineNum">     329 </span>            : 
<span class="lineNum">     330 </span>            :   /* Information about individual formal parameters that are gathered when
<span class="lineNum">     331 </span>            :      summaries are generated. */
<span class="lineNum">     332 </span>            :   vec&lt;ipa_param_descriptor, va_gc&gt; *descriptors;
<span class="lineNum">     333 </span>            :   /* Pointer to an array of structures describing individual formal
<span class="lineNum">     334 </span>            :      parameters.  */
<span class="lineNum">     335 </span>            :   struct ipcp_param_lattices * GTY((skip)) lattices;
<span class="lineNum">     336 </span>            :   /* Only for versioned nodes this field would not be NULL,
<span class="lineNum">     337 </span>            :      it points to the node that IPA cp cloned from.  */
<span class="lineNum">     338 </span>            :   struct cgraph_node * GTY((skip)) ipcp_orig_node;
<span class="lineNum">     339 </span>            :   /* If this node is an ipa-cp clone, these are the known constants that
<span class="lineNum">     340 </span>            :      describe what it has been specialized for.  */
<span class="lineNum">     341 </span>            :   vec&lt;tree&gt; GTY((skip)) known_csts;
<span class="lineNum">     342 </span>            :   /* If this node is an ipa-cp clone, these are the known polymorphic contexts
<span class="lineNum">     343 </span>            :      that describe what it has been specialized for.  */
<span class="lineNum">     344 </span>            :   vec&lt;ipa_polymorphic_call_context&gt; GTY((skip)) known_contexts;
<span class="lineNum">     345 </span>            :   /* Whether the param uses analysis and jump function computation has already
<span class="lineNum">     346 </span>            :      been performed.  */
<span class="lineNum">     347 </span>            :   unsigned analysis_done : 1;
<span class="lineNum">     348 </span>            :   /* Whether the function is enqueued in ipa-cp propagation stack.  */
<span class="lineNum">     349 </span>            :   unsigned node_enqueued : 1;
<span class="lineNum">     350 </span>            :   /* Whether we should create a specialized version based on values that are
<span class="lineNum">     351 </span>            :      known to be constant in all contexts.  */
<span class="lineNum">     352 </span>            :   unsigned do_clone_for_all_contexts : 1;
<span class="lineNum">     353 </span>            :   /* Set if this is an IPA-CP clone for all contexts.  */
<span class="lineNum">     354 </span>            :   unsigned is_all_contexts_clone : 1;
<span class="lineNum">     355 </span>            :   /* Node has been completely replaced by clones and will be removed after
<span class="lineNum">     356 </span>            :      ipa-cp is finished.  */
<span class="lineNum">     357 </span>            :   unsigned node_dead : 1;
<span class="lineNum">     358 </span>            :   /* Node is involved in a recursion, potentionally indirect.  */
<span class="lineNum">     359 </span>            :   unsigned node_within_scc : 1;
<span class="lineNum">     360 </span>            :   /* Node is calling a private function called only once.  */
<span class="lineNum">     361 </span>            :   unsigned node_calling_single_call : 1;
<span class="lineNum">     362 </span>            :   /* False when there is something makes versioning impossible.  */
<span class="lineNum">     363 </span>            :   unsigned versionable : 1;
<span class="lineNum">     364 </span>            : };
<span class="lineNum">     365 </span>            : 
<span class="lineNum">     366 </span>            : inline
<span class="lineNum">     367 </span><span class="lineNoCov">          0 : ipa_node_params::ipa_node_params ()</span>
<span class="lineNum">     368 </span>            : : descriptors (NULL), lattices (NULL), ipcp_orig_node (NULL),
<span class="lineNum">     369 </span>            :   known_csts (vNULL), known_contexts (vNULL), analysis_done (0),
<span class="lineNum">     370 </span>            :   node_enqueued (0), do_clone_for_all_contexts (0), is_all_contexts_clone (0),
<span class="lineNum">     371 </span>            :   node_dead (0), node_within_scc (0), node_calling_single_call (0),
<span class="lineNum">     372 </span><span class="lineNoCov">          0 :   versionable (0)</span>
<span class="lineNum">     373 </span>            : {
<span class="lineNum">     374 </span>            : }
<a name="375"><span class="lineNum">     375 </span>            : </a>
<span class="lineNum">     376 </span>            : inline
<span class="lineNum">     377 </span><span class="lineCov">    8473422 : ipa_node_params::~ipa_node_params ()</span>
<span class="lineNum">     378 </span>            : {
<span class="lineNum">     379 </span><span class="lineCov">    4236711 :   free (lattices);</span>
<span class="lineNum">     380 </span><span class="lineCov">    4236711 :   known_csts.release ();</span>
<span class="lineNum">     381 </span><span class="lineCov">    4236711 :   known_contexts.release ();</span>
<span class="lineNum">     382 </span><span class="lineCov">    4236711 : }</span>
<span class="lineNum">     383 </span>            : 
<span class="lineNum">     384 </span>            : /* Intermediate information that we get from alias analysis about a particular
<span class="lineNum">     385 </span>            :    parameter in a particular basic_block.  When a parameter or the memory it
<span class="lineNum">     386 </span>            :    references is marked modified, we use that information in all dominated
<span class="lineNum">     387 </span>            :    blocks without consulting alias analysis oracle.  */
<span class="lineNum">     388 </span>            : 
<span class="lineNum">     389 </span>            : struct ipa_param_aa_status
<span class="lineNum">     390 </span>            : {
<span class="lineNum">     391 </span>            :   /* Set when this structure contains meaningful information.  If not, the
<span class="lineNum">     392 </span>            :      structure describing a dominating BB should be used instead.  */
<span class="lineNum">     393 </span>            :   bool valid;
<span class="lineNum">     394 </span>            : 
<span class="lineNum">     395 </span>            :   /* Whether we have seen something which might have modified the data in
<span class="lineNum">     396 </span>            :      question.  PARM is for the parameter itself, REF is for data it points to
<span class="lineNum">     397 </span>            :      but using the alias type of individual accesses and PT is the same thing
<span class="lineNum">     398 </span>            :      but for computing aggregate pass-through functions using a very inclusive
<span class="lineNum">     399 </span>            :      ao_ref.  */
<span class="lineNum">     400 </span>            :   bool parm_modified, ref_modified, pt_modified;
<span class="lineNum">     401 </span>            : };
<span class="lineNum">     402 </span>            : 
<span class="lineNum">     403 </span>            : /* Information related to a given BB that used only when looking at function
<span class="lineNum">     404 </span>            :    body.  */
<span class="lineNum">     405 </span>            : 
<span class="lineNum">     406 </span>            : struct ipa_bb_info
<span class="lineNum">     407 </span>            : {
<span class="lineNum">     408 </span>            :   /* Call graph edges going out of this BB.  */
<span class="lineNum">     409 </span>            :   vec&lt;cgraph_edge *&gt; cg_edges;
<span class="lineNum">     410 </span>            :   /* Alias analysis statuses of each formal parameter at this bb.  */
<span class="lineNum">     411 </span>            :   vec&lt;ipa_param_aa_status&gt; param_aa_statuses;
<span class="lineNum">     412 </span>            : };
<span class="lineNum">     413 </span>            : 
<span class="lineNum">     414 </span>            : /* Structure with global information that is only used when looking at function
<span class="lineNum">     415 </span>            :    body. */
<span class="lineNum">     416 </span>            : 
<span class="lineNum">     417 </span>            : struct ipa_func_body_info
<span class="lineNum">     418 </span>            : {
<span class="lineNum">     419 </span>            :   /* The node that is being analyzed.  */
<span class="lineNum">     420 </span>            :   cgraph_node *node;
<span class="lineNum">     421 </span>            : 
<span class="lineNum">     422 </span>            :   /* Its info.  */
<span class="lineNum">     423 </span>            :   struct ipa_node_params *info;
<span class="lineNum">     424 </span>            : 
<span class="lineNum">     425 </span>            :   /* Information about individual BBs. */
<span class="lineNum">     426 </span>            :   vec&lt;ipa_bb_info&gt; bb_infos;
<span class="lineNum">     427 </span>            : 
<span class="lineNum">     428 </span>            :   /* Number of parameters.  */
<span class="lineNum">     429 </span>            :   int param_count;
<span class="lineNum">     430 </span>            : 
<span class="lineNum">     431 </span>            :   /* Number of statements already walked by when analyzing this function.  */
<span class="lineNum">     432 </span>            :   unsigned int aa_walked;
<span class="lineNum">     433 </span>            : };
<span class="lineNum">     434 </span>            : 
<span class="lineNum">     435 </span>            : /* ipa_node_params access functions.  Please use these to access fields that
<span class="lineNum">     436 </span>            :    are or will be shared among various passes.  */
<span class="lineNum">     437 </span>            : 
<span class="lineNum">     438 </span>            : /* Return the number of formal parameters. */
<a name="439"><span class="lineNum">     439 </span>            : </a>
<span class="lineNum">     440 </span>            : static inline int
<span class="lineNum">     441 </span><span class="lineNoCov">          0 : ipa_get_param_count (struct ipa_node_params *info)</span>
<span class="lineNum">     442 </span>            : {
<span class="lineNum">     443 </span><span class="lineCov">   80948188 :   return vec_safe_length (info-&gt;descriptors);</span>
<span class="lineNum">     444 </span>            : }
<span class="lineNum">     445 </span>            : 
<span class="lineNum">     446 </span>            : /* Return the declaration of Ith formal parameter of the function corresponding
<span class="lineNum">     447 </span>            :    to INFO.  Note there is no setter function as this array is built just once
<span class="lineNum">     448 </span>            :    using ipa_initialize_node_params.  This function should not be called in
<span class="lineNum">     449 </span>            :    WPA.  */
<span class="lineNum">     450 </span>            : 
<span class="lineNum">     451 </span>            : static inline tree
<span class="lineNum">     452 </span><span class="lineNoCov">          0 : ipa_get_param (struct ipa_node_params *info, int i)</span>
<span class="lineNum">     453 </span>            : {
<span class="lineNum">     454 </span><span class="lineNoCov">          0 :   gcc_checking_assert (info-&gt;descriptors);</span>
<span class="lineNum">     455 </span><span class="lineNoCov">          0 :   gcc_checking_assert (!flag_wpa);</span>
<span class="lineNum">     456 </span><span class="lineNoCov">          0 :   tree t = (*info-&gt;descriptors)[i].decl_or_type;</span>
<span class="lineNum">     457 </span><span class="lineNoCov">          0 :   gcc_checking_assert (TREE_CODE (t) == PARM_DECL);</span>
<span class="lineNum">     458 </span><span class="lineNoCov">          0 :   return t;</span>
<span class="lineNum">     459 </span>            : }
<span class="lineNum">     460 </span>            : 
<span class="lineNum">     461 </span>            : /* Return the type of Ith formal parameter of the function corresponding
<span class="lineNum">     462 </span>            :    to INFO if it is known or NULL if not.  */
<a name="463"><span class="lineNum">     463 </span>            : </a>
<span class="lineNum">     464 </span>            : static inline tree
<span class="lineNum">     465 </span><span class="lineNoCov">          0 : ipa_get_type (struct ipa_node_params *info, int i)</span>
<span class="lineNum">     466 </span>            : {
<span class="lineNum">     467 </span><span class="lineNoCov">          0 :   if (vec_safe_length (info-&gt;descriptors) &lt;= (unsigned) i)</span>
<span class="lineNum">     468 </span><span class="lineNoCov">          0 :     return NULL;</span>
<span class="lineNum">     469 </span><span class="lineNoCov">          0 :   tree t = (*info-&gt;descriptors)[i].decl_or_type;</span>
<span class="lineNum">     470 </span><span class="lineNoCov">          0 :   if (!t)</span>
<span class="lineNum">     471 </span><span class="lineNoCov">          0 :     return NULL;</span>
<span class="lineNum">     472 </span><span class="lineNoCov">          0 :   if (TYPE_P (t))</span>
<span class="lineNum">     473 </span><span class="lineNoCov">          0 :     return t;</span>
<span class="lineNum">     474 </span><span class="lineNoCov">          0 :   gcc_checking_assert (TREE_CODE (t) == PARM_DECL);</span>
<span class="lineNum">     475 </span><span class="lineNoCov">          0 :   return TREE_TYPE (t);</span>
<span class="lineNum">     476 </span>            : }
<span class="lineNum">     477 </span>            : 
<span class="lineNum">     478 </span>            : /* Return the move cost of Ith formal parameter of the function corresponding
<span class="lineNum">     479 </span>            :    to INFO.  */
<a name="480"><span class="lineNum">     480 </span>            : </a>
<span class="lineNum">     481 </span>            : static inline int
<span class="lineNum">     482 </span><span class="lineNoCov">          0 : ipa_get_param_move_cost (struct ipa_node_params *info, int i)</span>
<span class="lineNum">     483 </span>            : {
<span class="lineNum">     484 </span><span class="lineNoCov">          0 :   gcc_checking_assert (info-&gt;descriptors);</span>
<span class="lineNum">     485 </span><span class="lineNoCov">          0 :   return (*info-&gt;descriptors)[i].move_cost;</span>
<span class="lineNum">     486 </span>            : }
<span class="lineNum">     487 </span>            : 
<span class="lineNum">     488 </span>            : /* Set the used flag corresponding to the Ith formal parameter of the function
<span class="lineNum">     489 </span>            :    associated with INFO to VAL.  */
<span class="lineNum">     490 </span>            : 
<span class="lineNum">     491 </span>            : static inline void
<span class="lineNum">     492 </span><span class="lineCov">    1261389 : ipa_set_param_used (struct ipa_node_params *info, int i, bool val)</span>
<span class="lineNum">     493 </span>            : {
<span class="lineNum">     494 </span><span class="lineCov">    1261389 :   gcc_checking_assert (info-&gt;descriptors);</span>
<span class="lineNum">     495 </span><span class="lineCov">    1261389 :   (*info-&gt;descriptors)[i].used = val;</span>
<span class="lineNum">     496 </span><span class="lineCov">    1261389 : }</span>
<span class="lineNum">     497 </span>            : 
<span class="lineNum">     498 </span>            : /* Return how many uses described by ipa-prop a parameter has or
<span class="lineNum">     499 </span>            :    IPA_UNDESCRIBED_USE if there is a use that is not described by these
<a name="500"><span class="lineNum">     500 </span>            :    structures.  */</a>
<span class="lineNum">     501 </span>            : static inline int
<span class="lineNum">     502 </span><span class="lineNoCov">          0 : ipa_get_controlled_uses (struct ipa_node_params *info, int i)</span>
<span class="lineNum">     503 </span>            : {
<span class="lineNum">     504 </span>            :   /* FIXME: introducing speculation causes out of bounds access here.  */
<span class="lineNum">     505 </span><span class="lineNoCov">          0 :   if (vec_safe_length (info-&gt;descriptors) &gt; (unsigned)i)</span>
<span class="lineNum">     506 </span><span class="lineNoCov">          0 :     return (*info-&gt;descriptors)[i].controlled_uses;</span>
<span class="lineNum">     507 </span>            :   return IPA_UNDESCRIBED_USE;
<span class="lineNum">     508 </span>            : }
<span class="lineNum">     509 </span>            : 
<span class="lineNum">     510 </span>            : /* Set the controlled counter of a given parameter.  */
<a name="511"><span class="lineNum">     511 </span>            : </a>
<span class="lineNum">     512 </span>            : static inline void
<span class="lineNum">     513 </span><span class="lineNoCov">          0 : ipa_set_controlled_uses (struct ipa_node_params *info, int i, int val)</span>
<span class="lineNum">     514 </span>            : {
<span class="lineNum">     515 </span><span class="lineNoCov">          0 :   gcc_checking_assert (info-&gt;descriptors);</span>
<span class="lineNum">     516 </span><span class="lineNoCov">          0 :   (*info-&gt;descriptors)[i].controlled_uses = val;</span>
<span class="lineNum">     517 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     518 </span>            : 
<span class="lineNum">     519 </span>            : /* Return the used flag corresponding to the Ith formal parameter of the
<span class="lineNum">     520 </span>            :    function associated with INFO.  */
<a name="521"><span class="lineNum">     521 </span>            : </a>
<span class="lineNum">     522 </span>            : static inline bool
<span class="lineNum">     523 </span><span class="lineNoCov">          0 : ipa_is_param_used (struct ipa_node_params *info, int i)</span>
<span class="lineNum">     524 </span>            : {
<span class="lineNum">     525 </span><span class="lineNoCov">          0 :   gcc_checking_assert (info-&gt;descriptors);</span>
<span class="lineNum">     526 </span><span class="lineNoCov">          0 :   return (*info-&gt;descriptors)[i].used;</span>
<span class="lineNum">     527 </span>            : }
<span class="lineNum">     528 </span>            : 
<span class="lineNum">     529 </span>            : /* Information about replacements done in aggregates for a given node (each
<span class="lineNum">     530 </span>            :    node has its linked list).  */
<span class="lineNum">     531 </span>            : struct GTY(()) ipa_agg_replacement_value
<span class="lineNum">     532 </span>            : {
<span class="lineNum">     533 </span>            :   /* Next item in the linked list.  */
<span class="lineNum">     534 </span>            :   struct ipa_agg_replacement_value *next;
<span class="lineNum">     535 </span>            :   /* Offset within the aggregate.  */
<span class="lineNum">     536 </span>            :   HOST_WIDE_INT offset;
<span class="lineNum">     537 </span>            :   /* The constant value.  */
<span class="lineNum">     538 </span>            :   tree value;
<span class="lineNum">     539 </span>            :   /* The paramter index.  */
<span class="lineNum">     540 </span>            :   int index;
<span class="lineNum">     541 </span>            :   /* Whether the value was passed by reference.  */
<span class="lineNum">     542 </span>            :   bool by_ref;
<span class="lineNum">     543 </span>            : };
<span class="lineNum">     544 </span>            : 
<span class="lineNum">     545 </span>            : /* Structure holding information for the transformation phase of IPA-CP.  */
<span class="lineNum">     546 </span>            : 
<span class="lineNum">     547 </span>            : struct GTY(()) ipcp_transformation
<span class="lineNum">     548 </span>            : {
<span class="lineNum">     549 </span>            :   /* Linked list of known aggregate values.  */
<span class="lineNum">     550 </span>            :   ipa_agg_replacement_value *agg_values;
<span class="lineNum">     551 </span>            :   /* Known bits information.  */
<span class="lineNum">     552 </span>            :   vec&lt;ipa_bits *, va_gc&gt; *bits;
<span class="lineNum">     553 </span>            :   /* Value range information.  */
<span class="lineNum">     554 </span>            :   vec&lt;ipa_vr, va_gc&gt; *m_vr;
<span class="lineNum">     555 </span>            : };
<span class="lineNum">     556 </span>            : 
<span class="lineNum">     557 </span>            : void ipa_set_node_agg_value_chain (struct cgraph_node *node,
<span class="lineNum">     558 </span>            :                                    struct ipa_agg_replacement_value *aggvals);
<span class="lineNum">     559 </span>            : void ipcp_transformation_initialize (void);
<span class="lineNum">     560 </span>            : 
<span class="lineNum">     561 </span>            : /* ipa_edge_args stores information related to a callsite and particularly its
<span class="lineNum">     562 </span>            :    arguments.  It can be accessed by the IPA_EDGE_REF macro.  */
<span class="lineNum">     563 </span>            : 
<span class="lineNum">     564 </span>            : class GTY((for_user)) ipa_edge_args
<span class="lineNum">     565 </span>            : {
<span class="lineNum">     566 </span>            :  public:
<span class="lineNum">     567 </span>            : 
<span class="lineNum">     568 </span>            :   /* Default constructor.  */
<span class="lineNum">     569 </span><span class="lineNoCov">          0 :   ipa_edge_args () : jump_functions (NULL), polymorphic_call_contexts (NULL)</span>
<span class="lineNum">     570 </span>            :     {}
<span class="lineNum">     571 </span>            : 
<span class="lineNum">     572 </span>            :   /* Destructor.  */
<span class="lineNum">     573 </span><span class="lineCov">    1888848 :   ~ipa_edge_args ()</span>
<span class="lineNum">     574 </span><span class="lineCov">    1888848 :     {</span>
<span class="lineNum">     575 </span><span class="lineCov">    1888848 :       vec_free (jump_functions);</span>
<span class="lineNum">     576 </span><span class="lineCov">    1888848 :       vec_free (polymorphic_call_contexts);</span>
<span class="lineNum">     577 </span><span class="lineCov">    1888848 :     }</span>
<span class="lineNum">     578 </span>            : 
<span class="lineNum">     579 </span>            :   /* Vectors of the callsite's jump function and polymorphic context
<span class="lineNum">     580 </span>            :      information of each parameter.  */
<span class="lineNum">     581 </span>            :   vec&lt;ipa_jump_func, va_gc&gt; *jump_functions;
<span class="lineNum">     582 </span>            :   vec&lt;ipa_polymorphic_call_context, va_gc&gt; *polymorphic_call_contexts;
<span class="lineNum">     583 </span>            : };
<span class="lineNum">     584 </span>            : 
<span class="lineNum">     585 </span>            : /* ipa_edge_args access functions.  Please use these to access fields that
<span class="lineNum">     586 </span>            :    are or will be shared among various passes.  */
<span class="lineNum">     587 </span>            : 
<span class="lineNum">     588 </span>            : /* Return the number of actual arguments. */
<a name="589"><span class="lineNum">     589 </span>            : </a>
<span class="lineNum">     590 </span>            : static inline int
<span class="lineNum">     591 </span><span class="lineNoCov">          0 : ipa_get_cs_argument_count (struct ipa_edge_args *args)</span>
<span class="lineNum">     592 </span>            : {
<span class="lineNum">     593 </span><span class="lineCov">   13945972 :   return vec_safe_length (args-&gt;jump_functions);</span>
<span class="lineNum">     594 </span>            : }
<span class="lineNum">     595 </span>            : 
<span class="lineNum">     596 </span>            : /* Returns a pointer to the jump function for the ith argument.  Please note
<span class="lineNum">     597 </span>            :    there is no setter function as jump functions are all set up in
<span class="lineNum">     598 </span>            :    ipa_compute_jump_functions. */
<a name="599"><span class="lineNum">     599 </span>            : </a>
<span class="lineNum">     600 </span>            : static inline struct ipa_jump_func *
<span class="lineNum">     601 </span><span class="lineNoCov">          0 : ipa_get_ith_jump_func (struct ipa_edge_args *args, int i)</span>
<span class="lineNum">     602 </span>            : {
<span class="lineNum">     603 </span><span class="lineCov">   12638427 :   return &amp;(*args-&gt;jump_functions)[i];</span>
<span class="lineNum">     604 </span>            : }
<span class="lineNum">     605 </span>            : 
<span class="lineNum">     606 </span>            : /* Returns a pointer to the polymorphic call context for the ith argument.
<a name="607"><span class="lineNum">     607 </span>            :    NULL if contexts are not computed.  */</a>
<span class="lineNum">     608 </span>            : static inline struct ipa_polymorphic_call_context *
<span class="lineNum">     609 </span><span class="lineNoCov">          0 : ipa_get_ith_polymorhic_call_context (struct ipa_edge_args *args, int i)</span>
<span class="lineNum">     610 </span>            : {
<span class="lineNum">     611 </span><span class="lineCov">    8303113 :   if (!args-&gt;polymorphic_call_contexts)</span>
<span class="lineNum">     612 </span><span class="lineNoCov">          0 :     return NULL;</span>
<span class="lineNum">     613 </span><span class="lineCov">    2165285 :   return &amp;(*args-&gt;polymorphic_call_contexts)[i];</span>
<span class="lineNum">     614 </span>            : }
<span class="lineNum">     615 </span>            : 
<span class="lineNum">     616 </span>            : /* Function summary for ipa_node_params.  */
<span class="lineNum">     617 </span>            : class GTY((user)) ipa_node_params_t: public function_summary &lt;ipa_node_params *&gt;
<span class="lineNum">     618 </span>            : {
<span class="lineNum">     619 </span>            : public:
<span class="lineNum">     620 </span><span class="lineCov">    3374646 :   ipa_node_params_t (symbol_table *table, bool ggc):</span>
<span class="lineNum">     621 </span><span class="lineCov">    6749292 :     function_summary&lt;ipa_node_params *&gt; (table, ggc) { }</span>
<span class="lineNum">     622 </span>            : 
<span class="lineNum">     623 </span>            :   /* Hook that is called by summary when a node is duplicated.  */
<span class="lineNum">     624 </span>            :   virtual void duplicate (cgraph_node *node,
<span class="lineNum">     625 </span>            :                           cgraph_node *node2,
<span class="lineNum">     626 </span>            :                           ipa_node_params *data,
<span class="lineNum">     627 </span>            :                           ipa_node_params *data2);
<span class="lineNum">     628 </span>            : };
<span class="lineNum">     629 </span>            : 
<span class="lineNum">     630 </span>            : /* Summary to manange ipa_edge_args structures.  */
<span class="lineNum">     631 </span>            : 
<span class="lineNum">     632 </span>            : class GTY((user)) ipa_edge_args_sum_t : public call_summary &lt;ipa_edge_args *&gt;
<span class="lineNum">     633 </span>            : {
<span class="lineNum">     634 </span>            :  public:
<span class="lineNum">     635 </span>            :   ipa_edge_args_sum_t (symbol_table *table, bool ggc)
<span class="lineNum">     636 </span><span class="lineCov">     147381 :     : call_summary&lt;ipa_edge_args *&gt; (table, ggc) { }</span>
<span class="lineNum">     637 </span>            : 
<span class="lineNum">     638 </span>            :   /* Hook that is called by summary when an edge is duplicated.  */
<span class="lineNum">     639 </span>            :   virtual void remove (cgraph_edge *cs, ipa_edge_args *args);
<span class="lineNum">     640 </span>            :   /* Hook that is called by summary when an edge is duplicated.  */
<span class="lineNum">     641 </span>            :   virtual void duplicate (cgraph_edge *src,
<span class="lineNum">     642 </span>            :                           cgraph_edge *dst,
<span class="lineNum">     643 </span>            :                           ipa_edge_args *old_args,
<span class="lineNum">     644 </span>            :                           ipa_edge_args *new_args);
<span class="lineNum">     645 </span>            : };
<span class="lineNum">     646 </span>            : 
<span class="lineNum">     647 </span>            : /* Function summary where the parameter infos are actually stored. */
<span class="lineNum">     648 </span>            : extern GTY(()) ipa_node_params_t * ipa_node_params_sum;
<span class="lineNum">     649 </span>            : /* Call summary to store information about edges such as jump functions.  */
<span class="lineNum">     650 </span>            : extern GTY(()) ipa_edge_args_sum_t *ipa_edge_args_sum;
<span class="lineNum">     651 </span>            : 
<span class="lineNum">     652 </span>            : /* Function summary for IPA-CP transformation.  */
<span class="lineNum">     653 </span>            : class ipcp_transformation_t
<span class="lineNum">     654 </span>            : : public function_summary&lt;ipcp_transformation *&gt;
<span class="lineNum">     655 </span>            : {
<span class="lineNum">     656 </span>            : public:
<span class="lineNum">     657 </span><span class="lineCov">      15573 :   ipcp_transformation_t (symbol_table *table, bool ggc):</span>
<a name="658"><span class="lineNum">     658 </span><span class="lineCov">      31146 :     function_summary&lt;ipcp_transformation *&gt; (table, ggc) {}</span></a>
<span class="lineNum">     659 </span>            : 
<a name="660"><span class="lineNum">     660 </span><span class="lineNoCov">          0 :   ~ipcp_transformation_t () {}</span></a>
<span class="lineNum">     661 </span>            : 
<span class="lineNum">     662 </span><span class="lineCov">      15573 :   static ipcp_transformation_t *create_ggc (symbol_table *symtab)</span>
<span class="lineNum">     663 </span>            :   {
<span class="lineNum">     664 </span><span class="lineCov">      15573 :     ipcp_transformation_t *summary</span>
<span class="lineNum">     665 </span><span class="lineCov">      15573 :       = new (ggc_cleared_alloc &lt;ipcp_transformation_t&gt; ())</span>
<span class="lineNum">     666 </span><span class="lineCov">      31146 :       ipcp_transformation_t (symtab, true);</span>
<span class="lineNum">     667 </span><span class="lineCov">      15573 :     return summary;</span>
<span class="lineNum">     668 </span>            :   }
<span class="lineNum">     669 </span>            : };
<span class="lineNum">     670 </span>            : 
<span class="lineNum">     671 </span>            : /* Function summary where the IPA CP transformations are actually stored.  */
<span class="lineNum">     672 </span>            : extern GTY(()) function_summary &lt;ipcp_transformation *&gt; *ipcp_transformation_sum;
<span class="lineNum">     673 </span>            : 
<span class="lineNum">     674 </span>            : /* Return the associated parameter/argument info corresponding to the given
<span class="lineNum">     675 </span>            :    node/edge.  */
<span class="lineNum">     676 </span>            : #define IPA_NODE_REF(NODE) (ipa_node_params_sum-&gt;get_create (NODE))
<span class="lineNum">     677 </span>            : #define IPA_EDGE_REF(EDGE) (ipa_edge_args_sum-&gt;get_create (EDGE))
<span class="lineNum">     678 </span>            : /* This macro checks validity of index returned by
<span class="lineNum">     679 </span>            :    ipa_get_param_decl_index function.  */
<span class="lineNum">     680 </span>            : #define IS_VALID_JUMP_FUNC_INDEX(I) ((I) != -1)
<span class="lineNum">     681 </span>            : 
<span class="lineNum">     682 </span>            : /* Creating and freeing ipa_node_params and ipa_edge_args.  */
<span class="lineNum">     683 </span>            : void ipa_create_all_node_params (void);
<span class="lineNum">     684 </span>            : void ipa_create_all_edge_args (void);
<span class="lineNum">     685 </span>            : void ipa_check_create_edge_args (void);
<span class="lineNum">     686 </span>            : void ipa_free_all_node_params (void);
<span class="lineNum">     687 </span>            : void ipa_free_all_edge_args (void);
<span class="lineNum">     688 </span>            : void ipa_free_all_structures_after_ipa_cp (void);
<span class="lineNum">     689 </span>            : void ipa_free_all_structures_after_iinln (void);
<span class="lineNum">     690 </span>            : 
<span class="lineNum">     691 </span>            : void ipa_register_cgraph_hooks (void);
<span class="lineNum">     692 </span>            : int count_formal_params (tree fndecl);
<span class="lineNum">     693 </span>            : 
<span class="lineNum">     694 </span>            : /* This function ensures the array of node param infos is big enough to
<span class="lineNum">     695 </span>            :    accommodate a structure for all nodes and reallocates it if not.  */
<a name="696"><span class="lineNum">     696 </span>            : </a>
<span class="lineNum">     697 </span>            : static inline void
<span class="lineNum">     698 </span><span class="lineCov">    5018379 : ipa_check_create_node_params (void)</span>
<span class="lineNum">     699 </span>            : {
<span class="lineNum">     700 </span><span class="lineCov">    5018379 :   if (!ipa_node_params_sum)</span>
<span class="lineNum">     701 </span><span class="lineCov">    3374646 :     ipa_node_params_sum</span>
<span class="lineNum">     702 </span><span class="lineCov">    3374646 :       = (new (ggc_cleared_alloc &lt;ipa_node_params_t&gt; ())</span>
<span class="lineNum">     703 </span><span class="lineCov">    6749292 :          ipa_node_params_t (symtab, true));</span>
<span class="lineNum">     704 </span><span class="lineCov">    5018379 : }</span>
<span class="lineNum">     705 </span>            : 
<span class="lineNum">     706 </span>            : /* Returns true if edge summary contains a record for EDGE.  The main purpose
<span class="lineNum">     707 </span>            :    of this function is that debug dumping function can check info availability
<span class="lineNum">     708 </span>            :    without causing allocations.  */
<a name="709"><span class="lineNum">     709 </span>            : </a>
<span class="lineNum">     710 </span>            : static inline bool
<span class="lineNum">     711 </span><span class="lineCov">        781 : ipa_edge_args_info_available_for_edge_p (struct cgraph_edge *edge)</span>
<span class="lineNum">     712 </span>            : {
<span class="lineNum">     713 </span><span class="lineCov">        781 :   return ipa_edge_args_sum-&gt;exists (edge);</span>
<span class="lineNum">     714 </span>            : }
<a name="715"><span class="lineNum">     715 </span>            : </a>
<span class="lineNum">     716 </span>            : static inline ipcp_transformation *
<span class="lineNum">     717 </span><span class="lineCov">    2306999 : ipcp_get_transformation_summary (cgraph_node *node)</span>
<span class="lineNum">     718 </span>            : {
<span class="lineNum">     719 </span><span class="lineCov">    2306999 :   if (ipcp_transformation_sum == NULL)</span>
<span class="lineNum">     720 </span>            :     return NULL;
<span class="lineNum">     721 </span>            : 
<span class="lineNum">     722 </span><span class="lineCov">    1136277 :   return ipcp_transformation_sum-&gt;get (node);</span>
<span class="lineNum">     723 </span>            : }
<span class="lineNum">     724 </span>            : 
<span class="lineNum">     725 </span>            : /* Return the aggregate replacements for NODE, if there are any.  */
<span class="lineNum">     726 </span>            : 
<span class="lineNum">     727 </span>            : static inline struct ipa_agg_replacement_value *
<span class="lineNum">     728 </span>            : ipa_get_agg_replacements_for_node (cgraph_node *node)
<span class="lineNum">     729 </span>            : {
<span class="lineNum">     730 </span><span class="lineCov">     846321 :   ipcp_transformation *ts = ipcp_get_transformation_summary (node);</span>
<span class="lineNum">     731 </span><span class="lineCov">     846321 :   return ts ? ts-&gt;agg_values : NULL;</span>
<span class="lineNum">     732 </span>            : }
<span class="lineNum">     733 </span>            : 
<span class="lineNum">     734 </span>            : /* Function formal parameters related computations.  */
<span class="lineNum">     735 </span>            : void ipa_initialize_node_params (struct cgraph_node *node);
<span class="lineNum">     736 </span>            : bool ipa_propagate_indirect_call_infos (struct cgraph_edge *cs,
<span class="lineNum">     737 </span>            :                                         vec&lt;cgraph_edge *&gt; *new_edges);
<span class="lineNum">     738 </span>            : 
<span class="lineNum">     739 </span>            : /* Indirect edge and binfo processing.  */
<span class="lineNum">     740 </span>            : tree ipa_get_indirect_edge_target (struct cgraph_edge *ie,
<span class="lineNum">     741 </span>            :                                    vec&lt;tree&gt; ,
<span class="lineNum">     742 </span>            :                                    vec&lt;ipa_polymorphic_call_context&gt;,
<span class="lineNum">     743 </span>            :                                    vec&lt;ipa_agg_jump_function_p&gt;,
<span class="lineNum">     744 </span>            :                                    bool *);
<span class="lineNum">     745 </span>            : struct cgraph_edge *ipa_make_edge_direct_to_target (struct cgraph_edge *, tree,
<span class="lineNum">     746 </span>            :                                                     bool speculative = false);
<span class="lineNum">     747 </span>            : tree ipa_impossible_devirt_target (struct cgraph_edge *, tree);
<span class="lineNum">     748 </span>            : ipa_bits *ipa_get_ipa_bits_for_value (const widest_int &amp;value,
<span class="lineNum">     749 </span>            :                                       const widest_int &amp;mask);
<span class="lineNum">     750 </span>            : 
<span class="lineNum">     751 </span>            : 
<span class="lineNum">     752 </span>            : /* Functions related to both.  */
<span class="lineNum">     753 </span>            : void ipa_analyze_node (struct cgraph_node *);
<span class="lineNum">     754 </span>            : 
<span class="lineNum">     755 </span>            : /* Aggregate jump function related functions.  */
<span class="lineNum">     756 </span>            : tree ipa_find_agg_cst_for_param (struct ipa_agg_jump_function *agg, tree scalar,
<span class="lineNum">     757 </span>            :                                  HOST_WIDE_INT offset, bool by_ref,
<span class="lineNum">     758 </span>            :                                  bool *from_global_constant = NULL);
<span class="lineNum">     759 </span>            : bool ipa_load_from_parm_agg (struct ipa_func_body_info *fbi,
<span class="lineNum">     760 </span>            :                              vec&lt;ipa_param_descriptor, va_gc&gt; *descriptors,
<span class="lineNum">     761 </span>            :                              gimple *stmt, tree op, int *index_p,
<span class="lineNum">     762 </span>            :                              HOST_WIDE_INT *offset_p, HOST_WIDE_INT *size_p,
<span class="lineNum">     763 </span>            :                              bool *by_ref, bool *guaranteed_unmodified = NULL);
<span class="lineNum">     764 </span>            : 
<span class="lineNum">     765 </span>            : /* Debugging interface.  */
<span class="lineNum">     766 </span>            : void ipa_print_node_params (FILE *, struct cgraph_node *node);
<span class="lineNum">     767 </span>            : void ipa_print_all_params (FILE *);
<span class="lineNum">     768 </span>            : void ipa_print_node_jump_functions (FILE *f, struct cgraph_node *node);
<span class="lineNum">     769 </span>            : void ipa_print_all_jump_functions (FILE * f);
<span class="lineNum">     770 </span>            : void ipcp_verify_propagated_values (void);
<span class="lineNum">     771 </span>            : 
<span class="lineNum">     772 </span>            : template &lt;typename value&gt;
<span class="lineNum">     773 </span>            : class ipcp_value;
<span class="lineNum">     774 </span>            : 
<span class="lineNum">     775 </span>            : extern object_allocator&lt;ipcp_value&lt;tree&gt; &gt; ipcp_cst_values_pool;
<span class="lineNum">     776 </span>            : extern object_allocator&lt;ipcp_value&lt;ipa_polymorphic_call_context&gt; &gt;
<span class="lineNum">     777 </span>            :   ipcp_poly_ctx_values_pool;
<span class="lineNum">     778 </span>            : 
<span class="lineNum">     779 </span>            : template &lt;typename valtype&gt;
<span class="lineNum">     780 </span>            : class ipcp_value_source;
<span class="lineNum">     781 </span>            : 
<span class="lineNum">     782 </span>            : extern object_allocator&lt;ipcp_value_source&lt;tree&gt; &gt; ipcp_sources_pool;
<span class="lineNum">     783 </span>            : 
<span class="lineNum">     784 </span>            : class ipcp_agg_lattice;
<span class="lineNum">     785 </span>            : 
<span class="lineNum">     786 </span>            : extern object_allocator&lt;ipcp_agg_lattice&gt; ipcp_agg_lattice_pool;
<span class="lineNum">     787 </span>            : 
<span class="lineNum">     788 </span>            : void ipa_dump_agg_replacement_values (FILE *f,
<span class="lineNum">     789 </span>            :                                       struct ipa_agg_replacement_value *av);
<span class="lineNum">     790 </span>            : void ipa_prop_write_jump_functions (void);
<span class="lineNum">     791 </span>            : void ipa_prop_read_jump_functions (void);
<span class="lineNum">     792 </span>            : void ipcp_write_transformation_summaries (void);
<span class="lineNum">     793 </span>            : void ipcp_read_transformation_summaries (void);
<span class="lineNum">     794 </span>            : int ipa_get_param_decl_index (struct ipa_node_params *, tree);
<span class="lineNum">     795 </span>            : tree ipa_value_from_jfunc (struct ipa_node_params *info,
<span class="lineNum">     796 </span>            :                            struct ipa_jump_func *jfunc, tree type);
<span class="lineNum">     797 </span>            : unsigned int ipcp_transform_function (struct cgraph_node *node);
<span class="lineNum">     798 </span>            : ipa_polymorphic_call_context ipa_context_from_jfunc (ipa_node_params *,
<span class="lineNum">     799 </span>            :                                                      cgraph_edge *,
<span class="lineNum">     800 </span>            :                                                      int,
<span class="lineNum">     801 </span>            :                                                      ipa_jump_func *);
<span class="lineNum">     802 </span>            : void ipa_dump_param (FILE *, struct ipa_node_params *info, int i);
<span class="lineNum">     803 </span>            : void ipa_release_body_info (struct ipa_func_body_info *);
<span class="lineNum">     804 </span>            : tree ipa_get_callee_param_type (struct cgraph_edge *e, int i);
<span class="lineNum">     805 </span>            : 
<span class="lineNum">     806 </span>            : /* From tree-sra.c:  */
<span class="lineNum">     807 </span>            : tree build_ref_for_offset (location_t, tree, poly_int64, bool, tree,
<span class="lineNum">     808 </span>            :                            gimple_stmt_iterator *, bool);
<span class="lineNum">     809 </span>            : 
<span class="lineNum">     810 </span>            : /* In ipa-cp.c  */
<span class="lineNum">     811 </span>            : void ipa_cp_c_finalize (void);
<span class="lineNum">     812 </span>            : 
<span class="lineNum">     813 </span>            : #endif /* IPA_PROP_H */
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.0</a></td></tr>
  </table>
  <br>
<h3>LCOV profile is generated on x86_64 machine using following configure options: configure --disable-bootstrap --enable-coverage=opt --enable-languages=c,c++,fortran,go,jit,lto --enable-host-shared. GCC test suite is run with the built compiler.</h3></body></html>
