<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - gcc.info - gcc/wide-int-range.cc</title>
  <link rel="stylesheet" type="text/css" href="../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../index.html">top level</a> - <a href="index.html">gcc</a> - wide-int-range.cc<span style="font-size: 80%;"> (source / <a href="wide-int-range.cc.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">gcc.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">263</td>
            <td class="headerCovTableEntry">271</td>
            <td class="headerCovTableEntryHi">97.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2018-09-22 10:58:49</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">17</td>
            <td class="headerCovTableEntry">17</td>
            <td class="headerCovTableEntryHi">100.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /* Support routines for range operations on wide ints.</a>
<span class="lineNum">       2 </span>            :    Copyright (C) 2018 Free Software Foundation, Inc.
<span class="lineNum">       3 </span>            : 
<span class="lineNum">       4 </span>            : This file is part of GCC.
<span class="lineNum">       5 </span>            : 
<span class="lineNum">       6 </span>            : GCC is free software; you can redistribute it and/or modify
<span class="lineNum">       7 </span>            : it under the terms of the GNU General Public License as published by
<span class="lineNum">       8 </span>            : the Free Software Foundation; either version 3, or (at your option)
<span class="lineNum">       9 </span>            : any later version.
<span class="lineNum">      10 </span>            : 
<span class="lineNum">      11 </span>            : GCC is distributed in the hope that it will be useful,
<span class="lineNum">      12 </span>            : but WITHOUT ANY WARRANTY; without even the implied warranty of
<span class="lineNum">      13 </span>            : MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
<span class="lineNum">      14 </span>            : GNU General Public License for more details.
<span class="lineNum">      15 </span>            : 
<span class="lineNum">      16 </span>            : You should have received a copy of the GNU General Public License
<span class="lineNum">      17 </span>            : along with GCC; see the file COPYING3.  If not see
<span class="lineNum">      18 </span>            : &lt;http://www.gnu.org/licenses/&gt;.  */
<span class="lineNum">      19 </span>            : 
<span class="lineNum">      20 </span>            : #include &quot;config.h&quot;
<span class="lineNum">      21 </span>            : #include &quot;system.h&quot;
<span class="lineNum">      22 </span>            : #include &quot;coretypes.h&quot;
<span class="lineNum">      23 </span>            : #include &quot;tree.h&quot;
<span class="lineNum">      24 </span>            : #include &quot;function.h&quot;
<span class="lineNum">      25 </span>            : #include &quot;fold-const.h&quot;
<span class="lineNum">      26 </span>            : #include &quot;wide-int-range.h&quot;
<span class="lineNum">      27 </span>            : 
<span class="lineNum">      28 </span>            : /* Wrapper around wide_int_binop that adjusts for overflow.
<span class="lineNum">      29 </span>            : 
<span class="lineNum">      30 </span>            :    Return true if we can compute the result; i.e. if the operation
<span class="lineNum">      31 </span>            :    doesn't overflow or if the overflow is undefined.  In the latter
<span class="lineNum">      32 </span>            :    case (if the operation overflows and overflow is undefined), then
<span class="lineNum">      33 </span>            :    adjust the result to be -INF or +INF depending on CODE, VAL1 and
<span class="lineNum">      34 </span>            :    VAL2.  Return the value in *RES.
<span class="lineNum">      35 </span>            : 
<span class="lineNum">      36 </span>            :    Return false for division by zero, for which the result is
<span class="lineNum">      37 </span>            :    indeterminate.  */
<span class="lineNum">      38 </span>            : 
<span class="lineNum">      39 </span>            : static bool
<span class="lineNum">      40 </span><span class="lineCov">    7433703 : wide_int_binop_overflow (wide_int &amp;res,</span>
<span class="lineNum">      41 </span>            :                          enum tree_code code,
<span class="lineNum">      42 </span>            :                          const wide_int &amp;w0, const wide_int &amp;w1,
<span class="lineNum">      43 </span>            :                          signop sign, bool overflow_undefined)
<span class="lineNum">      44 </span>            : {
<span class="lineNum">      45 </span><span class="lineCov">    7433703 :   wi::overflow_type overflow;</span>
<span class="lineNum">      46 </span><span class="lineCov">    7433703 :   if (!wide_int_binop (res, code, w0, w1, sign, &amp;overflow))</span>
<span class="lineNum">      47 </span>            :     return false;
<span class="lineNum">      48 </span>            : 
<span class="lineNum">      49 </span>            :   /* If the operation overflowed return -INF or +INF depending on the
<span class="lineNum">      50 </span>            :      operation and the combination of signs of the operands.  */
<span class="lineNum">      51 </span><span class="lineCov">    7433703 :   if (overflow &amp;&amp; overflow_undefined)</span>
<span class="lineNum">      52 </span>            :     {
<span class="lineNum">      53 </span><span class="lineCov">    1307506 :       switch (code)</span>
<span class="lineNum">      54 </span>            :         {
<span class="lineNum">      55 </span><span class="lineCov">    1283207 :         case MULT_EXPR:</span>
<span class="lineNum">      56 </span>            :           /* For multiplication, the sign of the overflow is given
<span class="lineNum">      57 </span>            :              by the comparison of the signs of the operands.  */
<span class="lineNum">      58 </span><span class="lineCov">    2996646 :           if (sign == UNSIGNED || w0.sign_mask () == w1.sign_mask ())</span>
<span class="lineNum">      59 </span><span class="lineCov">    1464072 :             res = wi::max_value (w0.get_precision (), sign);</span>
<span class="lineNum">      60 </span>            :           else
<span class="lineNum">      61 </span><span class="lineCov">    1102342 :             res = wi::min_value (w0.get_precision (), sign);</span>
<span class="lineNum">      62 </span><span class="lineCov">    1283207 :           return true;</span>
<span class="lineNum">      63 </span>            : 
<span class="lineNum">      64 </span><span class="lineCov">      24299 :         case TRUNC_DIV_EXPR:</span>
<span class="lineNum">      65 </span><span class="lineCov">      24299 :         case FLOOR_DIV_EXPR:</span>
<span class="lineNum">      66 </span><span class="lineCov">      24299 :         case CEIL_DIV_EXPR:</span>
<span class="lineNum">      67 </span><span class="lineCov">      24299 :         case EXACT_DIV_EXPR:</span>
<span class="lineNum">      68 </span><span class="lineCov">      24299 :         case ROUND_DIV_EXPR:</span>
<span class="lineNum">      69 </span>            :           /* For division, the only case is -INF / -1 = +INF.  */
<span class="lineNum">      70 </span><span class="lineCov">      24299 :           res = wi::max_value (w0.get_precision (), sign);</span>
<span class="lineNum">      71 </span><span class="lineCov">      24299 :           return true;</span>
<span class="lineNum">      72 </span>            : 
<span class="lineNum">      73 </span><span class="lineNoCov">          0 :         default:</span>
<span class="lineNum">      74 </span><span class="lineNoCov">          0 :           gcc_unreachable ();</span>
<span class="lineNum">      75 </span>            :         }
<span class="lineNum">      76 </span>            :     }
<span class="lineNum">      77 </span><span class="lineCov">    6126197 :   return !overflow;</span>
<span class="lineNum">      78 </span>            : }
<span class="lineNum">      79 </span>            : 
<span class="lineNum">      80 </span>            : /* For range [LB, UB] compute two wide_int bit masks.
<span class="lineNum">      81 </span>            : 
<span class="lineNum">      82 </span>            :    In the MAY_BE_NONZERO bit mask, if some bit is unset, it means that
<span class="lineNum">      83 </span>            :    for all numbers in the range the bit is 0, otherwise it might be 0
<span class="lineNum">      84 </span>            :    or 1.
<span class="lineNum">      85 </span>            : 
<span class="lineNum">      86 </span>            :    In the MUST_BE_NONZERO bit mask, if some bit is set, it means that
<span class="lineNum">      87 </span>            :    for all numbers in the range the bit is 1, otherwise it might be 0
<span class="lineNum">      88 </span>            :    or 1.  */
<span class="lineNum">      89 </span>            : 
<span class="lineNum">      90 </span>            : void
<span class="lineNum">      91 </span><span class="lineCov">    7104898 : wide_int_range_set_zero_nonzero_bits (signop sign,</span>
<span class="lineNum">      92 </span>            :                                       const wide_int &amp;lb, const wide_int &amp;ub,
<span class="lineNum">      93 </span>            :                                       wide_int &amp;may_be_nonzero,
<span class="lineNum">      94 </span>            :                                       wide_int &amp;must_be_nonzero)
<span class="lineNum">      95 </span>            : {
<span class="lineNum">      96 </span><span class="lineCov">   20091243 :   may_be_nonzero = wi::minus_one (lb.get_precision ());</span>
<span class="lineNum">      97 </span><span class="lineCov">   21314694 :   must_be_nonzero = wi::zero (lb.get_precision ());</span>
<span class="lineNum">      98 </span>            : 
<span class="lineNum">      99 </span><span class="lineCov">    7104898 :   if (wi::eq_p (lb, ub))</span>
<span class="lineNum">     100 </span>            :     {
<span class="lineNum">     101 </span><span class="lineCov">    1844045 :       may_be_nonzero = lb;</span>
<span class="lineNum">     102 </span><span class="lineCov">    1844045 :       must_be_nonzero = may_be_nonzero;</span>
<span class="lineNum">     103 </span>            :     }
<span class="lineNum">     104 </span><span class="lineCov">    5260853 :   else if (wi::ge_p (lb, 0, sign) || wi::lt_p (ub, 0, sign))</span>
<span class="lineNum">     105 </span>            :     {
<span class="lineNum">     106 </span><span class="lineCov">    4890524 :       wide_int xor_mask = lb ^ ub;</span>
<span class="lineNum">     107 </span><span class="lineCov">    4890524 :       may_be_nonzero = lb | ub;</span>
<span class="lineNum">     108 </span><span class="lineCov">    4890524 :       must_be_nonzero = lb &amp; ub;</span>
<span class="lineNum">     109 </span><span class="lineCov">    4890524 :       if (xor_mask != 0)</span>
<span class="lineNum">     110 </span>            :         {
<span class="lineNum">     111 </span><span class="lineCov">    4890524 :           wide_int mask = wi::mask (wi::floor_log2 (xor_mask), false,</span>
<span class="lineNum">     112 </span><span class="lineCov">    9781048 :                                     may_be_nonzero.get_precision ());</span>
<span class="lineNum">     113 </span><span class="lineCov">    4890524 :           may_be_nonzero = may_be_nonzero | mask;</span>
<span class="lineNum">     114 </span><span class="lineCov">    4890524 :           must_be_nonzero = wi::bit_and_not (must_be_nonzero, mask);</span>
<span class="lineNum">     115 </span>            :         }
<span class="lineNum">     116 </span>            :     }
<span class="lineNum">     117 </span><span class="lineCov">    7104898 : }</span>
<span class="lineNum">     118 </span>            : 
<span class="lineNum">     119 </span>            : /* Order 2 sets of wide int ranges (w0/w1, w2/w3) and set MIN/MAX
<span class="lineNum">     120 </span>            :    accordingly.  */
<a name="121"><span class="lineNum">     121 </span>            : </a>
<span class="lineNum">     122 </span>            : static void
<span class="lineNum">     123 </span><span class="lineCov">    2366852 : wide_int_range_order_set (wide_int &amp;min, wide_int &amp;max,</span>
<span class="lineNum">     124 </span>            :                           wide_int &amp;w0, wide_int &amp;w1,
<span class="lineNum">     125 </span>            :                           wide_int &amp;w2, wide_int &amp;w3,
<span class="lineNum">     126 </span>            :                           signop sign)
<span class="lineNum">     127 </span>            : {
<span class="lineNum">     128 </span>            :   /* Order pairs w0,w1 and w2,w3.  */
<span class="lineNum">     129 </span><span class="lineCov">    2366852 :   if (wi::gt_p (w0, w1, sign))</span>
<span class="lineNum">     130 </span><span class="lineCov">     214152 :     std::swap (w0, w1);</span>
<span class="lineNum">     131 </span><span class="lineCov">    2366852 :   if (wi::gt_p (w2, w3, sign))</span>
<span class="lineNum">     132 </span><span class="lineCov">     218039 :     std::swap (w2, w3);</span>
<span class="lineNum">     133 </span>            : 
<span class="lineNum">     134 </span>            :   /* Choose min and max from the ordered pairs.  */
<span class="lineNum">     135 </span><span class="lineCov">    2366852 :   min = wi::min (w0, w2, sign);</span>
<span class="lineNum">     136 </span><span class="lineCov">    2366852 :   max = wi::max (w1, w3, sign);</span>
<span class="lineNum">     137 </span><span class="lineCov">    2366852 : }</span>
<span class="lineNum">     138 </span>            : 
<span class="lineNum">     139 </span>            : /* Calculate the cross product of two sets of ranges (VR0 and VR1) and
<span class="lineNum">     140 </span>            :    store the result in [RES_LB, RES_UB].
<span class="lineNum">     141 </span>            : 
<span class="lineNum">     142 </span>            :    CODE is the operation to perform with sign SIGN.
<span class="lineNum">     143 </span>            : 
<span class="lineNum">     144 </span>            :    OVERFLOW_UNDEFINED is set if overflow is undefined for the operation type.
<span class="lineNum">     145 </span>            : 
<span class="lineNum">     146 </span>            :    Return TRUE if we were able to calculate the cross product.  */
<span class="lineNum">     147 </span>            : 
<span class="lineNum">     148 </span>            : bool
<span class="lineNum">     149 </span><span class="lineCov">    2367169 : wide_int_range_cross_product (wide_int &amp;res_lb, wide_int &amp;res_ub,</span>
<span class="lineNum">     150 </span>            :                               enum tree_code code, signop sign,
<span class="lineNum">     151 </span>            :                               const wide_int &amp;vr0_lb, const wide_int &amp;vr0_ub,
<span class="lineNum">     152 </span>            :                               const wide_int &amp;vr1_lb, const wide_int &amp;vr1_ub,
<span class="lineNum">     153 </span>            :                               bool overflow_undefined)
<span class="lineNum">     154 </span>            : {
<span class="lineNum">     155 </span><span class="lineCov">    9468676 :   wide_int cp1, cp2, cp3, cp4;</span>
<span class="lineNum">     156 </span>            : 
<span class="lineNum">     157 </span>            :   /* Compute the 4 cross operations, bailing if we get an overflow we
<span class="lineNum">     158 </span>            :      can't handle.  */
<span class="lineNum">     159 </span>            : 
<span class="lineNum">     160 </span><span class="lineCov">    2367169 :   if (!wide_int_binop_overflow (cp1, code, vr0_lb, vr1_lb, sign,</span>
<span class="lineNum">     161 </span>            :                                 overflow_undefined))
<span class="lineNum">     162 </span>            :     return false;
<span class="lineNum">     163 </span>            : 
<span class="lineNum">     164 </span><span class="lineCov">    2367168 :   if (wi::eq_p (vr0_lb, vr0_ub))</span>
<span class="lineNum">     165 </span><span class="lineCov">     132085 :     cp3 = cp1;</span>
<span class="lineNum">     166 </span><span class="lineCov">    2235083 :   else if (!wide_int_binop_overflow (cp3, code, vr0_ub, vr1_lb, sign,</span>
<span class="lineNum">     167 </span>            :                                      overflow_undefined))
<span class="lineNum">     168 </span>            :     return false;
<span class="lineNum">     169 </span>            : 
<span class="lineNum">     170 </span><span class="lineCov">    2367163 :   if (wi::eq_p (vr1_lb, vr1_ub))</span>
<span class="lineNum">     171 </span><span class="lineCov">    1770517 :     cp2 = cp1;</span>
<span class="lineNum">     172 </span><span class="lineCov">     596646 :   else if (!wide_int_binop_overflow (cp2, code, vr0_lb, vr1_ub, sign,</span>
<span class="lineNum">     173 </span>            :                                      overflow_undefined))
<span class="lineNum">     174 </span>            :     return false;
<span class="lineNum">     175 </span>            : 
<span class="lineNum">     176 </span><span class="lineCov">    2366852 :   if (wi::eq_p (vr0_lb, vr0_ub))</span>
<span class="lineNum">     177 </span><span class="lineCov">     132047 :     cp4 = cp2;</span>
<span class="lineNum">     178 </span><span class="lineCov">    2234805 :   else if (!wide_int_binop_overflow (cp4, code, vr0_ub, vr1_ub, sign,</span>
<span class="lineNum">     179 </span>            :                                      overflow_undefined))
<span class="lineNum">     180 </span>            :     return false;
<span class="lineNum">     181 </span>            : 
<span class="lineNum">     182 </span><span class="lineCov">    2366852 :   wide_int_range_order_set (res_lb, res_ub, cp1, cp2, cp3, cp4, sign);</span>
<span class="lineNum">     183 </span><span class="lineCov">    2366852 :   return true;</span>
<span class="lineNum">     184 </span>            : }
<span class="lineNum">     185 </span>            : 
<span class="lineNum">     186 </span>            : /* Multiply two ranges when TYPE_OVERFLOW_WRAPS:
<span class="lineNum">     187 </span>            : 
<span class="lineNum">     188 </span>            :      [RES_LB, RES_UB] = [MIN0, MAX0] * [MIN1, MAX1]
<span class="lineNum">     189 </span>            : 
<span class="lineNum">     190 </span>            :    This is basically fancy code so we don't drop to varying with an
<span class="lineNum">     191 </span>            :    unsigned [-3,-1]*[-3,-1].
<span class="lineNum">     192 </span>            : 
<span class="lineNum">     193 </span>            :    Return TRUE if we were able to perform the operation.  */
<span class="lineNum">     194 </span>            : 
<span class="lineNum">     195 </span>            : bool
<span class="lineNum">     196 </span><span class="lineCov">    2856304 : wide_int_range_mult_wrapping (wide_int &amp;res_lb,</span>
<span class="lineNum">     197 </span>            :                               wide_int &amp;res_ub,
<span class="lineNum">     198 </span>            :                               signop sign,
<span class="lineNum">     199 </span>            :                               unsigned prec,
<span class="lineNum">     200 </span>            :                               const wide_int &amp;min0_,
<span class="lineNum">     201 </span>            :                               const wide_int &amp;max0_,
<span class="lineNum">     202 </span>            :                               const wide_int &amp;min1_,
<span class="lineNum">     203 </span>            :                               const wide_int &amp;max1_)
<span class="lineNum">     204 </span>            : {
<span class="lineNum">     205 </span>            :   /* This test requires 2*prec bits if both operands are signed and
<span class="lineNum">     206 </span>            :      2*prec + 2 bits if either is not.  Therefore, extend the values
<span class="lineNum">     207 </span>            :      using the sign of the result to PREC2.  From here on out,
<span class="lineNum">     208 </span>            :      everthing is just signed math no matter what the input types
<span class="lineNum">     209 </span>            :      were.  */
<span class="lineNum">     210 </span><span class="lineCov">    5712608 :   widest2_int min0 = widest2_int::from (min0_, sign);</span>
<span class="lineNum">     211 </span><span class="lineCov">    5712608 :   widest2_int max0 = widest2_int::from (max0_, sign);</span>
<span class="lineNum">     212 </span><span class="lineCov">    5712608 :   widest2_int min1 = widest2_int::from (min1_, sign);</span>
<span class="lineNum">     213 </span><span class="lineCov">    5712608 :   widest2_int max1 = widest2_int::from (max1_, sign);</span>
<span class="lineNum">     214 </span><span class="lineCov">    2856304 :   widest2_int sizem1 = wi::mask &lt;widest2_int&gt; (prec, false);</span>
<span class="lineNum">     215 </span><span class="lineCov">    2856304 :   widest2_int size = sizem1 + 1;</span>
<span class="lineNum">     216 </span>            : 
<span class="lineNum">     217 </span>            :   /* Canonicalize the intervals.  */
<span class="lineNum">     218 </span><span class="lineCov">    2856304 :   if (sign == UNSIGNED)</span>
<span class="lineNum">     219 </span>            :     {
<span class="lineNum">     220 </span><span class="lineCov">    2769552 :       if (wi::ltu_p (size, min0 + max0))</span>
<span class="lineNum">     221 </span>            :         {
<span class="lineNum">     222 </span><span class="lineCov">     518051 :           min0 -= size;</span>
<span class="lineNum">     223 </span><span class="lineCov">     518051 :           max0 -= size;</span>
<span class="lineNum">     224 </span>            :         }
<span class="lineNum">     225 </span>            : 
<span class="lineNum">     226 </span><span class="lineCov">    2769552 :       if (wi::ltu_p (size, min1 + max1))</span>
<span class="lineNum">     227 </span>            :         {
<span class="lineNum">     228 </span><span class="lineCov">      57710 :           min1 -= size;</span>
<span class="lineNum">     229 </span><span class="lineCov">      57710 :           max1 -= size;</span>
<span class="lineNum">     230 </span>            :         }
<span class="lineNum">     231 </span>            :     }
<span class="lineNum">     232 </span>            : 
<span class="lineNum">     233 </span><span class="lineCov">    2856304 :   widest2_int prod0 = min0 * min1;</span>
<span class="lineNum">     234 </span><span class="lineCov">    2856304 :   widest2_int prod1 = min0 * max1;</span>
<span class="lineNum">     235 </span><span class="lineCov">    2856304 :   widest2_int prod2 = max0 * min1;</span>
<span class="lineNum">     236 </span><span class="lineCov">    2856304 :   widest2_int prod3 = max0 * max1;</span>
<span class="lineNum">     237 </span>            : 
<span class="lineNum">     238 </span>            :   /* Sort the 4 products so that min is in prod0 and max is in
<span class="lineNum">     239 </span>            :      prod3.  */
<span class="lineNum">     240 </span>            :   /* min0min1 &gt; max0max1 */
<span class="lineNum">     241 </span><span class="lineCov">    2856304 :   if (prod0 &gt; prod3)</span>
<span class="lineNum">     242 </span><span class="lineCov">      74759 :     std::swap (prod0, prod3);</span>
<span class="lineNum">     243 </span>            : 
<span class="lineNum">     244 </span>            :   /* min0max1 &gt; max0min1 */
<span class="lineNum">     245 </span><span class="lineCov">    2856304 :   if (prod1 &gt; prod2)</span>
<span class="lineNum">     246 </span><span class="lineCov">      75786 :     std::swap (prod1, prod2);</span>
<span class="lineNum">     247 </span>            : 
<span class="lineNum">     248 </span><span class="lineCov">    2856304 :   if (prod0 &gt; prod1)</span>
<span class="lineNum">     249 </span><span class="lineCov">      35044 :     std::swap (prod0, prod1);</span>
<span class="lineNum">     250 </span>            : 
<span class="lineNum">     251 </span><span class="lineCov">    2856304 :   if (prod2 &gt; prod3)</span>
<span class="lineNum">     252 </span><span class="lineCov">       1833 :     std::swap (prod2, prod3);</span>
<span class="lineNum">     253 </span>            : 
<span class="lineNum">     254 </span>            :   /* diff = max - min.  */
<span class="lineNum">     255 </span><span class="lineCov">    2856304 :   prod2 = prod3 - prod0;</span>
<span class="lineNum">     256 </span><span class="lineCov">    2856304 :   if (wi::geu_p (prod2, sizem1))</span>
<span class="lineNum">     257 </span>            :     /* The range covers all values.  */
<span class="lineNum">     258 </span>            :     return false;
<span class="lineNum">     259 </span>            : 
<span class="lineNum">     260 </span><span class="lineCov">    3222584 :   res_lb = wide_int::from (prod0, prec, sign);</span>
<span class="lineNum">     261 </span><span class="lineCov">    3222584 :   res_ub = wide_int::from (prod3, prec, sign);</span>
<span class="lineNum">     262 </span><span class="lineCov">    1611292 :   return true;</span>
<span class="lineNum">     263 </span>            : }
<span class="lineNum">     264 </span>            : 
<span class="lineNum">     265 </span>            : /* Perform multiplicative operation CODE on two ranges:
<span class="lineNum">     266 </span>            : 
<span class="lineNum">     267 </span>            :      [RES_LB, RES_UB] = [VR0_LB, VR0_UB] .CODE. [VR1_LB, VR1_LB]
<span class="lineNum">     268 </span>            : 
<span class="lineNum">     269 </span>            :    Return TRUE if we were able to perform the operation.
<span class="lineNum">     270 </span>            : 
<span class="lineNum">     271 </span>            :    NOTE: If code is MULT_EXPR and TYPE_OVERFLOW_WRAPS, the resulting
<span class="lineNum">     272 </span>            :    range must be canonicalized by the caller because its components
<span class="lineNum">     273 </span>            :    may be swapped.  */
<a name="274"><span class="lineNum">     274 </span>            : </a>
<span class="lineNum">     275 </span>            : bool
<span class="lineNum">     276 </span><span class="lineCov">    5223473 : wide_int_range_multiplicative_op (wide_int &amp;res_lb, wide_int &amp;res_ub,</span>
<span class="lineNum">     277 </span>            :                                   enum tree_code code,
<span class="lineNum">     278 </span>            :                                   signop sign,
<span class="lineNum">     279 </span>            :                                   unsigned prec,
<span class="lineNum">     280 </span>            :                                   const wide_int &amp;vr0_lb,
<span class="lineNum">     281 </span>            :                                   const wide_int &amp;vr0_ub,
<span class="lineNum">     282 </span>            :                                   const wide_int &amp;vr1_lb,
<span class="lineNum">     283 </span>            :                                   const wide_int &amp;vr1_ub,
<span class="lineNum">     284 </span>            :                                   bool overflow_undefined,
<span class="lineNum">     285 </span>            :                                   bool overflow_wraps)
<span class="lineNum">     286 </span>            : {
<span class="lineNum">     287 </span>            :   /* Multiplications, divisions and shifts are a bit tricky to handle,
<span class="lineNum">     288 </span>            :      depending on the mix of signs we have in the two ranges, we
<span class="lineNum">     289 </span>            :      need to operate on different values to get the minimum and
<span class="lineNum">     290 </span>            :      maximum values for the new range.  One approach is to figure
<span class="lineNum">     291 </span>            :      out all the variations of range combinations and do the
<span class="lineNum">     292 </span>            :      operations.
<span class="lineNum">     293 </span>            : 
<span class="lineNum">     294 </span>            :      However, this involves several calls to compare_values and it
<span class="lineNum">     295 </span>            :      is pretty convoluted.  It's simpler to do the 4 operations
<span class="lineNum">     296 </span>            :      (MIN0 OP MIN1, MIN0 OP MAX1, MAX0 OP MIN1 and MAX0 OP MAX0 OP
<span class="lineNum">     297 </span>            :      MAX1) and then figure the smallest and largest values to form
<span class="lineNum">     298 </span>            :      the new range.  */
<span class="lineNum">     299 </span><span class="lineCov">    5223473 :   if (code == MULT_EXPR &amp;&amp; overflow_wraps)</span>
<span class="lineNum">     300 </span><span class="lineCov">    2856304 :     return wide_int_range_mult_wrapping (res_lb, res_ub,</span>
<span class="lineNum">     301 </span>            :                                          sign, prec,
<span class="lineNum">     302 </span><span class="lineCov">    2856304 :                                          vr0_lb, vr0_ub, vr1_lb, vr1_ub);</span>
<span class="lineNum">     303 </span><span class="lineCov">    2367169 :   return wide_int_range_cross_product (res_lb, res_ub,</span>
<span class="lineNum">     304 </span>            :                                        code, sign,
<span class="lineNum">     305 </span>            :                                        vr0_lb, vr0_ub, vr1_lb, vr1_ub,
<span class="lineNum">     306 </span><span class="lineCov">    2367169 :                                        overflow_undefined);</span>
<span class="lineNum">     307 </span>            : }
<span class="lineNum">     308 </span>            : 
<span class="lineNum">     309 </span>            : /* Perform a left shift operation on two ranges:
<span class="lineNum">     310 </span>            : 
<span class="lineNum">     311 </span>            :      [RES_LB, RES_UB] = [VR0_LB, VR0_UB] &lt;&lt; [VR1_LB, VR1_LB]
<span class="lineNum">     312 </span>            : 
<span class="lineNum">     313 </span>            :    Return TRUE if we were able to perform the operation.
<span class="lineNum">     314 </span>            : 
<span class="lineNum">     315 </span>            :    NOTE: The resulting range must be canonicalized by the caller
<span class="lineNum">     316 </span>            :    because its contents components may be swapped.  */
<span class="lineNum">     317 </span>            : 
<span class="lineNum">     318 </span>            : bool
<span class="lineNum">     319 </span><span class="lineCov">     313892 : wide_int_range_lshift (wide_int &amp;res_lb, wide_int &amp;res_ub,</span>
<span class="lineNum">     320 </span>            :                        signop sign, unsigned prec,
<span class="lineNum">     321 </span>            :                        const wide_int &amp;vr0_lb, const wide_int &amp;vr0_ub,
<span class="lineNum">     322 </span>            :                        const wide_int &amp;vr1_lb, const wide_int &amp;vr1_ub,
<span class="lineNum">     323 </span>            :                        bool overflow_undefined, bool overflow_wraps)
<span class="lineNum">     324 </span>            : {
<span class="lineNum">     325 </span>            :   /* Transform left shifts by constants into multiplies.  */
<span class="lineNum">     326 </span><span class="lineCov">     313892 :   if (wi::eq_p (vr1_lb, vr1_ub))</span>
<span class="lineNum">     327 </span>            :     {
<span class="lineNum">     328 </span><span class="lineCov">     183972 :       unsigned shift = vr1_ub.to_uhwi ();</span>
<span class="lineNum">     329 </span><span class="lineCov">     183972 :       wide_int tmp = wi::set_bit_in_zero (shift, prec);</span>
<span class="lineNum">     330 </span><span class="lineCov">     183972 :       return wide_int_range_multiplicative_op (res_lb, res_ub,</span>
<span class="lineNum">     331 </span>            :                                                MULT_EXPR, sign, prec,
<span class="lineNum">     332 </span>            :                                                vr0_lb, vr0_ub, tmp, tmp,
<span class="lineNum">     333 </span>            :                                                overflow_undefined,
<span class="lineNum">     334 </span>            :                                                /*overflow_wraps=*/true);
<span class="lineNum">     335 </span>            :     }
<span class="lineNum">     336 </span>            : 
<span class="lineNum">     337 </span><span class="lineCov">     129920 :   int overflow_pos = prec;</span>
<span class="lineNum">     338 </span><span class="lineCov">     129920 :   if (sign == SIGNED)</span>
<span class="lineNum">     339 </span><span class="lineCov">      69469 :     overflow_pos -= 1;</span>
<span class="lineNum">     340 </span><span class="lineCov">     129920 :   int bound_shift = overflow_pos - vr1_ub.to_shwi ();</span>
<span class="lineNum">     341 </span>            :   /* If bound_shift == HOST_BITS_PER_WIDE_INT, the llshift can
<span class="lineNum">     342 </span>            :      overflow.  However, for that to happen, vr1.max needs to be
<span class="lineNum">     343 </span>            :      zero, which means vr1 is a singleton range of zero, which
<span class="lineNum">     344 </span>            :      means it should be handled by the previous LSHIFT_EXPR
<span class="lineNum">     345 </span>            :      if-clause.  */
<span class="lineNum">     346 </span><span class="lineCov">     129920 :   wide_int bound = wi::set_bit_in_zero (bound_shift, prec);</span>
<span class="lineNum">     347 </span><span class="lineCov">     129920 :   wide_int complement = ~(bound - 1);</span>
<span class="lineNum">     348 </span><span class="lineCov">     259840 :   wide_int low_bound, high_bound;</span>
<span class="lineNum">     349 </span><span class="lineCov">     129920 :   bool in_bounds = false;</span>
<span class="lineNum">     350 </span><span class="lineCov">     129920 :   if (sign == UNSIGNED)</span>
<span class="lineNum">     351 </span>            :     {
<span class="lineNum">     352 </span><span class="lineCov">      60451 :       low_bound = bound;</span>
<span class="lineNum">     353 </span><span class="lineCov">      60451 :       high_bound = complement;</span>
<span class="lineNum">     354 </span><span class="lineCov">      60451 :       if (wi::ltu_p (vr0_ub, low_bound))</span>
<span class="lineNum">     355 </span>            :         {
<span class="lineNum">     356 </span>            :           /* [5, 6] &lt;&lt; [1, 2] == [10, 24].  */
<span class="lineNum">     357 </span>            :           /* We're shifting out only zeroes, the value increases
<span class="lineNum">     358 </span>            :              monotonically.  */
<span class="lineNum">     359 </span>            :           in_bounds = true;
<span class="lineNum">     360 </span>            :         }
<span class="lineNum">     361 </span><span class="lineCov">      10957 :       else if (wi::ltu_p (high_bound, vr0_lb))</span>
<span class="lineNum">     362 </span>            :         {
<span class="lineNum">     363 </span>            :           /* [0xffffff00, 0xffffffff] &lt;&lt; [1, 2]
<span class="lineNum">     364 </span>            :              == [0xfffffc00, 0xfffffffe].  */
<span class="lineNum">     365 </span>            :           /* We're shifting out only ones, the value decreases
<span class="lineNum">     366 </span>            :              monotonically.  */
<span class="lineNum">     367 </span>            :           in_bounds = true;
<span class="lineNum">     368 </span>            :         }
<span class="lineNum">     369 </span>            :     }
<span class="lineNum">     370 </span>            :   else
<span class="lineNum">     371 </span>            :     {
<span class="lineNum">     372 </span>            :       /* [-1, 1] &lt;&lt; [1, 2] == [-4, 4].  */
<span class="lineNum">     373 </span><span class="lineCov">      69469 :       low_bound = complement;</span>
<span class="lineNum">     374 </span><span class="lineCov">      69469 :       high_bound = bound;</span>
<span class="lineNum">     375 </span><span class="lineCov">      69469 :       if (wi::lts_p (vr0_ub, high_bound)</span>
<span class="lineNum">     376 </span><span class="lineCov">      69469 :           &amp;&amp; wi::lts_p (low_bound, vr0_lb))</span>
<span class="lineNum">     377 </span>            :         {
<span class="lineNum">     378 </span>            :           /* For non-negative numbers, we're shifting out only
<span class="lineNum">     379 </span>            :              zeroes, the value increases monotonically.
<span class="lineNum">     380 </span>            :              For negative numbers, we're shifting out only ones, the
<span class="lineNum">     381 </span>            :              value decreases monotomically.  */
<span class="lineNum">     382 </span>            :           in_bounds = true;
<span class="lineNum">     383 </span>            :         }
<span class="lineNum">     384 </span>            :     }
<span class="lineNum">     385 </span>            :   if (in_bounds)
<span class="lineNum">     386 </span><span class="lineCov">      79085 :     return wide_int_range_multiplicative_op (res_lb, res_ub,</span>
<span class="lineNum">     387 </span>            :                                              LSHIFT_EXPR, sign, prec,
<span class="lineNum">     388 </span>            :                                              vr0_lb, vr0_ub,
<span class="lineNum">     389 </span>            :                                              vr1_lb, vr1_ub,
<span class="lineNum">     390 </span>            :                                              overflow_undefined,
<span class="lineNum">     391 </span><span class="lineCov">      79085 :                                              overflow_wraps);</span>
<span class="lineNum">     392 </span>            :   return false;
<span class="lineNum">     393 </span>            : }
<span class="lineNum">     394 </span>            : 
<span class="lineNum">     395 </span>            : /* Return TRUE if a bit operation on two ranges can be easily
<span class="lineNum">     396 </span>            :    optimized in terms of a mask.
<span class="lineNum">     397 </span>            : 
<span class="lineNum">     398 </span>            :    Basically, for BIT_AND_EXPR or BIT_IOR_EXPR see if we can optimize:
<span class="lineNum">     399 </span>            : 
<span class="lineNum">     400 </span>            :         [LB, UB] op Z
<span class="lineNum">     401 </span>            :    into:
<span class="lineNum">     402 </span>            :         [LB op Z, UB op Z]
<span class="lineNum">     403 </span>            : 
<span class="lineNum">     404 </span>            :    It is up to the caller to perform the actual folding above.  */
<span class="lineNum">     405 </span>            : 
<span class="lineNum">     406 </span>            : static bool
<span class="lineNum">     407 </span><span class="lineCov">    1613931 : wide_int_range_can_optimize_bit_op (tree_code code,</span>
<span class="lineNum">     408 </span>            :                                     const wide_int &amp;lb, const wide_int &amp;ub,
<span class="lineNum">     409 </span>            :                                     const wide_int &amp;mask)
<span class="lineNum">     410 </span>            : 
<span class="lineNum">     411 </span>            : {
<span class="lineNum">     412 </span><span class="lineCov">    1613931 :   if (code != BIT_AND_EXPR &amp;&amp; code != BIT_IOR_EXPR)</span>
<span class="lineNum">     413 </span>            :     return false;
<span class="lineNum">     414 </span>            :   /* If Z is a constant which (for op | its bitwise not) has n
<span class="lineNum">     415 </span>            :      consecutive least significant bits cleared followed by m 1
<span class="lineNum">     416 </span>            :      consecutive bits set immediately above it and either
<span class="lineNum">     417 </span>            :      m + n == precision, or (x &gt;&gt; (m + n)) == (y &gt;&gt; (m + n)).
<span class="lineNum">     418 </span>            : 
<span class="lineNum">     419 </span>            :      The least significant n bits of all the values in the range are
<span class="lineNum">     420 </span>            :      cleared or set, the m bits above it are preserved and any bits
<span class="lineNum">     421 </span>            :      above these are required to be the same for all values in the
<span class="lineNum">     422 </span>            :      range.  */
<span class="lineNum">     423 </span>            : 
<span class="lineNum">     424 </span><span class="lineCov">    1613931 :   wide_int w = mask;</span>
<span class="lineNum">     425 </span><span class="lineCov">    1613931 :   int m = 0, n = 0;</span>
<span class="lineNum">     426 </span><span class="lineCov">    1613931 :   if (code == BIT_IOR_EXPR)</span>
<span class="lineNum">     427 </span><span class="lineCov">     199747 :     w = ~w;</span>
<span class="lineNum">     428 </span><span class="lineCov">    3219772 :   if (wi::eq_p (w, 0))</span>
<span class="lineNum">     429 </span><span class="lineCov">      12050 :     n = w.get_precision ();</span>
<span class="lineNum">     430 </span>            :   else
<span class="lineNum">     431 </span>            :     {
<span class="lineNum">     432 </span><span class="lineCov">    3215812 :       n = wi::ctz (w);</span>
<span class="lineNum">     433 </span><span class="lineCov">    3215812 :       w = ~(w | wi::mask (n, false, w.get_precision ()));</span>
<span class="lineNum">     434 </span><span class="lineCov">    3012779 :       if (wi::eq_p (w, 0))</span>
<span class="lineNum">     435 </span><span class="lineCov">     401996 :         m = w.get_precision () - n;</span>
<span class="lineNum">     436 </span>            :       else
<span class="lineNum">     437 </span><span class="lineCov">    2813816 :         m = wi::ctz (w) - n;</span>
<span class="lineNum">     438 </span>            :     }
<span class="lineNum">     439 </span><span class="lineCov">    3227862 :   wide_int new_mask = wi::mask (m + n, true, w.get_precision ());</span>
<span class="lineNum">     440 </span><span class="lineCov">    1613931 :   if ((new_mask &amp; lb) == (new_mask &amp; ub))</span>
<span class="lineNum">     441 </span><span class="lineCov">     252414 :     return true;</span>
<span class="lineNum">     442 </span>            : 
<span class="lineNum">     443 </span>            :   return false;
<span class="lineNum">     444 </span>            : }
<span class="lineNum">     445 </span>            : 
<span class="lineNum">     446 </span>            : /* Helper function for wide_int_range_optimize_bit_op.
<span class="lineNum">     447 </span>            : 
<span class="lineNum">     448 </span>            :    Calculates bounds and mask for a pair of ranges.  The mask is the
<span class="lineNum">     449 </span>            :    singleton range among the ranges, if any.  The bounds are the
<span class="lineNum">     450 </span>            :    bounds for the remaining range.  */
<a name="451"><span class="lineNum">     451 </span>            : </a>
<span class="lineNum">     452 </span>            : bool
<span class="lineNum">     453 </span><span class="lineCov">    3422697 : wide_int_range_get_mask_and_bounds (wide_int &amp;mask,</span>
<span class="lineNum">     454 </span>            :                                     wide_int &amp;lower_bound,
<span class="lineNum">     455 </span>            :                                     wide_int &amp;upper_bound,
<span class="lineNum">     456 </span>            :                                     const wide_int &amp;vr0_min,
<span class="lineNum">     457 </span>            :                                     const wide_int &amp;vr0_max,
<span class="lineNum">     458 </span>            :                                     const wide_int &amp;vr1_min,
<span class="lineNum">     459 </span>            :                                     const wide_int &amp;vr1_max)
<span class="lineNum">     460 </span>            : {
<span class="lineNum">     461 </span><span class="lineCov">    3422697 :   if (wi::eq_p (vr1_min, vr1_max))</span>
<span class="lineNum">     462 </span>            :     {
<span class="lineNum">     463 </span><span class="lineCov">    1590816 :       mask = vr1_min;</span>
<span class="lineNum">     464 </span><span class="lineCov">    1590816 :       lower_bound = vr0_min;</span>
<span class="lineNum">     465 </span><span class="lineCov">    1590816 :       upper_bound = vr0_max;</span>
<span class="lineNum">     466 </span><span class="lineCov">    1590816 :       return true;</span>
<span class="lineNum">     467 </span>            :     }
<span class="lineNum">     468 </span><span class="lineCov">    1831881 :   else if (wi::eq_p (vr0_min, vr0_max))</span>
<span class="lineNum">     469 </span>            :     {
<span class="lineNum">     470 </span><span class="lineCov">      23115 :       mask = vr0_min;</span>
<span class="lineNum">     471 </span><span class="lineCov">      23115 :       lower_bound = vr1_min;</span>
<span class="lineNum">     472 </span><span class="lineCov">      23115 :       upper_bound = vr1_max;</span>
<span class="lineNum">     473 </span><span class="lineCov">      23115 :       return true;</span>
<span class="lineNum">     474 </span>            :     }
<span class="lineNum">     475 </span>            :   return false;
<span class="lineNum">     476 </span>            : }
<span class="lineNum">     477 </span>            : 
<span class="lineNum">     478 </span>            : /* Optimize a bit operation (BIT_AND_EXPR or BIT_IOR_EXPR) if
<span class="lineNum">     479 </span>            :    possible.  If so, return TRUE and store the result in
<span class="lineNum">     480 </span>            :    [RES_LB, RES_UB].  */
<span class="lineNum">     481 </span>            : 
<span class="lineNum">     482 </span>            : bool
<span class="lineNum">     483 </span><span class="lineCov">    3422697 : wide_int_range_optimize_bit_op (wide_int &amp;res_lb, wide_int &amp;res_ub,</span>
<span class="lineNum">     484 </span>            :                                 enum tree_code code,
<span class="lineNum">     485 </span>            :                                 signop sign,
<span class="lineNum">     486 </span>            :                                 const wide_int &amp;vr0_min,
<span class="lineNum">     487 </span>            :                                 const wide_int &amp;vr0_max,
<span class="lineNum">     488 </span>            :                                 const wide_int &amp;vr1_min,
<span class="lineNum">     489 </span>            :                                 const wide_int &amp;vr1_max)
<span class="lineNum">     490 </span>            : {
<span class="lineNum">     491 </span><span class="lineCov">    3422697 :   gcc_assert (code == BIT_AND_EXPR || code == BIT_IOR_EXPR);</span>
<span class="lineNum">     492 </span>            : 
<span class="lineNum">     493 </span><span class="lineCov">   10268091 :   wide_int lower_bound, upper_bound, mask;</span>
<span class="lineNum">     494 </span><span class="lineCov">    3422697 :   if (!wide_int_range_get_mask_and_bounds (mask, lower_bound, upper_bound,</span>
<span class="lineNum">     495 </span>            :                                            vr0_min, vr0_max, vr1_min, vr1_max))
<span class="lineNum">     496 </span>            :     return false;
<span class="lineNum">     497 </span><span class="lineCov">    1613931 :   if (wide_int_range_can_optimize_bit_op (code,</span>
<span class="lineNum">     498 </span>            :                                           lower_bound, upper_bound, mask))
<span class="lineNum">     499 </span>            :     {
<span class="lineNum">     500 </span><span class="lineCov">     252414 :       wi::overflow_type ovf;</span>
<span class="lineNum">     501 </span><span class="lineCov">     252414 :       wide_int_binop (res_lb, code, lower_bound, mask, sign, &amp;ovf);</span>
<span class="lineNum">     502 </span><span class="lineCov">     252414 :       wide_int_binop (res_ub, code, upper_bound, mask, sign, &amp;ovf);</span>
<span class="lineNum">     503 </span><span class="lineCov">     252414 :       return true;</span>
<span class="lineNum">     504 </span>            :     }
<span class="lineNum">     505 </span>            :   return false;
<span class="lineNum">     506 </span>            : }
<span class="lineNum">     507 </span>            : 
<span class="lineNum">     508 </span>            : /* Calculate the XOR of two ranges and store the result in [WMIN,WMAX].
<span class="lineNum">     509 </span>            :    The two input ranges are described by their MUST_BE_NONZERO and
<span class="lineNum">     510 </span>            :    MAY_BE_NONZERO bit masks.
<span class="lineNum">     511 </span>            : 
<span class="lineNum">     512 </span>            :    Return TRUE if we were able to successfully calculate the new range.  */
<span class="lineNum">     513 </span>            : 
<span class="lineNum">     514 </span>            : bool
<span class="lineNum">     515 </span><span class="lineCov">      79910 : wide_int_range_bit_xor (wide_int &amp;wmin, wide_int &amp;wmax,</span>
<span class="lineNum">     516 </span>            :                         signop sign,
<span class="lineNum">     517 </span>            :                         unsigned prec,
<span class="lineNum">     518 </span>            :                         const wide_int &amp;must_be_nonzero0,
<span class="lineNum">     519 </span>            :                         const wide_int &amp;may_be_nonzero0,
<span class="lineNum">     520 </span>            :                         const wide_int &amp;must_be_nonzero1,
<span class="lineNum">     521 </span>            :                         const wide_int &amp;may_be_nonzero1)
<span class="lineNum">     522 </span>            : {
<span class="lineNum">     523 </span><span class="lineCov">     319640 :   wide_int result_zero_bits = ((must_be_nonzero0 &amp; must_be_nonzero1)</span>
<span class="lineNum">     524 </span><span class="lineCov">      79910 :                                | ~(may_be_nonzero0 | may_be_nonzero1));</span>
<span class="lineNum">     525 </span><span class="lineCov">      79910 :   wide_int result_one_bits</span>
<span class="lineNum">     526 </span><span class="lineCov">      79910 :     = (wi::bit_and_not (must_be_nonzero0, may_be_nonzero1)</span>
<span class="lineNum">     527 </span><span class="lineCov">     159820 :        | wi::bit_and_not (must_be_nonzero1, may_be_nonzero0));</span>
<span class="lineNum">     528 </span><span class="lineCov">      79910 :   wmax = ~result_zero_bits;</span>
<span class="lineNum">     529 </span><span class="lineCov">      79910 :   wmin = result_one_bits;</span>
<span class="lineNum">     530 </span>            :   /* If the range has all positive or all negative values, the result
<span class="lineNum">     531 </span>            :      is better than VARYING.  */
<span class="lineNum">     532 </span><span class="lineCov">      79910 :   if (wi::lt_p (wmin, 0, sign) || wi::ge_p (wmax, 0, sign))</span>
<span class="lineNum">     533 </span><span class="lineCov">      69643 :     return true;</span>
<span class="lineNum">     534 </span><span class="lineCov">      10267 :   wmin = wi::min_value (prec, sign);</span>
<span class="lineNum">     535 </span><span class="lineCov">      10267 :   wmax = wi::max_value (prec, sign);</span>
<span class="lineNum">     536 </span><span class="lineCov">      10267 :   return false;</span>
<span class="lineNum">     537 </span>            : }
<span class="lineNum">     538 </span>            : 
<span class="lineNum">     539 </span>            : /* Calculate the IOR of two ranges and store the result in [WMIN,WMAX].
<span class="lineNum">     540 </span>            :    Return TRUE if we were able to successfully calculate the new range.  */
<span class="lineNum">     541 </span>            : 
<span class="lineNum">     542 </span>            : bool
<span class="lineNum">     543 </span><span class="lineCov">    1494504 : wide_int_range_bit_ior (wide_int &amp;wmin, wide_int &amp;wmax,</span>
<span class="lineNum">     544 </span>            :                         signop sign,
<span class="lineNum">     545 </span>            :                         const wide_int &amp;vr0_min,
<span class="lineNum">     546 </span>            :                         const wide_int &amp;vr0_max,
<span class="lineNum">     547 </span>            :                         const wide_int &amp;vr1_min,
<span class="lineNum">     548 </span>            :                         const wide_int &amp;vr1_max,
<span class="lineNum">     549 </span>            :                         const wide_int &amp;must_be_nonzero0,
<span class="lineNum">     550 </span>            :                         const wide_int &amp;may_be_nonzero0,
<span class="lineNum">     551 </span>            :                         const wide_int &amp;must_be_nonzero1,
<span class="lineNum">     552 </span>            :                         const wide_int &amp;may_be_nonzero1)
<span class="lineNum">     553 </span>            : {
<span class="lineNum">     554 </span><span class="lineCov">    1494504 :   if (wide_int_range_optimize_bit_op (wmin, wmax, BIT_IOR_EXPR, sign,</span>
<span class="lineNum">     555 </span>            :                                       vr0_min, vr0_max,
<span class="lineNum">     556 </span>            :                                       vr1_min, vr1_max))
<span class="lineNum">     557 </span>            :     return true;
<span class="lineNum">     558 </span><span class="lineCov">    1416921 :   wmin = must_be_nonzero0 | must_be_nonzero1;</span>
<span class="lineNum">     559 </span><span class="lineCov">    1416921 :   wmax = may_be_nonzero0 | may_be_nonzero1;</span>
<span class="lineNum">     560 </span>            :   /* If the input ranges contain only positive values we can
<span class="lineNum">     561 </span>            :      truncate the minimum of the result range to the maximum
<span class="lineNum">     562 </span>            :      of the input range minima.  */
<span class="lineNum">     563 </span><span class="lineCov">    1416921 :   if (wi::ge_p (vr0_min, 0, sign)</span>
<span class="lineNum">     564 </span><span class="lineCov">    1416921 :       &amp;&amp; wi::ge_p (vr1_min, 0, sign))</span>
<span class="lineNum">     565 </span>            :     {
<span class="lineNum">     566 </span><span class="lineCov">    1245746 :       wmin = wi::max (wmin, vr0_min, sign);</span>
<span class="lineNum">     567 </span><span class="lineCov">    1245746 :       wmin = wi::max (wmin, vr1_min, sign);</span>
<span class="lineNum">     568 </span>            :     }
<span class="lineNum">     569 </span>            :   /* If either input range contains only negative values
<span class="lineNum">     570 </span>            :      we can truncate the minimum of the result range to the
<span class="lineNum">     571 </span>            :      respective minimum range.  */
<span class="lineNum">     572 </span><span class="lineCov">    1416921 :   if (wi::lt_p (vr0_max, 0, sign))</span>
<span class="lineNum">     573 </span><span class="lineCov">       3438 :     wmin = wi::max (wmin, vr0_min, sign);</span>
<span class="lineNum">     574 </span><span class="lineCov">    1416921 :   if (wi::lt_p (vr1_max, 0, sign))</span>
<span class="lineNum">     575 </span><span class="lineCov">       2935 :     wmin = wi::max (wmin, vr1_min, sign);</span>
<span class="lineNum">     576 </span>            :   /* If the limits got swapped around, indicate error so we can adjust
<span class="lineNum">     577 </span>            :      the range to VARYING.  */
<span class="lineNum">     578 </span><span class="lineCov">    1416921 :   if (wi::gt_p (wmin, wmax,sign))</span>
<span class="lineNum">     579 </span><span class="lineCov">     164844 :     return false;</span>
<span class="lineNum">     580 </span>            :   return true;
<span class="lineNum">     581 </span>            : }
<span class="lineNum">     582 </span>            : 
<span class="lineNum">     583 </span>            : /* Calculate the bitwise AND of two ranges and store the result in [WMIN,WMAX].
<span class="lineNum">     584 </span>            :    Return TRUE if we were able to successfully calculate the new range.  */
<span class="lineNum">     585 </span>            : 
<span class="lineNum">     586 </span>            : bool
<span class="lineNum">     587 </span><span class="lineCov">    1928193 : wide_int_range_bit_and (wide_int &amp;wmin, wide_int &amp;wmax,</span>
<span class="lineNum">     588 </span>            :                         signop sign,
<span class="lineNum">     589 </span>            :                         unsigned prec,
<span class="lineNum">     590 </span>            :                         const wide_int &amp;vr0_min,
<span class="lineNum">     591 </span>            :                         const wide_int &amp;vr0_max,
<span class="lineNum">     592 </span>            :                         const wide_int &amp;vr1_min,
<span class="lineNum">     593 </span>            :                         const wide_int &amp;vr1_max,
<span class="lineNum">     594 </span>            :                         const wide_int &amp;must_be_nonzero0,
<span class="lineNum">     595 </span>            :                         const wide_int &amp;may_be_nonzero0,
<span class="lineNum">     596 </span>            :                         const wide_int &amp;must_be_nonzero1,
<span class="lineNum">     597 </span>            :                         const wide_int &amp;may_be_nonzero1)
<span class="lineNum">     598 </span>            : {
<span class="lineNum">     599 </span><span class="lineCov">    1928193 :   if (wide_int_range_optimize_bit_op (wmin, wmax, BIT_AND_EXPR, sign,</span>
<span class="lineNum">     600 </span>            :                                       vr0_min, vr0_max,
<span class="lineNum">     601 </span>            :                                       vr1_min, vr1_max))
<span class="lineNum">     602 </span>            :     return true;
<span class="lineNum">     603 </span><span class="lineCov">    1753362 :   wmin = must_be_nonzero0 &amp; must_be_nonzero1;</span>
<span class="lineNum">     604 </span><span class="lineCov">    1753362 :   wmax = may_be_nonzero0 &amp; may_be_nonzero1;</span>
<span class="lineNum">     605 </span>            :   /* If both input ranges contain only negative values we can
<span class="lineNum">     606 </span>            :      truncate the result range maximum to the minimum of the
<span class="lineNum">     607 </span>            :      input range maxima.  */
<span class="lineNum">     608 </span><span class="lineCov">    1753362 :   if (wi::lt_p (vr0_max, 0, sign) &amp;&amp; wi::lt_p (vr1_max, 0, sign))</span>
<span class="lineNum">     609 </span>            :     {
<span class="lineNum">     610 </span><span class="lineCov">        717 :       wmax = wi::min (wmax, vr0_max, sign);</span>
<span class="lineNum">     611 </span><span class="lineCov">        717 :       wmax = wi::min (wmax, vr1_max, sign);</span>
<span class="lineNum">     612 </span>            :     }
<span class="lineNum">     613 </span>            :   /* If either input range contains only non-negative values
<span class="lineNum">     614 </span>            :      we can truncate the result range maximum to the respective
<span class="lineNum">     615 </span>            :      maximum of the input range.  */
<span class="lineNum">     616 </span><span class="lineCov">    1753362 :   if (wi::ge_p (vr0_min, 0, sign))</span>
<span class="lineNum">     617 </span><span class="lineCov">    1516820 :     wmax = wi::min (wmax, vr0_max, sign);</span>
<span class="lineNum">     618 </span><span class="lineCov">    1753362 :   if (wi::ge_p (vr1_min, 0, sign))</span>
<span class="lineNum">     619 </span><span class="lineCov">    1712672 :     wmax = wi::min (wmax, vr1_max, sign);</span>
<span class="lineNum">     620 </span>            :   /* PR68217: In case of signed &amp; sign-bit-CST should
<span class="lineNum">     621 </span>            :      result in [-INF, 0] instead of [-INF, INF].  */
<span class="lineNum">     622 </span><span class="lineCov">    1753362 :   if (wi::gt_p (wmin, wmax, sign))</span>
<span class="lineNum">     623 </span>            :     {
<span class="lineNum">     624 </span><span class="lineCov">      34405 :       wide_int sign_bit = wi::set_bit_in_zero (prec - 1, prec);</span>
<span class="lineNum">     625 </span><span class="lineCov">      34405 :       if (sign == SIGNED</span>
<span class="lineNum">     626 </span><span class="lineCov">      34405 :           &amp;&amp; ((wi::eq_p (vr0_min, vr0_max)</span>
<span class="lineNum">     627 </span><span class="lineCov">          4 :                &amp;&amp; !wi::cmps (vr0_min, sign_bit))</span>
<span class="lineNum">     628 </span><span class="lineCov">      34405 :               || (wi::eq_p (vr1_min, vr1_max)</span>
<span class="lineNum">     629 </span><span class="lineCov">      11381 :                   &amp;&amp; !wi::cmps (vr1_min, sign_bit))))</span>
<span class="lineNum">     630 </span>            :         {
<span class="lineNum">     631 </span><span class="lineNoCov">          0 :           wmin = wi::min_value (prec, sign);</span>
<span class="lineNum">     632 </span><span class="lineNoCov">          0 :           wmax = wi::zero (prec);</span>
<span class="lineNum">     633 </span>            :         }
<span class="lineNum">     634 </span>            :     }
<span class="lineNum">     635 </span>            :   /* If the limits got swapped around, indicate error so we can adjust
<span class="lineNum">     636 </span>            :      the range to VARYING.  */
<span class="lineNum">     637 </span><span class="lineCov">    1753362 :   if (wi::gt_p (wmin, wmax,sign))</span>
<span class="lineNum">     638 </span><span class="lineCov">      34405 :     return false;</span>
<span class="lineNum">     639 </span>            :   return true;
<span class="lineNum">     640 </span>            : }
<span class="lineNum">     641 </span>            : 
<span class="lineNum">     642 </span>            : /* Calculate TRUNC_MOD_EXPR on two ranges and store the result in
<span class="lineNum">     643 </span>            :    [WMIN,WMAX].  */
<span class="lineNum">     644 </span>            : 
<span class="lineNum">     645 </span>            : void
<span class="lineNum">     646 </span><span class="lineCov">     272835 : wide_int_range_trunc_mod (wide_int &amp;wmin, wide_int &amp;wmax,</span>
<span class="lineNum">     647 </span>            :                           signop sign,
<span class="lineNum">     648 </span>            :                           unsigned prec,
<span class="lineNum">     649 </span>            :                           const wide_int &amp;vr0_min,
<span class="lineNum">     650 </span>            :                           const wide_int &amp;vr0_max,
<span class="lineNum">     651 </span>            :                           const wide_int &amp;vr1_min,
<span class="lineNum">     652 </span>            :                           const wide_int &amp;vr1_max)
<span class="lineNum">     653 </span>            : {
<span class="lineNum">     654 </span><span class="lineCov">     272835 :   wide_int tmp;</span>
<span class="lineNum">     655 </span>            : 
<span class="lineNum">     656 </span>            :   /* ABS (A % B) &lt; ABS (B) and either
<span class="lineNum">     657 </span>            :      0 &lt;= A % B &lt;= A or A &lt;= A % B &lt;= 0.  */
<span class="lineNum">     658 </span><span class="lineCov">     272835 :   wmax = vr1_max - 1;</span>
<span class="lineNum">     659 </span><span class="lineCov">     272835 :   if (sign == SIGNED)</span>
<span class="lineNum">     660 </span>            :     {
<span class="lineNum">     661 </span><span class="lineCov">     101089 :       tmp = -1 - vr1_min;</span>
<span class="lineNum">     662 </span><span class="lineCov">     101089 :       wmax = wi::smax (wmax, tmp);</span>
<span class="lineNum">     663 </span>            :     }
<span class="lineNum">     664 </span>            : 
<span class="lineNum">     665 </span><span class="lineCov">     272835 :   if (sign == UNSIGNED)</span>
<span class="lineNum">     666 </span><span class="lineCov">     343492 :     wmin = wi::zero (prec);</span>
<span class="lineNum">     667 </span>            :   else
<span class="lineNum">     668 </span>            :     {
<span class="lineNum">     669 </span><span class="lineCov">     101089 :       wmin = -wmax;</span>
<span class="lineNum">     670 </span><span class="lineCov">     101089 :       tmp = vr0_min;</span>
<span class="lineNum">     671 </span><span class="lineCov">     101089 :       if (wi::gts_p (tmp, 0))</span>
<span class="lineNum">     672 </span><span class="lineCov">      26882 :         tmp = wi::zero (prec);</span>
<span class="lineNum">     673 </span><span class="lineCov">     101089 :       wmin = wi::smax (wmin, tmp);</span>
<span class="lineNum">     674 </span>            :     }
<span class="lineNum">     675 </span><span class="lineCov">     272835 :   tmp = vr0_max;</span>
<span class="lineNum">     676 </span><span class="lineCov">     272835 :   if (sign == SIGNED &amp;&amp; wi::neg_p (tmp))</span>
<span class="lineNum">     677 </span><span class="lineCov">       3972 :     tmp = wi::zero (prec);</span>
<span class="lineNum">     678 </span><span class="lineCov">     272835 :   wmax = wi::min (wmax, tmp, sign);</span>
<span class="lineNum">     679 </span><span class="lineCov">     272835 : }</span>
<span class="lineNum">     680 </span>            : 
<span class="lineNum">     681 </span>            : /* Calculate ABS_EXPR on a range and store the result in [MIN, MAX].  */
<span class="lineNum">     682 </span>            : 
<span class="lineNum">     683 </span>            : bool
<span class="lineNum">     684 </span><span class="lineCov">       9810 : wide_int_range_abs (wide_int &amp;min, wide_int &amp;max,</span>
<span class="lineNum">     685 </span>            :                     signop sign, unsigned prec,
<span class="lineNum">     686 </span>            :                     const wide_int &amp;vr0_min, const wide_int &amp;vr0_max,
<span class="lineNum">     687 </span>            :                     bool overflow_undefined)
<span class="lineNum">     688 </span>            : {
<span class="lineNum">     689 </span>            :   /* Pass through VR0 the easy cases.  */
<span class="lineNum">     690 </span><span class="lineCov">       9810 :   if (sign == UNSIGNED || wi::ge_p (vr0_min, 0, sign))</span>
<span class="lineNum">     691 </span>            :     {
<span class="lineNum">     692 </span><span class="lineCov">        382 :       min = vr0_min;</span>
<span class="lineNum">     693 </span><span class="lineCov">        382 :       max = vr0_max;</span>
<span class="lineNum">     694 </span><span class="lineCov">        382 :       return true;</span>
<span class="lineNum">     695 </span>            :     }
<span class="lineNum">     696 </span>            : 
<span class="lineNum">     697 </span>            :   /* -TYPE_MIN_VALUE = TYPE_MIN_VALUE with flag_wrapv so we can't get a
<span class="lineNum">     698 </span>            :      useful range.  */
<span class="lineNum">     699 </span><span class="lineCov">       9428 :   wide_int min_value = wi::min_value (prec, sign);</span>
<span class="lineNum">     700 </span><span class="lineCov">       9428 :   wide_int max_value = wi::max_value (prec, sign);</span>
<span class="lineNum">     701 </span><span class="lineCov">       9428 :   if (!overflow_undefined &amp;&amp; wi::eq_p (vr0_min, min_value))</span>
<span class="lineNum">     702 </span>            :     return false;
<span class="lineNum">     703 </span>            : 
<span class="lineNum">     704 </span>            :   /* ABS_EXPR may flip the range around, if the original range
<span class="lineNum">     705 </span>            :      included negative values.  */
<span class="lineNum">     706 </span><span class="lineCov">       9317 :   if (wi::eq_p (vr0_min, min_value))</span>
<span class="lineNum">     707 </span><span class="lineCov">       6482 :     min = max_value;</span>
<span class="lineNum">     708 </span>            :   else
<span class="lineNum">     709 </span><span class="lineCov">       2835 :     min = wi::abs (vr0_min);</span>
<span class="lineNum">     710 </span><span class="lineCov">       9317 :   if (wi::eq_p (vr0_max, min_value))</span>
<span class="lineNum">     711 </span><span class="lineNoCov">          0 :     max = max_value;</span>
<span class="lineNum">     712 </span>            :   else
<span class="lineNum">     713 </span><span class="lineCov">       9317 :     max = wi::abs (vr0_max);</span>
<span class="lineNum">     714 </span>            : 
<span class="lineNum">     715 </span>            :   /* If the range contains zero then we know that the minimum value in the
<span class="lineNum">     716 </span>            :      range will be zero.  */
<span class="lineNum">     717 </span><span class="lineCov">       9317 :   if (wi::le_p (vr0_min, 0, sign) &amp;&amp; wi::ge_p (vr0_max, 0, sign))</span>
<span class="lineNum">     718 </span>            :     {
<span class="lineNum">     719 </span><span class="lineCov">       9004 :       if (wi::gt_p (min, max, sign))</span>
<span class="lineNum">     720 </span><span class="lineCov">        349 :         max = min;</span>
<span class="lineNum">     721 </span><span class="lineCov">      18008 :       min = wi::zero (prec);</span>
<span class="lineNum">     722 </span>            :     }
<span class="lineNum">     723 </span>            :   else
<span class="lineNum">     724 </span>            :     {
<span class="lineNum">     725 </span>            :       /* If the range was reversed, swap MIN and MAX.  */
<span class="lineNum">     726 </span><span class="lineCov">        313 :       if (wi::gt_p (min, max, sign))</span>
<span class="lineNum">     727 </span><span class="lineCov">        313 :         std::swap (min, max);</span>
<span class="lineNum">     728 </span>            :     }
<span class="lineNum">     729 </span>            : 
<span class="lineNum">     730 </span>            :   /* If the new range has its limits swapped around (MIN &gt; MAX), then
<span class="lineNum">     731 </span>            :      the operation caused one of them to wrap around.  The only thing
<span class="lineNum">     732 </span>            :      we know is that the result is positive.  */
<span class="lineNum">     733 </span><span class="lineCov">       9317 :   if (wi::gt_p (min, max, sign))</span>
<span class="lineNum">     734 </span>            :     {
<span class="lineNum">     735 </span><span class="lineNoCov">          0 :       min = wi::zero (prec);</span>
<span class="lineNum">     736 </span><span class="lineNoCov">          0 :       max = max_value;</span>
<span class="lineNum">     737 </span>            :     }
<span class="lineNum">     738 </span>            :   return true;
<span class="lineNum">     739 </span>            : }
<span class="lineNum">     740 </span>            : 
<span class="lineNum">     741 </span>            : /* Convert range in [VR0_MIN, VR0_MAX] with INNER_SIGN and INNER_PREC,
<span class="lineNum">     742 </span>            :    to a range in [MIN, MAX] with OUTER_SIGN and OUTER_PREC.
<span class="lineNum">     743 </span>            : 
<span class="lineNum">     744 </span>            :    Return TRUE if we were able to successfully calculate the new range.
<span class="lineNum">     745 </span>            : 
<span class="lineNum">     746 </span>            :    Caller is responsible for canonicalizing the resulting range.  */
<span class="lineNum">     747 </span>            : 
<span class="lineNum">     748 </span>            : bool
<span class="lineNum">     749 </span><span class="lineCov">   11154714 : wide_int_range_convert (wide_int &amp;min, wide_int &amp;max,</span>
<span class="lineNum">     750 </span>            :                         signop inner_sign,
<span class="lineNum">     751 </span>            :                         unsigned inner_prec,
<span class="lineNum">     752 </span>            :                         signop outer_sign,
<span class="lineNum">     753 </span>            :                         unsigned outer_prec,
<span class="lineNum">     754 </span>            :                         const wide_int &amp;vr0_min,
<span class="lineNum">     755 </span>            :                         const wide_int &amp;vr0_max)
<span class="lineNum">     756 </span>            : {
<span class="lineNum">     757 </span>            :   /* If the conversion is not truncating we can convert the min and
<span class="lineNum">     758 </span>            :      max values and canonicalize the resulting range.  Otherwise we
<span class="lineNum">     759 </span>            :      can do the conversion if the size of the range is less than what
<span class="lineNum">     760 </span>            :      the precision of the target type can represent.  */
<span class="lineNum">     761 </span><span class="lineCov">   11154714 :   if (outer_prec &gt;= inner_prec</span>
<span class="lineNum">     762 </span><span class="lineCov">   11154714 :       || wi::rshift (wi::sub (vr0_max, vr0_min),</span>
<span class="lineNum">     763 </span><span class="lineCov">    1879001 :                      wi::uhwi (outer_prec, inner_prec),</span>
<span class="lineNum">     764 </span><span class="lineCov">    2207732 :                      inner_sign) == 0)</span>
<span class="lineNum">     765 </span>            :     {
<span class="lineNum">     766 </span><span class="lineCov">   20588334 :       min = wide_int::from (vr0_min, outer_prec, inner_sign);</span>
<span class="lineNum">     767 </span><span class="lineCov">   20588334 :       max = wide_int::from (vr0_max, outer_prec, inner_sign);</span>
<span class="lineNum">     768 </span><span class="lineCov">   10294167 :       return (!wi::eq_p (min, wi::min_value (outer_prec, outer_sign))</span>
<span class="lineNum">     769 </span><span class="lineCov">   11906028 :               || !wi::eq_p (max, wi::max_value (outer_prec, outer_sign)));</span>
<span class="lineNum">     770 </span>            :     }
<span class="lineNum">     771 </span>            :   return false;
<span class="lineNum">     772 </span>            : }
<span class="lineNum">     773 </span>            : 
<span class="lineNum">     774 </span>            : /* Calculate a division operation on two ranges and store the result in
<span class="lineNum">     775 </span>            :    [WMIN, WMAX] U [EXTRA_MIN, EXTRA_MAX].
<span class="lineNum">     776 </span>            : 
<span class="lineNum">     777 </span>            :    If EXTRA_RANGE_P is set upon return, EXTRA_MIN/EXTRA_MAX hold
<span class="lineNum">     778 </span>            :    meaningful information, otherwise they should be ignored.
<span class="lineNum">     779 </span>            : 
<span class="lineNum">     780 </span>            :    Return TRUE if we were able to successfully calculate the new range.  */
<span class="lineNum">     781 </span>            : 
<span class="lineNum">     782 </span>            : bool
<span class="lineNum">     783 </span><span class="lineCov">     543165 : wide_int_range_div (wide_int &amp;wmin, wide_int &amp;wmax,</span>
<span class="lineNum">     784 </span>            :                     tree_code code, signop sign, unsigned prec,
<span class="lineNum">     785 </span>            :                     const wide_int &amp;dividend_min, const wide_int &amp;dividend_max,
<span class="lineNum">     786 </span>            :                     const wide_int &amp;divisor_min, const wide_int &amp;divisor_max,
<span class="lineNum">     787 </span>            :                     bool overflow_undefined,
<span class="lineNum">     788 </span>            :                     bool overflow_wraps,
<span class="lineNum">     789 </span>            :                     bool &amp;extra_range_p,
<span class="lineNum">     790 </span>            :                     wide_int &amp;extra_min, wide_int &amp;extra_max)
<span class="lineNum">     791 </span>            : {
<span class="lineNum">     792 </span><span class="lineCov">     543165 :   extra_range_p = false;</span>
<span class="lineNum">     793 </span>            : 
<span class="lineNum">     794 </span>            :   /* If we know we won't divide by zero, just do the division.  */
<span class="lineNum">     795 </span><span class="lineCov">     543165 :   if (!wide_int_range_includes_zero_p (divisor_min, divisor_max, sign))</span>
<span class="lineNum">     796 </span><span class="lineCov">     445581 :     return wide_int_range_multiplicative_op (wmin, wmax, code, sign, prec,</span>
<span class="lineNum">     797 </span>            :                                              dividend_min, dividend_max,
<span class="lineNum">     798 </span>            :                                              divisor_min, divisor_max,
<span class="lineNum">     799 </span>            :                                              overflow_undefined,
<span class="lineNum">     800 </span><span class="lineCov">     445581 :                                              overflow_wraps);</span>
<span class="lineNum">     801 </span>            : 
<span class="lineNum">     802 </span>            :   /* If flag_non_call_exceptions, we must not eliminate a division
<span class="lineNum">     803 </span>            :      by zero.  */
<span class="lineNum">     804 </span><span class="lineCov">      97584 :   if (cfun-&gt;can_throw_non_call_exceptions)</span>
<span class="lineNum">     805 </span>            :     return false;
<span class="lineNum">     806 </span>            : 
<span class="lineNum">     807 </span>            :   /* If we're definitely dividing by zero, there's nothing to do.  */
<span class="lineNum">     808 </span><span class="lineCov">      96772 :   if (wide_int_range_zero_p (divisor_min, divisor_max, prec))</span>
<span class="lineNum">     809 </span>            :     return false;
<span class="lineNum">     810 </span>            : 
<span class="lineNum">     811 </span>            :   /* Perform the division in 2 parts, [LB, -1] and [1, UB],
<span class="lineNum">     812 </span>            :      which will skip any division by zero.
<span class="lineNum">     813 </span>            : 
<span class="lineNum">     814 </span>            :      First divide by the negative numbers, if any.  */
<span class="lineNum">     815 </span><span class="lineCov">     157049 :   if (wi::neg_p (divisor_min, sign))</span>
<span class="lineNum">     816 </span>            :     {
<span class="lineNum">     817 </span><span class="lineCov">      58565 :       if (!wide_int_range_multiplicative_op (wmin, wmax,</span>
<span class="lineNum">     818 </span>            :                                              code, sign, prec,
<span class="lineNum">     819 </span>            :                                              dividend_min, dividend_max,
<span class="lineNum">     820 </span><span class="lineCov">     144835 :                                              divisor_min, wi::minus_one (prec),</span>
<span class="lineNum">     821 </span>            :                                              overflow_undefined,
<span class="lineNum">     822 </span>            :                                              overflow_wraps))
<span class="lineNum">     823 </span>            :         return false;
<span class="lineNum">     824 </span><span class="lineCov">      58526 :       extra_range_p = true;</span>
<span class="lineNum">     825 </span>            :     }
<span class="lineNum">     826 </span>            :   /* Then divide by the non-zero positive numbers, if any.  */
<span class="lineNum">     827 </span><span class="lineCov">     193466 :   if (wi::gt_p (divisor_max, wi::zero (prec), sign))</span>
<span class="lineNum">     828 </span>            :     {
<span class="lineNum">     829 </span><span class="lineCov">     134773 :       if (!wide_int_range_multiplicative_op (extra_range_p ? extra_min : wmin,</span>
<span class="lineNum">     830 </span><span class="lineCov">      96566 :                                              extra_range_p ? extra_max : wmax,</span>
<span class="lineNum">     831 </span>            :                                              code, sign, prec,
<span class="lineNum">     832 </span>            :                                              dividend_min, dividend_max,
<span class="lineNum">     833 </span><span class="lineCov">     237469 :                                              wi::one (prec), divisor_max,</span>
<span class="lineNum">     834 </span>            :                                              overflow_undefined,
<span class="lineNum">     835 </span>            :                                              overflow_wraps))
<span class="lineNum">     836 </span><span class="lineNoCov">          0 :         return false;</span>
<span class="lineNum">     837 </span>            :     }
<span class="lineNum">     838 </span>            :   else
<span class="lineNum">     839 </span><span class="lineCov">        167 :     extra_range_p = false;</span>
<span class="lineNum">     840 </span>            :   return true;
<span class="lineNum">     841 </span>            : }
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.0</a></td></tr>
  </table>
  <br>
<h3>LCOV profile is generated on x86_64 machine using following configure options: configure --disable-bootstrap --enable-coverage=opt --enable-languages=c,c++,fortran,go,jit,lto --enable-host-shared. GCC test suite is run with the built compiler.</h3></body></html>
