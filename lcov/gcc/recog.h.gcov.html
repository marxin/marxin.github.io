<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - gcc.info - gcc/recog.h</title>
  <link rel="stylesheet" type="text/css" href="../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../index.html">top level</a> - <a href="index.html">gcc</a> - recog.h<span style="font-size: 80%;"> (source / <a href="recog.h.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">gcc.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">22</td>
            <td class="headerCovTableEntry">23</td>
            <td class="headerCovTableEntryHi">95.7 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2018-09-22 10:58:49</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">1</td>
            <td class="headerCovTableEntry">11</td>
            <td class="headerCovTableEntryLo">9.1 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /* Declarations for interface to insn recognizer and insn-output.c.</a>
<span class="lineNum">       2 </span>            :    Copyright (C) 1987-2018 Free Software Foundation, Inc.
<span class="lineNum">       3 </span>            : 
<span class="lineNum">       4 </span>            : This file is part of GCC.
<span class="lineNum">       5 </span>            : 
<span class="lineNum">       6 </span>            : GCC is free software; you can redistribute it and/or modify it under
<span class="lineNum">       7 </span>            : the terms of the GNU General Public License as published by the Free
<span class="lineNum">       8 </span>            : Software Foundation; either version 3, or (at your option) any later
<span class="lineNum">       9 </span>            : version.
<span class="lineNum">      10 </span>            : 
<span class="lineNum">      11 </span>            : GCC is distributed in the hope that it will be useful, but WITHOUT ANY
<span class="lineNum">      12 </span>            : WARRANTY; without even the implied warranty of MERCHANTABILITY or
<span class="lineNum">      13 </span>            : FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
<span class="lineNum">      14 </span>            : for more details.
<span class="lineNum">      15 </span>            : 
<span class="lineNum">      16 </span>            : You should have received a copy of the GNU General Public License
<span class="lineNum">      17 </span>            : along with GCC; see the file COPYING3.  If not see
<span class="lineNum">      18 </span>            : &lt;http://www.gnu.org/licenses/&gt;.  */
<span class="lineNum">      19 </span>            : 
<span class="lineNum">      20 </span>            : #ifndef GCC_RECOG_H
<span class="lineNum">      21 </span>            : #define GCC_RECOG_H
<span class="lineNum">      22 </span>            : 
<span class="lineNum">      23 </span>            : /* Random number that should be large enough for all purposes.  Also define
<span class="lineNum">      24 </span>            :    a type that has at least MAX_RECOG_ALTERNATIVES + 1 bits, with the extra
<span class="lineNum">      25 </span>            :    bit giving an invalid value that can be used to mean &quot;uninitialized&quot;.  */
<span class="lineNum">      26 </span>            : #define MAX_RECOG_ALTERNATIVES 35
<span class="lineNum">      27 </span>            : typedef uint64_t alternative_mask;
<span class="lineNum">      28 </span>            : 
<span class="lineNum">      29 </span>            : /* A mask of all alternatives.  */
<span class="lineNum">      30 </span>            : #define ALL_ALTERNATIVES ((alternative_mask) -1)
<span class="lineNum">      31 </span>            : 
<span class="lineNum">      32 </span>            : /* A mask containing just alternative X.  */
<span class="lineNum">      33 </span>            : #define ALTERNATIVE_BIT(X) ((alternative_mask) 1 &lt;&lt; (X))
<span class="lineNum">      34 </span>            : 
<span class="lineNum">      35 </span>            : /* Types of operands.  */
<span class="lineNum">      36 </span>            : enum op_type {
<span class="lineNum">      37 </span>            :   OP_IN,
<span class="lineNum">      38 </span>            :   OP_OUT,
<span class="lineNum">      39 </span>            :   OP_INOUT
<span class="lineNum">      40 </span>            : };
<span class="lineNum">      41 </span>            : 
<span class="lineNum">      42 </span>            : struct operand_alternative
<span class="lineNum">      43 </span>            : {
<span class="lineNum">      44 </span>            :   /* Pointer to the beginning of the constraint string for this alternative,
<span class="lineNum">      45 </span>            :      for easier access by alternative number.  */
<span class="lineNum">      46 </span>            :   const char *constraint;
<span class="lineNum">      47 </span>            : 
<span class="lineNum">      48 </span>            :   /* The register class valid for this alternative (possibly NO_REGS).  */
<span class="lineNum">      49 </span>            :   ENUM_BITFIELD (reg_class) cl : 16;
<span class="lineNum">      50 </span>            : 
<span class="lineNum">      51 </span>            :   /* &quot;Badness&quot; of this alternative, computed from number of '?' and '!'
<span class="lineNum">      52 </span>            :      characters in the constraint string.  */
<span class="lineNum">      53 </span>            :   unsigned int reject : 16;
<span class="lineNum">      54 </span>            : 
<span class="lineNum">      55 </span>            :   /* -1 if no matching constraint was found, or an operand number.  */
<span class="lineNum">      56 </span>            :   int matches : 8;
<span class="lineNum">      57 </span>            :   /* The same information, but reversed: -1 if this operand is not
<span class="lineNum">      58 </span>            :      matched by any other, or the operand number of the operand that
<span class="lineNum">      59 </span>            :      matches this one.  */
<span class="lineNum">      60 </span>            :   int matched : 8;
<span class="lineNum">      61 </span>            : 
<span class="lineNum">      62 </span>            :   /* Nonzero if '&amp;' was found in the constraint string.  */
<span class="lineNum">      63 </span>            :   unsigned int earlyclobber : 1;
<span class="lineNum">      64 </span>            :   /* Nonzero if TARGET_MEM_CONSTRAINT was found in the constraint
<span class="lineNum">      65 </span>            :      string.  */
<span class="lineNum">      66 </span>            :   unsigned int memory_ok : 1;
<span class="lineNum">      67 </span>            :   /* Nonzero if 'p' was found in the constraint string.  */
<span class="lineNum">      68 </span>            :   unsigned int is_address : 1;
<span class="lineNum">      69 </span>            :   /* Nonzero if 'X' was found in the constraint string, or if the constraint
<span class="lineNum">      70 </span>            :      string for this alternative was empty.  */
<span class="lineNum">      71 </span>            :   unsigned int anything_ok : 1;
<span class="lineNum">      72 </span>            : 
<span class="lineNum">      73 </span>            :   unsigned int unused : 12;
<span class="lineNum">      74 </span>            : };
<span class="lineNum">      75 </span>            : 
<span class="lineNum">      76 </span>            : /* Return the class for operand I of alternative ALT, taking matching
<span class="lineNum">      77 </span>            :    constraints into account.  */
<span class="lineNum">      78 </span>            : 
<span class="lineNum">      79 </span>            : static inline enum reg_class
<span class="lineNum">      80 </span>            : alternative_class (const operand_alternative *alt, int i)
<span class="lineNum">      81 </span>            : {
<span class="lineNum">      82 </span><span class="lineCov">   31820535 :   return alt[i].matches &gt;= 0 ? alt[alt[i].matches].cl : alt[i].cl;</span>
<span class="lineNum">      83 </span>            : }
<span class="lineNum">      84 </span>            : 
<span class="lineNum">      85 </span>            : extern void init_recog (void);
<span class="lineNum">      86 </span>            : extern void init_recog_no_volatile (void);
<span class="lineNum">      87 </span>            : extern int check_asm_operands (rtx);
<span class="lineNum">      88 </span>            : extern int asm_operand_ok (rtx, const char *, const char **);
<span class="lineNum">      89 </span>            : extern bool validate_change (rtx, rtx *, rtx, bool);
<span class="lineNum">      90 </span>            : extern bool validate_unshare_change (rtx, rtx *, rtx, bool);
<span class="lineNum">      91 </span>            : extern bool canonicalize_change_group (rtx_insn *insn, rtx x);
<span class="lineNum">      92 </span>            : extern int insn_invalid_p (rtx_insn *, bool);
<span class="lineNum">      93 </span>            : extern int verify_changes (int);
<span class="lineNum">      94 </span>            : extern void confirm_change_group (void);
<span class="lineNum">      95 </span>            : extern int apply_change_group (void);
<span class="lineNum">      96 </span>            : extern int num_validated_changes (void);
<span class="lineNum">      97 </span>            : extern void cancel_changes (int);
<span class="lineNum">      98 </span>            : extern int constrain_operands (int, alternative_mask);
<span class="lineNum">      99 </span>            : extern int constrain_operands_cached (rtx_insn *, int);
<span class="lineNum">     100 </span>            : extern int memory_address_addr_space_p (machine_mode, rtx, addr_space_t);
<span class="lineNum">     101 </span>            : #define memory_address_p(mode,addr) \
<span class="lineNum">     102 </span>            :         memory_address_addr_space_p ((mode), (addr), ADDR_SPACE_GENERIC)
<span class="lineNum">     103 </span>            : extern int strict_memory_address_addr_space_p (machine_mode, rtx,
<span class="lineNum">     104 </span>            :                                                addr_space_t);
<span class="lineNum">     105 </span>            : #define strict_memory_address_p(mode,addr) \
<span class="lineNum">     106 </span>            :         strict_memory_address_addr_space_p ((mode), (addr), ADDR_SPACE_GENERIC)
<span class="lineNum">     107 </span>            : extern int validate_replace_rtx_subexp (rtx, rtx, rtx_insn *, rtx *);
<span class="lineNum">     108 </span>            : extern int validate_replace_rtx (rtx, rtx, rtx_insn *);
<span class="lineNum">     109 </span>            : extern int validate_replace_rtx_part (rtx, rtx, rtx *, rtx_insn *);
<span class="lineNum">     110 </span>            : extern int validate_replace_rtx_part_nosimplify (rtx, rtx, rtx *, rtx_insn *);
<span class="lineNum">     111 </span>            : extern void validate_replace_rtx_group (rtx, rtx, rtx_insn *);
<span class="lineNum">     112 </span>            : extern void validate_replace_src_group (rtx, rtx, rtx_insn *);
<span class="lineNum">     113 </span>            : extern bool validate_simplify_insn (rtx_insn *insn);
<span class="lineNum">     114 </span>            : extern int num_changes_pending (void);
<span class="lineNum">     115 </span>            : extern int next_insn_tests_no_inequality (rtx_insn *);
<span class="lineNum">     116 </span>            : extern bool reg_fits_class_p (const_rtx, reg_class_t, int, machine_mode);
<span class="lineNum">     117 </span>            : 
<span class="lineNum">     118 </span>            : extern int offsettable_memref_p (rtx);
<span class="lineNum">     119 </span>            : extern int offsettable_nonstrict_memref_p (rtx);
<span class="lineNum">     120 </span>            : extern int offsettable_address_addr_space_p (int, machine_mode, rtx,
<span class="lineNum">     121 </span>            :                                              addr_space_t);
<span class="lineNum">     122 </span>            : #define offsettable_address_p(strict,mode,addr) \
<span class="lineNum">     123 </span>            :         offsettable_address_addr_space_p ((strict), (mode), (addr), \
<span class="lineNum">     124 </span>            :                                           ADDR_SPACE_GENERIC)
<span class="lineNum">     125 </span>            : extern bool mode_dependent_address_p (rtx, addr_space_t);
<span class="lineNum">     126 </span>            : 
<span class="lineNum">     127 </span>            : extern int recog (rtx, rtx_insn *, int *);
<span class="lineNum">     128 </span>            : #ifndef GENERATOR_FILE
<span class="lineNum">     129 </span>            : static inline int recog_memoized (rtx_insn *insn);
<span class="lineNum">     130 </span>            : #endif
<span class="lineNum">     131 </span>            : extern void add_clobbers (rtx, int);
<span class="lineNum">     132 </span>            : extern int added_clobbers_hard_reg_p (int);
<span class="lineNum">     133 </span>            : extern void insn_extract (rtx_insn *);
<span class="lineNum">     134 </span>            : extern void extract_insn (rtx_insn *);
<span class="lineNum">     135 </span>            : extern void extract_constrain_insn (rtx_insn *insn);
<span class="lineNum">     136 </span>            : extern void extract_constrain_insn_cached (rtx_insn *);
<span class="lineNum">     137 </span>            : extern void extract_insn_cached (rtx_insn *);
<span class="lineNum">     138 </span>            : extern void preprocess_constraints (int, int, const char **,
<span class="lineNum">     139 </span>            :                                     operand_alternative *, rtx **);
<span class="lineNum">     140 </span>            : extern const operand_alternative *preprocess_insn_constraints (unsigned int);
<span class="lineNum">     141 </span>            : extern void preprocess_constraints (rtx_insn *);
<span class="lineNum">     142 </span>            : extern rtx_insn *peep2_next_insn (int);
<span class="lineNum">     143 </span>            : extern int peep2_regno_dead_p (int, int);
<span class="lineNum">     144 </span>            : extern int peep2_reg_dead_p (int, rtx);
<span class="lineNum">     145 </span>            : #ifdef CLEAR_HARD_REG_SET
<span class="lineNum">     146 </span>            : extern rtx peep2_find_free_register (int, int, const char *,
<span class="lineNum">     147 </span>            :                                      machine_mode, HARD_REG_SET *);
<span class="lineNum">     148 </span>            : #endif
<span class="lineNum">     149 </span>            : extern rtx_insn *peephole2_insns (rtx, rtx_insn *, int *);
<span class="lineNum">     150 </span>            : 
<span class="lineNum">     151 </span>            : extern int store_data_bypass_p (rtx_insn *, rtx_insn *);
<span class="lineNum">     152 </span>            : extern int if_test_bypass_p (rtx_insn *, rtx_insn *);
<span class="lineNum">     153 </span>            : 
<span class="lineNum">     154 </span>            : #ifndef GENERATOR_FILE
<span class="lineNum">     155 </span>            : /* Try recognizing the instruction INSN,
<span class="lineNum">     156 </span>            :    and return the code number that results.
<span class="lineNum">     157 </span>            :    Remember the code so that repeated calls do not
<span class="lineNum">     158 </span>            :    need to spend the time for actual rerecognition.
<span class="lineNum">     159 </span>            : 
<span class="lineNum">     160 </span>            :    This function is the normal interface to instruction recognition.
<span class="lineNum">     161 </span>            :    The automatically-generated function `recog' is normally called
<span class="lineNum">     162 </span>            :    through this one.  */
<span class="lineNum">     163 </span>            : 
<span class="lineNum">     164 </span>            : static inline int
<span class="lineNum">     165 </span>            : recog_memoized (rtx_insn *insn)
<span class="lineNum">     166 </span>            : {
<span class="lineNum">     167 </span><span class="lineCov"> 8425231660 :   if (INSN_CODE (insn) &lt; 0)</span>
<span class="lineNum">     168 </span><span class="lineCov">  604799332 :     INSN_CODE (insn) = recog (PATTERN (insn), insn, 0);</span>
<span class="lineNum">     169 </span><span class="lineCov"> 8431629553 :   return INSN_CODE (insn);</span>
<span class="lineNum">     170 </span>            : }
<span class="lineNum">     171 </span>            : #endif
<span class="lineNum">     172 </span>            : 
<span class="lineNum">     173 </span>            : /* Skip chars until the next ',' or the end of the string.  This is
<a name="174"><span class="lineNum">     174 </span>            :    useful to skip alternatives in a constraint string.  */</a>
<span class="lineNum">     175 </span>            : static inline const char *
<span class="lineNum">     176 </span><span class="lineNoCov">          0 : skip_alternative (const char *p)</span>
<span class="lineNum">     177 </span>            : {
<span class="lineNum">     178 </span><span class="lineCov"> 1690339669 :   const char *r = p;</span>
<span class="lineNum">     179 </span><span class="lineCov"> 5303013484 :   while (*r != '\0' &amp;&amp; *r != ',')</span>
<span class="lineNum">     180 </span><span class="lineCov"> 3612673815 :     r++;</span>
<span class="lineNum">     181 </span><span class="lineCov"> 1690339669 :   if (*r == ',')</span>
<span class="lineNum">     182 </span><span class="lineCov"> 1642524877 :     r++;</span>
<span class="lineNum">     183 </span><span class="lineCov"> 1690339669 :   return r;</span>
<span class="lineNum">     184 </span>            : }
<span class="lineNum">     185 </span>            : 
<span class="lineNum">     186 </span>            : /* Nonzero means volatile operands are recognized.  */
<span class="lineNum">     187 </span>            : extern int volatile_ok;
<span class="lineNum">     188 </span>            : 
<span class="lineNum">     189 </span>            : /* Set by constrain_operands to the number of the alternative that
<span class="lineNum">     190 </span>            :    matched.  */
<span class="lineNum">     191 </span>            : extern int which_alternative;
<span class="lineNum">     192 </span>            : 
<span class="lineNum">     193 </span>            : /* The following vectors hold the results from insn_extract.  */
<span class="lineNum">     194 </span>            : 
<span class="lineNum">     195 </span>            : struct recog_data_d
<span class="lineNum">     196 </span>            : {
<span class="lineNum">     197 </span>            :   /* It is very tempting to make the 5 operand related arrays into a
<span class="lineNum">     198 </span>            :      structure and index on that.  However, to be source compatible
<span class="lineNum">     199 </span>            :      with all of the existing md file insn constraints and output
<span class="lineNum">     200 </span>            :      templates, we need `operand' as a flat array.  Without that
<span class="lineNum">     201 </span>            :      member, making an array for the rest seems pointless.  */
<span class="lineNum">     202 </span>            : 
<span class="lineNum">     203 </span>            :   /* Gives value of operand N.  */
<span class="lineNum">     204 </span>            :   rtx operand[MAX_RECOG_OPERANDS];
<span class="lineNum">     205 </span>            : 
<span class="lineNum">     206 </span>            :   /* Gives location where operand N was found.  */
<span class="lineNum">     207 </span>            :   rtx *operand_loc[MAX_RECOG_OPERANDS];
<span class="lineNum">     208 </span>            : 
<span class="lineNum">     209 </span>            :   /* Gives the constraint string for operand N.  */
<span class="lineNum">     210 </span>            :   const char *constraints[MAX_RECOG_OPERANDS];
<span class="lineNum">     211 </span>            : 
<span class="lineNum">     212 </span>            :   /* Nonzero if operand N is a match_operator or a match_parallel.  */
<span class="lineNum">     213 </span>            :   char is_operator[MAX_RECOG_OPERANDS];
<span class="lineNum">     214 </span>            : 
<span class="lineNum">     215 </span>            :   /* Gives the mode of operand N.  */
<span class="lineNum">     216 </span>            :   machine_mode operand_mode[MAX_RECOG_OPERANDS];
<span class="lineNum">     217 </span>            : 
<span class="lineNum">     218 </span>            :   /* Gives the type (in, out, inout) for operand N.  */
<span class="lineNum">     219 </span>            :   enum op_type operand_type[MAX_RECOG_OPERANDS];
<span class="lineNum">     220 </span>            : 
<span class="lineNum">     221 </span>            :   /* Gives location where the Nth duplicate-appearance of an operand
<span class="lineNum">     222 </span>            :      was found.  This is something that matched MATCH_DUP.  */
<span class="lineNum">     223 </span>            :   rtx *dup_loc[MAX_DUP_OPERANDS];
<span class="lineNum">     224 </span>            : 
<span class="lineNum">     225 </span>            :   /* Gives the operand number that was duplicated in the Nth
<span class="lineNum">     226 </span>            :      duplicate-appearance of an operand.  */
<span class="lineNum">     227 </span>            :   char dup_num[MAX_DUP_OPERANDS];
<span class="lineNum">     228 </span>            : 
<span class="lineNum">     229 </span>            :   /* ??? Note that these are `char' instead of `unsigned char' to (try to)
<span class="lineNum">     230 </span>            :      avoid certain lossage from K&amp;R C, wherein `unsigned char' default
<span class="lineNum">     231 </span>            :      promotes to `unsigned int' instead of `int' as in ISO C.  As of 1999,
<span class="lineNum">     232 </span>            :      the most common places to bootstrap from K&amp;R C are SunOS and HPUX,
<span class="lineNum">     233 </span>            :      both of which have signed characters by default.  The only other
<span class="lineNum">     234 </span>            :      supported natives that have both K&amp;R C and unsigned characters are
<span class="lineNum">     235 </span>            :      ROMP and Irix 3, and neither have been seen for a while, but do
<span class="lineNum">     236 </span>            :      continue to consider unsignedness when performing arithmetic inside
<span class="lineNum">     237 </span>            :      a comparison.  */
<span class="lineNum">     238 </span>            : 
<span class="lineNum">     239 </span>            :   /* The number of operands of the insn.  */
<span class="lineNum">     240 </span>            :   char n_operands;
<span class="lineNum">     241 </span>            : 
<span class="lineNum">     242 </span>            :   /* The number of MATCH_DUPs in the insn.  */
<span class="lineNum">     243 </span>            :   char n_dups;
<span class="lineNum">     244 </span>            : 
<span class="lineNum">     245 </span>            :   /* The number of alternatives in the constraints for the insn.  */
<span class="lineNum">     246 </span>            :   char n_alternatives;
<span class="lineNum">     247 </span>            : 
<span class="lineNum">     248 </span>            :   /* True if insn is ASM_OPERANDS.  */
<span class="lineNum">     249 </span>            :   bool is_asm;
<span class="lineNum">     250 </span>            : 
<span class="lineNum">     251 </span>            :   /* In case we are caching, hold insn data was generated for.  */
<span class="lineNum">     252 </span>            :   rtx_insn *insn;
<span class="lineNum">     253 </span>            : };
<span class="lineNum">     254 </span>            : 
<span class="lineNum">     255 </span>            : extern struct recog_data_d recog_data;
<span class="lineNum">     256 </span>            : 
<span class="lineNum">     257 </span>            : extern const operand_alternative *recog_op_alt;
<span class="lineNum">     258 </span>            : 
<span class="lineNum">     259 </span>            : /* Return a pointer to an array in which index OP describes the constraints
<span class="lineNum">     260 </span>            :    on operand OP of the current instruction alternative (which_alternative).
<span class="lineNum">     261 </span>            :    Only valid after calling preprocess_constraints and constrain_operands.  */
<a name="262"><span class="lineNum">     262 </span>            : </a>
<span class="lineNum">     263 </span>            : inline static const operand_alternative *
<span class="lineNum">     264 </span><span class="lineCov">   55994929 : which_op_alt ()</span>
<span class="lineNum">     265 </span>            : {
<span class="lineNum">     266 </span><span class="lineCov">   55994929 :   gcc_checking_assert (IN_RANGE (which_alternative, 0,</span>
<span class="lineNum">     267 </span>            :                                  recog_data.n_alternatives - 1));
<span class="lineNum">     268 </span><span class="lineCov">   55994929 :   return &amp;recog_op_alt[which_alternative * recog_data.n_operands];</span>
<span class="lineNum">     269 </span>            : }
<span class="lineNum">     270 </span>            : 
<span class="lineNum">     271 </span>            : /* A table defined in insn-output.c that give information about
<span class="lineNum">     272 </span>            :    each insn-code value.  */
<span class="lineNum">     273 </span>            : 
<span class="lineNum">     274 </span>            : typedef int (*insn_operand_predicate_fn) (rtx, machine_mode);
<span class="lineNum">     275 </span>            : typedef const char * (*insn_output_fn) (rtx *, rtx_insn *);
<span class="lineNum">     276 </span>            : 
<span class="lineNum">     277 </span>            : struct insn_gen_fn
<span class="lineNum">     278 </span>            : {
<span class="lineNum">     279 </span>            :   typedef rtx_insn * (*f0) (void);
<span class="lineNum">     280 </span>            :   typedef rtx_insn * (*f1) (rtx);
<span class="lineNum">     281 </span>            :   typedef rtx_insn * (*f2) (rtx, rtx);
<span class="lineNum">     282 </span>            :   typedef rtx_insn * (*f3) (rtx, rtx, rtx);
<span class="lineNum">     283 </span>            :   typedef rtx_insn * (*f4) (rtx, rtx, rtx, rtx);
<span class="lineNum">     284 </span>            :   typedef rtx_insn * (*f5) (rtx, rtx, rtx, rtx, rtx);
<span class="lineNum">     285 </span>            :   typedef rtx_insn * (*f6) (rtx, rtx, rtx, rtx, rtx, rtx);
<span class="lineNum">     286 </span>            :   typedef rtx_insn * (*f7) (rtx, rtx, rtx, rtx, rtx, rtx, rtx);
<span class="lineNum">     287 </span>            :   typedef rtx_insn * (*f8) (rtx, rtx, rtx, rtx, rtx, rtx, rtx, rtx);
<span class="lineNum">     288 </span>            :   typedef rtx_insn * (*f9) (rtx, rtx, rtx, rtx, rtx, rtx, rtx, rtx, rtx);
<span class="lineNum">     289 </span>            :   typedef rtx_insn * (*f10) (rtx, rtx, rtx, rtx, rtx, rtx, rtx, rtx, rtx, rtx);
<span class="lineNum">     290 </span>            :   typedef rtx_insn * (*f11) (rtx, rtx, rtx, rtx, rtx, rtx, rtx, rtx, rtx, rtx, rtx);
<span class="lineNum">     291 </span>            :   typedef rtx_insn * (*f12) (rtx, rtx, rtx, rtx, rtx, rtx, rtx, rtx, rtx, rtx, rtx, rtx);
<span class="lineNum">     292 </span>            :   typedef rtx_insn * (*f13) (rtx, rtx, rtx, rtx, rtx, rtx, rtx, rtx, rtx, rtx, rtx, rtx, rtx);
<span class="lineNum">     293 </span>            :   typedef rtx_insn * (*f14) (rtx, rtx, rtx, rtx, rtx, rtx, rtx, rtx, rtx, rtx, rtx, rtx, rtx, rtx);
<span class="lineNum">     294 </span>            :   typedef rtx_insn * (*f15) (rtx, rtx, rtx, rtx, rtx, rtx, rtx, rtx, rtx, rtx, rtx, rtx, rtx, rtx, rtx);
<span class="lineNum">     295 </span>            :   typedef rtx_insn * (*f16) (rtx, rtx, rtx, rtx, rtx, rtx, rtx, rtx, rtx, rtx, rtx, rtx, rtx, rtx, rtx, rtx);
<span class="lineNum">     296 </span>            : 
<span class="lineNum">     297 </span>            :   typedef void (*stored_funcptr) (void);
<a name="298"><span class="lineNum">     298 </span>            : </a>
<a name="299"><span class="lineNum">     299 </span>            :   rtx_insn * operator () (void) const { return ((f0)func) (); }</a>
<a name="300"><span class="lineNum">     300 </span><span class="lineCov">      38832 :   rtx_insn * operator () (rtx a0) const { return ((f1)func) (a0); }</span></a>
<a name="301"><span class="lineNum">     301 </span><span class="lineCov">   44401803 :   rtx_insn * operator () (rtx a0, rtx a1) const { return ((f2)func) (a0, a1); }</span></a>
<a name="302"><span class="lineNum">     302 </span><span class="lineCov">    7968820 :   rtx_insn * operator () (rtx a0, rtx a1, rtx a2) const { return ((f3)func) (a0, a1, a2); }</span></a>
<a name="303"><span class="lineNum">     303 </span><span class="lineCov">    4387239 :   rtx_insn * operator () (rtx a0, rtx a1, rtx a2, rtx a3) const { return ((f4)func) (a0, a1, a2, a3); }</span></a>
<a name="304"><span class="lineNum">     304 </span><span class="lineCov">      26176 :   rtx_insn * operator () (rtx a0, rtx a1, rtx a2, rtx a3, rtx a4) const { return ((f5)func) (a0, a1, a2, a3, a4); }</span></a>
<a name="305"><span class="lineNum">     305 </span><span class="lineCov">       9294 :   rtx_insn * operator () (rtx a0, rtx a1, rtx a2, rtx a3, rtx a4, rtx a5) const { return ((f6)func) (a0, a1, a2, a3, a4, a5); }</span></a>
<a name="306"><span class="lineNum">     306 </span><span class="lineCov">        649 :   rtx_insn * operator () (rtx a0, rtx a1, rtx a2, rtx a3, rtx a4, rtx a5, rtx a6) const { return ((f7)func) (a0, a1, a2, a3, a4, a5, a6); }</span></a>
<span class="lineNum">     307 </span><span class="lineCov">      19407 :   rtx_insn * operator () (rtx a0, rtx a1, rtx a2, rtx a3, rtx a4, rtx a5, rtx a6, rtx a7) const { return ((f8)func) (a0, a1, a2, a3, a4, a5, a6, a7); }</span>
<span class="lineNum">     308 </span><span class="lineCov">      56996 :   rtx_insn * operator () (rtx a0, rtx a1, rtx a2, rtx a3, rtx a4, rtx a5, rtx a6, rtx a7, rtx a8) const { return ((f9)func) (a0, a1, a2, a3, a4, a5, a6, a7, a8); }</span>
<span class="lineNum">     309 </span>            :   rtx_insn * operator () (rtx a0, rtx a1, rtx a2, rtx a3, rtx a4, rtx a5, rtx a6, rtx a7, rtx a8, rtx a9) const { return ((f10)func) (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9); }
<span class="lineNum">     310 </span>            :   rtx_insn * operator () (rtx a0, rtx a1, rtx a2, rtx a3, rtx a4, rtx a5, rtx a6, rtx a7, rtx a8, rtx a9, rtx a10) const { return ((f11)func) (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10); }
<span class="lineNum">     311 </span>            :   rtx_insn * operator () (rtx a0, rtx a1, rtx a2, rtx a3, rtx a4, rtx a5, rtx a6, rtx a7, rtx a8, rtx a9, rtx a10, rtx a11) const { return ((f12)func) (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11); }
<span class="lineNum">     312 </span>            :   rtx_insn * operator () (rtx a0, rtx a1, rtx a2, rtx a3, rtx a4, rtx a5, rtx a6, rtx a7, rtx a8, rtx a9, rtx a10, rtx a11, rtx a12) const { return ((f13)func) (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12); }
<span class="lineNum">     313 </span>            :   rtx_insn * operator () (rtx a0, rtx a1, rtx a2, rtx a3, rtx a4, rtx a5, rtx a6, rtx a7, rtx a8, rtx a9, rtx a10, rtx a11, rtx a12, rtx a13) const { return ((f14)func) (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13); }
<span class="lineNum">     314 </span>            :   rtx_insn * operator () (rtx a0, rtx a1, rtx a2, rtx a3, rtx a4, rtx a5, rtx a6, rtx a7, rtx a8, rtx a9, rtx a10, rtx a11, rtx a12, rtx a13, rtx a14) const { return ((f15)func) (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14); }
<span class="lineNum">     315 </span>            :   rtx_insn * operator () (rtx a0, rtx a1, rtx a2, rtx a3, rtx a4, rtx a5, rtx a6, rtx a7, rtx a8, rtx a9, rtx a10, rtx a11, rtx a12, rtx a13, rtx a14, rtx a15) const { return ((f16)func) (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15); }
<span class="lineNum">     316 </span>            : 
<span class="lineNum">     317 </span>            :   // This is for compatibility of code that invokes functions like
<span class="lineNum">     318 </span>            :   //   (*funcptr) (arg)
<span class="lineNum">     319 </span>            :   insn_gen_fn operator * (void) const { return *this; }
<span class="lineNum">     320 </span>            : 
<span class="lineNum">     321 </span>            :   // The wrapped function pointer must be public and there must not be any
<span class="lineNum">     322 </span>            :   // constructors.  Otherwise the insn_data_d struct initializers generated
<span class="lineNum">     323 </span>            :   // by genoutput.c will result in static initializer functions, which defeats
<span class="lineNum">     324 </span>            :   // the purpose of the generated insn_data_d array.
<span class="lineNum">     325 </span>            :   stored_funcptr func;
<span class="lineNum">     326 </span>            : };
<span class="lineNum">     327 </span>            : 
<span class="lineNum">     328 </span>            : struct insn_operand_data
<span class="lineNum">     329 </span>            : {
<span class="lineNum">     330 </span>            :   const insn_operand_predicate_fn predicate;
<span class="lineNum">     331 </span>            : 
<span class="lineNum">     332 </span>            :   const char *const constraint;
<span class="lineNum">     333 </span>            : 
<span class="lineNum">     334 </span>            :   ENUM_BITFIELD(machine_mode) const mode : 16;
<span class="lineNum">     335 </span>            : 
<span class="lineNum">     336 </span>            :   const char strict_low;
<span class="lineNum">     337 </span>            : 
<span class="lineNum">     338 </span>            :   const char is_operator;
<span class="lineNum">     339 </span>            : 
<span class="lineNum">     340 </span>            :   const char eliminable;
<span class="lineNum">     341 </span>            : 
<span class="lineNum">     342 </span>            :   const char allows_mem;
<span class="lineNum">     343 </span>            : };
<span class="lineNum">     344 </span>            : 
<span class="lineNum">     345 </span>            : /* Legal values for insn_data.output_format.  Indicate what type of data
<span class="lineNum">     346 </span>            :    is stored in insn_data.output.  */
<span class="lineNum">     347 </span>            : #define INSN_OUTPUT_FORMAT_NONE         0       /* abort */
<span class="lineNum">     348 </span>            : #define INSN_OUTPUT_FORMAT_SINGLE       1       /* const char * */
<span class="lineNum">     349 </span>            : #define INSN_OUTPUT_FORMAT_MULTI        2       /* const char * const * */
<span class="lineNum">     350 </span>            : #define INSN_OUTPUT_FORMAT_FUNCTION     3       /* const char * (*)(...) */
<span class="lineNum">     351 </span>            : 
<span class="lineNum">     352 </span>            : struct insn_data_d
<span class="lineNum">     353 </span>            : {
<span class="lineNum">     354 </span>            :   const char *const name;
<span class="lineNum">     355 </span>            : #if HAVE_DESIGNATED_UNION_INITIALIZERS
<span class="lineNum">     356 </span>            :   union {
<span class="lineNum">     357 </span>            :     const char *single;
<span class="lineNum">     358 </span>            :     const char *const *multi;
<span class="lineNum">     359 </span>            :     insn_output_fn function;
<span class="lineNum">     360 </span>            :   } output;
<span class="lineNum">     361 </span>            : #else
<span class="lineNum">     362 </span>            :   struct {
<span class="lineNum">     363 </span>            :     const char *single;
<span class="lineNum">     364 </span>            :     const char *const *multi;
<span class="lineNum">     365 </span>            :     insn_output_fn function;
<span class="lineNum">     366 </span>            :   } output;
<span class="lineNum">     367 </span>            : #endif
<span class="lineNum">     368 </span>            :   const insn_gen_fn genfun;
<span class="lineNum">     369 </span>            :   const struct insn_operand_data *const operand;
<span class="lineNum">     370 </span>            : 
<span class="lineNum">     371 </span>            :   const char n_generator_args;
<span class="lineNum">     372 </span>            :   const char n_operands;
<span class="lineNum">     373 </span>            :   const char n_dups;
<span class="lineNum">     374 </span>            :   const char n_alternatives;
<span class="lineNum">     375 </span>            :   const char output_format;
<span class="lineNum">     376 </span>            : };
<span class="lineNum">     377 </span>            : 
<span class="lineNum">     378 </span>            : extern const struct insn_data_d insn_data[];
<span class="lineNum">     379 </span>            : extern int peep2_current_count;
<span class="lineNum">     380 </span>            : 
<span class="lineNum">     381 </span>            : #ifndef GENERATOR_FILE
<span class="lineNum">     382 </span>            : #include &quot;insn-codes.h&quot;
<span class="lineNum">     383 </span>            : 
<span class="lineNum">     384 </span>            : /* An enum of boolean attributes that may only depend on the current
<span class="lineNum">     385 </span>            :    subtarget, not on things like operands or compiler phase.  */
<span class="lineNum">     386 </span>            : enum bool_attr {
<span class="lineNum">     387 </span>            :   BA_ENABLED,
<span class="lineNum">     388 </span>            :   BA_PREFERRED_FOR_SPEED,
<span class="lineNum">     389 </span>            :   BA_PREFERRED_FOR_SIZE,
<span class="lineNum">     390 </span>            :   BA_LAST = BA_PREFERRED_FOR_SIZE
<span class="lineNum">     391 </span>            : };
<span class="lineNum">     392 </span>            : 
<span class="lineNum">     393 </span>            : /* Target-dependent globals.  */
<span class="lineNum">     394 </span>            : struct target_recog {
<span class="lineNum">     395 </span>            :   bool x_initialized;
<span class="lineNum">     396 </span>            :   alternative_mask x_bool_attr_masks[NUM_INSN_CODES][BA_LAST + 1];
<span class="lineNum">     397 </span>            :   operand_alternative *x_op_alt[NUM_INSN_CODES];
<span class="lineNum">     398 </span>            : };
<span class="lineNum">     399 </span>            : 
<span class="lineNum">     400 </span>            : extern struct target_recog default_target_recog;
<span class="lineNum">     401 </span>            : #if SWITCHABLE_TARGET
<span class="lineNum">     402 </span>            : extern struct target_recog *this_target_recog;
<span class="lineNum">     403 </span>            : #else
<span class="lineNum">     404 </span>            : #define this_target_recog (&amp;default_target_recog)
<span class="lineNum">     405 </span>            : #endif
<span class="lineNum">     406 </span>            : 
<span class="lineNum">     407 </span>            : alternative_mask get_enabled_alternatives (rtx_insn *);
<span class="lineNum">     408 </span>            : alternative_mask get_preferred_alternatives (rtx_insn *);
<span class="lineNum">     409 </span>            : alternative_mask get_preferred_alternatives (rtx_insn *, basic_block);
<span class="lineNum">     410 </span>            : bool check_bool_attrs (rtx_insn *);
<span class="lineNum">     411 </span>            : 
<span class="lineNum">     412 </span>            : void recog_init ();
<span class="lineNum">     413 </span>            : #endif
<span class="lineNum">     414 </span>            : 
<span class="lineNum">     415 </span>            : #endif /* GCC_RECOG_H */
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.0</a></td></tr>
  </table>
  <br>
<h3>LCOV profile is generated on x86_64 machine using following configure options: configure --disable-bootstrap --enable-coverage=opt --enable-languages=c,c++,fortran,go,jit,lto --enable-host-shared. GCC test suite is run with the built compiler.</h3></body></html>
