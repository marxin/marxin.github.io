<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - gcc.info - gcc/lra-assigns.c</title>
  <link rel="stylesheet" type="text/css" href="../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../index.html">top level</a> - <a href="index.html">gcc</a> - lra-assigns.c<span style="font-size: 80%;"> (source / <a href="lra-assigns.c.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">gcc.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">911</td>
            <td class="headerCovTableEntry">940</td>
            <td class="headerCovTableEntryHi">96.9 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2018-09-22 10:58:49</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">29</td>
            <td class="headerCovTableEntry">30</td>
            <td class="headerCovTableEntryHi">96.7 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /* Assign reload pseudos.</a>
<span class="lineNum">       2 </span>            :    Copyright (C) 2010-2018 Free Software Foundation, Inc.
<span class="lineNum">       3 </span>            :    Contributed by Vladimir Makarov &lt;vmakarov@redhat.com&gt;.
<span class="lineNum">       4 </span>            : 
<span class="lineNum">       5 </span>            : This file is part of GCC.
<span class="lineNum">       6 </span>            : 
<span class="lineNum">       7 </span>            : GCC is free software; you can redistribute it and/or modify it under
<span class="lineNum">       8 </span>            : the terms of the GNU General Public License as published by the Free
<span class="lineNum">       9 </span>            : Software Foundation; either version 3, or (at your option) any later
<span class="lineNum">      10 </span>            : version.
<span class="lineNum">      11 </span>            : 
<span class="lineNum">      12 </span>            : GCC is distributed in the hope that it will be useful, but WITHOUT ANY
<span class="lineNum">      13 </span>            : WARRANTY; without even the implied warranty of MERCHANTABILITY or
<span class="lineNum">      14 </span>            : FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
<span class="lineNum">      15 </span>            : for more details.
<span class="lineNum">      16 </span>            : 
<span class="lineNum">      17 </span>            : You should have received a copy of the GNU General Public License
<span class="lineNum">      18 </span>            : along with GCC; see the file COPYING3.  If not see
<span class="lineNum">      19 </span>            : &lt;http://www.gnu.org/licenses/&gt;.    */
<span class="lineNum">      20 </span>            : 
<span class="lineNum">      21 </span>            : 
<span class="lineNum">      22 </span>            : /* This file's main objective is to assign hard registers to reload
<span class="lineNum">      23 </span>            :    pseudos.  It also tries to allocate hard registers to other
<span class="lineNum">      24 </span>            :    pseudos, but at a lower priority than the reload pseudos.  The pass
<span class="lineNum">      25 </span>            :    does not transform the RTL.
<span class="lineNum">      26 </span>            : 
<span class="lineNum">      27 </span>            :    We must allocate a hard register to every reload pseudo.  We try to
<span class="lineNum">      28 </span>            :    increase the chances of finding a viable allocation by assigning
<span class="lineNum">      29 </span>            :    the pseudos in order of fewest available hard registers first.  If
<span class="lineNum">      30 </span>            :    we still fail to find a hard register, we spill other (non-reload)
<span class="lineNum">      31 </span>            :    pseudos in order to make room.
<span class="lineNum">      32 </span>            : 
<span class="lineNum">      33 </span>            :    find_hard_regno_for finds hard registers for allocation without
<span class="lineNum">      34 </span>            :    spilling.  spill_for does the same with spilling.  Both functions
<span class="lineNum">      35 </span>            :    use a cost model to determine the most profitable choice of hard
<span class="lineNum">      36 </span>            :    and spill registers.
<span class="lineNum">      37 </span>            : 
<span class="lineNum">      38 </span>            :    Once we have finished allocating reload pseudos, we also try to
<span class="lineNum">      39 </span>            :    assign registers to other (non-reload) pseudos.  This is useful if
<span class="lineNum">      40 </span>            :    hard registers were freed up by the spilling just described.
<span class="lineNum">      41 </span>            : 
<span class="lineNum">      42 </span>            :    We try to assign hard registers by collecting pseudos into threads.
<span class="lineNum">      43 </span>            :    These threads contain reload and inheritance pseudos that are
<span class="lineNum">      44 </span>            :    connected by copies (move insns).  Doing this improves the chances
<span class="lineNum">      45 </span>            :    of pseudos in the thread getting the same hard register and, as a
<span class="lineNum">      46 </span>            :    result, of allowing some move insns to be deleted.
<span class="lineNum">      47 </span>            : 
<span class="lineNum">      48 </span>            :    When we assign a hard register to a pseudo, we decrease the cost of
<span class="lineNum">      49 </span>            :    using the same hard register for pseudos that are connected by
<span class="lineNum">      50 </span>            :    copies.
<span class="lineNum">      51 </span>            : 
<span class="lineNum">      52 </span>            :    If two hard registers have the same frequency-derived cost, we
<span class="lineNum">      53 </span>            :    prefer hard registers with higher priorities.  The mapping of
<span class="lineNum">      54 </span>            :    registers to priorities is controlled by the register_priority
<span class="lineNum">      55 </span>            :    target hook.  For example, x86-64 has a few register priorities:
<span class="lineNum">      56 </span>            :    hard registers with and without REX prefixes have different
<span class="lineNum">      57 </span>            :    priorities.  This permits us to generate smaller code as insns
<span class="lineNum">      58 </span>            :    without REX prefixes are shorter.
<span class="lineNum">      59 </span>            : 
<span class="lineNum">      60 </span>            :    If a few hard registers are still equally good for the assignment,
<span class="lineNum">      61 </span>            :    we choose the least used hard register.  It is called leveling and
<span class="lineNum">      62 </span>            :    may be profitable for some targets.
<span class="lineNum">      63 </span>            : 
<span class="lineNum">      64 </span>            :    Only insns with changed allocation pseudos are processed on the
<span class="lineNum">      65 </span>            :    next constraint pass.
<span class="lineNum">      66 </span>            : 
<span class="lineNum">      67 </span>            :    The pseudo live-ranges are used to find conflicting pseudos.
<span class="lineNum">      68 </span>            : 
<span class="lineNum">      69 </span>            :    For understanding the code, it is important to keep in mind that
<span class="lineNum">      70 </span>            :    inheritance, split, and reload pseudos created since last
<span class="lineNum">      71 </span>            :    constraint pass have regno &gt;= lra_constraint_new_regno_start.
<span class="lineNum">      72 </span>            :    Inheritance and split pseudos created on any pass are in the
<span class="lineNum">      73 </span>            :    corresponding bitmaps.  Inheritance and split pseudos since the
<span class="lineNum">      74 </span>            :    last constraint pass have also the corresponding non-negative
<span class="lineNum">      75 </span>            :    restore_regno.  */
<span class="lineNum">      76 </span>            : 
<span class="lineNum">      77 </span>            : #include &quot;config.h&quot;
<span class="lineNum">      78 </span>            : #include &quot;system.h&quot;
<span class="lineNum">      79 </span>            : #include &quot;coretypes.h&quot;
<span class="lineNum">      80 </span>            : #include &quot;backend.h&quot;
<span class="lineNum">      81 </span>            : #include &quot;target.h&quot;
<span class="lineNum">      82 </span>            : #include &quot;rtl.h&quot;
<span class="lineNum">      83 </span>            : #include &quot;tree.h&quot;
<span class="lineNum">      84 </span>            : #include &quot;predict.h&quot;
<span class="lineNum">      85 </span>            : #include &quot;df.h&quot;
<span class="lineNum">      86 </span>            : #include &quot;memmodel.h&quot;
<span class="lineNum">      87 </span>            : #include &quot;tm_p.h&quot;
<span class="lineNum">      88 </span>            : #include &quot;insn-config.h&quot;
<span class="lineNum">      89 </span>            : #include &quot;regs.h&quot;
<span class="lineNum">      90 </span>            : #include &quot;ira.h&quot;
<span class="lineNum">      91 </span>            : #include &quot;recog.h&quot;
<span class="lineNum">      92 </span>            : #include &quot;rtl-error.h&quot;
<span class="lineNum">      93 </span>            : #include &quot;sparseset.h&quot;
<span class="lineNum">      94 </span>            : #include &quot;params.h&quot;
<span class="lineNum">      95 </span>            : #include &quot;lra.h&quot;
<span class="lineNum">      96 </span>            : #include &quot;lra-int.h&quot;
<span class="lineNum">      97 </span>            : 
<span class="lineNum">      98 </span>            : /* Current iteration number of the pass and current iteration number
<span class="lineNum">      99 </span>            :    of the pass after the latest spill pass when any former reload
<span class="lineNum">     100 </span>            :    pseudo was spilled.  */
<span class="lineNum">     101 </span>            : int lra_assignment_iter;
<span class="lineNum">     102 </span>            : int lra_assignment_iter_after_spill;
<span class="lineNum">     103 </span>            : 
<span class="lineNum">     104 </span>            : /* Flag of spilling former reload pseudos on this pass.  */
<span class="lineNum">     105 </span>            : static bool former_reload_pseudo_spill_p;
<span class="lineNum">     106 </span>            : 
<span class="lineNum">     107 </span>            : /* Array containing corresponding values of function
<span class="lineNum">     108 </span>            :    lra_get_allocno_class.  It is used to speed up the code.  */
<span class="lineNum">     109 </span>            : static enum reg_class *regno_allocno_class_array;
<span class="lineNum">     110 </span>            : 
<span class="lineNum">     111 </span>            : /* Array containing lengths of pseudo live ranges.  It is used to
<span class="lineNum">     112 </span>            :    speed up the code.  */
<span class="lineNum">     113 </span>            : static int *regno_live_length;
<span class="lineNum">     114 </span>            : 
<span class="lineNum">     115 </span>            : /* Information about the thread to which a pseudo belongs.  Threads are
<span class="lineNum">     116 </span>            :    a set of connected reload and inheritance pseudos with the same set of
<span class="lineNum">     117 </span>            :    available hard registers.  Lone registers belong to their own threads.  */
<span class="lineNum">     118 </span>            : struct regno_assign_info
<span class="lineNum">     119 </span>            : {
<span class="lineNum">     120 </span>            :   /* First/next pseudo of the same thread.  */
<span class="lineNum">     121 </span>            :   int first, next;
<span class="lineNum">     122 </span>            :   /* Frequency of the thread (execution frequency of only reload
<span class="lineNum">     123 </span>            :      pseudos in the thread when the thread contains a reload pseudo).
<span class="lineNum">     124 </span>            :      Defined only for the first thread pseudo.  */
<span class="lineNum">     125 </span>            :   int freq;
<span class="lineNum">     126 </span>            : };
<span class="lineNum">     127 </span>            : 
<span class="lineNum">     128 </span>            : /* Map regno to the corresponding regno assignment info.  */
<span class="lineNum">     129 </span>            : static struct regno_assign_info *regno_assign_info;
<span class="lineNum">     130 </span>            : 
<span class="lineNum">     131 </span>            : /* All inherited, subreg or optional pseudos created before last spill
<span class="lineNum">     132 </span>            :    sub-pass.  Such pseudos are permitted to get memory instead of hard
<span class="lineNum">     133 </span>            :    regs.  */
<span class="lineNum">     134 </span>            : static bitmap_head non_reload_pseudos;
<span class="lineNum">     135 </span>            : 
<span class="lineNum">     136 </span>            : /* Process a pseudo copy with execution frequency COPY_FREQ connecting
<a name="137"><span class="lineNum">     137 </span>            :    REGNO1 and REGNO2 to form threads.  */</a>
<span class="lineNum">     138 </span>            : static void
<span class="lineNum">     139 </span><span class="lineCov">    1013745 : process_copy_to_form_thread (int regno1, int regno2, int copy_freq)</span>
<span class="lineNum">     140 </span>            : {
<span class="lineNum">     141 </span><span class="lineCov">    1013745 :   int last, regno1_first, regno2_first;</span>
<span class="lineNum">     142 </span>            : 
<span class="lineNum">     143 </span><span class="lineCov">    1013745 :   lra_assert (regno1 &gt;= lra_constraint_new_regno_start</span>
<span class="lineNum">     144 </span>            :               &amp;&amp; regno2 &gt;= lra_constraint_new_regno_start);
<span class="lineNum">     145 </span><span class="lineCov">    1013745 :   regno1_first = regno_assign_info[regno1].first;</span>
<span class="lineNum">     146 </span><span class="lineCov">    1013745 :   regno2_first = regno_assign_info[regno2].first;</span>
<span class="lineNum">     147 </span><span class="lineCov">    1013745 :   if (regno1_first != regno2_first)</span>
<span class="lineNum">     148 </span>            :     {
<span class="lineNum">     149 </span><span class="lineCov">    4133965 :       for (last = regno2_first;</span>
<span class="lineNum">     150 </span><span class="lineCov">    5147710 :            regno_assign_info[last].next &gt;= 0;</span>
<span class="lineNum">     151 </span><span class="lineCov">    4133965 :            last = regno_assign_info[last].next)</span>
<span class="lineNum">     152 </span><span class="lineCov">    4133965 :         regno_assign_info[last].first = regno1_first;</span>
<span class="lineNum">     153 </span><span class="lineCov">    1013745 :       regno_assign_info[last].first = regno1_first;</span>
<span class="lineNum">     154 </span><span class="lineCov">    1013745 :       regno_assign_info[last].next = regno_assign_info[regno1_first].next;</span>
<span class="lineNum">     155 </span><span class="lineCov">    1013745 :       regno_assign_info[regno1_first].next = regno2_first;</span>
<span class="lineNum">     156 </span><span class="lineCov">    1013745 :       regno_assign_info[regno1_first].freq</span>
<span class="lineNum">     157 </span><span class="lineCov">    1013745 :         += regno_assign_info[regno2_first].freq;</span>
<span class="lineNum">     158 </span>            :     }
<span class="lineNum">     159 </span><span class="lineCov">    1013745 :   regno_assign_info[regno1_first].freq -= 2 * copy_freq;</span>
<span class="lineNum">     160 </span><span class="lineCov">    1013745 :   lra_assert (regno_assign_info[regno1_first].freq &gt;= 0);</span>
<span class="lineNum">     161 </span><span class="lineCov">    1013745 : }</span>
<span class="lineNum">     162 </span>            : 
<a name="163"><span class="lineNum">     163 </span>            : /* Initialize REGNO_ASSIGN_INFO and form threads.  */</a>
<span class="lineNum">     164 </span>            : static void
<span class="lineNum">     165 </span><span class="lineCov">     881139 : init_regno_assign_info (void)</span>
<span class="lineNum">     166 </span>            : {
<span class="lineNum">     167 </span><span class="lineCov">     881139 :   int i, regno1, regno2, max_regno = max_reg_num ();</span>
<span class="lineNum">     168 </span><span class="lineCov">     881139 :   lra_copy_t cp;</span>
<span class="lineNum">     169 </span>            : 
<span class="lineNum">     170 </span><span class="lineCov">     881139 :   regno_assign_info = XNEWVEC (struct regno_assign_info, max_regno);</span>
<span class="lineNum">     171 </span><span class="lineCov">   55874723 :   for (i = FIRST_PSEUDO_REGISTER; i &lt; max_regno; i++)</span>
<span class="lineNum">     172 </span>            :     {
<span class="lineNum">     173 </span><span class="lineCov">   54993584 :       regno_assign_info[i].first = i;</span>
<span class="lineNum">     174 </span><span class="lineCov">   54993584 :       regno_assign_info[i].next = -1;</span>
<span class="lineNum">     175 </span><span class="lineCov">   54993584 :       regno_assign_info[i].freq = lra_reg_info[i].freq;</span>
<span class="lineNum">     176 </span>            :     }
<span class="lineNum">     177 </span>            :   /* Form the threads.  */
<span class="lineNum">     178 </span><span class="lineCov">    2741646 :   for (i = 0; (cp = lra_get_copy (i)) != NULL; i++)</span>
<span class="lineNum">     179 </span><span class="lineCov">    1860507 :     if ((regno1 = cp-&gt;regno1) &gt;= lra_constraint_new_regno_start</span>
<span class="lineNum">     180 </span><span class="lineCov">    1860507 :         &amp;&amp; (regno2 = cp-&gt;regno2) &gt;= lra_constraint_new_regno_start</span>
<span class="lineNum">     181 </span><span class="lineCov">    1860507 :         &amp;&amp; reg_renumber[regno1] &lt; 0 &amp;&amp; lra_reg_info[regno1].nrefs != 0</span>
<span class="lineNum">     182 </span><span class="lineCov">    1027187 :         &amp;&amp; reg_renumber[regno2] &lt; 0 &amp;&amp; lra_reg_info[regno2].nrefs != 0</span>
<span class="lineNum">     183 </span><span class="lineCov">    1860507 :         &amp;&amp; (ira_class_hard_regs_num[regno_allocno_class_array[regno1]]</span>
<span class="lineNum">     184 </span><span class="lineCov">    1026972 :             == ira_class_hard_regs_num[regno_allocno_class_array[regno2]]))</span>
<span class="lineNum">     185 </span><span class="lineCov">    1013745 :       process_copy_to_form_thread (regno1, regno2, cp-&gt;freq);</span>
<span class="lineNum">     186 </span><span class="lineCov">     881139 : }</span>
<span class="lineNum">     187 </span>            : 
<a name="188"><span class="lineNum">     188 </span>            : /* Free REGNO_ASSIGN_INFO.  */</a>
<span class="lineNum">     189 </span>            : static void
<span class="lineNum">     190 </span><span class="lineNoCov">          0 : finish_regno_assign_info (void)</span>
<span class="lineNum">     191 </span>            : {
<span class="lineNum">     192 </span><span class="lineCov">     881139 :   free (regno_assign_info);</span>
<span class="lineNum">     193 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     194 </span>            : 
<span class="lineNum">     195 </span>            : /* The function is used to sort *reload* and *inheritance* pseudos to
<span class="lineNum">     196 </span>            :    try to assign them hard registers.  We put pseudos from the same
<a name="197"><span class="lineNum">     197 </span>            :    thread always nearby.  */</a>
<span class="lineNum">     198 </span>            : static int
<span class="lineNum">     199 </span><span class="lineCov">  163891773 : reload_pseudo_compare_func (const void *v1p, const void *v2p)</span>
<span class="lineNum">     200 </span>            : {
<span class="lineNum">     201 </span><span class="lineCov">  163891773 :   int r1 = *(const int *) v1p, r2 = *(const int *) v2p;</span>
<span class="lineNum">     202 </span><span class="lineCov">  163891773 :   enum reg_class cl1 = regno_allocno_class_array[r1];</span>
<span class="lineNum">     203 </span><span class="lineCov">  163891773 :   enum reg_class cl2 = regno_allocno_class_array[r2];</span>
<span class="lineNum">     204 </span><span class="lineCov">  163891773 :   int diff;</span>
<span class="lineNum">     205 </span>            : 
<span class="lineNum">     206 </span><span class="lineCov">  163891773 :   lra_assert (r1 &gt;= lra_constraint_new_regno_start</span>
<span class="lineNum">     207 </span>            :               &amp;&amp; r2 &gt;= lra_constraint_new_regno_start);
<span class="lineNum">     208 </span>            : 
<span class="lineNum">     209 </span>            :   /* Prefer to assign reload registers with smaller classes first to
<span class="lineNum">     210 </span>            :      guarantee assignment to all reload registers.  */
<span class="lineNum">     211 </span><span class="lineCov">  327783546 :   if ((diff = (ira_class_hard_regs_num[cl1]</span>
<span class="lineNum">     212 </span><span class="lineCov">  163891773 :                - ira_class_hard_regs_num[cl2])) != 0)</span>
<span class="lineNum">     213 </span>            :     return diff;
<span class="lineNum">     214 </span>            :   /* Allocate bigger pseudos first to avoid register file
<span class="lineNum">     215 </span>            :      fragmentation.  */
<span class="lineNum">     216 </span><span class="lineCov">  311429092 :   if ((diff</span>
<span class="lineNum">     217 </span><span class="lineCov">  311429092 :        = (ira_reg_class_max_nregs[cl2][lra_reg_info[r2].biggest_mode]</span>
<span class="lineNum">     218 </span><span class="lineCov">  155714546 :           - ira_reg_class_max_nregs[cl1][lra_reg_info[r1].biggest_mode])) != 0)</span>
<span class="lineNum">     219 </span>            :     return diff;
<span class="lineNum">     220 </span><span class="lineCov">  308628764 :   if ((diff = (regno_assign_info[regno_assign_info[r2].first].freq</span>
<span class="lineNum">     221 </span><span class="lineCov">  154314382 :                - regno_assign_info[regno_assign_info[r1].first].freq)) != 0)</span>
<span class="lineNum">     222 </span>            :     return diff;
<span class="lineNum">     223 </span>            :   /* Put pseudos from the thread nearby.  */
<span class="lineNum">     224 </span><span class="lineCov">   83901319 :   if ((diff = regno_assign_info[r1].first - regno_assign_info[r2].first) != 0)</span>
<span class="lineNum">     225 </span>            :     return diff;
<span class="lineNum">     226 </span>            :   /* Prefer pseudos with longer live ranges.  It sets up better
<span class="lineNum">     227 </span>            :      prefered hard registers for the thread pseudos and decreases
<span class="lineNum">     228 </span>            :      register-register moves between the thread pseudos.  */
<span class="lineNum">     229 </span><span class="lineCov">   14605037 :   if ((diff = regno_live_length[r2] - regno_live_length[r1]) != 0)</span>
<span class="lineNum">     230 </span>            :     return diff;
<span class="lineNum">     231 </span>            :   /* If regs are equally good, sort by their numbers, so that the
<span class="lineNum">     232 </span>            :      results of qsort leave nothing to chance.  */
<span class="lineNum">     233 </span><span class="lineCov">    7765470 :   return r1 - r2;</span>
<span class="lineNum">     234 </span>            : }
<span class="lineNum">     235 </span>            : 
<span class="lineNum">     236 </span>            : /* The function is used to sort *non-reload* pseudos to try to assign
<span class="lineNum">     237 </span>            :    them hard registers.  The order calculation is simpler than in the
<a name="238"><span class="lineNum">     238 </span>            :    previous function and based on the pseudo frequency usage.  */</a>
<span class="lineNum">     239 </span>            : static int
<span class="lineNum">     240 </span><span class="lineCov">  560464712 : pseudo_compare_func (const void *v1p, const void *v2p)</span>
<span class="lineNum">     241 </span>            : {
<span class="lineNum">     242 </span><span class="lineCov">  560464712 :   int r1 = *(const int *) v1p, r2 = *(const int *) v2p;</span>
<span class="lineNum">     243 </span><span class="lineCov">  560464712 :   int diff;</span>
<span class="lineNum">     244 </span>            : 
<span class="lineNum">     245 </span>            :   /* Assign hard reg to static chain pointer first pseudo when
<span class="lineNum">     246 </span>            :      non-local goto is used.  */
<span class="lineNum">     247 </span><span class="lineCov">  560464712 :   if ((diff = (non_spilled_static_chain_regno_p (r2)</span>
<span class="lineNum">     248 </span><span class="lineCov"> 1120929424 :                - non_spilled_static_chain_regno_p (r1))) != 0)</span>
<span class="lineNum">     249 </span>            :     return diff;
<span class="lineNum">     250 </span>            : 
<span class="lineNum">     251 </span>            :   /* Prefer to assign more frequently used registers first.  */
<span class="lineNum">     252 </span><span class="lineCov">  560461857 :   if ((diff = lra_reg_info[r2].freq - lra_reg_info[r1].freq) != 0)</span>
<span class="lineNum">     253 </span>            :     return diff;
<span class="lineNum">     254 </span>            : 
<span class="lineNum">     255 </span>            :   /* If regs are equally good, sort by their numbers, so that the
<span class="lineNum">     256 </span>            :      results of qsort leave nothing to chance.  */
<span class="lineNum">     257 </span><span class="lineCov">  317039876 :   return r1 - r2;</span>
<span class="lineNum">     258 </span>            : }
<span class="lineNum">     259 </span>            : 
<span class="lineNum">     260 </span>            : /* Arrays of size LRA_LIVE_MAX_POINT mapping a program point to the
<span class="lineNum">     261 </span>            :    pseudo live ranges with given start point.  We insert only live
<span class="lineNum">     262 </span>            :    ranges of pseudos interesting for assignment purposes.  They are
<span class="lineNum">     263 </span>            :    reload pseudos and pseudos assigned to hard registers.  */
<span class="lineNum">     264 </span>            : static lra_live_range_t *start_point_ranges;
<span class="lineNum">     265 </span>            : 
<span class="lineNum">     266 </span>            : /* Used as a flag that a live range is not inserted in the start point
<span class="lineNum">     267 </span>            :    chain.  */
<span class="lineNum">     268 </span>            : static struct lra_live_range not_in_chain_mark;
<span class="lineNum">     269 </span>            : 
<a name="270"><span class="lineNum">     270 </span>            : /* Create and set up START_POINT_RANGES.  */</a>
<span class="lineNum">     271 </span>            : static void
<span class="lineNum">     272 </span><span class="lineCov">     881139 : create_live_range_start_chains (void)</span>
<span class="lineNum">     273 </span>            : {
<span class="lineNum">     274 </span><span class="lineCov">     881139 :   int i, max_regno;</span>
<span class="lineNum">     275 </span><span class="lineCov">     881139 :   lra_live_range_t r;</span>
<span class="lineNum">     276 </span>            : 
<span class="lineNum">     277 </span><span class="lineCov">     881139 :   start_point_ranges = XCNEWVEC (lra_live_range_t, lra_live_max_point);</span>
<span class="lineNum">     278 </span><span class="lineCov">     881139 :   max_regno = max_reg_num ();</span>
<span class="lineNum">     279 </span><span class="lineCov">   55874723 :   for (i = FIRST_PSEUDO_REGISTER; i &lt; max_regno; i++)</span>
<span class="lineNum">     280 </span><span class="lineCov">   54993584 :     if (i &gt;= lra_constraint_new_regno_start || reg_renumber[i] &gt;= 0)</span>
<span class="lineNum">     281 </span>            :       {
<span class="lineNum">     282 </span><span class="lineCov">   58660994 :         for (r = lra_reg_info[i].live_ranges; r != NULL; r = r-&gt;next)</span>
<span class="lineNum">     283 </span>            :           {
<span class="lineNum">     284 </span><span class="lineCov">   30828189 :             r-&gt;start_next = start_point_ranges[r-&gt;start];</span>
<span class="lineNum">     285 </span><span class="lineCov">   30828189 :             start_point_ranges[r-&gt;start] = r;</span>
<span class="lineNum">     286 </span>            :           }
<span class="lineNum">     287 </span>            :       }
<span class="lineNum">     288 </span>            :     else
<span class="lineNum">     289 </span>            :       {
<span class="lineNum">     290 </span><span class="lineCov">   28742276 :         for (r = lra_reg_info[i].live_ranges; r != NULL; r = r-&gt;next)</span>
<span class="lineNum">     291 </span><span class="lineCov">    1581497 :           r-&gt;start_next = &amp;not_in_chain_mark;</span>
<span class="lineNum">     292 </span>            :       }
<span class="lineNum">     293 </span><span class="lineCov">     881139 : }</span>
<span class="lineNum">     294 </span>            : 
<span class="lineNum">     295 </span>            : /* Insert live ranges of pseudo REGNO into start chains if they are
<a name="296"><span class="lineNum">     296 </span>            :    not there yet.  */</a>
<span class="lineNum">     297 </span>            : static void
<span class="lineNum">     298 </span><span class="lineCov">  258269289 : insert_in_live_range_start_chain (int regno)</span>
<span class="lineNum">     299 </span>            : {
<span class="lineNum">     300 </span><span class="lineCov">  258269289 :   lra_live_range_t r = lra_reg_info[regno].live_ranges;</span>
<span class="lineNum">     301 </span>            : 
<span class="lineNum">     302 </span><span class="lineCov">  258269289 :   if (r-&gt;start_next != &amp;not_in_chain_mark)</span>
<span class="lineNum">     303 </span>            :     return;
<span class="lineNum">     304 </span><span class="lineCov">      24244 :   for (; r != NULL; r = r-&gt;next)</span>
<span class="lineNum">     305 </span>            :     {
<span class="lineNum">     306 </span><span class="lineCov">      15409 :       r-&gt;start_next = start_point_ranges[r-&gt;start];</span>
<span class="lineNum">     307 </span><span class="lineCov">      15409 :       start_point_ranges[r-&gt;start] = r;</span>
<span class="lineNum">     308 </span>            :     }
<span class="lineNum">     309 </span>            : }
<span class="lineNum">     310 </span>            : 
<a name="311"><span class="lineNum">     311 </span>            : /* Free START_POINT_RANGES.  */</a>
<span class="lineNum">     312 </span>            : static void
<span class="lineNum">     313 </span><span class="lineCov">     881139 : finish_live_range_start_chains (void)</span>
<span class="lineNum">     314 </span>            : {
<span class="lineNum">     315 </span><span class="lineCov">     881139 :   gcc_assert (start_point_ranges != NULL);</span>
<span class="lineNum">     316 </span><span class="lineCov">     881139 :   free (start_point_ranges);</span>
<span class="lineNum">     317 </span><span class="lineCov">     881139 :   start_point_ranges = NULL;</span>
<span class="lineNum">     318 </span><span class="lineCov">     881139 : }</span>
<span class="lineNum">     319 </span>            : 
<span class="lineNum">     320 </span>            : /* Map: program point -&gt; bitmap of all pseudos living at the point and
<span class="lineNum">     321 </span>            :    assigned to hard registers.  */
<span class="lineNum">     322 </span>            : static bitmap_head *live_hard_reg_pseudos;
<span class="lineNum">     323 </span>            : static bitmap_obstack live_hard_reg_pseudos_bitmap_obstack;
<span class="lineNum">     324 </span>            : 
<span class="lineNum">     325 </span>            : /* reg_renumber corresponding to pseudos marked in
<span class="lineNum">     326 </span>            :    live_hard_reg_pseudos.  reg_renumber might be not matched to
<span class="lineNum">     327 </span>            :    live_hard_reg_pseudos but live_pseudos_reg_renumber always reflects
<span class="lineNum">     328 </span>            :    live_hard_reg_pseudos.  */
<span class="lineNum">     329 </span>            : static int *live_pseudos_reg_renumber;
<span class="lineNum">     330 </span>            : 
<span class="lineNum">     331 </span>            : /* Sparseset used to calculate living hard reg pseudos for some program
<span class="lineNum">     332 </span>            :    point range.  */
<span class="lineNum">     333 </span>            : static sparseset live_range_hard_reg_pseudos;
<span class="lineNum">     334 </span>            : 
<span class="lineNum">     335 </span>            : /* Sparseset used to calculate living reload/inheritance pseudos for
<span class="lineNum">     336 </span>            :    some program point range.  */
<span class="lineNum">     337 </span>            : static sparseset live_range_reload_inheritance_pseudos;
<span class="lineNum">     338 </span>            : 
<span class="lineNum">     339 </span>            : /* Allocate and initialize the data about living pseudos at program
<a name="340"><span class="lineNum">     340 </span>            :    points.  */</a>
<span class="lineNum">     341 </span>            : static void
<span class="lineNum">     342 </span><span class="lineCov">     881139 : init_lives (void)</span>
<span class="lineNum">     343 </span>            : {
<span class="lineNum">     344 </span><span class="lineCov">     881139 :   int i, max_regno = max_reg_num ();</span>
<span class="lineNum">     345 </span>            : 
<span class="lineNum">     346 </span><span class="lineCov">     881139 :   live_range_hard_reg_pseudos = sparseset_alloc (max_regno);</span>
<span class="lineNum">     347 </span><span class="lineCov">     881139 :   live_range_reload_inheritance_pseudos = sparseset_alloc (max_regno);</span>
<span class="lineNum">     348 </span><span class="lineCov">     881139 :   live_hard_reg_pseudos = XNEWVEC (bitmap_head, lra_live_max_point);</span>
<span class="lineNum">     349 </span><span class="lineCov">     881139 :   bitmap_obstack_initialize (&amp;live_hard_reg_pseudos_bitmap_obstack);</span>
<span class="lineNum">     350 </span><span class="lineCov">   47989751 :   for (i = 0; i &lt; lra_live_max_point; i++)</span>
<span class="lineNum">     351 </span><span class="lineCov">   94217224 :     bitmap_initialize (&amp;live_hard_reg_pseudos[i],</span>
<span class="lineNum">     352 </span>            :                        &amp;live_hard_reg_pseudos_bitmap_obstack);
<span class="lineNum">     353 </span><span class="lineCov">     881139 :   live_pseudos_reg_renumber = XNEWVEC (int, max_regno);</span>
<span class="lineNum">     354 </span><span class="lineCov">  123722426 :   for (i = 0; i &lt; max_regno; i++)</span>
<span class="lineNum">     355 </span><span class="lineCov">  122841287 :     live_pseudos_reg_renumber[i] = -1;</span>
<span class="lineNum">     356 </span><span class="lineCov">     881139 : }</span>
<span class="lineNum">     357 </span>            : 
<a name="358"><span class="lineNum">     358 </span>            : /* Free the data about living pseudos at program points.  */</a>
<span class="lineNum">     359 </span>            : static void
<span class="lineNum">     360 </span><span class="lineCov">     881139 : finish_lives (void)</span>
<span class="lineNum">     361 </span>            : {
<span class="lineNum">     362 </span><span class="lineCov">     881139 :   sparseset_free (live_range_hard_reg_pseudos);</span>
<span class="lineNum">     363 </span><span class="lineCov">     881139 :   sparseset_free (live_range_reload_inheritance_pseudos);</span>
<span class="lineNum">     364 </span><span class="lineCov">     881139 :   free (live_hard_reg_pseudos);</span>
<span class="lineNum">     365 </span><span class="lineCov">     881139 :   bitmap_obstack_release (&amp;live_hard_reg_pseudos_bitmap_obstack);</span>
<span class="lineNum">     366 </span><span class="lineCov">     881139 :   free (live_pseudos_reg_renumber);</span>
<span class="lineNum">     367 </span><span class="lineCov">     881139 : }</span>
<span class="lineNum">     368 </span>            : 
<span class="lineNum">     369 </span>            : /* Update the LIVE_HARD_REG_PSEUDOS and LIVE_PSEUDOS_REG_RENUMBER
<span class="lineNum">     370 </span>            :    entries for pseudo REGNO.  Assume that the register has been
<span class="lineNum">     371 </span>            :    spilled if FREE_P, otherwise assume that it has been assigned
<span class="lineNum">     372 </span>            :    reg_renumber[REGNO] (if &gt;= 0).  We also insert the pseudo live
<span class="lineNum">     373 </span>            :    ranges in the start chains when it is assumed to be assigned to a
<span class="lineNum">     374 </span>            :    hard register because we use the chains of pseudos assigned to hard
<a name="375"><span class="lineNum">     375 </span>            :    registers during allocation.  */</a>
<span class="lineNum">     376 </span>            : static void
<span class="lineNum">     377 </span><span class="lineCov">   26797167 : update_lives (int regno, bool free_p)</span>
<span class="lineNum">     378 </span>            : {
<span class="lineNum">     379 </span><span class="lineCov">   26797167 :   int p;</span>
<span class="lineNum">     380 </span><span class="lineCov">   26797167 :   lra_live_range_t r;</span>
<span class="lineNum">     381 </span>            : 
<span class="lineNum">     382 </span><span class="lineCov">   26797167 :   if (reg_renumber[regno] &lt; 0)</span>
<span class="lineNum">     383 </span>            :     return;
<span class="lineNum">     384 </span><span class="lineCov">   26797167 :   live_pseudos_reg_renumber[regno] = free_p ? -1 : reg_renumber[regno];</span>
<span class="lineNum">     385 </span><span class="lineCov">   57815174 :   for (r = lra_reg_info[regno].live_ranges; r != NULL; r = r-&gt;next)</span>
<span class="lineNum">     386 </span>            :     {
<span class="lineNum">     387 </span><span class="lineCov">  326378945 :       for (p = r-&gt;start; p &lt;= r-&gt;finish; p++)</span>
<span class="lineNum">     388 </span><span class="lineCov">  295360938 :         if (free_p)</span>
<span class="lineNum">     389 </span><span class="lineCov">   39554171 :           bitmap_clear_bit (&amp;live_hard_reg_pseudos[p], regno);</span>
<span class="lineNum">     390 </span>            :         else
<span class="lineNum">     391 </span>            :           {
<span class="lineNum">     392 </span><span class="lineCov">  255806767 :             bitmap_set_bit (&amp;live_hard_reg_pseudos[p], regno);</span>
<span class="lineNum">     393 </span><span class="lineCov">  255806767 :             insert_in_live_range_start_chain (regno);</span>
<span class="lineNum">     394 </span>            :           }
<span class="lineNum">     395 </span>            :     }
<span class="lineNum">     396 </span>            : }
<span class="lineNum">     397 </span>            : 
<span class="lineNum">     398 </span>            : /* Sparseset used to calculate reload pseudos conflicting with a given
<span class="lineNum">     399 </span>            :    pseudo when we are trying to find a hard register for the given
<span class="lineNum">     400 </span>            :    pseudo.  */
<span class="lineNum">     401 </span>            : static sparseset conflict_reload_and_inheritance_pseudos;
<span class="lineNum">     402 </span>            : 
<span class="lineNum">     403 </span>            : /* Map: program point -&gt; bitmap of all reload and inheritance pseudos
<span class="lineNum">     404 </span>            :    living at the point.  */
<span class="lineNum">     405 </span>            : static bitmap_head *live_reload_and_inheritance_pseudos;
<span class="lineNum">     406 </span>            : static bitmap_obstack live_reload_and_inheritance_pseudos_bitmap_obstack;
<span class="lineNum">     407 </span>            : 
<span class="lineNum">     408 </span>            : /* Allocate and initialize data about living reload pseudos at any
<a name="409"><span class="lineNum">     409 </span>            :    given program point.  */</a>
<span class="lineNum">     410 </span>            : static void
<span class="lineNum">     411 </span><span class="lineCov">     881139 : init_live_reload_and_inheritance_pseudos (void)</span>
<span class="lineNum">     412 </span>            : {
<span class="lineNum">     413 </span><span class="lineCov">     881139 :   int i, p, max_regno = max_reg_num ();</span>
<span class="lineNum">     414 </span><span class="lineCov">     881139 :   lra_live_range_t r;</span>
<span class="lineNum">     415 </span>            : 
<span class="lineNum">     416 </span><span class="lineCov">     881139 :   conflict_reload_and_inheritance_pseudos = sparseset_alloc (max_regno);</span>
<span class="lineNum">     417 </span><span class="lineCov">     881139 :   live_reload_and_inheritance_pseudos = XNEWVEC (bitmap_head, lra_live_max_point);</span>
<span class="lineNum">     418 </span><span class="lineCov">     881139 :   bitmap_obstack_initialize (&amp;live_reload_and_inheritance_pseudos_bitmap_obstack);</span>
<span class="lineNum">     419 </span><span class="lineCov">   47989751 :   for (p = 0; p &lt; lra_live_max_point; p++)</span>
<span class="lineNum">     420 </span><span class="lineCov">   94217224 :     bitmap_initialize (&amp;live_reload_and_inheritance_pseudos[p],</span>
<span class="lineNum">     421 </span>            :                        &amp;live_reload_and_inheritance_pseudos_bitmap_obstack);
<span class="lineNum">     422 </span><span class="lineCov">    8704353 :   for (i = lra_constraint_new_regno_start; i &lt; max_regno; i++)</span>
<span class="lineNum">     423 </span>            :     {
<span class="lineNum">     424 </span><span class="lineCov">   15068761 :       for (r = lra_reg_info[i].live_ranges; r != NULL; r = r-&gt;next)</span>
<span class="lineNum">     425 </span><span class="lineCov">  671282465 :         for (p = r-&gt;start; p &lt;= r-&gt;finish; p++)</span>
<span class="lineNum">     426 </span><span class="lineCov">  664036918 :           bitmap_set_bit (&amp;live_reload_and_inheritance_pseudos[p], i);</span>
<span class="lineNum">     427 </span>            :     }
<span class="lineNum">     428 </span><span class="lineCov">     881139 : }</span>
<span class="lineNum">     429 </span>            : 
<span class="lineNum">     430 </span>            : /* Finalize data about living reload pseudos at any given program
<a name="431"><span class="lineNum">     431 </span>            :    point.  */</a>
<span class="lineNum">     432 </span>            : static void
<span class="lineNum">     433 </span><span class="lineCov">     881139 : finish_live_reload_and_inheritance_pseudos (void)</span>
<span class="lineNum">     434 </span>            : {
<span class="lineNum">     435 </span><span class="lineCov">     881139 :   sparseset_free (conflict_reload_and_inheritance_pseudos);</span>
<span class="lineNum">     436 </span><span class="lineCov">     881139 :   free (live_reload_and_inheritance_pseudos);</span>
<span class="lineNum">     437 </span><span class="lineCov">     881139 :   bitmap_obstack_release (&amp;live_reload_and_inheritance_pseudos_bitmap_obstack);</span>
<span class="lineNum">     438 </span><span class="lineCov">     881139 : }</span>
<span class="lineNum">     439 </span>            : 
<span class="lineNum">     440 </span>            : /* The value used to check that cost of given hard reg is really
<span class="lineNum">     441 </span>            :    defined currently.  */
<span class="lineNum">     442 </span>            : static int curr_hard_regno_costs_check = 0;
<span class="lineNum">     443 </span>            : /* Array used to check that cost of the corresponding hard reg (the
<span class="lineNum">     444 </span>            :    array element index) is really defined currently.  */
<span class="lineNum">     445 </span>            : static int hard_regno_costs_check[FIRST_PSEUDO_REGISTER];
<span class="lineNum">     446 </span>            : /* The current costs of allocation of hard regs.  Defined only if the
<span class="lineNum">     447 </span>            :    value of the corresponding element of the previous array is equal to
<span class="lineNum">     448 </span>            :    CURR_HARD_REGNO_COSTS_CHECK.  */
<span class="lineNum">     449 </span>            : static int hard_regno_costs[FIRST_PSEUDO_REGISTER];
<span class="lineNum">     450 </span>            : 
<span class="lineNum">     451 </span>            : /* Adjust cost of HARD_REGNO by INCR.  Reset the cost first if it is
<span class="lineNum">     452 </span>            :    not defined yet.  */
<span class="lineNum">     453 </span>            : static inline void
<span class="lineNum">     454 </span>            : adjust_hard_regno_cost (int hard_regno, int incr)
<span class="lineNum">     455 </span>            : {
<span class="lineNum">     456 </span><span class="lineCov">   48434682 :   if (hard_regno_costs_check[hard_regno] != curr_hard_regno_costs_check)</span>
<span class="lineNum">     457 </span><span class="lineCov">    6276792 :     hard_regno_costs[hard_regno] = 0;</span>
<span class="lineNum">     458 </span><span class="lineCov">   48434682 :   hard_regno_costs_check[hard_regno] = curr_hard_regno_costs_check;</span>
<span class="lineNum">     459 </span><span class="lineCov">   11256477 :   hard_regno_costs[hard_regno] += incr;</span>
<span class="lineNum">     460 </span>            : }
<span class="lineNum">     461 </span>            : 
<span class="lineNum">     462 </span>            : /* Try to find a free hard register for pseudo REGNO.  Return the
<span class="lineNum">     463 </span>            :    hard register on success and set *COST to the cost of using
<span class="lineNum">     464 </span>            :    that register.  (If several registers have equal cost, the one with
<span class="lineNum">     465 </span>            :    the highest priority wins.)  Return -1 on failure.
<span class="lineNum">     466 </span>            : 
<span class="lineNum">     467 </span>            :    If FIRST_P, return the first available hard reg ignoring other
<span class="lineNum">     468 </span>            :    criteria, e.g. allocation cost.  This approach results in less hard
<span class="lineNum">     469 </span>            :    reg pool fragmentation and permit to allocate hard regs to reload
<span class="lineNum">     470 </span>            :    pseudos in complicated situations where pseudo sizes are different.
<span class="lineNum">     471 </span>            : 
<span class="lineNum">     472 </span>            :    If TRY_ONLY_HARD_REGNO &gt;= 0, consider only that hard register,
<span class="lineNum">     473 </span>            :    otherwise consider all hard registers in REGNO's class.
<span class="lineNum">     474 </span>            : 
<span class="lineNum">     475 </span>            :    If REGNO_SET is not empty, only hard registers from the set are
<a name="476"><span class="lineNum">     476 </span>            :    considered.  */</a>
<span class="lineNum">     477 </span>            : static int
<span class="lineNum">     478 </span><span class="lineCov">    8114253 : find_hard_regno_for_1 (int regno, int *cost, int try_only_hard_regno,</span>
<span class="lineNum">     479 </span>            :                        bool first_p, HARD_REG_SET regno_set)
<span class="lineNum">     480 </span>            : {
<span class="lineNum">     481 </span><span class="lineCov">    8114253 :   HARD_REG_SET conflict_set;</span>
<span class="lineNum">     482 </span><span class="lineCov">    8114253 :   int best_cost = INT_MAX, best_priority = INT_MIN, best_usage = INT_MAX;</span>
<span class="lineNum">     483 </span><span class="lineCov">    8114253 :   lra_live_range_t r;</span>
<span class="lineNum">     484 </span><span class="lineCov">    8114253 :   int p, i, j, rclass_size, best_hard_regno, priority, hard_regno;</span>
<span class="lineNum">     485 </span><span class="lineCov">    8114253 :   int hr, conflict_hr, nregs;</span>
<span class="lineNum">     486 </span><span class="lineCov">    8114253 :   machine_mode biggest_mode;</span>
<span class="lineNum">     487 </span><span class="lineCov">    8114253 :   unsigned int k, conflict_regno;</span>
<span class="lineNum">     488 </span><span class="lineCov">    8114253 :   poly_int64 offset;</span>
<span class="lineNum">     489 </span><span class="lineCov">    8114253 :   int val, biggest_nregs, nregs_diff;</span>
<span class="lineNum">     490 </span><span class="lineCov">    8114253 :   enum reg_class rclass;</span>
<span class="lineNum">     491 </span><span class="lineCov">    8114253 :   bitmap_iterator bi;</span>
<span class="lineNum">     492 </span><span class="lineCov">    8114253 :   bool *rclass_intersect_p;</span>
<span class="lineNum">     493 </span><span class="lineCov">    8114253 :   HARD_REG_SET impossible_start_hard_regs, available_regs;</span>
<span class="lineNum">     494 </span>            : 
<span class="lineNum">     495 </span><span class="lineCov">    8114253 :   if (hard_reg_set_empty_p (regno_set))</span>
<span class="lineNum">     496 </span><span class="lineCov">    7992874 :     COPY_HARD_REG_SET (conflict_set, lra_no_alloc_regs);</span>
<span class="lineNum">     497 </span>            :   else
<span class="lineNum">     498 </span>            :     {
<span class="lineNum">     499 </span><span class="lineCov">     121379 :       COMPL_HARD_REG_SET (conflict_set, regno_set);</span>
<span class="lineNum">     500 </span><span class="lineCov">     121379 :       IOR_HARD_REG_SET (conflict_set, lra_no_alloc_regs);</span>
<span class="lineNum">     501 </span>            :     }
<span class="lineNum">     502 </span><span class="lineCov">    8114253 :   rclass = regno_allocno_class_array[regno];</span>
<span class="lineNum">     503 </span><span class="lineCov">    8114253 :   rclass_intersect_p = ira_reg_classes_intersect_p[rclass];</span>
<span class="lineNum">     504 </span><span class="lineCov">    8114253 :   curr_hard_regno_costs_check++;</span>
<span class="lineNum">     505 </span><span class="lineCov">    8114253 :   sparseset_clear (conflict_reload_and_inheritance_pseudos);</span>
<span class="lineNum">     506 </span><span class="lineCov">    8114253 :   sparseset_clear (live_range_hard_reg_pseudos);</span>
<span class="lineNum">     507 </span><span class="lineCov">    8114253 :   IOR_HARD_REG_SET (conflict_set, lra_reg_info[regno].conflict_hard_regs);</span>
<span class="lineNum">     508 </span><span class="lineCov">    8114253 :   biggest_mode = lra_reg_info[regno].biggest_mode;</span>
<span class="lineNum">     509 </span><span class="lineCov">   17167882 :   for (r = lra_reg_info[regno].live_ranges; r != NULL; r = r-&gt;next)</span>
<span class="lineNum">     510 </span>            :     {
<span class="lineNum">     511 </span><span class="lineCov">   65576531 :       EXECUTE_IF_SET_IN_BITMAP (&amp;live_hard_reg_pseudos[r-&gt;start], 0, k, bi)</span>
<span class="lineNum">     512 </span><span class="lineCov">   56522902 :         if (rclass_intersect_p[regno_allocno_class_array[k]])</span>
<span class="lineNum">     513 </span><span class="lineCov">   50966978 :           sparseset_set_bit (live_range_hard_reg_pseudos, k);</span>
<span class="lineNum">     514 </span><span class="lineCov">  275844427 :       EXECUTE_IF_SET_IN_BITMAP (&amp;live_reload_and_inheritance_pseudos[r-&gt;start],</span>
<span class="lineNum">     515 </span>            :                                 0, k, bi)
<span class="lineNum">     516 </span><span class="lineCov">  266790798 :         if (lra_reg_info[k].preferred_hard_regno1 &gt;= 0</span>
<span class="lineNum">     517 </span><span class="lineCov">  226760679 :             &amp;&amp; live_pseudos_reg_renumber[k] &lt; 0</span>
<span class="lineNum">     518 </span><span class="lineCov">  225033884 :             &amp;&amp; rclass_intersect_p[regno_allocno_class_array[k]])</span>
<span class="lineNum">     519 </span><span class="lineCov">  223583491 :           sparseset_set_bit (conflict_reload_and_inheritance_pseudos, k);</span>
<span class="lineNum">     520 </span><span class="lineCov"> 1778053965 :       for (p = r-&gt;start + 1; p &lt;= r-&gt;finish; p++)</span>
<span class="lineNum">     521 </span>            :         {
<span class="lineNum">     522 </span><span class="lineCov"> 1769000336 :           lra_live_range_t r2;</span>
<span class="lineNum">     523 </span>            : 
<span class="lineNum">     524 </span><span class="lineCov"> 1769000336 :           for (r2 = start_point_ranges[p];</span>
<span class="lineNum">     525 </span><span class="lineCov"> 2982951851 :                r2 != NULL;</span>
<span class="lineNum">     526 </span><span class="lineCov"> 1213951515 :                r2 = r2-&gt;start_next)</span>
<span class="lineNum">     527 </span>            :             {
<span class="lineNum">     528 </span><span class="lineCov"> 1213951515 :               if (r2-&gt;regno &gt;= lra_constraint_new_regno_start</span>
<span class="lineNum">     529 </span><span class="lineCov">  447335049 :                   &amp;&amp; lra_reg_info[r2-&gt;regno].preferred_hard_regno1 &gt;= 0</span>
<span class="lineNum">     530 </span><span class="lineCov">  283662784 :                   &amp;&amp; live_pseudos_reg_renumber[r2-&gt;regno] &lt; 0</span>
<span class="lineNum">     531 </span><span class="lineCov">  200649608 :                   &amp;&amp; rclass_intersect_p[regno_allocno_class_array[r2-&gt;regno]])</span>
<span class="lineNum">     532 </span><span class="lineCov">  194943967 :                 sparseset_set_bit (conflict_reload_and_inheritance_pseudos,</span>
<span class="lineNum">     533 </span>            :                                    r2-&gt;regno);
<span class="lineNum">     534 </span><span class="lineCov"> 1213951515 :               if (live_pseudos_reg_renumber[r2-&gt;regno] &gt;= 0</span>
<span class="lineNum">     535 </span><span class="lineCov">  982170770 :                   &amp;&amp; rclass_intersect_p[regno_allocno_class_array[r2-&gt;regno]])</span>
<span class="lineNum">     536 </span><span class="lineCov">  927710716 :                 sparseset_set_bit (live_range_hard_reg_pseudos, r2-&gt;regno);</span>
<span class="lineNum">     537 </span>            :             }
<span class="lineNum">     538 </span>            :         }
<span class="lineNum">     539 </span>            :     }
<span class="lineNum">     540 </span><span class="lineCov">    8114253 :   if ((hard_regno = lra_reg_info[regno].preferred_hard_regno1) &gt;= 0)</span>
<span class="lineNum">     541 </span>            :     {
<span class="lineNum">     542 </span><span class="lineCov">    3125525 :       adjust_hard_regno_cost</span>
<span class="lineNum">     543 </span><span class="lineCov">    3125525 :         (hard_regno, -lra_reg_info[regno].preferred_hard_regno_profit1);</span>
<span class="lineNum">     544 </span><span class="lineCov">    3125525 :       if ((hard_regno = lra_reg_info[regno].preferred_hard_regno2) &gt;= 0)</span>
<span class="lineNum">     545 </span><span class="lineCov">     578479 :         adjust_hard_regno_cost</span>
<span class="lineNum">     546 </span><span class="lineCov">     578479 :           (hard_regno, -lra_reg_info[regno].preferred_hard_regno_profit2);</span>
<span class="lineNum">     547 </span>            :     }
<span class="lineNum">     548 </span>            : #ifdef STACK_REGS
<span class="lineNum">     549 </span><span class="lineCov">    8114253 :   if (lra_reg_info[regno].no_stack_p)</span>
<span class="lineNum">     550 </span><span class="lineCov">     220131 :     for (i = FIRST_STACK_REG; i &lt;= LAST_STACK_REG; i++)</span>
<span class="lineNum">     551 </span><span class="lineCov">     195672 :       SET_HARD_REG_BIT (conflict_set, i);</span>
<span class="lineNum">     552 </span>            : #endif
<span class="lineNum">     553 </span><span class="lineCov">    8114253 :   sparseset_clear_bit (conflict_reload_and_inheritance_pseudos, regno);</span>
<span class="lineNum">     554 </span><span class="lineCov">    8114253 :   val = lra_reg_info[regno].val;</span>
<span class="lineNum">     555 </span><span class="lineCov">    8114253 :   offset = lra_reg_info[regno].offset;</span>
<span class="lineNum">     556 </span><span class="lineCov">    8114253 :   CLEAR_HARD_REG_SET (impossible_start_hard_regs);</span>
<span class="lineNum">     557 </span><span class="lineCov">  197287916 :   EXECUTE_IF_SET_IN_SPARSESET (live_range_hard_reg_pseudos, conflict_regno)</span>
<span class="lineNum">     558 </span>            :     {
<span class="lineNum">     559 </span><span class="lineCov">   95822751 :       conflict_hr = live_pseudos_reg_renumber[conflict_regno];</span>
<span class="lineNum">     560 </span><span class="lineCov">   95822751 :       if (lra_reg_val_equal_p (conflict_regno, val, offset))</span>
<span class="lineNum">     561 </span>            :         {
<span class="lineNum">     562 </span><span class="lineCov">     575283 :           conflict_hr = live_pseudos_reg_renumber[conflict_regno];</span>
<span class="lineNum">     563 </span><span class="lineCov">    1725849 :           nregs = hard_regno_nregs (conflict_hr,</span>
<span class="lineNum">     564 </span><span class="lineCov">     575283 :                                     lra_reg_info[conflict_regno].biggest_mode);</span>
<span class="lineNum">     565 </span>            :           /* Remember about multi-register pseudos.  For example, 2
<span class="lineNum">     566 </span>            :              hard register pseudos can start on the same hard register
<span class="lineNum">     567 </span>            :              but can not start on HR and HR+1/HR-1.  */
<span class="lineNum">     568 </span><span class="lineCov">     575283 :           for (hr = conflict_hr + 1;</span>
<span class="lineNum">     569 </span><span class="lineCov">     589624 :                hr &lt; FIRST_PSEUDO_REGISTER &amp;&amp; hr &lt; conflict_hr + nregs;</span>
<span class="lineNum">     570 </span>            :                hr++)
<span class="lineNum">     571 </span><span class="lineCov">      14341 :             SET_HARD_REG_BIT (impossible_start_hard_regs, hr);</span>
<span class="lineNum">     572 </span><span class="lineCov">     575283 :           for (hr = conflict_hr - 1;</span>
<span class="lineNum">     573 </span><span class="lineCov">     585379 :                hr &gt;= 0 &amp;&amp; (int) end_hard_regno (biggest_mode, hr) &gt; conflict_hr;</span>
<span class="lineNum">     574 </span>            :                hr--)
<span class="lineNum">     575 </span><span class="lineCov">      10096 :             SET_HARD_REG_BIT (impossible_start_hard_regs, hr);</span>
<span class="lineNum">     576 </span>            :         }
<span class="lineNum">     577 </span>            :       else
<span class="lineNum">     578 </span>            :         {
<span class="lineNum">     579 </span><span class="lineCov">  190494936 :           machine_mode biggest_conflict_mode</span>
<span class="lineNum">     580 </span><span class="lineCov">   95247468 :             = lra_reg_info[conflict_regno].biggest_mode;</span>
<span class="lineNum">     581 </span><span class="lineCov">   95247468 :           int biggest_conflict_nregs</span>
<span class="lineNum">     582 </span><span class="lineCov">   95247468 :             = hard_regno_nregs (conflict_hr, biggest_conflict_mode);</span>
<span class="lineNum">     583 </span>            :           
<span class="lineNum">     584 </span><span class="lineCov">   95247468 :           nregs_diff</span>
<span class="lineNum">     585 </span><span class="lineCov">   95247468 :             = (biggest_conflict_nregs</span>
<span class="lineNum">     586 </span><span class="lineCov">  190494936 :                - hard_regno_nregs (conflict_hr,</span>
<span class="lineNum">     587 </span><span class="lineCov">   95247468 :                                    PSEUDO_REGNO_MODE (conflict_regno)));</span>
<span class="lineNum">     588 </span><span class="lineCov">   95247468 :           add_to_hard_reg_set (&amp;conflict_set,</span>
<span class="lineNum">     589 </span>            :                                biggest_conflict_mode,
<span class="lineNum">     590 </span>            :                                conflict_hr
<span class="lineNum">     591 </span>            :                                - (WORDS_BIG_ENDIAN ? nregs_diff : 0));
<span class="lineNum">     592 </span><span class="lineCov">   95247468 :           if (hard_reg_set_subset_p (reg_class_contents[rclass],</span>
<span class="lineNum">     593 </span>            :                                      conflict_set))
<span class="lineNum">     594 </span>            :             return -1;
<span class="lineNum">     595 </span>            :         }
<span class="lineNum">     596 </span>            :     }
<span class="lineNum">     597 </span><span class="lineCov">   39882166 :   EXECUTE_IF_SET_IN_SPARSESET (conflict_reload_and_inheritance_pseudos,</span>
<span class="lineNum">     598 </span>            :                                conflict_regno)
<span class="lineNum">     599 </span><span class="lineCov">   34239752 :     if (!lra_reg_val_equal_p (conflict_regno, val, offset))</span>
<span class="lineNum">     600 </span>            :       {
<span class="lineNum">     601 </span><span class="lineCov">   34052680 :         lra_assert (live_pseudos_reg_renumber[conflict_regno] &lt; 0);</span>
<span class="lineNum">     602 </span><span class="lineCov">   68105360 :         if ((hard_regno</span>
<span class="lineNum">     603 </span><span class="lineCov">   34052680 :              = lra_reg_info[conflict_regno].preferred_hard_regno1) &gt;= 0)</span>
<span class="lineNum">     604 </span>            :           {
<span class="lineNum">     605 </span><span class="lineCov">   34052680 :             adjust_hard_regno_cost</span>
<span class="lineNum">     606 </span><span class="lineCov">   34052680 :               (hard_regno,</span>
<span class="lineNum">     607 </span>            :                lra_reg_info[conflict_regno].preferred_hard_regno_profit1);
<span class="lineNum">     608 </span><span class="lineCov">   68105360 :             if ((hard_regno</span>
<span class="lineNum">     609 </span><span class="lineCov">   34052680 :                  = lra_reg_info[conflict_regno].preferred_hard_regno2) &gt;= 0)</span>
<span class="lineNum">     610 </span><span class="lineCov">   10677998 :               adjust_hard_regno_cost</span>
<span class="lineNum">     611 </span><span class="lineCov">   10677998 :                 (hard_regno,</span>
<span class="lineNum">     612 </span>            :                  lra_reg_info[conflict_regno].preferred_hard_regno_profit2);
<span class="lineNum">     613 </span>            :           }
<span class="lineNum">     614 </span>            :       }
<span class="lineNum">     615 </span>            :   /* Make sure that all registers in a multi-word pseudo belong to the
<span class="lineNum">     616 </span>            :      required class.  */
<span class="lineNum">     617 </span><span class="lineCov">    5642414 :   IOR_COMPL_HARD_REG_SET (conflict_set, reg_class_contents[rclass]);</span>
<span class="lineNum">     618 </span><span class="lineCov">    5642414 :   lra_assert (rclass != NO_REGS);</span>
<span class="lineNum">     619 </span><span class="lineCov">    5642414 :   rclass_size = ira_class_hard_regs_num[rclass];</span>
<span class="lineNum">     620 </span><span class="lineCov">    5642414 :   best_hard_regno = -1;</span>
<span class="lineNum">     621 </span><span class="lineCov">    5642414 :   hard_regno = ira_class_hard_regs[rclass][0];</span>
<span class="lineNum">     622 </span><span class="lineCov">    5642414 :   biggest_nregs = hard_regno_nregs (hard_regno, biggest_mode);</span>
<span class="lineNum">     623 </span><span class="lineCov">   11284828 :   nregs_diff = (biggest_nregs</span>
<span class="lineNum">     624 </span><span class="lineCov">    5642414 :                 - hard_regno_nregs (hard_regno, PSEUDO_REGNO_MODE (regno)));</span>
<span class="lineNum">     625 </span><span class="lineCov">    5642414 :   COPY_HARD_REG_SET (available_regs, reg_class_contents[rclass]);</span>
<span class="lineNum">     626 </span><span class="lineCov">    5642414 :   AND_COMPL_HARD_REG_SET (available_regs, lra_no_alloc_regs);</span>
<span class="lineNum">     627 </span><span class="lineCov">   71800463 :   for (i = 0; i &lt; rclass_size; i++)</span>
<span class="lineNum">     628 </span>            :     {
<span class="lineNum">     629 </span><span class="lineCov">   66211012 :       if (try_only_hard_regno &gt;= 0)</span>
<span class="lineNum">     630 </span>            :         hard_regno = try_only_hard_regno;
<span class="lineNum">     631 </span>            :       else
<span class="lineNum">     632 </span><span class="lineCov">   66158180 :         hard_regno = ira_class_hard_regs[rclass][i];</span>
<span class="lineNum">     633 </span><span class="lineCov">  132422024 :       if (! overlaps_hard_reg_set_p (conflict_set,</span>
<span class="lineNum">     634 </span><span class="lineCov">   66211012 :                                      PSEUDO_REGNO_MODE (regno), hard_regno)</span>
<span class="lineNum">     635 </span><span class="lineCov">   37612684 :           &amp;&amp; targetm.hard_regno_mode_ok (hard_regno,</span>
<span class="lineNum">     636 </span>            :                                          PSEUDO_REGNO_MODE (regno))
<span class="lineNum">     637 </span>            :           /* We can not use prohibited_class_mode_regs for all classes
<span class="lineNum">     638 </span>            :              because it is not defined for all classes.  */
<span class="lineNum">     639 </span><span class="lineCov">   37555869 :           &amp;&amp; (ira_allocno_class_translate[rclass] != rclass</span>
<span class="lineNum">     640 </span><span class="lineCov">   22730450 :               || ! TEST_HARD_REG_BIT (ira_prohibited_class_mode_regs</span>
<span class="lineNum">     641 </span>            :                                       [rclass][PSEUDO_REGNO_MODE (regno)],
<span class="lineNum">     642 </span>            :                                       hard_regno))
<span class="lineNum">     643 </span><span class="lineCov">   37555869 :           &amp;&amp; ! TEST_HARD_REG_BIT (impossible_start_hard_regs, hard_regno)</span>
<span class="lineNum">     644 </span><span class="lineCov">  103762270 :           &amp;&amp; (nregs_diff == 0</span>
<span class="lineNum">     645 </span><span class="lineCov">       5173 :               || (WORDS_BIG_ENDIAN</span>
<span class="lineNum">     646 </span>            :                   ? (hard_regno - nregs_diff &gt;= 0
<span class="lineNum">     647 </span>            :                      &amp;&amp; TEST_HARD_REG_BIT (available_regs,
<span class="lineNum">     648 </span>            :                                            hard_regno - nregs_diff))
<span class="lineNum">     649 </span><span class="lineCov">       5173 :                   : TEST_HARD_REG_BIT (available_regs,</span>
<span class="lineNum">     650 </span>            :                                        hard_regno + nregs_diff))))
<span class="lineNum">     651 </span>            :         {
<span class="lineNum">     652 </span><span class="lineCov">   75100826 :           if (hard_regno_costs_check[hard_regno]</span>
<span class="lineNum">     653 </span><span class="lineCov">   37550413 :               != curr_hard_regno_costs_check)</span>
<span class="lineNum">     654 </span>            :             {
<span class="lineNum">     655 </span><span class="lineCov">   34284304 :               hard_regno_costs_check[hard_regno] = curr_hard_regno_costs_check;</span>
<span class="lineNum">     656 </span><span class="lineCov">   34284304 :               hard_regno_costs[hard_regno] = 0;</span>
<span class="lineNum">     657 </span>            :             }
<span class="lineNum">     658 </span><span class="lineCov">   38231546 :           for (j = 0;</span>
<span class="lineNum">     659 </span><span class="lineCov">  151563918 :                j &lt; hard_regno_nregs (hard_regno, PSEUDO_REGNO_MODE (regno));</span>
<span class="lineNum">     660 </span>            :                j++)
<span class="lineNum">     661 </span><span class="lineCov">   38231546 :             if (! TEST_HARD_REG_BIT (call_used_reg_set, hard_regno + j)</span>
<span class="lineNum">     662 </span><span class="lineCov">   38231546 :                 &amp;&amp; ! df_regs_ever_live_p (hard_regno + j))</span>
<span class="lineNum">     663 </span>            :               /* It needs save restore.  */
<span class="lineNum">     664 </span><span class="lineCov">    3024252 :               hard_regno_costs[hard_regno]</span>
<span class="lineNum">     665 </span><span class="lineCov">    3024252 :                 += (2</span>
<span class="lineNum">     666 </span><span class="lineCov">    8708263 :                     * REG_FREQ_FROM_BB (ENTRY_BLOCK_PTR_FOR_FN (cfun)-&gt;next_bb)</span>
<span class="lineNum">     667 </span><span class="lineCov">    8708263 :                     + 1);</span>
<span class="lineNum">     668 </span><span class="lineCov">   37550413 :           priority = targetm.register_priority (hard_regno);</span>
<span class="lineNum">     669 </span><span class="lineCov">   32026931 :           if (best_hard_regno &lt; 0 || hard_regno_costs[hard_regno] &lt; best_cost</span>
<span class="lineNum">     670 </span><span class="lineCov">   68360699 :               || (hard_regno_costs[hard_regno] == best_cost</span>
<span class="lineNum">     671 </span><span class="lineCov">   16501729 :                   &amp;&amp; (priority &gt; best_priority</span>
<span class="lineNum">     672 </span><span class="lineCov">   16469383 :                       || (targetm.register_usage_leveling_p ()</span>
<span class="lineNum">     673 </span><span class="lineCov">   16469383 :                           &amp;&amp; priority == best_priority</span>
<span class="lineNum">     674 </span><span class="lineCov">    4692796 :                           &amp;&amp; best_usage &gt; lra_hard_reg_usage[hard_regno]))))</span>
<span class="lineNum">     675 </span>            :             {
<span class="lineNum">     676 </span><span class="lineCov">    8500520 :               best_hard_regno = hard_regno;</span>
<span class="lineNum">     677 </span><span class="lineCov">    8500520 :               best_cost = hard_regno_costs[hard_regno];</span>
<span class="lineNum">     678 </span><span class="lineCov">    8500520 :               best_priority = priority;</span>
<span class="lineNum">     679 </span><span class="lineCov">    8500520 :               best_usage = lra_hard_reg_usage[hard_regno];</span>
<span class="lineNum">     680 </span>            :             }
<span class="lineNum">     681 </span>            :         }
<span class="lineNum">     682 </span><span class="lineCov">   66211012 :       if (try_only_hard_regno &gt;= 0 || (first_p &amp;&amp; best_hard_regno &gt;= 0))</span>
<span class="lineNum">     683 </span>            :         break;
<span class="lineNum">     684 </span>            :     }
<span class="lineNum">     685 </span><span class="lineCov">    5642414 :   if (best_hard_regno &gt;= 0)</span>
<span class="lineNum">     686 </span><span class="lineCov">    5523482 :     *cost = best_cost - lra_reg_info[regno].freq;</span>
<span class="lineNum">     687 </span>            :   return best_hard_regno;
<span class="lineNum">     688 </span>            : }
<span class="lineNum">     689 </span>            : 
<span class="lineNum">     690 </span>            : /* A wrapper for find_hard_regno_for_1 (see comments for that function
<span class="lineNum">     691 </span>            :    description).  This function tries to find a hard register for
<a name="692"><span class="lineNum">     692 </span>            :    preferred class first if it is worth.  */</a>
<span class="lineNum">     693 </span>            : static int
<span class="lineNum">     694 </span><span class="lineCov">    7993432 : find_hard_regno_for (int regno, int *cost, int try_only_hard_regno, bool first_p)</span>
<span class="lineNum">     695 </span>            : {
<span class="lineNum">     696 </span><span class="lineCov">    7993432 :   int hard_regno;</span>
<span class="lineNum">     697 </span><span class="lineCov">    7993432 :   HARD_REG_SET regno_set;</span>
<span class="lineNum">     698 </span>            : 
<span class="lineNum">     699 </span>            :   /* Only original pseudos can have a different preferred class.  */
<span class="lineNum">     700 </span><span class="lineCov">    7993432 :   if (try_only_hard_regno &lt; 0 &amp;&amp; regno &lt; lra_new_regno_start)</span>
<span class="lineNum">     701 </span>            :     {
<span class="lineNum">     702 </span><span class="lineCov">     716265 :       enum reg_class pref_class = reg_preferred_class (regno);</span>
<span class="lineNum">     703 </span>            :       
<span class="lineNum">     704 </span><span class="lineCov">     716265 :       if (regno_allocno_class_array[regno] != pref_class)</span>
<span class="lineNum">     705 </span>            :         {
<span class="lineNum">     706 </span><span class="lineCov">     364137 :           hard_regno = find_hard_regno_for_1 (regno, cost, -1, first_p,</span>
<span class="lineNum">     707 </span><span class="lineCov">     121379 :                                               reg_class_contents[pref_class]);</span>
<span class="lineNum">     708 </span><span class="lineCov">     121379 :           if (hard_regno &gt;= 0)</span>
<span class="lineNum">     709 </span>            :             return hard_regno;
<span class="lineNum">     710 </span>            :         }
<span class="lineNum">     711 </span>            :     }
<span class="lineNum">     712 </span><span class="lineCov">    7992874 :   CLEAR_HARD_REG_SET (regno_set);</span>
<span class="lineNum">     713 </span><span class="lineCov">    7992874 :   return find_hard_regno_for_1 (regno, cost, try_only_hard_regno, first_p,</span>
<span class="lineNum">     714 </span><span class="lineCov">    7992874 :                                 regno_set);</span>
<span class="lineNum">     715 </span>            : }
<span class="lineNum">     716 </span>            : 
<span class="lineNum">     717 </span>            : /* Current value used for checking elements in
<span class="lineNum">     718 </span>            :    update_hard_regno_preference_check.  */
<span class="lineNum">     719 </span>            : static int curr_update_hard_regno_preference_check;
<span class="lineNum">     720 </span>            : /* If an element value is equal to the above variable value, then the
<span class="lineNum">     721 </span>            :    corresponding regno has been processed for preference
<span class="lineNum">     722 </span>            :    propagation.  */
<span class="lineNum">     723 </span>            : static int *update_hard_regno_preference_check;
<span class="lineNum">     724 </span>            : 
<span class="lineNum">     725 </span>            : /* Update the preference for using HARD_REGNO for pseudos that are
<span class="lineNum">     726 </span>            :    connected directly or indirectly with REGNO.  Apply divisor DIV
<span class="lineNum">     727 </span>            :    to any preference adjustments.
<span class="lineNum">     728 </span>            : 
<span class="lineNum">     729 </span>            :    The more indirectly a pseudo is connected, the smaller its effect
<a name="730"><span class="lineNum">     730 </span>            :    should be.  We therefore increase DIV on each &quot;hop&quot;.  */</a>
<span class="lineNum">     731 </span>            : static void
<span class="lineNum">     732 </span><span class="lineCov">    6287476 : update_hard_regno_preference (int regno, int hard_regno, int div)</span>
<span class="lineNum">     733 </span>            : {
<span class="lineNum">     734 </span><span class="lineCov">    6287476 :   int another_regno, cost;</span>
<span class="lineNum">     735 </span><span class="lineCov">    6287476 :   lra_copy_t cp, next_cp;</span>
<span class="lineNum">     736 </span>            : 
<span class="lineNum">     737 </span>            :   /* Search depth 5 seems to be enough.  */
<span class="lineNum">     738 </span><span class="lineCov">    6287476 :   if (div &gt; (1 &lt;&lt; 5))</span>
<span class="lineNum">     739 </span>            :     return;
<span class="lineNum">     740 </span><span class="lineCov">   11538305 :   for (cp = lra_reg_info[regno].copies; cp != NULL; cp = next_cp)</span>
<span class="lineNum">     741 </span>            :     {
<span class="lineNum">     742 </span><span class="lineCov">    5333354 :       if (cp-&gt;regno1 == regno)</span>
<span class="lineNum">     743 </span>            :         {
<span class="lineNum">     744 </span><span class="lineCov">    2440332 :           next_cp = cp-&gt;regno1_next;</span>
<span class="lineNum">     745 </span><span class="lineCov">    2440332 :           another_regno = cp-&gt;regno2;</span>
<span class="lineNum">     746 </span>            :         }
<span class="lineNum">     747 </span><span class="lineCov">    2893022 :       else if (cp-&gt;regno2 == regno)</span>
<span class="lineNum">     748 </span>            :         {
<span class="lineNum">     749 </span><span class="lineCov">    2893022 :           next_cp = cp-&gt;regno2_next;</span>
<span class="lineNum">     750 </span><span class="lineCov">    2893022 :           another_regno = cp-&gt;regno1;</span>
<span class="lineNum">     751 </span>            :         }
<span class="lineNum">     752 </span>            :       else
<span class="lineNum">     753 </span><span class="lineNoCov">          0 :         gcc_unreachable ();</span>
<span class="lineNum">     754 </span><span class="lineCov">    5333354 :       if (reg_renumber[another_regno] &lt; 0</span>
<span class="lineNum">     755 </span><span class="lineCov">    6144094 :           &amp;&amp; (update_hard_regno_preference_check[another_regno]</span>
<span class="lineNum">     756 </span><span class="lineCov">    3072047 :               != curr_update_hard_regno_preference_check))</span>
<span class="lineNum">     757 </span>            :         {
<span class="lineNum">     758 </span><span class="lineCov">    2052012 :           update_hard_regno_preference_check[another_regno]</span>
<span class="lineNum">     759 </span><span class="lineCov">    2052012 :             = curr_update_hard_regno_preference_check;</span>
<span class="lineNum">     760 </span><span class="lineCov">    2052012 :           cost = cp-&gt;freq &lt; div ? 1 : cp-&gt;freq / div;</span>
<span class="lineNum">     761 </span><span class="lineCov">    2052012 :           lra_setup_reload_pseudo_preferenced_hard_reg</span>
<span class="lineNum">     762 </span><span class="lineCov">    2052012 :             (another_regno, hard_regno, cost);</span>
<span class="lineNum">     763 </span><span class="lineCov">    2052012 :           update_hard_regno_preference (another_regno, hard_regno, div * 2);</span>
<span class="lineNum">     764 </span>            :         }
<span class="lineNum">     765 </span>            :     }
<span class="lineNum">     766 </span>            : }
<span class="lineNum">     767 </span>            : 
<a name="768"><span class="lineNum">     768 </span>            : /* Return prefix title for pseudo REGNO.  */</a>
<span class="lineNum">     769 </span>            : static const char *
<span class="lineNum">     770 </span><span class="lineCov">        251 : pseudo_prefix_title (int regno)</span>
<span class="lineNum">     771 </span>            : {
<span class="lineNum">     772 </span><span class="lineCov">        251 :   return</span>
<span class="lineNum">     773 </span><span class="lineCov">        251 :     (regno &lt; lra_constraint_new_regno_start ? &quot;&quot;</span>
<span class="lineNum">     774 </span><span class="lineCov">        244 :      : bitmap_bit_p (&amp;lra_inheritance_pseudos, regno) ? &quot;inheritance &quot;</span>
<span class="lineNum">     775 </span><span class="lineCov">        223 :      : bitmap_bit_p (&amp;lra_split_regs, regno) ? &quot;split &quot;</span>
<span class="lineNum">     776 </span><span class="lineCov">        223 :      : bitmap_bit_p (&amp;lra_optional_reload_pseudos, regno) ? &quot;optional reload &quot;</span>
<span class="lineNum">     777 </span><span class="lineCov">        209 :      : bitmap_bit_p (&amp;lra_subreg_reload_pseudos, regno) ? &quot;subreg reload &quot;</span>
<span class="lineNum">     778 </span><span class="lineCov">        251 :      : &quot;reload &quot;);</span>
<span class="lineNum">     779 </span>            : }
<span class="lineNum">     780 </span>            : 
<span class="lineNum">     781 </span>            : /* Update REG_RENUMBER and other pseudo preferences by assignment of
<a name="782"><span class="lineNum">     782 </span>            :    HARD_REGNO to pseudo REGNO and print about it if PRINT_P.  */</a>
<span class="lineNum">     783 </span>            : void
<span class="lineNum">     784 </span><span class="lineCov">    4311729 : lra_setup_reg_renumber (int regno, int hard_regno, bool print_p)</span>
<span class="lineNum">     785 </span>            : {
<span class="lineNum">     786 </span><span class="lineCov">    4311729 :   int i, hr;</span>
<span class="lineNum">     787 </span>            : 
<span class="lineNum">     788 </span>            :   /* We can not just reassign hard register.  */
<span class="lineNum">     789 </span><span class="lineCov">    4311729 :   lra_assert (hard_regno &lt; 0 || reg_renumber[regno] &lt; 0);</span>
<span class="lineNum">     790 </span><span class="lineCov">    4311729 :   if ((hr = hard_regno) &lt; 0)</span>
<span class="lineNum">     791 </span><span class="lineCov">      76265 :     hr = reg_renumber[regno];</span>
<span class="lineNum">     792 </span><span class="lineCov">    4311729 :   reg_renumber[regno] = hard_regno;</span>
<span class="lineNum">     793 </span><span class="lineCov">    4311729 :   lra_assert (hr &gt;= 0);</span>
<span class="lineNum">     794 </span><span class="lineCov">   13064632 :   for (i = 0; i &lt; hard_regno_nregs (hr, PSEUDO_REGNO_MODE (regno)); i++)</span>
<span class="lineNum">     795 </span><span class="lineCov">    4441174 :     if (hard_regno &lt; 0)</span>
<span class="lineNum">     796 </span><span class="lineCov">      79191 :       lra_hard_reg_usage[hr + i] -= lra_reg_info[regno].freq;</span>
<span class="lineNum">     797 </span>            :     else
<span class="lineNum">     798 </span><span class="lineCov">    4361983 :       lra_hard_reg_usage[hr + i] += lra_reg_info[regno].freq;</span>
<span class="lineNum">     799 </span><span class="lineCov">    4311729 :   if (print_p &amp;&amp; lra_dump_file != NULL)</span>
<span class="lineNum">     800 </span><span class="lineCov">        732 :     fprintf (lra_dump_file, &quot;         Assign %d to %sr%d (freq=%d)\n&quot;,</span>
<span class="lineNum">     801 </span><span class="lineCov">        244 :              reg_renumber[regno], pseudo_prefix_title (regno),</span>
<span class="lineNum">     802 </span><span class="lineCov">        244 :              regno, lra_reg_info[regno].freq);</span>
<span class="lineNum">     803 </span><span class="lineCov">    4311729 :   if (hard_regno &gt;= 0)</span>
<span class="lineNum">     804 </span>            :     {
<span class="lineNum">     805 </span><span class="lineCov">    4235464 :       curr_update_hard_regno_preference_check++;</span>
<span class="lineNum">     806 </span><span class="lineCov">    4235464 :       update_hard_regno_preference (regno, hard_regno, 1);</span>
<span class="lineNum">     807 </span>            :     }
<span class="lineNum">     808 </span><span class="lineCov">    4311729 : }</span>
<span class="lineNum">     809 </span>            : 
<span class="lineNum">     810 </span>            : /* Pseudos which occur in insns containing a particular pseudo.  */
<span class="lineNum">     811 </span>            : static bitmap_head insn_conflict_pseudos;
<span class="lineNum">     812 </span>            : 
<span class="lineNum">     813 </span>            : /* Bitmaps used to contain spill pseudos for given pseudo hard regno
<span class="lineNum">     814 </span>            :    and best spill pseudos for given pseudo (and best hard regno).  */
<span class="lineNum">     815 </span>            : static bitmap_head spill_pseudos_bitmap, best_spill_pseudos_bitmap;
<span class="lineNum">     816 </span>            : 
<span class="lineNum">     817 </span>            : /* Current pseudo check for validity of elements in
<span class="lineNum">     818 </span>            :    TRY_HARD_REG_PSEUDOS.  */
<span class="lineNum">     819 </span>            : static int curr_pseudo_check;
<span class="lineNum">     820 </span>            : /* Array used for validity of elements in TRY_HARD_REG_PSEUDOS.  */
<span class="lineNum">     821 </span>            : static int try_hard_reg_pseudos_check[FIRST_PSEUDO_REGISTER];
<span class="lineNum">     822 </span>            : /* Pseudos who hold given hard register at the considered points.  */
<span class="lineNum">     823 </span>            : static bitmap_head try_hard_reg_pseudos[FIRST_PSEUDO_REGISTER];
<span class="lineNum">     824 </span>            : 
<span class="lineNum">     825 </span>            : /* Set up try_hard_reg_pseudos for given program point P and class
<span class="lineNum">     826 </span>            :    RCLASS.  Those are pseudos living at P and assigned to a hard
<span class="lineNum">     827 </span>            :    register of RCLASS.  In other words, those are pseudos which can be
<span class="lineNum">     828 </span>            :    spilled to assign a hard register of RCLASS to a pseudo living at
<a name="829"><span class="lineNum">     829 </span>            :    P.  */</a>
<span class="lineNum">     830 </span>            : static void
<span class="lineNum">     831 </span><span class="lineCov">      49680 : setup_try_hard_regno_pseudos (int p, enum reg_class rclass)</span>
<span class="lineNum">     832 </span>            : {
<span class="lineNum">     833 </span><span class="lineCov">      49680 :   int i, hard_regno;</span>
<span class="lineNum">     834 </span><span class="lineCov">      49680 :   machine_mode mode;</span>
<span class="lineNum">     835 </span><span class="lineCov">      49680 :   unsigned int spill_regno;</span>
<span class="lineNum">     836 </span><span class="lineCov">      49680 :   bitmap_iterator bi;</span>
<span class="lineNum">     837 </span>            : 
<span class="lineNum">     838 </span>            :   /* Find what pseudos could be spilled.  */
<span class="lineNum">     839 </span><span class="lineCov">     387683 :   EXECUTE_IF_SET_IN_BITMAP (&amp;live_hard_reg_pseudos[p], 0, spill_regno, bi)</span>
<span class="lineNum">     840 </span>            :     {
<span class="lineNum">     841 </span><span class="lineCov">     338003 :       mode = PSEUDO_REGNO_MODE (spill_regno);</span>
<span class="lineNum">     842 </span><span class="lineCov">     338003 :       hard_regno = live_pseudos_reg_renumber[spill_regno];</span>
<span class="lineNum">     843 </span><span class="lineCov">     338003 :       if (overlaps_hard_reg_set_p (reg_class_contents[rclass],</span>
<span class="lineNum">     844 </span>            :                                    mode, hard_regno))
<span class="lineNum">     845 </span>            :         {
<span class="lineNum">     846 </span><span class="lineCov">     841969 :           for (i = hard_regno_nregs (hard_regno, mode) - 1; i &gt;= 0; i--)</span>
<span class="lineNum">     847 </span>            :             {
<span class="lineNum">     848 </span><span class="lineCov">     581670 :               if (try_hard_reg_pseudos_check[hard_regno + i]</span>
<span class="lineNum">     849 </span><span class="lineCov">     290835 :                   != curr_pseudo_check)</span>
<span class="lineNum">     850 </span>            :                 {
<span class="lineNum">     851 </span><span class="lineCov">     137818 :                   try_hard_reg_pseudos_check[hard_regno + i]</span>
<span class="lineNum">     852 </span><span class="lineCov">     137818 :                     = curr_pseudo_check;</span>
<span class="lineNum">     853 </span><span class="lineCov">     137818 :                   bitmap_clear (&amp;try_hard_reg_pseudos[hard_regno + i]);</span>
<span class="lineNum">     854 </span>            :                 }
<span class="lineNum">     855 </span><span class="lineCov">     290835 :               bitmap_set_bit (&amp;try_hard_reg_pseudos[hard_regno + i],</span>
<span class="lineNum">     856 </span>            :                               spill_regno);
<span class="lineNum">     857 </span>            :             }
<span class="lineNum">     858 </span>            :         }
<span class="lineNum">     859 </span>            :     }
<span class="lineNum">     860 </span><span class="lineCov">      49680 : }</span>
<span class="lineNum">     861 </span>            : 
<span class="lineNum">     862 </span>            : /* Assign temporarily HARD_REGNO to pseudo REGNO.  Temporary
<a name="863"><span class="lineNum">     863 </span>            :    assignment means that we might undo the data change.  */</a>
<span class="lineNum">     864 </span>            : static void
<span class="lineNum">     865 </span><span class="lineCov">    1218988 : assign_temporarily (int regno, int hard_regno)</span>
<span class="lineNum">     866 </span>            : {
<span class="lineNum">     867 </span><span class="lineCov">    1218988 :   int p;</span>
<span class="lineNum">     868 </span><span class="lineCov">    1218988 :   lra_live_range_t r;</span>
<span class="lineNum">     869 </span>            : 
<span class="lineNum">     870 </span><span class="lineCov">    2446438 :   for (r = lra_reg_info[regno].live_ranges; r != NULL; r = r-&gt;next)</span>
<span class="lineNum">     871 </span>            :     {
<span class="lineNum">     872 </span><span class="lineCov">    6152494 :       for (p = r-&gt;start; p &lt;= r-&gt;finish; p++)</span>
<span class="lineNum">     873 </span><span class="lineCov">    4925044 :         if (hard_regno &lt; 0)</span>
<span class="lineNum">     874 </span><span class="lineCov">    2462522 :           bitmap_clear_bit (&amp;live_hard_reg_pseudos[p], regno);</span>
<span class="lineNum">     875 </span>            :         else
<span class="lineNum">     876 </span>            :           {
<span class="lineNum">     877 </span><span class="lineCov">    2462522 :             bitmap_set_bit (&amp;live_hard_reg_pseudos[p], regno);</span>
<span class="lineNum">     878 </span><span class="lineCov">    2462522 :             insert_in_live_range_start_chain (regno);</span>
<span class="lineNum">     879 </span>            :           }
<span class="lineNum">     880 </span>            :     }
<span class="lineNum">     881 </span><span class="lineCov">    1218988 :   live_pseudos_reg_renumber[regno] = hard_regno;</span>
<span class="lineNum">     882 </span><span class="lineCov">    1218988 : }</span>
<span class="lineNum">     883 </span>            : 
<span class="lineNum">     884 </span>            : /* Return true iff there is a reason why pseudo SPILL_REGNO should not
<a name="885"><span class="lineNum">     885 </span>            :    be spilled.  */</a>
<span class="lineNum">     886 </span>            : static bool
<span class="lineNum">     887 </span><span class="lineCov">     142500 : must_not_spill_p (unsigned spill_regno)</span>
<span class="lineNum">     888 </span>            : {
<span class="lineNum">     889 </span><span class="lineCov">     142500 :   if ((pic_offset_table_rtx != NULL</span>
<span class="lineNum">     890 </span><span class="lineCov">      85658 :        &amp;&amp; spill_regno == REGNO (pic_offset_table_rtx))</span>
<span class="lineNum">     891 </span><span class="lineCov">     182912 :       || ((int) spill_regno &gt;= lra_constraint_new_regno_start</span>
<span class="lineNum">     892 </span><span class="lineCov">      12099 :           &amp;&amp; ! bitmap_bit_p (&amp;lra_inheritance_pseudos, spill_regno)</span>
<span class="lineNum">     893 </span><span class="lineCov">       3919 :           &amp;&amp; ! bitmap_bit_p (&amp;lra_split_regs, spill_regno)</span>
<span class="lineNum">     894 </span><span class="lineCov">       3333 :           &amp;&amp; ! bitmap_bit_p (&amp;lra_subreg_reload_pseudos, spill_regno)</span>
<span class="lineNum">     895 </span><span class="lineCov">       3333 :           &amp;&amp; ! bitmap_bit_p (&amp;lra_optional_reload_pseudos, spill_regno)))</span>
<span class="lineNum">     896 </span><span class="lineCov">       4371 :     return true;</span>
<span class="lineNum">     897 </span>            :   /* A reload pseudo that requires a singleton register class should
<span class="lineNum">     898 </span>            :      not be spilled.
<span class="lineNum">     899 </span>            :      FIXME: this mitigates the issue on certain i386 patterns, but
<span class="lineNum">     900 </span>            :      does not solve the general case where existing reloads fully
<span class="lineNum">     901 </span>            :      cover a limited register class.  */
<span class="lineNum">     902 </span><span class="lineCov">     138129 :   if (!bitmap_bit_p (&amp;non_reload_pseudos, spill_regno)</span>
<span class="lineNum">     903 </span><span class="lineCov">     127984 :       &amp;&amp; reg_class_size [reg_preferred_class (spill_regno)] == 1</span>
<span class="lineNum">     904 </span><span class="lineCov">     147282 :       &amp;&amp; reg_alternate_class (spill_regno) == NO_REGS)</span>
<span class="lineNum">     905 </span><span class="lineCov">          9 :     return true;</span>
<span class="lineNum">     906 </span>            :   return false;
<span class="lineNum">     907 </span>            : }
<span class="lineNum">     908 </span>            : 
<span class="lineNum">     909 </span>            : /* Array used for sorting reload pseudos for subsequent allocation
<span class="lineNum">     910 </span>            :    after spilling some pseudo.  */
<span class="lineNum">     911 </span>            : static int *sorted_reload_pseudos;
<span class="lineNum">     912 </span>            : 
<span class="lineNum">     913 </span>            : /* Spill some pseudos for a reload pseudo REGNO and return hard
<span class="lineNum">     914 </span>            :    register which should be used for pseudo after spilling.  The
<span class="lineNum">     915 </span>            :    function adds spilled pseudos to SPILLED_PSEUDO_BITMAP.  When we
<span class="lineNum">     916 </span>            :    choose hard register (and pseudos occupying the hard registers and
<span class="lineNum">     917 </span>            :    to be spilled), we take into account not only how REGNO will
<span class="lineNum">     918 </span>            :    benefit from the spills but also how other reload pseudos not yet
<span class="lineNum">     919 </span>            :    assigned to hard registers benefit from the spills too.  In very
<span class="lineNum">     920 </span>            :    rare cases, the function can fail and return -1.
<span class="lineNum">     921 </span>            : 
<span class="lineNum">     922 </span>            :    If FIRST_P, return the first available hard reg ignoring other
<span class="lineNum">     923 </span>            :    criteria, e.g. allocation cost and cost of spilling non-reload
<span class="lineNum">     924 </span>            :    pseudos.  This approach results in less hard reg pool fragmentation
<span class="lineNum">     925 </span>            :    and permit to allocate hard regs to reload pseudos in complicated
<a name="926"><span class="lineNum">     926 </span>            :    situations where pseudo sizes are different.  */</a>
<span class="lineNum">     927 </span>            : static int
<span class="lineNum">     928 </span><span class="lineCov">      23048 : spill_for (int regno, bitmap spilled_pseudo_bitmap, bool first_p)</span>
<span class="lineNum">     929 </span>            : {
<span class="lineNum">     930 </span><span class="lineCov">      23048 :   int i, j, n, p, hard_regno, best_hard_regno, cost, best_cost, rclass_size;</span>
<span class="lineNum">     931 </span><span class="lineCov">      23048 :   int reload_hard_regno, reload_cost;</span>
<span class="lineNum">     932 </span><span class="lineCov">      23048 :   bool static_p, best_static_p;</span>
<span class="lineNum">     933 </span><span class="lineCov">      23048 :   machine_mode mode;</span>
<span class="lineNum">     934 </span><span class="lineCov">      23048 :   enum reg_class rclass;</span>
<span class="lineNum">     935 </span><span class="lineCov">      23048 :   unsigned int spill_regno, reload_regno, uid;</span>
<span class="lineNum">     936 </span><span class="lineCov">      23048 :   int insn_pseudos_num, best_insn_pseudos_num;</span>
<span class="lineNum">     937 </span><span class="lineCov">      23048 :   int bad_spills_num, smallest_bad_spills_num;</span>
<span class="lineNum">     938 </span><span class="lineCov">      23048 :   lra_live_range_t r;</span>
<span class="lineNum">     939 </span><span class="lineCov">      23048 :   bitmap_iterator bi;</span>
<span class="lineNum">     940 </span>            : 
<span class="lineNum">     941 </span><span class="lineCov">      23048 :   rclass = regno_allocno_class_array[regno];</span>
<span class="lineNum">     942 </span><span class="lineCov">      23048 :   lra_assert (reg_renumber[regno] &lt; 0 &amp;&amp; rclass != NO_REGS);</span>
<span class="lineNum">     943 </span><span class="lineCov">      23048 :   bitmap_clear (&amp;insn_conflict_pseudos);</span>
<span class="lineNum">     944 </span><span class="lineCov">      23048 :   bitmap_clear (&amp;best_spill_pseudos_bitmap);</span>
<span class="lineNum">     945 </span><span class="lineCov">      72708 :   EXECUTE_IF_SET_IN_BITMAP (&amp;lra_reg_info[regno].insn_bitmap, 0, uid, bi)</span>
<span class="lineNum">     946 </span>            :     {
<span class="lineNum">     947 </span><span class="lineCov">      49660 :       struct lra_insn_reg *ir;</span>
<span class="lineNum">     948 </span>            : 
<span class="lineNum">     949 </span><span class="lineCov">     164421 :       for (ir = lra_get_insn_regs (uid); ir != NULL; ir = ir-&gt;next)</span>
<span class="lineNum">     950 </span><span class="lineCov">     114761 :         if (ir-&gt;regno &gt;= FIRST_PSEUDO_REGISTER)</span>
<span class="lineNum">     951 </span><span class="lineCov">     110425 :           bitmap_set_bit (&amp;insn_conflict_pseudos, ir-&gt;regno);</span>
<span class="lineNum">     952 </span>            :     }
<span class="lineNum">     953 </span><span class="lineCov">      23048 :   best_hard_regno = -1;</span>
<span class="lineNum">     954 </span><span class="lineCov">      23048 :   best_cost = INT_MAX;</span>
<span class="lineNum">     955 </span><span class="lineCov">      23048 :   best_static_p = TRUE;</span>
<span class="lineNum">     956 </span><span class="lineCov">      23048 :   best_insn_pseudos_num = INT_MAX;</span>
<span class="lineNum">     957 </span><span class="lineCov">      23048 :   smallest_bad_spills_num = INT_MAX;</span>
<span class="lineNum">     958 </span><span class="lineCov">      23048 :   rclass_size = ira_class_hard_regs_num[rclass];</span>
<span class="lineNum">     959 </span><span class="lineCov">      23048 :   mode = PSEUDO_REGNO_MODE (regno);</span>
<span class="lineNum">     960 </span>            :   /* Invalidate try_hard_reg_pseudos elements.  */
<span class="lineNum">     961 </span><span class="lineCov">      23048 :   curr_pseudo_check++;</span>
<span class="lineNum">     962 </span><span class="lineCov">      46097 :   for (r = lra_reg_info[regno].live_ranges; r != NULL; r = r-&gt;next)</span>
<span class="lineNum">     963 </span><span class="lineCov">      72729 :     for (p = r-&gt;start; p &lt;= r-&gt;finish; p++)</span>
<span class="lineNum">     964 </span><span class="lineCov">      49680 :       setup_try_hard_regno_pseudos (p, rclass);</span>
<span class="lineNum">     965 </span><span class="lineCov">     166430 :   for (i = 0; i &lt; rclass_size; i++)</span>
<span class="lineNum">     966 </span>            :     {
<span class="lineNum">     967 </span><span class="lineCov">     143382 :       hard_regno = ira_class_hard_regs[rclass][i];</span>
<span class="lineNum">     968 </span><span class="lineCov">     143382 :       bitmap_clear (&amp;spill_pseudos_bitmap);</span>
<span class="lineNum">     969 </span><span class="lineCov">     443556 :       for (j = hard_regno_nregs (hard_regno, mode) - 1; j &gt;= 0; j--)</span>
<span class="lineNum">     970 </span>            :         {
<span class="lineNum">     971 </span><span class="lineCov">     156792 :           if (try_hard_reg_pseudos_check[hard_regno + j] != curr_pseudo_check)</span>
<span class="lineNum">     972 </span>            :             continue;
<span class="lineNum">     973 </span><span class="lineCov">     288994 :           lra_assert (!bitmap_empty_p (&amp;try_hard_reg_pseudos[hard_regno + j]));</span>
<span class="lineNum">     974 </span><span class="lineCov">     144497 :           bitmap_ior_into (&amp;spill_pseudos_bitmap,</span>
<span class="lineNum">     975 </span>            :                            &amp;try_hard_reg_pseudos[hard_regno + j]);
<span class="lineNum">     976 </span>            :         }
<span class="lineNum">     977 </span>            :       /* Spill pseudos.  */
<span class="lineNum">     978 </span><span class="lineCov">     143382 :       static_p = false;</span>
<span class="lineNum">     979 </span><span class="lineCov">     281502 :       EXECUTE_IF_SET_IN_BITMAP (&amp;spill_pseudos_bitmap, 0, spill_regno, bi)</span>
<span class="lineNum">     980 </span><span class="lineCov">     142500 :         if (must_not_spill_p (spill_regno))</span>
<span class="lineNum">     981 </span>            :           goto fail;
<span class="lineNum">     982 </span><span class="lineCov">     139294 :         else if (non_spilled_static_chain_regno_p (spill_regno))</span>
<span class="lineNum">     983 </span>            :           static_p = true;
<span class="lineNum">     984 </span><span class="lineCov">     139002 :       insn_pseudos_num = 0;</span>
<span class="lineNum">     985 </span><span class="lineCov">     139002 :       bad_spills_num = 0;</span>
<span class="lineNum">     986 </span><span class="lineCov">     139002 :       if (lra_dump_file != NULL)</span>
<span class="lineNum">     987 </span><span class="lineCov">        105 :         fprintf (lra_dump_file, &quot;   Trying %d:&quot;, hard_regno);</span>
<span class="lineNum">     988 </span><span class="lineCov">     139002 :       sparseset_clear (live_range_reload_inheritance_pseudos);</span>
<span class="lineNum">     989 </span><span class="lineCov">     277021 :       EXECUTE_IF_SET_IN_BITMAP (&amp;spill_pseudos_bitmap, 0, spill_regno, bi)</span>
<span class="lineNum">     990 </span>            :         {
<span class="lineNum">     991 </span><span class="lineCov">     138019 :           if (bitmap_bit_p (&amp;insn_conflict_pseudos, spill_regno))</span>
<span class="lineNum">     992 </span><span class="lineCov">      28161 :             insn_pseudos_num++;</span>
<span class="lineNum">     993 </span><span class="lineCov">     138019 :           if (spill_regno &gt;= (unsigned int) lra_bad_spill_regno_start)</span>
<span class="lineNum">     994 </span><span class="lineNoCov">          0 :             bad_spills_num++;</span>
<span class="lineNum">     995 </span><span class="lineCov">     138019 :           for (r = lra_reg_info[spill_regno].live_ranges;</span>
<span class="lineNum">     996 </span><span class="lineCov">     507104 :                r != NULL;</span>
<span class="lineNum">     997 </span><span class="lineCov">     369085 :                r = r-&gt;next)</span>
<span class="lineNum">     998 </span>            :             {
<span class="lineNum">     999 </span><span class="lineCov">   38184712 :               for (p = r-&gt;start; p &lt;= r-&gt;finish; p++)</span>
<span class="lineNum">    1000 </span>            :                 {
<span class="lineNum">    1001 </span><span class="lineCov">   37815627 :                   lra_live_range_t r2;</span>
<span class="lineNum">    1002 </span>            : 
<span class="lineNum">    1003 </span><span class="lineCov">   37815627 :                   for (r2 = start_point_ranges[p];</span>
<span class="lineNum">    1004 </span><span class="lineCov">   70863493 :                        r2 != NULL;</span>
<span class="lineNum">    1005 </span><span class="lineCov">   33047866 :                        r2 = r2-&gt;start_next)</span>
<span class="lineNum">    1006 </span><span class="lineCov">   33047866 :                     if (r2-&gt;regno &gt;= lra_constraint_new_regno_start)</span>
<span class="lineNum">    1007 </span><span class="lineCov">   27682046 :                       sparseset_set_bit (live_range_reload_inheritance_pseudos,</span>
<span class="lineNum">    1008 </span>            :                                          r2-&gt;regno);
<span class="lineNum">    1009 </span>            :                 }
<span class="lineNum">    1010 </span>            :             }
<span class="lineNum">    1011 </span>            :         }
<span class="lineNum">    1012 </span><span class="lineCov">     139002 :       n = 0;</span>
<span class="lineNum">    1013 </span><span class="lineCov">     139002 :       if (sparseset_cardinality (live_range_reload_inheritance_pseudos)</span>
<span class="lineNum">    1014 </span><span class="lineCov">     139002 :           &lt;= (unsigned)LRA_MAX_CONSIDERED_RELOAD_PSEUDOS)</span>
<span class="lineNum">    1015 </span><span class="lineCov">    6119025 :         EXECUTE_IF_SET_IN_SPARSESET (live_range_reload_inheritance_pseudos,</span>
<span class="lineNum">    1016 </span>            :                                      reload_regno)
<span class="lineNum">    1017 </span><span class="lineCov">    2987475 :           if ((int) reload_regno != regno</span>
<span class="lineNum">    1018 </span><span class="lineCov">    2862138 :               &amp;&amp; (ira_reg_classes_intersect_p</span>
<span class="lineNum">    1019 </span><span class="lineCov">    2862138 :                   [rclass][regno_allocno_class_array[reload_regno]])</span>
<span class="lineNum">    1020 </span><span class="lineCov">    2509265 :               &amp;&amp; live_pseudos_reg_renumber[reload_regno] &lt; 0</span>
<span class="lineNum">    1021 </span><span class="lineCov">    4509824 :               &amp;&amp; find_hard_regno_for (reload_regno, &amp;cost, -1, first_p) &lt; 0)</span>
<span class="lineNum">    1022 </span><span class="lineCov">     786640 :             sorted_reload_pseudos[n++] = reload_regno;</span>
<span class="lineNum">    1023 </span><span class="lineCov">     277021 :       EXECUTE_IF_SET_IN_BITMAP (&amp;spill_pseudos_bitmap, 0, spill_regno, bi)</span>
<span class="lineNum">    1024 </span>            :         {
<span class="lineNum">    1025 </span><span class="lineCov">     138019 :           update_lives (spill_regno, true);</span>
<span class="lineNum">    1026 </span><span class="lineCov">     138019 :           if (lra_dump_file != NULL)</span>
<span class="lineNum">    1027 </span><span class="lineCov">        210 :             fprintf (lra_dump_file, &quot; spill %d(freq=%d)&quot;,</span>
<span class="lineNum">    1028 </span><span class="lineCov">        105 :                      spill_regno, lra_reg_info[spill_regno].freq);</span>
<span class="lineNum">    1029 </span>            :         }
<span class="lineNum">    1030 </span><span class="lineCov">     139002 :       hard_regno = find_hard_regno_for (regno, &amp;cost, -1, first_p);</span>
<span class="lineNum">    1031 </span><span class="lineCov">     139002 :       if (hard_regno &gt;= 0)</span>
<span class="lineNum">    1032 </span>            :         {
<span class="lineNum">    1033 </span><span class="lineCov">     134300 :           assign_temporarily (regno, hard_regno);</span>
<span class="lineNum">    1034 </span><span class="lineCov">     134300 :           qsort (sorted_reload_pseudos, n, sizeof (int),</span>
<span class="lineNum">    1035 </span>            :                  reload_pseudo_compare_func);
<span class="lineNum">    1036 </span><span class="lineCov">     917611 :           for (j = 0; j &lt; n; j++)</span>
<span class="lineNum">    1037 </span>            :             {
<span class="lineNum">    1038 </span><span class="lineCov">     783311 :               reload_regno = sorted_reload_pseudos[j];</span>
<span class="lineNum">    1039 </span><span class="lineCov">     783311 :               lra_assert (live_pseudos_reg_renumber[reload_regno] &lt; 0);</span>
<span class="lineNum">    1040 </span><span class="lineCov">    1566622 :               if ((reload_hard_regno</span>
<span class="lineNum">    1041 </span><span class="lineCov">     783311 :                    = find_hard_regno_for (reload_regno,</span>
<span class="lineNum">    1042 </span>            :                                           &amp;reload_cost, -1, first_p)) &gt;= 0)
<span class="lineNum">    1043 </span>            :                 {
<span class="lineNum">    1044 </span><span class="lineCov">     475194 :                   if (lra_dump_file != NULL)</span>
<span class="lineNum">    1045 </span><span class="lineCov">        196 :                     fprintf (lra_dump_file, &quot; assign %d(cost=%d)&quot;,</span>
<span class="lineNum">    1046 </span>            :                              reload_regno, reload_cost);
<span class="lineNum">    1047 </span><span class="lineCov">     475194 :                   assign_temporarily (reload_regno, reload_hard_regno);</span>
<span class="lineNum">    1048 </span><span class="lineCov">     475194 :                   cost += reload_cost;</span>
<span class="lineNum">    1049 </span>            :                 }
<span class="lineNum">    1050 </span>            :             }
<span class="lineNum">    1051 </span><span class="lineCov">     271759 :           EXECUTE_IF_SET_IN_BITMAP (&amp;spill_pseudos_bitmap, 0, spill_regno, bi)</span>
<span class="lineNum">    1052 </span>            :             {
<span class="lineNum">    1053 </span><span class="lineCov">     137459 :               rtx_insn_list *x;</span>
<span class="lineNum">    1054 </span>            : 
<span class="lineNum">    1055 </span><span class="lineCov">     137459 :               cost += lra_reg_info[spill_regno].freq;</span>
<span class="lineNum">    1056 </span><span class="lineCov">     137459 :               if (ira_reg_equiv[spill_regno].memory != NULL</span>
<span class="lineNum">    1057 </span><span class="lineCov">     129130 :                   || ira_reg_equiv[spill_regno].constant != NULL)</span>
<span class="lineNum">    1058 </span><span class="lineCov">      10346 :                 for (x = ira_reg_equiv[spill_regno].init_insns;</span>
<span class="lineNum">    1059 </span><span class="lineCov">      10346 :                      x != NULL;</span>
<span class="lineNum">    1060 </span><span class="lineCov">       8294 :                      x = x-&gt;next ())</span>
<span class="lineNum">    1061 </span><span class="lineCov">       8294 :                   cost -= REG_FREQ_FROM_BB (BLOCK_FOR_INSN (x-&gt;insn ()));</span>
<span class="lineNum">    1062 </span>            :             }
<span class="lineNum">    1063 </span>            :           /* Avoid spilling static chain pointer pseudo when non-local
<span class="lineNum">    1064 </span>            :              goto is used.  */
<span class="lineNum">    1065 </span><span class="lineCov">     134300 :           if ((! static_p &amp;&amp; best_static_p)</span>
<span class="lineNum">    1066 </span><span class="lineCov">     111279 :               || (static_p == best_static_p</span>
<span class="lineNum">    1067 </span><span class="lineCov">     111279 :                   &amp;&amp; (best_insn_pseudos_num &gt; insn_pseudos_num</span>
<span class="lineNum">    1068 </span><span class="lineCov">     106514 :                       || (best_insn_pseudos_num == insn_pseudos_num</span>
<span class="lineNum">    1069 </span><span class="lineCov">      93333 :                           &amp;&amp; (bad_spills_num &lt; smallest_bad_spills_num</span>
<span class="lineNum">    1070 </span><span class="lineCov">      93333 :                               || (bad_spills_num == smallest_bad_spills_num</span>
<span class="lineNum">    1071 </span><span class="lineCov">      93333 :                                   &amp;&amp; best_cost &gt; cost))))))</span>
<span class="lineNum">    1072 </span>            :             {
<span class="lineNum">    1073 </span><span class="lineCov">      48658 :               best_insn_pseudos_num = insn_pseudos_num;</span>
<span class="lineNum">    1074 </span><span class="lineCov">      48658 :               smallest_bad_spills_num = bad_spills_num;</span>
<span class="lineNum">    1075 </span><span class="lineCov">      48658 :               best_static_p = static_p;</span>
<span class="lineNum">    1076 </span><span class="lineCov">      48658 :               best_cost = cost;</span>
<span class="lineNum">    1077 </span><span class="lineCov">      48658 :               best_hard_regno = hard_regno;</span>
<span class="lineNum">    1078 </span><span class="lineCov">      48658 :               bitmap_copy (&amp;best_spill_pseudos_bitmap, &amp;spill_pseudos_bitmap);</span>
<span class="lineNum">    1079 </span><span class="lineCov">      48658 :               if (lra_dump_file != NULL)</span>
<span class="lineNum">    1080 </span><span class="lineCov">         28 :                 fprintf (lra_dump_file,</span>
<span class="lineNum">    1081 </span>            :                          &quot;  Now best %d(cost=%d, bad_spills=%d, insn_pseudos=%d)\n&quot;,
<span class="lineNum">    1082 </span>            :                          hard_regno, cost, bad_spills_num, insn_pseudos_num);
<span class="lineNum">    1083 </span>            :             }
<span class="lineNum">    1084 </span><span class="lineCov">     134300 :           assign_temporarily (regno, -1);</span>
<span class="lineNum">    1085 </span><span class="lineCov">     917611 :           for (j = 0; j &lt; n; j++)</span>
<span class="lineNum">    1086 </span>            :             {
<span class="lineNum">    1087 </span><span class="lineCov">     783311 :               reload_regno = sorted_reload_pseudos[j];</span>
<span class="lineNum">    1088 </span><span class="lineCov">     783311 :               if (live_pseudos_reg_renumber[reload_regno] &gt;= 0)</span>
<span class="lineNum">    1089 </span><span class="lineCov">     475194 :                 assign_temporarily (reload_regno, -1);</span>
<span class="lineNum">    1090 </span>            :             }
<span class="lineNum">    1091 </span>            :         }
<span class="lineNum">    1092 </span><span class="lineCov">     139002 :       if (lra_dump_file != NULL)</span>
<span class="lineNum">    1093 </span><span class="lineCov">        105 :         fprintf (lra_dump_file, &quot;\n&quot;);</span>
<span class="lineNum">    1094 </span>            :       /* Restore the live hard reg pseudo info for spilled pseudos.  */
<span class="lineNum">    1095 </span><span class="lineCov">     277021 :       EXECUTE_IF_SET_IN_BITMAP (&amp;spill_pseudos_bitmap, 0, spill_regno, bi)</span>
<span class="lineNum">    1096 </span><span class="lineCov">     138019 :         update_lives (spill_regno, false);</span>
<span class="lineNum">    1097 </span><span class="lineCov">     139002 :     fail:</span>
<span class="lineNum">    1098 </span><span class="lineCov">     143382 :       ;</span>
<span class="lineNum">    1099 </span>            :     }
<span class="lineNum">    1100 </span>            :   /* Spill: */
<span class="lineNum">    1101 </span><span class="lineCov">      46301 :   EXECUTE_IF_SET_IN_BITMAP (&amp;best_spill_pseudos_bitmap, 0, spill_regno, bi)</span>
<span class="lineNum">    1102 </span>            :     {
<span class="lineNum">    1103 </span><span class="lineCov">      23253 :       if ((int) spill_regno &gt;= lra_constraint_new_regno_start)</span>
<span class="lineNum">    1104 </span><span class="lineCov">       1603 :         former_reload_pseudo_spill_p = true;</span>
<span class="lineNum">    1105 </span><span class="lineCov">      23253 :       if (lra_dump_file != NULL)</span>
<span class="lineNum">    1106 </span><span class="lineCov">          7 :         fprintf (lra_dump_file, &quot;      Spill %sr%d(hr=%d, freq=%d) for r%d\n&quot;,</span>
<span class="lineNum">    1107 </span>            :                  pseudo_prefix_title (spill_regno),
<span class="lineNum">    1108 </span><span class="lineCov">          7 :                  spill_regno, reg_renumber[spill_regno],</span>
<span class="lineNum">    1109 </span><span class="lineCov">          7 :                  lra_reg_info[spill_regno].freq, regno);</span>
<span class="lineNum">    1110 </span><span class="lineCov">      23253 :       update_lives (spill_regno, true);</span>
<span class="lineNum">    1111 </span><span class="lineCov">      23253 :       lra_setup_reg_renumber (spill_regno, -1, false);</span>
<span class="lineNum">    1112 </span>            :     }
<span class="lineNum">    1113 </span><span class="lineCov">      23048 :   bitmap_ior_into (spilled_pseudo_bitmap, &amp;best_spill_pseudos_bitmap);</span>
<span class="lineNum">    1114 </span><span class="lineCov">      23048 :   return best_hard_regno;</span>
<span class="lineNum">    1115 </span>            : }
<span class="lineNum">    1116 </span>            : 
<a name="1117"><span class="lineNum">    1117 </span>            : /* Assign HARD_REGNO to REGNO.  */</a>
<span class="lineNum">    1118 </span>            : static void
<span class="lineNum">    1119 </span><span class="lineCov">    4235455 : assign_hard_regno (int hard_regno, int regno)</span>
<span class="lineNum">    1120 </span>            : {
<span class="lineNum">    1121 </span><span class="lineCov">    4235455 :   int i;</span>
<span class="lineNum">    1122 </span>            : 
<span class="lineNum">    1123 </span><span class="lineCov">    4235455 :   lra_assert (hard_regno &gt;= 0);</span>
<span class="lineNum">    1124 </span><span class="lineCov">    4235455 :   lra_setup_reg_renumber (regno, hard_regno, true);</span>
<span class="lineNum">    1125 </span><span class="lineCov">    4235455 :   update_lives (regno, false);</span>
<span class="lineNum">    1126 </span><span class="lineCov">    8597860 :   for (i = 0;</span>
<span class="lineNum">    1127 </span><span class="lineCov">   17195720 :        i &lt; hard_regno_nregs (hard_regno, lra_reg_info[regno].biggest_mode);</span>
<span class="lineNum">    1128 </span>            :        i++)
<span class="lineNum">    1129 </span><span class="lineCov">    4362405 :     df_set_regs_ever_live (hard_regno + i, true);</span>
<span class="lineNum">    1130 </span><span class="lineCov">    4235455 : }</span>
<span class="lineNum">    1131 </span>            : 
<span class="lineNum">    1132 </span>            : /* Array used for sorting different pseudos.  */
<span class="lineNum">    1133 </span>            : static int *sorted_pseudos;
<span class="lineNum">    1134 </span>            : 
<span class="lineNum">    1135 </span>            : /* The constraints pass is allowed to create equivalences between
<span class="lineNum">    1136 </span>            :    pseudos that make the current allocation &quot;incorrect&quot; (in the sense
<span class="lineNum">    1137 </span>            :    that pseudos are assigned to hard registers from their own conflict
<span class="lineNum">    1138 </span>            :    sets).  The global variable lra_risky_transformations_p says
<span class="lineNum">    1139 </span>            :    whether this might have happened.
<span class="lineNum">    1140 </span>            : 
<span class="lineNum">    1141 </span>            :    Process pseudos assigned to hard registers (less frequently used
<span class="lineNum">    1142 </span>            :    first), spill if a conflict is found, and mark the spilled pseudos
<span class="lineNum">    1143 </span>            :    in SPILLED_PSEUDO_BITMAP.  Set up LIVE_HARD_REG_PSEUDOS from
<a name="1144"><span class="lineNum">    1144 </span>            :    pseudos, assigned to hard registers.  */</a>
<span class="lineNum">    1145 </span>            : static void
<span class="lineNum">    1146 </span><span class="lineCov">     881139 : setup_live_pseudos_and_spill_after_risky_transforms (bitmap</span>
<span class="lineNum">    1147 </span>            :                                                      spilled_pseudo_bitmap)
<span class="lineNum">    1148 </span>            : {
<span class="lineNum">    1149 </span><span class="lineCov">     881139 :   int p, i, j, n, regno, hard_regno;</span>
<span class="lineNum">    1150 </span><span class="lineCov">     881139 :   unsigned int k, conflict_regno;</span>
<span class="lineNum">    1151 </span><span class="lineCov">     881139 :   poly_int64 offset;</span>
<span class="lineNum">    1152 </span><span class="lineCov">     881139 :   int val;</span>
<span class="lineNum">    1153 </span><span class="lineCov">     881139 :   HARD_REG_SET conflict_set;</span>
<span class="lineNum">    1154 </span><span class="lineCov">     881139 :   machine_mode mode;</span>
<span class="lineNum">    1155 </span><span class="lineCov">     881139 :   lra_live_range_t r;</span>
<span class="lineNum">    1156 </span><span class="lineCov">     881139 :   bitmap_iterator bi;</span>
<span class="lineNum">    1157 </span><span class="lineCov">     881139 :   int max_regno = max_reg_num ();</span>
<span class="lineNum">    1158 </span>            : 
<span class="lineNum">    1159 </span><span class="lineCov">     881139 :   if (! lra_risky_transformations_p)</span>
<span class="lineNum">    1160 </span>            :     {
<span class="lineNum">    1161 </span><span class="lineCov">   13356860 :       for (i = FIRST_PSEUDO_REGISTER; i &lt; max_regno; i++)</span>
<span class="lineNum">    1162 </span><span class="lineCov">   13315087 :         if (reg_renumber[i] &gt;= 0 &amp;&amp; lra_reg_info[i].nrefs &gt; 0)</span>
<span class="lineNum">    1163 </span><span class="lineCov">    6630087 :           update_lives (i, false);</span>
<span class="lineNum">    1164 </span><span class="lineCov">      41773 :       return;</span>
<span class="lineNum">    1165 </span>            :     }
<span class="lineNum">    1166 </span><span class="lineCov">   42517863 :   for (n = 0, i = FIRST_PSEUDO_REGISTER; i &lt; max_regno; i++)</span>
<span class="lineNum">    1167 </span><span class="lineCov">   41678497 :     if ((pic_offset_table_rtx == NULL_RTX</span>
<span class="lineNum">    1168 </span><span class="lineCov">   10105978 :          || i != (int) REGNO (pic_offset_table_rtx))</span>
<span class="lineNum">    1169 </span><span class="lineCov">   46694787 :         &amp;&amp; reg_renumber[i] &gt;= 0 &amp;&amp; lra_reg_info[i].nrefs &gt; 0)</span>
<span class="lineNum">    1170 </span><span class="lineCov">   15556905 :       sorted_pseudos[n++] = i;</span>
<span class="lineNum">    1171 </span><span class="lineCov">     839366 :   qsort (sorted_pseudos, n, sizeof (int), pseudo_compare_func);</span>
<span class="lineNum">    1172 </span><span class="lineCov">     839366 :   if (pic_offset_table_rtx != NULL_RTX</span>
<span class="lineNum">    1173 </span><span class="lineCov">      73398 :       &amp;&amp; (regno = REGNO (pic_offset_table_rtx)) &gt;= FIRST_PSEUDO_REGISTER</span>
<span class="lineNum">    1174 </span><span class="lineCov">     876065 :       &amp;&amp; reg_renumber[regno] &gt;= 0 &amp;&amp; lra_reg_info[regno].nrefs &gt; 0)</span>
<span class="lineNum">    1175 </span><span class="lineCov">      32236 :     sorted_pseudos[n++] = regno;</span>
<span class="lineNum">    1176 </span><span class="lineCov">   16428507 :   for (i = n - 1; i &gt;= 0; i--)</span>
<span class="lineNum">    1177 </span>            :     {
<span class="lineNum">    1178 </span><span class="lineCov">   15589141 :       regno = sorted_pseudos[i];</span>
<span class="lineNum">    1179 </span><span class="lineCov">   15589141 :       hard_regno = reg_renumber[regno];</span>
<span class="lineNum">    1180 </span><span class="lineCov">   15589141 :       lra_assert (hard_regno &gt;= 0);</span>
<span class="lineNum">    1181 </span><span class="lineCov">   15589141 :       mode = lra_reg_info[regno].biggest_mode;</span>
<span class="lineNum">    1182 </span><span class="lineCov">   15589141 :       sparseset_clear (live_range_hard_reg_pseudos);</span>
<span class="lineNum">    1183 </span><span class="lineCov">   33549202 :       for (r = lra_reg_info[regno].live_ranges; r != NULL; r = r-&gt;next)</span>
<span class="lineNum">    1184 </span>            :         {
<span class="lineNum">    1185 </span><span class="lineCov">   39672276 :           EXECUTE_IF_SET_IN_BITMAP (&amp;live_hard_reg_pseudos[r-&gt;start], 0, k, bi)</span>
<span class="lineNum">    1186 </span><span class="lineCov">   21712215 :             sparseset_set_bit (live_range_hard_reg_pseudos, k);</span>
<span class="lineNum">    1187 </span><span class="lineCov">  128165024 :           for (p = r-&gt;start + 1; p &lt;= r-&gt;finish; p++)</span>
<span class="lineNum">    1188 </span>            :             {
<span class="lineNum">    1189 </span><span class="lineCov">  110204963 :               lra_live_range_t r2;</span>
<span class="lineNum">    1190 </span>            : 
<span class="lineNum">    1191 </span><span class="lineCov">  110204963 :               for (r2 = start_point_ranges[p];</span>
<span class="lineNum">    1192 </span><span class="lineCov">  169654594 :                    r2 != NULL;</span>
<span class="lineNum">    1193 </span><span class="lineCov">   59449631 :                    r2 = r2-&gt;start_next)</span>
<span class="lineNum">    1194 </span><span class="lineCov">   59449631 :                 if (live_pseudos_reg_renumber[r2-&gt;regno] &gt;= 0)</span>
<span class="lineNum">    1195 </span><span class="lineCov">   30033592 :                   sparseset_set_bit (live_range_hard_reg_pseudos, r2-&gt;regno);</span>
<span class="lineNum">    1196 </span>            :             }
<span class="lineNum">    1197 </span>            :         }
<span class="lineNum">    1198 </span><span class="lineCov">   15589141 :       COPY_HARD_REG_SET (conflict_set, lra_no_alloc_regs);</span>
<span class="lineNum">    1199 </span><span class="lineCov">   15589141 :       IOR_HARD_REG_SET (conflict_set, lra_reg_info[regno].conflict_hard_regs);</span>
<span class="lineNum">    1200 </span><span class="lineCov">   15589141 :       val = lra_reg_info[regno].val;</span>
<span class="lineNum">    1201 </span><span class="lineCov">   15589141 :       offset = lra_reg_info[regno].offset;</span>
<span class="lineNum">    1202 </span><span class="lineCov">   58989130 :       EXECUTE_IF_SET_IN_SPARSESET (live_range_hard_reg_pseudos, conflict_regno)</span>
<span class="lineNum">    1203 </span><span class="lineCov">   43399989 :         if (!lra_reg_val_equal_p (conflict_regno, val, offset)</span>
<span class="lineNum">    1204 </span>            :             /* If it is multi-register pseudos they should start on
<span class="lineNum">    1205 </span>            :                the same hard register.  */
<span class="lineNum">    1206 </span><span class="lineCov">      67339 :             || hard_regno != reg_renumber[conflict_regno])</span>
<span class="lineNum">    1207 </span>            :           {
<span class="lineNum">    1208 </span><span class="lineCov">   43338409 :             int conflict_hard_regno = reg_renumber[conflict_regno];</span>
<span class="lineNum">    1209 </span><span class="lineCov">   43338409 :             machine_mode biggest_mode = lra_reg_info[conflict_regno].biggest_mode;</span>
<span class="lineNum">    1210 </span><span class="lineCov">   43338409 :             int biggest_nregs = hard_regno_nregs (conflict_hard_regno,</span>
<span class="lineNum">    1211 </span><span class="lineCov">   43338409 :                                                   biggest_mode);</span>
<span class="lineNum">    1212 </span><span class="lineCov">   43338409 :             int nregs_diff</span>
<span class="lineNum">    1213 </span>            :               = (biggest_nregs
<span class="lineNum">    1214 </span><span class="lineCov">   86676818 :                  - hard_regno_nregs (conflict_hard_regno,</span>
<span class="lineNum">    1215 </span><span class="lineCov">   43338409 :                                      PSEUDO_REGNO_MODE (conflict_regno)));</span>
<span class="lineNum">    1216 </span><span class="lineCov">   43338409 :             add_to_hard_reg_set (&amp;conflict_set,</span>
<span class="lineNum">    1217 </span>            :                                  biggest_mode,
<span class="lineNum">    1218 </span>            :                                  conflict_hard_regno
<span class="lineNum">    1219 </span>            :                                  - (WORDS_BIG_ENDIAN ? nregs_diff : 0));
<span class="lineNum">    1220 </span>            :           }
<span class="lineNum">    1221 </span><span class="lineCov">   15589141 :       if (! overlaps_hard_reg_set_p (conflict_set, mode, hard_regno))</span>
<span class="lineNum">    1222 </span>            :         {
<span class="lineNum">    1223 </span><span class="lineCov">   15579322 :           update_lives (regno, false);</span>
<span class="lineNum">    1224 </span><span class="lineCov">   15579322 :           continue;</span>
<span class="lineNum">    1225 </span>            :         }
<span class="lineNum">    1226 </span><span class="lineCov">       9819 :       bitmap_set_bit (spilled_pseudo_bitmap, regno);</span>
<span class="lineNum">    1227 </span><span class="lineCov">       9819 :       for (j = 0;</span>
<span class="lineNum">    1228 </span><span class="lineCov">      55836 :            j &lt; hard_regno_nregs (hard_regno, PSEUDO_REGNO_MODE (regno));</span>
<span class="lineNum">    1229 </span>            :            j++)
<span class="lineNum">    1230 </span><span class="lineCov">      18099 :         lra_hard_reg_usage[hard_regno + j] -= lra_reg_info[regno].freq;</span>
<span class="lineNum">    1231 </span><span class="lineCov">       9819 :       reg_renumber[regno] = -1;</span>
<span class="lineNum">    1232 </span><span class="lineCov">       9819 :       if (regno &gt;= lra_constraint_new_regno_start)</span>
<span class="lineNum">    1233 </span><span class="lineNoCov">          0 :         former_reload_pseudo_spill_p = true;</span>
<span class="lineNum">    1234 </span><span class="lineCov">       9819 :       if (lra_dump_file != NULL)</span>
<span class="lineNum">    1235 </span><span class="lineNoCov">          0 :         fprintf (lra_dump_file, &quot;    Spill r%d after risky transformations\n&quot;,</span>
<span class="lineNum">    1236 </span>            :                  regno);
<span class="lineNum">    1237 </span>            :     }
<span class="lineNum">    1238 </span>            : }
<span class="lineNum">    1239 </span>            : 
<span class="lineNum">    1240 </span>            : /* Improve allocation by assigning the same hard regno of inheritance
<span class="lineNum">    1241 </span>            :    pseudos to the connected pseudos.  We need this because inheritance
<span class="lineNum">    1242 </span>            :    pseudos are allocated after reload pseudos in the thread and when
<span class="lineNum">    1243 </span>            :    we assign a hard register to a reload pseudo we don't know yet that
<span class="lineNum">    1244 </span>            :    the connected inheritance pseudos can get the same hard register.
<a name="1245"><span class="lineNum">    1245 </span>            :    Add pseudos with changed allocation to bitmap CHANGED_PSEUDOS.  */</a>
<span class="lineNum">    1246 </span>            : static void
<span class="lineNum">    1247 </span><span class="lineCov">     881139 : improve_inheritance (bitmap changed_pseudos)</span>
<span class="lineNum">    1248 </span>            : {
<span class="lineNum">    1249 </span><span class="lineCov">     881139 :   unsigned int k;</span>
<span class="lineNum">    1250 </span><span class="lineCov">     881139 :   int regno, another_regno, hard_regno, another_hard_regno, cost, i, n;</span>
<span class="lineNum">    1251 </span><span class="lineCov">     881139 :   lra_copy_t cp, next_cp;</span>
<span class="lineNum">    1252 </span><span class="lineCov">     881139 :   bitmap_iterator bi;</span>
<span class="lineNum">    1253 </span>            : 
<span class="lineNum">    1254 </span><span class="lineCov">     881139 :   if (lra_inheritance_iter &gt; LRA_MAX_INHERITANCE_PASSES)</span>
<span class="lineNum">    1255 </span><span class="lineCov">       3655 :     return;</span>
<span class="lineNum">    1256 </span><span class="lineCov">     877484 :   n = 0;</span>
<span class="lineNum">    1257 </span><span class="lineCov">    2087975 :   EXECUTE_IF_SET_IN_BITMAP (&amp;lra_inheritance_pseudos, 0, k, bi)</span>
<span class="lineNum">    1258 </span><span class="lineCov">    1210491 :     if (reg_renumber[k] &gt;= 0 &amp;&amp; lra_reg_info[k].nrefs != 0)</span>
<span class="lineNum">    1259 </span><span class="lineCov">     809844 :       sorted_pseudos[n++] = k;</span>
<span class="lineNum">    1260 </span><span class="lineCov">     877484 :   qsort (sorted_pseudos, n, sizeof (int), pseudo_compare_func);</span>
<span class="lineNum">    1261 </span><span class="lineCov">    1687328 :   for (i = 0; i &lt; n; i++)</span>
<span class="lineNum">    1262 </span>            :     {
<span class="lineNum">    1263 </span><span class="lineCov">     809844 :       regno = sorted_pseudos[i];</span>
<span class="lineNum">    1264 </span><span class="lineCov">     809844 :       hard_regno = reg_renumber[regno];</span>
<span class="lineNum">    1265 </span><span class="lineCov">     809844 :       lra_assert (hard_regno &gt;= 0);</span>
<span class="lineNum">    1266 </span><span class="lineCov">    2441414 :       for (cp = lra_reg_info[regno].copies; cp != NULL; cp = next_cp)</span>
<span class="lineNum">    1267 </span>            :         {
<span class="lineNum">    1268 </span><span class="lineCov">    1631570 :           if (cp-&gt;regno1 == regno)</span>
<span class="lineNum">    1269 </span>            :             {
<span class="lineNum">    1270 </span><span class="lineCov">     312298 :               next_cp = cp-&gt;regno1_next;</span>
<span class="lineNum">    1271 </span><span class="lineCov">     312298 :               another_regno = cp-&gt;regno2;</span>
<span class="lineNum">    1272 </span>            :             }
<span class="lineNum">    1273 </span><span class="lineCov">    1319272 :           else if (cp-&gt;regno2 == regno)</span>
<span class="lineNum">    1274 </span>            :             {
<span class="lineNum">    1275 </span><span class="lineCov">    1319272 :               next_cp = cp-&gt;regno2_next;</span>
<span class="lineNum">    1276 </span><span class="lineCov">    1319272 :               another_regno = cp-&gt;regno1;</span>
<span class="lineNum">    1277 </span>            :             }
<span class="lineNum">    1278 </span>            :           else
<span class="lineNum">    1279 </span><span class="lineNoCov">          0 :             gcc_unreachable ();</span>
<span class="lineNum">    1280 </span>            :           /* Don't change reload pseudo allocation.  It might have
<span class="lineNum">    1281 </span>            :              this allocation for a purpose and changing it can result
<span class="lineNum">    1282 </span>            :              in LRA cycling.  */
<span class="lineNum">    1283 </span><span class="lineCov">    1631570 :           if ((another_regno &lt; lra_constraint_new_regno_start</span>
<span class="lineNum">    1284 </span><span class="lineCov">    1631570 :                || bitmap_bit_p (&amp;lra_inheritance_pseudos, another_regno))</span>
<span class="lineNum">    1285 </span><span class="lineCov">     615299 :               &amp;&amp; (another_hard_regno = reg_renumber[another_regno]) &gt;= 0</span>
<span class="lineNum">    1286 </span><span class="lineCov">    2163844 :               &amp;&amp; another_hard_regno != hard_regno)</span>
<span class="lineNum">    1287 </span>            :             {
<span class="lineNum">    1288 </span><span class="lineCov">      52832 :               if (lra_dump_file != NULL)</span>
<span class="lineNum">    1289 </span><span class="lineCov">          7 :                 fprintf</span>
<span class="lineNum">    1290 </span><span class="lineCov">          7 :                   (lra_dump_file,</span>
<span class="lineNum">    1291 </span>            :                    &quot;       Improving inheritance for %d(%d) and %d(%d)...\n&quot;,
<span class="lineNum">    1292 </span>            :                    regno, hard_regno, another_regno, another_hard_regno);
<span class="lineNum">    1293 </span><span class="lineCov">      52832 :               update_lives (another_regno, true);</span>
<span class="lineNum">    1294 </span><span class="lineCov">      52832 :               lra_setup_reg_renumber (another_regno, -1, false);</span>
<span class="lineNum">    1295 </span><span class="lineCov">      52832 :               if (hard_regno == find_hard_regno_for (another_regno, &amp;cost,</span>
<span class="lineNum">    1296 </span>            :                                                      hard_regno, false))
<span class="lineNum">    1297 </span><span class="lineCov">      18677 :                 assign_hard_regno (hard_regno, another_regno);</span>
<span class="lineNum">    1298 </span>            :               else
<span class="lineNum">    1299 </span><span class="lineCov">      34155 :                 assign_hard_regno (another_hard_regno, another_regno);</span>
<span class="lineNum">    1300 </span><span class="lineCov">      52832 :               bitmap_set_bit (changed_pseudos, another_regno);</span>
<span class="lineNum">    1301 </span>            :             }
<span class="lineNum">    1302 </span>            :         }
<span class="lineNum">    1303 </span>            :     }
<span class="lineNum">    1304 </span>            : }
<span class="lineNum">    1305 </span>            : 
<span class="lineNum">    1306 </span>            : 
<span class="lineNum">    1307 </span>            : /* Bitmap finally containing all pseudos spilled on this assignment
<span class="lineNum">    1308 </span>            :    pass.  */
<span class="lineNum">    1309 </span>            : static bitmap_head all_spilled_pseudos;
<span class="lineNum">    1310 </span>            : /* All pseudos whose allocation was changed.  */
<span class="lineNum">    1311 </span>            : static bitmap_head changed_pseudo_bitmap;
<span class="lineNum">    1312 </span>            : 
<span class="lineNum">    1313 </span>            : 
<span class="lineNum">    1314 </span>            : /* Add to LIVE_RANGE_HARD_REG_PSEUDOS all pseudos conflicting with
<a name="1315"><span class="lineNum">    1315 </span>            :    REGNO and whose hard regs can be assigned to REGNO.  */</a>
<span class="lineNum">    1316 </span>            : static void
<span class="lineNum">    1317 </span><span class="lineCov">         18 : find_all_spills_for (int regno)</span>
<span class="lineNum">    1318 </span>            : {
<span class="lineNum">    1319 </span><span class="lineCov">         18 :   int p;</span>
<span class="lineNum">    1320 </span><span class="lineCov">         18 :   lra_live_range_t r;</span>
<span class="lineNum">    1321 </span><span class="lineCov">         18 :   unsigned int k;</span>
<span class="lineNum">    1322 </span><span class="lineCov">         18 :   bitmap_iterator bi;</span>
<span class="lineNum">    1323 </span><span class="lineCov">         18 :   enum reg_class rclass;</span>
<span class="lineNum">    1324 </span><span class="lineCov">         18 :   bool *rclass_intersect_p;</span>
<span class="lineNum">    1325 </span>            : 
<span class="lineNum">    1326 </span><span class="lineCov">         18 :   rclass = regno_allocno_class_array[regno];</span>
<span class="lineNum">    1327 </span><span class="lineCov">         18 :   rclass_intersect_p = ira_reg_classes_intersect_p[rclass];</span>
<span class="lineNum">    1328 </span><span class="lineCov">         36 :   for (r = lra_reg_info[regno].live_ranges; r != NULL; r = r-&gt;next)</span>
<span class="lineNum">    1329 </span>            :     {
<span class="lineNum">    1330 </span><span class="lineCov">        198 :       EXECUTE_IF_SET_IN_BITMAP (&amp;live_hard_reg_pseudos[r-&gt;start], 0, k, bi)</span>
<span class="lineNum">    1331 </span><span class="lineCov">        180 :         if (rclass_intersect_p[regno_allocno_class_array[k]])</span>
<span class="lineNum">    1332 </span><span class="lineCov">        179 :           sparseset_set_bit (live_range_hard_reg_pseudos, k);</span>
<span class="lineNum">    1333 </span><span class="lineCov">         36 :       for (p = r-&gt;start + 1; p &lt;= r-&gt;finish; p++)</span>
<span class="lineNum">    1334 </span>            :         {
<span class="lineNum">    1335 </span><span class="lineCov">         18 :           lra_live_range_t r2;</span>
<span class="lineNum">    1336 </span>            : 
<span class="lineNum">    1337 </span><span class="lineCov">         18 :           for (r2 = start_point_ranges[p];</span>
<span class="lineNum">    1338 </span><span class="lineCov">         19 :                r2 != NULL;</span>
<span class="lineNum">    1339 </span><span class="lineCov">          1 :                r2 = r2-&gt;start_next)</span>
<span class="lineNum">    1340 </span>            :             {
<span class="lineNum">    1341 </span><span class="lineCov">          1 :               if (live_pseudos_reg_renumber[r2-&gt;regno] &gt;= 0</span>
<span class="lineNum">    1342 </span><span class="lineCov">          1 :                   &amp;&amp; ! sparseset_bit_p (live_range_hard_reg_pseudos, r2-&gt;regno)</span>
<span class="lineNum">    1343 </span><span class="lineCov">          1 :                   &amp;&amp; rclass_intersect_p[regno_allocno_class_array[r2-&gt;regno]]</span>
<span class="lineNum">    1344 </span><span class="lineCov">          2 :                   &amp;&amp; ((int) r2-&gt;regno &lt; lra_constraint_new_regno_start</span>
<span class="lineNum">    1345 </span><span class="lineCov">          1 :                       || bitmap_bit_p (&amp;lra_inheritance_pseudos, r2-&gt;regno)</span>
<span class="lineNum">    1346 </span><span class="lineCov">          1 :                       || bitmap_bit_p (&amp;lra_split_regs, r2-&gt;regno)</span>
<span class="lineNum">    1347 </span><span class="lineCov">          1 :                       || bitmap_bit_p (&amp;lra_optional_reload_pseudos, r2-&gt;regno)</span>
<span class="lineNum">    1348 </span>            :                       /* There is no sense to consider another reload
<span class="lineNum">    1349 </span>            :                          pseudo if it has the same class.  */
<span class="lineNum">    1350 </span><span class="lineCov">          1 :                       || regno_allocno_class_array[r2-&gt;regno] != rclass))</span>
<span class="lineNum">    1351 </span><span class="lineCov">          1 :                 sparseset_set_bit (live_range_hard_reg_pseudos, r2-&gt;regno);</span>
<span class="lineNum">    1352 </span>            :             }
<span class="lineNum">    1353 </span>            :         }
<span class="lineNum">    1354 </span>            :     }
<span class="lineNum">    1355 </span><span class="lineCov">         18 : }</span>
<span class="lineNum">    1356 </span>            : 
<span class="lineNum">    1357 </span>            : /* Assign hard registers to reload pseudos and other pseudos.  Return
<span class="lineNum">    1358 </span>            :    true if we was not able to assign hard registers to all reload
<a name="1359"><span class="lineNum">    1359 </span>            :    pseudos.  */</a>
<span class="lineNum">    1360 </span>            : static bool
<span class="lineNum">    1361 </span><span class="lineCov">     881139 : assign_by_spills (void)</span>
<span class="lineNum">    1362 </span>            : {
<span class="lineNum">    1363 </span><span class="lineCov">     881139 :   int i, n, nfails, iter, regno, regno2, hard_regno, cost;</span>
<span class="lineNum">    1364 </span><span class="lineCov">     881139 :   rtx restore_rtx;</span>
<span class="lineNum">    1365 </span><span class="lineCov">     881139 :   bitmap_head changed_insns, do_not_assign_nonreload_pseudos;</span>
<span class="lineNum">    1366 </span><span class="lineCov">     881139 :   unsigned int u, conflict_regno;</span>
<span class="lineNum">    1367 </span><span class="lineCov">     881139 :   bitmap_iterator bi;</span>
<span class="lineNum">    1368 </span><span class="lineCov">     881139 :   bool reload_p, fails_p = false;</span>
<span class="lineNum">    1369 </span><span class="lineCov">     881139 :   int max_regno = max_reg_num ();</span>
<span class="lineNum">    1370 </span>            : 
<span class="lineNum">    1371 </span><span class="lineCov">    8704353 :   for (n = 0, i = lra_constraint_new_regno_start; i &lt; max_regno; i++)</span>
<span class="lineNum">    1372 </span><span class="lineCov">    7823214 :     if (reg_renumber[i] &lt; 0 &amp;&amp; lra_reg_info[i].nrefs != 0</span>
<span class="lineNum">    1373 </span><span class="lineCov">    4858020 :         &amp;&amp; regno_allocno_class_array[i] != NO_REGS)</span>
<span class="lineNum">    1374 </span><span class="lineCov">    4456940 :       sorted_pseudos[n++] = i;</span>
<span class="lineNum">    1375 </span><span class="lineCov">     881139 :   bitmap_initialize (&amp;insn_conflict_pseudos, &amp;reg_obstack);</span>
<span class="lineNum">    1376 </span><span class="lineCov">     881139 :   bitmap_initialize (&amp;spill_pseudos_bitmap, &amp;reg_obstack);</span>
<span class="lineNum">    1377 </span><span class="lineCov">     881139 :   bitmap_initialize (&amp;best_spill_pseudos_bitmap, &amp;reg_obstack);</span>
<span class="lineNum">    1378 </span><span class="lineCov">     881139 :   update_hard_regno_preference_check = XCNEWVEC (int, max_regno);</span>
<span class="lineNum">    1379 </span><span class="lineCov">     881139 :   curr_update_hard_regno_preference_check = 0;</span>
<span class="lineNum">    1380 </span><span class="lineCov">     881139 :   memset (try_hard_reg_pseudos_check, 0, sizeof (try_hard_reg_pseudos_check));</span>
<span class="lineNum">    1381 </span><span class="lineCov">   68728842 :   for (i = 0; i &lt; FIRST_PSEUDO_REGISTER; i++)</span>
<span class="lineNum">    1382 </span><span class="lineCov">  135695406 :     bitmap_initialize (&amp;try_hard_reg_pseudos[i], &amp;reg_obstack);</span>
<span class="lineNum">    1383 </span><span class="lineCov">     881139 :   curr_pseudo_check = 0;</span>
<span class="lineNum">    1384 </span><span class="lineCov">     881139 :   bitmap_initialize (&amp;changed_insns, &amp;reg_obstack);</span>
<span class="lineNum">    1385 </span><span class="lineCov">     881139 :   bitmap_initialize (&amp;non_reload_pseudos, &amp;reg_obstack);</span>
<span class="lineNum">    1386 </span><span class="lineCov">     881139 :   bitmap_ior (&amp;non_reload_pseudos, &amp;lra_inheritance_pseudos, &amp;lra_split_regs);</span>
<span class="lineNum">    1387 </span><span class="lineCov">     881139 :   bitmap_ior_into (&amp;non_reload_pseudos, &amp;lra_subreg_reload_pseudos);</span>
<span class="lineNum">    1388 </span><span class="lineCov">     881139 :   bitmap_ior_into (&amp;non_reload_pseudos, &amp;lra_optional_reload_pseudos);</span>
<span class="lineNum">    1389 </span><span class="lineCov">     881157 :   for (iter = 0; iter &lt;= 1; iter++)</span>
<span class="lineNum">    1390 </span>            :     {
<span class="lineNum">    1391 </span><span class="lineCov">     881157 :       qsort (sorted_pseudos, n, sizeof (int), reload_pseudo_compare_func);</span>
<span class="lineNum">    1392 </span><span class="lineCov">     881157 :       nfails = 0;</span>
<span class="lineNum">    1393 </span><span class="lineCov">    5338817 :       for (i = 0; i &lt; n; i++)</span>
<span class="lineNum">    1394 </span>            :         {
<span class="lineNum">    1395 </span><span class="lineCov">    4457660 :           regno = sorted_pseudos[i];</span>
<span class="lineNum">    1396 </span><span class="lineCov">    4457660 :           if (reg_renumber[regno] &gt;= 0)</span>
<span class="lineNum">    1397 </span>            :             continue;
<span class="lineNum">    1398 </span><span class="lineCov">    4457387 :           if (lra_dump_file != NULL)</span>
<span class="lineNum">    1399 </span><span class="lineCov">       1185 :             fprintf (lra_dump_file, &quot;       Assigning to %d &quot;</span>
<span class="lineNum">    1400 </span>            :                      &quot;(cl=%s, orig=%d, freq=%d, tfirst=%d, tfreq=%d)...\n&quot;,
<span class="lineNum">    1401 </span><span class="lineCov">        237 :                      regno, reg_class_names[regno_allocno_class_array[regno]],</span>
<span class="lineNum">    1402 </span><span class="lineCov">        237 :                      ORIGINAL_REGNO (regno_reg_rtx[regno]),</span>
<span class="lineNum">    1403 </span><span class="lineCov">        237 :                      lra_reg_info[regno].freq, regno_assign_info[regno].first,</span>
<span class="lineNum">    1404 </span><span class="lineCov">        237 :                      regno_assign_info[regno_assign_info[regno].first].freq);</span>
<span class="lineNum">    1405 </span><span class="lineCov">    4457387 :           hard_regno = find_hard_regno_for (regno, &amp;cost, -1, iter == 1);</span>
<span class="lineNum">    1406 </span><span class="lineCov">    4457387 :           reload_p = ! bitmap_bit_p (&amp;non_reload_pseudos, regno);</span>
<span class="lineNum">    1407 </span><span class="lineCov">    4457387 :           if (hard_regno &lt; 0 &amp;&amp; reload_p)</span>
<span class="lineNum">    1408 </span><span class="lineCov">      23048 :             hard_regno = spill_for (regno, &amp;all_spilled_pseudos, iter == 1);</span>
<span class="lineNum">    1409 </span><span class="lineCov">    4457387 :           if (hard_regno &lt; 0)</span>
<span class="lineNum">    1410 </span>            :             {
<span class="lineNum">    1411 </span><span class="lineCov">     321584 :               if (reload_p) {</span>
<span class="lineNum">    1412 </span>            :                 /* Put unassigned reload pseudo first in the
<span class="lineNum">    1413 </span>            :                    array.  */
<span class="lineNum">    1414 </span><span class="lineCov">         27 :                 regno2 = sorted_pseudos[nfails];</span>
<span class="lineNum">    1415 </span><span class="lineCov">         27 :                 sorted_pseudos[nfails++] = regno;</span>
<span class="lineNum">    1416 </span><span class="lineCov">         27 :                 sorted_pseudos[i] = regno2;</span>
<span class="lineNum">    1417 </span>            :               }
<span class="lineNum">    1418 </span>            :             }
<span class="lineNum">    1419 </span>            :           else
<span class="lineNum">    1420 </span>            :             {
<span class="lineNum">    1421 </span>            :               /* This register might have been spilled by the previous
<span class="lineNum">    1422 </span>            :                  pass.  Indicate that it is no longer spilled.  */
<span class="lineNum">    1423 </span><span class="lineCov">    4135803 :               bitmap_clear_bit (&amp;all_spilled_pseudos, regno);</span>
<span class="lineNum">    1424 </span><span class="lineCov">    4135803 :               assign_hard_regno (hard_regno, regno);</span>
<span class="lineNum">    1425 </span><span class="lineCov">    4135803 :               if (! reload_p)</span>
<span class="lineNum">    1426 </span>            :                 /* As non-reload pseudo assignment is changed we
<span class="lineNum">    1427 </span>            :                    should reconsider insns referring for the
<span class="lineNum">    1428 </span>            :                    pseudo.  */
<span class="lineNum">    1429 </span><span class="lineCov">    1034268 :                 bitmap_set_bit (&amp;changed_pseudo_bitmap, regno);</span>
<span class="lineNum">    1430 </span>            :             }
<span class="lineNum">    1431 </span>            :         }
<span class="lineNum">    1432 </span><span class="lineCov">     881157 :       if (nfails == 0 || iter &gt; 0)</span>
<span class="lineNum">    1433 </span>            :         {
<span class="lineNum">    1434 </span><span class="lineCov">     881139 :           fails_p = nfails != 0;</span>
<span class="lineNum">    1435 </span><span class="lineCov">     881139 :           break;</span>
<span class="lineNum">    1436 </span>            :         }
<span class="lineNum">    1437 </span>            :       /* This is a very rare event.  We can not assign a hard register
<span class="lineNum">    1438 </span>            :          to reload pseudo because the hard register was assigned to
<span class="lineNum">    1439 </span>            :          another reload pseudo on a previous assignment pass.  For x86
<span class="lineNum">    1440 </span>            :          example, on the 1st pass we assigned CX (although another
<span class="lineNum">    1441 </span>            :          hard register could be used for this) to reload pseudo in an
<span class="lineNum">    1442 </span>            :          insn, on the 2nd pass we need CX (and only this) hard
<span class="lineNum">    1443 </span>            :          register for a new reload pseudo in the same insn.  Another
<span class="lineNum">    1444 </span>            :          possible situation may occur in assigning to multi-regs
<span class="lineNum">    1445 </span>            :          reload pseudos when hard regs pool is too fragmented even
<span class="lineNum">    1446 </span>            :          after spilling non-reload pseudos.
<span class="lineNum">    1447 </span>            : 
<span class="lineNum">    1448 </span>            :          We should do something radical here to succeed.  Here we
<span class="lineNum">    1449 </span>            :          spill *all* conflicting pseudos and reassign them.  */
<span class="lineNum">    1450 </span><span class="lineCov">         18 :       if (lra_dump_file != NULL)</span>
<span class="lineNum">    1451 </span><span class="lineNoCov">          0 :         fprintf (lra_dump_file, &quot;  2nd iter for reload pseudo assignments:\n&quot;);</span>
<span class="lineNum">    1452 </span><span class="lineCov">         18 :       sparseset_clear (live_range_hard_reg_pseudos);</span>
<span class="lineNum">    1453 </span><span class="lineCov">         36 :       for (i = 0; i &lt; nfails; i++)</span>
<span class="lineNum">    1454 </span>            :         {
<span class="lineNum">    1455 </span><span class="lineCov">         18 :           if (lra_dump_file != NULL)</span>
<span class="lineNum">    1456 </span><span class="lineNoCov">          0 :             fprintf (lra_dump_file, &quot;       Reload r%d assignment failure\n&quot;,</span>
<span class="lineNum">    1457 </span><span class="lineNoCov">          0 :                      sorted_pseudos[i]);</span>
<span class="lineNum">    1458 </span><span class="lineCov">         18 :           find_all_spills_for (sorted_pseudos[i]);</span>
<span class="lineNum">    1459 </span>            :         }
<span class="lineNum">    1460 </span><span class="lineCov">        378 :       EXECUTE_IF_SET_IN_SPARSESET (live_range_hard_reg_pseudos, conflict_regno)</span>
<span class="lineNum">    1461 </span>            :         {
<span class="lineNum">    1462 </span><span class="lineCov">        180 :           if ((int) conflict_regno &gt;= lra_constraint_new_regno_start)</span>
<span class="lineNum">    1463 </span>            :             {
<span class="lineNum">    1464 </span><span class="lineCov">        108 :               sorted_pseudos[nfails++] = conflict_regno;</span>
<span class="lineNum">    1465 </span><span class="lineCov">        108 :               former_reload_pseudo_spill_p = true;</span>
<span class="lineNum">    1466 </span>            :             }
<span class="lineNum">    1467 </span>            :           else
<span class="lineNum">    1468 </span>            :             /* It is better to do reloads before spilling as after the
<span class="lineNum">    1469 </span>            :                spill-subpass we will reload memory instead of pseudos
<span class="lineNum">    1470 </span>            :                and this will make reusing reload pseudos more
<span class="lineNum">    1471 </span>            :                complicated.  Going directly to the spill pass in such
<span class="lineNum">    1472 </span>            :                case might result in worse code performance or even LRA
<span class="lineNum">    1473 </span>            :                cycling if we have few registers.  */
<span class="lineNum">    1474 </span><span class="lineCov">         72 :             bitmap_set_bit (&amp;all_spilled_pseudos, conflict_regno);</span>
<span class="lineNum">    1475 </span><span class="lineCov">        180 :           if (lra_dump_file != NULL)</span>
<span class="lineNum">    1476 </span><span class="lineNoCov">          0 :             fprintf (lra_dump_file, &quot;        Spill %s r%d(hr=%d, freq=%d)\n&quot;,</span>
<span class="lineNum">    1477 </span>            :                      pseudo_prefix_title (conflict_regno), conflict_regno,
<span class="lineNum">    1478 </span><span class="lineNoCov">          0 :                      reg_renumber[conflict_regno],</span>
<span class="lineNum">    1479 </span><span class="lineNoCov">          0 :                      lra_reg_info[conflict_regno].freq);</span>
<span class="lineNum">    1480 </span><span class="lineCov">        180 :           update_lives (conflict_regno, true);</span>
<span class="lineNum">    1481 </span><span class="lineCov">        180 :           lra_setup_reg_renumber (conflict_regno, -1, false);</span>
<span class="lineNum">    1482 </span>            :         }
<span class="lineNum">    1483 </span><span class="lineCov">         18 :       if (n &lt; nfails)</span>
<span class="lineNum">    1484 </span><span class="lineCov">          2 :         n = nfails;</span>
<span class="lineNum">    1485 </span>            :     }
<span class="lineNum">    1486 </span><span class="lineCov">     881139 :   improve_inheritance (&amp;changed_pseudo_bitmap);</span>
<span class="lineNum">    1487 </span><span class="lineCov">     881139 :   bitmap_clear (&amp;non_reload_pseudos);</span>
<span class="lineNum">    1488 </span><span class="lineCov">     881139 :   bitmap_clear (&amp;changed_insns);</span>
<span class="lineNum">    1489 </span><span class="lineCov">     881139 :   if (! lra_simple_p)</span>
<span class="lineNum">    1490 </span>            :     {
<span class="lineNum">    1491 </span>            :       /* We should not assign to original pseudos of inheritance
<span class="lineNum">    1492 </span>            :          pseudos or split pseudos if any its inheritance pseudo did
<span class="lineNum">    1493 </span>            :          not get hard register or any its split pseudo was not split
<span class="lineNum">    1494 </span>            :          because undo inheritance/split pass will extend live range of
<span class="lineNum">    1495 </span>            :          such inheritance or split pseudos.  */
<span class="lineNum">    1496 </span><span class="lineCov">     881127 :       bitmap_initialize (&amp;do_not_assign_nonreload_pseudos, &amp;reg_obstack);</span>
<span class="lineNum">    1497 </span><span class="lineCov">    2196352 :       EXECUTE_IF_SET_IN_BITMAP (&amp;lra_inheritance_pseudos, 0, u, bi)</span>
<span class="lineNum">    1498 </span><span class="lineCov">    1315225 :         if ((restore_rtx = lra_reg_info[u].restore_rtx) != NULL_RTX</span>
<span class="lineNum">    1499 </span><span class="lineCov">     738172 :             &amp;&amp; REG_P (restore_rtx)</span>
<span class="lineNum">    1500 </span><span class="lineCov">     731134 :             &amp;&amp; reg_renumber[u] &lt; 0</span>
<span class="lineNum">    1501 </span><span class="lineCov">    1603259 :             &amp;&amp; bitmap_bit_p (&amp;lra_inheritance_pseudos, u))</span>
<span class="lineNum">    1502 </span><span class="lineCov">     576068 :           bitmap_set_bit (&amp;do_not_assign_nonreload_pseudos, REGNO (restore_rtx));</span>
<span class="lineNum">    1503 </span><span class="lineCov">    1232936 :       EXECUTE_IF_SET_IN_BITMAP (&amp;lra_split_regs, 0, u, bi)</span>
<span class="lineNum">    1504 </span><span class="lineCov">     351809 :         if ((restore_rtx = lra_reg_info[u].restore_rtx) != NULL_RTX</span>
<span class="lineNum">    1505 </span><span class="lineCov">     351809 :             &amp;&amp; reg_renumber[u] &gt;= 0)</span>
<span class="lineNum">    1506 </span>            :           {
<span class="lineNum">    1507 </span><span class="lineCov">        906 :             lra_assert (REG_P (restore_rtx));</span>
<span class="lineNum">    1508 </span><span class="lineCov">       1812 :             bitmap_set_bit (&amp;do_not_assign_nonreload_pseudos, REGNO (restore_rtx));</span>
<span class="lineNum">    1509 </span>            :           }
<span class="lineNum">    1510 </span><span class="lineCov">   55458246 :       for (n = 0, i = FIRST_PSEUDO_REGISTER; i &lt; max_regno; i++)</span>
<span class="lineNum">    1511 </span><span class="lineCov">   54577119 :         if (((i &lt; lra_constraint_new_regno_start</span>
<span class="lineNum">    1512 </span><span class="lineCov">   46768956 :               &amp;&amp; ! bitmap_bit_p (&amp;do_not_assign_nonreload_pseudos, i))</span>
<span class="lineNum">    1513 </span><span class="lineCov">    7992968 :              || (bitmap_bit_p (&amp;lra_inheritance_pseudos, i)</span>
<span class="lineNum">    1514 </span><span class="lineCov">    1315225 :                  &amp;&amp; lra_reg_info[i].restore_rtx != NULL_RTX)</span>
<span class="lineNum">    1515 </span><span class="lineCov">    7254796 :              || (bitmap_bit_p (&amp;lra_split_regs, i)</span>
<span class="lineNum">    1516 </span><span class="lineCov">     351809 :                  &amp;&amp; lra_reg_info[i].restore_rtx != NULL_RTX)</span>
<span class="lineNum">    1517 </span><span class="lineCov">    7045998 :              || bitmap_bit_p (&amp;lra_subreg_reload_pseudos, i)</span>
<span class="lineNum">    1518 </span><span class="lineCov">    7044483 :              || bitmap_bit_p (&amp;lra_optional_reload_pseudos, i))</span>
<span class="lineNum">    1519 </span><span class="lineCov">   48616910 :             &amp;&amp; reg_renumber[i] &lt; 0 &amp;&amp; lra_reg_info[i].nrefs != 0</span>
<span class="lineNum">    1520 </span><span class="lineCov">   55865005 :             &amp;&amp; regno_allocno_class_array[i] != NO_REGS)</span>
<span class="lineNum">    1521 </span><span class="lineCov">    1038551 :           sorted_pseudos[n++] = i;</span>
<span class="lineNum">    1522 </span><span class="lineCov">     881127 :       bitmap_clear (&amp;do_not_assign_nonreload_pseudos);</span>
<span class="lineNum">    1523 </span><span class="lineCov">     881127 :       if (n != 0 &amp;&amp; lra_dump_file != NULL)</span>
<span class="lineNum">    1524 </span><span class="lineCov">         14 :         fprintf (lra_dump_file, &quot;  Reassigning non-reload pseudos\n&quot;);</span>
<span class="lineNum">    1525 </span><span class="lineCov">     881127 :       qsort (sorted_pseudos, n, sizeof (int), pseudo_compare_func);</span>
<span class="lineNum">    1526 </span><span class="lineCov">    1919678 :       for (i = 0; i &lt; n; i++)</span>
<span class="lineNum">    1527 </span>            :         {
<span class="lineNum">    1528 </span><span class="lineCov">    1038551 :           regno = sorted_pseudos[i];</span>
<span class="lineNum">    1529 </span><span class="lineCov">    1038551 :           hard_regno = find_hard_regno_for (regno, &amp;cost, -1, false);</span>
<span class="lineNum">    1530 </span><span class="lineCov">    1038551 :           if (hard_regno &gt;= 0)</span>
<span class="lineNum">    1531 </span>            :             {
<span class="lineNum">    1532 </span><span class="lineCov">      46820 :               assign_hard_regno (hard_regno, regno);</span>
<span class="lineNum">    1533 </span>            :               /* We change allocation for non-reload pseudo on this
<span class="lineNum">    1534 </span>            :                  iteration -- mark the pseudo for invalidation of used
<span class="lineNum">    1535 </span>            :                  alternatives of insns containing the pseudo.  */
<span class="lineNum">    1536 </span><span class="lineCov">      46820 :               bitmap_set_bit (&amp;changed_pseudo_bitmap, regno);</span>
<span class="lineNum">    1537 </span>            :             }
<span class="lineNum">    1538 </span>            :           else
<span class="lineNum">    1539 </span>            :             {
<span class="lineNum">    1540 </span><span class="lineCov">     991731 :               enum reg_class rclass = lra_get_allocno_class (regno);</span>
<span class="lineNum">    1541 </span><span class="lineCov">     991731 :               enum reg_class spill_class;</span>
<span class="lineNum">    1542 </span>            :               
<span class="lineNum">    1543 </span><span class="lineCov">     991731 :               if (targetm.spill_class == NULL</span>
<span class="lineNum">    1544 </span><span class="lineCov">     991731 :                   || lra_reg_info[regno].restore_rtx == NULL_RTX</span>
<span class="lineNum">    1545 </span><span class="lineCov">     299637 :                   || ! bitmap_bit_p (&amp;lra_inheritance_pseudos, regno)</span>
<span class="lineNum">    1546 </span><span class="lineCov">     991731 :                   || (spill_class</span>
<span class="lineNum">    1547 </span><span class="lineCov">     277657 :                       = ((enum reg_class)</span>
<span class="lineNum">    1548 </span><span class="lineCov">     277657 :                          targetm.spill_class</span>
<span class="lineNum">    1549 </span><span class="lineCov">     277657 :                          ((reg_class_t) rclass,</span>
<span class="lineNum">    1550 </span><span class="lineCov">     277657 :                           PSEUDO_REGNO_MODE (regno)))) == NO_REGS)</span>
<span class="lineNum">    1551 </span><span class="lineCov">     991731 :                 continue;</span>
<span class="lineNum">    1552 </span><span class="lineNoCov">          0 :               regno_allocno_class_array[regno] = spill_class;</span>
<span class="lineNum">    1553 </span><span class="lineNoCov">          0 :               hard_regno = find_hard_regno_for (regno, &amp;cost, -1, false);</span>
<span class="lineNum">    1554 </span><span class="lineNoCov">          0 :               if (hard_regno &lt; 0)</span>
<span class="lineNum">    1555 </span><span class="lineNoCov">          0 :                 regno_allocno_class_array[regno] = rclass;</span>
<span class="lineNum">    1556 </span>            :               else
<span class="lineNum">    1557 </span>            :                 {
<span class="lineNum">    1558 </span><span class="lineNoCov">          0 :                   setup_reg_classes</span>
<span class="lineNum">    1559 </span><span class="lineNoCov">          0 :                     (regno, spill_class, spill_class, spill_class);</span>
<span class="lineNum">    1560 </span><span class="lineNoCov">          0 :                   assign_hard_regno (hard_regno, regno);</span>
<span class="lineNum">    1561 </span><span class="lineNoCov">          0 :                   bitmap_set_bit (&amp;changed_pseudo_bitmap, regno);</span>
<span class="lineNum">    1562 </span>            :                 }
<span class="lineNum">    1563 </span>            :             }
<span class="lineNum">    1564 </span>            :         }
<span class="lineNum">    1565 </span>            :     }
<span class="lineNum">    1566 </span><span class="lineCov">     881139 :   free (update_hard_regno_preference_check);</span>
<span class="lineNum">    1567 </span><span class="lineCov">     881139 :   bitmap_clear (&amp;best_spill_pseudos_bitmap);</span>
<span class="lineNum">    1568 </span><span class="lineCov">     881139 :   bitmap_clear (&amp;spill_pseudos_bitmap);</span>
<span class="lineNum">    1569 </span><span class="lineCov">     881139 :   bitmap_clear (&amp;insn_conflict_pseudos);</span>
<span class="lineNum">    1570 </span><span class="lineCov">     881139 :   return fails_p;</span>
<span class="lineNum">    1571 </span>            : }
<span class="lineNum">    1572 </span>            : 
<span class="lineNum">    1573 </span>            : /* Entry function to assign hard registers to new reload pseudos
<span class="lineNum">    1574 </span>            :    starting with LRA_CONSTRAINT_NEW_REGNO_START (by possible spilling
<span class="lineNum">    1575 </span>            :    of old pseudos) and possibly to the old pseudos.  The function adds
<span class="lineNum">    1576 </span>            :    what insns to process for the next constraint pass.  Those are all
<span class="lineNum">    1577 </span>            :    insns who contains non-reload and non-inheritance pseudos with
<span class="lineNum">    1578 </span>            :    changed allocation.
<span class="lineNum">    1579 </span>            : 
<span class="lineNum">    1580 </span>            :    Return true if we did not spill any non-reload and non-inheritance
<span class="lineNum">    1581 </span>            :    pseudos.  Set up FAILS_P if we failed to assign hard registers to
<a name="1582"><span class="lineNum">    1582 </span>            :    all reload pseudos.  */</a>
<span class="lineNum">    1583 </span>            : bool
<span class="lineNum">    1584 </span><span class="lineCov">     881139 : lra_assign (bool &amp;fails_p)</span>
<span class="lineNum">    1585 </span>            : {
<span class="lineNum">    1586 </span><span class="lineCov">     881139 :   int i;</span>
<span class="lineNum">    1587 </span><span class="lineCov">     881139 :   unsigned int u;</span>
<span class="lineNum">    1588 </span><span class="lineCov">     881139 :   bitmap_iterator bi;</span>
<span class="lineNum">    1589 </span><span class="lineCov">     881139 :   bitmap_head insns_to_process;</span>
<span class="lineNum">    1590 </span><span class="lineCov">     881139 :   bool no_spills_p;</span>
<span class="lineNum">    1591 </span><span class="lineCov">     881139 :   int max_regno = max_reg_num ();</span>
<span class="lineNum">    1592 </span>            : 
<span class="lineNum">    1593 </span><span class="lineCov">     881139 :   timevar_push (TV_LRA_ASSIGN);</span>
<span class="lineNum">    1594 </span><span class="lineCov">     881139 :   lra_assignment_iter++;</span>
<span class="lineNum">    1595 </span><span class="lineCov">     881139 :   if (lra_dump_file != NULL)</span>
<span class="lineNum">    1596 </span><span class="lineCov">        107 :     fprintf (lra_dump_file, &quot;\n********** Assignment #%d: **********\n\n&quot;,</span>
<span class="lineNum">    1597 </span>            :              lra_assignment_iter);
<span class="lineNum">    1598 </span><span class="lineCov">     881139 :   init_lives ();</span>
<span class="lineNum">    1599 </span><span class="lineCov">     881139 :   sorted_pseudos = XNEWVEC (int, max_regno);</span>
<span class="lineNum">    1600 </span><span class="lineCov">     881139 :   sorted_reload_pseudos = XNEWVEC (int, max_regno);</span>
<span class="lineNum">    1601 </span><span class="lineCov">     881139 :   regno_allocno_class_array = XNEWVEC (enum reg_class, max_regno);</span>
<span class="lineNum">    1602 </span><span class="lineCov">     881139 :   regno_live_length = XNEWVEC (int, max_regno);</span>
<span class="lineNum">    1603 </span><span class="lineCov">   55874723 :   for (i = FIRST_PSEUDO_REGISTER; i &lt; max_regno; i++)</span>
<span class="lineNum">    1604 </span>            :     {
<span class="lineNum">    1605 </span><span class="lineCov">   54993584 :       int l;</span>
<span class="lineNum">    1606 </span><span class="lineCov">   54993584 :       lra_live_range_t r;</span>
<span class="lineNum">    1607 </span>            : 
<span class="lineNum">    1608 </span><span class="lineCov">   54993584 :       regno_allocno_class_array[i] = lra_get_allocno_class (i);</span>
<span class="lineNum">    1609 </span><span class="lineCov">   87403270 :       for (l = 0, r = lra_reg_info[i].live_ranges; r != NULL; r = r-&gt;next)</span>
<span class="lineNum">    1610 </span><span class="lineCov">   32409686 :         l  += r-&gt;finish - r-&gt;start + 1;</span>
<span class="lineNum">    1611 </span><span class="lineCov">   54993584 :       regno_live_length[i] = l;</span>
<span class="lineNum">    1612 </span>            :     }
<span class="lineNum">    1613 </span><span class="lineCov">     881139 :   former_reload_pseudo_spill_p = false;</span>
<span class="lineNum">    1614 </span><span class="lineCov">     881139 :   init_regno_assign_info ();</span>
<span class="lineNum">    1615 </span><span class="lineCov">     881139 :   bitmap_initialize (&amp;all_spilled_pseudos, &amp;reg_obstack);</span>
<span class="lineNum">    1616 </span><span class="lineCov">     881139 :   create_live_range_start_chains ();</span>
<span class="lineNum">    1617 </span><span class="lineCov">     881139 :   setup_live_pseudos_and_spill_after_risky_transforms (&amp;all_spilled_pseudos);</span>
<span class="lineNum">    1618 </span><span class="lineCov">     881139 :   if (flag_checking &amp;&amp; !flag_ipa_ra)</span>
<span class="lineNum">    1619 </span><span class="lineCov">   11647492 :     for (i = FIRST_PSEUDO_REGISTER; i &lt; max_regno; i++)</span>
<span class="lineNum">    1620 </span><span class="lineCov">    7968976 :       if (lra_reg_info[i].nrefs != 0 &amp;&amp; reg_renumber[i] &gt;= 0</span>
<span class="lineNum">    1621 </span><span class="lineCov">    7342737 :           &amp;&amp; lra_reg_info[i].call_p</span>
<span class="lineNum">    1622 </span><span class="lineCov">   11391402 :           &amp;&amp; overlaps_hard_reg_set_p (call_used_reg_set,</span>
<span class="lineNum">    1623 </span><span class="lineCov">     138592 :                                       PSEUDO_REGNO_MODE (i), reg_renumber[i]))</span>
<span class="lineNum">    1624 </span><span class="lineNoCov">          0 :         gcc_unreachable ();</span>
<span class="lineNum">    1625 </span>            :   /* Setup insns to process on the next constraint pass.  */
<span class="lineNum">    1626 </span><span class="lineCov">     881139 :   bitmap_initialize (&amp;changed_pseudo_bitmap, &amp;reg_obstack);</span>
<span class="lineNum">    1627 </span><span class="lineCov">     881139 :   init_live_reload_and_inheritance_pseudos ();</span>
<span class="lineNum">    1628 </span><span class="lineCov">     881139 :   fails_p = assign_by_spills ();</span>
<span class="lineNum">    1629 </span><span class="lineCov">     881139 :   finish_live_reload_and_inheritance_pseudos ();</span>
<span class="lineNum">    1630 </span><span class="lineCov">     881139 :   bitmap_ior_into (&amp;changed_pseudo_bitmap, &amp;all_spilled_pseudos);</span>
<span class="lineNum">    1631 </span><span class="lineCov">     881139 :   no_spills_p = true;</span>
<span class="lineNum">    1632 </span><span class="lineCov">     881372 :   EXECUTE_IF_SET_IN_BITMAP (&amp;all_spilled_pseudos, 0, u, bi)</span>
<span class="lineNum">    1633 </span>            :     /* We ignore spilled pseudos created on last inheritance pass
<span class="lineNum">    1634 </span>            :        because they will be removed.  */
<span class="lineNum">    1635 </span><span class="lineCov">      17545 :     if (lra_reg_info[u].restore_rtx == NULL_RTX)</span>
<span class="lineNum">    1636 </span>            :       {
<span class="lineNum">    1637 </span>            :         no_spills_p = false;
<span class="lineNum">    1638 </span>            :         break;
<span class="lineNum">    1639 </span>            :       }
<span class="lineNum">    1640 </span><span class="lineCov">     881139 :   finish_live_range_start_chains ();</span>
<span class="lineNum">    1641 </span><span class="lineCov">     881139 :   bitmap_clear (&amp;all_spilled_pseudos);</span>
<span class="lineNum">    1642 </span><span class="lineCov">     881139 :   bitmap_initialize (&amp;insns_to_process, &amp;reg_obstack);</span>
<span class="lineNum">    1643 </span><span class="lineCov">    1994660 :   EXECUTE_IF_SET_IN_BITMAP (&amp;changed_pseudo_bitmap, 0, u, bi)</span>
<span class="lineNum">    1644 </span><span class="lineCov">    1113521 :     bitmap_ior_into (&amp;insns_to_process, &amp;lra_reg_info[u].insn_bitmap);</span>
<span class="lineNum">    1645 </span><span class="lineCov">     881139 :   bitmap_clear (&amp;changed_pseudo_bitmap);</span>
<span class="lineNum">    1646 </span><span class="lineCov">    3434492 :   EXECUTE_IF_SET_IN_BITMAP (&amp;insns_to_process, 0, u, bi)</span>
<span class="lineNum">    1647 </span>            :     {
<span class="lineNum">    1648 </span><span class="lineCov">    2553353 :       lra_push_insn_by_uid (u);</span>
<span class="lineNum">    1649 </span>            :       /* Invalidate alternatives for insn should be processed.  */
<span class="lineNum">    1650 </span><span class="lineCov">    2553353 :       lra_set_used_insn_alternative_by_uid (u, -1);</span>
<span class="lineNum">    1651 </span>            :     }
<span class="lineNum">    1652 </span><span class="lineCov">     881139 :   bitmap_clear (&amp;insns_to_process);</span>
<span class="lineNum">    1653 </span><span class="lineCov">     881139 :   finish_regno_assign_info ();</span>
<span class="lineNum">    1654 </span><span class="lineCov">     881139 :   free (regno_live_length);</span>
<span class="lineNum">    1655 </span><span class="lineCov">     881139 :   free (regno_allocno_class_array);</span>
<span class="lineNum">    1656 </span><span class="lineCov">     881139 :   free (sorted_pseudos);</span>
<span class="lineNum">    1657 </span><span class="lineCov">     881139 :   free (sorted_reload_pseudos);</span>
<span class="lineNum">    1658 </span><span class="lineCov">     881139 :   finish_lives ();</span>
<span class="lineNum">    1659 </span><span class="lineCov">     881139 :   timevar_pop (TV_LRA_ASSIGN);</span>
<span class="lineNum">    1660 </span><span class="lineCov">     881139 :   if (former_reload_pseudo_spill_p)</span>
<span class="lineNum">    1661 </span><span class="lineCov">        653 :     lra_assignment_iter_after_spill++;</span>
<span class="lineNum">    1662 </span>            :   /* This is conditional on flag_checking because valid code can take
<span class="lineNum">    1663 </span>            :      more than this maximum number of iteration, but at the same time
<span class="lineNum">    1664 </span>            :      the test can uncover errors in machine descriptions.  */
<span class="lineNum">    1665 </span><span class="lineCov">     881139 :   if (flag_checking</span>
<span class="lineNum">    1666 </span><span class="lineCov">     881128 :       &amp;&amp; (lra_assignment_iter_after_spill</span>
<span class="lineNum">    1667 </span><span class="lineCov">     881128 :           &gt; LRA_MAX_ASSIGNMENT_ITERATION_NUMBER))</span>
<span class="lineNum">    1668 </span><span class="lineNoCov">          0 :     internal_error</span>
<span class="lineNum">    1669 </span><span class="lineNoCov">          0 :       (&quot;Maximum number of LRA assignment passes is achieved (%d)\n&quot;,</span>
<span class="lineNum">    1670 </span>            :        LRA_MAX_ASSIGNMENT_ITERATION_NUMBER);
<span class="lineNum">    1671 </span><span class="lineCov">     881139 :   return no_spills_p;</span>
<span class="lineNum">    1672 </span>            : }
<span class="lineNum">    1673 </span>            : 
<span class="lineNum">    1674 </span>            : /* Find start and finish insns for reload pseudo REGNO.  Return true
<span class="lineNum">    1675 </span>            :    if we managed to find the expected insns.  Return false,
<a name="1676"><span class="lineNum">    1676 </span>            :    otherwise.  */</a>
<span class="lineNum">    1677 </span>            : static bool
<span class="lineNum">    1678 </span><span class="lineCov">          9 : find_reload_regno_insns (int regno, rtx_insn * &amp;start, rtx_insn * &amp;finish)</span>
<span class="lineNum">    1679 </span>            : {
<span class="lineNum">    1680 </span><span class="lineCov">          9 :   unsigned int uid;</span>
<span class="lineNum">    1681 </span><span class="lineCov">          9 :   bitmap_iterator bi;</span>
<span class="lineNum">    1682 </span><span class="lineCov">          9 :   int n = 0;</span>
<span class="lineNum">    1683 </span><span class="lineCov">          9 :   rtx_insn *prev_insn, *next_insn;</span>
<span class="lineNum">    1684 </span><span class="lineCov">          9 :   rtx_insn *start_insn = NULL, *first_insn = NULL, *second_insn = NULL;</span>
<span class="lineNum">    1685 </span>            :   
<span class="lineNum">    1686 </span><span class="lineCov">         28 :   EXECUTE_IF_SET_IN_BITMAP (&amp;lra_reg_info[regno].insn_bitmap, 0, uid, bi)</span>
<span class="lineNum">    1687 </span>            :     {
<span class="lineNum">    1688 </span><span class="lineCov">         19 :       if (start_insn == NULL)</span>
<span class="lineNum">    1689 </span><span class="lineCov">          9 :         start_insn = lra_insn_recog_data[uid]-&gt;insn;</span>
<span class="lineNum">    1690 </span><span class="lineCov">         19 :       n++;</span>
<span class="lineNum">    1691 </span>            :     }
<span class="lineNum">    1692 </span>            :   /* For reload pseudo we should have at most 3 insns referring for it:
<span class="lineNum">    1693 </span>            :      input/output reload insns and the original insn.  */
<span class="lineNum">    1694 </span><span class="lineCov">          9 :   if (n &gt; 3)</span>
<span class="lineNum">    1695 </span>            :     return false;
<span class="lineNum">    1696 </span><span class="lineCov">          9 :   if (n &gt; 1)</span>
<span class="lineNum">    1697 </span>            :     {
<span class="lineNum">    1698 </span><span class="lineCov">          9 :       for (prev_insn = PREV_INSN (start_insn),</span>
<span class="lineNum">    1699 </span><span class="lineCov">         18 :              next_insn = NEXT_INSN (start_insn);</span>
<span class="lineNum">    1700 </span><span class="lineCov">         20 :            n != 1 &amp;&amp; (prev_insn != NULL || next_insn != NULL); )</span>
<span class="lineNum">    1701 </span>            :         {
<span class="lineNum">    1702 </span><span class="lineCov">         11 :           if (prev_insn != NULL &amp;&amp; first_insn == NULL)</span>
<span class="lineNum">    1703 </span>            :             {
<span class="lineNum">    1704 </span><span class="lineCov">         11 :               if (! bitmap_bit_p (&amp;lra_reg_info[regno].insn_bitmap,</span>
<span class="lineNum">    1705 </span><span class="lineCov">         11 :                                   INSN_UID (prev_insn)))</span>
<span class="lineNum">    1706 </span><span class="lineCov">          4 :                 prev_insn = PREV_INSN (prev_insn);</span>
<span class="lineNum">    1707 </span>            :               else
<span class="lineNum">    1708 </span>            :                 {
<span class="lineNum">    1709 </span><span class="lineCov">          9 :                   first_insn = prev_insn;</span>
<span class="lineNum">    1710 </span><span class="lineCov">          9 :                   n--;</span>
<span class="lineNum">    1711 </span>            :                 }
<span class="lineNum">    1712 </span>            :             }
<span class="lineNum">    1713 </span><span class="lineCov">         11 :           if (next_insn != NULL &amp;&amp; second_insn == NULL)</span>
<span class="lineNum">    1714 </span>            :             {
<span class="lineNum">    1715 </span><span class="lineCov">         11 :               if (! bitmap_bit_p (&amp;lra_reg_info[regno].insn_bitmap,</span>
<span class="lineNum">    1716 </span><span class="lineCov">         11 :                                 INSN_UID (next_insn)))</span>
<span class="lineNum">    1717 </span><span class="lineCov">         20 :                 next_insn = NEXT_INSN (next_insn);</span>
<span class="lineNum">    1718 </span>            :               else
<span class="lineNum">    1719 </span>            :                 {
<span class="lineNum">    1720 </span><span class="lineCov">          1 :                   second_insn = next_insn;</span>
<span class="lineNum">    1721 </span><span class="lineCov">          1 :                   n--;</span>
<span class="lineNum">    1722 </span>            :                 }
<span class="lineNum">    1723 </span>            :             }
<span class="lineNum">    1724 </span>            :         }
<span class="lineNum">    1725 </span><span class="lineCov">          9 :       if (n &gt; 1)</span>
<span class="lineNum">    1726 </span>            :         return false;
<span class="lineNum">    1727 </span>            :     }
<span class="lineNum">    1728 </span><span class="lineCov">          9 :   start = first_insn != NULL ? first_insn : start_insn;</span>
<span class="lineNum">    1729 </span><span class="lineCov">          9 :   finish = second_insn != NULL ? second_insn : start_insn;</span>
<span class="lineNum">    1730 </span><span class="lineCov">          9 :   return true;</span>
<span class="lineNum">    1731 </span>            : }
<span class="lineNum">    1732 </span>            : 
<span class="lineNum">    1733 </span>            : /* Process reload pseudos which did not get a hard reg, split a hard
<span class="lineNum">    1734 </span>            :    reg live range in live range of a reload pseudo, and then return
<span class="lineNum">    1735 </span>            :    TRUE.  If we did not split a hard reg live range, report an error,
<a name="1736"><span class="lineNum">    1736 </span>            :    and return FALSE.  */</a>
<span class="lineNum">    1737 </span>            : bool
<span class="lineNum">    1738 </span><span class="lineCov">          7 : lra_split_hard_reg_for (void)</span>
<span class="lineNum">    1739 </span>            : {
<span class="lineNum">    1740 </span><span class="lineCov">          7 :   int i, regno;</span>
<span class="lineNum">    1741 </span><span class="lineCov">          7 :   rtx_insn *insn, *first, *last;</span>
<span class="lineNum">    1742 </span><span class="lineCov">          7 :   unsigned int u;</span>
<span class="lineNum">    1743 </span><span class="lineCov">          7 :   bitmap_iterator bi;</span>
<span class="lineNum">    1744 </span><span class="lineCov">          7 :   enum reg_class rclass;</span>
<span class="lineNum">    1745 </span><span class="lineCov">          7 :   int max_regno = max_reg_num ();</span>
<span class="lineNum">    1746 </span>            :   /* We did not assign hard regs to reload pseudos after two
<span class="lineNum">    1747 </span>            :      iterations.  Either it's an asm and something is wrong with the
<span class="lineNum">    1748 </span>            :      constraints, or we have run out of spill registers; error out in
<span class="lineNum">    1749 </span>            :      either case.  */
<span class="lineNum">    1750 </span><span class="lineCov">          7 :   bool asm_p = false;</span>
<span class="lineNum">    1751 </span><span class="lineCov">          7 :   bitmap_head failed_reload_insns, failed_reload_pseudos;</span>
<span class="lineNum">    1752 </span>            :   
<span class="lineNum">    1753 </span><span class="lineCov">          7 :   if (lra_dump_file != NULL)</span>
<span class="lineNum">    1754 </span><span class="lineNoCov">          0 :     fprintf (lra_dump_file,</span>
<span class="lineNum">    1755 </span>            :              &quot;\n****** Splitting a hard reg after assignment #%d: ******\n\n&quot;,
<span class="lineNum">    1756 </span>            :              lra_assignment_iter);
<span class="lineNum">    1757 </span><span class="lineCov">          7 :   bitmap_initialize (&amp;failed_reload_pseudos, &amp;reg_obstack);</span>
<span class="lineNum">    1758 </span><span class="lineCov">        285 :   for (i = lra_constraint_new_regno_start; i &lt; max_regno; i++)</span>
<span class="lineNum">    1759 </span><span class="lineCov">          9 :     if (reg_renumber[i] &lt; 0 &amp;&amp; lra_reg_info[i].nrefs != 0</span>
<span class="lineNum">    1760 </span><span class="lineCov">         18 :         &amp;&amp; (rclass = lra_get_allocno_class (i)) != NO_REGS</span>
<span class="lineNum">    1761 </span><span class="lineCov">        287 :         &amp;&amp; ! bitmap_bit_p (&amp;non_reload_pseudos, i))</span>
<span class="lineNum">    1762 </span>            :       {
<span class="lineNum">    1763 </span><span class="lineCov">          9 :         if (! find_reload_regno_insns (i, first, last))</span>
<span class="lineNum">    1764 </span>            :           continue;
<span class="lineNum">    1765 </span><span class="lineCov">          9 :         if (spill_hard_reg_in_range (i, rclass, first, last))</span>
<span class="lineNum">    1766 </span>            :           {
<span class="lineNum">    1767 </span><span class="lineNoCov">          0 :             bitmap_clear (&amp;failed_reload_pseudos);</span>
<span class="lineNum">    1768 </span><span class="lineNoCov">          0 :             return true;</span>
<span class="lineNum">    1769 </span>            :           }
<span class="lineNum">    1770 </span><span class="lineCov">          9 :         bitmap_set_bit (&amp;failed_reload_pseudos, i);</span>
<span class="lineNum">    1771 </span>            :       }
<span class="lineNum">    1772 </span><span class="lineCov">          7 :   bitmap_initialize (&amp;failed_reload_insns, &amp;reg_obstack);</span>
<span class="lineNum">    1773 </span><span class="lineCov">         16 :   EXECUTE_IF_SET_IN_BITMAP (&amp;failed_reload_pseudos, 0, u, bi)</span>
<span class="lineNum">    1774 </span>            :     {
<span class="lineNum">    1775 </span><span class="lineCov">          9 :       regno = u;</span>
<span class="lineNum">    1776 </span><span class="lineCov">         18 :       bitmap_ior_into (&amp;failed_reload_insns,</span>
<span class="lineNum">    1777 </span><span class="lineCov">          9 :                        &amp;lra_reg_info[regno].insn_bitmap);</span>
<span class="lineNum">    1778 </span><span class="lineCov">          9 :       lra_setup_reg_renumber</span>
<span class="lineNum">    1779 </span><span class="lineCov">         18 :         (regno, ira_class_hard_regs[lra_get_allocno_class (regno)][0], false);</span>
<span class="lineNum">    1780 </span>            :     }
<span class="lineNum">    1781 </span><span class="lineCov">         24 :   EXECUTE_IF_SET_IN_BITMAP (&amp;failed_reload_insns, 0, u, bi)</span>
<span class="lineNum">    1782 </span>            :     {
<span class="lineNum">    1783 </span><span class="lineCov">         17 :       insn = lra_insn_recog_data[u]-&gt;insn;</span>
<span class="lineNum">    1784 </span><span class="lineCov">         34 :       if (asm_noperands (PATTERN (insn)) &gt;= 0)</span>
<span class="lineNum">    1785 </span>            :         {
<span class="lineNum">    1786 </span><span class="lineCov">          7 :           asm_p = true;</span>
<span class="lineNum">    1787 </span><span class="lineCov">          7 :           error_for_asm (insn,</span>
<span class="lineNum">    1788 </span>            :                          &quot;%&lt;asm%&gt; operand has impossible constraints&quot;);
<span class="lineNum">    1789 </span>            :           /* Avoid further trouble with this insn.
<span class="lineNum">    1790 </span>            :              For asm goto, instead of fixing up all the edges
<span class="lineNum">    1791 </span>            :              just clear the template and clear input operands
<span class="lineNum">    1792 </span>            :              (asm goto doesn't have any output operands).  */
<span class="lineNum">    1793 </span><span class="lineCov">          7 :           if (JUMP_P (insn))</span>
<span class="lineNum">    1794 </span>            :             {
<span class="lineNum">    1795 </span><span class="lineCov">         12 :               rtx asm_op = extract_asm_operands (PATTERN (insn));</span>
<span class="lineNum">    1796 </span><span class="lineCov">          6 :               ASM_OPERANDS_TEMPLATE (asm_op) = ggc_strdup (&quot;&quot;);</span>
<span class="lineNum">    1797 </span><span class="lineCov">          6 :               ASM_OPERANDS_INPUT_VEC (asm_op) = rtvec_alloc (0);</span>
<span class="lineNum">    1798 </span><span class="lineCov">          6 :               ASM_OPERANDS_INPUT_CONSTRAINT_VEC (asm_op) = rtvec_alloc (0);</span>
<span class="lineNum">    1799 </span><span class="lineCov">          6 :               lra_update_insn_regno_info (insn);</span>
<span class="lineNum">    1800 </span>            :             }
<span class="lineNum">    1801 </span>            :           else
<span class="lineNum">    1802 </span>            :             {
<span class="lineNum">    1803 </span><span class="lineCov">          2 :               PATTERN (insn) = gen_rtx_USE (VOIDmode, const0_rtx);</span>
<span class="lineNum">    1804 </span><span class="lineCov">          1 :               lra_set_insn_deleted (insn);</span>
<span class="lineNum">    1805 </span>            :             }
<span class="lineNum">    1806 </span>            :         }
<span class="lineNum">    1807 </span><span class="lineCov">         10 :       else if (!asm_p)</span>
<span class="lineNum">    1808 </span>            :         {
<span class="lineNum">    1809 </span><span class="lineNoCov">          0 :           error (&quot;unable to find a register to spill&quot;);</span>
<span class="lineNum">    1810 </span><span class="lineNoCov">          0 :           fatal_insn (&quot;this is the insn:&quot;, insn);</span>
<span class="lineNum">    1811 </span>            :         }
<span class="lineNum">    1812 </span>            :     }
<span class="lineNum">    1813 </span><span class="lineCov">          7 :   bitmap_clear (&amp;failed_reload_pseudos);</span>
<span class="lineNum">    1814 </span><span class="lineCov">          7 :   bitmap_clear (&amp;failed_reload_insns);</span>
<span class="lineNum">    1815 </span><span class="lineCov">          7 :   return false;</span>
<span class="lineNum">    1816 </span>            : }
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.0</a></td></tr>
  </table>
  <br>
<h3>LCOV profile is generated on x86_64 machine using following configure options: configure --disable-bootstrap --enable-coverage=opt --enable-languages=c,c++,fortran,go,jit,lto --enable-host-shared. GCC test suite is run with the built compiler.</h3></body></html>
