<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - gcc.info - gcc/gimple-ssa-evrp-analyze.c</title>
  <link rel="stylesheet" type="text/css" href="../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../index.html">top level</a> - <a href="index.html">gcc</a> - gimple-ssa-evrp-analyze.c<span style="font-size: 80%;"> (source / <a href="gimple-ssa-evrp-analyze.c.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">gcc.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">199</td>
            <td class="headerCovTableEntry">199</td>
            <td class="headerCovTableEntryHi">100.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2018-09-22 10:58:49</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">13</td>
            <td class="headerCovTableEntry">13</td>
            <td class="headerCovTableEntryHi">100.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /* Support routines for Value Range Propagation (VRP).</a>
<span class="lineNum">       2 </span>            :    Copyright (C) 2005-2018 Free Software Foundation, Inc.
<span class="lineNum">       3 </span>            : 
<span class="lineNum">       4 </span>            : This file is part of GCC.
<span class="lineNum">       5 </span>            : 
<span class="lineNum">       6 </span>            : GCC is free software; you can redistribute it and/or modify
<span class="lineNum">       7 </span>            : it under the terms of the GNU General Public License as published by
<span class="lineNum">       8 </span>            : the Free Software Foundation; either version 3, or (at your option)
<span class="lineNum">       9 </span>            : any later version.
<span class="lineNum">      10 </span>            : 
<span class="lineNum">      11 </span>            : GCC is distributed in the hope that it will be useful,
<span class="lineNum">      12 </span>            : but WITHOUT ANY WARRANTY; without even the implied warranty of
<span class="lineNum">      13 </span>            : MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
<span class="lineNum">      14 </span>            : GNU General Public License for more details.
<span class="lineNum">      15 </span>            : 
<span class="lineNum">      16 </span>            : You should have received a copy of the GNU General Public License
<span class="lineNum">      17 </span>            : along with GCC; see the file COPYING3.  If not see
<span class="lineNum">      18 </span>            : &lt;http://www.gnu.org/licenses/&gt;.  */
<span class="lineNum">      19 </span>            : 
<span class="lineNum">      20 </span>            : #include &quot;config.h&quot;
<span class="lineNum">      21 </span>            : #include &quot;system.h&quot;
<span class="lineNum">      22 </span>            : #include &quot;coretypes.h&quot;
<span class="lineNum">      23 </span>            : #include &quot;backend.h&quot;
<span class="lineNum">      24 </span>            : #include &quot;tree.h&quot;
<span class="lineNum">      25 </span>            : #include &quot;gimple.h&quot;
<span class="lineNum">      26 </span>            : #include &quot;tree-pass.h&quot;
<span class="lineNum">      27 </span>            : #include &quot;ssa.h&quot;
<span class="lineNum">      28 </span>            : #include &quot;gimple-pretty-print.h&quot;
<span class="lineNum">      29 </span>            : #include &quot;cfganal.h&quot;
<span class="lineNum">      30 </span>            : #include &quot;gimple-fold.h&quot;
<span class="lineNum">      31 </span>            : #include &quot;tree-eh.h&quot;
<span class="lineNum">      32 </span>            : #include &quot;gimple-iterator.h&quot;
<span class="lineNum">      33 </span>            : #include &quot;tree-cfg.h&quot;
<span class="lineNum">      34 </span>            : #include &quot;tree-ssa-loop-manip.h&quot;
<span class="lineNum">      35 </span>            : #include &quot;tree-ssa-loop.h&quot;
<span class="lineNum">      36 </span>            : #include &quot;cfgloop.h&quot;
<span class="lineNum">      37 </span>            : #include &quot;tree-scalar-evolution.h&quot;
<span class="lineNum">      38 </span>            : #include &quot;tree-ssa-propagate.h&quot;
<span class="lineNum">      39 </span>            : #include &quot;alloc-pool.h&quot;
<span class="lineNum">      40 </span>            : #include &quot;domwalk.h&quot;
<span class="lineNum">      41 </span>            : #include &quot;tree-cfgcleanup.h&quot;
<span class="lineNum">      42 </span>            : #include &quot;vr-values.h&quot;
<span class="lineNum">      43 </span>            : #include &quot;gimple-ssa-evrp-analyze.h&quot;
<span class="lineNum">      44 </span>            : 
<span class="lineNum">      45 </span><span class="lineCov">    3451670 : evrp_range_analyzer::evrp_range_analyzer () : stack (10)</span>
<span class="lineNum">      46 </span>            : {
<span class="lineNum">      47 </span><span class="lineCov">    3451670 :   edge e;</span>
<span class="lineNum">      48 </span><span class="lineCov">    3451670 :   edge_iterator ei;</span>
<span class="lineNum">      49 </span><span class="lineCov">    3451670 :   basic_block bb;</span>
<span class="lineNum">      50 </span><span class="lineCov">   30875097 :   FOR_EACH_BB_FN (bb, cfun)</span>
<span class="lineNum">      51 </span>            :     {
<span class="lineNum">      52 </span><span class="lineCov">   27423427 :       bb-&gt;flags &amp;= ~BB_VISITED;</span>
<span class="lineNum">      53 </span><span class="lineCov">   93713062 :       FOR_EACH_EDGE (e, ei, bb-&gt;preds)</span>
<span class="lineNum">      54 </span><span class="lineCov">   38866208 :         e-&gt;flags |= EDGE_EXECUTABLE;</span>
<span class="lineNum">      55 </span>            :     }
<span class="lineNum">      56 </span><span class="lineCov">    3451670 :   vr_values = new class vr_values;</span>
<span class="lineNum">      57 </span><span class="lineCov">    3451670 : }</span>
<span class="lineNum">      58 </span>            : 
<span class="lineNum">      59 </span>            : /* Push an unwinding marker onto the unwinding stack.  */
<a name="60"><span class="lineNum">      60 </span>            : </a>
<span class="lineNum">      61 </span>            : void
<span class="lineNum">      62 </span><span class="lineCov">   38024290 : evrp_range_analyzer::push_marker ()</span>
<span class="lineNum">      63 </span>            : {
<span class="lineNum">      64 </span><span class="lineCov">   38024290 :   stack.safe_push (std::make_pair (NULL_TREE, (value_range *)NULL));</span>
<span class="lineNum">      65 </span><span class="lineCov">   38024290 : }</span>
<span class="lineNum">      66 </span>            : 
<span class="lineNum">      67 </span>            : /* Analyze ranges as we enter basic block BB.  */
<a name="68"><span class="lineNum">      68 </span>            : </a>
<span class="lineNum">      69 </span>            : void
<span class="lineNum">      70 </span><span class="lineCov">   30841568 : evrp_range_analyzer::enter (basic_block bb)</span>
<span class="lineNum">      71 </span>            : {
<span class="lineNum">      72 </span><span class="lineCov">   30841568 :   if (!optimize)</span>
<span class="lineNum">      73 </span>            :     return;
<span class="lineNum">      74 </span><span class="lineCov">   28805311 :   push_marker ();</span>
<span class="lineNum">      75 </span><span class="lineCov">   28805311 :   record_ranges_from_incoming_edge (bb);</span>
<span class="lineNum">      76 </span><span class="lineCov">   28805311 :   record_ranges_from_phis (bb);</span>
<span class="lineNum">      77 </span><span class="lineCov">   28805311 :   bb-&gt;flags |= BB_VISITED;</span>
<span class="lineNum">      78 </span>            : }
<span class="lineNum">      79 </span>            : 
<a name="80"><span class="lineNum">      80 </span>            : /* Find new range for NAME such that (OP CODE LIMIT) is true.  */</a>
<span class="lineNum">      81 </span>            : value_range *
<span class="lineNum">      82 </span><span class="lineCov">   31943504 : evrp_range_analyzer::try_find_new_range (tree name,</span>
<span class="lineNum">      83 </span>            :                                     tree op, tree_code code, tree limit)
<span class="lineNum">      84 </span>            : {
<span class="lineNum">      85 </span><span class="lineCov">   31943504 :   value_range vr = VR_INITIALIZER;</span>
<span class="lineNum">      86 </span><span class="lineCov">   31943504 :   value_range *old_vr = get_value_range (name);</span>
<span class="lineNum">      87 </span>            : 
<span class="lineNum">      88 </span>            :   /* Discover VR when condition is true.  */
<span class="lineNum">      89 </span><span class="lineCov">   31943504 :   vr_values-&gt;extract_range_for_var_from_comparison_expr (name, code, op,</span>
<span class="lineNum">      90 </span>            :                                                          limit, &amp;vr);
<span class="lineNum">      91 </span>            :   /* If we found any usable VR, set the VR to ssa_name and create a
<span class="lineNum">      92 </span>            :      PUSH old value in the stack with the old VR.  */
<span class="lineNum">      93 </span><span class="lineCov">   31943504 :   if (vr.type == VR_RANGE || vr.type == VR_ANTI_RANGE)</span>
<span class="lineNum">      94 </span>            :     {
<span class="lineNum">      95 </span><span class="lineCov">   31738353 :       if (old_vr-&gt;type == vr.type</span>
<span class="lineNum">      96 </span><span class="lineCov">   17153223 :           &amp;&amp; vrp_operand_equal_p (old_vr-&gt;min, vr.min)</span>
<span class="lineNum">      97 </span><span class="lineCov">   45061365 :           &amp;&amp; vrp_operand_equal_p (old_vr-&gt;max, vr.max))</span>
<span class="lineNum">      98 </span>            :         return NULL;
<span class="lineNum">      99 </span><span class="lineCov">   20322285 :       value_range *new_vr = vr_values-&gt;allocate_value_range ();</span>
<span class="lineNum">     100 </span><span class="lineCov">   20322285 :       *new_vr = vr;</span>
<span class="lineNum">     101 </span><span class="lineCov">   20322285 :       return new_vr;</span>
<span class="lineNum">     102 </span>            :     }
<span class="lineNum">     103 </span>            :   return NULL;
<span class="lineNum">     104 </span>            : }
<span class="lineNum">     105 </span>            : 
<a name="106"><span class="lineNum">     106 </span>            : /* For LHS record VR in the SSA info.  */</a>
<span class="lineNum">     107 </span>            : void
<span class="lineNum">     108 </span><span class="lineCov">   29691895 : evrp_range_analyzer::set_ssa_range_info (tree lhs, value_range *vr)</span>
<span class="lineNum">     109 </span>            : {
<span class="lineNum">     110 </span>            :   /* Set the SSA with the value range.  */
<span class="lineNum">     111 </span><span class="lineCov">   29691895 :   if (INTEGRAL_TYPE_P (TREE_TYPE (lhs)))</span>
<span class="lineNum">     112 </span>            :     {
<span class="lineNum">     113 </span><span class="lineCov">   44416634 :       if ((vr-&gt;type == VR_RANGE</span>
<span class="lineNum">     114 </span><span class="lineCov">   22208317 :            || vr-&gt;type == VR_ANTI_RANGE)</span>
<span class="lineNum">     115 </span><span class="lineCov">   16431757 :           &amp;&amp; (TREE_CODE (vr-&gt;min) == INTEGER_CST)</span>
<span class="lineNum">     116 </span><span class="lineCov">   15819429 :           &amp;&amp; (TREE_CODE (vr-&gt;max) == INTEGER_CST))</span>
<span class="lineNum">     117 </span><span class="lineCov">   15758250 :         set_range_info (lhs, vr-&gt;type,</span>
<span class="lineNum">     118 </span><span class="lineCov">   15758250 :                         wi::to_wide (vr-&gt;min),</span>
<span class="lineNum">     119 </span><span class="lineCov">   31516500 :                         wi::to_wide (vr-&gt;max));</span>
<span class="lineNum">     120 </span>            :     }
<span class="lineNum">     121 </span><span class="lineCov">    7483578 :   else if (POINTER_TYPE_P (TREE_TYPE (lhs))</span>
<span class="lineNum">     122 </span><span class="lineCov">    7746251 :            &amp;&amp; range_includes_zero_p (vr) == 0)</span>
<span class="lineNum">     123 </span><span class="lineCov">    2315011 :     set_ptr_nonnull (lhs);</span>
<span class="lineNum">     124 </span><span class="lineCov">   29691895 : }</span>
<span class="lineNum">     125 </span>            : 
<span class="lineNum">     126 </span>            : /* Return true if all uses of NAME are dominated by STMT or feed STMT
<span class="lineNum">     127 </span>            :    via a chain of single immediate uses.  */
<a name="128"><span class="lineNum">     128 </span>            : </a>
<span class="lineNum">     129 </span>            : static bool
<span class="lineNum">     130 </span><span class="lineCov">       3840 : all_uses_feed_or_dominated_by_stmt (tree name, gimple *stmt)</span>
<span class="lineNum">     131 </span>            : {
<span class="lineNum">     132 </span><span class="lineCov">       3840 :   use_operand_p use_p, use2_p;</span>
<span class="lineNum">     133 </span><span class="lineCov">       3840 :   imm_use_iterator iter;</span>
<span class="lineNum">     134 </span><span class="lineCov">       3840 :   basic_block stmt_bb = gimple_bb (stmt);</span>
<span class="lineNum">     135 </span>            : 
<span class="lineNum">     136 </span><span class="lineCov">       9870 :   FOR_EACH_IMM_USE_FAST (use_p, iter, name)</span>
<span class="lineNum">     137 </span>            :     {
<span class="lineNum">     138 </span><span class="lineCov">       7438 :       gimple *use_stmt = USE_STMT (use_p), *use_stmt2;</span>
<span class="lineNum">     139 </span><span class="lineCov">       7438 :       if (use_stmt == stmt</span>
<span class="lineNum">     140 </span><span class="lineCov">       8378 :           || is_gimple_debug (use_stmt)</span>
<span class="lineNum">     141 </span><span class="lineCov">      14644 :           || (gimple_bb (use_stmt) != stmt_bb</span>
<span class="lineNum">     142 </span><span class="lineCov">       3049 :               &amp;&amp; dominated_by_p (CDI_DOMINATORS,</span>
<span class="lineNum">     143 </span><span class="lineCov">       3049 :                                  gimple_bb (use_stmt), stmt_bb)))</span>
<span class="lineNum">     144 </span><span class="lineCov">       5778 :         continue;</span>
<span class="lineNum">     145 </span><span class="lineCov">       2346 :       while (use_stmt != stmt</span>
<span class="lineNum">     146 </span><span class="lineCov">       3502 :              &amp;&amp; is_gimple_assign (use_stmt)</span>
<span class="lineNum">     147 </span><span class="lineCov">       1212 :              &amp;&amp; TREE_CODE (gimple_assign_lhs (use_stmt)) == SSA_NAME</span>
<span class="lineNum">     148 </span><span class="lineCov">       3155 :              &amp;&amp; single_imm_use (gimple_assign_lhs (use_stmt),</span>
<span class="lineNum">     149 </span>            :                                 &amp;use2_p, &amp;use_stmt2))
<span class="lineNum">     150 </span><span class="lineCov">        343 :         use_stmt = use_stmt2;</span>
<span class="lineNum">     151 </span><span class="lineCov">       1660 :       if (use_stmt != stmt)</span>
<span class="lineNum">     152 </span><span class="lineCov">       1408 :         return false;</span>
<span class="lineNum">     153 </span>            :     }
<span class="lineNum">     154 </span>            :   return true;
<span class="lineNum">     155 </span>            : }
<span class="lineNum">     156 </span>            : 
<span class="lineNum">     157 </span>            : void
<span class="lineNum">     158 </span><span class="lineCov">   28805311 : evrp_range_analyzer::record_ranges_from_incoming_edge (basic_block bb)</span>
<span class="lineNum">     159 </span>            : {
<span class="lineNum">     160 </span><span class="lineCov">   28805311 :   edge pred_e = single_pred_edge_ignoring_loop_edges (bb, false);</span>
<span class="lineNum">     161 </span><span class="lineCov">   28805311 :   if (pred_e)</span>
<span class="lineNum">     162 </span>            :     {
<span class="lineNum">     163 </span><span class="lineCov">   20945887 :       gimple *stmt = last_stmt (pred_e-&gt;src);</span>
<span class="lineNum">     164 </span><span class="lineCov">   20945887 :       tree op0 = NULL_TREE;</span>
<span class="lineNum">     165 </span>            : 
<span class="lineNum">     166 </span><span class="lineCov">   20945887 :       if (stmt</span>
<span class="lineNum">     167 </span><span class="lineCov">   34345504 :           &amp;&amp; gimple_code (stmt) == GIMPLE_COND</span>
<span class="lineNum">     168 </span><span class="lineCov">   24633184 :           &amp;&amp; (op0 = gimple_cond_lhs (stmt))</span>
<span class="lineNum">     169 </span><span class="lineCov">   12316592 :           &amp;&amp; TREE_CODE (op0) == SSA_NAME</span>
<span class="lineNum">     170 </span><span class="lineCov">   44741253 :           &amp;&amp; (INTEGRAL_TYPE_P (TREE_TYPE (gimple_cond_lhs (stmt)))</span>
<span class="lineNum">     171 </span><span class="lineCov">    7662015 :               || POINTER_TYPE_P (TREE_TYPE (gimple_cond_lhs (stmt)))))</span>
<span class="lineNum">     172 </span>            :         {
<span class="lineNum">     173 </span><span class="lineCov">   11278814 :           if (dump_file &amp;&amp; (dump_flags &amp; TDF_DETAILS))</span>
<span class="lineNum">     174 </span>            :             {
<span class="lineNum">     175 </span><span class="lineCov">        349 :               fprintf (dump_file, &quot;Visiting controlling predicate &quot;);</span>
<span class="lineNum">     176 </span><span class="lineCov">        349 :               print_gimple_stmt (dump_file, stmt, 0);</span>
<span class="lineNum">     177 </span>            :             }
<span class="lineNum">     178 </span>            :           /* Entering a new scope.  Try to see if we can find a VR
<span class="lineNum">     179 </span>            :              here.  */
<span class="lineNum">     180 </span><span class="lineCov">   11278814 :           tree op1 = gimple_cond_rhs (stmt);</span>
<span class="lineNum">     181 </span><span class="lineCov">   11278814 :           if (TREE_OVERFLOW_P (op1))</span>
<span class="lineNum">     182 </span><span class="lineCov">       2525 :             op1 = drop_tree_overflow (op1);</span>
<span class="lineNum">     183 </span><span class="lineCov">   11278814 :           tree_code code = gimple_cond_code (stmt);</span>
<span class="lineNum">     184 </span>            : 
<span class="lineNum">     185 </span><span class="lineCov">   22557628 :           auto_vec&lt;assert_info, 8&gt; asserts;</span>
<span class="lineNum">     186 </span><span class="lineCov">   11278814 :           register_edge_assert_for (op0, pred_e, code, op0, op1, asserts);</span>
<span class="lineNum">     187 </span><span class="lineCov">   11278814 :           if (TREE_CODE (op1) == SSA_NAME)</span>
<span class="lineNum">     188 </span><span class="lineCov">    2760913 :             register_edge_assert_for (op1, pred_e, code, op0, op1, asserts);</span>
<span class="lineNum">     189 </span>            : 
<span class="lineNum">     190 </span><span class="lineCov">   33836442 :           auto_vec&lt;std::pair&lt;tree, value_range *&gt;, 8&gt; vrs;</span>
<span class="lineNum">     191 </span><span class="lineCov">   55697472 :           for (unsigned i = 0; i &lt; asserts.length (); ++i)</span>
<span class="lineNum">     192 </span>            :             {
<span class="lineNum">     193 </span><span class="lineCov">   16569922 :               value_range *vr = try_find_new_range (asserts[i].name,</span>
<span class="lineNum">     194 </span><span class="lineCov">   16569922 :                                                     asserts[i].expr,</span>
<span class="lineNum">     195 </span><span class="lineCov">   16569922 :                                                     asserts[i].comp_code,</span>
<span class="lineNum">     196 </span><span class="lineCov">   16569922 :                                                     asserts[i].val);</span>
<span class="lineNum">     197 </span><span class="lineCov">   16569922 :               if (vr)</span>
<span class="lineNum">     198 </span><span class="lineCov">   15566911 :                 vrs.safe_push (std::make_pair (asserts[i].name, vr));</span>
<span class="lineNum">     199 </span>            :             }
<span class="lineNum">     200 </span>            : 
<span class="lineNum">     201 </span>            :           /* If pred_e is really a fallthru we can record value ranges
<span class="lineNum">     202 </span>            :              in SSA names as well.  */
<span class="lineNum">     203 </span><span class="lineCov">   11278814 :           bool is_fallthru = assert_unreachable_fallthru_edge_p (pred_e);</span>
<span class="lineNum">     204 </span>            : 
<span class="lineNum">     205 </span>            :           /* Push updated ranges only after finding all of them to avoid
<span class="lineNum">     206 </span>            :              ordering issues that can lead to worse ranges.  */
<span class="lineNum">     207 </span><span class="lineCov">   53691450 :           for (unsigned i = 0; i &lt; vrs.length (); ++i)</span>
<span class="lineNum">     208 </span>            :             {
<span class="lineNum">     209 </span><span class="lineCov">   15566911 :               push_value_range (vrs[i].first, vrs[i].second);</span>
<span class="lineNum">     210 </span><span class="lineCov">   15566911 :               if (is_fallthru</span>
<span class="lineNum">     211 </span><span class="lineCov">   15566911 :                   &amp;&amp; all_uses_feed_or_dominated_by_stmt (vrs[i].first, stmt))</span>
<span class="lineNum">     212 </span>            :                 {
<span class="lineNum">     213 </span><span class="lineCov">       2432 :                   set_ssa_range_info (vrs[i].first, vrs[i].second);</span>
<span class="lineNum">     214 </span><span class="lineCov">       2432 :                   maybe_set_nonzero_bits (pred_e, vrs[i].first);</span>
<span class="lineNum">     215 </span>            :                 }
<span class="lineNum">     216 </span>            :             }
<span class="lineNum">     217 </span>            :         }
<span class="lineNum">     218 </span>            :     }
<span class="lineNum">     219 </span><span class="lineCov">   28805311 : }</span>
<a name="220"><span class="lineNum">     220 </span>            : </a>
<span class="lineNum">     221 </span>            : void
<span class="lineNum">     222 </span><span class="lineCov">   28805311 : evrp_range_analyzer::record_ranges_from_phis (basic_block bb)</span>
<span class="lineNum">     223 </span>            : {
<span class="lineNum">     224 </span>            :   /* Visit PHI stmts and discover any new VRs possible.  */
<span class="lineNum">     225 </span><span class="lineCov">   28805311 :   bool has_unvisited_preds = false;</span>
<span class="lineNum">     226 </span><span class="lineCov">   28805311 :   edge_iterator ei;</span>
<span class="lineNum">     227 </span><span class="lineCov">   28805311 :   edge e;</span>
<span class="lineNum">     228 </span><span class="lineCov">   92442243 :   FOR_EACH_EDGE (e, ei, bb-&gt;preds)</span>
<span class="lineNum">     229 </span><span class="lineCov">   36144017 :     if (e-&gt;flags &amp; EDGE_EXECUTABLE</span>
<span class="lineNum">     230 </span><span class="lineCov">   36042034 :         &amp;&amp; !(e-&gt;src-&gt;flags &amp; BB_VISITED))</span>
<span class="lineNum">     231 </span>            :       {
<span class="lineNum">     232 </span>            :         has_unvisited_preds = true;
<span class="lineNum">     233 </span>            :         break;
<span class="lineNum">     234 </span>            :       }
<span class="lineNum">     235 </span>            : 
<span class="lineNum">     236 </span><span class="lineCov">   28805311 :   for (gphi_iterator gpi = gsi_start_phis (bb);</span>
<span class="lineNum">     237 </span><span class="lineCov">   67578193 :        !gsi_end_p (gpi); gsi_next (&amp;gpi))</span>
<span class="lineNum">     238 </span>            :     {
<span class="lineNum">     239 </span><span class="lineCov">    9967571 :       gphi *phi = gpi.phi ();</span>
<span class="lineNum">     240 </span><span class="lineCov">   19935142 :       tree lhs = PHI_RESULT (phi);</span>
<span class="lineNum">     241 </span><span class="lineCov">   19935142 :       if (virtual_operand_p (lhs))</span>
<span class="lineNum">     242 </span><span class="lineCov">    4503826 :         continue;</span>
<span class="lineNum">     243 </span>            : 
<span class="lineNum">     244 </span><span class="lineCov">    5463745 :       value_range vr_result = VR_INITIALIZER;</span>
<span class="lineNum">     245 </span><span class="lineCov">    5463745 :       bool interesting = stmt_interesting_for_vrp (phi);</span>
<span class="lineNum">     246 </span><span class="lineCov">    5463745 :       if (!has_unvisited_preds &amp;&amp; interesting)</span>
<span class="lineNum">     247 </span><span class="lineCov">    3161400 :         vr_values-&gt;extract_range_from_phi_node (phi, &amp;vr_result);</span>
<span class="lineNum">     248 </span>            :       else
<span class="lineNum">     249 </span>            :         {
<span class="lineNum">     250 </span><span class="lineCov">    2302345 :           set_value_range_to_varying (&amp;vr_result);</span>
<span class="lineNum">     251 </span>            :           /* When we have an unvisited executable predecessor we can't
<span class="lineNum">     252 </span>            :              use PHI arg ranges which may be still UNDEFINED but have
<span class="lineNum">     253 </span>            :              to use VARYING for them.  But we can still resort to
<span class="lineNum">     254 </span>            :              SCEV for loop header PHIs.  */
<span class="lineNum">     255 </span><span class="lineCov">    2302345 :           struct loop *l;</span>
<span class="lineNum">     256 </span><span class="lineCov">    2302345 :           if (scev_initialized_p ()</span>
<span class="lineNum">     257 </span><span class="lineCov">     516059 :               &amp;&amp; interesting</span>
<span class="lineNum">     258 </span><span class="lineCov">     457974 :               &amp;&amp; (l = loop_containing_stmt (phi))</span>
<span class="lineNum">     259 </span><span class="lineCov">    3218293 :               &amp;&amp; l-&gt;header == gimple_bb (phi))</span>
<span class="lineNum">     260 </span><span class="lineCov">     457090 :           vr_values-&gt;adjust_range_with_scev (&amp;vr_result, l, phi, lhs);</span>
<span class="lineNum">     261 </span>            :         }
<span class="lineNum">     262 </span><span class="lineCov">    5463745 :       vr_values-&gt;update_value_range (lhs, &amp;vr_result);</span>
<span class="lineNum">     263 </span>            : 
<span class="lineNum">     264 </span>            :       /* Set the SSA with the value range.  */
<span class="lineNum">     265 </span><span class="lineCov">    5463745 :       set_ssa_range_info (lhs, &amp;vr_result);</span>
<span class="lineNum">     266 </span>            :     }
<span class="lineNum">     267 </span><span class="lineCov">   28805311 : }</span>
<span class="lineNum">     268 </span>            : 
<span class="lineNum">     269 </span>            : /* Record ranges from STMT into our VR_VALUES class.  If TEMPORARY is
<span class="lineNum">     270 </span>            :    true, then this is a temporary equivalence and should be recorded
<span class="lineNum">     271 </span>            :    into the unwind table.  Othewise record the equivalence into the
<span class="lineNum">     272 </span>            :    global table.  */
<a name="273"><span class="lineNum">     273 </span>            : </a>
<span class="lineNum">     274 </span>            : void
<span class="lineNum">     275 </span><span class="lineCov">  236803664 : evrp_range_analyzer::record_ranges_from_stmt (gimple *stmt, bool temporary)</span>
<span class="lineNum">     276 </span>            : {
<span class="lineNum">     277 </span><span class="lineCov">  236803664 :   tree output = NULL_TREE;</span>
<span class="lineNum">     278 </span>            : 
<span class="lineNum">     279 </span><span class="lineCov">  236803664 :   if (!optimize)</span>
<span class="lineNum">     280 </span><span class="lineCov">    6172283 :     return;</span>
<span class="lineNum">     281 </span>            : 
<span class="lineNum">     282 </span><span class="lineCov">  230631381 :   if (dyn_cast &lt;gcond *&gt; (stmt))</span>
<span class="lineNum">     283 </span>            :     ;
<span class="lineNum">     284 </span><span class="lineCov">  216560283 :   else if (stmt_interesting_for_vrp (stmt))</span>
<span class="lineNum">     285 </span>            :     {
<span class="lineNum">     286 </span><span class="lineCov">   33730431 :       edge taken_edge;</span>
<span class="lineNum">     287 </span><span class="lineCov">   33730431 :       value_range vr = VR_INITIALIZER;</span>
<span class="lineNum">     288 </span><span class="lineCov">   33730431 :       vr_values-&gt;extract_range_from_stmt (stmt, &amp;taken_edge, &amp;output, &amp;vr);</span>
<span class="lineNum">     289 </span><span class="lineCov">   33730431 :       if (output)</span>
<span class="lineNum">     290 </span>            :         {
<span class="lineNum">     291 </span>            :           /* Set the SSA with the value range.  There are two cases to
<span class="lineNum">     292 </span>            :              consider.  First (the the most common) is we are processing
<span class="lineNum">     293 </span>            :              STMT in a context where its resulting range globally holds
<span class="lineNum">     294 </span>            :              and thus it can be reflected into the global ranges and need
<span class="lineNum">     295 </span>            :              not be unwound as we leave scope.
<span class="lineNum">     296 </span>            : 
<span class="lineNum">     297 </span>            :              The second case occurs if we are processing a statement in
<span class="lineNum">     298 </span>            :              a context where the resulting range must not be reflected
<span class="lineNum">     299 </span>            :              into the global tables and must be unwound as we leave
<span class="lineNum">     300 </span>            :              the current context.  This happens in jump threading for
<span class="lineNum">     301 </span>            :              example.  */
<span class="lineNum">     302 </span><span class="lineCov">   33485328 :           if (!temporary)</span>
<span class="lineNum">     303 </span>            :             {
<span class="lineNum">     304 </span>            :               /* Case one.  We can just update the underlying range
<span class="lineNum">     305 </span>            :                  information as well as the global information.  */
<span class="lineNum">     306 </span><span class="lineCov">   24225718 :               vr_values-&gt;update_value_range (output, &amp;vr);</span>
<span class="lineNum">     307 </span><span class="lineCov">   24225718 :               set_ssa_range_info (output, &amp;vr);</span>
<span class="lineNum">     308 </span>            :             }
<span class="lineNum">     309 </span>            :           else
<span class="lineNum">     310 </span>            :             {
<span class="lineNum">     311 </span>            :               /* We're going to need to unwind this range.  We can
<span class="lineNum">     312 </span>            :                  not use VR as that's a stack object.  We have to allocate
<span class="lineNum">     313 </span>            :                  a new range and push the old range onto the stack.  We
<span class="lineNum">     314 </span>            :                  also have to be very careful about sharing the underlying
<span class="lineNum">     315 </span>            :                  bitmaps.  Ugh.  */
<span class="lineNum">     316 </span><span class="lineCov">    9259610 :               value_range *new_vr = vr_values-&gt;allocate_value_range ();</span>
<span class="lineNum">     317 </span><span class="lineCov">    9259610 :               *new_vr = vr;</span>
<span class="lineNum">     318 </span><span class="lineCov">    9259610 :               new_vr-&gt;equiv = NULL;</span>
<span class="lineNum">     319 </span><span class="lineCov">    9259610 :               push_value_range (output, new_vr);</span>
<span class="lineNum">     320 </span>            :             }
<span class="lineNum">     321 </span>            :         }
<span class="lineNum">     322 </span>            :       else
<span class="lineNum">     323 </span><span class="lineCov">     245103 :         vr_values-&gt;set_defs_to_varying (stmt);</span>
<span class="lineNum">     324 </span>            :     }
<span class="lineNum">     325 </span>            :   else
<span class="lineNum">     326 </span><span class="lineCov">  182829852 :     vr_values-&gt;set_defs_to_varying (stmt);</span>
<span class="lineNum">     327 </span>            : 
<span class="lineNum">     328 </span>            :   /* See if we can derive a range for any of STMT's operands.  */
<span class="lineNum">     329 </span><span class="lineCov">  230631381 :   tree op;</span>
<span class="lineNum">     330 </span><span class="lineCov">  230631381 :   ssa_op_iter i;</span>
<span class="lineNum">     331 </span><span class="lineCov">  345662784 :   FOR_EACH_SSA_TREE_OPERAND (op, stmt, i, SSA_OP_USE)</span>
<span class="lineNum">     332 </span>            :     {
<span class="lineNum">     333 </span><span class="lineCov">  115031403 :       tree value;</span>
<span class="lineNum">     334 </span><span class="lineCov">  115031403 :       enum tree_code comp_code;</span>
<span class="lineNum">     335 </span>            : 
<span class="lineNum">     336 </span>            :       /* If OP is used in such a way that we can infer a value
<span class="lineNum">     337 </span>            :          range for it, and we don't find a previous assertion for
<span class="lineNum">     338 </span>            :          it, create a new assertion location node for OP.  */
<span class="lineNum">     339 </span><span class="lineCov">  115031403 :       if (infer_value_range (stmt, op, &amp;comp_code, &amp;value))</span>
<span class="lineNum">     340 </span>            :         {
<span class="lineNum">     341 </span>            :           /* If we are able to infer a nonzero value range for OP,
<span class="lineNum">     342 </span>            :              then walk backwards through the use-def chain to see if OP
<span class="lineNum">     343 </span>            :              was set via a typecast.
<span class="lineNum">     344 </span>            :              If so, then we can also infer a nonzero value range
<span class="lineNum">     345 </span>            :              for the operand of the NOP_EXPR.  */
<span class="lineNum">     346 </span><span class="lineCov">   15373556 :           if (comp_code == NE_EXPR &amp;&amp; integer_zerop (value))</span>
<span class="lineNum">     347 </span>            :             {
<span class="lineNum">     348 </span><span class="lineCov">   15373556 :               tree t = op;</span>
<span class="lineNum">     349 </span><span class="lineCov">   15373556 :               gimple *def_stmt = SSA_NAME_DEF_STMT (t);</span>
<span class="lineNum">     350 </span><span class="lineCov">   15373582 :               while (is_gimple_assign (def_stmt)</span>
<span class="lineNum">     351 </span><span class="lineCov">    5305965 :                      &amp;&amp; CONVERT_EXPR_CODE_P (gimple_assign_rhs_code (def_stmt))</span>
<span class="lineNum">     352 </span><span class="lineCov">    1158564 :                      &amp;&amp; TREE_CODE</span>
<span class="lineNum">     353 </span>            :                           (gimple_assign_rhs1 (def_stmt)) == SSA_NAME
<span class="lineNum">     354 </span><span class="lineCov">   16532146 :                      &amp;&amp; POINTER_TYPE_P</span>
<span class="lineNum">     355 </span>            :                           (TREE_TYPE (gimple_assign_rhs1 (def_stmt))))
<span class="lineNum">     356 </span>            :                 {
<span class="lineNum">     357 </span><span class="lineCov">         26 :                   t = gimple_assign_rhs1 (def_stmt);</span>
<span class="lineNum">     358 </span><span class="lineCov">         26 :                   def_stmt = SSA_NAME_DEF_STMT (t);</span>
<span class="lineNum">     359 </span>            : 
<span class="lineNum">     360 </span>            :                   /* Add VR when (T COMP_CODE value) condition is
<span class="lineNum">     361 </span>            :                      true.  */
<span class="lineNum">     362 </span><span class="lineCov">         26 :                   value_range *op_range</span>
<span class="lineNum">     363 </span><span class="lineCov">         26 :                     = try_find_new_range (t, t, comp_code, value);</span>
<span class="lineNum">     364 </span><span class="lineCov">         26 :                   if (op_range)</span>
<span class="lineNum">     365 </span><span class="lineCov">         26 :                     push_value_range (t, op_range);</span>
<span class="lineNum">     366 </span>            :                 }
<span class="lineNum">     367 </span>            :             }
<span class="lineNum">     368 </span>            :           /* Add VR when (OP COMP_CODE value) condition is true.  */
<span class="lineNum">     369 </span><span class="lineCov">   15373556 :           value_range *op_range = try_find_new_range (op, op,</span>
<span class="lineNum">     370 </span>            :                                                       comp_code, value);
<span class="lineNum">     371 </span><span class="lineCov">   15373556 :           if (op_range)</span>
<span class="lineNum">     372 </span><span class="lineCov">    4755348 :             push_value_range (op, op_range);</span>
<span class="lineNum">     373 </span>            :         }
<span class="lineNum">     374 </span>            :     }
<span class="lineNum">     375 </span>            : }
<span class="lineNum">     376 </span>            : 
<span class="lineNum">     377 </span>            : /* Unwind recorded ranges to their most recent state.  */
<span class="lineNum">     378 </span>            : 
<span class="lineNum">     379 </span>            : void
<span class="lineNum">     380 </span><span class="lineCov">   38024290 : evrp_range_analyzer::pop_to_marker (void)</span>
<span class="lineNum">     381 </span>            : {
<span class="lineNum">     382 </span><span class="lineCov">   38024290 :   gcc_checking_assert (!stack.is_empty ());</span>
<span class="lineNum">     383 </span><span class="lineCov">   76626417 :   while (stack.last ().first != NULL_TREE)</span>
<span class="lineNum">     384 </span><span class="lineCov">   77204254 :     pop_value_range (stack.last ().first);</span>
<span class="lineNum">     385 </span><span class="lineCov">   38024290 :   stack.pop ();</span>
<span class="lineNum">     386 </span><span class="lineCov">   38024290 : }</span>
<span class="lineNum">     387 </span>            : 
<span class="lineNum">     388 </span>            : /* Restore/pop VRs valid only for BB when we leave BB.  */
<a name="389"><span class="lineNum">     389 </span>            : </a>
<span class="lineNum">     390 </span>            : void
<span class="lineNum">     391 </span><span class="lineCov">   30841568 : evrp_range_analyzer::leave (basic_block bb ATTRIBUTE_UNUSED)</span>
<span class="lineNum">     392 </span>            : {
<span class="lineNum">     393 </span><span class="lineCov">   30841568 :   if (!optimize)</span>
<span class="lineNum">     394 </span>            :     return;
<span class="lineNum">     395 </span><span class="lineCov">   28805311 :   pop_to_marker ();</span>
<span class="lineNum">     396 </span>            : }
<span class="lineNum">     397 </span>            : 
<span class="lineNum">     398 </span>            : 
<span class="lineNum">     399 </span>            : /* Push the Value Range of VAR to the stack and update it with new VR.  */
<a name="400"><span class="lineNum">     400 </span>            : </a>
<span class="lineNum">     401 </span>            : void
<span class="lineNum">     402 </span><span class="lineCov">   38602127 : evrp_range_analyzer::push_value_range (tree var, value_range *vr)</span>
<span class="lineNum">     403 </span>            : {
<span class="lineNum">     404 </span><span class="lineCov">   38602127 :   if (dump_file &amp;&amp; (dump_flags &amp; TDF_DETAILS))</span>
<span class="lineNum">     405 </span>            :     {
<span class="lineNum">     406 </span><span class="lineCov">       1541 :       fprintf (dump_file, &quot;pushing new range for &quot;);</span>
<span class="lineNum">     407 </span><span class="lineCov">       1541 :       print_generic_expr (dump_file, var);</span>
<span class="lineNum">     408 </span><span class="lineCov">       1541 :       fprintf (dump_file, &quot;: &quot;);</span>
<span class="lineNum">     409 </span><span class="lineCov">       1541 :       dump_value_range (dump_file, vr);</span>
<span class="lineNum">     410 </span><span class="lineCov">       1541 :       fprintf (dump_file, &quot;\n&quot;);</span>
<span class="lineNum">     411 </span>            :     }
<span class="lineNum">     412 </span><span class="lineCov">   38602127 :   stack.safe_push (std::make_pair (var, get_value_range (var)));</span>
<span class="lineNum">     413 </span><span class="lineCov">   38602127 :   vr_values-&gt;set_vr_value (var, vr);</span>
<span class="lineNum">     414 </span><span class="lineCov">   38602127 : }</span>
<span class="lineNum">     415 </span>            : 
<span class="lineNum">     416 </span>            : /* Pop the Value Range from the vrp_stack and update VAR with it.  */
<span class="lineNum">     417 </span>            : 
<span class="lineNum">     418 </span>            : value_range *
<span class="lineNum">     419 </span><span class="lineCov">   38602127 : evrp_range_analyzer::pop_value_range (tree var)</span>
<span class="lineNum">     420 </span>            : {
<span class="lineNum">     421 </span><span class="lineCov">   38602127 :   value_range *vr = stack.last ().second;</span>
<span class="lineNum">     422 </span><span class="lineCov">   77204254 :   gcc_checking_assert (var == stack.last ().first);</span>
<span class="lineNum">     423 </span><span class="lineCov">   38602127 :   if (dump_file &amp;&amp; (dump_flags &amp; TDF_DETAILS))</span>
<span class="lineNum">     424 </span>            :     {
<span class="lineNum">     425 </span><span class="lineCov">       1541 :       fprintf (dump_file, &quot;popping range for &quot;);</span>
<span class="lineNum">     426 </span><span class="lineCov">       1541 :       print_generic_expr (dump_file, var);</span>
<span class="lineNum">     427 </span><span class="lineCov">       1541 :       fprintf (dump_file, &quot;, restoring &quot;);</span>
<span class="lineNum">     428 </span><span class="lineCov">       1541 :       dump_value_range (dump_file, vr);</span>
<span class="lineNum">     429 </span><span class="lineCov">       1541 :       fprintf (dump_file, &quot;\n&quot;);</span>
<span class="lineNum">     430 </span>            :     }
<span class="lineNum">     431 </span><span class="lineCov">   38602127 :   vr_values-&gt;set_vr_value (var, vr);</span>
<span class="lineNum">     432 </span><span class="lineCov">   38602127 :   stack.pop ();</span>
<span class="lineNum">     433 </span><span class="lineCov">   38602127 :   return vr;</span>
<span class="lineNum">     434 </span>            : }
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.0</a></td></tr>
  </table>
  <br>
<h3>LCOV profile is generated on x86_64 machine using following configure options: configure --disable-bootstrap --enable-coverage=opt --enable-languages=c,c++,fortran,go,jit,lto --enable-host-shared. GCC test suite is run with the built compiler.</h3></body></html>
