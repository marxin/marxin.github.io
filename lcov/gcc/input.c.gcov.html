<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - gcc.info - gcc/input.c</title>
  <link rel="stylesheet" type="text/css" href="../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../index.html">top level</a> - <a href="index.html">gcc</a> - input.c<span style="font-size: 80%;"> (source / <a href="input.c.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">gcc.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">1197</td>
            <td class="headerCovTableEntry">1372</td>
            <td class="headerCovTableEntryMed">87.2 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2018-09-22 10:58:49</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">85</td>
            <td class="headerCovTableEntry">101</td>
            <td class="headerCovTableEntryMed">84.2 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /* Data and functions related to line maps and input files.</a>
<span class="lineNum">       2 </span>            :    Copyright (C) 2004-2018 Free Software Foundation, Inc.
<span class="lineNum">       3 </span>            : 
<span class="lineNum">       4 </span>            : This file is part of GCC.
<span class="lineNum">       5 </span>            : 
<span class="lineNum">       6 </span>            : GCC is free software; you can redistribute it and/or modify it under
<span class="lineNum">       7 </span>            : the terms of the GNU General Public License as published by the Free
<span class="lineNum">       8 </span>            : Software Foundation; either version 3, or (at your option) any later
<span class="lineNum">       9 </span>            : version.
<span class="lineNum">      10 </span>            : 
<span class="lineNum">      11 </span>            : GCC is distributed in the hope that it will be useful, but WITHOUT ANY
<span class="lineNum">      12 </span>            : WARRANTY; without even the implied warranty of MERCHANTABILITY or
<span class="lineNum">      13 </span>            : FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
<span class="lineNum">      14 </span>            : for more details.
<span class="lineNum">      15 </span>            : 
<span class="lineNum">      16 </span>            : You should have received a copy of the GNU General Public License
<span class="lineNum">      17 </span>            : along with GCC; see the file COPYING3.  If not see
<span class="lineNum">      18 </span>            : &lt;http://www.gnu.org/licenses/&gt;.  */
<span class="lineNum">      19 </span>            : 
<span class="lineNum">      20 </span>            : #include &quot;config.h&quot;
<span class="lineNum">      21 </span>            : #include &quot;system.h&quot;
<span class="lineNum">      22 </span>            : #include &quot;coretypes.h&quot;
<span class="lineNum">      23 </span>            : #include &quot;intl.h&quot;
<span class="lineNum">      24 </span>            : #include &quot;diagnostic-core.h&quot;
<span class="lineNum">      25 </span>            : #include &quot;selftest.h&quot;
<span class="lineNum">      26 </span>            : #include &quot;cpplib.h&quot;
<span class="lineNum">      27 </span>            : 
<span class="lineNum">      28 </span>            : #ifndef HAVE_ICONV
<span class="lineNum">      29 </span>            : #define HAVE_ICONV 0
<span class="lineNum">      30 </span>            : #endif
<span class="lineNum">      31 </span>            : 
<span class="lineNum">      32 </span>            : /* This is a cache used by get_next_line to store the content of a
<span class="lineNum">      33 </span>            :    file to be searched for file lines.  */
<span class="lineNum">      34 </span>            : struct fcache
<span class="lineNum">      35 </span>            : {
<span class="lineNum">      36 </span>            :   /* These are information used to store a line boundary.  */
<span class="lineNum">      37 </span>            :   struct line_info
<span class="lineNum">      38 </span>            :   {
<span class="lineNum">      39 </span>            :     /* The line number.  It starts from 1.  */
<span class="lineNum">      40 </span>            :     size_t line_num;
<span class="lineNum">      41 </span>            : 
<span class="lineNum">      42 </span>            :     /* The position (byte count) of the beginning of the line,
<span class="lineNum">      43 </span>            :        relative to the file data pointer.  This starts at zero.  */
<span class="lineNum">      44 </span>            :     size_t start_pos;
<span class="lineNum">      45 </span>            : 
<span class="lineNum">      46 </span>            :     /* The position (byte count) of the last byte of the line.  This
<span class="lineNum">      47 </span>            :        normally points to the '\n' character, or to one byte after the
<span class="lineNum">      48 </span>            :        last byte of the file, if the file doesn't contain a '\n'
<span class="lineNum">      49 </span>            :        character.  */
<span class="lineNum">      50 </span>            :     size_t end_pos;
<span class="lineNum">      51 </span>            : 
<span class="lineNum">      52 </span>            :     line_info (size_t l, size_t s, size_t e)
<span class="lineNum">      53 </span><span class="lineCov">    1347636 :       : line_num (l), start_pos (s), end_pos (e)</span>
<span class="lineNum">      54 </span>            :     {}
<span class="lineNum">      55 </span>            : 
<span class="lineNum">      56 </span>            :     line_info ()
<span class="lineNum">      57 </span>            :       :line_num (0), start_pos (0), end_pos (0)
<span class="lineNum">      58 </span>            :     {}
<span class="lineNum">      59 </span>            :   };
<span class="lineNum">      60 </span>            : 
<span class="lineNum">      61 </span>            :   /* The number of time this file has been accessed.  This is used
<span class="lineNum">      62 </span>            :      to designate which file cache to evict from the cache
<span class="lineNum">      63 </span>            :      array.  */
<span class="lineNum">      64 </span>            :   unsigned use_count;
<span class="lineNum">      65 </span>            : 
<span class="lineNum">      66 </span>            :   /* The file_path is the key for identifying a particular file in
<span class="lineNum">      67 </span>            :      the cache.
<span class="lineNum">      68 </span>            :      For libcpp-using code, the underlying buffer for this field is
<span class="lineNum">      69 </span>            :      owned by the corresponding _cpp_file within the cpp_reader.  */
<span class="lineNum">      70 </span>            :   const char *file_path;
<span class="lineNum">      71 </span>            : 
<span class="lineNum">      72 </span>            :   FILE *fp;
<span class="lineNum">      73 </span>            : 
<span class="lineNum">      74 </span>            :   /* This points to the content of the file that we've read so
<span class="lineNum">      75 </span>            :      far.  */
<span class="lineNum">      76 </span>            :   char *data;
<span class="lineNum">      77 </span>            : 
<span class="lineNum">      78 </span>            :   /*  The size of the DATA array above.*/
<span class="lineNum">      79 </span>            :   size_t size;
<span class="lineNum">      80 </span>            : 
<span class="lineNum">      81 </span>            :   /* The number of bytes read from the underlying file so far.  This
<span class="lineNum">      82 </span>            :      must be less (or equal) than SIZE above.  */
<span class="lineNum">      83 </span>            :   size_t nb_read;
<span class="lineNum">      84 </span>            : 
<span class="lineNum">      85 </span>            :   /* The index of the beginning of the current line.  */
<span class="lineNum">      86 </span>            :   size_t line_start_idx;
<span class="lineNum">      87 </span>            : 
<span class="lineNum">      88 </span>            :   /* The number of the previous line read.  This starts at 1.  Zero
<span class="lineNum">      89 </span>            :      means we've read no line so far.  */
<span class="lineNum">      90 </span>            :   size_t line_num;
<span class="lineNum">      91 </span>            : 
<span class="lineNum">      92 </span>            :   /* This is the total number of lines of the current file.  At the
<span class="lineNum">      93 </span>            :      moment, we try to get this information from the line map
<span class="lineNum">      94 </span>            :      subsystem.  Note that this is just a hint.  When using the C++
<span class="lineNum">      95 </span>            :      front-end, this hint is correct because the input file is then
<span class="lineNum">      96 </span>            :      completely tokenized before parsing starts; so the line map knows
<span class="lineNum">      97 </span>            :      the number of lines before compilation really starts.  For e.g,
<span class="lineNum">      98 </span>            :      the C front-end, it can happen that we start emitting diagnostics
<span class="lineNum">      99 </span>            :      before the line map has seen the end of the file.  */
<span class="lineNum">     100 </span>            :   size_t total_lines;
<span class="lineNum">     101 </span>            : 
<span class="lineNum">     102 </span>            :   /* Could this file be missing a trailing newline on its final line?
<span class="lineNum">     103 </span>            :      Initially true (to cope with empty files), set to true/false
<span class="lineNum">     104 </span>            :      as each line is read.  */
<span class="lineNum">     105 </span>            :   bool missing_trailing_newline;
<span class="lineNum">     106 </span>            : 
<span class="lineNum">     107 </span>            :   /* This is a record of the beginning and end of the lines we've seen
<span class="lineNum">     108 </span>            :      while reading the file.  This is useful to avoid walking the data
<span class="lineNum">     109 </span>            :      from the beginning when we are asked to read a line that is
<span class="lineNum">     110 </span>            :      before LINE_START_IDX above.  Note that the maximum size of this
<span class="lineNum">     111 </span>            :      record is fcache_line_record_size, so that the memory consumption
<span class="lineNum">     112 </span>            :      doesn't explode.  We thus scale total_lines down to
<span class="lineNum">     113 </span>            :      fcache_line_record_size.  */
<span class="lineNum">     114 </span>            :   vec&lt;line_info, va_heap&gt; line_record;
<span class="lineNum">     115 </span>            : 
<span class="lineNum">     116 </span>            :   fcache ();
<span class="lineNum">     117 </span>            :   ~fcache ();
<span class="lineNum">     118 </span>            : };
<span class="lineNum">     119 </span>            : 
<span class="lineNum">     120 </span>            : /* Current position in real source file.  */
<span class="lineNum">     121 </span>            : 
<span class="lineNum">     122 </span>            : location_t input_location = UNKNOWN_LOCATION;
<span class="lineNum">     123 </span>            : 
<span class="lineNum">     124 </span>            : struct line_maps *line_table;
<span class="lineNum">     125 </span>            : 
<span class="lineNum">     126 </span>            : /* A stashed copy of &quot;line_table&quot; for use by selftest::line_table_test.
<span class="lineNum">     127 </span>            :    This needs to be a global so that it can be a GC root, and thus
<span class="lineNum">     128 </span>            :    prevent the stashed copy from being garbage-collected if the GC runs
<span class="lineNum">     129 </span>            :    during a line_table_test.  */
<span class="lineNum">     130 </span>            : 
<span class="lineNum">     131 </span>            : struct line_maps *saved_line_table;
<span class="lineNum">     132 </span>            : 
<span class="lineNum">     133 </span>            : static fcache *fcache_tab;
<span class="lineNum">     134 </span>            : static const size_t fcache_tab_size = 16;
<span class="lineNum">     135 </span>            : static const size_t fcache_buffer_size = 4 * 1024;
<span class="lineNum">     136 </span>            : static const size_t fcache_line_record_size = 100;
<span class="lineNum">     137 </span>            : 
<span class="lineNum">     138 </span>            : /* Expand the source location LOC into a human readable location.  If
<span class="lineNum">     139 </span>            :    LOC resolves to a builtin location, the file name of the readable
<span class="lineNum">     140 </span>            :    location is set to the string &quot;&lt;built-in&gt;&quot;. If EXPANSION_POINT_P is
<span class="lineNum">     141 </span>            :    TRUE and LOC is virtual, then it is resolved to the expansion
<span class="lineNum">     142 </span>            :    point of the involved macro.  Otherwise, it is resolved to the
<span class="lineNum">     143 </span>            :    spelling location of the token.
<span class="lineNum">     144 </span>            : 
<span class="lineNum">     145 </span>            :    When resolving to the spelling location of the token, if the
<span class="lineNum">     146 </span>            :    resulting location is for a built-in location (that is, it has no
<span class="lineNum">     147 </span>            :    associated line/column) in the context of a macro expansion, the
<span class="lineNum">     148 </span>            :    returned location is the first one (while unwinding the macro
<span class="lineNum">     149 </span>            :    location towards its expansion point) that is in real source
<span class="lineNum">     150 </span>            :    code.
<span class="lineNum">     151 </span>            : 
<span class="lineNum">     152 </span>            :    ASPECT controls which part of the location to use.  */
<a name="153"><span class="lineNum">     153 </span>            : </a>
<span class="lineNum">     154 </span>            : static expanded_location
<span class="lineNum">     155 </span><span class="lineCov">  202889010 : expand_location_1 (source_location loc,</span>
<span class="lineNum">     156 </span>            :                    bool expansion_point_p,
<span class="lineNum">     157 </span>            :                    enum location_aspect aspect)
<span class="lineNum">     158 </span>            : {
<span class="lineNum">     159 </span><span class="lineCov">  202889010 :   expanded_location xloc;</span>
<span class="lineNum">     160 </span><span class="lineCov">  202889010 :   const line_map_ordinary *map;</span>
<span class="lineNum">     161 </span><span class="lineCov">  202889010 :   enum location_resolution_kind lrk = LRK_MACRO_EXPANSION_POINT;</span>
<span class="lineNum">     162 </span><span class="lineCov">  202889010 :   tree block = NULL;</span>
<span class="lineNum">     163 </span>            : 
<span class="lineNum">     164 </span><span class="lineCov">  405778020 :   if (IS_ADHOC_LOC (loc))</span>
<span class="lineNum">     165 </span>            :     {
<span class="lineNum">     166 </span><span class="lineCov">  153663664 :       block = LOCATION_BLOCK (loc);</span>
<span class="lineNum">     167 </span><span class="lineCov">  153663664 :       loc = LOCATION_LOCUS (loc);</span>
<span class="lineNum">     168 </span>            :     }
<span class="lineNum">     169 </span>            : 
<span class="lineNum">     170 </span><span class="lineCov">  202889010 :   memset (&amp;xloc, 0, sizeof (xloc));</span>
<span class="lineNum">     171 </span>            : 
<span class="lineNum">     172 </span><span class="lineCov">  202889010 :   if (loc &gt;= RESERVED_LOCATION_COUNT)</span>
<span class="lineNum">     173 </span>            :     {
<span class="lineNum">     174 </span><span class="lineCov">  195686672 :       if (!expansion_point_p)</span>
<span class="lineNum">     175 </span>            :         {
<span class="lineNum">     176 </span>            :           /* We want to resolve LOC to its spelling location.
<span class="lineNum">     177 </span>            : 
<span class="lineNum">     178 </span>            :              But if that spelling location is a reserved location that
<span class="lineNum">     179 </span>            :              appears in the context of a macro expansion (like for a
<span class="lineNum">     180 </span>            :              location for a built-in token), let's consider the first
<span class="lineNum">     181 </span>            :              location (toward the expansion point) that is not reserved;
<span class="lineNum">     182 </span>            :              that is, the first location that is in real source code.  */
<span class="lineNum">     183 </span><span class="lineCov">    1361144 :           loc = linemap_unwind_to_first_non_reserved_loc (line_table,</span>
<span class="lineNum">     184 </span>            :                                                           loc, NULL);
<span class="lineNum">     185 </span><span class="lineCov">    1361144 :           lrk = LRK_SPELLING_LOCATION;</span>
<span class="lineNum">     186 </span>            :         }
<span class="lineNum">     187 </span><span class="lineCov">  195686672 :       loc = linemap_resolve_location (line_table, loc, lrk, &amp;map);</span>
<span class="lineNum">     188 </span>            : 
<span class="lineNum">     189 </span>            :       /* loc is now either in an ordinary map, or is a reserved location.
<span class="lineNum">     190 </span>            :          If it is a compound location, the caret is in a spelling location,
<span class="lineNum">     191 </span>            :          but the start/finish might still be a virtual location.
<span class="lineNum">     192 </span>            :          Depending of what the caller asked for, we may need to recurse
<span class="lineNum">     193 </span>            :          one level in order to resolve any virtual locations in the
<span class="lineNum">     194 </span>            :          end-points.  */
<span class="lineNum">     195 </span><span class="lineCov">  195686672 :       switch (aspect)</span>
<span class="lineNum">     196 </span>            :         {
<span class="lineNum">     197 </span><span class="lineNoCov">          0 :         default:</span>
<span class="lineNum">     198 </span><span class="lineNoCov">          0 :           gcc_unreachable ();</span>
<span class="lineNum">     199 </span>            :           /* Fall through.  */
<span class="lineNum">     200 </span>            :         case LOCATION_ASPECT_CARET:
<span class="lineNum">     201 </span>            :           break;
<span class="lineNum">     202 </span><span class="lineCov">     187891 :         case LOCATION_ASPECT_START:</span>
<span class="lineNum">     203 </span><span class="lineCov">     187891 :           {</span>
<span class="lineNum">     204 </span><span class="lineCov">     187891 :             source_location start = get_start (loc);</span>
<span class="lineNum">     205 </span><span class="lineCov">     187891 :             if (start != loc)</span>
<span class="lineNum">     206 </span><span class="lineCov">     187891 :               return expand_location_1 (start, expansion_point_p, aspect);</span>
<span class="lineNum">     207 </span>            :           }
<span class="lineNum">     208 </span>            :           break;
<span class="lineNum">     209 </span><span class="lineCov">      92145 :         case LOCATION_ASPECT_FINISH:</span>
<span class="lineNum">     210 </span><span class="lineCov">      92145 :           {</span>
<span class="lineNum">     211 </span><span class="lineCov">      92145 :             source_location finish = get_finish (loc);</span>
<span class="lineNum">     212 </span><span class="lineCov">      92145 :             if (finish != loc)</span>
<span class="lineNum">     213 </span><span class="lineCov">      92145 :               return expand_location_1 (finish, expansion_point_p, aspect);</span>
<span class="lineNum">     214 </span>            :           }
<span class="lineNum">     215 </span>            :           break;
<span class="lineNum">     216 </span>            :         }
<span class="lineNum">     217 </span><span class="lineCov">  195686553 :       xloc = linemap_expand_location (line_table, map, loc);</span>
<span class="lineNum">     218 </span>            :     }
<span class="lineNum">     219 </span>            : 
<span class="lineNum">     220 </span><span class="lineCov">  202888891 :   xloc.data = block;</span>
<span class="lineNum">     221 </span><span class="lineCov">  202888891 :   if (loc &lt;= BUILTINS_LOCATION)</span>
<span class="lineNum">     222 </span><span class="lineCov">    7202338 :     xloc.file = loc == UNKNOWN_LOCATION ? NULL : _(&quot;&lt;built-in&gt;&quot;);</span>
<span class="lineNum">     223 </span>            : 
<span class="lineNum">     224 </span><span class="lineCov">  202888891 :   return xloc;</span>
<span class="lineNum">     225 </span>            : }
<span class="lineNum">     226 </span>            : 
<span class="lineNum">     227 </span>            : /* Initialize the set of cache used for files accessed by caret
<span class="lineNum">     228 </span>            :    diagnostic.  */
<a name="229"><span class="lineNum">     229 </span>            : </a>
<span class="lineNum">     230 </span>            : static void
<span class="lineNum">     231 </span><span class="lineCov">     769034 : diagnostic_file_cache_init (void)</span>
<span class="lineNum">     232 </span>            : {
<span class="lineNum">     233 </span><span class="lineCov">     769034 :   if (fcache_tab == NULL)</span>
<span class="lineNum">     234 </span><span class="lineCov">    1340552 :     fcache_tab = new fcache[fcache_tab_size];</span>
<span class="lineNum">     235 </span><span class="lineCov">     769034 : }</span>
<span class="lineNum">     236 </span>            : 
<span class="lineNum">     237 </span>            : /* Free the resources used by the set of cache used for files accessed
<span class="lineNum">     238 </span>            :    by caret diagnostic.  */
<a name="239"><span class="lineNum">     239 </span>            : </a>
<span class="lineNum">     240 </span>            : void
<span class="lineNum">     241 </span><span class="lineCov">     243911 : diagnostic_file_cache_fini (void)</span>
<span class="lineNum">     242 </span>            : {
<span class="lineNum">     243 </span><span class="lineCov">     243911 :   if (fcache_tab)</span>
<span class="lineNum">     244 </span>            :     {
<span class="lineNum">     245 </span><span class="lineCov">    1419408 :       delete [] (fcache_tab);</span>
<span class="lineNum">     246 </span><span class="lineCov">      78856 :       fcache_tab = NULL;</span>
<span class="lineNum">     247 </span>            :     }
<span class="lineNum">     248 </span><span class="lineCov">     243911 : }</span>
<span class="lineNum">     249 </span>            : 
<span class="lineNum">     250 </span>            : /* Return the total lines number that have been read so far by the
<span class="lineNum">     251 </span>            :    line map (in the preprocessor) so far.  For languages like C++ that
<span class="lineNum">     252 </span>            :    entirely preprocess the input file before starting to parse, this
<span class="lineNum">     253 </span>            :    equals the actual number of lines of the file.  */
<a name="254"><span class="lineNum">     254 </span>            : </a>
<span class="lineNum">     255 </span>            : static size_t
<span class="lineNum">     256 </span><span class="lineCov">      91529 : total_lines_num (const char *file_path)</span>
<span class="lineNum">     257 </span>            : {
<span class="lineNum">     258 </span><span class="lineCov">      91529 :   size_t r = 0;</span>
<span class="lineNum">     259 </span><span class="lineCov">      91529 :   source_location l = 0;</span>
<span class="lineNum">     260 </span><span class="lineCov">      91529 :   if (linemap_get_file_highest_location (line_table, file_path, &amp;l))</span>
<span class="lineNum">     261 </span>            :     {
<span class="lineNum">     262 </span><span class="lineCov">      91524 :       gcc_assert (l &gt;= RESERVED_LOCATION_COUNT);</span>
<span class="lineNum">     263 </span><span class="lineCov">      91524 :       expanded_location xloc = expand_location (l);</span>
<span class="lineNum">     264 </span><span class="lineCov">      91524 :       r = xloc.line;</span>
<span class="lineNum">     265 </span>            :     }
<span class="lineNum">     266 </span><span class="lineCov">      91529 :   return r;</span>
<span class="lineNum">     267 </span>            : }
<span class="lineNum">     268 </span>            : 
<span class="lineNum">     269 </span>            : /* Lookup the cache used for the content of a given file accessed by
<span class="lineNum">     270 </span>            :    caret diagnostic.  Return the found cached file, or NULL if no
<span class="lineNum">     271 </span>            :    cached file was found.  */
<a name="272"><span class="lineNum">     272 </span>            : </a>
<span class="lineNum">     273 </span>            : static fcache*
<span class="lineNum">     274 </span><span class="lineCov">     677505 : lookup_file_in_cache_tab (const char *file_path)</span>
<span class="lineNum">     275 </span>            : {
<span class="lineNum">     276 </span><span class="lineCov">     677505 :   if (file_path == NULL)</span>
<span class="lineNum">     277 </span>            :     return NULL;
<span class="lineNum">     278 </span>            : 
<span class="lineNum">     279 </span><span class="lineCov">     677505 :   diagnostic_file_cache_init ();</span>
<span class="lineNum">     280 </span>            : 
<span class="lineNum">     281 </span>            :   /* This will contain the found cached file.  */
<span class="lineNum">     282 </span><span class="lineCov">     677505 :   fcache *r = NULL;</span>
<span class="lineNum">     283 </span><span class="lineCov">   11517585 :   for (unsigned i = 0; i &lt; fcache_tab_size; ++i)</span>
<span class="lineNum">     284 </span>            :     {
<span class="lineNum">     285 </span><span class="lineCov">   10840080 :       fcache *c = &amp;fcache_tab[i];</span>
<span class="lineNum">     286 </span><span class="lineCov">   10840080 :       if (c-&gt;file_path &amp;&amp; !strcmp (c-&gt;file_path, file_path))</span>
<span class="lineNum">     287 </span>            :         {
<span class="lineNum">     288 </span><span class="lineCov">     581549 :           ++c-&gt;use_count;</span>
<span class="lineNum">     289 </span><span class="lineCov">     581549 :           r = c;</span>
<span class="lineNum">     290 </span>            :         }
<span class="lineNum">     291 </span>            :     }
<span class="lineNum">     292 </span>            : 
<span class="lineNum">     293 </span><span class="lineCov">     677505 :   if (r)</span>
<span class="lineNum">     294 </span><span class="lineCov">     581549 :     ++r-&gt;use_count;</span>
<span class="lineNum">     295 </span>            : 
<span class="lineNum">     296 </span>            :   return r;
<span class="lineNum">     297 </span>            : }
<span class="lineNum">     298 </span>            : 
<span class="lineNum">     299 </span>            : /* Purge any mention of FILENAME from the cache of files used for
<span class="lineNum">     300 </span>            :    printing source code.  For use in selftests when working
<span class="lineNum">     301 </span>            :    with tempfiles.  */
<a name="302"><span class="lineNum">     302 </span>            : </a>
<span class="lineNum">     303 </span>            : void
<span class="lineNum">     304 </span><span class="lineCov">       1426 : diagnostics_file_cache_forcibly_evict_file (const char *file_path)</span>
<span class="lineNum">     305 </span>            : {
<span class="lineNum">     306 </span><span class="lineCov">       1426 :   gcc_assert (file_path);</span>
<span class="lineNum">     307 </span>            : 
<span class="lineNum">     308 </span><span class="lineCov">       1426 :   fcache *r = lookup_file_in_cache_tab (file_path);</span>
<span class="lineNum">     309 </span><span class="lineCov">       1426 :   if (!r)</span>
<span class="lineNum">     310 </span>            :     /* Not found.  */
<span class="lineNum">     311 </span>            :     return;
<span class="lineNum">     312 </span>            : 
<span class="lineNum">     313 </span><span class="lineCov">        528 :   r-&gt;file_path = NULL;</span>
<span class="lineNum">     314 </span><span class="lineCov">        528 :   if (r-&gt;fp)</span>
<span class="lineNum">     315 </span><span class="lineCov">        528 :     fclose (r-&gt;fp);</span>
<span class="lineNum">     316 </span><span class="lineCov">        528 :   r-&gt;fp = NULL;</span>
<span class="lineNum">     317 </span><span class="lineCov">        528 :   r-&gt;nb_read = 0;</span>
<span class="lineNum">     318 </span><span class="lineCov">        528 :   r-&gt;line_start_idx = 0;</span>
<span class="lineNum">     319 </span><span class="lineCov">        528 :   r-&gt;line_num = 0;</span>
<span class="lineNum">     320 </span><span class="lineCov">        528 :   r-&gt;line_record.truncate (0);</span>
<span class="lineNum">     321 </span><span class="lineCov">        528 :   r-&gt;use_count = 0;</span>
<span class="lineNum">     322 </span><span class="lineCov">        528 :   r-&gt;total_lines = 0;</span>
<span class="lineNum">     323 </span><span class="lineCov">        528 :   r-&gt;missing_trailing_newline = true;</span>
<span class="lineNum">     324 </span>            : }
<span class="lineNum">     325 </span>            : 
<span class="lineNum">     326 </span>            : /* Return the file cache that has been less used, recently, or the
<span class="lineNum">     327 </span>            :    first empty one.  If HIGHEST_USE_COUNT is non-null,
<span class="lineNum">     328 </span>            :    *HIGHEST_USE_COUNT is set to the highest use count of the entries
<span class="lineNum">     329 </span>            :    in the cache table.  */
<a name="330"><span class="lineNum">     330 </span>            : </a>
<span class="lineNum">     331 </span>            : static fcache*
<span class="lineNum">     332 </span><span class="lineCov">      91529 : evicted_cache_tab_entry (unsigned *highest_use_count)</span>
<span class="lineNum">     333 </span>            : {
<span class="lineNum">     334 </span><span class="lineCov">      91529 :   diagnostic_file_cache_init ();</span>
<span class="lineNum">     335 </span>            : 
<span class="lineNum">     336 </span><span class="lineCov">      91529 :   fcache *to_evict = &amp;fcache_tab[0];</span>
<span class="lineNum">     337 </span><span class="lineCov">      91529 :   unsigned huc = to_evict-&gt;use_count;</span>
<span class="lineNum">     338 </span><span class="lineCov">     181980 :   for (unsigned i = 1; i &lt; fcache_tab_size; ++i)</span>
<span class="lineNum">     339 </span>            :     {
<span class="lineNum">     340 </span><span class="lineCov">     179237 :       fcache *c = &amp;fcache_tab[i];</span>
<span class="lineNum">     341 </span><span class="lineCov">     179237 :       bool c_is_empty = (c-&gt;file_path == NULL);</span>
<span class="lineNum">     342 </span>            : 
<span class="lineNum">     343 </span><span class="lineCov">     179237 :       if (c-&gt;use_count &lt; to_evict-&gt;use_count</span>
<span class="lineNum">     344 </span><span class="lineCov">     167344 :           || (to_evict-&gt;file_path &amp;&amp; c_is_empty))</span>
<span class="lineNum">     345 </span>            :         /* We evict C because it's either an entry with a lower use
<span class="lineNum">     346 </span>            :            count or one that is empty.  */
<span class="lineNum">     347 </span><span class="lineCov">      11893 :         to_evict = c;</span>
<span class="lineNum">     348 </span>            : 
<span class="lineNum">     349 </span><span class="lineCov">     179237 :       if (huc &lt; c-&gt;use_count)</span>
<span class="lineNum">     350 </span><span class="lineCov">      64566 :         huc = c-&gt;use_count;</span>
<span class="lineNum">     351 </span>            : 
<span class="lineNum">     352 </span><span class="lineCov">     179237 :       if (c_is_empty)</span>
<span class="lineNum">     353 </span>            :         /* We've reached the end of the cache; subsequent elements are
<span class="lineNum">     354 </span>            :            all empty.  */
<span class="lineNum">     355 </span>            :         break;
<span class="lineNum">     356 </span>            :     }
<span class="lineNum">     357 </span>            : 
<span class="lineNum">     358 </span><span class="lineCov">      91529 :   if (highest_use_count)</span>
<span class="lineNum">     359 </span><span class="lineCov">      91529 :     *highest_use_count = huc;</span>
<span class="lineNum">     360 </span>            : 
<span class="lineNum">     361 </span><span class="lineCov">      91529 :   return to_evict;</span>
<span class="lineNum">     362 </span>            : }
<span class="lineNum">     363 </span>            : 
<span class="lineNum">     364 </span>            : /* Create the cache used for the content of a given file to be
<span class="lineNum">     365 </span>            :    accessed by caret diagnostic.  This cache is added to an array of
<span class="lineNum">     366 </span>            :    cache and can be retrieved by lookup_file_in_cache_tab.  This
<span class="lineNum">     367 </span>            :    function returns the created cache.  Note that only the last
<span class="lineNum">     368 </span>            :    fcache_tab_size files are cached.  */
<a name="369"><span class="lineNum">     369 </span>            : </a>
<span class="lineNum">     370 </span>            : static fcache*
<span class="lineNum">     371 </span><span class="lineCov">      95058 : add_file_to_cache_tab (const char *file_path)</span>
<span class="lineNum">     372 </span>            : {
<span class="lineNum">     373 </span>            : 
<span class="lineNum">     374 </span><span class="lineCov">      95058 :   FILE *fp = fopen (file_path, &quot;r&quot;);</span>
<span class="lineNum">     375 </span><span class="lineCov">      95058 :   if (fp == NULL)</span>
<span class="lineNum">     376 </span>            :     return NULL;
<span class="lineNum">     377 </span>            : 
<span class="lineNum">     378 </span><span class="lineCov">      91529 :   unsigned highest_use_count = 0;</span>
<span class="lineNum">     379 </span><span class="lineCov">      91529 :   fcache *r = evicted_cache_tab_entry (&amp;highest_use_count);</span>
<span class="lineNum">     380 </span><span class="lineCov">      91529 :   r-&gt;file_path = file_path;</span>
<span class="lineNum">     381 </span><span class="lineCov">      91529 :   if (r-&gt;fp)</span>
<span class="lineNum">     382 </span><span class="lineCov">       2743 :     fclose (r-&gt;fp);</span>
<span class="lineNum">     383 </span><span class="lineCov">      91529 :   r-&gt;fp = fp;</span>
<span class="lineNum">     384 </span><span class="lineCov">      91529 :   r-&gt;nb_read = 0;</span>
<span class="lineNum">     385 </span><span class="lineCov">      91529 :   r-&gt;line_start_idx = 0;</span>
<span class="lineNum">     386 </span><span class="lineCov">      91529 :   r-&gt;line_num = 0;</span>
<span class="lineNum">     387 </span><span class="lineCov">      91529 :   r-&gt;line_record.truncate (0);</span>
<span class="lineNum">     388 </span>            :   /* Ensure that this cache entry doesn't get evicted next time
<span class="lineNum">     389 </span>            :      add_file_to_cache_tab is called.  */
<span class="lineNum">     390 </span><span class="lineCov">      91529 :   r-&gt;use_count = ++highest_use_count;</span>
<span class="lineNum">     391 </span><span class="lineCov">      91529 :   r-&gt;total_lines = total_lines_num (file_path);</span>
<span class="lineNum">     392 </span><span class="lineCov">      91529 :   r-&gt;missing_trailing_newline = true;</span>
<span class="lineNum">     393 </span>            : 
<span class="lineNum">     394 </span><span class="lineCov">      91529 :   return r;</span>
<span class="lineNum">     395 </span>            : }
<span class="lineNum">     396 </span>            : 
<span class="lineNum">     397 </span>            : /* Lookup the cache used for the content of a given file accessed by
<span class="lineNum">     398 </span>            :    caret diagnostic.  If no cached file was found, create a new cache
<span class="lineNum">     399 </span>            :    for this file, add it to the array of cached file and return
<span class="lineNum">     400 </span>            :    it.  */
<a name="401"><span class="lineNum">     401 </span>            : </a>
<span class="lineNum">     402 </span>            : static fcache*
<span class="lineNum">     403 </span><span class="lineCov">     676079 : lookup_or_add_file_to_cache_tab (const char *file_path)</span>
<span class="lineNum">     404 </span>            : {
<span class="lineNum">     405 </span><span class="lineCov">     676079 :   fcache *r = lookup_file_in_cache_tab (file_path);</span>
<span class="lineNum">     406 </span><span class="lineCov">     676079 :   if (r == NULL)</span>
<span class="lineNum">     407 </span><span class="lineCov">      95058 :     r = add_file_to_cache_tab (file_path);</span>
<span class="lineNum">     408 </span><span class="lineCov">     676079 :   return r;</span>
<span class="lineNum">     409 </span>            : }
<span class="lineNum">     410 </span>            : 
<span class="lineNum">     411 </span>            : /* Default constructor for a cache of file used by caret
<a name="412"><span class="lineNum">     412 </span>            :    diagnostic.  */</a>
<span class="lineNum">     413 </span>            : 
<span class="lineNum">     414 </span><span class="lineCov">    1261696 : fcache::fcache ()</span>
<span class="lineNum">     415 </span>            : : use_count (0), file_path (NULL), fp (NULL), data (0),
<span class="lineNum">     416 </span>            :   size (0), nb_read (0), line_start_idx (0), line_num (0),
<span class="lineNum">     417 </span><span class="lineCov">    1261696 :   total_lines (0), missing_trailing_newline (true)</span>
<span class="lineNum">     418 </span>            : {
<span class="lineNum">     419 </span><span class="lineCov">    2523392 :   line_record.create (0);</span>
<span class="lineNum">     420 </span><span class="lineCov">    1261696 : }</span>
<span class="lineNum">     421 </span>            : 
<a name="422"><span class="lineNum">     422 </span>            : /* Destructor for a cache of file used by caret diagnostic.  */</a>
<span class="lineNum">     423 </span>            : 
<span class="lineNum">     424 </span><span class="lineCov">    2523392 : fcache::~fcache ()</span>
<span class="lineNum">     425 </span>            : {
<span class="lineNum">     426 </span><span class="lineCov">    1261696 :   if (fp)</span>
<span class="lineNum">     427 </span>            :     {
<span class="lineNum">     428 </span><span class="lineCov">      88258 :       fclose (fp);</span>
<span class="lineNum">     429 </span><span class="lineCov">      88258 :       fp = NULL;</span>
<span class="lineNum">     430 </span>            :     }
<span class="lineNum">     431 </span><span class="lineCov">    1261696 :   if (data)</span>
<span class="lineNum">     432 </span>            :     {
<span class="lineNum">     433 </span><span class="lineCov">      88260 :       XDELETEVEC (data);</span>
<span class="lineNum">     434 </span><span class="lineCov">      88260 :       data = 0;</span>
<span class="lineNum">     435 </span>            :     }
<span class="lineNum">     436 </span><span class="lineCov">    1261696 :   line_record.release ();</span>
<span class="lineNum">     437 </span><span class="lineCov">    1261696 : }</span>
<span class="lineNum">     438 </span>            : 
<span class="lineNum">     439 </span>            : /* Returns TRUE iff the cache would need to be filled with data coming
<span class="lineNum">     440 </span>            :    from the file.  That is, either the cache is empty or full or the
<span class="lineNum">     441 </span>            :    current line is empty.  Note that if the cache is full, it would
<span class="lineNum">     442 </span>            :    need to be extended and filled again.  */
<a name="443"><span class="lineNum">     443 </span>            : </a>
<span class="lineNum">     444 </span>            : static bool
<span class="lineNum">     445 </span><span class="lineNoCov">          0 : needs_read (fcache *c)</span>
<span class="lineNum">     446 </span>            : {
<span class="lineNum">     447 </span><span class="lineCov">  100977220 :   return (c-&gt;nb_read == 0</span>
<span class="lineNum">     448 </span><span class="lineCov">  100885691 :           || c-&gt;nb_read == c-&gt;size</span>
<span class="lineNum">     449 </span><span class="lineCov">  100808989 :           || (c-&gt;line_start_idx &gt;= c-&gt;nb_read - 1));</span>
<span class="lineNum">     450 </span>            : }
<span class="lineNum">     451 </span>            : 
<span class="lineNum">     452 </span>            : /*  Return TRUE iff the cache is full and thus needs to be
<span class="lineNum">     453 </span>            :     extended.  */
<a name="454"><span class="lineNum">     454 </span>            : </a>
<span class="lineNum">     455 </span>            : static bool
<span class="lineNum">     456 </span><span class="lineNoCov">          0 : needs_grow (fcache *c)</span>
<span class="lineNum">     457 </span>            : {
<span class="lineNum">     458 </span><span class="lineCov">     168231 :   return c-&gt;nb_read == c-&gt;size;</span>
<span class="lineNum">     459 </span>            : }
<span class="lineNum">     460 </span>            : 
<span class="lineNum">     461 </span>            : /* Grow the cache if it needs to be extended.  */
<a name="462"><span class="lineNum">     462 </span>            : </a>
<span class="lineNum">     463 </span>            : static void
<span class="lineNum">     464 </span><span class="lineCov">     168231 : maybe_grow (fcache *c)</span>
<span class="lineNum">     465 </span>            : {
<span class="lineNum">     466 </span><span class="lineCov">     168231 :   if (!needs_grow (c))</span>
<span class="lineNum">     467 </span>            :     return;
<span class="lineNum">     468 </span>            : 
<span class="lineNum">     469 </span><span class="lineCov">     164962 :   size_t size = c-&gt;size == 0 ? fcache_buffer_size : c-&gt;size * 2;</span>
<span class="lineNum">     470 </span><span class="lineCov">     164962 :   c-&gt;data = XRESIZEVEC (char, c-&gt;data, size);</span>
<span class="lineNum">     471 </span><span class="lineCov">     164962 :   c-&gt;size = size;</span>
<span class="lineNum">     472 </span>            : }
<span class="lineNum">     473 </span>            : 
<span class="lineNum">     474 </span>            : /*  Read more data into the cache.  Extends the cache if need be.
<span class="lineNum">     475 </span>            :     Returns TRUE iff new data could be read.  */
<a name="476"><span class="lineNum">     476 </span>            : </a>
<span class="lineNum">     477 </span>            : static bool
<span class="lineNum">     478 </span><span class="lineCov">     179083 : read_data (fcache *c)</span>
<span class="lineNum">     479 </span>            : {
<span class="lineNum">     480 </span><span class="lineCov">     179083 :   if (feof (c-&gt;fp) || ferror (c-&gt;fp))</span>
<span class="lineNum">     481 </span><span class="lineCov">      10852 :     return false;</span>
<span class="lineNum">     482 </span>            : 
<span class="lineNum">     483 </span><span class="lineCov">     168231 :   maybe_grow (c);</span>
<span class="lineNum">     484 </span>            : 
<span class="lineNum">     485 </span><span class="lineCov">     168231 :   char * from = c-&gt;data + c-&gt;nb_read;</span>
<span class="lineNum">     486 </span><span class="lineCov">     168231 :   size_t to_read = c-&gt;size - c-&gt;nb_read;</span>
<span class="lineNum">     487 </span><span class="lineCov">     168231 :   size_t nb_read = fread (from, 1, to_read, c-&gt;fp);</span>
<span class="lineNum">     488 </span>            : 
<span class="lineNum">     489 </span><span class="lineCov">     168231 :   if (ferror (c-&gt;fp))</span>
<span class="lineNum">     490 </span>            :     return false;
<span class="lineNum">     491 </span>            : 
<span class="lineNum">     492 </span><span class="lineCov">     168231 :   c-&gt;nb_read += nb_read;</span>
<span class="lineNum">     493 </span><span class="lineCov">     168231 :   return !!nb_read;</span>
<span class="lineNum">     494 </span>            : }
<span class="lineNum">     495 </span>            : 
<span class="lineNum">     496 </span>            : /* Read new data iff the cache needs to be filled with more data
<span class="lineNum">     497 </span>            :    coming from the file FP.  Return TRUE iff the cache was filled with
<span class="lineNum">     498 </span>            :    mode data.  */
<a name="499"><span class="lineNum">     499 </span>            : </a>
<span class="lineNum">     500 </span>            : static bool
<span class="lineNum">     501 </span><span class="lineCov">  100977220 : maybe_read_data (fcache *c)</span>
<span class="lineNum">     502 </span>            : {
<span class="lineNum">     503 </span><span class="lineCov">  100977220 :   if (!needs_read (c))</span>
<span class="lineNum">     504 </span>            :     return false;
<span class="lineNum">     505 </span><span class="lineCov">     179083 :   return read_data (c);</span>
<span class="lineNum">     506 </span>            : }
<span class="lineNum">     507 </span>            : 
<span class="lineNum">     508 </span>            : /* Read a new line from file FP, using C as a cache for the data
<span class="lineNum">     509 </span>            :    coming from the file.  Upon successful completion, *LINE is set to
<span class="lineNum">     510 </span>            :    the beginning of the line found.  *LINE points directly in the
<span class="lineNum">     511 </span>            :    line cache and is only valid until the next call of get_next_line.
<span class="lineNum">     512 </span>            :    *LINE_LEN is set to the length of the line.  Note that the line
<span class="lineNum">     513 </span>            :    does not contain any terminal delimiter.  This function returns
<span class="lineNum">     514 </span>            :    true if some data was read or process from the cache, false
<span class="lineNum">     515 </span>            :    otherwise.  Note that subsequent calls to get_next_line might
<span class="lineNum">     516 </span>            :    make the content of *LINE invalid.  */
<a name="517"><span class="lineNum">     517 </span>            : </a>
<span class="lineNum">     518 </span>            : static bool
<span class="lineNum">     519 </span><span class="lineCov">  100926816 : get_next_line (fcache *c, char **line, ssize_t *line_len)</span>
<span class="lineNum">     520 </span>            : {
<span class="lineNum">     521 </span>            :   /* Fill the cache with data to process.  */
<span class="lineNum">     522 </span><span class="lineCov">  100926816 :   maybe_read_data (c);</span>
<span class="lineNum">     523 </span>            : 
<span class="lineNum">     524 </span><span class="lineCov">  100926816 :   size_t remaining_size = c-&gt;nb_read - c-&gt;line_start_idx;</span>
<span class="lineNum">     525 </span><span class="lineCov">  100926816 :   if (remaining_size == 0)</span>
<span class="lineNum">     526 </span>            :     /* There is no more data to process.  */
<span class="lineNum">     527 </span>            :     return false;
<span class="lineNum">     528 </span>            : 
<span class="lineNum">     529 </span><span class="lineCov">  100913619 :   char *line_start = c-&gt;data + c-&gt;line_start_idx;</span>
<span class="lineNum">     530 </span>            : 
<span class="lineNum">     531 </span><span class="lineCov">  100913619 :   char *next_line_start = NULL;</span>
<span class="lineNum">     532 </span><span class="lineCov">  100913619 :   size_t len = 0;</span>
<span class="lineNum">     533 </span><span class="lineCov">  100913619 :   char *line_end = (char *) memchr (line_start, '\n', remaining_size);</span>
<span class="lineNum">     534 </span><span class="lineCov">  100913619 :   if (line_end == NULL)</span>
<span class="lineNum">     535 </span>            :     {
<span class="lineNum">     536 </span>            :       /* We haven't found the end-of-line delimiter in the cache.
<span class="lineNum">     537 </span>            :          Fill the cache with more data from the file and look for the
<span class="lineNum">     538 </span>            :          '\n'.  */
<span class="lineNum">     539 </span><span class="lineCov">      50404 :       while (maybe_read_data (c))</span>
<span class="lineNum">     540 </span>            :         {
<span class="lineNum">     541 </span><span class="lineCov">      50400 :           line_start = c-&gt;data + c-&gt;line_start_idx;</span>
<span class="lineNum">     542 </span><span class="lineCov">      50400 :           remaining_size = c-&gt;nb_read - c-&gt;line_start_idx;</span>
<span class="lineNum">     543 </span><span class="lineCov">      50400 :           line_end = (char *) memchr (line_start, '\n', remaining_size);</span>
<span class="lineNum">     544 </span><span class="lineCov">      50400 :           if (line_end != NULL)</span>
<span class="lineNum">     545 </span>            :             {
<span class="lineNum">     546 </span><span class="lineCov">      36000 :               next_line_start = line_end + 1;</span>
<span class="lineNum">     547 </span><span class="lineCov">      36000 :               break;</span>
<span class="lineNum">     548 </span>            :             }
<span class="lineNum">     549 </span>            :         }
<span class="lineNum">     550 </span><span class="lineCov">      36004 :       if (line_end == NULL)</span>
<span class="lineNum">     551 </span>            :         {
<span class="lineNum">     552 </span>            :           /* We've loadded all the file into the cache and still no
<span class="lineNum">     553 </span>            :              '\n'.  Let's say the line ends up at one byte passed the
<span class="lineNum">     554 </span>            :              end of the file.  This is to stay consistent with the case
<span class="lineNum">     555 </span>            :              of when the line ends up with a '\n' and line_end points to
<span class="lineNum">     556 </span>            :              that terminal '\n'.  That consistency is useful below in
<span class="lineNum">     557 </span>            :              the len calculation.  */
<span class="lineNum">     558 </span><span class="lineCov">          4 :           line_end = c-&gt;data + c-&gt;nb_read ;</span>
<span class="lineNum">     559 </span><span class="lineCov">          4 :           c-&gt;missing_trailing_newline = true;</span>
<span class="lineNum">     560 </span>            :         }
<span class="lineNum">     561 </span>            :       else
<span class="lineNum">     562 </span><span class="lineCov">      36000 :         c-&gt;missing_trailing_newline = false;</span>
<span class="lineNum">     563 </span>            :     }
<span class="lineNum">     564 </span>            :   else
<span class="lineNum">     565 </span>            :     {
<span class="lineNum">     566 </span><span class="lineCov">  100877615 :       next_line_start = line_end + 1;</span>
<span class="lineNum">     567 </span><span class="lineCov">  100877615 :       c-&gt;missing_trailing_newline = false;</span>
<span class="lineNum">     568 </span>            :     }
<span class="lineNum">     569 </span>            : 
<span class="lineNum">     570 </span><span class="lineCov">  100913619 :   if (ferror (c-&gt;fp))</span>
<span class="lineNum">     571 </span>            :     return false;
<span class="lineNum">     572 </span>            : 
<span class="lineNum">     573 </span>            :   /* At this point, we've found the end of the of line.  It either
<span class="lineNum">     574 </span>            :      points to the '\n' or to one byte after the last byte of the
<span class="lineNum">     575 </span>            :      file.  */
<span class="lineNum">     576 </span><span class="lineCov">  100913619 :   gcc_assert (line_end != NULL);</span>
<span class="lineNum">     577 </span>            : 
<span class="lineNum">     578 </span><span class="lineCov">  100913619 :   len = line_end - line_start;</span>
<span class="lineNum">     579 </span>            : 
<span class="lineNum">     580 </span><span class="lineCov">  100913619 :   if (c-&gt;line_start_idx &lt; c-&gt;nb_read)</span>
<span class="lineNum">     581 </span><span class="lineCov">  100913619 :     *line = line_start;</span>
<span class="lineNum">     582 </span>            : 
<span class="lineNum">     583 </span><span class="lineCov">  100913619 :   ++c-&gt;line_num;</span>
<span class="lineNum">     584 </span>            : 
<span class="lineNum">     585 </span>            :   /* Before we update our line record, make sure the hint about the
<span class="lineNum">     586 </span>            :      total number of lines of the file is correct.  If it's not, then
<span class="lineNum">     587 </span>            :      we give up recording line boundaries from now on.  */
<span class="lineNum">     588 </span><span class="lineCov">  100913619 :   bool update_line_record = true;</span>
<span class="lineNum">     589 </span><span class="lineCov">  100913619 :   if (c-&gt;line_num &gt; c-&gt;total_lines)</span>
<span class="lineNum">     590 </span>            :     update_line_record = false;
<span class="lineNum">     591 </span>            : 
<span class="lineNum">     592 </span>            :     /* Now update our line record so that re-reading lines from the
<span class="lineNum">     593 </span>            :      before c-&gt;line_start_idx is faster.  */
<span class="lineNum">     594 </span><span class="lineCov">    9653124 :   if (update_line_record</span>
<span class="lineNum">     595 </span><span class="lineCov">    9653124 :       &amp;&amp; c-&gt;line_record.length () &lt; fcache_line_record_size)</span>
<span class="lineNum">     596 </span>            :     {
<span class="lineNum">     597 </span>            :       /* If the file lines fits in the line record, we just record all
<span class="lineNum">     598 </span>            :          its lines ...*/
<span class="lineNum">     599 </span><span class="lineCov">    8104200 :       if (c-&gt;total_lines &lt;= fcache_line_record_size</span>
<span class="lineNum">     600 </span><span class="lineCov">    8446682 :           &amp;&amp; c-&gt;line_num &gt; c-&gt;line_record.length ())</span>
<span class="lineNum">     601 </span><span class="lineCov">     388374 :         c-&gt;line_record.safe_push (fcache::line_info (c-&gt;line_num,</span>
<span class="lineNum">     602 </span>            :                                                  c-&gt;line_start_idx,
<span class="lineNum">     603 </span><span class="lineCov">     388374 :                                                  line_end - c-&gt;data));</span>
<span class="lineNum">     604 </span><span class="lineCov">    7715826 :       else if (c-&gt;total_lines &gt; fcache_line_record_size)</span>
<span class="lineNum">     605 </span>            :         {
<span class="lineNum">     606 </span>            :           /* ... otherwise, we just scale total_lines down to
<span class="lineNum">     607 </span>            :              (fcache_line_record_size lines.  */
<span class="lineNum">     608 </span><span class="lineCov">    7683278 :           size_t n = (c-&gt;line_num * fcache_line_record_size) / c-&gt;total_lines;</span>
<span class="lineNum">     609 </span><span class="lineCov">    7683278 :           if (c-&gt;line_record.length () == 0</span>
<span class="lineNum">     610 </span><span class="lineCov">    7673459 :               || n &gt;= c-&gt;line_record.length ())</span>
<span class="lineNum">     611 </span><span class="lineCov">     959262 :             c-&gt;line_record.safe_push (fcache::line_info (c-&gt;line_num,</span>
<span class="lineNum">     612 </span>            :                                                      c-&gt;line_start_idx,
<span class="lineNum">     613 </span><span class="lineCov">     959262 :                                                      line_end - c-&gt;data));</span>
<span class="lineNum">     614 </span>            :         }
<span class="lineNum">     615 </span>            :     }
<span class="lineNum">     616 </span>            : 
<span class="lineNum">     617 </span>            :   /* Update c-&gt;line_start_idx so that it points to the next line to be
<span class="lineNum">     618 </span>            :      read.  */
<span class="lineNum">     619 </span><span class="lineCov">  100913619 :   if (next_line_start)</span>
<span class="lineNum">     620 </span><span class="lineCov">  100913615 :     c-&gt;line_start_idx = next_line_start - c-&gt;data;</span>
<span class="lineNum">     621 </span>            :   else
<span class="lineNum">     622 </span>            :     /* We didn't find any terminal '\n'.  Let's consider that the end
<span class="lineNum">     623 </span>            :        of line is the end of the data in the cache.  The next
<span class="lineNum">     624 </span>            :        invocation of get_next_line will either read more data from the
<span class="lineNum">     625 </span>            :        underlying file or return false early because we've reached the
<span class="lineNum">     626 </span>            :        end of the file.  */
<span class="lineNum">     627 </span><span class="lineCov">          4 :     c-&gt;line_start_idx = c-&gt;nb_read;</span>
<span class="lineNum">     628 </span>            : 
<span class="lineNum">     629 </span><span class="lineCov">  100913619 :   *line_len = len;</span>
<span class="lineNum">     630 </span>            : 
<span class="lineNum">     631 </span><span class="lineCov">  100913619 :   return true;</span>
<span class="lineNum">     632 </span>            : }
<span class="lineNum">     633 </span>            : 
<span class="lineNum">     634 </span>            : /* Consume the next bytes coming from the cache (or from its
<span class="lineNum">     635 </span>            :    underlying file if there are remaining unread bytes in the file)
<span class="lineNum">     636 </span>            :    until we reach the next end-of-line (or end-of-file).  There is no
<span class="lineNum">     637 </span>            :    copying from the cache involved.  Return TRUE upon successful
<span class="lineNum">     638 </span>            :    completion.  */
<a name="639"><span class="lineNum">     639 </span>            : </a>
<span class="lineNum">     640 </span>            : static bool
<span class="lineNum">     641 </span><span class="lineNoCov">          0 : goto_next_line (fcache *cache)</span>
<span class="lineNum">     642 </span>            : {
<span class="lineNum">     643 </span><span class="lineCov">  100430895 :   char *l;</span>
<span class="lineNum">     644 </span><span class="lineCov">  100430895 :   ssize_t len;</span>
<span class="lineNum">     645 </span>            : 
<span class="lineNum">     646 </span><span class="lineNoCov">          0 :   return get_next_line (cache, &amp;l, &amp;len);</span>
<span class="lineNum">     647 </span>            : }
<span class="lineNum">     648 </span>            : 
<span class="lineNum">     649 </span>            : /* Read an arbitrary line number LINE_NUM from the file cached in C.
<span class="lineNum">     650 </span>            :    If the line was read successfully, *LINE points to the beginning
<span class="lineNum">     651 </span>            :    of the line in the file cache and *LINE_LEN is the length of the
<span class="lineNum">     652 </span>            :    line.  *LINE is not nul-terminated, but may contain zero bytes.
<span class="lineNum">     653 </span>            :    *LINE is only valid until the next call of read_line_num.
<span class="lineNum">     654 </span>            :    This function returns bool if a line was read.  */
<a name="655"><span class="lineNum">     655 </span>            : </a>
<span class="lineNum">     656 </span>            : static bool
<span class="lineNum">     657 </span><span class="lineCov">     663751 : read_line_num (fcache *c, size_t line_num,</span>
<span class="lineNum">     658 </span>            :                char **line, ssize_t *line_len)
<span class="lineNum">     659 </span>            : {
<span class="lineNum">     660 </span><span class="lineCov">     663751 :   gcc_assert (line_num &gt; 0);</span>
<span class="lineNum">     661 </span>            : 
<span class="lineNum">     662 </span><span class="lineCov">     663751 :   if (line_num &lt;= c-&gt;line_num)</span>
<span class="lineNum">     663 </span>            :     {
<span class="lineNum">     664 </span>            :       /* We've been asked to read lines that are before c-&gt;line_num.
<span class="lineNum">     665 </span>            :          So lets use our line record (if it's not empty) to try to
<span class="lineNum">     666 </span>            :          avoid re-reading the file from the beginning again.  */
<span class="lineNum">     667 </span>            : 
<span class="lineNum">     668 </span><span class="lineCov">     409943 :       if (c-&gt;line_record.is_empty ())</span>
<span class="lineNum">     669 </span>            :         {
<span class="lineNum">     670 </span><span class="lineCov">         13 :           c-&gt;line_start_idx = 0;</span>
<span class="lineNum">     671 </span><span class="lineCov">         13 :           c-&gt;line_num = 0;</span>
<span class="lineNum">     672 </span>            :         }
<span class="lineNum">     673 </span>            :       else
<span class="lineNum">     674 </span>            :         {
<span class="lineNum">     675 </span><span class="lineCov">     409930 :           fcache::line_info *i = NULL;</span>
<span class="lineNum">     676 </span><span class="lineCov">     409930 :           if (c-&gt;total_lines &lt;= fcache_line_record_size)</span>
<span class="lineNum">     677 </span>            :             {
<span class="lineNum">     678 </span>            :               /* In languages where the input file is not totally
<span class="lineNum">     679 </span>            :                  preprocessed up front, the c-&gt;total_lines hint
<span class="lineNum">     680 </span>            :                  can be smaller than the number of lines of the
<span class="lineNum">     681 </span>            :                  file.  In that case, only the first
<span class="lineNum">     682 </span>            :                  c-&gt;total_lines have been recorded.
<span class="lineNum">     683 </span>            : 
<span class="lineNum">     684 </span>            :                  Otherwise, the first c-&gt;total_lines we've read have
<span class="lineNum">     685 </span>            :                  their start/end recorded here.  */
<span class="lineNum">     686 </span><span class="lineCov">     311846 :               i = (line_num &lt;= c-&gt;total_lines)</span>
<span class="lineNum">     687 </span><span class="lineCov">     155923 :                 ? &amp;c-&gt;line_record[line_num - 1]</span>
<span class="lineNum">     688 </span><span class="lineCov">      32860 :                 : &amp;c-&gt;line_record[c-&gt;total_lines - 1];</span>
<span class="lineNum">     689 </span><span class="lineCov">     155923 :               gcc_assert (i-&gt;line_num &lt;= line_num);</span>
<span class="lineNum">     690 </span>            :             }
<span class="lineNum">     691 </span>            :           else
<span class="lineNum">     692 </span>            :             {
<span class="lineNum">     693 </span>            :               /*  So the file had more lines than our line record
<span class="lineNum">     694 </span>            :                   size.  Thus the number of lines we've recorded has
<span class="lineNum">     695 </span>            :                   been scaled down to fcache_line_reacord_size.  Let's
<span class="lineNum">     696 </span>            :                   pick the start/end of the recorded line that is
<span class="lineNum">     697 </span>            :                   closest to line_num.  */
<span class="lineNum">     698 </span><span class="lineCov">     254007 :               size_t n = (line_num &lt;= c-&gt;total_lines)</span>
<span class="lineNum">     699 </span><span class="lineCov">     254007 :                 ? line_num * fcache_line_record_size / c-&gt;total_lines</span>
<span class="lineNum">     700 </span><span class="lineCov">      97134 :                 : c -&gt;line_record.length () - 1;</span>
<span class="lineNum">     701 </span><span class="lineCov">     508014 :               if (n &lt; c-&gt;line_record.length ())</span>
<span class="lineNum">     702 </span>            :                 {
<span class="lineNum">     703 </span><span class="lineCov">     253324 :                   i = &amp;c-&gt;line_record[n];</span>
<span class="lineNum">     704 </span><span class="lineCov">     253324 :                   gcc_assert (i-&gt;line_num &lt;= line_num);</span>
<span class="lineNum">     705 </span>            :                 }
<span class="lineNum">     706 </span>            :             }
<span class="lineNum">     707 </span>            : 
<span class="lineNum">     708 </span><span class="lineCov">     409247 :           if (i &amp;&amp; i-&gt;line_num == line_num)</span>
<span class="lineNum">     709 </span>            :             {
<span class="lineNum">     710 </span>            :               /* We have the start/end of the line.  */
<span class="lineNum">     711 </span><span class="lineCov">     165618 :               *line = c-&gt;data + i-&gt;start_pos;</span>
<span class="lineNum">     712 </span><span class="lineCov">     165618 :               *line_len = i-&gt;end_pos - i-&gt;start_pos;</span>
<span class="lineNum">     713 </span><span class="lineCov">     165618 :               return true;</span>
<span class="lineNum">     714 </span>            :             }
<span class="lineNum">     715 </span>            : 
<span class="lineNum">     716 </span><span class="lineCov">     244312 :           if (i)</span>
<span class="lineNum">     717 </span>            :             {
<span class="lineNum">     718 </span><span class="lineCov">     243629 :               c-&gt;line_start_idx = i-&gt;start_pos;</span>
<span class="lineNum">     719 </span><span class="lineCov">     243629 :               c-&gt;line_num = i-&gt;line_num - 1;</span>
<span class="lineNum">     720 </span>            :             }
<span class="lineNum">     721 </span>            :           else
<span class="lineNum">     722 </span>            :             {
<span class="lineNum">     723 </span><span class="lineCov">        683 :               c-&gt;line_start_idx = 0;</span>
<span class="lineNum">     724 </span><span class="lineCov">        683 :               c-&gt;line_num = 0;</span>
<span class="lineNum">     725 </span>            :             }
<span class="lineNum">     726 </span>            :         }
<span class="lineNum">     727 </span>            :     }
<span class="lineNum">     728 </span>            : 
<span class="lineNum">     729 </span>            :   /*  Let's walk from line c-&gt;line_num up to line_num - 1, without
<span class="lineNum">     730 </span>            :       copying any line.  */
<span class="lineNum">     731 </span><span class="lineCov">  100926816 :   while (c-&gt;line_num &lt; line_num - 1)</span>
<span class="lineNum">     732 </span><span class="lineCov">  100430895 :     if (!goto_next_line (c))</span>
<span class="lineNum">     733 </span>            :       return false;
<span class="lineNum">     734 </span>            : 
<span class="lineNum">     735 </span>            :   /* The line we want is the next one.  Let's read and copy it back to
<span class="lineNum">     736 </span>            :      the caller.  */
<span class="lineNum">     737 </span><span class="lineCov">     495921 :   return get_next_line (c, line, line_len);</span>
<span class="lineNum">     738 </span>            : }
<span class="lineNum">     739 </span>            : 
<span class="lineNum">     740 </span>            : /* Return the physical source line that corresponds to FILE_PATH/LINE.
<span class="lineNum">     741 </span>            :    The line is not nul-terminated.  The returned pointer is only
<span class="lineNum">     742 </span>            :    valid until the next call of location_get_source_line.
<span class="lineNum">     743 </span>            :    Note that the line can contain several null characters,
<span class="lineNum">     744 </span>            :    so the returned value's length has the actual length of the line.
<span class="lineNum">     745 </span>            :    If the function fails, a NULL char_span is returned.  */
<a name="746"><span class="lineNum">     746 </span>            : </a>
<span class="lineNum">     747 </span>            : char_span
<span class="lineNum">     748 </span><span class="lineCov">     667291 : location_get_source_line (const char *file_path, int line)</span>
<span class="lineNum">     749 </span>            : {
<span class="lineNum">     750 </span><span class="lineCov">     667291 :   char *buffer = NULL;</span>
<span class="lineNum">     751 </span><span class="lineCov">     667291 :   ssize_t len;</span>
<span class="lineNum">     752 </span>            : 
<span class="lineNum">     753 </span><span class="lineCov">     667291 :   if (line == 0)</span>
<span class="lineNum">     754 </span><span class="lineCov">         11 :     return char_span (NULL, 0);</span>
<span class="lineNum">     755 </span>            : 
<span class="lineNum">     756 </span><span class="lineCov">     667280 :   fcache *c = lookup_or_add_file_to_cache_tab (file_path);</span>
<span class="lineNum">     757 </span><span class="lineCov">     667280 :   if (c == NULL)</span>
<span class="lineNum">     758 </span><span class="lineCov">       3529 :     return char_span (NULL, 0);</span>
<span class="lineNum">     759 </span>            : 
<span class="lineNum">     760 </span><span class="lineCov">     663751 :   bool read = read_line_num (c, line, &amp;buffer, &amp;len);</span>
<span class="lineNum">     761 </span><span class="lineCov">     663751 :   if (!read)</span>
<span class="lineNum">     762 </span><span class="lineCov">      13197 :     return char_span (NULL, 0);</span>
<span class="lineNum">     763 </span>            : 
<span class="lineNum">     764 </span><span class="lineCov">     650554 :   return char_span (buffer, len);</span>
<span class="lineNum">     765 </span>            : }
<span class="lineNum">     766 </span>            : 
<span class="lineNum">     767 </span>            : /* Determine if FILE_PATH missing a trailing newline on its final line.
<span class="lineNum">     768 </span>            :    Only valid to call once all of the file has been loaded, by
<span class="lineNum">     769 </span>            :    requesting a line number beyond the end of the file.  */
<a name="770"><span class="lineNum">     770 </span>            : </a>
<span class="lineNum">     771 </span>            : bool
<span class="lineNum">     772 </span><span class="lineCov">       8799 : location_missing_trailing_newline (const char *file_path)</span>
<span class="lineNum">     773 </span>            : {
<span class="lineNum">     774 </span><span class="lineCov">       8799 :   fcache *c = lookup_or_add_file_to_cache_tab (file_path);</span>
<span class="lineNum">     775 </span><span class="lineCov">       8799 :   if (c == NULL)</span>
<span class="lineNum">     776 </span>            :     return false;
<span class="lineNum">     777 </span>            : 
<span class="lineNum">     778 </span><span class="lineCov">       8799 :   return c-&gt;missing_trailing_newline;</span>
<span class="lineNum">     779 </span>            : }
<span class="lineNum">     780 </span>            : 
<span class="lineNum">     781 </span>            : /* Test if the location originates from the spelling location of a
<span class="lineNum">     782 </span>            :    builtin-tokens.  That is, return TRUE if LOC is a (possibly
<span class="lineNum">     783 </span>            :    virtual) location of a built-in token that appears in the expansion
<span class="lineNum">     784 </span>            :    list of a macro.  Please note that this function also works on
<span class="lineNum">     785 </span>            :    tokens that result from built-in tokens.  For instance, the
<span class="lineNum">     786 </span>            :    function would return true if passed a token &quot;4&quot; that is the result
<a name="787"><span class="lineNum">     787 </span>            :    of the expansion of the built-in __LINE__ macro.  */</a>
<span class="lineNum">     788 </span>            : bool
<span class="lineNum">     789 </span><span class="lineCov">       1475 : is_location_from_builtin_token (source_location loc)</span>
<span class="lineNum">     790 </span>            : {
<span class="lineNum">     791 </span><span class="lineCov">       1475 :   const line_map_ordinary *map = NULL;</span>
<span class="lineNum">     792 </span><span class="lineCov">       1475 :   loc = linemap_resolve_location (line_table, loc,</span>
<span class="lineNum">     793 </span>            :                                   LRK_SPELLING_LOCATION, &amp;map);
<span class="lineNum">     794 </span><span class="lineCov">       1475 :   return loc == BUILTINS_LOCATION;</span>
<span class="lineNum">     795 </span>            : }
<span class="lineNum">     796 </span>            : 
<span class="lineNum">     797 </span>            : /* Expand the source location LOC into a human readable location.  If
<span class="lineNum">     798 </span>            :    LOC is virtual, it resolves to the expansion point of the involved
<span class="lineNum">     799 </span>            :    macro.  If LOC resolves to a builtin location, the file name of the
<span class="lineNum">     800 </span>            :    readable location is set to the string &quot;&lt;built-in&gt;&quot;.  */
<a name="801"><span class="lineNum">     801 </span>            : </a>
<span class="lineNum">     802 </span>            : expanded_location
<span class="lineNum">     803 </span><span class="lineCov">  201526771 : expand_location (source_location loc)</span>
<span class="lineNum">     804 </span>            : {
<span class="lineNum">     805 </span><span class="lineCov">  201526771 :   return expand_location_1 (loc, /*expansion_point_p=*/true,</span>
<span class="lineNum">     806 </span><span class="lineCov">  201526771 :                             LOCATION_ASPECT_CARET);</span>
<span class="lineNum">     807 </span>            : }
<span class="lineNum">     808 </span>            : 
<span class="lineNum">     809 </span>            : /* Expand the source location LOC into a human readable location.  If
<span class="lineNum">     810 </span>            :    LOC is virtual, it resolves to the expansion location of the
<span class="lineNum">     811 </span>            :    relevant macro.  If LOC resolves to a builtin location, the file
<span class="lineNum">     812 </span>            :    name of the readable location is set to the string
<span class="lineNum">     813 </span>            :    &quot;&lt;built-in&gt;&quot;.  */
<a name="814"><span class="lineNum">     814 </span>            : </a>
<span class="lineNum">     815 </span>            : expanded_location
<span class="lineNum">     816 </span><span class="lineCov">      24593 : expand_location_to_spelling_point (source_location loc)</span>
<span class="lineNum">     817 </span>            : {
<span class="lineNum">     818 </span><span class="lineCov">      24593 :   return expand_location_1 (loc, /*expansion_point_p=*/false,</span>
<span class="lineNum">     819 </span><span class="lineCov">      24593 :                             LOCATION_ASPECT_CARET);</span>
<span class="lineNum">     820 </span>            : }
<span class="lineNum">     821 </span>            : 
<span class="lineNum">     822 </span>            : /* The rich_location class within libcpp requires a way to expand
<span class="lineNum">     823 </span>            :    source_location instances, and relies on the client code
<span class="lineNum">     824 </span>            :    providing a symbol named
<span class="lineNum">     825 </span>            :      linemap_client_expand_location_to_spelling_point
<span class="lineNum">     826 </span>            :    to do this.
<span class="lineNum">     827 </span>            : 
<span class="lineNum">     828 </span>            :    This is the implementation for libcommon.a (all host binaries),
<span class="lineNum">     829 </span>            :    which simply calls into expand_location_1.  */
<a name="830"><span class="lineNum">     830 </span>            : </a>
<span class="lineNum">     831 </span>            : expanded_location
<span class="lineNum">     832 </span><span class="lineCov">    1337527 : linemap_client_expand_location_to_spelling_point (source_location loc,</span>
<span class="lineNum">     833 </span>            :                                                   enum location_aspect aspect)
<span class="lineNum">     834 </span>            : {
<span class="lineNum">     835 </span><span class="lineCov">    1337527 :   return expand_location_1 (loc, /*expansion_point_p=*/false, aspect);</span>
<span class="lineNum">     836 </span>            : }
<span class="lineNum">     837 </span>            : 
<span class="lineNum">     838 </span>            : 
<span class="lineNum">     839 </span>            : /* If LOCATION is in a system header and if it is a virtual location for
<span class="lineNum">     840 </span>            :    a token coming from the expansion of a macro, unwind it to the
<span class="lineNum">     841 </span>            :    location of the expansion point of the macro.  Otherwise, just return
<span class="lineNum">     842 </span>            :    LOCATION.
<span class="lineNum">     843 </span>            : 
<span class="lineNum">     844 </span>            :    This is used for instance when we want to emit diagnostics about a
<span class="lineNum">     845 </span>            :    token that may be located in a macro that is itself defined in a
<span class="lineNum">     846 </span>            :    system header, for example, for the NULL macro.  In such a case, if
<span class="lineNum">     847 </span>            :    LOCATION were passed directly to diagnostic functions such as
<span class="lineNum">     848 </span>            :    warning_at, the diagnostic would be suppressed (unless
<span class="lineNum">     849 </span>            :    -Wsystem-headers).  */
<a name="850"><span class="lineNum">     850 </span>            : </a>
<span class="lineNum">     851 </span>            : source_location
<span class="lineNum">     852 </span><span class="lineCov">  199609179 : expansion_point_location_if_in_system_header (source_location location)</span>
<span class="lineNum">     853 </span>            : {
<span class="lineNum">     854 </span><span class="lineCov">  199609179 :   if (in_system_header_at (location))</span>
<span class="lineNum">     855 </span><span class="lineCov">  182338588 :     location = linemap_resolve_location (line_table, location,</span>
<span class="lineNum">     856 </span>            :                                          LRK_MACRO_EXPANSION_POINT,
<span class="lineNum">     857 </span>            :                                          NULL);
<span class="lineNum">     858 </span><span class="lineCov">  199609179 :   return location;</span>
<span class="lineNum">     859 </span>            : }
<span class="lineNum">     860 </span>            : 
<span class="lineNum">     861 </span>            : /* If LOCATION is a virtual location for a token coming from the expansion
<span class="lineNum">     862 </span>            :    of a macro, unwind to the location of the expansion point of the macro.  */
<a name="863"><span class="lineNum">     863 </span>            : </a>
<span class="lineNum">     864 </span>            : source_location
<span class="lineNum">     865 </span><span class="lineCov">         91 : expansion_point_location (source_location location)</span>
<span class="lineNum">     866 </span>            : {
<span class="lineNum">     867 </span><span class="lineCov">         91 :   return linemap_resolve_location (line_table, location,</span>
<span class="lineNum">     868 </span><span class="lineCov">         91 :                                    LRK_MACRO_EXPANSION_POINT, NULL);</span>
<span class="lineNum">     869 </span>            : }
<span class="lineNum">     870 </span>            : 
<span class="lineNum">     871 </span>            : /* Construct a location with caret at CARET, ranging from START to
<span class="lineNum">     872 </span>            :    finish e.g.
<span class="lineNum">     873 </span>            : 
<span class="lineNum">     874 </span>            :                  11111111112
<span class="lineNum">     875 </span>            :         12345678901234567890
<span class="lineNum">     876 </span>            :      522
<span class="lineNum">     877 </span>            :      523   return foo + bar;
<span class="lineNum">     878 </span>            :                   ~~~~^~~~~
<span class="lineNum">     879 </span>            :      524
<span class="lineNum">     880 </span>            : 
<span class="lineNum">     881 </span>            :    The location's caret is at the &quot;+&quot;, line 523 column 15, but starts
<span class="lineNum">     882 </span>            :    earlier, at the &quot;f&quot; of &quot;foo&quot; at column 11.  The finish is at the &quot;r&quot;
<span class="lineNum">     883 </span>            :    of &quot;bar&quot; at column 19.  */
<a name="884"><span class="lineNum">     884 </span>            : </a>
<span class="lineNum">     885 </span>            : location_t
<span class="lineNum">     886 </span><span class="lineCov">  159780174 : make_location (location_t caret, location_t start, location_t finish)</span>
<span class="lineNum">     887 </span>            : {
<span class="lineNum">     888 </span><span class="lineCov">  159780174 :   location_t pure_loc = get_pure_location (caret);</span>
<span class="lineNum">     889 </span><span class="lineCov">  159780174 :   source_range src_range;</span>
<span class="lineNum">     890 </span><span class="lineCov">  159780174 :   src_range.m_start = get_start (start);</span>
<span class="lineNum">     891 </span><span class="lineCov">  159780174 :   src_range.m_finish = get_finish (finish);</span>
<span class="lineNum">     892 </span><span class="lineCov">  159780174 :   location_t combined_loc = COMBINE_LOCATION_DATA (line_table,</span>
<span class="lineNum">     893 </span>            :                                                    pure_loc,
<span class="lineNum">     894 </span>            :                                                    src_range,
<span class="lineNum">     895 </span>            :                                                    NULL);
<span class="lineNum">     896 </span><span class="lineCov">  159780174 :   return combined_loc;</span>
<span class="lineNum">     897 </span>            : }
<span class="lineNum">     898 </span>            : 
<span class="lineNum">     899 </span>            : /* Same as above, but taking a source range rather than two locations.  */
<a name="900"><span class="lineNum">     900 </span>            : </a>
<span class="lineNum">     901 </span>            : location_t
<span class="lineNum">     902 </span><span class="lineCov">     469310 : make_location (location_t caret, source_range src_range)</span>
<span class="lineNum">     903 </span>            : {
<span class="lineNum">     904 </span><span class="lineCov">     469310 :   location_t pure_loc = get_pure_location (caret);</span>
<span class="lineNum">     905 </span><span class="lineCov">     469310 :   return COMBINE_LOCATION_DATA (line_table, pure_loc, src_range, NULL);</span>
<span class="lineNum">     906 </span>            : }
<span class="lineNum">     907 </span>            : 
<span class="lineNum">     908 </span>            : #define ONE_K 1024
<span class="lineNum">     909 </span>            : #define ONE_M (ONE_K * ONE_K)
<span class="lineNum">     910 </span>            : 
<span class="lineNum">     911 </span>            : /* Display a number as an integer multiple of either:
<span class="lineNum">     912 </span>            :    - 1024, if said integer is &gt;= to 10 K (in base 2)
<span class="lineNum">     913 </span>            :    - 1024 * 1024, if said integer is &gt;= 10 M in (base 2)
<span class="lineNum">     914 </span>            :  */
<span class="lineNum">     915 </span>            : #define SCALE(x) ((unsigned long) ((x) &lt; 10 * ONE_K \
<span class="lineNum">     916 </span>            :                   ? (x) \
<span class="lineNum">     917 </span>            :                   : ((x) &lt; 10 * ONE_M \
<span class="lineNum">     918 </span>            :                      ? (x) / ONE_K \
<span class="lineNum">     919 </span>            :                      : (x) / ONE_M)))
<span class="lineNum">     920 </span>            : 
<span class="lineNum">     921 </span>            : /* For a given integer, display either:
<span class="lineNum">     922 </span>            :    - the character 'k', if the number is higher than 10 K (in base 2)
<span class="lineNum">     923 </span>            :      but strictly lower than 10 M (in base 2)
<span class="lineNum">     924 </span>            :    - the character 'M' if the number is higher than 10 M (in base2)
<span class="lineNum">     925 </span>            :    - the charcter ' ' if the number is strictly lower  than 10 K  */
<span class="lineNum">     926 </span>            : #define STAT_LABEL(x) ((x) &lt; 10 * ONE_K ? ' ' : ((x) &lt; 10 * ONE_M ? 'k' : 'M'))
<span class="lineNum">     927 </span>            : 
<span class="lineNum">     928 </span>            : /* Display an integer amount as multiple of 1K or 1M (in base 2).
<span class="lineNum">     929 </span>            :    Display the correct unit (either k, M, or ' ') after the amount, as
<span class="lineNum">     930 </span>            :    well.  */
<span class="lineNum">     931 </span>            : #define FORMAT_AMOUNT(size) SCALE (size), STAT_LABEL (size)
<span class="lineNum">     932 </span>            : 
<span class="lineNum">     933 </span>            : /* Dump statistics to stderr about the memory usage of the line_table
<span class="lineNum">     934 </span>            :    set of line maps.  This also displays some statistics about macro
<span class="lineNum">     935 </span>            :    expansion.  */
<a name="936"><span class="lineNum">     936 </span>            : </a>
<span class="lineNum">     937 </span>            : void
<span class="lineNum">     938 </span><span class="lineNoCov">          0 : dump_line_table_statistics (void)</span>
<span class="lineNum">     939 </span>            : {
<span class="lineNum">     940 </span><span class="lineNoCov">          0 :   struct linemap_stats s;</span>
<span class="lineNum">     941 </span><span class="lineNoCov">          0 :   long total_used_map_size,</span>
<span class="lineNum">     942 </span>            :     macro_maps_size,
<span class="lineNum">     943 </span>            :     total_allocated_map_size;
<span class="lineNum">     944 </span>            : 
<span class="lineNum">     945 </span><span class="lineNoCov">          0 :   memset (&amp;s, 0, sizeof (s));</span>
<span class="lineNum">     946 </span>            : 
<span class="lineNum">     947 </span><span class="lineNoCov">          0 :   linemap_get_statistics (line_table, &amp;s);</span>
<span class="lineNum">     948 </span>            : 
<span class="lineNum">     949 </span><span class="lineNoCov">          0 :   macro_maps_size = s.macro_maps_used_size</span>
<span class="lineNum">     950 </span><span class="lineNoCov">          0 :     + s.macro_maps_locations_size;</span>
<span class="lineNum">     951 </span>            : 
<span class="lineNum">     952 </span><span class="lineNoCov">          0 :   total_allocated_map_size = s.ordinary_maps_allocated_size</span>
<span class="lineNum">     953 </span><span class="lineNoCov">          0 :     + s.macro_maps_allocated_size</span>
<span class="lineNum">     954 </span><span class="lineNoCov">          0 :     + s.macro_maps_locations_size;</span>
<span class="lineNum">     955 </span>            : 
<span class="lineNum">     956 </span><span class="lineNoCov">          0 :   total_used_map_size = s.ordinary_maps_used_size</span>
<span class="lineNum">     957 </span><span class="lineNoCov">          0 :     + s.macro_maps_used_size</span>
<span class="lineNum">     958 </span><span class="lineNoCov">          0 :     + s.macro_maps_locations_size;</span>
<span class="lineNum">     959 </span>            : 
<span class="lineNum">     960 </span><span class="lineNoCov">          0 :   fprintf (stderr, &quot;Number of expanded macros:                     %5ld\n&quot;,</span>
<span class="lineNum">     961 </span>            :            s.num_expanded_macros);
<span class="lineNum">     962 </span><span class="lineNoCov">          0 :   if (s.num_expanded_macros != 0)</span>
<span class="lineNum">     963 </span><span class="lineNoCov">          0 :     fprintf (stderr, &quot;Average number of tokens per macro expansion:  %5ld\n&quot;,</span>
<span class="lineNum">     964 </span><span class="lineNoCov">          0 :              s.num_macro_tokens / s.num_expanded_macros);</span>
<span class="lineNum">     965 </span><span class="lineNoCov">          0 :   fprintf (stderr,</span>
<span class="lineNum">     966 </span>            :            &quot;\nLine Table allocations during the &quot;
<span class="lineNum">     967 </span>            :            &quot;compilation process\n&quot;);
<span class="lineNum">     968 </span><span class="lineNoCov">          0 :   fprintf (stderr, &quot;Number of ordinary maps used:        %5ld%c\n&quot;,</span>
<span class="lineNum">     969 </span><span class="lineNoCov">          0 :            SCALE (s.num_ordinary_maps_used),</span>
<span class="lineNum">     970 </span><span class="lineNoCov">          0 :            STAT_LABEL (s.num_ordinary_maps_used));</span>
<span class="lineNum">     971 </span><span class="lineNoCov">          0 :   fprintf (stderr, &quot;Ordinary map used size:              %5ld%c\n&quot;,</span>
<span class="lineNum">     972 </span><span class="lineNoCov">          0 :            SCALE (s.ordinary_maps_used_size),</span>
<span class="lineNum">     973 </span><span class="lineNoCov">          0 :            STAT_LABEL (s.ordinary_maps_used_size));</span>
<span class="lineNum">     974 </span><span class="lineNoCov">          0 :   fprintf (stderr, &quot;Number of ordinary maps allocated:   %5ld%c\n&quot;,</span>
<span class="lineNum">     975 </span><span class="lineNoCov">          0 :            SCALE (s.num_ordinary_maps_allocated),</span>
<span class="lineNum">     976 </span><span class="lineNoCov">          0 :            STAT_LABEL (s.num_ordinary_maps_allocated));</span>
<span class="lineNum">     977 </span><span class="lineNoCov">          0 :   fprintf (stderr, &quot;Ordinary maps allocated size:        %5ld%c\n&quot;,</span>
<span class="lineNum">     978 </span><span class="lineNoCov">          0 :            SCALE (s.ordinary_maps_allocated_size),</span>
<span class="lineNum">     979 </span><span class="lineNoCov">          0 :            STAT_LABEL (s.ordinary_maps_allocated_size));</span>
<span class="lineNum">     980 </span><span class="lineNoCov">          0 :   fprintf (stderr, &quot;Number of macro maps used:           %5ld%c\n&quot;,</span>
<span class="lineNum">     981 </span><span class="lineNoCov">          0 :            SCALE (s.num_macro_maps_used),</span>
<span class="lineNum">     982 </span><span class="lineNoCov">          0 :            STAT_LABEL (s.num_macro_maps_used));</span>
<span class="lineNum">     983 </span><span class="lineNoCov">          0 :   fprintf (stderr, &quot;Macro maps used size:                %5ld%c\n&quot;,</span>
<span class="lineNum">     984 </span><span class="lineNoCov">          0 :            SCALE (s.macro_maps_used_size),</span>
<span class="lineNum">     985 </span><span class="lineNoCov">          0 :            STAT_LABEL (s.macro_maps_used_size));</span>
<span class="lineNum">     986 </span><span class="lineNoCov">          0 :   fprintf (stderr, &quot;Macro maps locations size:           %5ld%c\n&quot;,</span>
<span class="lineNum">     987 </span><span class="lineNoCov">          0 :            SCALE (s.macro_maps_locations_size),</span>
<span class="lineNum">     988 </span><span class="lineNoCov">          0 :            STAT_LABEL (s.macro_maps_locations_size));</span>
<span class="lineNum">     989 </span><span class="lineNoCov">          0 :   fprintf (stderr, &quot;Macro maps size:                     %5ld%c\n&quot;,</span>
<span class="lineNum">     990 </span><span class="lineNoCov">          0 :            SCALE (macro_maps_size),</span>
<span class="lineNum">     991 </span><span class="lineNoCov">          0 :            STAT_LABEL (macro_maps_size));</span>
<span class="lineNum">     992 </span><span class="lineNoCov">          0 :   fprintf (stderr, &quot;Duplicated maps locations size:      %5ld%c\n&quot;,</span>
<span class="lineNum">     993 </span><span class="lineNoCov">          0 :            SCALE (s.duplicated_macro_maps_locations_size),</span>
<span class="lineNum">     994 </span><span class="lineNoCov">          0 :            STAT_LABEL (s.duplicated_macro_maps_locations_size));</span>
<span class="lineNum">     995 </span><span class="lineNoCov">          0 :   fprintf (stderr, &quot;Total allocated maps size:           %5ld%c\n&quot;,</span>
<span class="lineNum">     996 </span><span class="lineNoCov">          0 :            SCALE (total_allocated_map_size),</span>
<span class="lineNum">     997 </span><span class="lineNoCov">          0 :            STAT_LABEL (total_allocated_map_size));</span>
<span class="lineNum">     998 </span><span class="lineNoCov">          0 :   fprintf (stderr, &quot;Total used maps size:                %5ld%c\n&quot;,</span>
<span class="lineNum">     999 </span><span class="lineNoCov">          0 :            SCALE (total_used_map_size),</span>
<span class="lineNum">    1000 </span><span class="lineNoCov">          0 :            STAT_LABEL (total_used_map_size));</span>
<span class="lineNum">    1001 </span><span class="lineNoCov">          0 :   fprintf (stderr, &quot;Ad-hoc table size:                   %5ld%c\n&quot;,</span>
<span class="lineNum">    1002 </span><span class="lineNoCov">          0 :            SCALE (s.adhoc_table_size),</span>
<span class="lineNum">    1003 </span><span class="lineNoCov">          0 :            STAT_LABEL (s.adhoc_table_size));</span>
<span class="lineNum">    1004 </span><span class="lineNoCov">          0 :   fprintf (stderr, &quot;Ad-hoc table entries used:           %5ld\n&quot;,</span>
<span class="lineNum">    1005 </span>            :            s.adhoc_table_entries_used);
<span class="lineNum">    1006 </span><span class="lineNoCov">          0 :   fprintf (stderr, &quot;optimized_ranges: %i\n&quot;,</span>
<span class="lineNum">    1007 </span>            :            line_table-&gt;num_optimized_ranges);
<span class="lineNum">    1008 </span><span class="lineNoCov">          0 :   fprintf (stderr, &quot;unoptimized_ranges: %i\n&quot;,</span>
<span class="lineNum">    1009 </span>            :            line_table-&gt;num_unoptimized_ranges);
<span class="lineNum">    1010 </span>            : 
<span class="lineNum">    1011 </span><span class="lineNoCov">          0 :   fprintf (stderr, &quot;\n&quot;);</span>
<span class="lineNum">    1012 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1013 </span>            : 
<span class="lineNum">    1014 </span>            : /* Get location one beyond the final location in ordinary map IDX.  */
<a name="1015"><span class="lineNum">    1015 </span>            : </a>
<span class="lineNum">    1016 </span>            : static source_location
<span class="lineNum">    1017 </span><span class="lineNoCov">          0 : get_end_location (struct line_maps *set, unsigned int idx)</span>
<span class="lineNum">    1018 </span>            : {
<span class="lineNum">    1019 </span><span class="lineNoCov">          0 :   if (idx == LINEMAPS_ORDINARY_USED (set) - 1)</span>
<span class="lineNum">    1020 </span><span class="lineNoCov">          0 :     return set-&gt;highest_location;</span>
<span class="lineNum">    1021 </span>            : 
<span class="lineNum">    1022 </span><span class="lineNoCov">          0 :   struct line_map *next_map = LINEMAPS_ORDINARY_MAP_AT (set, idx + 1);</span>
<span class="lineNum">    1023 </span><span class="lineNoCov">          0 :   return MAP_START_LOCATION (next_map);</span>
<span class="lineNum">    1024 </span>            : }
<span class="lineNum">    1025 </span>            : 
<span class="lineNum">    1026 </span>            : /* Helper function for write_digit_row.  */
<a name="1027"><span class="lineNum">    1027 </span>            : </a>
<span class="lineNum">    1028 </span>            : static void
<span class="lineNum">    1029 </span><span class="lineNoCov">          0 : write_digit (FILE *stream, int digit)</span>
<span class="lineNum">    1030 </span>            : {
<span class="lineNum">    1031 </span><span class="lineNoCov">          0 :   fputc ('0' + (digit % 10), stream);</span>
<span class="lineNum">    1032 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1033 </span>            : 
<span class="lineNum">    1034 </span>            : /* Helper function for dump_location_info.
<span class="lineNum">    1035 </span>            :    Write a row of numbers to STREAM, numbering a source line,
<span class="lineNum">    1036 </span>            :    giving the units, tens, hundreds etc of the column number.  */
<a name="1037"><span class="lineNum">    1037 </span>            : </a>
<span class="lineNum">    1038 </span>            : static void
<span class="lineNum">    1039 </span><span class="lineNoCov">          0 : write_digit_row (FILE *stream, int indent,</span>
<span class="lineNum">    1040 </span>            :                  const line_map_ordinary *map,
<span class="lineNum">    1041 </span>            :                  source_location loc, int max_col, int divisor)
<span class="lineNum">    1042 </span>            : {
<span class="lineNum">    1043 </span><span class="lineNoCov">          0 :   fprintf (stream, &quot;%*c&quot;, indent, ' ');</span>
<span class="lineNum">    1044 </span><span class="lineNoCov">          0 :   fprintf (stream, &quot;|&quot;);</span>
<span class="lineNum">    1045 </span><span class="lineNoCov">          0 :   for (int column = 1; column &lt; max_col; column++)</span>
<span class="lineNum">    1046 </span>            :     {
<span class="lineNum">    1047 </span><span class="lineNoCov">          0 :       source_location column_loc = loc + (column &lt;&lt; map-&gt;m_range_bits);</span>
<span class="lineNum">    1048 </span><span class="lineNoCov">          0 :       write_digit (stream, column_loc / divisor);</span>
<span class="lineNum">    1049 </span>            :     }
<span class="lineNum">    1050 </span><span class="lineNoCov">          0 :   fprintf (stream, &quot;\n&quot;);</span>
<span class="lineNum">    1051 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1052 </span>            : 
<span class="lineNum">    1053 </span>            : /* Write a half-closed (START) / half-open (END) interval of
<span class="lineNum">    1054 </span>            :    source_location to STREAM.  */
<a name="1055"><span class="lineNum">    1055 </span>            : </a>
<span class="lineNum">    1056 </span>            : static void
<span class="lineNum">    1057 </span><span class="lineNoCov">          0 : dump_location_range (FILE *stream,</span>
<span class="lineNum">    1058 </span>            :                      source_location start, source_location end)
<span class="lineNum">    1059 </span>            : {
<span class="lineNum">    1060 </span><span class="lineNoCov">          0 :   fprintf (stream,</span>
<span class="lineNum">    1061 </span>            :            &quot;  source_location interval: %u &lt;= loc &lt; %u\n&quot;,
<span class="lineNum">    1062 </span>            :            start, end);
<span class="lineNum">    1063 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1064 </span>            : 
<span class="lineNum">    1065 </span>            : /* Write a labelled description of a half-closed (START) / half-open (END)
<span class="lineNum">    1066 </span>            :    interval of source_location to STREAM.  */
<a name="1067"><span class="lineNum">    1067 </span>            : </a>
<span class="lineNum">    1068 </span>            : static void
<span class="lineNum">    1069 </span><span class="lineNoCov">          0 : dump_labelled_location_range (FILE *stream,</span>
<span class="lineNum">    1070 </span>            :                               const char *name,
<span class="lineNum">    1071 </span>            :                               source_location start, source_location end)
<span class="lineNum">    1072 </span>            : {
<span class="lineNum">    1073 </span><span class="lineNoCov">          0 :   fprintf (stream, &quot;%s\n&quot;, name);</span>
<span class="lineNum">    1074 </span><span class="lineNoCov">          0 :   dump_location_range (stream, start, end);</span>
<span class="lineNum">    1075 </span><span class="lineNoCov">          0 :   fprintf (stream, &quot;\n&quot;);</span>
<span class="lineNum">    1076 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1077 </span>            : 
<span class="lineNum">    1078 </span>            : /* Write a visualization of the locations in the line_table to STREAM.  */
<a name="1079"><span class="lineNum">    1079 </span>            : </a>
<span class="lineNum">    1080 </span>            : void
<span class="lineNum">    1081 </span><span class="lineNoCov">          0 : dump_location_info (FILE *stream)</span>
<span class="lineNum">    1082 </span>            : {
<span class="lineNum">    1083 </span>            :   /* Visualize the reserved locations.  */
<span class="lineNum">    1084 </span><span class="lineNoCov">          0 :   dump_labelled_location_range (stream, &quot;RESERVED LOCATIONS&quot;,</span>
<span class="lineNum">    1085 </span>            :                                 0, RESERVED_LOCATION_COUNT);
<span class="lineNum">    1086 </span>            : 
<span class="lineNum">    1087 </span>            :   /* Visualize the ordinary line_map instances, rendering the sources. */
<span class="lineNum">    1088 </span><span class="lineNoCov">          0 :   for (unsigned int idx = 0; idx &lt; LINEMAPS_ORDINARY_USED (line_table); idx++)</span>
<span class="lineNum">    1089 </span>            :     {
<span class="lineNum">    1090 </span><span class="lineNoCov">          0 :       source_location end_location = get_end_location (line_table, idx);</span>
<span class="lineNum">    1091 </span>            :       /* half-closed: doesn't include this one. */
<span class="lineNum">    1092 </span>            : 
<span class="lineNum">    1093 </span><span class="lineNoCov">          0 :       const line_map_ordinary *map</span>
<span class="lineNum">    1094 </span><span class="lineNoCov">          0 :         = LINEMAPS_ORDINARY_MAP_AT (line_table, idx);</span>
<span class="lineNum">    1095 </span><span class="lineNoCov">          0 :       fprintf (stream, &quot;ORDINARY MAP: %i\n&quot;, idx);</span>
<span class="lineNum">    1096 </span><span class="lineNoCov">          0 :       dump_location_range (stream,</span>
<span class="lineNum">    1097 </span>            :                            MAP_START_LOCATION (map), end_location);
<span class="lineNum">    1098 </span><span class="lineNoCov">          0 :       fprintf (stream, &quot;  file: %s\n&quot;, ORDINARY_MAP_FILE_NAME (map));</span>
<span class="lineNum">    1099 </span><span class="lineNoCov">          0 :       fprintf (stream, &quot;  starting at line: %i\n&quot;,</span>
<span class="lineNum">    1100 </span>            :                ORDINARY_MAP_STARTING_LINE_NUMBER (map));
<span class="lineNum">    1101 </span><span class="lineNoCov">          0 :       fprintf (stream, &quot;  column and range bits: %i\n&quot;,</span>
<span class="lineNum">    1102 </span><span class="lineNoCov">          0 :                map-&gt;m_column_and_range_bits);</span>
<span class="lineNum">    1103 </span><span class="lineNoCov">          0 :       fprintf (stream, &quot;  column bits: %i\n&quot;,</span>
<span class="lineNum">    1104 </span><span class="lineNoCov">          0 :                map-&gt;m_column_and_range_bits - map-&gt;m_range_bits);</span>
<span class="lineNum">    1105 </span><span class="lineNoCov">          0 :       fprintf (stream, &quot;  range bits: %i\n&quot;,</span>
<span class="lineNum">    1106 </span><span class="lineNoCov">          0 :                map-&gt;m_range_bits);</span>
<span class="lineNum">    1107 </span>            : 
<span class="lineNum">    1108 </span>            :       /* Render the span of source lines that this &quot;map&quot; covers.  */
<span class="lineNum">    1109 </span><span class="lineNoCov">          0 :       for (source_location loc = MAP_START_LOCATION (map);</span>
<span class="lineNum">    1110 </span><span class="lineNoCov">          0 :            loc &lt; end_location;</span>
<span class="lineNum">    1111 </span><span class="lineNoCov">          0 :            loc += (1 &lt;&lt; map-&gt;m_range_bits) )</span>
<span class="lineNum">    1112 </span>            :         {
<span class="lineNum">    1113 </span><span class="lineNoCov">          0 :           gcc_assert (pure_location_p (line_table, loc) );</span>
<span class="lineNum">    1114 </span>            : 
<span class="lineNum">    1115 </span><span class="lineNoCov">          0 :           expanded_location exploc</span>
<span class="lineNum">    1116 </span><span class="lineNoCov">          0 :             = linemap_expand_location (line_table, map, loc);</span>
<span class="lineNum">    1117 </span>            : 
<span class="lineNum">    1118 </span><span class="lineNoCov">          0 :           if (exploc.column == 0)</span>
<span class="lineNum">    1119 </span>            :             {
<span class="lineNum">    1120 </span>            :               /* Beginning of a new source line: draw the line.  */
<span class="lineNum">    1121 </span>            : 
<span class="lineNum">    1122 </span><span class="lineNoCov">          0 :               char_span line_text = location_get_source_line (exploc.file,</span>
<span class="lineNum">    1123 </span><span class="lineNoCov">          0 :                                                               exploc.line);</span>
<span class="lineNum">    1124 </span><span class="lineNoCov">          0 :               if (!line_text)</span>
<span class="lineNum">    1125 </span>            :                 break;
<span class="lineNum">    1126 </span><span class="lineNoCov">          0 :               fprintf (stream,</span>
<span class="lineNum">    1127 </span>            :                        &quot;%s:%3i|loc:%5i|%.*s\n&quot;,
<span class="lineNum">    1128 </span>            :                        exploc.file, exploc.line,
<span class="lineNum">    1129 </span>            :                        loc,
<span class="lineNum">    1130 </span><span class="lineNoCov">          0 :                        (int)line_text.length (), line_text.get_buffer ());</span>
<span class="lineNum">    1131 </span>            : 
<span class="lineNum">    1132 </span>            :               /* &quot;loc&quot; is at column 0, which means &quot;the whole line&quot;.
<span class="lineNum">    1133 </span>            :                  Render the locations *within* the line, by underlining
<span class="lineNum">    1134 </span>            :                  it, showing the source_location numeric values
<span class="lineNum">    1135 </span>            :                  at each column.  */
<span class="lineNum">    1136 </span><span class="lineNoCov">          0 :               size_t max_col = (1 &lt;&lt; map-&gt;m_column_and_range_bits) - 1;</span>
<span class="lineNum">    1137 </span><span class="lineNoCov">          0 :               if (max_col &gt; line_text.length ())</span>
<span class="lineNum">    1138 </span><span class="lineNoCov">          0 :                 max_col = line_text.length () + 1;</span>
<span class="lineNum">    1139 </span>            : 
<span class="lineNum">    1140 </span><span class="lineNoCov">          0 :               int indent = 14 + strlen (exploc.file);</span>
<span class="lineNum">    1141 </span>            : 
<span class="lineNum">    1142 </span>            :               /* Thousands.  */
<span class="lineNum">    1143 </span><span class="lineNoCov">          0 :               if (end_location &gt; 999)</span>
<span class="lineNum">    1144 </span><span class="lineNoCov">          0 :                 write_digit_row (stream, indent, map, loc, max_col, 1000);</span>
<span class="lineNum">    1145 </span>            : 
<span class="lineNum">    1146 </span>            :               /* Hundreds.  */
<span class="lineNum">    1147 </span><span class="lineNoCov">          0 :               if (end_location &gt; 99)</span>
<span class="lineNum">    1148 </span><span class="lineNoCov">          0 :                 write_digit_row (stream, indent, map, loc, max_col, 100);</span>
<span class="lineNum">    1149 </span>            : 
<span class="lineNum">    1150 </span>            :               /* Tens.  */
<span class="lineNum">    1151 </span><span class="lineNoCov">          0 :               write_digit_row (stream, indent, map, loc, max_col, 10);</span>
<span class="lineNum">    1152 </span>            : 
<span class="lineNum">    1153 </span>            :               /* Units.  */
<span class="lineNum">    1154 </span><span class="lineNoCov">          0 :               write_digit_row (stream, indent, map, loc, max_col, 1);</span>
<span class="lineNum">    1155 </span>            :             }
<span class="lineNum">    1156 </span>            :         }
<span class="lineNum">    1157 </span><span class="lineNoCov">          0 :       fprintf (stream, &quot;\n&quot;);</span>
<span class="lineNum">    1158 </span>            :     }
<span class="lineNum">    1159 </span>            : 
<span class="lineNum">    1160 </span>            :   /* Visualize unallocated values.  */
<span class="lineNum">    1161 </span><span class="lineNoCov">          0 :   dump_labelled_location_range (stream, &quot;UNALLOCATED LOCATIONS&quot;,</span>
<span class="lineNum">    1162 </span>            :                                 line_table-&gt;highest_location,
<span class="lineNum">    1163 </span>            :                                 LINEMAPS_MACRO_LOWEST_LOCATION (line_table));
<span class="lineNum">    1164 </span>            : 
<span class="lineNum">    1165 </span>            :   /* Visualize the macro line_map instances, rendering the sources. */
<span class="lineNum">    1166 </span><span class="lineNoCov">          0 :   for (unsigned int i = 0; i &lt; LINEMAPS_MACRO_USED (line_table); i++)</span>
<span class="lineNum">    1167 </span>            :     {
<span class="lineNum">    1168 </span>            :       /* Each macro map that is allocated owns source_location values
<span class="lineNum">    1169 </span>            :          that are *lower* that the one before them.
<span class="lineNum">    1170 </span>            :          Hence it's meaningful to view them either in order of ascending
<span class="lineNum">    1171 </span>            :          source locations, or in order of ascending macro map index.  */
<span class="lineNum">    1172 </span><span class="lineNoCov">          0 :       const bool ascending_source_locations = true;</span>
<span class="lineNum">    1173 </span><span class="lineNoCov">          0 :       unsigned int idx = (ascending_source_locations</span>
<span class="lineNum">    1174 </span><span class="lineNoCov">          0 :                           ? (LINEMAPS_MACRO_USED (line_table) - (i + 1))</span>
<span class="lineNum">    1175 </span><span class="lineNoCov">          0 :                           : i);</span>
<span class="lineNum">    1176 </span><span class="lineNoCov">          0 :       const line_map_macro *map = LINEMAPS_MACRO_MAP_AT (line_table, idx);</span>
<span class="lineNum">    1177 </span><span class="lineNoCov">          0 :       fprintf (stream, &quot;MACRO %i: %s (%u tokens)\n&quot;,</span>
<span class="lineNum">    1178 </span>            :                idx,
<span class="lineNum">    1179 </span>            :                linemap_map_get_macro_name (map),
<span class="lineNum">    1180 </span>            :                MACRO_MAP_NUM_MACRO_TOKENS (map));
<span class="lineNum">    1181 </span><span class="lineNoCov">          0 :       dump_location_range (stream,</span>
<span class="lineNum">    1182 </span><span class="lineNoCov">          0 :                            map-&gt;start_location,</span>
<span class="lineNum">    1183 </span><span class="lineNoCov">          0 :                            (map-&gt;start_location</span>
<span class="lineNum">    1184 </span><span class="lineNoCov">          0 :                             + MACRO_MAP_NUM_MACRO_TOKENS (map)));</span>
<span class="lineNum">    1185 </span><span class="lineNoCov">          0 :       inform (MACRO_MAP_EXPANSION_POINT_LOCATION (map),</span>
<span class="lineNum">    1186 </span>            :               &quot;expansion point is location %i&quot;,
<span class="lineNum">    1187 </span>            :               MACRO_MAP_EXPANSION_POINT_LOCATION (map));
<span class="lineNum">    1188 </span><span class="lineNoCov">          0 :       fprintf (stream, &quot;  map-&gt;start_location: %u\n&quot;,</span>
<span class="lineNum">    1189 </span><span class="lineNoCov">          0 :                map-&gt;start_location);</span>
<span class="lineNum">    1190 </span>            : 
<span class="lineNum">    1191 </span><span class="lineNoCov">          0 :       fprintf (stream, &quot;  macro_locations:\n&quot;);</span>
<span class="lineNum">    1192 </span><span class="lineNoCov">          0 :       for (unsigned int i = 0; i &lt; MACRO_MAP_NUM_MACRO_TOKENS (map); i++)</span>
<span class="lineNum">    1193 </span>            :         {
<span class="lineNum">    1194 </span><span class="lineNoCov">          0 :           source_location x = MACRO_MAP_LOCATIONS (map)[2 * i];</span>
<span class="lineNum">    1195 </span><span class="lineNoCov">          0 :           source_location y = MACRO_MAP_LOCATIONS (map)[(2 * i) + 1];</span>
<span class="lineNum">    1196 </span>            : 
<span class="lineNum">    1197 </span>            :           /* linemap_add_macro_token encodes token numbers in an expansion
<span class="lineNum">    1198 </span>            :              by putting them after MAP_START_LOCATION. */
<span class="lineNum">    1199 </span>            : 
<span class="lineNum">    1200 </span>            :           /* I'm typically seeing 4 uninitialized entries at the end of
<span class="lineNum">    1201 </span>            :              0xafafafaf.
<span class="lineNum">    1202 </span>            :              This appears to be due to macro.c:replace_args
<span class="lineNum">    1203 </span>            :              adding 2 extra args for padding tokens; presumably there may
<span class="lineNum">    1204 </span>            :              be a leading and/or trailing padding token injected,
<span class="lineNum">    1205 </span>            :              each for 2 more location slots.
<span class="lineNum">    1206 </span>            :              This would explain there being up to 4 source_locations slots
<span class="lineNum">    1207 </span>            :              that may be uninitialized.  */
<span class="lineNum">    1208 </span>            : 
<span class="lineNum">    1209 </span><span class="lineNoCov">          0 :           fprintf (stream, &quot;    %u: %u, %u\n&quot;,</span>
<span class="lineNum">    1210 </span>            :                    i,
<span class="lineNum">    1211 </span>            :                    x,
<span class="lineNum">    1212 </span>            :                    y);
<span class="lineNum">    1213 </span><span class="lineNoCov">          0 :           if (x == y)</span>
<span class="lineNum">    1214 </span>            :             {
<span class="lineNum">    1215 </span><span class="lineNoCov">          0 :               if (x &lt; MAP_START_LOCATION (map))</span>
<span class="lineNum">    1216 </span><span class="lineNoCov">          0 :                 inform (x, &quot;token %u has x-location == y-location == %u&quot;, i, x);</span>
<span class="lineNum">    1217 </span>            :               else
<span class="lineNum">    1218 </span><span class="lineNoCov">          0 :                 fprintf (stream,</span>
<span class="lineNum">    1219 </span>            :                          &quot;x-location == y-location == %u encodes token # %u\n&quot;,
<span class="lineNum">    1220 </span><span class="lineNoCov">          0 :                          x, x - MAP_START_LOCATION (map));</span>
<span class="lineNum">    1221 </span>            :                 }
<span class="lineNum">    1222 </span>            :           else
<span class="lineNum">    1223 </span>            :             {
<span class="lineNum">    1224 </span><span class="lineNoCov">          0 :               inform (x, &quot;token %u has x-location == %u&quot;, i, x);</span>
<span class="lineNum">    1225 </span><span class="lineNoCov">          0 :               inform (x, &quot;token %u has y-location == %u&quot;, i, y);</span>
<span class="lineNum">    1226 </span>            :             }
<span class="lineNum">    1227 </span>            :         }
<span class="lineNum">    1228 </span><span class="lineNoCov">          0 :       fprintf (stream, &quot;\n&quot;);</span>
<span class="lineNum">    1229 </span>            :     }
<span class="lineNum">    1230 </span>            : 
<span class="lineNum">    1231 </span>            :   /* It appears that MAX_SOURCE_LOCATION itself is never assigned to a
<span class="lineNum">    1232 </span>            :      macro map, presumably due to an off-by-one error somewhere
<span class="lineNum">    1233 </span>            :      between the logic in linemap_enter_macro and
<span class="lineNum">    1234 </span>            :      LINEMAPS_MACRO_LOWEST_LOCATION.  */
<span class="lineNum">    1235 </span><span class="lineNoCov">          0 :   dump_labelled_location_range (stream, &quot;MAX_SOURCE_LOCATION&quot;,</span>
<span class="lineNum">    1236 </span>            :                                 MAX_SOURCE_LOCATION,
<span class="lineNum">    1237 </span>            :                                 MAX_SOURCE_LOCATION + 1);
<span class="lineNum">    1238 </span>            : 
<span class="lineNum">    1239 </span>            :   /* Visualize ad-hoc values.  */
<span class="lineNum">    1240 </span><span class="lineNoCov">          0 :   dump_labelled_location_range (stream, &quot;AD-HOC LOCATIONS&quot;,</span>
<span class="lineNum">    1241 </span>            :                                 MAX_SOURCE_LOCATION + 1, UINT_MAX);
<span class="lineNum">    1242 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    1243 </span>            : 
<a name="1244"><span class="lineNum">    1244 </span>            : /* string_concat's constructor.  */</a>
<span class="lineNum">    1245 </span>            : 
<span class="lineNum">    1246 </span><span class="lineCov">     572159 : string_concat::string_concat (int num, location_t *locs)</span>
<span class="lineNum">    1247 </span><span class="lineCov">     572159 :   : m_num (num)</span>
<span class="lineNum">    1248 </span>            : {
<span class="lineNum">    1249 </span><span class="lineCov">     572159 :   m_locs = ggc_vec_alloc &lt;location_t&gt; (num);</span>
<span class="lineNum">    1250 </span><span class="lineCov">   27867219 :   for (int i = 0; i &lt; num; i++)</span>
<span class="lineNum">    1251 </span><span class="lineCov">   27295060 :     m_locs[i] = locs[i];</span>
<span class="lineNum">    1252 </span><span class="lineCov">     572159 : }</span>
<span class="lineNum">    1253 </span>            : 
<a name="1254"><span class="lineNum">    1254 </span>            : /* string_concat_db's constructor.  */</a>
<span class="lineNum">    1255 </span>            : 
<span class="lineNum">    1256 </span><span class="lineCov">     131336 : string_concat_db::string_concat_db ()</span>
<span class="lineNum">    1257 </span>            : {
<span class="lineNum">    1258 </span><span class="lineCov">     131336 :   m_table = hash_map &lt;location_hash, string_concat *&gt;::create_ggc (64);</span>
<span class="lineNum">    1259 </span><span class="lineCov">     131336 : }</span>
<span class="lineNum">    1260 </span>            : 
<span class="lineNum">    1261 </span>            : /* Record that a string concatenation occurred, covering NUM
<span class="lineNum">    1262 </span>            :    string literal tokens.  LOCS is an array of size NUM, containing the
<span class="lineNum">    1263 </span>            :    locations of the tokens.  A copy of LOCS is taken.  */
<a name="1264"><span class="lineNum">    1264 </span>            : </a>
<span class="lineNum">    1265 </span>            : void
<span class="lineNum">    1266 </span><span class="lineCov">     572159 : string_concat_db::record_string_concatenation (int num, location_t *locs)</span>
<span class="lineNum">    1267 </span>            : {
<span class="lineNum">    1268 </span><span class="lineCov">     572159 :   gcc_assert (num &gt; 1);</span>
<span class="lineNum">    1269 </span><span class="lineCov">     572159 :   gcc_assert (locs);</span>
<span class="lineNum">    1270 </span>            : 
<span class="lineNum">    1271 </span><span class="lineCov">     572159 :   location_t key_loc = get_key_loc (locs[0]);</span>
<span class="lineNum">    1272 </span>            : 
<span class="lineNum">    1273 </span><span class="lineCov">     572159 :   string_concat *concat</span>
<span class="lineNum">    1274 </span><span class="lineCov">     572159 :     = new (ggc_alloc &lt;string_concat&gt; ()) string_concat (num, locs);</span>
<span class="lineNum">    1275 </span><span class="lineCov">     572159 :   m_table-&gt;put (key_loc, concat);</span>
<span class="lineNum">    1276 </span><span class="lineCov">     572159 : }</span>
<span class="lineNum">    1277 </span>            : 
<span class="lineNum">    1278 </span>            : /* Determine if LOC was the location of the the initial token of a
<span class="lineNum">    1279 </span>            :    concatenation of string literal tokens.
<span class="lineNum">    1280 </span>            :    If so, *OUT_NUM is written to with the number of tokens, and
<span class="lineNum">    1281 </span>            :    *OUT_LOCS with the location of an array of locations of the
<span class="lineNum">    1282 </span>            :    tokens, and return true.  *OUT_LOCS is a borrowed pointer to
<span class="lineNum">    1283 </span>            :    storage owned by the string_concat_db.
<span class="lineNum">    1284 </span>            :    Otherwise, return false.  */
<a name="1285"><span class="lineNum">    1285 </span>            : </a>
<span class="lineNum">    1286 </span>            : bool
<span class="lineNum">    1287 </span><span class="lineCov">      10605 : string_concat_db::get_string_concatenation (location_t loc,</span>
<span class="lineNum">    1288 </span>            :                                             int *out_num,
<span class="lineNum">    1289 </span>            :                                             location_t **out_locs)
<span class="lineNum">    1290 </span>            : {
<span class="lineNum">    1291 </span><span class="lineCov">      10605 :   gcc_assert (out_num);</span>
<span class="lineNum">    1292 </span><span class="lineCov">      10605 :   gcc_assert (out_locs);</span>
<span class="lineNum">    1293 </span>            : 
<span class="lineNum">    1294 </span><span class="lineCov">      10605 :   location_t key_loc = get_key_loc (loc);</span>
<span class="lineNum">    1295 </span>            : 
<span class="lineNum">    1296 </span><span class="lineCov">      10605 :   string_concat **concat = m_table-&gt;get (key_loc);</span>
<span class="lineNum">    1297 </span><span class="lineCov">        882 :   if (!concat)</span>
<span class="lineNum">    1298 </span>            :     return false;
<span class="lineNum">    1299 </span>            : 
<span class="lineNum">    1300 </span><span class="lineCov">        882 :   *out_num = (*concat)-&gt;m_num;</span>
<span class="lineNum">    1301 </span><span class="lineCov">        882 :   *out_locs =(*concat)-&gt;m_locs;</span>
<span class="lineNum">    1302 </span><span class="lineCov">        882 :   return true;</span>
<span class="lineNum">    1303 </span>            : }
<span class="lineNum">    1304 </span>            : 
<span class="lineNum">    1305 </span>            : /* Internal function.  Canonicalize LOC into a form suitable for
<span class="lineNum">    1306 </span>            :    use as a key within the database, stripping away macro expansion,
<span class="lineNum">    1307 </span>            :    ad-hoc information, and range information, using the location of
<span class="lineNum">    1308 </span>            :    the start of LOC within an ordinary linemap.  */
<a name="1309"><span class="lineNum">    1309 </span>            : </a>
<span class="lineNum">    1310 </span>            : location_t
<span class="lineNum">    1311 </span><span class="lineCov">     582764 : string_concat_db::get_key_loc (location_t loc)</span>
<span class="lineNum">    1312 </span>            : {
<span class="lineNum">    1313 </span><span class="lineCov">     582764 :   loc = linemap_resolve_location (line_table, loc, LRK_SPELLING_LOCATION,</span>
<span class="lineNum">    1314 </span>            :                                   NULL);
<span class="lineNum">    1315 </span>            : 
<span class="lineNum">    1316 </span><span class="lineCov">     582764 :   loc = get_range_from_loc (line_table, loc).m_start;</span>
<span class="lineNum">    1317 </span>            : 
<span class="lineNum">    1318 </span><span class="lineCov">     582764 :   return loc;</span>
<span class="lineNum">    1319 </span>            : }
<span class="lineNum">    1320 </span>            : 
<span class="lineNum">    1321 </span>            : /* Helper class for use within get_substring_ranges_for_loc.
<span class="lineNum">    1322 </span>            :    An vec of cpp_string with responsibility for releasing all of the
<span class="lineNum">    1323 </span>            :    str-&gt;text for each str in the vector.  */
<span class="lineNum">    1324 </span>            : 
<span class="lineNum">    1325 </span>            : class auto_cpp_string_vec :  public auto_vec &lt;cpp_string&gt;
<span class="lineNum">    1326 </span>            : {
<span class="lineNum">    1327 </span>            :  public:
<span class="lineNum">    1328 </span>            :   auto_cpp_string_vec (int alloc)
<a name="1329"><span class="lineNum">    1329 </span><span class="lineCov">      21210 :     : auto_vec &lt;cpp_string&gt; (alloc) {}</span></a>
<span class="lineNum">    1330 </span>            : 
<span class="lineNum">    1331 </span><span class="lineCov">      10605 :   ~auto_cpp_string_vec ()</span>
<span class="lineNum">    1332 </span><span class="lineCov">      10605 :   {</span>
<span class="lineNum">    1333 </span>            :     /* Clean up the copies within this vec.  */
<span class="lineNum">    1334 </span><span class="lineCov">      10605 :     int i;</span>
<span class="lineNum">    1335 </span><span class="lineCov">      10605 :     cpp_string *str;</span>
<span class="lineNum">    1336 </span><span class="lineCov">      20486 :     FOR_EACH_VEC_ELT (*this, i, str)</span>
<span class="lineNum">    1337 </span><span class="lineCov">       9881 :       free (const_cast &lt;unsigned char *&gt; (str-&gt;text));</span>
<span class="lineNum">    1338 </span><span class="lineCov">      10605 :   }</span>
<span class="lineNum">    1339 </span>            : };
<span class="lineNum">    1340 </span>            : 
<span class="lineNum">    1341 </span>            : /* Attempt to populate RANGES with source location information on the
<span class="lineNum">    1342 </span>            :    individual characters within the string literal found at STRLOC.
<span class="lineNum">    1343 </span>            :    If CONCATS is non-NULL, then any string literals that the token at
<span class="lineNum">    1344 </span>            :    STRLOC  was concatenated with are also added to RANGES.
<span class="lineNum">    1345 </span>            : 
<span class="lineNum">    1346 </span>            :    Return NULL if successful, or an error message if any errors occurred (in
<span class="lineNum">    1347 </span>            :    which case RANGES may be only partially populated and should not
<span class="lineNum">    1348 </span>            :    be used).
<span class="lineNum">    1349 </span>            : 
<span class="lineNum">    1350 </span>            :    This is implemented by re-parsing the relevant source line(s).  */
<a name="1351"><span class="lineNum">    1351 </span>            : </a>
<span class="lineNum">    1352 </span>            : static const char *
<span class="lineNum">    1353 </span><span class="lineCov">      12456 : get_substring_ranges_for_loc (cpp_reader *pfile,</span>
<span class="lineNum">    1354 </span>            :                               string_concat_db *concats,
<span class="lineNum">    1355 </span>            :                               location_t strloc,
<span class="lineNum">    1356 </span>            :                               enum cpp_ttype type,
<span class="lineNum">    1357 </span>            :                               cpp_substring_ranges &amp;ranges)
<span class="lineNum">    1358 </span>            : {
<span class="lineNum">    1359 </span><span class="lineCov">      12456 :   gcc_assert (pfile);</span>
<span class="lineNum">    1360 </span>            : 
<span class="lineNum">    1361 </span><span class="lineCov">      12456 :   if (strloc == UNKNOWN_LOCATION)</span>
<span class="lineNum">    1362 </span>            :     return &quot;unknown location&quot;;
<span class="lineNum">    1363 </span>            : 
<span class="lineNum">    1364 </span>            :   /* Reparsing the strings requires accurate location information.
<span class="lineNum">    1365 </span>            :      If -ftrack-macro-expansion has been overridden from its default
<span class="lineNum">    1366 </span>            :      of 2, then we might have a location of a macro expansion point,
<span class="lineNum">    1367 </span>            :      rather than the location of the literal itself.
<span class="lineNum">    1368 </span>            :      Avoid this by requiring that we have full macro expansion tracking
<span class="lineNum">    1369 </span>            :      for substring locations to be available.  */
<span class="lineNum">    1370 </span><span class="lineCov">      12456 :   if (cpp_get_options (pfile)-&gt;track_macro_expansion != 2)</span>
<span class="lineNum">    1371 </span>            :     return &quot;track_macro_expansion != 2&quot;;
<span class="lineNum">    1372 </span>            : 
<span class="lineNum">    1373 </span>            :   /* If #line or # 44 &quot;file&quot;-style directives are present, then there's
<span class="lineNum">    1374 </span>            :      no guarantee that the line numbers we have can be used to locate
<span class="lineNum">    1375 </span>            :      the strings.  For example, we might have a .i file with # directives
<span class="lineNum">    1376 </span>            :      pointing back to lines within a .c file, but the .c file might
<span class="lineNum">    1377 </span>            :      have been edited since the .i file was created.
<span class="lineNum">    1378 </span>            :      In such a case, the safest course is to disable on-demand substring
<span class="lineNum">    1379 </span>            :      locations.  */
<span class="lineNum">    1380 </span><span class="lineCov">      10608 :   if (line_table-&gt;seen_line_directive)</span>
<span class="lineNum">    1381 </span>            :     return &quot;seen line directive&quot;;
<span class="lineNum">    1382 </span>            : 
<span class="lineNum">    1383 </span>            :   /* If string concatenation has occurred at STRLOC, get the locations
<span class="lineNum">    1384 </span>            :      of all of the literal tokens making up the compound string.
<span class="lineNum">    1385 </span>            :      Otherwise, just use STRLOC.  */
<span class="lineNum">    1386 </span><span class="lineCov">      10605 :   int num_locs = 1;</span>
<span class="lineNum">    1387 </span><span class="lineCov">      10605 :   location_t *strlocs = &amp;strloc;</span>
<span class="lineNum">    1388 </span><span class="lineCov">      10605 :   if (concats)</span>
<span class="lineNum">    1389 </span><span class="lineCov">      10605 :     concats-&gt;get_string_concatenation (strloc, &amp;num_locs, &amp;strlocs);</span>
<span class="lineNum">    1390 </span>            : 
<span class="lineNum">    1391 </span><span class="lineCov">      10605 :   auto_cpp_string_vec strs (num_locs);</span>
<span class="lineNum">    1392 </span><span class="lineCov">      31815 :   auto_vec &lt;cpp_string_location_reader&gt; loc_readers (num_locs);</span>
<span class="lineNum">    1393 </span><span class="lineCov">      20486 :   for (int i = 0; i &lt; num_locs; i++)</span>
<span class="lineNum">    1394 </span>            :     {
<span class="lineNum">    1395 </span>            :       /* Get range of strloc.  We will use it to locate the start and finish
<span class="lineNum">    1396 </span>            :          of the literal token within the line.  */
<span class="lineNum">    1397 </span><span class="lineCov">      12120 :       source_range src_range = get_range_from_loc (line_table, strlocs[i]);</span>
<span class="lineNum">    1398 </span>            : 
<span class="lineNum">    1399 </span><span class="lineCov">      16828 :       if (src_range.m_start &gt;= LINEMAPS_MACRO_LOWEST_LOCATION (line_table))</span>
<span class="lineNum">    1400 </span>            :         /* If the string is within a macro expansion, we can't get at the
<span class="lineNum">    1401 </span>            :            end location.  */
<span class="lineNum">    1402 </span><span class="lineCov">       2239 :         return &quot;macro expansion&quot;;</span>
<span class="lineNum">    1403 </span>            : 
<span class="lineNum">    1404 </span><span class="lineCov">      11322 :       if (src_range.m_start &gt;= LINE_MAP_MAX_LOCATION_WITH_COLS)</span>
<span class="lineNum">    1405 </span>            :         /* If so, we can't reliably determine where the token started within
<span class="lineNum">    1406 </span>            :            its line.  */
<span class="lineNum">    1407 </span>            :         return &quot;range starts after LINE_MAP_MAX_LOCATION_WITH_COLS&quot;;
<span class="lineNum">    1408 </span>            : 
<span class="lineNum">    1409 </span><span class="lineCov">       9904 :       if (src_range.m_finish &gt;= LINE_MAP_MAX_LOCATION_WITH_COLS)</span>
<span class="lineNum">    1410 </span>            :         /* If so, we can't reliably determine where the token finished within
<span class="lineNum">    1411 </span>            :            its line.  */
<span class="lineNum">    1412 </span>            :         return &quot;range ends after LINE_MAP_MAX_LOCATION_WITH_COLS&quot;;
<span class="lineNum">    1413 </span>            : 
<span class="lineNum">    1414 </span><span class="lineCov">       9904 :       expanded_location start</span>
<span class="lineNum">    1415 </span><span class="lineCov">       9904 :         = expand_location_to_spelling_point (src_range.m_start);</span>
<span class="lineNum">    1416 </span><span class="lineCov">       9904 :       expanded_location finish</span>
<span class="lineNum">    1417 </span><span class="lineCov">       9904 :         = expand_location_to_spelling_point (src_range.m_finish);</span>
<span class="lineNum">    1418 </span><span class="lineCov">       9904 :       if (start.file != finish.file)</span>
<span class="lineNum">    1419 </span>            :         return &quot;range endpoints are in different files&quot;;
<span class="lineNum">    1420 </span><span class="lineCov">       9904 :       if (start.line != finish.line)</span>
<span class="lineNum">    1421 </span>            :         return &quot;range endpoints are on different lines&quot;;
<span class="lineNum">    1422 </span><span class="lineCov">       9886 :       if (start.column &gt; finish.column)</span>
<span class="lineNum">    1423 </span>            :         return &quot;range endpoints are reversed&quot;;
<span class="lineNum">    1424 </span>            : 
<span class="lineNum">    1425 </span><span class="lineCov">       9886 :       char_span line = location_get_source_line (start.file, start.line);</span>
<span class="lineNum">    1426 </span><span class="lineCov">      19772 :       if (!line)</span>
<span class="lineNum">    1427 </span>            :         return &quot;unable to read source line&quot;;
<span class="lineNum">    1428 </span>            : 
<span class="lineNum">    1429 </span>            :       /* Determine the location of the literal (including quotes
<span class="lineNum">    1430 </span>            :          and leading prefix chars, such as the 'u' in a u&quot;&quot;
<span class="lineNum">    1431 </span>            :          token).  */
<span class="lineNum">    1432 </span><span class="lineCov">       9886 :       size_t literal_length = finish.column - start.column + 1;</span>
<span class="lineNum">    1433 </span>            : 
<span class="lineNum">    1434 </span>            :       /* Ensure that we don't crash if we got the wrong location.  */
<span class="lineNum">    1435 </span><span class="lineCov">      19772 :       if (line.length () &lt; (start.column - 1 + literal_length))</span>
<span class="lineNum">    1436 </span>            :         return &quot;line is not wide enough&quot;;
<span class="lineNum">    1437 </span>            : 
<span class="lineNum">    1438 </span><span class="lineCov">       9881 :       char_span literal = line.subspan (start.column - 1, literal_length);</span>
<span class="lineNum">    1439 </span>            : 
<span class="lineNum">    1440 </span><span class="lineCov">       9881 :       cpp_string from;</span>
<span class="lineNum">    1441 </span><span class="lineCov">       9881 :       from.len = literal_length;</span>
<span class="lineNum">    1442 </span>            :       /* Make a copy of the literal, to avoid having to rely on
<span class="lineNum">    1443 </span>            :          the lifetime of the copy of the line within the cache.
<span class="lineNum">    1444 </span>            :          This will be released by the auto_cpp_string_vec dtor.  */
<span class="lineNum">    1445 </span><span class="lineCov">       9881 :       from.text = (unsigned char *)literal.xstrdup ();</span>
<span class="lineNum">    1446 </span><span class="lineCov">       9881 :       strs.safe_push (from);</span>
<span class="lineNum">    1447 </span>            : 
<span class="lineNum">    1448 </span>            :       /* For very long lines, a new linemap could have started
<span class="lineNum">    1449 </span>            :          halfway through the token.
<span class="lineNum">    1450 </span>            :          Ensure that the loc_reader uses the linemap of the
<span class="lineNum">    1451 </span>            :          *end* of the token for its start location.  */
<span class="lineNum">    1452 </span><span class="lineCov">       9881 :       const line_map_ordinary *final_ord_map;</span>
<span class="lineNum">    1453 </span><span class="lineCov">       9881 :       linemap_resolve_location (line_table, src_range.m_finish,</span>
<span class="lineNum">    1454 </span>            :                                 LRK_MACRO_EXPANSION_POINT, &amp;final_ord_map);
<span class="lineNum">    1455 </span><span class="lineCov">       9881 :       location_t start_loc</span>
<span class="lineNum">    1456 </span><span class="lineCov">       9881 :         = linemap_position_for_line_and_column (line_table, final_ord_map,</span>
<span class="lineNum">    1457 </span>            :                                                 start.line, start.column);
<span class="lineNum">    1458 </span>            : 
<span class="lineNum">    1459 </span><span class="lineCov">       9881 :       cpp_string_location_reader loc_reader (start_loc, line_table);</span>
<span class="lineNum">    1460 </span><span class="lineCov">       9881 :       loc_readers.safe_push (loc_reader);</span>
<span class="lineNum">    1461 </span>            :     }
<span class="lineNum">    1462 </span>            : 
<span class="lineNum">    1463 </span>            :   /* Rerun cpp_interpret_string, or rather, a modified version of it.  */
<span class="lineNum">    1464 </span><span class="lineCov">      25098 :   const char *err = cpp_interpret_string_ranges (pfile, strs.address (),</span>
<span class="lineNum">    1465 </span>            :                                                  loc_readers.address (),
<span class="lineNum">    1466 </span>            :                                                  num_locs, &amp;ranges, type);
<span class="lineNum">    1467 </span><span class="lineCov">       8366 :   if (err)</span>
<span class="lineNum">    1468 </span><span class="lineCov">        145 :     return err;</span>
<span class="lineNum">    1469 </span>            : 
<span class="lineNum">    1470 </span>            :   /* Success: &quot;ranges&quot; should now contain information on the string.  */
<span class="lineNum">    1471 </span>            :   return NULL;
<span class="lineNum">    1472 </span>            : }
<span class="lineNum">    1473 </span>            : 
<span class="lineNum">    1474 </span>            : /* Attempt to populate *OUT_LOC with source location information on the
<span class="lineNum">    1475 </span>            :    given characters within the string literal found at STRLOC.
<span class="lineNum">    1476 </span>            :    CARET_IDX, START_IDX, and END_IDX refer to offsets within the execution
<span class="lineNum">    1477 </span>            :    character set.
<span class="lineNum">    1478 </span>            : 
<span class="lineNum">    1479 </span>            :    For example, given CARET_IDX = 4, START_IDX = 3, END_IDX  = 7
<span class="lineNum">    1480 </span>            :    and string literal &quot;012345\n789&quot;
<span class="lineNum">    1481 </span>            :    *OUT_LOC is written to with:
<span class="lineNum">    1482 </span>            :      &quot;012345\n789&quot;
<span class="lineNum">    1483 </span>            :          ~^~~~~
<span class="lineNum">    1484 </span>            : 
<span class="lineNum">    1485 </span>            :    If CONCATS is non-NULL, then any string literals that the token at
<span class="lineNum">    1486 </span>            :    STRLOC was concatenated with are also considered.
<span class="lineNum">    1487 </span>            : 
<span class="lineNum">    1488 </span>            :    This is implemented by re-parsing the relevant source line(s).
<span class="lineNum">    1489 </span>            : 
<span class="lineNum">    1490 </span>            :    Return NULL if successful, or an error message if any errors occurred.
<span class="lineNum">    1491 </span>            :    Error messages are intended for GCC developers (to help debugging) rather
<span class="lineNum">    1492 </span>            :    than for end-users.  */
<a name="1493"><span class="lineNum">    1493 </span>            : </a>
<span class="lineNum">    1494 </span>            : const char *
<span class="lineNum">    1495 </span><span class="lineCov">       6176 : get_source_location_for_substring (cpp_reader *pfile,</span>
<span class="lineNum">    1496 </span>            :                                    string_concat_db *concats,
<span class="lineNum">    1497 </span>            :                                    location_t strloc,
<span class="lineNum">    1498 </span>            :                                    enum cpp_ttype type,
<span class="lineNum">    1499 </span>            :                                    int caret_idx, int start_idx, int end_idx,
<span class="lineNum">    1500 </span>            :                                    source_location *out_loc)
<span class="lineNum">    1501 </span>            : {
<span class="lineNum">    1502 </span><span class="lineCov">       6176 :   gcc_checking_assert (caret_idx &gt;= 0);</span>
<span class="lineNum">    1503 </span><span class="lineCov">       6176 :   gcc_checking_assert (start_idx &gt;= 0);</span>
<span class="lineNum">    1504 </span><span class="lineCov">       6176 :   gcc_checking_assert (end_idx &gt;= 0);</span>
<span class="lineNum">    1505 </span><span class="lineCov">       6176 :   gcc_assert (out_loc);</span>
<span class="lineNum">    1506 </span>            : 
<span class="lineNum">    1507 </span><span class="lineCov">      12352 :   cpp_substring_ranges ranges;</span>
<span class="lineNum">    1508 </span><span class="lineCov">       6176 :   const char *err</span>
<span class="lineNum">    1509 </span><span class="lineCov">       6176 :     = get_substring_ranges_for_loc (pfile, concats, strloc, type, ranges);</span>
<span class="lineNum">    1510 </span><span class="lineCov">       6176 :   if (err)</span>
<span class="lineNum">    1511 </span>            :     return err;
<span class="lineNum">    1512 </span>            : 
<span class="lineNum">    1513 </span><span class="lineCov">       6938 :   if (caret_idx &gt;= ranges.get_num_ranges ())</span>
<span class="lineNum">    1514 </span>            :     return &quot;caret_idx out of range&quot;;
<span class="lineNum">    1515 </span><span class="lineCov">       6938 :   if (start_idx &gt;= ranges.get_num_ranges ())</span>
<span class="lineNum">    1516 </span>            :     return &quot;start_idx out of range&quot;;
<span class="lineNum">    1517 </span><span class="lineCov">       6938 :   if (end_idx &gt;= ranges.get_num_ranges ())</span>
<span class="lineNum">    1518 </span>            :     return &quot;end_idx out of range&quot;;
<span class="lineNum">    1519 </span>            : 
<span class="lineNum">    1520 </span><span class="lineCov">       3469 :   *out_loc = make_location (ranges.get_range (caret_idx).m_start,</span>
<span class="lineNum">    1521 </span><span class="lineCov">       3469 :                             ranges.get_range (start_idx).m_start,</span>
<span class="lineNum">    1522 </span><span class="lineCov">       6938 :                             ranges.get_range (end_idx).m_finish);</span>
<span class="lineNum">    1523 </span><span class="lineCov">       3469 :   return NULL;</span>
<span class="lineNum">    1524 </span>            : }
<span class="lineNum">    1525 </span>            : 
<span class="lineNum">    1526 </span>            : #if CHECKING_P
<span class="lineNum">    1527 </span>            : 
<span class="lineNum">    1528 </span>            : namespace selftest {
<span class="lineNum">    1529 </span>            : 
<span class="lineNum">    1530 </span>            : /* Selftests of location handling.  */
<span class="lineNum">    1531 </span>            : 
<span class="lineNum">    1532 </span>            : /* Attempt to populate *OUT_RANGE with source location information on the
<span class="lineNum">    1533 </span>            :    given character within the string literal found at STRLOC.
<span class="lineNum">    1534 </span>            :    CHAR_IDX refers to an offset within the execution character set.
<span class="lineNum">    1535 </span>            :    If CONCATS is non-NULL, then any string literals that the token at
<span class="lineNum">    1536 </span>            :    STRLOC was concatenated with are also considered.
<span class="lineNum">    1537 </span>            : 
<span class="lineNum">    1538 </span>            :    This is implemented by re-parsing the relevant source line(s).
<span class="lineNum">    1539 </span>            : 
<span class="lineNum">    1540 </span>            :    Return NULL if successful, or an error message if any errors occurred.
<span class="lineNum">    1541 </span>            :    Error messages are intended for GCC developers (to help debugging) rather
<span class="lineNum">    1542 </span>            :    than for end-users.  */
<a name="1543"><span class="lineNum">    1543 </span>            : </a>
<span class="lineNum">    1544 </span>            : static const char *
<span class="lineNum">    1545 </span><span class="lineCov">       5806 : get_source_range_for_char (cpp_reader *pfile,</span>
<span class="lineNum">    1546 </span>            :                            string_concat_db *concats,
<span class="lineNum">    1547 </span>            :                            location_t strloc,
<span class="lineNum">    1548 </span>            :                            enum cpp_ttype type,
<span class="lineNum">    1549 </span>            :                            int char_idx,
<span class="lineNum">    1550 </span>            :                            source_range *out_range)
<span class="lineNum">    1551 </span>            : {
<span class="lineNum">    1552 </span><span class="lineCov">       5806 :   gcc_checking_assert (char_idx &gt;= 0);</span>
<span class="lineNum">    1553 </span><span class="lineCov">       5806 :   gcc_assert (out_range);</span>
<span class="lineNum">    1554 </span>            : 
<span class="lineNum">    1555 </span><span class="lineCov">      11612 :   cpp_substring_ranges ranges;</span>
<span class="lineNum">    1556 </span><span class="lineCov">       5806 :   const char *err</span>
<span class="lineNum">    1557 </span><span class="lineCov">       5806 :     = get_substring_ranges_for_loc (pfile, concats, strloc, type, ranges);</span>
<span class="lineNum">    1558 </span><span class="lineCov">       5806 :   if (err)</span>
<span class="lineNum">    1559 </span>            :     return err;
<span class="lineNum">    1560 </span>            : 
<span class="lineNum">    1561 </span><span class="lineCov">       9064 :   if (char_idx &gt;= ranges.get_num_ranges ())</span>
<span class="lineNum">    1562 </span>            :     return &quot;char_idx out of range&quot;;
<span class="lineNum">    1563 </span>            : 
<span class="lineNum">    1564 </span><span class="lineCov">       4532 :   *out_range = ranges.get_range (char_idx);</span>
<span class="lineNum">    1565 </span><span class="lineCov">       4532 :   return NULL;</span>
<span class="lineNum">    1566 </span>            : }
<span class="lineNum">    1567 </span>            : 
<span class="lineNum">    1568 </span>            : /* As get_source_range_for_char, but write to *OUT the number
<span class="lineNum">    1569 </span>            :    of ranges that are available.  */
<a name="1570"><span class="lineNum">    1570 </span>            : </a>
<span class="lineNum">    1571 </span>            : static const char *
<span class="lineNum">    1572 </span><span class="lineCov">        316 : get_num_source_ranges_for_substring (cpp_reader *pfile,</span>
<span class="lineNum">    1573 </span>            :                                      string_concat_db *concats,
<span class="lineNum">    1574 </span>            :                                      location_t strloc,
<span class="lineNum">    1575 </span>            :                                      enum cpp_ttype type,
<span class="lineNum">    1576 </span>            :                                      int *out)
<span class="lineNum">    1577 </span>            : {
<span class="lineNum">    1578 </span><span class="lineCov">        316 :   gcc_assert (out);</span>
<span class="lineNum">    1579 </span>            : 
<span class="lineNum">    1580 </span><span class="lineCov">        632 :   cpp_substring_ranges ranges;</span>
<span class="lineNum">    1581 </span><span class="lineCov">        316 :   const char *err</span>
<span class="lineNum">    1582 </span><span class="lineCov">        316 :     = get_substring_ranges_for_loc (pfile, concats, strloc, type, ranges);</span>
<span class="lineNum">    1583 </span>            : 
<span class="lineNum">    1584 </span><span class="lineCov">        316 :   if (err)</span>
<span class="lineNum">    1585 </span>            :     return err;
<span class="lineNum">    1586 </span>            : 
<span class="lineNum">    1587 </span><span class="lineCov">        220 :   *out = ranges.get_num_ranges ();</span>
<span class="lineNum">    1588 </span><span class="lineCov">        220 :   return NULL;</span>
<span class="lineNum">    1589 </span>            : }
<span class="lineNum">    1590 </span>            : 
<span class="lineNum">    1591 </span>            : /* Selftests of location handling.  */
<span class="lineNum">    1592 </span>            : 
<span class="lineNum">    1593 </span>            : /* Verify that compare() on linenum_type handles comparisons over the full
<span class="lineNum">    1594 </span>            :    range of the type.  */
<a name="1595"><span class="lineNum">    1595 </span>            : </a>
<span class="lineNum">    1596 </span>            : static void
<span class="lineNum">    1597 </span><span class="lineCov">          1 : test_linenum_comparisons ()</span>
<span class="lineNum">    1598 </span>            : {
<span class="lineNum">    1599 </span><span class="lineCov">          1 :   linenum_type min_line (0);</span>
<span class="lineNum">    1600 </span><span class="lineCov">          1 :   linenum_type max_line (0xffffffff);</span>
<span class="lineNum">    1601 </span><span class="lineCov">          3 :   ASSERT_EQ (0, compare (min_line, min_line));</span>
<span class="lineNum">    1602 </span><span class="lineCov">          3 :   ASSERT_EQ (0, compare (max_line, max_line));</span>
<span class="lineNum">    1603 </span>            : 
<span class="lineNum">    1604 </span><span class="lineCov">          3 :   ASSERT_GT (compare (max_line, min_line), 0);</span>
<span class="lineNum">    1605 </span><span class="lineCov">          3 :   ASSERT_LT (compare (min_line, max_line), 0);</span>
<span class="lineNum">    1606 </span><span class="lineCov">          1 : }</span>
<span class="lineNum">    1607 </span>            : 
<span class="lineNum">    1608 </span>            : /* Helper function for verifying location data: when location_t
<span class="lineNum">    1609 </span>            :    values are &gt; LINE_MAP_MAX_LOCATION_WITH_COLS, they are treated
<span class="lineNum">    1610 </span>            :    as having column 0.  */
<a name="1611"><span class="lineNum">    1611 </span>            : </a>
<span class="lineNum">    1612 </span>            : static bool
<span class="lineNum">    1613 </span><span class="lineNoCov">          0 : should_have_column_data_p (location_t loc)</span>
<span class="lineNum">    1614 </span>            : {
<span class="lineNum">    1615 </span><span class="lineCov">      15887 :   if (IS_ADHOC_LOC (loc))</span>
<span class="lineNum">    1616 </span><span class="lineCov">       4911 :     loc = get_location_from_adhoc_loc (line_table, loc);</span>
<span class="lineNum">    1617 </span><span class="lineCov">      15887 :   if (loc &gt; LINE_MAP_MAX_LOCATION_WITH_COLS)</span>
<span class="lineNum">    1618 </span><span class="lineNoCov">          0 :     return false;</span>
<span class="lineNum">    1619 </span>            :   return true;
<span class="lineNum">    1620 </span>            : }
<span class="lineNum">    1621 </span>            : 
<span class="lineNum">    1622 </span>            : /* Selftest for should_have_column_data_p.  */
<a name="1623"><span class="lineNum">    1623 </span>            : </a>
<span class="lineNum">    1624 </span>            : static void
<span class="lineNum">    1625 </span><span class="lineCov">          1 : test_should_have_column_data_p ()</span>
<span class="lineNum">    1626 </span>            : {
<span class="lineNum">    1627 </span><span class="lineCov">          3 :   ASSERT_TRUE (should_have_column_data_p (RESERVED_LOCATION_COUNT));</span>
<span class="lineNum">    1628 </span><span class="lineCov">          3 :   ASSERT_TRUE</span>
<span class="lineNum">    1629 </span>            :     (should_have_column_data_p (LINE_MAP_MAX_LOCATION_WITH_COLS));
<span class="lineNum">    1630 </span><span class="lineCov">          3 :   ASSERT_FALSE</span>
<span class="lineNum">    1631 </span>            :     (should_have_column_data_p (LINE_MAP_MAX_LOCATION_WITH_COLS + 1));
<span class="lineNum">    1632 </span><span class="lineCov">          1 : }</span>
<span class="lineNum">    1633 </span>            : 
<span class="lineNum">    1634 </span>            : /* Verify the result of LOCATION_FILE/LOCATION_LINE/LOCATION_COLUMN
<span class="lineNum">    1635 </span>            :    on LOC.  */
<a name="1636"><span class="lineNum">    1636 </span>            : </a>
<span class="lineNum">    1637 </span>            : static void
<span class="lineNum">    1638 </span><span class="lineCov">        265 : assert_loceq (const char *exp_filename, int exp_linenum, int exp_colnum,</span>
<span class="lineNum">    1639 </span>            :               location_t loc)
<span class="lineNum">    1640 </span>            : {
<span class="lineNum">    1641 </span><span class="lineCov">        265 :   ASSERT_STREQ (exp_filename, LOCATION_FILE (loc));</span>
<span class="lineNum">    1642 </span><span class="lineCov">        265 :   ASSERT_EQ (exp_linenum, LOCATION_LINE (loc));</span>
<span class="lineNum">    1643 </span>            :   /* If location_t values are sufficiently high, then column numbers
<span class="lineNum">    1644 </span>            :      will be unavailable and LOCATION_COLUMN (loc) will be 0.
<span class="lineNum">    1645 </span>            :      When close to the threshold, column numbers *may* be present: if
<span class="lineNum">    1646 </span>            :      the final linemap before the threshold contains a line that straddles
<span class="lineNum">    1647 </span>            :      the threshold, locations in that line have column information.  */
<span class="lineNum">    1648 </span><span class="lineCov">        265 :   if (should_have_column_data_p (loc))</span>
<span class="lineNum">    1649 </span><span class="lineCov">        159 :     ASSERT_EQ (exp_colnum, LOCATION_COLUMN (loc));</span>
<span class="lineNum">    1650 </span><span class="lineCov">        265 : }</span>
<span class="lineNum">    1651 </span>            : 
<span class="lineNum">    1652 </span>            : /* Various selftests involve constructing a line table and one or more
<span class="lineNum">    1653 </span>            :    line maps within it.
<span class="lineNum">    1654 </span>            : 
<span class="lineNum">    1655 </span>            :    For maximum test coverage we want to run these tests with a variety
<span class="lineNum">    1656 </span>            :    of situations:
<span class="lineNum">    1657 </span>            :    - line_table-&gt;default_range_bits: some frontends use a non-zero value
<span class="lineNum">    1658 </span>            :    and others use zero
<span class="lineNum">    1659 </span>            :    - the fallback modes within line-map.c: there are various threshold
<span class="lineNum">    1660 </span>            :    values for source_location/location_t beyond line-map.c changes
<span class="lineNum">    1661 </span>            :    behavior (disabling of the range-packing optimization, disabling
<span class="lineNum">    1662 </span>            :    of column-tracking).  We can exercise these by starting the line_table
<span class="lineNum">    1663 </span>            :    at interesting values at or near these thresholds.
<span class="lineNum">    1664 </span>            : 
<span class="lineNum">    1665 </span>            :    The following struct describes a particular case within our test
<span class="lineNum">    1666 </span>            :    matrix.  */
<span class="lineNum">    1667 </span>            : 
<span class="lineNum">    1668 </span>            : struct line_table_case
<span class="lineNum">    1669 </span>            : {
<span class="lineNum">    1670 </span>            :   line_table_case (int default_range_bits, int base_location)
<span class="lineNum">    1671 </span><span class="lineCov">       1248 :   : m_default_range_bits (default_range_bits),</span>
<span class="lineNum">    1672 </span><span class="lineCov">       1248 :     m_base_location (base_location)</span>
<span class="lineNum">    1673 </span>            :   {}
<span class="lineNum">    1674 </span>            : 
<span class="lineNum">    1675 </span>            :   int m_default_range_bits;
<span class="lineNum">    1676 </span>            :   int m_base_location;
<span class="lineNum">    1677 </span>            : };
<span class="lineNum">    1678 </span>            : 
<span class="lineNum">    1679 </span>            : /* Constructor.  Store the old value of line_table, and create a new
<a name="1680"><span class="lineNum">    1680 </span>            :    one, using sane defaults.  */</a>
<span class="lineNum">    1681 </span>            : 
<span class="lineNum">    1682 </span><span class="lineCov">          3 : line_table_test::line_table_test ()</span>
<span class="lineNum">    1683 </span>            : {
<span class="lineNum">    1684 </span><span class="lineCov">          3 :   gcc_assert (saved_line_table == NULL);</span>
<span class="lineNum">    1685 </span><span class="lineCov">          3 :   saved_line_table = line_table;</span>
<span class="lineNum">    1686 </span><span class="lineCov">          3 :   line_table = ggc_alloc&lt;line_maps&gt; ();</span>
<span class="lineNum">    1687 </span><span class="lineCov">          3 :   linemap_init (line_table, BUILTINS_LOCATION);</span>
<span class="lineNum">    1688 </span><span class="lineCov">          3 :   gcc_assert (saved_line_table-&gt;reallocator);</span>
<span class="lineNum">    1689 </span><span class="lineCov">          3 :   line_table-&gt;reallocator = saved_line_table-&gt;reallocator;</span>
<span class="lineNum">    1690 </span><span class="lineCov">          3 :   gcc_assert (saved_line_table-&gt;round_alloc_size);</span>
<span class="lineNum">    1691 </span><span class="lineCov">          3 :   line_table-&gt;round_alloc_size = saved_line_table-&gt;round_alloc_size;</span>
<span class="lineNum">    1692 </span><span class="lineCov">          3 :   line_table-&gt;default_range_bits = 0;</span>
<span class="lineNum">    1693 </span><span class="lineCov">          3 : }</span>
<span class="lineNum">    1694 </span>            : 
<span class="lineNum">    1695 </span>            : /* Constructor.  Store the old value of line_table, and create a new
<a name="1696"><span class="lineNum">    1696 </span>            :    one, using the sitation described in CASE_.  */</a>
<span class="lineNum">    1697 </span>            : 
<span class="lineNum">    1698 </span><span class="lineCov">       1464 : line_table_test::line_table_test (const line_table_case &amp;case_)</span>
<span class="lineNum">    1699 </span>            : {
<span class="lineNum">    1700 </span><span class="lineCov">       1464 :   gcc_assert (saved_line_table == NULL);</span>
<span class="lineNum">    1701 </span><span class="lineCov">       1464 :   saved_line_table = line_table;</span>
<span class="lineNum">    1702 </span><span class="lineCov">       1464 :   line_table = ggc_alloc&lt;line_maps&gt; ();</span>
<span class="lineNum">    1703 </span><span class="lineCov">       1464 :   linemap_init (line_table, BUILTINS_LOCATION);</span>
<span class="lineNum">    1704 </span><span class="lineCov">       1464 :   gcc_assert (saved_line_table-&gt;reallocator);</span>
<span class="lineNum">    1705 </span><span class="lineCov">       1464 :   line_table-&gt;reallocator = saved_line_table-&gt;reallocator;</span>
<span class="lineNum">    1706 </span><span class="lineCov">       1464 :   gcc_assert (saved_line_table-&gt;round_alloc_size);</span>
<span class="lineNum">    1707 </span><span class="lineCov">       1464 :   line_table-&gt;round_alloc_size = saved_line_table-&gt;round_alloc_size;</span>
<span class="lineNum">    1708 </span><span class="lineCov">       1464 :   line_table-&gt;default_range_bits = case_.m_default_range_bits;</span>
<span class="lineNum">    1709 </span><span class="lineCov">       1464 :   if (case_.m_base_location)</span>
<span class="lineNum">    1710 </span>            :     {
<span class="lineNum">    1711 </span><span class="lineCov">       1342 :       line_table-&gt;highest_location = case_.m_base_location;</span>
<span class="lineNum">    1712 </span><span class="lineCov">       1342 :       line_table-&gt;highest_line = case_.m_base_location;</span>
<span class="lineNum">    1713 </span>            :     }
<span class="lineNum">    1714 </span><span class="lineCov">       1464 : }</span>
<span class="lineNum">    1715 </span>            : 
<a name="1716"><span class="lineNum">    1716 </span>            : /* Destructor.  Restore the old value of line_table.  */</a>
<span class="lineNum">    1717 </span>            : 
<span class="lineNum">    1718 </span><span class="lineCov">       1467 : line_table_test::~line_table_test ()</span>
<span class="lineNum">    1719 </span>            : {
<span class="lineNum">    1720 </span><span class="lineCov">       1467 :   gcc_assert (saved_line_table != NULL);</span>
<span class="lineNum">    1721 </span><span class="lineCov">       1467 :   line_table = saved_line_table;</span>
<span class="lineNum">    1722 </span><span class="lineCov">       1467 :   saved_line_table = NULL;</span>
<span class="lineNum">    1723 </span><span class="lineCov">       1467 : }</span>
<span class="lineNum">    1724 </span>            : 
<span class="lineNum">    1725 </span>            : /* Verify basic operation of ordinary linemaps.  */
<a name="1726"><span class="lineNum">    1726 </span>            : </a>
<span class="lineNum">    1727 </span>            : static void
<span class="lineNum">    1728 </span><span class="lineCov">         24 : test_accessing_ordinary_linemaps (const line_table_case &amp;case_)</span>
<span class="lineNum">    1729 </span>            : {
<span class="lineNum">    1730 </span><span class="lineCov">         24 :   line_table_test ltt (case_);</span>
<span class="lineNum">    1731 </span>            : 
<span class="lineNum">    1732 </span>            :   /* Build a simple linemap describing some locations. */
<span class="lineNum">    1733 </span><span class="lineCov">         24 :   linemap_add (line_table, LC_ENTER, false, &quot;foo.c&quot;, 0);</span>
<span class="lineNum">    1734 </span>            : 
<span class="lineNum">    1735 </span><span class="lineCov">         24 :   linemap_line_start (line_table, 1, 100);</span>
<span class="lineNum">    1736 </span><span class="lineCov">         24 :   location_t loc_a = linemap_position_for_column (line_table, 1);</span>
<span class="lineNum">    1737 </span><span class="lineCov">         24 :   location_t loc_b = linemap_position_for_column (line_table, 23);</span>
<span class="lineNum">    1738 </span>            : 
<span class="lineNum">    1739 </span><span class="lineCov">         24 :   linemap_line_start (line_table, 2, 100);</span>
<span class="lineNum">    1740 </span><span class="lineCov">         24 :   location_t loc_c = linemap_position_for_column (line_table, 1);</span>
<span class="lineNum">    1741 </span><span class="lineCov">         24 :   location_t loc_d = linemap_position_for_column (line_table, 17);</span>
<span class="lineNum">    1742 </span>            : 
<span class="lineNum">    1743 </span>            :   /* Example of a very long line.  */
<span class="lineNum">    1744 </span><span class="lineCov">         24 :   linemap_line_start (line_table, 3, 2000);</span>
<span class="lineNum">    1745 </span><span class="lineCov">         24 :   location_t loc_e = linemap_position_for_column (line_table, 700);</span>
<span class="lineNum">    1746 </span>            : 
<span class="lineNum">    1747 </span>            :   /* Transitioning back to a short line.  */
<span class="lineNum">    1748 </span><span class="lineCov">         24 :   linemap_line_start (line_table, 4, 0);</span>
<span class="lineNum">    1749 </span><span class="lineCov">         24 :   location_t loc_back_to_short = linemap_position_for_column (line_table, 100);</span>
<span class="lineNum">    1750 </span>            : 
<span class="lineNum">    1751 </span><span class="lineCov">         24 :   if (should_have_column_data_p (loc_back_to_short))</span>
<span class="lineNum">    1752 </span>            :     {
<span class="lineNum">    1753 </span>            :       /* Verify that we switched to short lines in the linemap.  */
<span class="lineNum">    1754 </span><span class="lineCov">         14 :       line_map_ordinary *map = LINEMAPS_LAST_ORDINARY_MAP (line_table);</span>
<span class="lineNum">    1755 </span><span class="lineCov">         14 :       ASSERT_EQ (7, map-&gt;m_column_and_range_bits - map-&gt;m_range_bits);</span>
<span class="lineNum">    1756 </span>            :     }
<span class="lineNum">    1757 </span>            : 
<span class="lineNum">    1758 </span>            :   /* Example of a line that will eventually be seen to be longer
<span class="lineNum">    1759 </span>            :      than LINE_MAP_MAX_COLUMN_NUMBER; the initially seen width is
<span class="lineNum">    1760 </span>            :      below that.  */
<span class="lineNum">    1761 </span><span class="lineCov">         24 :   linemap_line_start (line_table, 5, 2000);</span>
<span class="lineNum">    1762 </span>            : 
<span class="lineNum">    1763 </span><span class="lineCov">         24 :   location_t loc_start_of_very_long_line</span>
<span class="lineNum">    1764 </span><span class="lineCov">         24 :     = linemap_position_for_column (line_table, 2000);</span>
<span class="lineNum">    1765 </span><span class="lineCov">         24 :   location_t loc_too_wide</span>
<span class="lineNum">    1766 </span><span class="lineCov">         24 :     = linemap_position_for_column (line_table, 4097);</span>
<span class="lineNum">    1767 </span><span class="lineCov">         24 :   location_t loc_too_wide_2</span>
<span class="lineNum">    1768 </span><span class="lineCov">         24 :     = linemap_position_for_column (line_table, 4098);</span>
<span class="lineNum">    1769 </span>            : 
<span class="lineNum">    1770 </span>            :   /* ...and back to a sane line length.  */
<span class="lineNum">    1771 </span><span class="lineCov">         24 :   linemap_line_start (line_table, 6, 100);</span>
<span class="lineNum">    1772 </span><span class="lineCov">         24 :   location_t loc_sane_again = linemap_position_for_column (line_table, 10);</span>
<span class="lineNum">    1773 </span>            : 
<span class="lineNum">    1774 </span><span class="lineCov">         24 :   linemap_add (line_table, LC_LEAVE, false, NULL, 0);</span>
<span class="lineNum">    1775 </span>            : 
<span class="lineNum">    1776 </span>            :   /* Multiple files.  */
<span class="lineNum">    1777 </span><span class="lineCov">         24 :   linemap_add (line_table, LC_ENTER, false, &quot;bar.c&quot;, 0);</span>
<span class="lineNum">    1778 </span><span class="lineCov">         24 :   linemap_line_start (line_table, 1, 200);</span>
<span class="lineNum">    1779 </span><span class="lineCov">         24 :   location_t loc_f = linemap_position_for_column (line_table, 150);</span>
<span class="lineNum">    1780 </span><span class="lineCov">         24 :   linemap_add (line_table, LC_LEAVE, false, NULL, 0);</span>
<span class="lineNum">    1781 </span>            : 
<span class="lineNum">    1782 </span>            :   /* Verify that we can recover the location info.  */
<span class="lineNum">    1783 </span><span class="lineCov">         24 :   assert_loceq (&quot;foo.c&quot;, 1, 1, loc_a);</span>
<span class="lineNum">    1784 </span><span class="lineCov">         24 :   assert_loceq (&quot;foo.c&quot;, 1, 23, loc_b);</span>
<span class="lineNum">    1785 </span><span class="lineCov">         24 :   assert_loceq (&quot;foo.c&quot;, 2, 1, loc_c);</span>
<span class="lineNum">    1786 </span><span class="lineCov">         24 :   assert_loceq (&quot;foo.c&quot;, 2, 17, loc_d);</span>
<span class="lineNum">    1787 </span><span class="lineCov">         24 :   assert_loceq (&quot;foo.c&quot;, 3, 700, loc_e);</span>
<span class="lineNum">    1788 </span><span class="lineCov">         24 :   assert_loceq (&quot;foo.c&quot;, 4, 100, loc_back_to_short);</span>
<span class="lineNum">    1789 </span>            : 
<span class="lineNum">    1790 </span>            :   /* In the very wide line, the initial location should be fully tracked.  */
<span class="lineNum">    1791 </span><span class="lineCov">         24 :   assert_loceq (&quot;foo.c&quot;, 5, 2000, loc_start_of_very_long_line);</span>
<span class="lineNum">    1792 </span>            :   /* ...but once we exceed LINE_MAP_MAX_COLUMN_NUMBER column-tracking should
<span class="lineNum">    1793 </span>            :      be disabled.  */
<span class="lineNum">    1794 </span><span class="lineCov">         24 :   assert_loceq (&quot;foo.c&quot;, 5, 0, loc_too_wide);</span>
<span class="lineNum">    1795 </span><span class="lineCov">         24 :   assert_loceq (&quot;foo.c&quot;, 5, 0, loc_too_wide_2);</span>
<span class="lineNum">    1796 </span>            :   /*...and column-tracking should be re-enabled for subsequent lines.  */
<span class="lineNum">    1797 </span><span class="lineCov">         24 :   assert_loceq (&quot;foo.c&quot;, 6, 10, loc_sane_again);</span>
<span class="lineNum">    1798 </span>            : 
<span class="lineNum">    1799 </span><span class="lineCov">         24 :   assert_loceq (&quot;bar.c&quot;, 1, 150, loc_f);</span>
<span class="lineNum">    1800 </span>            : 
<span class="lineNum">    1801 </span><span class="lineCov">         24 :   ASSERT_FALSE (is_location_from_builtin_token (loc_a));</span>
<span class="lineNum">    1802 </span><span class="lineCov">         24 :   ASSERT_TRUE (pure_location_p (line_table, loc_a));</span>
<span class="lineNum">    1803 </span>            : 
<span class="lineNum">    1804 </span>            :   /* Verify using make_location to build a range, and extracting data
<span class="lineNum">    1805 </span>            :      back from it.  */
<span class="lineNum">    1806 </span><span class="lineCov">         24 :   location_t range_c_b_d = make_location (loc_c, loc_b, loc_d);</span>
<span class="lineNum">    1807 </span><span class="lineCov">         24 :   ASSERT_FALSE (pure_location_p (line_table, range_c_b_d));</span>
<span class="lineNum">    1808 </span><span class="lineCov">         24 :   ASSERT_EQ (loc_c, get_location_from_adhoc_loc (line_table, range_c_b_d));</span>
<span class="lineNum">    1809 </span><span class="lineCov">         24 :   source_range src_range = get_range_from_loc (line_table, range_c_b_d);</span>
<span class="lineNum">    1810 </span><span class="lineCov">         24 :   ASSERT_EQ (loc_b, src_range.m_start);</span>
<span class="lineNum">    1811 </span><span class="lineCov">         24 :   ASSERT_EQ (loc_d, src_range.m_finish);</span>
<span class="lineNum">    1812 </span><span class="lineCov">         24 : }</span>
<span class="lineNum">    1813 </span>            : 
<span class="lineNum">    1814 </span>            : /* Verify various properties of UNKNOWN_LOCATION.  */
<a name="1815"><span class="lineNum">    1815 </span>            : </a>
<span class="lineNum">    1816 </span>            : static void
<span class="lineNum">    1817 </span><span class="lineCov">          1 : test_unknown_location ()</span>
<span class="lineNum">    1818 </span>            : {
<span class="lineNum">    1819 </span><span class="lineCov">          1 :   ASSERT_EQ (NULL, LOCATION_FILE (UNKNOWN_LOCATION));</span>
<span class="lineNum">    1820 </span><span class="lineCov">          1 :   ASSERT_EQ (0, LOCATION_LINE (UNKNOWN_LOCATION));</span>
<span class="lineNum">    1821 </span><span class="lineCov">          1 :   ASSERT_EQ (0, LOCATION_COLUMN (UNKNOWN_LOCATION));</span>
<span class="lineNum">    1822 </span><span class="lineCov">          1 : }</span>
<span class="lineNum">    1823 </span>            : 
<span class="lineNum">    1824 </span>            : /* Verify various properties of BUILTINS_LOCATION.  */
<a name="1825"><span class="lineNum">    1825 </span>            : </a>
<span class="lineNum">    1826 </span>            : static void
<span class="lineNum">    1827 </span><span class="lineCov">          1 : test_builtins ()</span>
<span class="lineNum">    1828 </span>            : {
<span class="lineNum">    1829 </span><span class="lineCov">          1 :   assert_loceq (_(&quot;&lt;built-in&gt;&quot;), 0, 0, BUILTINS_LOCATION);</span>
<span class="lineNum">    1830 </span><span class="lineCov">          1 :   ASSERT_PRED1 (is_location_from_builtin_token, BUILTINS_LOCATION);</span>
<span class="lineNum">    1831 </span><span class="lineCov">          1 : }</span>
<span class="lineNum">    1832 </span>            : 
<span class="lineNum">    1833 </span>            : /* Regression test for make_location.
<span class="lineNum">    1834 </span>            :    Ensure that we use pure locations for the start/finish of the range,
<span class="lineNum">    1835 </span>            :    rather than storing a packed or ad-hoc range as the start/finish.  */
<a name="1836"><span class="lineNum">    1836 </span>            : </a>
<span class="lineNum">    1837 </span>            : static void
<span class="lineNum">    1838 </span><span class="lineCov">         24 : test_make_location_nonpure_range_endpoints (const line_table_case &amp;case_)</span>
<span class="lineNum">    1839 </span>            : {
<span class="lineNum">    1840 </span>            :   /* Issue seen with testsuite/c-c++-common/Wlogical-not-parentheses-2.c
<span class="lineNum">    1841 </span>            :      with C++ frontend.
<span class="lineNum">    1842 </span>            :      ....................0000000001111111111222.
<span class="lineNum">    1843 </span>            :      ....................1234567890123456789012.  */
<span class="lineNum">    1844 </span><span class="lineCov">         24 :   const char *content = &quot;     r += !aaa == bbb;\n&quot;;</span>
<span class="lineNum">    1845 </span><span class="lineCov">         64 :   temp_source_file tmp (SELFTEST_LOCATION, &quot;.C&quot;, content);</span>
<span class="lineNum">    1846 </span><span class="lineCov">         40 :   line_table_test ltt (case_);</span>
<span class="lineNum">    1847 </span><span class="lineCov">         48 :   linemap_add (line_table, LC_ENTER, false, tmp.get_filename (), 1);</span>
<span class="lineNum">    1848 </span>            : 
<span class="lineNum">    1849 </span><span class="lineCov">         24 :   const location_t c11 = linemap_position_for_column (line_table, 11);</span>
<span class="lineNum">    1850 </span><span class="lineCov">         24 :   const location_t c12 = linemap_position_for_column (line_table, 12);</span>
<span class="lineNum">    1851 </span><span class="lineCov">         24 :   const location_t c13 = linemap_position_for_column (line_table, 13);</span>
<span class="lineNum">    1852 </span><span class="lineCov">         24 :   const location_t c14 = linemap_position_for_column (line_table, 14);</span>
<span class="lineNum">    1853 </span><span class="lineCov">         24 :   const location_t c21 = linemap_position_for_column (line_table, 21);</span>
<span class="lineNum">    1854 </span>            : 
<span class="lineNum">    1855 </span><span class="lineCov">         24 :   if (c21 &gt; LINE_MAP_MAX_LOCATION_WITH_COLS)</span>
<span class="lineNum">    1856 </span><span class="lineCov">          8 :     return;</span>
<span class="lineNum">    1857 </span>            : 
<span class="lineNum">    1858 </span>            :   /* Use column 13 for the caret location, arbitrarily, to verify that we
<span class="lineNum">    1859 </span>            :      handle start != caret.  */
<span class="lineNum">    1860 </span><span class="lineCov">         16 :   const location_t aaa = make_location (c13, c12, c14);</span>
<span class="lineNum">    1861 </span><span class="lineCov">         16 :   ASSERT_EQ (c13, get_pure_location (aaa));</span>
<span class="lineNum">    1862 </span><span class="lineCov">         16 :   ASSERT_EQ (c12, get_start (aaa));</span>
<span class="lineNum">    1863 </span><span class="lineCov">         16 :   ASSERT_FALSE (IS_ADHOC_LOC (get_start (aaa)));</span>
<span class="lineNum">    1864 </span><span class="lineCov">         16 :   ASSERT_EQ (c14, get_finish (aaa));</span>
<span class="lineNum">    1865 </span><span class="lineCov">         16 :   ASSERT_FALSE (IS_ADHOC_LOC (get_finish (aaa)));</span>
<span class="lineNum">    1866 </span>            : 
<span class="lineNum">    1867 </span>            :   /* Make a location using a location with a range as the start-point.  */
<span class="lineNum">    1868 </span><span class="lineCov">         16 :   const location_t not_aaa = make_location (c11, aaa, c14);</span>
<span class="lineNum">    1869 </span><span class="lineCov">         16 :   ASSERT_EQ (c11, get_pure_location (not_aaa));</span>
<span class="lineNum">    1870 </span>            :   /* It should use the start location of the range, not store the range
<span class="lineNum">    1871 </span>            :      itself.  */
<span class="lineNum">    1872 </span><span class="lineCov">         16 :   ASSERT_EQ (c12, get_start (not_aaa));</span>
<span class="lineNum">    1873 </span><span class="lineCov">         16 :   ASSERT_FALSE (IS_ADHOC_LOC (get_start (not_aaa)));</span>
<span class="lineNum">    1874 </span><span class="lineCov">         16 :   ASSERT_EQ (c14, get_finish (not_aaa));</span>
<span class="lineNum">    1875 </span><span class="lineCov">         16 :   ASSERT_FALSE (IS_ADHOC_LOC (get_finish (not_aaa)));</span>
<span class="lineNum">    1876 </span>            : 
<span class="lineNum">    1877 </span>            :   /* Similarly, make a location with a range as the end-point.  */
<span class="lineNum">    1878 </span><span class="lineCov">         16 :   const location_t aaa_eq_bbb = make_location (c12, c12, c21);</span>
<span class="lineNum">    1879 </span><span class="lineCov">         16 :   ASSERT_EQ (c12, get_pure_location (aaa_eq_bbb));</span>
<span class="lineNum">    1880 </span><span class="lineCov">         16 :   ASSERT_EQ (c12, get_start (aaa_eq_bbb));</span>
<span class="lineNum">    1881 </span><span class="lineCov">         16 :   ASSERT_FALSE (IS_ADHOC_LOC (get_start (aaa_eq_bbb)));</span>
<span class="lineNum">    1882 </span><span class="lineCov">         16 :   ASSERT_EQ (c21, get_finish (aaa_eq_bbb));</span>
<span class="lineNum">    1883 </span><span class="lineCov">         16 :   ASSERT_FALSE (IS_ADHOC_LOC (get_finish (aaa_eq_bbb)));</span>
<span class="lineNum">    1884 </span><span class="lineCov">         16 :   const location_t not_aaa_eq_bbb = make_location (c11, c12, aaa_eq_bbb);</span>
<span class="lineNum">    1885 </span>            :   /* It should use the finish location of the range, not store the range
<span class="lineNum">    1886 </span>            :      itself.  */
<span class="lineNum">    1887 </span><span class="lineCov">         16 :   ASSERT_EQ (c11, get_pure_location (not_aaa_eq_bbb));</span>
<span class="lineNum">    1888 </span><span class="lineCov">         16 :   ASSERT_EQ (c12, get_start (not_aaa_eq_bbb));</span>
<span class="lineNum">    1889 </span><span class="lineCov">         16 :   ASSERT_FALSE (IS_ADHOC_LOC (get_start (not_aaa_eq_bbb)));</span>
<span class="lineNum">    1890 </span><span class="lineCov">         16 :   ASSERT_EQ (c21, get_finish (not_aaa_eq_bbb));</span>
<span class="lineNum">    1891 </span><span class="lineCov">         16 :   ASSERT_FALSE (IS_ADHOC_LOC (get_finish (not_aaa_eq_bbb)));</span>
<span class="lineNum">    1892 </span>            : }
<span class="lineNum">    1893 </span>            : 
<span class="lineNum">    1894 </span>            : /* Verify reading of input files (e.g. for caret-based diagnostics).  */
<a name="1895"><span class="lineNum">    1895 </span>            : </a>
<span class="lineNum">    1896 </span>            : static void
<span class="lineNum">    1897 </span><span class="lineCov">          1 : test_reading_source_line ()</span>
<span class="lineNum">    1898 </span>            : {
<span class="lineNum">    1899 </span>            :   /* Create a tempfile and write some text to it.  */
<span class="lineNum">    1900 </span><span class="lineCov">          1 :   temp_source_file tmp (SELFTEST_LOCATION, &quot;.txt&quot;,</span>
<span class="lineNum">    1901 </span>            :                         &quot;01234567890123456789\n&quot;
<span class="lineNum">    1902 </span>            :                         &quot;This is the test text\n&quot;
<span class="lineNum">    1903 </span><span class="lineCov">          1 :                         &quot;This is the 3rd line&quot;);</span>
<span class="lineNum">    1904 </span>            : 
<span class="lineNum">    1905 </span>            :   /* Read back a specific line from the tempfile.  */
<span class="lineNum">    1906 </span><span class="lineCov">          2 :   char_span source_line = location_get_source_line (tmp.get_filename (), 3);</span>
<span class="lineNum">    1907 </span><span class="lineCov">          2 :   ASSERT_TRUE (source_line);</span>
<span class="lineNum">    1908 </span><span class="lineCov">          3 :   ASSERT_TRUE (source_line.get_buffer () != NULL);</span>
<span class="lineNum">    1909 </span><span class="lineCov">          2 :   ASSERT_EQ (20, source_line.length ());</span>
<span class="lineNum">    1910 </span><span class="lineCov">          3 :   ASSERT_TRUE (!strncmp (&quot;This is the 3rd line&quot;,</span>
<span class="lineNum">    1911 </span>            :                          source_line.get_buffer (), source_line.length ()));
<span class="lineNum">    1912 </span>            : 
<span class="lineNum">    1913 </span><span class="lineCov">          2 :   source_line = location_get_source_line (tmp.get_filename (), 2);</span>
<span class="lineNum">    1914 </span><span class="lineCov">          2 :   ASSERT_TRUE (source_line);</span>
<span class="lineNum">    1915 </span><span class="lineCov">          3 :   ASSERT_TRUE (source_line.get_buffer () != NULL);</span>
<span class="lineNum">    1916 </span><span class="lineCov">          2 :   ASSERT_EQ (21, source_line.length ());</span>
<span class="lineNum">    1917 </span><span class="lineCov">          3 :   ASSERT_TRUE (!strncmp (&quot;This is the test text&quot;,</span>
<span class="lineNum">    1918 </span>            :                          source_line.get_buffer (), source_line.length ()));
<span class="lineNum">    1919 </span>            : 
<span class="lineNum">    1920 </span><span class="lineCov">          2 :   source_line = location_get_source_line (tmp.get_filename (), 4);</span>
<span class="lineNum">    1921 </span><span class="lineCov">          2 :   ASSERT_FALSE (source_line);</span>
<span class="lineNum">    1922 </span><span class="lineCov">          3 :   ASSERT_TRUE (source_line.get_buffer () == NULL);</span>
<span class="lineNum">    1923 </span><span class="lineCov">          1 : }</span>
<span class="lineNum">    1924 </span>            : 
<span class="lineNum">    1925 </span>            : /* Tests of lexing.  */
<span class="lineNum">    1926 </span>            : 
<span class="lineNum">    1927 </span>            : /* Verify that token TOK from PARSER has cpp_token_as_text
<span class="lineNum">    1928 </span>            :    equal to EXPECTED_TEXT.  */
<span class="lineNum">    1929 </span>            : 
<span class="lineNum">    1930 </span>            : #define ASSERT_TOKEN_AS_TEXT_EQ(PARSER, TOK, EXPECTED_TEXT)             \
<span class="lineNum">    1931 </span>            :   SELFTEST_BEGIN_STMT                                                   \
<span class="lineNum">    1932 </span>            :     unsigned char *actual_txt = cpp_token_as_text ((PARSER), (TOK));    \
<span class="lineNum">    1933 </span>            :     ASSERT_STREQ ((EXPECTED_TEXT), (const char *)actual_txt);           \
<span class="lineNum">    1934 </span>            :   SELFTEST_END_STMT
<span class="lineNum">    1935 </span>            : 
<span class="lineNum">    1936 </span>            : /* Verify that TOK's src_loc is within EXP_FILENAME at EXP_LINENUM,
<span class="lineNum">    1937 </span>            :    and ranges from EXP_START_COL to EXP_FINISH_COL.
<span class="lineNum">    1938 </span>            :    Use LOC as the effective location of the selftest.  */
<a name="1939"><span class="lineNum">    1939 </span>            : </a>
<span class="lineNum">    1940 </span>            : static void
<span class="lineNum">    1941 </span><span class="lineCov">        144 : assert_token_loc_eq (const location &amp;loc,</span>
<span class="lineNum">    1942 </span>            :                      const cpp_token *tok,
<span class="lineNum">    1943 </span>            :                      const char *exp_filename, int exp_linenum,
<span class="lineNum">    1944 </span>            :                      int exp_start_col, int exp_finish_col)
<span class="lineNum">    1945 </span>            : {
<span class="lineNum">    1946 </span><span class="lineCov">        144 :   location_t tok_loc = tok-&gt;src_loc;</span>
<span class="lineNum">    1947 </span><span class="lineCov">        144 :   ASSERT_STREQ_AT (loc, exp_filename, LOCATION_FILE (tok_loc));</span>
<span class="lineNum">    1948 </span><span class="lineCov">        144 :   ASSERT_EQ_AT (loc, exp_linenum, LOCATION_LINE (tok_loc));</span>
<span class="lineNum">    1949 </span>            : 
<span class="lineNum">    1950 </span>            :   /* If location_t values are sufficiently high, then column numbers
<span class="lineNum">    1951 </span>            :      will be unavailable.  */
<span class="lineNum">    1952 </span><span class="lineCov">        144 :   if (!should_have_column_data_p (tok_loc))</span>
<span class="lineNum">    1953 </span><span class="lineCov">         50 :     return;</span>
<span class="lineNum">    1954 </span>            : 
<span class="lineNum">    1955 </span><span class="lineCov">         94 :   ASSERT_EQ_AT (loc, exp_start_col, LOCATION_COLUMN (tok_loc));</span>
<span class="lineNum">    1956 </span><span class="lineCov">         94 :   source_range tok_range = get_range_from_loc (line_table, tok_loc);</span>
<span class="lineNum">    1957 </span><span class="lineCov">         94 :   ASSERT_EQ_AT (loc, exp_start_col, LOCATION_COLUMN (tok_range.m_start));</span>
<span class="lineNum">    1958 </span><span class="lineCov">         94 :   ASSERT_EQ_AT (loc, exp_finish_col, LOCATION_COLUMN (tok_range.m_finish));</span>
<span class="lineNum">    1959 </span>            : }
<span class="lineNum">    1960 </span>            : 
<span class="lineNum">    1961 </span>            : /* Use assert_token_loc_eq to verify the TOK-&gt;src_loc, using
<span class="lineNum">    1962 </span>            :    SELFTEST_LOCATION as the effective location of the selftest.  */
<span class="lineNum">    1963 </span>            : 
<span class="lineNum">    1964 </span>            : #define ASSERT_TOKEN_LOC_EQ(TOK, EXP_FILENAME, EXP_LINENUM, \
<span class="lineNum">    1965 </span>            :                             EXP_START_COL, EXP_FINISH_COL) \
<span class="lineNum">    1966 </span>            :   assert_token_loc_eq (SELFTEST_LOCATION, (TOK), (EXP_FILENAME), \
<span class="lineNum">    1967 </span>            :                        (EXP_LINENUM), (EXP_START_COL), (EXP_FINISH_COL))
<span class="lineNum">    1968 </span>            : 
<span class="lineNum">    1969 </span>            : /* Test of lexing a file using libcpp, verifying tokens and their
<span class="lineNum">    1970 </span>            :    location information.  */
<a name="1971"><span class="lineNum">    1971 </span>            : </a>
<span class="lineNum">    1972 </span>            : static void
<span class="lineNum">    1973 </span><span class="lineCov">         24 : test_lexer (const line_table_case &amp;case_)</span>
<span class="lineNum">    1974 </span>            : {
<span class="lineNum">    1975 </span>            :   /* Create a tempfile and write some text to it.  */
<span class="lineNum">    1976 </span><span class="lineCov">         24 :   const char *content =</span>
<span class="lineNum">    1977 </span>            :     /*00000000011111111112222222222333333.3333444444444.455555555556
<span class="lineNum">    1978 </span>            :       12345678901234567890123456789012345.6789012345678.901234567890.  */
<span class="lineNum">    1979 </span>            :     (&quot;test_name /* c-style comment */\n&quot;
<span class="lineNum">    1980 </span>            :      &quot;                                  \&quot;test literal\&quot;\n&quot;
<span class="lineNum">    1981 </span>            :      &quot; // test c++-style comment\n&quot;
<span class="lineNum">    1982 </span>            :      &quot;   42\n&quot;);
<span class="lineNum">    1983 </span><span class="lineCov">         48 :   temp_source_file tmp (SELFTEST_LOCATION, &quot;.txt&quot;, content);</span>
<span class="lineNum">    1984 </span>            : 
<span class="lineNum">    1985 </span><span class="lineCov">         48 :   line_table_test ltt (case_);</span>
<span class="lineNum">    1986 </span>            : 
<span class="lineNum">    1987 </span><span class="lineCov">         24 :   cpp_reader *parser = cpp_create_reader (CLK_GNUC89, NULL, line_table);</span>
<span class="lineNum">    1988 </span>            : 
<span class="lineNum">    1989 </span><span class="lineCov">         48 :   const char *fname = cpp_read_main_file (parser, tmp.get_filename ());</span>
<span class="lineNum">    1990 </span><span class="lineCov">         24 :   ASSERT_NE (fname, NULL);</span>
<span class="lineNum">    1991 </span>            : 
<span class="lineNum">    1992 </span>            :   /* Verify that we get the expected tokens back, with the correct
<span class="lineNum">    1993 </span>            :      location information.  */
<span class="lineNum">    1994 </span>            : 
<span class="lineNum">    1995 </span><span class="lineCov">         24 :   location_t loc;</span>
<span class="lineNum">    1996 </span><span class="lineCov">         24 :   const cpp_token *tok;</span>
<span class="lineNum">    1997 </span><span class="lineCov">         24 :   tok = cpp_get_token_with_location (parser, &amp;loc);</span>
<span class="lineNum">    1998 </span><span class="lineCov">         24 :   ASSERT_NE (tok, NULL);</span>
<span class="lineNum">    1999 </span><span class="lineCov">         24 :   ASSERT_EQ (tok-&gt;type, CPP_NAME);</span>
<span class="lineNum">    2000 </span><span class="lineCov">         24 :   ASSERT_TOKEN_AS_TEXT_EQ (parser, tok, &quot;test_name&quot;);</span>
<span class="lineNum">    2001 </span><span class="lineCov">         72 :   ASSERT_TOKEN_LOC_EQ (tok, tmp.get_filename (), 1, 1, 9);</span>
<span class="lineNum">    2002 </span>            : 
<span class="lineNum">    2003 </span><span class="lineCov">         24 :   tok = cpp_get_token_with_location (parser, &amp;loc);</span>
<span class="lineNum">    2004 </span><span class="lineCov">         24 :   ASSERT_NE (tok, NULL);</span>
<span class="lineNum">    2005 </span><span class="lineCov">         24 :   ASSERT_EQ (tok-&gt;type, CPP_STRING);</span>
<span class="lineNum">    2006 </span><span class="lineCov">         24 :   ASSERT_TOKEN_AS_TEXT_EQ (parser, tok, &quot;\&quot;test literal\&quot;&quot;);</span>
<span class="lineNum">    2007 </span><span class="lineCov">         72 :   ASSERT_TOKEN_LOC_EQ (tok, tmp.get_filename (), 2, 35, 48);</span>
<span class="lineNum">    2008 </span>            : 
<span class="lineNum">    2009 </span><span class="lineCov">         24 :   tok = cpp_get_token_with_location (parser, &amp;loc);</span>
<span class="lineNum">    2010 </span><span class="lineCov">         24 :   ASSERT_NE (tok, NULL);</span>
<span class="lineNum">    2011 </span><span class="lineCov">         24 :   ASSERT_EQ (tok-&gt;type, CPP_NUMBER);</span>
<span class="lineNum">    2012 </span><span class="lineCov">         24 :   ASSERT_TOKEN_AS_TEXT_EQ (parser, tok, &quot;42&quot;);</span>
<span class="lineNum">    2013 </span><span class="lineCov">         72 :   ASSERT_TOKEN_LOC_EQ (tok, tmp.get_filename (), 4, 4, 5);</span>
<span class="lineNum">    2014 </span>            : 
<span class="lineNum">    2015 </span><span class="lineCov">         24 :   tok = cpp_get_token_with_location (parser, &amp;loc);</span>
<span class="lineNum">    2016 </span><span class="lineCov">         24 :   ASSERT_NE (tok, NULL);</span>
<span class="lineNum">    2017 </span><span class="lineCov">         24 :   ASSERT_EQ (tok-&gt;type, CPP_EOF);</span>
<span class="lineNum">    2018 </span>            : 
<span class="lineNum">    2019 </span><span class="lineCov">         24 :   cpp_finish (parser, NULL);</span>
<span class="lineNum">    2020 </span><span class="lineCov">         24 :   cpp_destroy (parser);</span>
<span class="lineNum">    2021 </span><span class="lineCov">         24 : }</span>
<span class="lineNum">    2022 </span>            : 
<span class="lineNum">    2023 </span>            : /* Forward decls.  */
<span class="lineNum">    2024 </span>            : 
<span class="lineNum">    2025 </span>            : struct lexer_test;
<span class="lineNum">    2026 </span>            : class lexer_test_options;
<span class="lineNum">    2027 </span>            : 
<span class="lineNum">    2028 </span>            : /* A class for specifying options of a lexer_test.
<span class="lineNum">    2029 </span>            :    The &quot;apply&quot; vfunc is called during the lexer_test constructor.  */
<span class="lineNum">    2030 </span>            : 
<span class="lineNum">    2031 </span>            : class lexer_test_options
<span class="lineNum">    2032 </span>            : {
<span class="lineNum">    2033 </span>            :  public:
<span class="lineNum">    2034 </span>            :   virtual void apply (lexer_test &amp;) = 0;
<span class="lineNum">    2035 </span>            : };
<span class="lineNum">    2036 </span>            : 
<span class="lineNum">    2037 </span>            : /* Wrapper around an cpp_reader *, which calls cpp_finish and cpp_destroy
<span class="lineNum">    2038 </span>            :    in its dtor.
<span class="lineNum">    2039 </span>            : 
<span class="lineNum">    2040 </span>            :    This is needed by struct lexer_test to ensure that the cleanup of the
<span class="lineNum">    2041 </span>            :    cpp_reader happens *after* the cleanup of the temp_source_file.  */
<span class="lineNum">    2042 </span>            : 
<span class="lineNum">    2043 </span>            : class cpp_reader_ptr
<span class="lineNum">    2044 </span>            : {
<span class="lineNum">    2045 </span>            :  public:
<span class="lineNum">    2046 </span><span class="lineCov">        576 :   cpp_reader_ptr (cpp_reader *ptr) : m_ptr (ptr) {}</span>
<span class="lineNum">    2047 </span>            : 
<span class="lineNum">    2048 </span>            :   ~cpp_reader_ptr ()
<span class="lineNum">    2049 </span><span class="lineCov">        576 :   {</span>
<span class="lineNum">    2050 </span><span class="lineCov">        576 :     cpp_finish (m_ptr, NULL);</span>
<span class="lineNum">    2051 </span><span class="lineCov">        576 :     cpp_destroy (m_ptr);</span>
<a name="2052"><span class="lineNum">    2052 </span>            :   }</a>
<span class="lineNum">    2053 </span>            : 
<span class="lineNum">    2054 </span><span class="lineCov">      10000 :   operator cpp_reader * () const { return m_ptr; }</span>
<span class="lineNum">    2055 </span>            : 
<span class="lineNum">    2056 </span>            :  private:
<span class="lineNum">    2057 </span>            :   cpp_reader *m_ptr;
<span class="lineNum">    2058 </span>            : };
<span class="lineNum">    2059 </span>            : 
<span class="lineNum">    2060 </span>            : /* A struct for writing lexer tests.  */
<span class="lineNum">    2061 </span>            : 
<span class="lineNum">    2062 </span>            : struct lexer_test
<span class="lineNum">    2063 </span>            : {
<span class="lineNum">    2064 </span>            :   lexer_test (const line_table_case &amp;case_, const char *content,
<span class="lineNum">    2065 </span>            :               lexer_test_options *options);
<span class="lineNum">    2066 </span>            :   ~lexer_test ();
<span class="lineNum">    2067 </span>            : 
<span class="lineNum">    2068 </span>            :   const cpp_token *get_token ();
<span class="lineNum">    2069 </span>            : 
<span class="lineNum">    2070 </span>            :   /* The ordering of these fields matters.
<span class="lineNum">    2071 </span>            :      The line_table_test must be first, since the cpp_reader_ptr
<span class="lineNum">    2072 </span>            :      uses it.
<span class="lineNum">    2073 </span>            :      The cpp_reader must be cleaned up *after* the temp_source_file
<span class="lineNum">    2074 </span>            :      since the filenames in input.c's input cache are owned by the
<span class="lineNum">    2075 </span>            :      cpp_reader; in particular, when ~temp_source_file evicts the
<span class="lineNum">    2076 </span>            :      filename the filenames must still be alive.  */
<span class="lineNum">    2077 </span>            :   line_table_test m_ltt;
<span class="lineNum">    2078 </span>            :   cpp_reader_ptr m_parser;
<span class="lineNum">    2079 </span>            :   temp_source_file m_tempfile;
<span class="lineNum">    2080 </span>            :   string_concat_db m_concats;
<span class="lineNum">    2081 </span>            :   bool m_implicitly_expect_EOF;
<span class="lineNum">    2082 </span>            : };
<span class="lineNum">    2083 </span>            : 
<span class="lineNum">    2084 </span>            : /* Use an EBCDIC encoding for the execution charset, specifically
<span class="lineNum">    2085 </span>            :    IBM1047-encoded (aka &quot;EBCDIC 1047&quot;, or &quot;Code page 1047&quot;).
<span class="lineNum">    2086 </span>            : 
<span class="lineNum">    2087 </span>            :    This exercises iconv integration within libcpp.
<span class="lineNum">    2088 </span>            :    Not every build of iconv supports the given charset,
<span class="lineNum">    2089 </span>            :    so we need to flag this error and handle it gracefully.  */
<span class="lineNum">    2090 </span>            : 
<span class="lineNum">    2091 </span>            : class ebcdic_execution_charset : public lexer_test_options
<span class="lineNum">    2092 </span>            : {
<span class="lineNum">    2093 </span>            :  public:
<span class="lineNum">    2094 </span><span class="lineCov">         24 :   ebcdic_execution_charset () : m_num_iconv_errors (0)</span>
<span class="lineNum">    2095 </span>            :     {
<span class="lineNum">    2096 </span><span class="lineNoCov">          0 :       gcc_assert (s_singleton == NULL);</span>
<span class="lineNum">    2097 </span><span class="lineCov">         24 :       s_singleton = this;</span>
<span class="lineNum">    2098 </span>            :     }
<span class="lineNum">    2099 </span>            :   ~ebcdic_execution_charset ()
<span class="lineNum">    2100 </span><span class="lineCov">         24 :     {</span>
<span class="lineNum">    2101 </span><span class="lineNoCov">          0 :       gcc_assert (s_singleton == this);</span>
<span class="lineNum">    2102 </span><span class="lineCov">         24 :       s_singleton = NULL;</span>
<a name="2103"><span class="lineNum">    2103 </span>            :     }</a>
<span class="lineNum">    2104 </span>            : 
<span class="lineNum">    2105 </span><span class="lineCov">         24 :   void apply (lexer_test &amp;test) FINAL OVERRIDE</span>
<span class="lineNum">    2106 </span>            :   {
<span class="lineNum">    2107 </span><span class="lineCov">         24 :     cpp_options *cpp_opts = cpp_get_options (test.m_parser);</span>
<span class="lineNum">    2108 </span><span class="lineCov">         24 :     cpp_opts-&gt;narrow_charset = &quot;IBM1047&quot;;</span>
<span class="lineNum">    2109 </span>            : 
<span class="lineNum">    2110 </span><span class="lineCov">         24 :     cpp_callbacks *callbacks = cpp_get_callbacks (test.m_parser);</span>
<span class="lineNum">    2111 </span><span class="lineCov">         24 :     callbacks-&gt;error = on_error;</span>
<a name="2112"><span class="lineNum">    2112 </span><span class="lineCov">         24 :   }</span></a>
<span class="lineNum">    2113 </span>            : 
<span class="lineNum">    2114 </span><span class="lineNoCov">          0 :   static bool on_error (cpp_reader *pfile ATTRIBUTE_UNUSED,</span>
<span class="lineNum">    2115 </span>            :                         int level ATTRIBUTE_UNUSED,
<span class="lineNum">    2116 </span>            :                         int reason ATTRIBUTE_UNUSED,
<span class="lineNum">    2117 </span>            :                         rich_location *richloc ATTRIBUTE_UNUSED,
<span class="lineNum">    2118 </span>            :                         const char *msgid, va_list *ap ATTRIBUTE_UNUSED)
<span class="lineNum">    2119 </span>            :     ATTRIBUTE_FPTR_PRINTF(5,0)
<span class="lineNum">    2120 </span>            :   {
<span class="lineNum">    2121 </span><span class="lineNoCov">          0 :     gcc_assert (s_singleton);</span>
<span class="lineNum">    2122 </span>            :     /* Avoid exgettext from picking this up, it is translated in libcpp.  */
<span class="lineNum">    2123 </span><span class="lineNoCov">          0 :     const char *msg = &quot;conversion from %s to %s not supported by iconv&quot;;</span>
<span class="lineNum">    2124 </span>            : #ifdef ENABLE_NLS
<span class="lineNum">    2125 </span><span class="lineNoCov">          0 :     msg = dgettext (&quot;cpplib&quot;, msg);</span>
<span class="lineNum">    2126 </span>            : #endif
<span class="lineNum">    2127 </span>            :     /* Detect and record errors emitted by libcpp/charset.c:init_iconv_desc
<span class="lineNum">    2128 </span>            :        when the local iconv build doesn't support the conversion.  */
<span class="lineNum">    2129 </span><span class="lineNoCov">          0 :     if (strcmp (msgid, msg) == 0)</span>
<span class="lineNum">    2130 </span>            :       {
<span class="lineNum">    2131 </span><span class="lineNoCov">          0 :         s_singleton-&gt;m_num_iconv_errors++;</span>
<span class="lineNum">    2132 </span><span class="lineNoCov">          0 :         return true;</span>
<span class="lineNum">    2133 </span>            :       }
<span class="lineNum">    2134 </span>            : 
<span class="lineNum">    2135 </span>            :     /* Otherwise, we have an unexpected error.  */
<span class="lineNum">    2136 </span><span class="lineNoCov">          0 :     abort ();</span>
<a name="2137"><span class="lineNum">    2137 </span>            :   }</a>
<span class="lineNum">    2138 </span>            : 
<span class="lineNum">    2139 </span><span class="lineCov">         24 :   bool iconv_errors_occurred_p () const { return m_num_iconv_errors &gt; 0; }</span>
<span class="lineNum">    2140 </span>            : 
<span class="lineNum">    2141 </span>            :  private:
<span class="lineNum">    2142 </span>            :   static ebcdic_execution_charset *s_singleton;
<span class="lineNum">    2143 </span>            :   int m_num_iconv_errors;
<span class="lineNum">    2144 </span>            : };
<span class="lineNum">    2145 </span>            : 
<span class="lineNum">    2146 </span>            : ebcdic_execution_charset *ebcdic_execution_charset::s_singleton;
<span class="lineNum">    2147 </span>            : 
<span class="lineNum">    2148 </span>            : /* A lexer_test_options subclass that records a list of error
<span class="lineNum">    2149 </span>            :    messages emitted by the lexer.  */
<span class="lineNum">    2150 </span>            : 
<span class="lineNum">    2151 </span>            : class lexer_error_sink : public lexer_test_options
<span class="lineNum">    2152 </span>            : {
<span class="lineNum">    2153 </span>            :  public:
<span class="lineNum">    2154 </span>            :   lexer_error_sink ()
<span class="lineNum">    2155 </span><span class="lineCov">         48 :   {</span>
<span class="lineNum">    2156 </span><span class="lineCov">         24 :     gcc_assert (s_singleton == NULL);</span>
<a name="2157"><span class="lineNum">    2157 </span><span class="lineCov">         24 :     s_singleton = this;</span></a>
<span class="lineNum">    2158 </span>            :   }
<span class="lineNum">    2159 </span><span class="lineCov">         24 :   ~lexer_error_sink ()</span>
<span class="lineNum">    2160 </span><span class="lineCov">         24 :   {</span>
<span class="lineNum">    2161 </span><span class="lineCov">         24 :     gcc_assert (s_singleton == this);</span>
<span class="lineNum">    2162 </span><span class="lineCov">         24 :     s_singleton = NULL;</span>
<span class="lineNum">    2163 </span>            : 
<span class="lineNum">    2164 </span><span class="lineCov">         24 :     int i;</span>
<span class="lineNum">    2165 </span><span class="lineCov">         24 :     char *str;</span>
<span class="lineNum">    2166 </span><span class="lineCov">         48 :     FOR_EACH_VEC_ELT (m_errors, i, str)</span>
<span class="lineNum">    2167 </span><span class="lineCov">         24 :       free (str);</span>
<a name="2168"><span class="lineNum">    2168 </span><span class="lineCov">         24 :   }</span></a>
<span class="lineNum">    2169 </span>            : 
<span class="lineNum">    2170 </span><span class="lineCov">         24 :   void apply (lexer_test &amp;test) FINAL OVERRIDE</span>
<span class="lineNum">    2171 </span>            :   {
<span class="lineNum">    2172 </span><span class="lineCov">         24 :     cpp_callbacks *callbacks = cpp_get_callbacks (test.m_parser);</span>
<span class="lineNum">    2173 </span><span class="lineCov">         24 :     callbacks-&gt;error = on_error;</span>
<a name="2174"><span class="lineNum">    2174 </span><span class="lineCov">         24 :   }</span></a>
<span class="lineNum">    2175 </span>            : 
<span class="lineNum">    2176 </span><span class="lineCov">         24 :   static bool on_error (cpp_reader *pfile ATTRIBUTE_UNUSED,</span>
<span class="lineNum">    2177 </span>            :                         int level ATTRIBUTE_UNUSED,
<span class="lineNum">    2178 </span>            :                         int reason ATTRIBUTE_UNUSED,
<span class="lineNum">    2179 </span>            :                         rich_location *richloc ATTRIBUTE_UNUSED,
<span class="lineNum">    2180 </span>            :                         const char *msgid, va_list *ap)
<span class="lineNum">    2181 </span>            :     ATTRIBUTE_FPTR_PRINTF(5,0)
<span class="lineNum">    2182 </span>            :   {
<span class="lineNum">    2183 </span><span class="lineCov">         24 :     char *msg = xvasprintf (msgid, *ap);</span>
<span class="lineNum">    2184 </span><span class="lineCov">         24 :     s_singleton-&gt;m_errors.safe_push (msg);</span>
<span class="lineNum">    2185 </span><span class="lineCov">         24 :     return true;</span>
<span class="lineNum">    2186 </span>            :   }
<span class="lineNum">    2187 </span>            : 
<span class="lineNum">    2188 </span>            :   auto_vec&lt;char *&gt; m_errors;
<span class="lineNum">    2189 </span>            : 
<span class="lineNum">    2190 </span>            :  private:
<span class="lineNum">    2191 </span>            :   static lexer_error_sink *s_singleton;
<span class="lineNum">    2192 </span>            : };
<span class="lineNum">    2193 </span>            : 
<span class="lineNum">    2194 </span>            : lexer_error_sink *lexer_error_sink::s_singleton;
<span class="lineNum">    2195 </span>            : 
<span class="lineNum">    2196 </span>            : /* Constructor.  Override line_table with a new instance based on CASE_,
<span class="lineNum">    2197 </span>            :    and write CONTENT to a tempfile.  Create a cpp_reader, and use it to
<a name="2198"><span class="lineNum">    2198 </span>            :    start parsing the tempfile.  */</a>
<span class="lineNum">    2199 </span>            : 
<span class="lineNum">    2200 </span><span class="lineCov">        576 : lexer_test::lexer_test (const line_table_case &amp;case_, const char *content,</span>
<span class="lineNum">    2201 </span><span class="lineCov">        576 :                         lexer_test_options *options)</span>
<span class="lineNum">    2202 </span>            : : m_ltt (case_),
<span class="lineNum">    2203 </span>            :   m_parser (cpp_create_reader (CLK_GNUC99, NULL, line_table)),
<span class="lineNum">    2204 </span>            :   /* Create a tempfile and write the text to it.  */
<span class="lineNum">    2205 </span><span class="lineCov">       1728 :   m_tempfile (SELFTEST_LOCATION, &quot;.c&quot;, content),</span>
<span class="lineNum">    2206 </span>            :   m_concats (),
<span class="lineNum">    2207 </span><span class="lineCov">        576 :   m_implicitly_expect_EOF (true)</span>
<span class="lineNum">    2208 </span>            : {
<span class="lineNum">    2209 </span><span class="lineCov">        576 :   if (options)</span>
<span class="lineNum">    2210 </span><span class="lineCov">         48 :     options-&gt;apply (*this);</span>
<span class="lineNum">    2211 </span>            : 
<span class="lineNum">    2212 </span><span class="lineCov">        576 :   cpp_init_iconv (m_parser);</span>
<span class="lineNum">    2213 </span>            : 
<span class="lineNum">    2214 </span>            :   /* Parse the file.  */
<span class="lineNum">    2215 </span><span class="lineCov">       1152 :   const char *fname = cpp_read_main_file (m_parser,</span>
<span class="lineNum">    2216 </span><span class="lineCov">        576 :                                           m_tempfile.get_filename ());</span>
<span class="lineNum">    2217 </span><span class="lineCov">        576 :   ASSERT_NE (fname, NULL);</span>
<span class="lineNum">    2218 </span><span class="lineCov">        576 : }</span>
<span class="lineNum">    2219 </span>            : 
<a name="2220"><span class="lineNum">    2220 </span>            : /* Destructor.  By default, verify that the next token in m_parser is EOF.  */</a>
<span class="lineNum">    2221 </span>            : 
<span class="lineNum">    2222 </span><span class="lineCov">       1152 : lexer_test::~lexer_test ()</span>
<span class="lineNum">    2223 </span>            : {
<span class="lineNum">    2224 </span><span class="lineCov">        576 :   location_t loc;</span>
<span class="lineNum">    2225 </span><span class="lineCov">        576 :   const cpp_token *tok;</span>
<span class="lineNum">    2226 </span>            : 
<span class="lineNum">    2227 </span><span class="lineCov">        576 :   if (m_implicitly_expect_EOF)</span>
<span class="lineNum">    2228 </span>            :     {
<span class="lineNum">    2229 </span><span class="lineCov">        552 :       tok = cpp_get_token_with_location (m_parser, &amp;loc);</span>
<span class="lineNum">    2230 </span><span class="lineCov">        552 :       ASSERT_NE (tok, NULL);</span>
<span class="lineNum">    2231 </span><span class="lineCov">        552 :       ASSERT_EQ (tok-&gt;type, CPP_EOF);</span>
<span class="lineNum">    2232 </span>            :     }
<span class="lineNum">    2233 </span><span class="lineCov">        576 : }</span>
<span class="lineNum">    2234 </span>            : 
<span class="lineNum">    2235 </span>            : /* Get the next token from m_parser.  */
<a name="2236"><span class="lineNum">    2236 </span>            : </a>
<span class="lineNum">    2237 </span>            : const cpp_token *
<span class="lineNum">    2238 </span><span class="lineCov">        984 : lexer_test::get_token ()</span>
<span class="lineNum">    2239 </span>            : {
<span class="lineNum">    2240 </span><span class="lineCov">        984 :   location_t loc;</span>
<span class="lineNum">    2241 </span><span class="lineCov">        984 :   const cpp_token *tok;</span>
<span class="lineNum">    2242 </span>            : 
<span class="lineNum">    2243 </span><span class="lineCov">        984 :   tok = cpp_get_token_with_location (m_parser, &amp;loc);</span>
<span class="lineNum">    2244 </span><span class="lineCov">        984 :   ASSERT_NE (tok, NULL);</span>
<span class="lineNum">    2245 </span><span class="lineCov">        984 :   return tok;</span>
<span class="lineNum">    2246 </span>            : }
<span class="lineNum">    2247 </span>            : 
<span class="lineNum">    2248 </span>            : /* Verify that locations within string literals are correctly handled.  */
<span class="lineNum">    2249 </span>            : 
<span class="lineNum">    2250 </span>            : /* Verify get_source_range_for_substring for token(s) at STRLOC,
<span class="lineNum">    2251 </span>            :    using the string concatenation database for TEST.
<span class="lineNum">    2252 </span>            : 
<span class="lineNum">    2253 </span>            :    Assert that the character at index IDX is on EXPECTED_LINE,
<span class="lineNum">    2254 </span>            :    and that it begins at column EXPECTED_START_COL and ends at
<span class="lineNum">    2255 </span>            :    EXPECTED_FINISH_COL (unless the locations are beyond
<span class="lineNum">    2256 </span>            :    LINE_MAP_MAX_LOCATION_WITH_COLS, in which case don't check their
<span class="lineNum">    2257 </span>            :    columns).  */
<a name="2258"><span class="lineNum">    2258 </span>            : </a>
<span class="lineNum">    2259 </span>            : static void
<span class="lineNum">    2260 </span><span class="lineCov">       5804 : assert_char_at_range (const location &amp;loc,</span>
<span class="lineNum">    2261 </span>            :                       lexer_test&amp; test,
<span class="lineNum">    2262 </span>            :                       location_t strloc, enum cpp_ttype type, int idx,
<span class="lineNum">    2263 </span>            :                       int expected_line, int expected_start_col,
<span class="lineNum">    2264 </span>            :                       int expected_finish_col)
<span class="lineNum">    2265 </span>            : {
<span class="lineNum">    2266 </span><span class="lineCov">      11608 :   cpp_reader *pfile = test.m_parser;</span>
<span class="lineNum">    2267 </span><span class="lineCov">       5804 :   string_concat_db *concats = &amp;test.m_concats;</span>
<span class="lineNum">    2268 </span>            : 
<span class="lineNum">    2269 </span><span class="lineCov">       5804 :   source_range actual_range = source_range();</span>
<span class="lineNum">    2270 </span><span class="lineCov">       5804 :   const char *err</span>
<span class="lineNum">    2271 </span><span class="lineCov">       5804 :     = get_source_range_for_char (pfile, concats, strloc, type, idx,</span>
<span class="lineNum">    2272 </span><span class="lineCov">       5804 :                                  &amp;actual_range);</span>
<span class="lineNum">    2273 </span><span class="lineCov">       5804 :   if (should_have_column_data_p (strloc))</span>
<span class="lineNum">    2274 </span><span class="lineCov">       4532 :     ASSERT_EQ_AT (loc, NULL, err);</span>
<span class="lineNum">    2275 </span>            :   else
<span class="lineNum">    2276 </span>            :     {
<span class="lineNum">    2277 </span><span class="lineCov">       1272 :       ASSERT_STREQ_AT (loc,</span>
<span class="lineNum">    2278 </span>            :                        &quot;range starts after LINE_MAP_MAX_LOCATION_WITH_COLS&quot;,
<span class="lineNum">    2279 </span>            :                        err);
<span class="lineNum">    2280 </span><span class="lineCov">       1272 :       return;</span>
<span class="lineNum">    2281 </span>            :     }
<span class="lineNum">    2282 </span>            : 
<span class="lineNum">    2283 </span><span class="lineCov">       4532 :   int actual_start_line = LOCATION_LINE (actual_range.m_start);</span>
<span class="lineNum">    2284 </span><span class="lineCov">       4532 :   ASSERT_EQ_AT (loc, expected_line, actual_start_line);</span>
<span class="lineNum">    2285 </span><span class="lineCov">       4532 :   int actual_finish_line = LOCATION_LINE (actual_range.m_finish);</span>
<span class="lineNum">    2286 </span><span class="lineCov">       4532 :   ASSERT_EQ_AT (loc, expected_line, actual_finish_line);</span>
<span class="lineNum">    2287 </span>            : 
<span class="lineNum">    2288 </span><span class="lineCov">       4532 :   if (should_have_column_data_p (actual_range.m_start))</span>
<span class="lineNum">    2289 </span>            :     {
<span class="lineNum">    2290 </span><span class="lineCov">       4532 :       int actual_start_col = LOCATION_COLUMN (actual_range.m_start);</span>
<span class="lineNum">    2291 </span><span class="lineCov">       4532 :       ASSERT_EQ_AT (loc, expected_start_col, actual_start_col);</span>
<span class="lineNum">    2292 </span>            :     }
<span class="lineNum">    2293 </span><span class="lineCov">       4532 :   if (should_have_column_data_p (actual_range.m_finish))</span>
<span class="lineNum">    2294 </span>            :     {
<span class="lineNum">    2295 </span><span class="lineCov">       4532 :       int actual_finish_col = LOCATION_COLUMN (actual_range.m_finish);</span>
<span class="lineNum">    2296 </span><span class="lineCov">       4532 :       ASSERT_EQ_AT (loc, expected_finish_col, actual_finish_col);</span>
<span class="lineNum">    2297 </span>            :     }
<span class="lineNum">    2298 </span>            : }
<span class="lineNum">    2299 </span>            : 
<span class="lineNum">    2300 </span>            : /* Macro for calling assert_char_at_range, supplying SELFTEST_LOCATION for
<span class="lineNum">    2301 </span>            :    the effective location of any errors.  */
<span class="lineNum">    2302 </span>            : 
<span class="lineNum">    2303 </span>            : #define ASSERT_CHAR_AT_RANGE(LEXER_TEST, STRLOC, TYPE, IDX, EXPECTED_LINE, \
<span class="lineNum">    2304 </span>            :                              EXPECTED_START_COL, EXPECTED_FINISH_COL)   \
<span class="lineNum">    2305 </span>            :   assert_char_at_range (SELFTEST_LOCATION, (LEXER_TEST), (STRLOC), (TYPE), \
<span class="lineNum">    2306 </span>            :                         (IDX), (EXPECTED_LINE), (EXPECTED_START_COL), \
<span class="lineNum">    2307 </span>            :                         (EXPECTED_FINISH_COL))
<span class="lineNum">    2308 </span>            : 
<span class="lineNum">    2309 </span>            : /* Verify get_num_source_ranges_for_substring for token(s) at STRLOC,
<span class="lineNum">    2310 </span>            :    using the string concatenation database for TEST.
<span class="lineNum">    2311 </span>            : 
<span class="lineNum">    2312 </span>            :    Assert that the token(s) at STRLOC contain EXPECTED_NUM_RANGES.  */
<a name="2313"><span class="lineNum">    2313 </span>            : </a>
<span class="lineNum">    2314 </span>            : static void
<span class="lineNum">    2315 </span><span class="lineCov">        316 : assert_num_substring_ranges (const location &amp;loc,</span>
<span class="lineNum">    2316 </span>            :                              lexer_test&amp; test,
<span class="lineNum">    2317 </span>            :                              location_t strloc,
<span class="lineNum">    2318 </span>            :                              enum cpp_ttype type,
<span class="lineNum">    2319 </span>            :                              int expected_num_ranges)
<span class="lineNum">    2320 </span>            : {
<span class="lineNum">    2321 </span><span class="lineCov">        632 :   cpp_reader *pfile = test.m_parser;</span>
<span class="lineNum">    2322 </span><span class="lineCov">        316 :   string_concat_db *concats = &amp;test.m_concats;</span>
<span class="lineNum">    2323 </span>            : 
<span class="lineNum">    2324 </span><span class="lineCov">        316 :   int actual_num_ranges = -1;</span>
<span class="lineNum">    2325 </span><span class="lineCov">        316 :   const char *err</span>
<span class="lineNum">    2326 </span><span class="lineCov">        316 :     = get_num_source_ranges_for_substring (pfile, concats, strloc, type,</span>
<span class="lineNum">    2327 </span><span class="lineCov">        316 :                                            &amp;actual_num_ranges);</span>
<span class="lineNum">    2328 </span><span class="lineCov">        316 :   if (should_have_column_data_p (strloc))</span>
<span class="lineNum">    2329 </span><span class="lineCov">        220 :     ASSERT_EQ_AT (loc, NULL, err);</span>
<span class="lineNum">    2330 </span>            :   else
<span class="lineNum">    2331 </span>            :     {
<span class="lineNum">    2332 </span><span class="lineCov">         96 :       ASSERT_STREQ_AT (loc,</span>
<span class="lineNum">    2333 </span>            :                        &quot;range starts after LINE_MAP_MAX_LOCATION_WITH_COLS&quot;,
<span class="lineNum">    2334 </span>            :                        err);
<span class="lineNum">    2335 </span><span class="lineCov">         96 :       return;</span>
<span class="lineNum">    2336 </span>            :     }
<span class="lineNum">    2337 </span><span class="lineCov">        220 :   ASSERT_EQ_AT (loc, expected_num_ranges, actual_num_ranges);</span>
<span class="lineNum">    2338 </span>            : }
<span class="lineNum">    2339 </span>            : 
<span class="lineNum">    2340 </span>            : /* Macro for calling assert_num_substring_ranges, supplying
<span class="lineNum">    2341 </span>            :    SELFTEST_LOCATION for the effective location of any errors.  */
<span class="lineNum">    2342 </span>            : 
<span class="lineNum">    2343 </span>            : #define ASSERT_NUM_SUBSTRING_RANGES(LEXER_TEST, STRLOC, TYPE, \
<span class="lineNum">    2344 </span>            :                                     EXPECTED_NUM_RANGES)                \
<span class="lineNum">    2345 </span>            :   assert_num_substring_ranges (SELFTEST_LOCATION, (LEXER_TEST), (STRLOC), \
<span class="lineNum">    2346 </span>            :                                (TYPE), (EXPECTED_NUM_RANGES))
<span class="lineNum">    2347 </span>            : 
<span class="lineNum">    2348 </span>            : 
<span class="lineNum">    2349 </span>            : /* Verify that get_num_source_ranges_for_substring for token(s) at STRLOC
<span class="lineNum">    2350 </span>            :    returns an error (using the string concatenation database for TEST).  */
<a name="2351"><span class="lineNum">    2351 </span>            : </a>
<span class="lineNum">    2352 </span>            : static void
<span class="lineNum">    2353 </span><span class="lineCov">        158 : assert_has_no_substring_ranges (const location &amp;loc,</span>
<span class="lineNum">    2354 </span>            :                                 lexer_test&amp; test,
<span class="lineNum">    2355 </span>            :                                 location_t strloc,
<span class="lineNum">    2356 </span>            :                                 enum cpp_ttype type,
<span class="lineNum">    2357 </span>            :                                 const char *expected_err)
<span class="lineNum">    2358 </span>            : {
<span class="lineNum">    2359 </span><span class="lineCov">        316 :   cpp_reader *pfile = test.m_parser;</span>
<span class="lineNum">    2360 </span><span class="lineCov">        158 :   string_concat_db *concats = &amp;test.m_concats;</span>
<span class="lineNum">    2361 </span><span class="lineCov">        316 :   cpp_substring_ranges ranges;</span>
<span class="lineNum">    2362 </span><span class="lineCov">        158 :   const char *actual_err</span>
<span class="lineNum">    2363 </span><span class="lineCov">        158 :     = get_substring_ranges_for_loc (pfile, concats, strloc,</span>
<span class="lineNum">    2364 </span><span class="lineCov">        158 :                                     type, ranges);</span>
<span class="lineNum">    2365 </span><span class="lineCov">        158 :   if (should_have_column_data_p (strloc))</span>
<span class="lineNum">    2366 </span><span class="lineCov">        110 :     ASSERT_STREQ_AT (loc, expected_err, actual_err);</span>
<span class="lineNum">    2367 </span>            :   else
<span class="lineNum">    2368 </span><span class="lineCov">         48 :     ASSERT_STREQ_AT (loc,</span>
<span class="lineNum">    2369 </span>            :                      &quot;range starts after LINE_MAP_MAX_LOCATION_WITH_COLS&quot;,
<span class="lineNum">    2370 </span>            :                      actual_err);
<span class="lineNum">    2371 </span><span class="lineCov">        158 : }</span>
<span class="lineNum">    2372 </span>            : 
<span class="lineNum">    2373 </span>            : #define ASSERT_HAS_NO_SUBSTRING_RANGES(LEXER_TEST, STRLOC, TYPE, ERR)    \
<span class="lineNum">    2374 </span>            :     assert_has_no_substring_ranges (SELFTEST_LOCATION, (LEXER_TEST), \
<span class="lineNum">    2375 </span>            :                                     (STRLOC), (TYPE), (ERR))
<span class="lineNum">    2376 </span>            : 
<span class="lineNum">    2377 </span>            : /* Lex a simple string literal.  Verify the substring location data, before
<span class="lineNum">    2378 </span>            :    and after running cpp_interpret_string on it.  */
<a name="2379"><span class="lineNum">    2379 </span>            : </a>
<span class="lineNum">    2380 </span>            : static void
<span class="lineNum">    2381 </span><span class="lineCov">         24 : test_lexer_string_locations_simple (const line_table_case &amp;case_)</span>
<span class="lineNum">    2382 </span>            : {
<span class="lineNum">    2383 </span>            :   /* Digits 0-9 (with 0 at column 10), the simple way.
<span class="lineNum">    2384 </span>            :      ....................000000000.11111111112.2222222223333333333
<span class="lineNum">    2385 </span>            :      ....................123456789.01234567890.1234567890123456789
<span class="lineNum">    2386 </span>            :      We add a trailing comment to ensure that we correctly locate
<span class="lineNum">    2387 </span>            :      the end of the string literal token.  */
<span class="lineNum">    2388 </span><span class="lineCov">         24 :   const char *content = &quot;        \&quot;0123456789\&quot; /* not a string */\n&quot;;</span>
<span class="lineNum">    2389 </span><span class="lineCov">         24 :   lexer_test test (case_, content, NULL);</span>
<span class="lineNum">    2390 </span>            : 
<span class="lineNum">    2391 </span>            :   /* Verify that we get the expected token back, with the correct
<span class="lineNum">    2392 </span>            :      location information.  */
<span class="lineNum">    2393 </span><span class="lineCov">         24 :   const cpp_token *tok = test.get_token ();</span>
<span class="lineNum">    2394 </span><span class="lineCov">         24 :   ASSERT_EQ (tok-&gt;type, CPP_STRING);</span>
<span class="lineNum">    2395 </span><span class="lineCov">         24 :   ASSERT_TOKEN_AS_TEXT_EQ (test.m_parser, tok, &quot;\&quot;0123456789\&quot;&quot;);</span>
<span class="lineNum">    2396 </span><span class="lineCov">         72 :   ASSERT_TOKEN_LOC_EQ (tok, test.m_tempfile.get_filename (), 1, 9, 20);</span>
<span class="lineNum">    2397 </span>            : 
<span class="lineNum">    2398 </span>            :   /* At this point in lexing, the quote characters are treated as part of
<span class="lineNum">    2399 </span>            :      the string (they are stripped off by cpp_interpret_string).  */
<span class="lineNum">    2400 </span>            : 
<span class="lineNum">    2401 </span><span class="lineCov">         24 :   ASSERT_EQ (tok-&gt;val.str.len, 12);</span>
<span class="lineNum">    2402 </span>            : 
<span class="lineNum">    2403 </span>            :   /* Verify that cpp_interpret_string works.  */
<span class="lineNum">    2404 </span><span class="lineCov">         24 :   cpp_string dst_string;</span>
<span class="lineNum">    2405 </span><span class="lineCov">         24 :   const enum cpp_ttype type = CPP_STRING;</span>
<span class="lineNum">    2406 </span><span class="lineCov">         24 :   bool result = cpp_interpret_string (test.m_parser, &amp;tok-&gt;val.str, 1,</span>
<span class="lineNum">    2407 </span><span class="lineCov">         24 :                                       &amp;dst_string, type);</span>
<span class="lineNum">    2408 </span><span class="lineCov">         24 :   ASSERT_TRUE (result);</span>
<span class="lineNum">    2409 </span><span class="lineCov">         48 :   ASSERT_STREQ (&quot;0123456789&quot;, (const char *)dst_string.text);</span>
<span class="lineNum">    2410 </span><span class="lineCov">         24 :   free (const_cast &lt;unsigned char *&gt; (dst_string.text));</span>
<span class="lineNum">    2411 </span>            : 
<span class="lineNum">    2412 </span>            :   /* Verify ranges of individual characters.  This no longer includes the
<span class="lineNum">    2413 </span>            :      opening quote, but does include the closing quote.  */
<span class="lineNum">    2414 </span><span class="lineCov">        288 :   for (int i = 0; i &lt;= 10; i++)</span>
<span class="lineNum">    2415 </span><span class="lineCov">        528 :     ASSERT_CHAR_AT_RANGE (test, tok-&gt;src_loc, type, i, 1,</span>
<span class="lineNum">    2416 </span>            :                           10 + i, 10 + i);
<span class="lineNum">    2417 </span>            : 
<span class="lineNum">    2418 </span><span class="lineCov">         48 :   ASSERT_NUM_SUBSTRING_RANGES (test, tok-&gt;src_loc, type, 11);</span>
<span class="lineNum">    2419 </span><span class="lineCov">         24 : }</span>
<span class="lineNum">    2420 </span>            : 
<span class="lineNum">    2421 </span>            : /* As test_lexer_string_locations_simple, but use an EBCDIC execution
<span class="lineNum">    2422 </span>            :    encoding.  */
<a name="2423"><span class="lineNum">    2423 </span>            : </a>
<span class="lineNum">    2424 </span>            : static void
<span class="lineNum">    2425 </span><span class="lineCov">         24 : test_lexer_string_locations_ebcdic (const line_table_case &amp;case_)</span>
<span class="lineNum">    2426 </span>            : {
<span class="lineNum">    2427 </span>            :   /* EBCDIC support requires iconv.  */
<span class="lineNum">    2428 </span><span class="lineCov">         24 :   if (!HAVE_ICONV)</span>
<span class="lineNum">    2429 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">    2430 </span>            : 
<span class="lineNum">    2431 </span>            :   /* Digits 0-9 (with 0 at column 10), the simple way.
<span class="lineNum">    2432 </span>            :      ....................000000000.11111111112.2222222223333333333
<span class="lineNum">    2433 </span>            :      ....................123456789.01234567890.1234567890123456789
<span class="lineNum">    2434 </span>            :      We add a trailing comment to ensure that we correctly locate
<span class="lineNum">    2435 </span>            :      the end of the string literal token.  */
<span class="lineNum">    2436 </span><span class="lineCov">         24 :   const char *content = &quot;        \&quot;0123456789\&quot; /* not a string */\n&quot;;</span>
<span class="lineNum">    2437 </span><span class="lineCov">         48 :   ebcdic_execution_charset use_ebcdic;</span>
<span class="lineNum">    2438 </span><span class="lineCov">         48 :   lexer_test test (case_, content, &amp;use_ebcdic);</span>
<span class="lineNum">    2439 </span>            : 
<span class="lineNum">    2440 </span>            :   /* Verify that we get the expected token back, with the correct
<span class="lineNum">    2441 </span>            :      location information.  */
<span class="lineNum">    2442 </span><span class="lineCov">         24 :   const cpp_token *tok = test.get_token ();</span>
<span class="lineNum">    2443 </span><span class="lineCov">         24 :   ASSERT_EQ (tok-&gt;type, CPP_STRING);</span>
<span class="lineNum">    2444 </span><span class="lineCov">         24 :   ASSERT_TOKEN_AS_TEXT_EQ (test.m_parser, tok, &quot;\&quot;0123456789\&quot;&quot;);</span>
<span class="lineNum">    2445 </span><span class="lineCov">         72 :   ASSERT_TOKEN_LOC_EQ (tok, test.m_tempfile.get_filename (), 1, 9, 20);</span>
<span class="lineNum">    2446 </span>            : 
<span class="lineNum">    2447 </span>            :   /* At this point in lexing, the quote characters are treated as part of
<span class="lineNum">    2448 </span>            :      the string (they are stripped off by cpp_interpret_string).  */
<span class="lineNum">    2449 </span>            : 
<span class="lineNum">    2450 </span><span class="lineCov">         24 :   ASSERT_EQ (tok-&gt;val.str.len, 12);</span>
<span class="lineNum">    2451 </span>            : 
<span class="lineNum">    2452 </span>            :   /* The remainder of the test requires an iconv implementation that
<span class="lineNum">    2453 </span>            :      can convert from UTF-8 to the EBCDIC encoding requested above.  */
<span class="lineNum">    2454 </span><span class="lineCov">         24 :   if (use_ebcdic.iconv_errors_occurred_p ())</span>
<span class="lineNum">    2455 </span><span class="lineNoCov">          0 :     return;</span>
<span class="lineNum">    2456 </span>            : 
<span class="lineNum">    2457 </span>            :   /* Verify that cpp_interpret_string works.  */
<span class="lineNum">    2458 </span><span class="lineCov">         24 :   cpp_string dst_string;</span>
<span class="lineNum">    2459 </span><span class="lineCov">         24 :   const enum cpp_ttype type = CPP_STRING;</span>
<span class="lineNum">    2460 </span><span class="lineCov">         24 :   bool result = cpp_interpret_string (test.m_parser, &amp;tok-&gt;val.str, 1,</span>
<span class="lineNum">    2461 </span><span class="lineCov">         24 :                                       &amp;dst_string, type);</span>
<span class="lineNum">    2462 </span><span class="lineCov">         24 :   ASSERT_TRUE (result);</span>
<span class="lineNum">    2463 </span>            :   /* We should now have EBCDIC-encoded text, specifically
<span class="lineNum">    2464 </span>            :      IBM1047-encoded (aka &quot;EBCDIC 1047&quot;, or &quot;Code page 1047&quot;).
<span class="lineNum">    2465 </span>            :      The digits 0-9 are encoded as 240-249 i.e. 0xf0-0xf9.  */
<span class="lineNum">    2466 </span><span class="lineCov">         48 :   ASSERT_STREQ (&quot;\xf0\xf1\xf2\xf3\xf4\xf5\xf6\xf7\xf8\xf9&quot;,</span>
<span class="lineNum">    2467 </span>            :                 (const char *)dst_string.text);
<span class="lineNum">    2468 </span><span class="lineCov">         24 :   free (const_cast &lt;unsigned char *&gt; (dst_string.text));</span>
<span class="lineNum">    2469 </span>            : 
<span class="lineNum">    2470 </span>            :   /* Verify that we don't attempt to record substring location information
<span class="lineNum">    2471 </span>            :      for such cases.  */
<span class="lineNum">    2472 </span><span class="lineCov">         48 :   ASSERT_HAS_NO_SUBSTRING_RANGES</span>
<span class="lineNum">    2473 </span>            :     (test, tok-&gt;src_loc, type,
<span class="lineNum">    2474 </span>            :      &quot;execution character set != source character set&quot;);
<span class="lineNum">    2475 </span>            : }
<span class="lineNum">    2476 </span>            : 
<span class="lineNum">    2477 </span>            : /* Lex a string literal containing a hex-escaped character.
<span class="lineNum">    2478 </span>            :    Verify the substring location data, before and after running
<span class="lineNum">    2479 </span>            :    cpp_interpret_string on it.  */
<a name="2480"><span class="lineNum">    2480 </span>            : </a>
<span class="lineNum">    2481 </span>            : static void
<span class="lineNum">    2482 </span><span class="lineCov">         24 : test_lexer_string_locations_hex (const line_table_case &amp;case_)</span>
<span class="lineNum">    2483 </span>            : {
<span class="lineNum">    2484 </span>            :   /* Digits 0-9, expressing digit 5 in ASCII as &quot;\x35&quot;
<span class="lineNum">    2485 </span>            :      and with a space in place of digit 6, to terminate the escaped
<span class="lineNum">    2486 </span>            :      hex code.
<span class="lineNum">    2487 </span>            :      ....................000000000.111111.11112222.
<span class="lineNum">    2488 </span>            :      ....................123456789.012345.67890123.  */
<span class="lineNum">    2489 </span><span class="lineCov">         24 :   const char *content = &quot;        \&quot;01234\\x35 789\&quot;\n&quot;;</span>
<span class="lineNum">    2490 </span><span class="lineCov">         24 :   lexer_test test (case_, content, NULL);</span>
<span class="lineNum">    2491 </span>            : 
<span class="lineNum">    2492 </span>            :   /* Verify that we get the expected token back, with the correct
<span class="lineNum">    2493 </span>            :      location information.  */
<span class="lineNum">    2494 </span><span class="lineCov">         24 :   const cpp_token *tok = test.get_token ();</span>
<span class="lineNum">    2495 </span><span class="lineCov">         24 :   ASSERT_EQ (tok-&gt;type, CPP_STRING);</span>
<span class="lineNum">    2496 </span><span class="lineCov">         24 :   ASSERT_TOKEN_AS_TEXT_EQ (test.m_parser, tok, &quot;\&quot;01234\\x35 789\&quot;&quot;);</span>
<span class="lineNum">    2497 </span><span class="lineCov">         72 :   ASSERT_TOKEN_LOC_EQ (tok, test.m_tempfile.get_filename (), 1, 9, 23);</span>
<span class="lineNum">    2498 </span>            : 
<span class="lineNum">    2499 </span>            :   /* At this point in lexing, the quote characters are treated as part of
<span class="lineNum">    2500 </span>            :      the string (they are stripped off by cpp_interpret_string).  */
<span class="lineNum">    2501 </span><span class="lineCov">         24 :   ASSERT_EQ (tok-&gt;val.str.len, 15);</span>
<span class="lineNum">    2502 </span>            : 
<span class="lineNum">    2503 </span>            :   /* Verify that cpp_interpret_string works.  */
<span class="lineNum">    2504 </span><span class="lineCov">         24 :   cpp_string dst_string;</span>
<span class="lineNum">    2505 </span><span class="lineCov">         24 :   const enum cpp_ttype type = CPP_STRING;</span>
<span class="lineNum">    2506 </span><span class="lineCov">         24 :   bool result = cpp_interpret_string (test.m_parser, &amp;tok-&gt;val.str, 1,</span>
<span class="lineNum">    2507 </span><span class="lineCov">         24 :                                       &amp;dst_string, type);</span>
<span class="lineNum">    2508 </span><span class="lineCov">         24 :   ASSERT_TRUE (result);</span>
<span class="lineNum">    2509 </span><span class="lineCov">         48 :   ASSERT_STREQ (&quot;012345 789&quot;, (const char *)dst_string.text);</span>
<span class="lineNum">    2510 </span><span class="lineCov">         24 :   free (const_cast &lt;unsigned char *&gt; (dst_string.text));</span>
<span class="lineNum">    2511 </span>            : 
<span class="lineNum">    2512 </span>            :   /* Verify ranges of individual characters.  This no longer includes the
<span class="lineNum">    2513 </span>            :      opening quote, but does include the closing quote.  */
<span class="lineNum">    2514 </span><span class="lineCov">        144 :   for (int i = 0; i &lt;= 4; i++)</span>
<span class="lineNum">    2515 </span><span class="lineCov">        240 :     ASSERT_CHAR_AT_RANGE (test, tok-&gt;src_loc, type, i, 1, 10 + i, 10 + i);</span>
<span class="lineNum">    2516 </span><span class="lineCov">         48 :   ASSERT_CHAR_AT_RANGE (test, tok-&gt;src_loc, type, 5, 1, 15, 18);</span>
<span class="lineNum">    2517 </span><span class="lineCov">        144 :   for (int i = 6; i &lt;= 10; i++)</span>
<span class="lineNum">    2518 </span><span class="lineCov">        240 :     ASSERT_CHAR_AT_RANGE (test, tok-&gt;src_loc, type, i, 1, 13 + i, 13 + i);</span>
<span class="lineNum">    2519 </span>            : 
<span class="lineNum">    2520 </span><span class="lineCov">         48 :   ASSERT_NUM_SUBSTRING_RANGES (test, tok-&gt;src_loc, type, 11);</span>
<span class="lineNum">    2521 </span><span class="lineCov">         24 : }</span>
<span class="lineNum">    2522 </span>            : 
<span class="lineNum">    2523 </span>            : /* Lex a string literal containing an octal-escaped character.
<span class="lineNum">    2524 </span>            :    Verify the substring location data after running cpp_interpret_string
<span class="lineNum">    2525 </span>            :    on it.  */
<a name="2526"><span class="lineNum">    2526 </span>            : </a>
<span class="lineNum">    2527 </span>            : static void
<span class="lineNum">    2528 </span><span class="lineCov">         24 : test_lexer_string_locations_oct (const line_table_case &amp;case_)</span>
<span class="lineNum">    2529 </span>            : {
<span class="lineNum">    2530 </span>            :   /* Digits 0-9, expressing digit 5 in ASCII as &quot;\065&quot;
<span class="lineNum">    2531 </span>            :      and with a space in place of digit 6, to terminate the escaped
<span class="lineNum">    2532 </span>            :      octal code.
<span class="lineNum">    2533 </span>            :      ....................000000000.111111.11112222.2222223333333333444
<span class="lineNum">    2534 </span>            :      ....................123456789.012345.67890123.4567890123456789012  */
<span class="lineNum">    2535 </span><span class="lineCov">         24 :   const char *content = &quot;        \&quot;01234\\065 789\&quot; /* not a string */\n&quot;;</span>
<span class="lineNum">    2536 </span><span class="lineCov">         24 :   lexer_test test (case_, content, NULL);</span>
<span class="lineNum">    2537 </span>            : 
<span class="lineNum">    2538 </span>            :   /* Verify that we get the expected token back, with the correct
<span class="lineNum">    2539 </span>            :      location information.  */
<span class="lineNum">    2540 </span><span class="lineCov">         24 :   const cpp_token *tok = test.get_token ();</span>
<span class="lineNum">    2541 </span><span class="lineCov">         24 :   ASSERT_EQ (tok-&gt;type, CPP_STRING);</span>
<span class="lineNum">    2542 </span><span class="lineCov">         24 :   ASSERT_TOKEN_AS_TEXT_EQ (test.m_parser, tok, &quot;\&quot;01234\\065 789\&quot;&quot;);</span>
<span class="lineNum">    2543 </span>            : 
<span class="lineNum">    2544 </span>            :   /* Verify that cpp_interpret_string works.  */
<span class="lineNum">    2545 </span><span class="lineCov">         24 :   cpp_string dst_string;</span>
<span class="lineNum">    2546 </span><span class="lineCov">         24 :   const enum cpp_ttype type = CPP_STRING;</span>
<span class="lineNum">    2547 </span><span class="lineCov">         24 :   bool result = cpp_interpret_string (test.m_parser, &amp;tok-&gt;val.str, 1,</span>
<span class="lineNum">    2548 </span><span class="lineCov">         24 :                                       &amp;dst_string, type);</span>
<span class="lineNum">    2549 </span><span class="lineCov">         24 :   ASSERT_TRUE (result);</span>
<span class="lineNum">    2550 </span><span class="lineCov">         48 :   ASSERT_STREQ (&quot;012345 789&quot;, (const char *)dst_string.text);</span>
<span class="lineNum">    2551 </span><span class="lineCov">         24 :   free (const_cast &lt;unsigned char *&gt; (dst_string.text));</span>
<span class="lineNum">    2552 </span>            : 
<span class="lineNum">    2553 </span>            :   /* Verify ranges of individual characters.  This no longer includes the
<span class="lineNum">    2554 </span>            :      opening quote, but does include the closing quote.  */
<span class="lineNum">    2555 </span><span class="lineCov">        144 :   for (int i = 0; i &lt; 5; i++)</span>
<span class="lineNum">    2556 </span><span class="lineCov">        240 :     ASSERT_CHAR_AT_RANGE (test, tok-&gt;src_loc, type, i, 1, 10 + i, 10 + i);</span>
<span class="lineNum">    2557 </span><span class="lineCov">         48 :   ASSERT_CHAR_AT_RANGE (test, tok-&gt;src_loc, type, 5, 1, 15, 18);</span>
<span class="lineNum">    2558 </span><span class="lineCov">        144 :   for (int i = 6; i &lt;= 10; i++)</span>
<span class="lineNum">    2559 </span><span class="lineCov">        240 :     ASSERT_CHAR_AT_RANGE (test, tok-&gt;src_loc, type, i, 1, 13 + i, 13 + i);</span>
<span class="lineNum">    2560 </span>            : 
<span class="lineNum">    2561 </span><span class="lineCov">         48 :   ASSERT_NUM_SUBSTRING_RANGES (test, tok-&gt;src_loc, type, 11);</span>
<span class="lineNum">    2562 </span><span class="lineCov">         24 : }</span>
<span class="lineNum">    2563 </span>            : 
<span class="lineNum">    2564 </span>            : /* Test of string literal containing letter escapes.  */
<a name="2565"><span class="lineNum">    2565 </span>            : </a>
<span class="lineNum">    2566 </span>            : static void
<span class="lineNum">    2567 </span><span class="lineCov">         24 : test_lexer_string_locations_letter_escape_1 (const line_table_case &amp;case_)</span>
<span class="lineNum">    2568 </span>            : {
<span class="lineNum">    2569 </span>            :   /* The string &quot;\tfoo\\\nbar&quot; i.e. tab, &quot;foo&quot;, backslash, newline, bar.
<span class="lineNum">    2570 </span>            :      .....................000000000.1.11111.1.1.11222.22222223333333
<span class="lineNum">    2571 </span>            :      .....................123456789.0.12345.6.7.89012.34567890123456.  */
<span class="lineNum">    2572 </span><span class="lineCov">         24 :   const char *content = (&quot;        \&quot;\\tfoo\\\\\\nbar\&quot; /* non-str */\n&quot;);</span>
<span class="lineNum">    2573 </span><span class="lineCov">         24 :   lexer_test test (case_, content, NULL);</span>
<span class="lineNum">    2574 </span>            : 
<span class="lineNum">    2575 </span>            :   /* Verify that we get the expected tokens back.  */
<span class="lineNum">    2576 </span><span class="lineCov">         24 :   const cpp_token *tok = test.get_token ();</span>
<span class="lineNum">    2577 </span><span class="lineCov">         24 :   ASSERT_EQ (tok-&gt;type, CPP_STRING);</span>
<span class="lineNum">    2578 </span><span class="lineCov">         24 :   ASSERT_TOKEN_AS_TEXT_EQ (test.m_parser, tok, &quot;\&quot;\\tfoo\\\\\\nbar\&quot;&quot;);</span>
<span class="lineNum">    2579 </span>            : 
<span class="lineNum">    2580 </span>            :   /* Verify ranges of individual characters. */
<span class="lineNum">    2581 </span>            :   /* &quot;\t&quot;.  */
<span class="lineNum">    2582 </span><span class="lineCov">         48 :   ASSERT_CHAR_AT_RANGE (test, tok-&gt;src_loc, CPP_STRING,</span>
<span class="lineNum">    2583 </span>            :                         0, 1, 10, 11);
<span class="lineNum">    2584 </span>            :   /* &quot;foo&quot;. */
<span class="lineNum">    2585 </span><span class="lineCov">         96 :   for (int i = 1; i &lt;= 3; i++)</span>
<span class="lineNum">    2586 </span><span class="lineCov">        144 :     ASSERT_CHAR_AT_RANGE (test, tok-&gt;src_loc, CPP_STRING,</span>
<span class="lineNum">    2587 </span>            :                           i, 1, 11 + i, 11 + i);
<span class="lineNum">    2588 </span>            :   /* &quot;\\&quot; and &quot;\n&quot;.  */
<span class="lineNum">    2589 </span><span class="lineCov">         48 :   ASSERT_CHAR_AT_RANGE (test, tok-&gt;src_loc, CPP_STRING,</span>
<span class="lineNum">    2590 </span>            :                         4, 1, 15, 16);
<span class="lineNum">    2591 </span><span class="lineCov">         48 :   ASSERT_CHAR_AT_RANGE (test, tok-&gt;src_loc, CPP_STRING,</span>
<span class="lineNum">    2592 </span>            :                         5, 1, 17, 18);
<span class="lineNum">    2593 </span>            : 
<span class="lineNum">    2594 </span>            :   /* &quot;bar&quot; and closing quote for nul-terminator.  */
<span class="lineNum">    2595 </span><span class="lineCov">        120 :   for (int i = 6; i &lt;= 9; i++)</span>
<span class="lineNum">    2596 </span><span class="lineCov">        192 :     ASSERT_CHAR_AT_RANGE (test, tok-&gt;src_loc, CPP_STRING,</span>
<span class="lineNum">    2597 </span>            :                           i, 1, 13 + i, 13 + i);
<span class="lineNum">    2598 </span>            : 
<span class="lineNum">    2599 </span><span class="lineCov">         48 :   ASSERT_NUM_SUBSTRING_RANGES (test, tok-&gt;src_loc, CPP_STRING, 10);</span>
<span class="lineNum">    2600 </span><span class="lineCov">         24 : }</span>
<span class="lineNum">    2601 </span>            : 
<span class="lineNum">    2602 </span>            : /* Another test of a string literal containing a letter escape.
<span class="lineNum">    2603 </span>            :    Based on string seen in
<span class="lineNum">    2604 </span>            :      printf (&quot;%-%\n&quot;);
<span class="lineNum">    2605 </span>            :    in gcc.dg/format/c90-printf-1.c.  */
<a name="2606"><span class="lineNum">    2606 </span>            : </a>
<span class="lineNum">    2607 </span>            : static void
<span class="lineNum">    2608 </span><span class="lineCov">         24 : test_lexer_string_locations_letter_escape_2 (const line_table_case &amp;case_)</span>
<span class="lineNum">    2609 </span>            : {
<span class="lineNum">    2610 </span>            :   /* .....................000000000.1111.11.1111.22222222223.
<span class="lineNum">    2611 </span>            :      .....................123456789.0123.45.6789.01234567890.  */
<span class="lineNum">    2612 </span><span class="lineCov">         24 :   const char *content = (&quot;        \&quot;%-%\\n\&quot; /* non-str */\n&quot;);</span>
<span class="lineNum">    2613 </span><span class="lineCov">         24 :   lexer_test test (case_, content, NULL);</span>
<span class="lineNum">    2614 </span>            : 
<span class="lineNum">    2615 </span>            :   /* Verify that we get the expected tokens back.  */
<span class="lineNum">    2616 </span><span class="lineCov">         24 :   const cpp_token *tok = test.get_token ();</span>
<span class="lineNum">    2617 </span><span class="lineCov">         24 :   ASSERT_EQ (tok-&gt;type, CPP_STRING);</span>
<span class="lineNum">    2618 </span><span class="lineCov">         24 :   ASSERT_TOKEN_AS_TEXT_EQ (test.m_parser, tok, &quot;\&quot;%-%\\n\&quot;&quot;);</span>
<span class="lineNum">    2619 </span>            : 
<span class="lineNum">    2620 </span>            :   /* Verify ranges of individual characters. */
<span class="lineNum">    2621 </span>            :   /* &quot;%-%&quot;.  */
<span class="lineNum">    2622 </span><span class="lineCov">         96 :   for (int i = 0; i &lt; 3; i++)</span>
<span class="lineNum">    2623 </span><span class="lineCov">        144 :     ASSERT_CHAR_AT_RANGE (test, tok-&gt;src_loc, CPP_STRING,</span>
<span class="lineNum">    2624 </span>            :                           i, 1, 10 + i, 10 + i);
<span class="lineNum">    2625 </span>            :   /* &quot;\n&quot;.  */
<span class="lineNum">    2626 </span><span class="lineCov">         48 :   ASSERT_CHAR_AT_RANGE (test, tok-&gt;src_loc, CPP_STRING,</span>
<span class="lineNum">    2627 </span>            :                         3, 1, 13, 14);
<span class="lineNum">    2628 </span>            : 
<span class="lineNum">    2629 </span>            :   /* Closing quote for nul-terminator.  */
<span class="lineNum">    2630 </span><span class="lineCov">         48 :   ASSERT_CHAR_AT_RANGE (test, tok-&gt;src_loc, CPP_STRING,</span>
<span class="lineNum">    2631 </span>            :                         4, 1, 15, 15);
<span class="lineNum">    2632 </span>            : 
<span class="lineNum">    2633 </span><span class="lineCov">         48 :   ASSERT_NUM_SUBSTRING_RANGES (test, tok-&gt;src_loc, CPP_STRING, 5);</span>
<span class="lineNum">    2634 </span><span class="lineCov">         24 : }</span>
<span class="lineNum">    2635 </span>            : 
<span class="lineNum">    2636 </span>            : /* Lex a string literal containing UCN 4 characters.
<span class="lineNum">    2637 </span>            :    Verify the substring location data after running cpp_interpret_string
<span class="lineNum">    2638 </span>            :    on it.  */
<a name="2639"><span class="lineNum">    2639 </span>            : </a>
<span class="lineNum">    2640 </span>            : static void
<span class="lineNum">    2641 </span><span class="lineCov">         24 : test_lexer_string_locations_ucn4 (const line_table_case &amp;case_)</span>
<span class="lineNum">    2642 </span>            : {
<span class="lineNum">    2643 </span>            :   /* Digits 0-9, expressing digits 5 and 6 as Roman numerals expressed
<span class="lineNum">    2644 </span>            :      as UCN 4.
<span class="lineNum">    2645 </span>            :      ....................000000000.111111.111122.222222223.33333333344444
<span class="lineNum">    2646 </span>            :      ....................123456789.012345.678901.234567890.12345678901234  */
<span class="lineNum">    2647 </span><span class="lineCov">         24 :   const char *content = &quot;        \&quot;01234\\u2174\\u2175789\&quot; /* non-str */\n&quot;;</span>
<span class="lineNum">    2648 </span><span class="lineCov">         24 :   lexer_test test (case_, content, NULL);</span>
<span class="lineNum">    2649 </span>            : 
<span class="lineNum">    2650 </span>            :   /* Verify that we get the expected token back, with the correct
<span class="lineNum">    2651 </span>            :      location information.  */
<span class="lineNum">    2652 </span><span class="lineCov">         24 :   const cpp_token *tok = test.get_token ();</span>
<span class="lineNum">    2653 </span><span class="lineCov">         24 :   ASSERT_EQ (tok-&gt;type, CPP_STRING);</span>
<span class="lineNum">    2654 </span><span class="lineCov">         24 :   ASSERT_TOKEN_AS_TEXT_EQ (test.m_parser, tok, &quot;\&quot;01234\\u2174\\u2175789\&quot;&quot;);</span>
<span class="lineNum">    2655 </span>            : 
<span class="lineNum">    2656 </span>            :   /* Verify that cpp_interpret_string works.
<span class="lineNum">    2657 </span>            :      The string should be encoded in the execution character
<span class="lineNum">    2658 </span>            :      set.  Assuming that that is UTF-8, we should have the following:
<span class="lineNum">    2659 </span>            :      -----------  ----  -----  -------  ----------------
<span class="lineNum">    2660 </span>            :      Byte offset  Byte  Octal  Unicode  Source Column(s)
<span class="lineNum">    2661 </span>            :      -----------  ----  -----  -------  ----------------
<span class="lineNum">    2662 </span>            :      0            0x30         '0'      10
<span class="lineNum">    2663 </span>            :      1            0x31         '1'      11
<span class="lineNum">    2664 </span>            :      2            0x32         '2'      12
<span class="lineNum">    2665 </span>            :      3            0x33         '3'      13
<span class="lineNum">    2666 </span>            :      4            0x34         '4'      14
<span class="lineNum">    2667 </span>            :      5            0xE2  \342   U+2174   15-20
<span class="lineNum">    2668 </span>            :      6            0x85  \205    (cont)  15-20
<span class="lineNum">    2669 </span>            :      7            0xB4  \264    (cont)  15-20
<span class="lineNum">    2670 </span>            :      8            0xE2  \342   U+2175   21-26
<span class="lineNum">    2671 </span>            :      9            0x85  \205    (cont)  21-26
<span class="lineNum">    2672 </span>            :      10           0xB5  \265    (cont)  21-26
<span class="lineNum">    2673 </span>            :      11           0x37         '7'      27
<span class="lineNum">    2674 </span>            :      12           0x38         '8'      28
<span class="lineNum">    2675 </span>            :      13           0x39         '9'      29
<span class="lineNum">    2676 </span>            :      14           0x00                  30 (closing quote)
<span class="lineNum">    2677 </span>            :      -----------  ----  -----  -------  ---------------.  */
<span class="lineNum">    2678 </span>            : 
<span class="lineNum">    2679 </span><span class="lineCov">         24 :   cpp_string dst_string;</span>
<span class="lineNum">    2680 </span><span class="lineCov">         24 :   const enum cpp_ttype type = CPP_STRING;</span>
<span class="lineNum">    2681 </span><span class="lineCov">         24 :   bool result = cpp_interpret_string (test.m_parser, &amp;tok-&gt;val.str, 1,</span>
<span class="lineNum">    2682 </span><span class="lineCov">         24 :                                       &amp;dst_string, type);</span>
<span class="lineNum">    2683 </span><span class="lineCov">         24 :   ASSERT_TRUE (result);</span>
<span class="lineNum">    2684 </span><span class="lineCov">         48 :   ASSERT_STREQ (&quot;01234\342\205\264\342\205\265789&quot;,</span>
<span class="lineNum">    2685 </span>            :                 (const char *)dst_string.text);
<span class="lineNum">    2686 </span><span class="lineCov">         24 :   free (const_cast &lt;unsigned char *&gt; (dst_string.text));</span>
<span class="lineNum">    2687 </span>            : 
<span class="lineNum">    2688 </span>            :   /* Verify ranges of individual characters.  This no longer includes the
<span class="lineNum">    2689 </span>            :      opening quote, but does include the closing quote.
<span class="lineNum">    2690 </span>            :      '01234'.  */
<span class="lineNum">    2691 </span><span class="lineCov">        144 :   for (int i = 0; i &lt;= 4; i++)</span>
<span class="lineNum">    2692 </span><span class="lineCov">        240 :     ASSERT_CHAR_AT_RANGE (test, tok-&gt;src_loc, type, i, 1, 10 + i, 10 + i);</span>
<span class="lineNum">    2693 </span>            :   /* U+2174.  */
<span class="lineNum">    2694 </span><span class="lineCov">         96 :   for (int i = 5; i &lt;= 7; i++)</span>
<span class="lineNum">    2695 </span><span class="lineCov">        144 :     ASSERT_CHAR_AT_RANGE (test, tok-&gt;src_loc, type, i, 1, 15, 20);</span>
<span class="lineNum">    2696 </span>            :   /* U+2175.  */
<span class="lineNum">    2697 </span><span class="lineCov">         96 :   for (int i = 8; i &lt;= 10; i++)</span>
<span class="lineNum">    2698 </span><span class="lineCov">        144 :     ASSERT_CHAR_AT_RANGE (test, tok-&gt;src_loc, type, i, 1, 21, 26);</span>
<span class="lineNum">    2699 </span>            :   /* '789' and nul terminator  */
<span class="lineNum">    2700 </span><span class="lineCov">        120 :   for (int i = 11; i &lt;= 14; i++)</span>
<span class="lineNum">    2701 </span><span class="lineCov">        192 :     ASSERT_CHAR_AT_RANGE (test, tok-&gt;src_loc, type, i, 1, 16 + i, 16 + i);</span>
<span class="lineNum">    2702 </span>            : 
<span class="lineNum">    2703 </span><span class="lineCov">         48 :   ASSERT_NUM_SUBSTRING_RANGES (test, tok-&gt;src_loc, type, 15);</span>
<span class="lineNum">    2704 </span><span class="lineCov">         24 : }</span>
<span class="lineNum">    2705 </span>            : 
<span class="lineNum">    2706 </span>            : /* Lex a string literal containing UCN 8 characters.
<span class="lineNum">    2707 </span>            :    Verify the substring location data after running cpp_interpret_string
<span class="lineNum">    2708 </span>            :    on it.  */
<a name="2709"><span class="lineNum">    2709 </span>            : </a>
<span class="lineNum">    2710 </span>            : static void
<span class="lineNum">    2711 </span><span class="lineCov">         24 : test_lexer_string_locations_ucn8 (const line_table_case &amp;case_)</span>
<span class="lineNum">    2712 </span>            : {
<span class="lineNum">    2713 </span>            :   /* Digits 0-9, expressing digits 5 and 6 as Roman numerals as UCN 8.
<span class="lineNum">    2714 </span>            :      ....................000000000.111111.1111222222.2222333333333.344444
<span class="lineNum">    2715 </span>            :      ....................123456789.012345.6789012345.6789012345678.901234  */
<span class="lineNum">    2716 </span><span class="lineCov">         24 :   const char *content = &quot;        \&quot;01234\\U00002174\\U00002175789\&quot; /* */\n&quot;;</span>
<span class="lineNum">    2717 </span><span class="lineCov">         24 :   lexer_test test (case_, content, NULL);</span>
<span class="lineNum">    2718 </span>            : 
<span class="lineNum">    2719 </span>            :   /* Verify that we get the expected token back, with the correct
<span class="lineNum">    2720 </span>            :      location information.  */
<span class="lineNum">    2721 </span><span class="lineCov">         24 :   const cpp_token *tok = test.get_token ();</span>
<span class="lineNum">    2722 </span><span class="lineCov">         24 :   ASSERT_EQ (tok-&gt;type, CPP_STRING);</span>
<span class="lineNum">    2723 </span><span class="lineCov">         24 :   ASSERT_TOKEN_AS_TEXT_EQ (test.m_parser, tok,</span>
<span class="lineNum">    2724 </span>            :                            &quot;\&quot;01234\\U00002174\\U00002175789\&quot;&quot;);
<span class="lineNum">    2725 </span>            : 
<span class="lineNum">    2726 </span>            :   /* Verify that cpp_interpret_string works.
<span class="lineNum">    2727 </span>            :      The UTF-8 encoding of the string is identical to that from
<span class="lineNum">    2728 </span>            :      the ucn4 testcase above; the only difference is the column
<span class="lineNum">    2729 </span>            :      locations.  */
<span class="lineNum">    2730 </span><span class="lineCov">         24 :   cpp_string dst_string;</span>
<span class="lineNum">    2731 </span><span class="lineCov">         24 :   const enum cpp_ttype type = CPP_STRING;</span>
<span class="lineNum">    2732 </span><span class="lineCov">         24 :   bool result = cpp_interpret_string (test.m_parser, &amp;tok-&gt;val.str, 1,</span>
<span class="lineNum">    2733 </span><span class="lineCov">         24 :                                       &amp;dst_string, type);</span>
<span class="lineNum">    2734 </span><span class="lineCov">         24 :   ASSERT_TRUE (result);</span>
<span class="lineNum">    2735 </span><span class="lineCov">         48 :   ASSERT_STREQ (&quot;01234\342\205\264\342\205\265789&quot;,</span>
<span class="lineNum">    2736 </span>            :                 (const char *)dst_string.text);
<span class="lineNum">    2737 </span><span class="lineCov">         24 :   free (const_cast &lt;unsigned char *&gt; (dst_string.text));</span>
<span class="lineNum">    2738 </span>            : 
<span class="lineNum">    2739 </span>            :   /* Verify ranges of individual characters.  This no longer includes the
<span class="lineNum">    2740 </span>            :      opening quote, but does include the closing quote.
<span class="lineNum">    2741 </span>            :      '01234'.  */
<span class="lineNum">    2742 </span><span class="lineCov">        144 :   for (int i = 0; i &lt;= 4; i++)</span>
<span class="lineNum">    2743 </span><span class="lineCov">        240 :     ASSERT_CHAR_AT_RANGE (test, tok-&gt;src_loc, type, i, 1, 10 + i, 10 + i);</span>
<span class="lineNum">    2744 </span>            :   /* U+2174.  */
<span class="lineNum">    2745 </span><span class="lineCov">         96 :   for (int i = 5; i &lt;= 7; i++)</span>
<span class="lineNum">    2746 </span><span class="lineCov">        144 :     ASSERT_CHAR_AT_RANGE (test, tok-&gt;src_loc, type, i, 1, 15, 24);</span>
<span class="lineNum">    2747 </span>            :   /* U+2175.  */
<span class="lineNum">    2748 </span><span class="lineCov">         96 :   for (int i = 8; i &lt;= 10; i++)</span>
<span class="lineNum">    2749 </span><span class="lineCov">        144 :     ASSERT_CHAR_AT_RANGE (test, tok-&gt;src_loc, type, i, 1, 25, 34);</span>
<span class="lineNum">    2750 </span>            :   /* '789' at columns 35-37  */
<span class="lineNum">    2751 </span><span class="lineCov">         96 :   for (int i = 11; i &lt;= 13; i++)</span>
<span class="lineNum">    2752 </span><span class="lineCov">        144 :     ASSERT_CHAR_AT_RANGE (test, tok-&gt;src_loc, type, i, 1, 24 + i, 24 + i);</span>
<span class="lineNum">    2753 </span>            :   /* Closing quote/nul-terminator at column 38.  */
<span class="lineNum">    2754 </span><span class="lineCov">         48 :   ASSERT_CHAR_AT_RANGE (test, tok-&gt;src_loc, type, 14, 1, 38, 38);</span>
<span class="lineNum">    2755 </span>            : 
<span class="lineNum">    2756 </span><span class="lineCov">         48 :   ASSERT_NUM_SUBSTRING_RANGES (test, tok-&gt;src_loc, type, 15);</span>
<span class="lineNum">    2757 </span><span class="lineCov">         24 : }</span>
<span class="lineNum">    2758 </span>            : 
<span class="lineNum">    2759 </span>            : /* Fetch a big-endian 32-bit value and convert to host endianness.  */
<a name="2760"><span class="lineNum">    2760 </span>            : </a>
<span class="lineNum">    2761 </span>            : static uint32_t
<span class="lineNum">    2762 </span><span class="lineNoCov">          0 : uint32_from_big_endian (const uint32_t *ptr_be_value)</span>
<span class="lineNum">    2763 </span>            : {
<span class="lineNum">    2764 </span><span class="lineCov">        192 :   const unsigned char *buf = (const unsigned char *)ptr_be_value;</span>
<span class="lineNum">    2765 </span><span class="lineCov">        192 :   return (((uint32_t) buf[0] &lt;&lt; 24)</span>
<span class="lineNum">    2766 </span><span class="lineCov">        192 :           | ((uint32_t) buf[1] &lt;&lt; 16)</span>
<span class="lineNum">    2767 </span><span class="lineCov">        192 :           | ((uint32_t) buf[2] &lt;&lt; 8)</span>
<span class="lineNum">    2768 </span><span class="lineCov">        192 :           | (uint32_t) buf[3]);</span>
<span class="lineNum">    2769 </span>            : }
<span class="lineNum">    2770 </span>            : 
<span class="lineNum">    2771 </span>            : /* Lex a wide string literal and verify that attempts to read substring
<span class="lineNum">    2772 </span>            :    location data from it fail gracefully.  */
<a name="2773"><span class="lineNum">    2773 </span>            : </a>
<span class="lineNum">    2774 </span>            : static void
<span class="lineNum">    2775 </span><span class="lineCov">         24 : test_lexer_string_locations_wide_string (const line_table_case &amp;case_)</span>
<span class="lineNum">    2776 </span>            : {
<span class="lineNum">    2777 </span>            :   /* Digits 0-9.
<span class="lineNum">    2778 </span>            :      ....................000000000.11111111112.22222222233333
<span class="lineNum">    2779 </span>            :      ....................123456789.01234567890.12345678901234  */
<span class="lineNum">    2780 </span><span class="lineCov">         24 :   const char *content = &quot;       L\&quot;0123456789\&quot; /* non-str */\n&quot;;</span>
<span class="lineNum">    2781 </span><span class="lineCov">         24 :   lexer_test test (case_, content, NULL);</span>
<span class="lineNum">    2782 </span>            : 
<span class="lineNum">    2783 </span>            :   /* Verify that we get the expected token back, with the correct
<span class="lineNum">    2784 </span>            :      location information.  */
<span class="lineNum">    2785 </span><span class="lineCov">         24 :   const cpp_token *tok = test.get_token ();</span>
<span class="lineNum">    2786 </span><span class="lineCov">         24 :   ASSERT_EQ (tok-&gt;type, CPP_WSTRING);</span>
<span class="lineNum">    2787 </span><span class="lineCov">         24 :   ASSERT_TOKEN_AS_TEXT_EQ (test.m_parser, tok, &quot;L\&quot;0123456789\&quot;&quot;);</span>
<span class="lineNum">    2788 </span>            : 
<span class="lineNum">    2789 </span>            :   /* Verify that cpp_interpret_string works, using CPP_WSTRING.  */
<span class="lineNum">    2790 </span><span class="lineCov">         24 :   cpp_string dst_string;</span>
<span class="lineNum">    2791 </span><span class="lineCov">         24 :   const enum cpp_ttype type = CPP_WSTRING;</span>
<span class="lineNum">    2792 </span><span class="lineCov">         24 :   bool result = cpp_interpret_string (test.m_parser, &amp;tok-&gt;val.str, 1,</span>
<span class="lineNum">    2793 </span><span class="lineCov">         24 :                                       &amp;dst_string, type);</span>
<span class="lineNum">    2794 </span><span class="lineCov">         24 :   ASSERT_TRUE (result);</span>
<span class="lineNum">    2795 </span>            :   /* The cpp_reader defaults to big-endian with
<span class="lineNum">    2796 </span>            :      CHAR_BIT * sizeof (int) for the wchar_precision, so dst_string should
<span class="lineNum">    2797 </span>            :      now be encoded as UTF-32BE.  */
<span class="lineNum">    2798 </span><span class="lineCov">         24 :   const uint32_t *be32_chars = (const uint32_t *)dst_string.text;</span>
<span class="lineNum">    2799 </span><span class="lineCov">         24 :   ASSERT_EQ ('0', uint32_from_big_endian (&amp;be32_chars[0]));</span>
<span class="lineNum">    2800 </span><span class="lineCov">         24 :   ASSERT_EQ ('5', uint32_from_big_endian (&amp;be32_chars[5]));</span>
<span class="lineNum">    2801 </span><span class="lineCov">         24 :   ASSERT_EQ ('9', uint32_from_big_endian (&amp;be32_chars[9]));</span>
<span class="lineNum">    2802 </span><span class="lineCov">         24 :   ASSERT_EQ (0, uint32_from_big_endian (&amp;be32_chars[10]));</span>
<span class="lineNum">    2803 </span><span class="lineCov">         24 :   free (const_cast &lt;unsigned char *&gt; (dst_string.text));</span>
<span class="lineNum">    2804 </span>            : 
<span class="lineNum">    2805 </span>            :   /* We don't yet support generating substring location information
<span class="lineNum">    2806 </span>            :      for L&quot;&quot; strings.  */
<span class="lineNum">    2807 </span><span class="lineCov">         48 :   ASSERT_HAS_NO_SUBSTRING_RANGES</span>
<span class="lineNum">    2808 </span>            :     (test, tok-&gt;src_loc, type,
<span class="lineNum">    2809 </span>            :      &quot;execution character set != source character set&quot;);
<span class="lineNum">    2810 </span><span class="lineCov">         24 : }</span>
<span class="lineNum">    2811 </span>            : 
<span class="lineNum">    2812 </span>            : /* Fetch a big-endian 16-bit value and convert to host endianness.  */
<a name="2813"><span class="lineNum">    2813 </span>            : </a>
<span class="lineNum">    2814 </span>            : static uint16_t
<span class="lineNum">    2815 </span><span class="lineNoCov">          0 : uint16_from_big_endian (const uint16_t *ptr_be_value)</span>
<span class="lineNum">    2816 </span>            : {
<span class="lineNum">    2817 </span><span class="lineCov">         96 :   const unsigned char *buf = (const unsigned char *)ptr_be_value;</span>
<span class="lineNum">    2818 </span><span class="lineCov">         96 :   return ((uint16_t) buf[0] &lt;&lt; 8) | (uint16_t) buf[1];</span>
<span class="lineNum">    2819 </span>            : }
<span class="lineNum">    2820 </span>            : 
<span class="lineNum">    2821 </span>            : /* Lex a u&quot;&quot; string literal and verify that attempts to read substring
<span class="lineNum">    2822 </span>            :    location data from it fail gracefully.  */
<a name="2823"><span class="lineNum">    2823 </span>            : </a>
<span class="lineNum">    2824 </span>            : static void
<span class="lineNum">    2825 </span><span class="lineCov">         24 : test_lexer_string_locations_string16 (const line_table_case &amp;case_)</span>
<span class="lineNum">    2826 </span>            : {
<span class="lineNum">    2827 </span>            :   /* Digits 0-9.
<span class="lineNum">    2828 </span>            :      ....................000000000.11111111112.22222222233333
<span class="lineNum">    2829 </span>            :      ....................123456789.01234567890.12345678901234  */
<span class="lineNum">    2830 </span><span class="lineCov">         24 :   const char *content = &quot;       u\&quot;0123456789\&quot; /* non-str */\n&quot;;</span>
<span class="lineNum">    2831 </span><span class="lineCov">         24 :   lexer_test test (case_, content, NULL);</span>
<span class="lineNum">    2832 </span>            : 
<span class="lineNum">    2833 </span>            :   /* Verify that we get the expected token back, with the correct
<span class="lineNum">    2834 </span>            :      location information.  */
<span class="lineNum">    2835 </span><span class="lineCov">         24 :   const cpp_token *tok = test.get_token ();</span>
<span class="lineNum">    2836 </span><span class="lineCov">         24 :   ASSERT_EQ (tok-&gt;type, CPP_STRING16);</span>
<span class="lineNum">    2837 </span><span class="lineCov">         24 :   ASSERT_TOKEN_AS_TEXT_EQ (test.m_parser, tok, &quot;u\&quot;0123456789\&quot;&quot;);</span>
<span class="lineNum">    2838 </span>            : 
<span class="lineNum">    2839 </span>            :   /* Verify that cpp_interpret_string works, using CPP_STRING16.  */
<span class="lineNum">    2840 </span><span class="lineCov">         24 :   cpp_string dst_string;</span>
<span class="lineNum">    2841 </span><span class="lineCov">         24 :   const enum cpp_ttype type = CPP_STRING16;</span>
<span class="lineNum">    2842 </span><span class="lineCov">         24 :   bool result = cpp_interpret_string (test.m_parser, &amp;tok-&gt;val.str, 1,</span>
<span class="lineNum">    2843 </span><span class="lineCov">         24 :                                       &amp;dst_string, type);</span>
<span class="lineNum">    2844 </span><span class="lineCov">         24 :   ASSERT_TRUE (result);</span>
<span class="lineNum">    2845 </span>            : 
<span class="lineNum">    2846 </span>            :   /* The cpp_reader defaults to big-endian, so dst_string should
<span class="lineNum">    2847 </span>            :      now be encoded as UTF-16BE.  */
<span class="lineNum">    2848 </span><span class="lineCov">         24 :   const uint16_t *be16_chars = (const uint16_t *)dst_string.text;</span>
<span class="lineNum">    2849 </span><span class="lineCov">         24 :   ASSERT_EQ ('0', uint16_from_big_endian (&amp;be16_chars[0]));</span>
<span class="lineNum">    2850 </span><span class="lineCov">         24 :   ASSERT_EQ ('5', uint16_from_big_endian (&amp;be16_chars[5]));</span>
<span class="lineNum">    2851 </span><span class="lineCov">         24 :   ASSERT_EQ ('9', uint16_from_big_endian (&amp;be16_chars[9]));</span>
<span class="lineNum">    2852 </span><span class="lineCov">         24 :   ASSERT_EQ (0, uint16_from_big_endian (&amp;be16_chars[10]));</span>
<span class="lineNum">    2853 </span><span class="lineCov">         24 :   free (const_cast &lt;unsigned char *&gt; (dst_string.text));</span>
<span class="lineNum">    2854 </span>            : 
<span class="lineNum">    2855 </span>            :   /* We don't yet support generating substring location information
<span class="lineNum">    2856 </span>            :      for L&quot;&quot; strings.  */
<span class="lineNum">    2857 </span><span class="lineCov">         48 :   ASSERT_HAS_NO_SUBSTRING_RANGES</span>
<span class="lineNum">    2858 </span>            :     (test, tok-&gt;src_loc, type,
<span class="lineNum">    2859 </span>            :      &quot;execution character set != source character set&quot;);
<span class="lineNum">    2860 </span><span class="lineCov">         24 : }</span>
<span class="lineNum">    2861 </span>            : 
<span class="lineNum">    2862 </span>            : /* Lex a U&quot;&quot; string literal and verify that attempts to read substring
<span class="lineNum">    2863 </span>            :    location data from it fail gracefully.  */
<a name="2864"><span class="lineNum">    2864 </span>            : </a>
<span class="lineNum">    2865 </span>            : static void
<span class="lineNum">    2866 </span><span class="lineCov">         24 : test_lexer_string_locations_string32 (const line_table_case &amp;case_)</span>
<span class="lineNum">    2867 </span>            : {
<span class="lineNum">    2868 </span>            :   /* Digits 0-9.
<span class="lineNum">    2869 </span>            :      ....................000000000.11111111112.22222222233333
<span class="lineNum">    2870 </span>            :      ....................123456789.01234567890.12345678901234  */
<span class="lineNum">    2871 </span><span class="lineCov">         24 :   const char *content = &quot;       U\&quot;0123456789\&quot; /* non-str */\n&quot;;</span>
<span class="lineNum">    2872 </span><span class="lineCov">         24 :   lexer_test test (case_, content, NULL);</span>
<span class="lineNum">    2873 </span>            : 
<span class="lineNum">    2874 </span>            :   /* Verify that we get the expected token back, with the correct
<span class="lineNum">    2875 </span>            :      location information.  */
<span class="lineNum">    2876 </span><span class="lineCov">         24 :   const cpp_token *tok = test.get_token ();</span>
<span class="lineNum">    2877 </span><span class="lineCov">         24 :   ASSERT_EQ (tok-&gt;type, CPP_STRING32);</span>
<span class="lineNum">    2878 </span><span class="lineCov">         24 :   ASSERT_TOKEN_AS_TEXT_EQ (test.m_parser, tok, &quot;U\&quot;0123456789\&quot;&quot;);</span>
<span class="lineNum">    2879 </span>            : 
<span class="lineNum">    2880 </span>            :   /* Verify that cpp_interpret_string works, using CPP_STRING32.  */
<span class="lineNum">    2881 </span><span class="lineCov">         24 :   cpp_string dst_string;</span>
<span class="lineNum">    2882 </span><span class="lineCov">         24 :   const enum cpp_ttype type = CPP_STRING32;</span>
<span class="lineNum">    2883 </span><span class="lineCov">         24 :   bool result = cpp_interpret_string (test.m_parser, &amp;tok-&gt;val.str, 1,</span>
<span class="lineNum">    2884 </span><span class="lineCov">         24 :                                       &amp;dst_string, type);</span>
<span class="lineNum">    2885 </span><span class="lineCov">         24 :   ASSERT_TRUE (result);</span>
<span class="lineNum">    2886 </span>            : 
<span class="lineNum">    2887 </span>            :   /* The cpp_reader defaults to big-endian, so dst_string should
<span class="lineNum">    2888 </span>            :      now be encoded as UTF-32BE.  */
<span class="lineNum">    2889 </span><span class="lineCov">         24 :   const uint32_t *be32_chars = (const uint32_t *)dst_string.text;</span>
<span class="lineNum">    2890 </span><span class="lineCov">         24 :   ASSERT_EQ ('0', uint32_from_big_endian (&amp;be32_chars[0]));</span>
<span class="lineNum">    2891 </span><span class="lineCov">         24 :   ASSERT_EQ ('5', uint32_from_big_endian (&amp;be32_chars[5]));</span>
<span class="lineNum">    2892 </span><span class="lineCov">         24 :   ASSERT_EQ ('9', uint32_from_big_endian (&amp;be32_chars[9]));</span>
<span class="lineNum">    2893 </span><span class="lineCov">         24 :   ASSERT_EQ (0, uint32_from_big_endian (&amp;be32_chars[10]));</span>
<span class="lineNum">    2894 </span><span class="lineCov">         24 :   free (const_cast &lt;unsigned char *&gt; (dst_string.text));</span>
<span class="lineNum">    2895 </span>            : 
<span class="lineNum">    2896 </span>            :   /* We don't yet support generating substring location information
<span class="lineNum">    2897 </span>            :      for L&quot;&quot; strings.  */
<span class="lineNum">    2898 </span><span class="lineCov">         48 :   ASSERT_HAS_NO_SUBSTRING_RANGES</span>
<span class="lineNum">    2899 </span>            :     (test, tok-&gt;src_loc, type,
<span class="lineNum">    2900 </span>            :      &quot;execution character set != source character set&quot;);
<span class="lineNum">    2901 </span><span class="lineCov">         24 : }</span>
<span class="lineNum">    2902 </span>            : 
<span class="lineNum">    2903 </span>            : /* Lex a u8-string literal.
<span class="lineNum">    2904 </span>            :    Verify the substring location data after running cpp_interpret_string
<span class="lineNum">    2905 </span>            :    on it.  */
<a name="2906"><span class="lineNum">    2906 </span>            : </a>
<span class="lineNum">    2907 </span>            : static void
<span class="lineNum">    2908 </span><span class="lineCov">         24 : test_lexer_string_locations_u8 (const line_table_case &amp;case_)</span>
<span class="lineNum">    2909 </span>            : {
<span class="lineNum">    2910 </span>            :   /* Digits 0-9.
<span class="lineNum">    2911 </span>            :      ....................000000000.11111111112.22222222233333
<span class="lineNum">    2912 </span>            :      ....................123456789.01234567890.12345678901234  */
<span class="lineNum">    2913 </span><span class="lineCov">         24 :   const char *content = &quot;      u8\&quot;0123456789\&quot; /* non-str */\n&quot;;</span>
<span class="lineNum">    2914 </span><span class="lineCov">         48 :   lexer_test test (case_, content, NULL);</span>
<span class="lineNum">    2915 </span>            : 
<span class="lineNum">    2916 </span>            :   /* Verify that we get the expected token back, with the correct
<span class="lineNum">    2917 </span>            :      location information.  */
<span class="lineNum">    2918 </span><span class="lineCov">         24 :   const cpp_token *tok = test.get_token ();</span>
<span class="lineNum">    2919 </span><span class="lineCov">         24 :   ASSERT_EQ (tok-&gt;type, CPP_UTF8STRING);</span>
<span class="lineNum">    2920 </span><span class="lineCov">         24 :   ASSERT_TOKEN_AS_TEXT_EQ (test.m_parser, tok, &quot;u8\&quot;0123456789\&quot;&quot;);</span>
<span class="lineNum">    2921 </span>            : 
<span class="lineNum">    2922 </span>            :   /* Verify that cpp_interpret_string works.  */
<span class="lineNum">    2923 </span><span class="lineCov">         24 :   cpp_string dst_string;</span>
<span class="lineNum">    2924 </span><span class="lineCov">         24 :   const enum cpp_ttype type = CPP_STRING;</span>
<span class="lineNum">    2925 </span><span class="lineCov">         24 :   bool result = cpp_interpret_string (test.m_parser, &amp;tok-&gt;val.str, 1,</span>
<span class="lineNum">    2926 </span><span class="lineCov">         24 :                                       &amp;dst_string, type);</span>
<span class="lineNum">    2927 </span><span class="lineCov">         24 :   ASSERT_TRUE (result);</span>
<span class="lineNum">    2928 </span><span class="lineCov">         48 :   ASSERT_STREQ (&quot;0123456789&quot;, (const char *)dst_string.text);</span>
<span class="lineNum">    2929 </span><span class="lineCov">         24 :   free (const_cast &lt;unsigned char *&gt; (dst_string.text));</span>
<span class="lineNum">    2930 </span>            : 
<span class="lineNum">    2931 </span>            :   /* Verify ranges of individual characters.  This no longer includes the
<span class="lineNum">    2932 </span>            :      opening quote, but does include the closing quote.  */
<span class="lineNum">    2933 </span><span class="lineCov">        288 :   for (int i = 0; i &lt;= 10; i++)</span>
<span class="lineNum">    2934 </span><span class="lineCov">        528 :     ASSERT_CHAR_AT_RANGE (test, tok-&gt;src_loc, type, i, 1, 10 + i, 10 + i);</span>
<span class="lineNum">    2935 </span><span class="lineCov">         24 : }</span>
<span class="lineNum">    2936 </span>            : 
<span class="lineNum">    2937 </span>            : /* Lex a string literal containing UTF-8 source characters.
<span class="lineNum">    2938 </span>            :    Verify the substring location data after running cpp_interpret_string
<span class="lineNum">    2939 </span>            :    on it.  */
<a name="2940"><span class="lineNum">    2940 </span>            : </a>
<span class="lineNum">    2941 </span>            : static void
<span class="lineNum">    2942 </span><span class="lineCov">         24 : test_lexer_string_locations_utf8_source (const line_table_case &amp;case_)</span>
<span class="lineNum">    2943 </span>            : {
<span class="lineNum">    2944 </span>            :  /* This string literal is written out to the source file as UTF-8,
<span class="lineNum">    2945 </span>            :     and is of the form &quot;before mojibake after&quot;, where &quot;mojibake&quot;
<span class="lineNum">    2946 </span>            :     is written as the following four unicode code points:
<span class="lineNum">    2947 </span>            :        U+6587 CJK UNIFIED IDEOGRAPH-6587
<span class="lineNum">    2948 </span>            :        U+5B57 CJK UNIFIED IDEOGRAPH-5B57
<span class="lineNum">    2949 </span>            :        U+5316 CJK UNIFIED IDEOGRAPH-5316
<span class="lineNum">    2950 </span>            :        U+3051 HIRAGANA LETTER KE.
<span class="lineNum">    2951 </span>            :      Each of these is 3 bytes wide when encoded in UTF-8, whereas the
<span class="lineNum">    2952 </span>            :      &quot;before&quot; and &quot;after&quot; are 1 byte per unicode character.
<span class="lineNum">    2953 </span>            : 
<span class="lineNum">    2954 </span>            :      The numbering shown are &quot;columns&quot;, which are *byte* numbers within
<span class="lineNum">    2955 </span>            :      the line, rather than unicode character numbers.
<span class="lineNum">    2956 </span>            : 
<span class="lineNum">    2957 </span>            :      .................... 000000000.1111111.
<span class="lineNum">    2958 </span>            :      .................... 123456789.0123456.  */
<span class="lineNum">    2959 </span><span class="lineCov">         24 :   const char *content = (&quot;        \&quot;before &quot;</span>
<span class="lineNum">    2960 </span>            :                          /* U+6587 CJK UNIFIED IDEOGRAPH-6587
<span class="lineNum">    2961 </span>            :                               UTF-8: 0xE6 0x96 0x87
<span class="lineNum">    2962 </span>            :                               C octal escaped UTF-8: \346\226\207
<span class="lineNum">    2963 </span>            :                             &quot;column&quot; numbers: 17-19.  */
<span class="lineNum">    2964 </span>            :                          &quot;\346\226\207&quot;
<span class="lineNum">    2965 </span>            : 
<span class="lineNum">    2966 </span>            :                          /* U+5B57 CJK UNIFIED IDEOGRAPH-5B57
<span class="lineNum">    2967 </span>            :                               UTF-8: 0xE5 0xAD 0x97
<span class="lineNum">    2968 </span>            :                               C octal escaped UTF-8: \345\255\227
<span class="lineNum">    2969 </span>            :                             &quot;column&quot; numbers: 20-22.  */
<span class="lineNum">    2970 </span>            :                          &quot;\345\255\227&quot;
<span class="lineNum">    2971 </span>            : 
<span class="lineNum">    2972 </span>            :                          /* U+5316 CJK UNIFIED IDEOGRAPH-5316
<span class="lineNum">    2973 </span>            :                               UTF-8: 0xE5 0x8C 0x96
<span class="lineNum">    2974 </span>            :                               C octal escaped UTF-8: \345\214\226
<span class="lineNum">    2975 </span>            :                             &quot;column&quot; numbers: 23-25.  */
<span class="lineNum">    2976 </span>            :                          &quot;\345\214\226&quot;
<span class="lineNum">    2977 </span>            : 
<span class="lineNum">    2978 </span>            :                          /* U+3051 HIRAGANA LETTER KE
<span class="lineNum">    2979 </span>            :                               UTF-8: 0xE3 0x81 0x91
<span class="lineNum">    2980 </span>            :                               C octal escaped UTF-8: \343\201\221
<span class="lineNum">    2981 </span>            :                             &quot;column&quot; numbers: 26-28.  */
<span class="lineNum">    2982 </span>            :                          &quot;\343\201\221&quot;
<span class="lineNum">    2983 </span>            : 
<span class="lineNum">    2984 </span>            :                          /* column numbers 29 onwards
<span class="lineNum">    2985 </span>            :                           2333333.33334444444444
<span class="lineNum">    2986 </span>            :                           9012345.67890123456789. */
<span class="lineNum">    2987 </span>            :                          &quot; after\&quot; /* non-str */\n&quot;);
<span class="lineNum">    2988 </span><span class="lineCov">         24 :   lexer_test test (case_, content, NULL);</span>
<span class="lineNum">    2989 </span>            : 
<span class="lineNum">    2990 </span>            :   /* Verify that we get the expected token back, with the correct
<span class="lineNum">    2991 </span>            :      location information.  */
<span class="lineNum">    2992 </span><span class="lineCov">         24 :   const cpp_token *tok = test.get_token ();</span>
<span class="lineNum">    2993 </span><span class="lineCov">         24 :   ASSERT_EQ (tok-&gt;type, CPP_STRING);</span>
<span class="lineNum">    2994 </span><span class="lineCov">         24 :   ASSERT_TOKEN_AS_TEXT_EQ</span>
<span class="lineNum">    2995 </span>            :     (test.m_parser, tok,
<span class="lineNum">    2996 </span>            :      &quot;\&quot;before \346\226\207\345\255\227\345\214\226\343\201\221 after\&quot;&quot;);
<span class="lineNum">    2997 </span>            : 
<span class="lineNum">    2998 </span>            :   /* Verify that cpp_interpret_string works.  */
<span class="lineNum">    2999 </span><span class="lineCov">         24 :   cpp_string dst_string;</span>
<span class="lineNum">    3000 </span><span class="lineCov">         24 :   const enum cpp_ttype type = CPP_STRING;</span>
<span class="lineNum">    3001 </span><span class="lineCov">         24 :   bool result = cpp_interpret_string (test.m_parser, &amp;tok-&gt;val.str, 1,</span>
<span class="lineNum">    3002 </span><span class="lineCov">         24 :                                       &amp;dst_string, type);</span>
<span class="lineNum">    3003 </span><span class="lineCov">         24 :   ASSERT_TRUE (result);</span>
<span class="lineNum">    3004 </span><span class="lineCov">         48 :   ASSERT_STREQ</span>
<span class="lineNum">    3005 </span>            :     (&quot;before \346\226\207\345\255\227\345\214\226\343\201\221 after&quot;,
<span class="lineNum">    3006 </span>            :      (const char *)dst_string.text);
<span class="lineNum">    3007 </span><span class="lineCov">         24 :   free (const_cast &lt;unsigned char *&gt; (dst_string.text));</span>
<span class="lineNum">    3008 </span>            : 
<span class="lineNum">    3009 </span>            :   /* Verify ranges of individual characters.  This no longer includes the
<span class="lineNum">    3010 </span>            :      opening quote, but does include the closing quote.
<span class="lineNum">    3011 </span>            :      Assuming that both source and execution encodings are UTF-8, we have
<span class="lineNum">    3012 </span>            :      a run of 25 octets in each, plus the NUL terminator.  */
<span class="lineNum">    3013 </span><span class="lineCov">        624 :   for (int i = 0; i &lt; 25; i++)</span>
<span class="lineNum">    3014 </span><span class="lineCov">       1200 :     ASSERT_CHAR_AT_RANGE (test, tok-&gt;src_loc, type, i, 1, 10 + i, 10 + i);</span>
<span class="lineNum">    3015 </span>            :   /* NUL-terminator should use the closing quote at column 35.  */
<span class="lineNum">    3016 </span><span class="lineCov">         48 :   ASSERT_CHAR_AT_RANGE (test, tok-&gt;src_loc, type, 25, 1, 35, 35);</span>
<span class="lineNum">    3017 </span>            : 
<span class="lineNum">    3018 </span><span class="lineCov">         48 :   ASSERT_NUM_SUBSTRING_RANGES (test, tok-&gt;src_loc, type, 26);</span>
<span class="lineNum">    3019 </span><span class="lineCov">         24 : }</span>
<span class="lineNum">    3020 </span>            : 
<span class="lineNum">    3021 </span>            : /* Test of string literal concatenation.  */
<a name="3022"><span class="lineNum">    3022 </span>            : </a>
<span class="lineNum">    3023 </span>            : static void
<span class="lineNum">    3024 </span><span class="lineCov">         24 : test_lexer_string_locations_concatenation_1 (const line_table_case &amp;case_)</span>
<span class="lineNum">    3025 </span>            : {
<span class="lineNum">    3026 </span>            :   /* Digits 0-9.
<span class="lineNum">    3027 </span>            :      .....................000000000.111111.11112222222222
<span class="lineNum">    3028 </span>            :      .....................123456789.012345.67890123456789.  */
<span class="lineNum">    3029 </span><span class="lineCov">         24 :   const char *content = (&quot;        \&quot;01234\&quot; /* non-str */\n&quot;</span>
<span class="lineNum">    3030 </span>            :                          &quot;        \&quot;56789\&quot; /* non-str */\n&quot;);
<span class="lineNum">    3031 </span><span class="lineCov">         24 :   lexer_test test (case_, content, NULL);</span>
<span class="lineNum">    3032 </span>            : 
<span class="lineNum">    3033 </span><span class="lineCov">         24 :   location_t input_locs[2];</span>
<span class="lineNum">    3034 </span>            : 
<span class="lineNum">    3035 </span>            :   /* Verify that we get the expected tokens back.  */
<span class="lineNum">    3036 </span><span class="lineCov">         48 :   auto_vec &lt;cpp_string&gt; input_strings;</span>
<span class="lineNum">    3037 </span><span class="lineCov">         24 :   const cpp_token *tok_a = test.get_token ();</span>
<span class="lineNum">    3038 </span><span class="lineCov">         24 :   ASSERT_EQ (tok_a-&gt;type, CPP_STRING);</span>
<span class="lineNum">    3039 </span><span class="lineCov">         24 :   ASSERT_TOKEN_AS_TEXT_EQ (test.m_parser, tok_a, &quot;\&quot;01234\&quot;&quot;);</span>
<span class="lineNum">    3040 </span><span class="lineCov">         24 :   input_strings.safe_push (tok_a-&gt;val.str);</span>
<span class="lineNum">    3041 </span><span class="lineCov">         24 :   input_locs[0] = tok_a-&gt;src_loc;</span>
<span class="lineNum">    3042 </span>            : 
<span class="lineNum">    3043 </span><span class="lineCov">         24 :   const cpp_token *tok_b = test.get_token ();</span>
<span class="lineNum">    3044 </span><span class="lineCov">         24 :   ASSERT_EQ (tok_b-&gt;type, CPP_STRING);</span>
<span class="lineNum">    3045 </span><span class="lineCov">         24 :   ASSERT_TOKEN_AS_TEXT_EQ (test.m_parser, tok_b, &quot;\&quot;56789\&quot;&quot;);</span>
<span class="lineNum">    3046 </span><span class="lineCov">         24 :   input_strings.safe_push (tok_b-&gt;val.str);</span>
<span class="lineNum">    3047 </span><span class="lineCov">         24 :   input_locs[1] = tok_b-&gt;src_loc;</span>
<span class="lineNum">    3048 </span>            : 
<span class="lineNum">    3049 </span>            :   /* Verify that cpp_interpret_string works.  */
<span class="lineNum">    3050 </span><span class="lineCov">         24 :   cpp_string dst_string;</span>
<span class="lineNum">    3051 </span><span class="lineCov">         24 :   const enum cpp_ttype type = CPP_STRING;</span>
<span class="lineNum">    3052 </span><span class="lineCov">         24 :   bool result = cpp_interpret_string (test.m_parser,</span>
<span class="lineNum">    3053 </span><span class="lineCov">         24 :                                       input_strings.address (), 2,</span>
<span class="lineNum">    3054 </span><span class="lineCov">         24 :                                       &amp;dst_string, type);</span>
<span class="lineNum">    3055 </span><span class="lineCov">         24 :   ASSERT_TRUE (result);</span>
<span class="lineNum">    3056 </span><span class="lineCov">         48 :   ASSERT_STREQ (&quot;0123456789&quot;, (const char *)dst_string.text);</span>
<span class="lineNum">    3057 </span><span class="lineCov">         24 :   free (const_cast &lt;unsigned char *&gt; (dst_string.text));</span>
<span class="lineNum">    3058 </span>            : 
<span class="lineNum">    3059 </span>            :   /* Simulate c-lex.c's lex_string in order to record concatenation.  */
<span class="lineNum">    3060 </span><span class="lineCov">         24 :   test.m_concats.record_string_concatenation (2, input_locs);</span>
<span class="lineNum">    3061 </span>            : 
<span class="lineNum">    3062 </span><span class="lineCov">         24 :   location_t initial_loc = input_locs[0];</span>
<span class="lineNum">    3063 </span>            : 
<span class="lineNum">    3064 </span>            :   /* &quot;01234&quot; on line 1.  */
<span class="lineNum">    3065 </span><span class="lineCov">        144 :   for (int i = 0; i &lt;= 4; i++)</span>
<span class="lineNum">    3066 </span><span class="lineCov">        240 :     ASSERT_CHAR_AT_RANGE (test, initial_loc, type, i, 1, 10 + i, 10 + i);</span>
<span class="lineNum">    3067 </span>            :   /* &quot;56789&quot; in line 2, plus its closing quote for the nul terminator.  */
<span class="lineNum">    3068 </span><span class="lineCov">        168 :   for (int i = 5; i &lt;= 10; i++)</span>
<span class="lineNum">    3069 </span><span class="lineCov">        288 :     ASSERT_CHAR_AT_RANGE (test, initial_loc, type, i, 2, 5 + i, 5 + i);</span>
<span class="lineNum">    3070 </span>            : 
<span class="lineNum">    3071 </span><span class="lineCov">         48 :   ASSERT_NUM_SUBSTRING_RANGES (test, initial_loc, type, 11);</span>
<span class="lineNum">    3072 </span><span class="lineCov">         24 : }</span>
<span class="lineNum">    3073 </span>            : 
<span class="lineNum">    3074 </span>            : /* Another test of string literal concatenation.  */
<a name="3075"><span class="lineNum">    3075 </span>            : </a>
<span class="lineNum">    3076 </span>            : static void
<span class="lineNum">    3077 </span><span class="lineCov">         24 : test_lexer_string_locations_concatenation_2 (const line_table_case &amp;case_)</span>
<span class="lineNum">    3078 </span>            : {
<span class="lineNum">    3079 </span>            :   /* Digits 0-9.
<span class="lineNum">    3080 </span>            :      .....................000000000.111.11111112222222
<span class="lineNum">    3081 </span>            :      .....................123456789.012.34567890123456.  */
<span class="lineNum">    3082 </span><span class="lineCov">         24 :   const char *content = (&quot;        \&quot;01\&quot; /* non-str */\n&quot;</span>
<span class="lineNum">    3083 </span>            :                          &quot;        \&quot;23\&quot; /* non-str */\n&quot;
<span class="lineNum">    3084 </span>            :                          &quot;        \&quot;45\&quot; /* non-str */\n&quot;
<span class="lineNum">    3085 </span>            :                          &quot;        \&quot;67\&quot; /* non-str */\n&quot;
<span class="lineNum">    3086 </span>            :                          &quot;        \&quot;89\&quot; /* non-str */\n&quot;);
<span class="lineNum">    3087 </span><span class="lineCov">         24 :   lexer_test test (case_, content, NULL);</span>
<span class="lineNum">    3088 </span>            : 
<span class="lineNum">    3089 </span><span class="lineCov">         46 :   auto_vec &lt;cpp_string&gt; input_strings;</span>
<span class="lineNum">    3090 </span><span class="lineCov">         24 :   location_t input_locs[5];</span>
<span class="lineNum">    3091 </span>            : 
<span class="lineNum">    3092 </span>            :   /* Verify that we get the expected tokens back.  */
<span class="lineNum">    3093 </span><span class="lineCov">        144 :   for (int i = 0; i &lt; 5; i++)</span>
<span class="lineNum">    3094 </span>            :     {
<span class="lineNum">    3095 </span><span class="lineCov">        120 :       const cpp_token *tok = test.get_token ();</span>
<span class="lineNum">    3096 </span><span class="lineCov">        120 :       ASSERT_EQ (tok-&gt;type, CPP_STRING);</span>
<span class="lineNum">    3097 </span><span class="lineCov">        120 :       input_strings.safe_push (tok-&gt;val.str);</span>
<span class="lineNum">    3098 </span><span class="lineCov">        120 :       input_locs[i] = tok-&gt;src_loc;</span>
<span class="lineNum">    3099 </span>            :     }
<span class="lineNum">    3100 </span>            : 
<span class="lineNum">    3101 </span>            :   /* Verify that cpp_interpret_string works.  */
<span class="lineNum">    3102 </span><span class="lineCov">         24 :   cpp_string dst_string;</span>
<span class="lineNum">    3103 </span><span class="lineCov">         24 :   const enum cpp_ttype type = CPP_STRING;</span>
<span class="lineNum">    3104 </span><span class="lineCov">         24 :   bool result = cpp_interpret_string (test.m_parser,</span>
<span class="lineNum">    3105 </span><span class="lineCov">         24 :                                       input_strings.address (), 5,</span>
<span class="lineNum">    3106 </span><span class="lineCov">         24 :                                       &amp;dst_string, type);</span>
<span class="lineNum">    3107 </span><span class="lineCov">         24 :   ASSERT_TRUE (result);</span>
<span class="lineNum">    3108 </span><span class="lineCov">         48 :   ASSERT_STREQ (&quot;0123456789&quot;, (const char *)dst_string.text);</span>
<span class="lineNum">    3109 </span><span class="lineCov">         24 :   free (const_cast &lt;unsigned char *&gt; (dst_string.text));</span>
<span class="lineNum">    3110 </span>            : 
<span class="lineNum">    3111 </span>            :   /* Simulate c-lex.c's lex_string in order to record concatenation.  */
<span class="lineNum">    3112 </span><span class="lineCov">         24 :   test.m_concats.record_string_concatenation (5, input_locs);</span>
<span class="lineNum">    3113 </span>            : 
<span class="lineNum">    3114 </span><span class="lineCov">         24 :   location_t initial_loc = input_locs[0];</span>
<span class="lineNum">    3115 </span>            : 
<span class="lineNum">    3116 </span>            :   /* Within ASSERT_CHAR_AT_RANGE (actually assert_char_at_range), we can
<span class="lineNum">    3117 </span>            :      detect if the initial loc is after LINE_MAP_MAX_LOCATION_WITH_COLS
<span class="lineNum">    3118 </span>            :      and expect get_source_range_for_substring to fail.
<span class="lineNum">    3119 </span>            :      However, for a string concatenation test, we can have a case
<span class="lineNum">    3120 </span>            :      where the initial string is fully before LINE_MAP_MAX_LOCATION_WITH_COLS,
<span class="lineNum">    3121 </span>            :      but subsequent strings can be after it.
<span class="lineNum">    3122 </span>            :      Attempting to detect this within assert_char_at_range
<span class="lineNum">    3123 </span>            :      would overcomplicate the logic for the common test cases, so
<span class="lineNum">    3124 </span>            :      we detect it here.  */
<span class="lineNum">    3125 </span><span class="lineCov">         24 :   if (should_have_column_data_p (input_locs[0])</span>
<span class="lineNum">    3126 </span><span class="lineCov">         16 :       &amp;&amp; !should_have_column_data_p (input_locs[4]))</span>
<span class="lineNum">    3127 </span>            :     {
<span class="lineNum">    3128 </span>            :       /* Verify that get_source_range_for_substring gracefully rejects
<span class="lineNum">    3129 </span>            :          this case.  */
<span class="lineNum">    3130 </span><span class="lineCov">          2 :       source_range actual_range;</span>
<span class="lineNum">    3131 </span><span class="lineCov">          2 :       const char *err</span>
<span class="lineNum">    3132 </span><span class="lineCov">          2 :         = get_source_range_for_char (test.m_parser, &amp;test.m_concats,</span>
<span class="lineNum">    3133 </span><span class="lineCov">          2 :                                      initial_loc, type, 0, &amp;actual_range);</span>
<span class="lineNum">    3134 </span><span class="lineCov">          4 :       ASSERT_STREQ (&quot;range starts after LINE_MAP_MAX_LOCATION_WITH_COLS&quot;, err);</span>
<span class="lineNum">    3135 </span><span class="lineCov">          2 :       return;</span>
<span class="lineNum">    3136 </span>            :     }
<span class="lineNum">    3137 </span>            : 
<span class="lineNum">    3138 </span><span class="lineCov">        132 :   for (int i = 0; i &lt; 5; i++)</span>
<span class="lineNum">    3139 </span><span class="lineCov">        330 :     for (int j = 0; j &lt; 2; j++)</span>
<span class="lineNum">    3140 </span><span class="lineCov">        440 :       ASSERT_CHAR_AT_RANGE (test, initial_loc, type, (i * 2) + j,</span>
<span class="lineNum">    3141 </span>            :                             i + 1, 10 + j, 10 + j);
<span class="lineNum">    3142 </span>            : 
<span class="lineNum">    3143 </span>            :   /* NUL-terminator should use the final closing quote at line 5 column 12.  */
<span class="lineNum">    3144 </span><span class="lineCov">         44 :   ASSERT_CHAR_AT_RANGE (test, initial_loc, type, 10, 5, 12, 12);</span>
<span class="lineNum">    3145 </span>            : 
<span class="lineNum">    3146 </span><span class="lineCov">         44 :   ASSERT_NUM_SUBSTRING_RANGES (test, initial_loc, type, 11);</span>
<span class="lineNum">    3147 </span>            : }
<span class="lineNum">    3148 </span>            : 
<span class="lineNum">    3149 </span>            : /* Another test of string literal concatenation, this time combined with
<span class="lineNum">    3150 </span>            :    various kinds of escaped characters.  */
<a name="3151"><span class="lineNum">    3151 </span>            : </a>
<span class="lineNum">    3152 </span>            : static void
<span class="lineNum">    3153 </span><span class="lineCov">         24 : test_lexer_string_locations_concatenation_3 (const line_table_case &amp;case_)</span>
<span class="lineNum">    3154 </span>            : {
<span class="lineNum">    3155 </span>            :   /* Digits 0-9, expressing digit 5 in ASCII as hex &quot;\x35&quot;
<span class="lineNum">    3156 </span>            :      digit 6 in ASCII as octal &quot;\066&quot;, concatenating multiple strings.  */
<span class="lineNum">    3157 </span><span class="lineCov">         24 :   const char *content</span>
<span class="lineNum">    3158 </span>            :     /* .000000000.111111.111.1.2222.222.2.2233.333.3333.34444444444555
<span class="lineNum">    3159 </span>            :        .123456789.012345.678.9.0123.456.7.8901.234.5678.90123456789012. */
<span class="lineNum">    3160 </span>            :     = (&quot;        \&quot;01234\&quot;  \&quot;\\x35\&quot;  \&quot;\\066\&quot;  \&quot;789\&quot; /* non-str */\n&quot;);
<span class="lineNum">    3161 </span><span class="lineCov">         24 :   lexer_test test (case_, content, NULL);</span>
<span class="lineNum">    3162 </span>            : 
<span class="lineNum">    3163 </span><span class="lineCov">         48 :   auto_vec &lt;cpp_string&gt; input_strings;</span>
<span class="lineNum">    3164 </span><span class="lineCov">         24 :   location_t input_locs[4];</span>
<span class="lineNum">    3165 </span>            : 
<span class="lineNum">    3166 </span>            :   /* Verify that we get the expected tokens back.  */
<span class="lineNum">    3167 </span><span class="lineCov">        120 :   for (int i = 0; i &lt; 4; i++)</span>
<span class="lineNum">    3168 </span>            :     {
<span class="lineNum">    3169 </span><span class="lineCov">         96 :       const cpp_token *tok = test.get_token ();</span>
<span class="lineNum">    3170 </span><span class="lineCov">         96 :       ASSERT_EQ (tok-&gt;type, CPP_STRING);</span>
<span class="lineNum">    3171 </span><span class="lineCov">         96 :       input_strings.safe_push (tok-&gt;val.str);</span>
<span class="lineNum">    3172 </span><span class="lineCov">         96 :       input_locs[i] = tok-&gt;src_loc;</span>
<span class="lineNum">    3173 </span>            :     }
<span class="lineNum">    3174 </span>            : 
<span class="lineNum">    3175 </span>            :   /* Verify that cpp_interpret_string works.  */
<span class="lineNum">    3176 </span><span class="lineCov">         24 :   cpp_string dst_string;</span>
<span class="lineNum">    3177 </span><span class="lineCov">         24 :   const enum cpp_ttype type = CPP_STRING;</span>
<span class="lineNum">    3178 </span><span class="lineCov">         24 :   bool result = cpp_interpret_string (test.m_parser,</span>
<span class="lineNum">    3179 </span><span class="lineCov">         24 :                                       input_strings.address (), 4,</span>
<span class="lineNum">    3180 </span><span class="lineCov">         24 :                                       &amp;dst_string, type);</span>
<span class="lineNum">    3181 </span><span class="lineCov">         24 :   ASSERT_TRUE (result);</span>
<span class="lineNum">    3182 </span><span class="lineCov">         48 :   ASSERT_STREQ (&quot;0123456789&quot;, (const char *)dst_string.text);</span>
<span class="lineNum">    3183 </span><span class="lineCov">         24 :   free (const_cast &lt;unsigned char *&gt; (dst_string.text));</span>
<span class="lineNum">    3184 </span>            : 
<span class="lineNum">    3185 </span>            :   /* Simulate c-lex.c's lex_string in order to record concatenation.  */
<span class="lineNum">    3186 </span><span class="lineCov">         24 :   test.m_concats.record_string_concatenation (4, input_locs);</span>
<span class="lineNum">    3187 </span>            : 
<span class="lineNum">    3188 </span><span class="lineCov">         24 :   location_t initial_loc = input_locs[0];</span>
<span class="lineNum">    3189 </span>            : 
<span class="lineNum">    3190 </span><span class="lineCov">        144 :   for (int i = 0; i &lt;= 4; i++)</span>
<span class="lineNum">    3191 </span><span class="lineCov">        240 :     ASSERT_CHAR_AT_RANGE (test, initial_loc, type, i, 1, 10 + i, 10 + i);</span>
<span class="lineNum">    3192 </span><span class="lineCov">         48 :   ASSERT_CHAR_AT_RANGE (test, initial_loc, type, 5, 1, 19, 22);</span>
<span class="lineNum">    3193 </span><span class="lineCov">         48 :   ASSERT_CHAR_AT_RANGE (test, initial_loc, type, 6, 1, 27, 30);</span>
<span class="lineNum">    3194 </span><span class="lineCov">         96 :   for (int i = 7; i &lt;= 9; i++)</span>
<span class="lineNum">    3195 </span><span class="lineCov">        144 :     ASSERT_CHAR_AT_RANGE (test, initial_loc, type, i, 1, 28 + i, 28 + i);</span>
<span class="lineNum">    3196 </span>            : 
<span class="lineNum">    3197 </span>            :   /* NUL-terminator should use the location of the final closing quote.  */
<span class="lineNum">    3198 </span><span class="lineCov">         48 :   ASSERT_CHAR_AT_RANGE (test, initial_loc, type, 10, 1, 38, 38);</span>
<span class="lineNum">    3199 </span>            : 
<span class="lineNum">    3200 </span><span class="lineCov">         48 :   ASSERT_NUM_SUBSTRING_RANGES (test, initial_loc, type, 11);</span>
<span class="lineNum">    3201 </span><span class="lineCov">         24 : }</span>
<span class="lineNum">    3202 </span>            : 
<span class="lineNum">    3203 </span>            : /* Test of string literal in a macro.  */
<a name="3204"><span class="lineNum">    3204 </span>            : </a>
<span class="lineNum">    3205 </span>            : static void
<span class="lineNum">    3206 </span><span class="lineCov">         24 : test_lexer_string_locations_macro (const line_table_case &amp;case_)</span>
<span class="lineNum">    3207 </span>            : {
<span class="lineNum">    3208 </span>            :   /* Digits 0-9.
<span class="lineNum">    3209 </span>            :      .....................0000000001111111111.22222222223.
<span class="lineNum">    3210 </span>            :      .....................1234567890123456789.01234567890.  */
<span class="lineNum">    3211 </span><span class="lineCov">         24 :   const char *content = (&quot;#define MACRO     \&quot;0123456789\&quot; /* non-str */\n&quot;</span>
<span class="lineNum">    3212 </span>            :                          &quot;  MACRO&quot;);
<span class="lineNum">    3213 </span><span class="lineCov">         24 :   lexer_test test (case_, content, NULL);</span>
<span class="lineNum">    3214 </span>            : 
<span class="lineNum">    3215 </span>            :   /* Verify that we get the expected tokens back.  */
<span class="lineNum">    3216 </span><span class="lineCov">         24 :   const cpp_token *tok = test.get_token ();</span>
<span class="lineNum">    3217 </span><span class="lineCov">         24 :   ASSERT_EQ (tok-&gt;type, CPP_PADDING);</span>
<span class="lineNum">    3218 </span>            : 
<span class="lineNum">    3219 </span><span class="lineCov">         24 :   tok = test.get_token ();</span>
<span class="lineNum">    3220 </span><span class="lineCov">         24 :   ASSERT_EQ (tok-&gt;type, CPP_STRING);</span>
<span class="lineNum">    3221 </span><span class="lineCov">         24 :   ASSERT_TOKEN_AS_TEXT_EQ (test.m_parser, tok, &quot;\&quot;0123456789\&quot;&quot;);</span>
<span class="lineNum">    3222 </span>            : 
<span class="lineNum">    3223 </span>            :   /* Verify ranges of individual characters.  We ought to
<span class="lineNum">    3224 </span>            :      see columns within the macro definition.  */
<span class="lineNum">    3225 </span><span class="lineCov">        288 :   for (int i = 0; i &lt;= 10; i++)</span>
<span class="lineNum">    3226 </span><span class="lineCov">        528 :     ASSERT_CHAR_AT_RANGE (test, tok-&gt;src_loc, CPP_STRING,</span>
<span class="lineNum">    3227 </span>            :                           i, 1, 20 + i, 20 + i);
<span class="lineNum">    3228 </span>            : 
<span class="lineNum">    3229 </span><span class="lineCov">         48 :   ASSERT_NUM_SUBSTRING_RANGES (test, tok-&gt;src_loc, CPP_STRING, 11);</span>
<span class="lineNum">    3230 </span>            : 
<span class="lineNum">    3231 </span><span class="lineCov">         24 :   tok = test.get_token ();</span>
<span class="lineNum">    3232 </span><span class="lineCov">         24 :   ASSERT_EQ (tok-&gt;type, CPP_PADDING);</span>
<span class="lineNum">    3233 </span><span class="lineCov">         24 : }</span>
<span class="lineNum">    3234 </span>            : 
<span class="lineNum">    3235 </span>            : /* Test of stringification of a macro argument.  */
<a name="3236"><span class="lineNum">    3236 </span>            : </a>
<span class="lineNum">    3237 </span>            : static void
<span class="lineNum">    3238 </span><span class="lineCov">         24 : test_lexer_string_locations_stringified_macro_argument</span>
<span class="lineNum">    3239 </span>            :   (const line_table_case &amp;case_)
<span class="lineNum">    3240 </span>            : {
<span class="lineNum">    3241 </span>            :   /* .....................000000000111111111122222222223.
<span class="lineNum">    3242 </span>            :      .....................123456789012345678901234567890.  */
<span class="lineNum">    3243 </span><span class="lineCov">         24 :   const char *content = (&quot;#define MACRO(X) #X /* non-str */\n&quot;</span>
<span class="lineNum">    3244 </span>            :                          &quot;MACRO(foo)\n&quot;);
<span class="lineNum">    3245 </span><span class="lineCov">         24 :   lexer_test test (case_, content, NULL);</span>
<span class="lineNum">    3246 </span>            : 
<span class="lineNum">    3247 </span>            :   /* Verify that we get the expected token back.  */
<span class="lineNum">    3248 </span><span class="lineCov">         24 :   const cpp_token *tok = test.get_token ();</span>
<span class="lineNum">    3249 </span><span class="lineCov">         24 :   ASSERT_EQ (tok-&gt;type, CPP_PADDING);</span>
<span class="lineNum">    3250 </span>            : 
<span class="lineNum">    3251 </span><span class="lineCov">         24 :   tok = test.get_token ();</span>
<span class="lineNum">    3252 </span><span class="lineCov">         24 :   ASSERT_EQ (tok-&gt;type, CPP_STRING);</span>
<span class="lineNum">    3253 </span><span class="lineCov">         24 :   ASSERT_TOKEN_AS_TEXT_EQ (test.m_parser, tok, &quot;\&quot;foo\&quot;&quot;);</span>
<span class="lineNum">    3254 </span>            : 
<span class="lineNum">    3255 </span>            :   /* We don't support getting the location of a stringified macro
<span class="lineNum">    3256 </span>            :      argument.  Verify that it fails gracefully.  */
<span class="lineNum">    3257 </span><span class="lineCov">         48 :   ASSERT_HAS_NO_SUBSTRING_RANGES (test, tok-&gt;src_loc, CPP_STRING,</span>
<span class="lineNum">    3258 </span>            :                                   &quot;cpp_interpret_string_1 failed&quot;);
<span class="lineNum">    3259 </span>            : 
<span class="lineNum">    3260 </span><span class="lineCov">         24 :   tok = test.get_token ();</span>
<span class="lineNum">    3261 </span><span class="lineCov">         24 :   ASSERT_EQ (tok-&gt;type, CPP_PADDING);</span>
<span class="lineNum">    3262 </span>            : 
<span class="lineNum">    3263 </span><span class="lineCov">         24 :   tok = test.get_token ();</span>
<span class="lineNum">    3264 </span><span class="lineCov">         24 :   ASSERT_EQ (tok-&gt;type, CPP_PADDING);</span>
<span class="lineNum">    3265 </span><span class="lineCov">         24 : }</span>
<span class="lineNum">    3266 </span>            : 
<span class="lineNum">    3267 </span>            : /* Ensure that we are fail gracefully if something attempts to pass
<span class="lineNum">    3268 </span>            :    in a location that isn't a string literal token.  Seen on this code:
<span class="lineNum">    3269 </span>            : 
<span class="lineNum">    3270 </span>            :      const char a[] = &quot; %d &quot;;
<span class="lineNum">    3271 </span>            :      __builtin_printf (a, 0.5);
<span class="lineNum">    3272 </span>            :                        ^
<span class="lineNum">    3273 </span>            : 
<span class="lineNum">    3274 </span>            :    when c-format.c erroneously used the indicated one-character
<span class="lineNum">    3275 </span>            :    location as the format string location, leading to a read past the
<span class="lineNum">    3276 </span>            :    end of a string buffer in cpp_interpret_string_1.  */
<a name="3277"><span class="lineNum">    3277 </span>            : </a>
<span class="lineNum">    3278 </span>            : static void
<span class="lineNum">    3279 </span><span class="lineCov">         24 : test_lexer_string_locations_non_string (const line_table_case &amp;case_)</span>
<span class="lineNum">    3280 </span>            : {
<span class="lineNum">    3281 </span>            :   /* .....................000000000111111111122222222223.
<span class="lineNum">    3282 </span>            :      .....................123456789012345678901234567890.  */
<span class="lineNum">    3283 </span><span class="lineCov">         24 :   const char *content = (&quot;         a\n&quot;);</span>
<span class="lineNum">    3284 </span><span class="lineCov">         24 :   lexer_test test (case_, content, NULL);</span>
<span class="lineNum">    3285 </span>            : 
<span class="lineNum">    3286 </span>            :   /* Verify that we get the expected token back.  */
<span class="lineNum">    3287 </span><span class="lineCov">         24 :   const cpp_token *tok = test.get_token ();</span>
<span class="lineNum">    3288 </span><span class="lineCov">         24 :   ASSERT_EQ (tok-&gt;type, CPP_NAME);</span>
<span class="lineNum">    3289 </span><span class="lineCov">         24 :   ASSERT_TOKEN_AS_TEXT_EQ (test.m_parser, tok, &quot;a&quot;);</span>
<span class="lineNum">    3290 </span>            : 
<span class="lineNum">    3291 </span>            :   /* At this point, libcpp is attempting to interpret the name as a
<span class="lineNum">    3292 </span>            :      string literal, despite it not starting with a quote.  We don't detect
<span class="lineNum">    3293 </span>            :      that, but we should at least fail gracefully.  */
<span class="lineNum">    3294 </span><span class="lineCov">         48 :   ASSERT_HAS_NO_SUBSTRING_RANGES (test, tok-&gt;src_loc, CPP_STRING,</span>
<span class="lineNum">    3295 </span>            :                                   &quot;cpp_interpret_string_1 failed&quot;);
<span class="lineNum">    3296 </span><span class="lineCov">         24 : }</span>
<span class="lineNum">    3297 </span>            : 
<span class="lineNum">    3298 </span>            : /* Ensure that we can read substring information for a token which
<span class="lineNum">    3299 </span>            :    starts in one linemap and ends in another .  Adapted from
<span class="lineNum">    3300 </span>            :    gcc.dg/cpp/pr69985.c.  */
<a name="3301"><span class="lineNum">    3301 </span>            : </a>
<span class="lineNum">    3302 </span>            : static void
<span class="lineNum">    3303 </span><span class="lineCov">         24 : test_lexer_string_locations_long_line (const line_table_case &amp;case_)</span>
<span class="lineNum">    3304 </span>            : {
<span class="lineNum">    3305 </span>            :   /* .....................000000.000111111111
<span class="lineNum">    3306 </span>            :      .....................123456.789012346789.  */
<span class="lineNum">    3307 </span><span class="lineCov">         24 :   const char *content = (&quot;/* A very long line, so that we start a new line map.  */\n&quot;</span>
<span class="lineNum">    3308 </span>            :                          &quot;     \&quot;0123456789012345678901234567890123456789&quot;
<span class="lineNum">    3309 </span>            :                          &quot;0123456789012345678901234567890123456789&quot;
<span class="lineNum">    3310 </span>            :                          &quot;0123456789012345678901234567890123456789&quot;
<span class="lineNum">    3311 </span>            :                          &quot;0123456789\&quot;\n&quot;);
<span class="lineNum">    3312 </span>            : 
<span class="lineNum">    3313 </span><span class="lineCov">         38 :   lexer_test test (case_, content, NULL);</span>
<span class="lineNum">    3314 </span>            : 
<span class="lineNum">    3315 </span>            :   /* Verify that we get the expected token back.  */
<span class="lineNum">    3316 </span><span class="lineCov">         24 :   const cpp_token *tok = test.get_token ();</span>
<span class="lineNum">    3317 </span><span class="lineCov">         24 :   ASSERT_EQ (tok-&gt;type, CPP_STRING);</span>
<span class="lineNum">    3318 </span>            : 
<span class="lineNum">    3319 </span><span class="lineCov">         24 :   if (!should_have_column_data_p (line_table-&gt;highest_location))</span>
<span class="lineNum">    3320 </span><span class="lineCov">         10 :     return;</span>
<span class="lineNum">    3321 </span>            : 
<span class="lineNum">    3322 </span>            :   /* Verify ranges of individual characters.  */
<span class="lineNum">    3323 </span><span class="lineCov">         28 :   ASSERT_NUM_SUBSTRING_RANGES (test, tok-&gt;src_loc, CPP_STRING, 131);</span>
<span class="lineNum">    3324 </span><span class="lineCov">       1848 :   for (int i = 0; i &lt; 131; i++)</span>
<span class="lineNum">    3325 </span><span class="lineCov">       3668 :     ASSERT_CHAR_AT_RANGE (test, tok-&gt;src_loc, CPP_STRING,</span>
<span class="lineNum">    3326 </span>            :                           i, 2, 7 + i, 7 + i);
<span class="lineNum">    3327 </span>            : }
<span class="lineNum">    3328 </span>            : 
<span class="lineNum">    3329 </span>            : /* Test of locations within a raw string that doesn't contain a newline.  */
<a name="3330"><span class="lineNum">    3330 </span>            : </a>
<span class="lineNum">    3331 </span>            : static void
<span class="lineNum">    3332 </span><span class="lineCov">         24 : test_lexer_string_locations_raw_string_one_line (const line_table_case &amp;case_)</span>
<span class="lineNum">    3333 </span>            : {
<span class="lineNum">    3334 </span>            :   /* .....................00.0000000111111111122.
<span class="lineNum">    3335 </span>            :      .....................12.3456789012345678901.  */
<span class="lineNum">    3336 </span><span class="lineCov">         24 :   const char *content = (&quot;R\&quot;foo(0123456789)foo\&quot;\n&quot;);</span>
<span class="lineNum">    3337 </span><span class="lineCov">         40 :   lexer_test test (case_, content, NULL);</span>
<span class="lineNum">    3338 </span>            : 
<span class="lineNum">    3339 </span>            :   /* Verify that we get the expected token back.  */
<span class="lineNum">    3340 </span><span class="lineCov">         24 :   const cpp_token *tok = test.get_token ();</span>
<span class="lineNum">    3341 </span><span class="lineCov">         24 :   ASSERT_EQ (tok-&gt;type, CPP_STRING);</span>
<span class="lineNum">    3342 </span>            : 
<span class="lineNum">    3343 </span>            :   /* Verify that cpp_interpret_string works.  */
<span class="lineNum">    3344 </span><span class="lineCov">         24 :   cpp_string dst_string;</span>
<span class="lineNum">    3345 </span><span class="lineCov">         24 :   const enum cpp_ttype type = CPP_STRING;</span>
<span class="lineNum">    3346 </span><span class="lineCov">         24 :   bool result = cpp_interpret_string (test.m_parser, &amp;tok-&gt;val.str, 1,</span>
<span class="lineNum">    3347 </span><span class="lineCov">         24 :                                       &amp;dst_string, type);</span>
<span class="lineNum">    3348 </span><span class="lineCov">         24 :   ASSERT_TRUE (result);</span>
<span class="lineNum">    3349 </span><span class="lineCov">         48 :   ASSERT_STREQ (&quot;0123456789&quot;, (const char *)dst_string.text);</span>
<span class="lineNum">    3350 </span><span class="lineCov">         24 :   free (const_cast &lt;unsigned char *&gt; (dst_string.text));</span>
<span class="lineNum">    3351 </span>            : 
<span class="lineNum">    3352 </span><span class="lineCov">         24 :   if (!should_have_column_data_p (line_table-&gt;highest_location))</span>
<span class="lineNum">    3353 </span><span class="lineCov">          8 :     return;</span>
<span class="lineNum">    3354 </span>            : 
<span class="lineNum">    3355 </span>            :   /* 0-9, plus the nil terminator.  */
<span class="lineNum">    3356 </span><span class="lineCov">         32 :   ASSERT_NUM_SUBSTRING_RANGES (test, tok-&gt;src_loc, CPP_STRING, 11);</span>
<span class="lineNum">    3357 </span><span class="lineCov">        192 :   for (int i = 0; i &lt; 11; i++)</span>
<span class="lineNum">    3358 </span><span class="lineCov">        352 :     ASSERT_CHAR_AT_RANGE (test, tok-&gt;src_loc, CPP_STRING,</span>
<span class="lineNum">    3359 </span>            :                           i, 1, 7 + i, 7 + i);
<span class="lineNum">    3360 </span>            : }
<span class="lineNum">    3361 </span>            : 
<span class="lineNum">    3362 </span>            : /* Test of locations within a raw string that contains a newline.  */
<a name="3363"><span class="lineNum">    3363 </span>            : </a>
<span class="lineNum">    3364 </span>            : static void
<span class="lineNum">    3365 </span><span class="lineCov">         24 : test_lexer_string_locations_raw_string_multiline (const line_table_case &amp;case_)</span>
<span class="lineNum">    3366 </span>            : {
<span class="lineNum">    3367 </span>            :   /* .....................00.0000.
<span class="lineNum">    3368 </span>            :      .....................12.3456.  */
<span class="lineNum">    3369 </span><span class="lineCov">         24 :   const char *content = (&quot;R\&quot;foo(\n&quot;</span>
<span class="lineNum">    3370 </span>            :   /* .....................00000.
<span class="lineNum">    3371 </span>            :      .....................12345.  */
<span class="lineNum">    3372 </span>            :                          &quot;hello\n&quot;
<span class="lineNum">    3373 </span>            :                          &quot;world\n&quot;
<span class="lineNum">    3374 </span>            :   /* .....................00000.
<span class="lineNum">    3375 </span>            :      .....................12345.  */
<span class="lineNum">    3376 </span>            :                          &quot;)foo\&quot;\n&quot;);
<span class="lineNum">    3377 </span><span class="lineCov">         24 :   lexer_test test (case_, content, NULL);</span>
<span class="lineNum">    3378 </span>            : 
<span class="lineNum">    3379 </span>            :   /* Verify that we get the expected token back.  */
<span class="lineNum">    3380 </span><span class="lineCov">         24 :   const cpp_token *tok = test.get_token ();</span>
<span class="lineNum">    3381 </span><span class="lineCov">         24 :   ASSERT_EQ (tok-&gt;type, CPP_STRING);</span>
<span class="lineNum">    3382 </span>            : 
<span class="lineNum">    3383 </span>            :   /* Verify that cpp_interpret_string works.  */
<span class="lineNum">    3384 </span><span class="lineCov">         24 :   cpp_string dst_string;</span>
<span class="lineNum">    3385 </span><span class="lineCov">         24 :   const enum cpp_ttype type = CPP_STRING;</span>
<span class="lineNum">    3386 </span><span class="lineCov">         24 :   bool result = cpp_interpret_string (test.m_parser, &amp;tok-&gt;val.str, 1,</span>
<span class="lineNum">    3387 </span><span class="lineCov">         24 :                                       &amp;dst_string, type);</span>
<span class="lineNum">    3388 </span><span class="lineCov">         24 :   ASSERT_TRUE (result);</span>
<span class="lineNum">    3389 </span><span class="lineCov">         48 :   ASSERT_STREQ (&quot;\nhello\nworld\n&quot;, (const char *)dst_string.text);</span>
<span class="lineNum">    3390 </span><span class="lineCov">         24 :   free (const_cast &lt;unsigned char *&gt; (dst_string.text));</span>
<span class="lineNum">    3391 </span>            : 
<span class="lineNum">    3392 </span><span class="lineCov">         24 :   if (!should_have_column_data_p (line_table-&gt;highest_location))</span>
<span class="lineNum">    3393 </span><span class="lineCov">         10 :     return;</span>
<span class="lineNum">    3394 </span>            : 
<span class="lineNum">    3395 </span>            :   /* Currently we don't support locations within raw strings that
<span class="lineNum">    3396 </span>            :      contain newlines.  */
<span class="lineNum">    3397 </span><span class="lineCov">         28 :   ASSERT_HAS_NO_SUBSTRING_RANGES (test, tok-&gt;src_loc, tok-&gt;type,</span>
<span class="lineNum">    3398 </span>            :                                   &quot;range endpoints are on different lines&quot;);
<span class="lineNum">    3399 </span>            : }
<span class="lineNum">    3400 </span>            : 
<span class="lineNum">    3401 </span>            : /* Test of parsing an unterminated raw string.  */
<a name="3402"><span class="lineNum">    3402 </span>            : </a>
<span class="lineNum">    3403 </span>            : static void
<span class="lineNum">    3404 </span><span class="lineCov">         24 : test_lexer_string_locations_raw_string_unterminated (const line_table_case &amp;case_)</span>
<span class="lineNum">    3405 </span>            : {
<span class="lineNum">    3406 </span><span class="lineCov">         24 :   const char *content = &quot;R\&quot;ouch()ouCh\&quot; /* etc */&quot;;</span>
<span class="lineNum">    3407 </span>            : 
<span class="lineNum">    3408 </span><span class="lineCov">         48 :   lexer_error_sink errors;</span>
<span class="lineNum">    3409 </span><span class="lineCov">         24 :   lexer_test test (case_, content, &amp;errors);</span>
<span class="lineNum">    3410 </span><span class="lineCov">         24 :   test.m_implicitly_expect_EOF = false;</span>
<span class="lineNum">    3411 </span>            : 
<span class="lineNum">    3412 </span>            :   /* Attempt to parse the raw string.  */
<span class="lineNum">    3413 </span><span class="lineCov">         24 :   const cpp_token *tok = test.get_token ();</span>
<span class="lineNum">    3414 </span><span class="lineCov">         24 :   ASSERT_EQ (tok-&gt;type, CPP_EOF);</span>
<span class="lineNum">    3415 </span>            : 
<span class="lineNum">    3416 </span><span class="lineCov">         24 :   ASSERT_EQ (1, errors.m_errors.length ());</span>
<span class="lineNum">    3417 </span>            :   /* We expect the message &quot;unterminated raw string&quot;
<span class="lineNum">    3418 </span>            :      in the &quot;cpplib&quot; translation domain.
<span class="lineNum">    3419 </span>            :      It's not clear that dgettext is available on all supported hosts,
<span class="lineNum">    3420 </span>            :      so this assertion is commented-out for now.
<span class="lineNum">    3421 </span>            :        ASSERT_STREQ (dgettext (&quot;cpplib&quot;, &quot;unterminated raw string&quot;),
<span class="lineNum">    3422 </span>            :                      errors.m_errors[0]);
<span class="lineNum">    3423 </span>            :   */
<span class="lineNum">    3424 </span><span class="lineCov">         24 : }</span>
<span class="lineNum">    3425 </span>            : 
<span class="lineNum">    3426 </span>            : /* Test of lexing char constants.  */
<a name="3427"><span class="lineNum">    3427 </span>            : </a>
<span class="lineNum">    3428 </span>            : static void
<span class="lineNum">    3429 </span><span class="lineCov">         24 : test_lexer_char_constants (const line_table_case &amp;case_)</span>
<span class="lineNum">    3430 </span>            : {
<span class="lineNum">    3431 </span>            :   /* Various char constants.
<span class="lineNum">    3432 </span>            :      .....................0000000001111111111.22222222223.
<span class="lineNum">    3433 </span>            :      .....................1234567890123456789.01234567890.  */
<span class="lineNum">    3434 </span><span class="lineCov">         24 :   const char *content = (&quot;         'a'\n&quot;</span>
<span class="lineNum">    3435 </span>            :                          &quot;        u'a'\n&quot;
<span class="lineNum">    3436 </span>            :                          &quot;        U'a'\n&quot;
<span class="lineNum">    3437 </span>            :                          &quot;        L'a'\n&quot;
<span class="lineNum">    3438 </span>            :                          &quot;         'abc'\n&quot;);
<span class="lineNum">    3439 </span><span class="lineCov">         24 :   lexer_test test (case_, content, NULL);</span>
<span class="lineNum">    3440 </span>            : 
<span class="lineNum">    3441 </span>            :   /* Verify that we get the expected tokens back.  */
<span class="lineNum">    3442 </span>            :   /* 'a'.  */
<span class="lineNum">    3443 </span><span class="lineCov">         24 :   const cpp_token *tok = test.get_token ();</span>
<span class="lineNum">    3444 </span><span class="lineCov">         24 :   ASSERT_EQ (tok-&gt;type, CPP_CHAR);</span>
<span class="lineNum">    3445 </span><span class="lineCov">         24 :   ASSERT_TOKEN_AS_TEXT_EQ (test.m_parser, tok, &quot;'a'&quot;);</span>
<span class="lineNum">    3446 </span>            : 
<span class="lineNum">    3447 </span><span class="lineCov">         24 :   unsigned int chars_seen;</span>
<span class="lineNum">    3448 </span><span class="lineCov">         24 :   int unsignedp;</span>
<span class="lineNum">    3449 </span><span class="lineCov">         24 :   cppchar_t cc = cpp_interpret_charconst (test.m_parser, tok,</span>
<span class="lineNum">    3450 </span><span class="lineCov">         24 :                                           &amp;chars_seen, &amp;unsignedp);</span>
<span class="lineNum">    3451 </span><span class="lineCov">         24 :   ASSERT_EQ (cc, 'a');</span>
<span class="lineNum">    3452 </span><span class="lineCov">         24 :   ASSERT_EQ (chars_seen, 1);</span>
<span class="lineNum">    3453 </span>            : 
<span class="lineNum">    3454 </span>            :   /* u'a'.  */
<span class="lineNum">    3455 </span><span class="lineCov">         24 :   tok = test.get_token ();</span>
<span class="lineNum">    3456 </span><span class="lineCov">         24 :   ASSERT_EQ (tok-&gt;type, CPP_CHAR16);</span>
<span class="lineNum">    3457 </span><span class="lineCov">         24 :   ASSERT_TOKEN_AS_TEXT_EQ (test.m_parser, tok, &quot;u'a'&quot;);</span>
<span class="lineNum">    3458 </span>            : 
<span class="lineNum">    3459 </span>            :   /* U'a'.  */
<span class="lineNum">    3460 </span><span class="lineCov">         24 :   tok = test.get_token ();</span>
<span class="lineNum">    3461 </span><span class="lineCov">         24 :   ASSERT_EQ (tok-&gt;type, CPP_CHAR32);</span>
<span class="lineNum">    3462 </span><span class="lineCov">         24 :   ASSERT_TOKEN_AS_TEXT_EQ (test.m_parser, tok, &quot;U'a'&quot;);</span>
<span class="lineNum">    3463 </span>            : 
<span class="lineNum">    3464 </span>            :   /* L'a'.  */
<span class="lineNum">    3465 </span><span class="lineCov">         24 :   tok = test.get_token ();</span>
<span class="lineNum">    3466 </span><span class="lineCov">         24 :   ASSERT_EQ (tok-&gt;type, CPP_WCHAR);</span>
<span class="lineNum">    3467 </span><span class="lineCov">         24 :   ASSERT_TOKEN_AS_TEXT_EQ (test.m_parser, tok, &quot;L'a'&quot;);</span>
<span class="lineNum">    3468 </span>            : 
<span class="lineNum">    3469 </span>            :   /* 'abc' (c-char-sequence).  */
<span class="lineNum">    3470 </span><span class="lineCov">         24 :   tok = test.get_token ();</span>
<span class="lineNum">    3471 </span><span class="lineCov">         24 :   ASSERT_EQ (tok-&gt;type, CPP_CHAR);</span>
<span class="lineNum">    3472 </span><span class="lineCov">         24 :   ASSERT_TOKEN_AS_TEXT_EQ (test.m_parser, tok, &quot;'abc'&quot;);</span>
<span class="lineNum">    3473 </span><span class="lineCov">         24 : }</span>
<span class="lineNum">    3474 </span>            : /* A table of interesting location_t values, giving one axis of our test
<span class="lineNum">    3475 </span>            :    matrix.  */
<span class="lineNum">    3476 </span>            : 
<span class="lineNum">    3477 </span>            : static const location_t boundary_locations[] = {
<span class="lineNum">    3478 </span>            :   /* Zero means &quot;don't override the default values for a new line_table&quot;.  */
<span class="lineNum">    3479 </span>            :   0,
<span class="lineNum">    3480 </span>            : 
<span class="lineNum">    3481 </span>            :   /* An arbitrary non-zero value that isn't close to one of
<span class="lineNum">    3482 </span>            :      the boundary values below.  */
<span class="lineNum">    3483 </span>            :   0x10000,
<span class="lineNum">    3484 </span>            : 
<span class="lineNum">    3485 </span>            :   /* Values near LINE_MAP_MAX_LOCATION_WITH_PACKED_RANGES.  */
<span class="lineNum">    3486 </span>            :   LINE_MAP_MAX_LOCATION_WITH_PACKED_RANGES - 0x100,
<span class="lineNum">    3487 </span>            :   LINE_MAP_MAX_LOCATION_WITH_PACKED_RANGES - 1,
<span class="lineNum">    3488 </span>            :   LINE_MAP_MAX_LOCATION_WITH_PACKED_RANGES,
<span class="lineNum">    3489 </span>            :   LINE_MAP_MAX_LOCATION_WITH_PACKED_RANGES + 1,
<span class="lineNum">    3490 </span>            :   LINE_MAP_MAX_LOCATION_WITH_PACKED_RANGES + 0x100,
<span class="lineNum">    3491 </span>            : 
<span class="lineNum">    3492 </span>            :   /* Values near LINE_MAP_MAX_LOCATION_WITH_COLS.  */
<span class="lineNum">    3493 </span>            :   LINE_MAP_MAX_LOCATION_WITH_COLS - 0x100,
<span class="lineNum">    3494 </span>            :   LINE_MAP_MAX_LOCATION_WITH_COLS - 1,
<span class="lineNum">    3495 </span>            :   LINE_MAP_MAX_LOCATION_WITH_COLS,
<span class="lineNum">    3496 </span>            :   LINE_MAP_MAX_LOCATION_WITH_COLS + 1,
<span class="lineNum">    3497 </span>            :   LINE_MAP_MAX_LOCATION_WITH_COLS + 0x100,
<span class="lineNum">    3498 </span>            : };
<span class="lineNum">    3499 </span>            : 
<span class="lineNum">    3500 </span>            : /* Run TESTCASE multiple times, once for each case in our test matrix.  */
<a name="3501"><span class="lineNum">    3501 </span>            : </a>
<span class="lineNum">    3502 </span>            : void
<span class="lineNum">    3503 </span><span class="lineCov">         52 : for_each_line_table_case (void (*testcase) (const line_table_case &amp;))</span>
<span class="lineNum">    3504 </span>            : {
<span class="lineNum">    3505 </span>            :   /* As noted above in the description of struct line_table_case,
<span class="lineNum">    3506 </span>            :      we want to explore a test matrix of interesting line_table
<span class="lineNum">    3507 </span>            :      situations, running various selftests for each case within the
<span class="lineNum">    3508 </span>            :      matrix.  */
<span class="lineNum">    3509 </span>            : 
<span class="lineNum">    3510 </span>            :   /* Run all tests with:
<span class="lineNum">    3511 </span>            :      (a) line_table-&gt;default_range_bits == 0, and
<span class="lineNum">    3512 </span>            :      (b) line_table-&gt;default_range_bits == 5.  */
<span class="lineNum">    3513 </span><span class="lineCov">         52 :   int num_cases_tested = 0;</span>
<span class="lineNum">    3514 </span><span class="lineCov">        156 :   for (int default_range_bits = 0; default_range_bits &lt;= 5;</span>
<span class="lineNum">    3515 </span><span class="lineCov">        104 :        default_range_bits += 5)</span>
<span class="lineNum">    3516 </span>            :     {
<span class="lineNum">    3517 </span>            :       /* ...and use each of the &quot;interesting&quot; location values as
<span class="lineNum">    3518 </span>            :          the starting location within line_table.  */
<span class="lineNum">    3519 </span>            :       const int num_boundary_locations
<span class="lineNum">    3520 </span>            :         = sizeof (boundary_locations) / sizeof (boundary_locations[0]);
<span class="lineNum">    3521 </span><span class="lineCov">       1352 :       for (int loc_idx = 0; loc_idx &lt; num_boundary_locations; loc_idx++)</span>
<span class="lineNum">    3522 </span>            :         {
<span class="lineNum">    3523 </span><span class="lineCov">       2496 :           line_table_case c (default_range_bits, boundary_locations[loc_idx]);</span>
<span class="lineNum">    3524 </span>            : 
<span class="lineNum">    3525 </span><span class="lineCov">       1248 :           testcase (c);</span>
<span class="lineNum">    3526 </span>            : 
<span class="lineNum">    3527 </span><span class="lineCov">       1248 :           num_cases_tested++;</span>
<span class="lineNum">    3528 </span>            :         }
<span class="lineNum">    3529 </span>            :     }
<span class="lineNum">    3530 </span>            : 
<span class="lineNum">    3531 </span>            :   /* Verify that we fully covered the test matrix.  */
<span class="lineNum">    3532 </span><span class="lineCov">         52 :   ASSERT_EQ (num_cases_tested, 2 * 12);</span>
<span class="lineNum">    3533 </span><span class="lineCov">         52 : }</span>
<span class="lineNum">    3534 </span>            : 
<span class="lineNum">    3535 </span>            : /* Run all of the selftests within this file.  */
<a name="3536"><span class="lineNum">    3536 </span>            : </a>
<span class="lineNum">    3537 </span>            : void
<span class="lineNum">    3538 </span><span class="lineCov">          1 : input_c_tests ()</span>
<span class="lineNum">    3539 </span>            : {
<span class="lineNum">    3540 </span><span class="lineCov">          1 :   test_linenum_comparisons ();</span>
<span class="lineNum">    3541 </span><span class="lineCov">          1 :   test_should_have_column_data_p ();</span>
<span class="lineNum">    3542 </span><span class="lineCov">          1 :   test_unknown_location ();</span>
<span class="lineNum">    3543 </span><span class="lineCov">          1 :   test_builtins ();</span>
<span class="lineNum">    3544 </span><span class="lineCov">          1 :   for_each_line_table_case (test_make_location_nonpure_range_endpoints);</span>
<span class="lineNum">    3545 </span>            : 
<span class="lineNum">    3546 </span><span class="lineCov">          1 :   for_each_line_table_case (test_accessing_ordinary_linemaps);</span>
<span class="lineNum">    3547 </span><span class="lineCov">          1 :   for_each_line_table_case (test_lexer);</span>
<span class="lineNum">    3548 </span><span class="lineCov">          1 :   for_each_line_table_case (test_lexer_string_locations_simple);</span>
<span class="lineNum">    3549 </span><span class="lineCov">          1 :   for_each_line_table_case (test_lexer_string_locations_ebcdic);</span>
<span class="lineNum">    3550 </span><span class="lineCov">          1 :   for_each_line_table_case (test_lexer_string_locations_hex);</span>
<span class="lineNum">    3551 </span><span class="lineCov">          1 :   for_each_line_table_case (test_lexer_string_locations_oct);</span>
<span class="lineNum">    3552 </span><span class="lineCov">          1 :   for_each_line_table_case (test_lexer_string_locations_letter_escape_1);</span>
<span class="lineNum">    3553 </span><span class="lineCov">          1 :   for_each_line_table_case (test_lexer_string_locations_letter_escape_2);</span>
<span class="lineNum">    3554 </span><span class="lineCov">          1 :   for_each_line_table_case (test_lexer_string_locations_ucn4);</span>
<span class="lineNum">    3555 </span><span class="lineCov">          1 :   for_each_line_table_case (test_lexer_string_locations_ucn8);</span>
<span class="lineNum">    3556 </span><span class="lineCov">          1 :   for_each_line_table_case (test_lexer_string_locations_wide_string);</span>
<span class="lineNum">    3557 </span><span class="lineCov">          1 :   for_each_line_table_case (test_lexer_string_locations_string16);</span>
<span class="lineNum">    3558 </span><span class="lineCov">          1 :   for_each_line_table_case (test_lexer_string_locations_string32);</span>
<span class="lineNum">    3559 </span><span class="lineCov">          1 :   for_each_line_table_case (test_lexer_string_locations_u8);</span>
<span class="lineNum">    3560 </span><span class="lineCov">          1 :   for_each_line_table_case (test_lexer_string_locations_utf8_source);</span>
<span class="lineNum">    3561 </span><span class="lineCov">          1 :   for_each_line_table_case (test_lexer_string_locations_concatenation_1);</span>
<span class="lineNum">    3562 </span><span class="lineCov">          1 :   for_each_line_table_case (test_lexer_string_locations_concatenation_2);</span>
<span class="lineNum">    3563 </span><span class="lineCov">          1 :   for_each_line_table_case (test_lexer_string_locations_concatenation_3);</span>
<span class="lineNum">    3564 </span><span class="lineCov">          1 :   for_each_line_table_case (test_lexer_string_locations_macro);</span>
<span class="lineNum">    3565 </span><span class="lineCov">          1 :   for_each_line_table_case (test_lexer_string_locations_stringified_macro_argument);</span>
<span class="lineNum">    3566 </span><span class="lineCov">          1 :   for_each_line_table_case (test_lexer_string_locations_non_string);</span>
<span class="lineNum">    3567 </span><span class="lineCov">          1 :   for_each_line_table_case (test_lexer_string_locations_long_line);</span>
<span class="lineNum">    3568 </span><span class="lineCov">          1 :   for_each_line_table_case (test_lexer_string_locations_raw_string_one_line);</span>
<span class="lineNum">    3569 </span><span class="lineCov">          1 :   for_each_line_table_case (test_lexer_string_locations_raw_string_multiline);</span>
<span class="lineNum">    3570 </span><span class="lineCov">          1 :   for_each_line_table_case (test_lexer_string_locations_raw_string_unterminated);</span>
<span class="lineNum">    3571 </span><span class="lineCov">          1 :   for_each_line_table_case (test_lexer_char_constants);</span>
<span class="lineNum">    3572 </span>            : 
<span class="lineNum">    3573 </span><span class="lineCov">          1 :   test_reading_source_line ();</span>
<span class="lineNum">    3574 </span><span class="lineCov">          1 : }</span>
<span class="lineNum">    3575 </span>            : 
<span class="lineNum">    3576 </span>            : } // namespace selftest
<span class="lineNum">    3577 </span>            : 
<span class="lineNum">    3578 </span>            : #endif /* CHECKING_P */
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.0</a></td></tr>
  </table>
  <br>
<h3>LCOV profile is generated on x86_64 machine using following configure options: configure --disable-bootstrap --enable-coverage=opt --enable-languages=c,c++,fortran,go,jit,lto --enable-host-shared. GCC test suite is run with the built compiler.</h3></body></html>
