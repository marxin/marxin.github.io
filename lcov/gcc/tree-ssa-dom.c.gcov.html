<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - gcc.info - gcc/tree-ssa-dom.c</title>
  <link rel="stylesheet" type="text/css" href="../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../index.html">top level</a> - <a href="index.html">gcc</a> - tree-ssa-dom.c<span style="font-size: 80%;"> (source / <a href="tree-ssa-dom.c.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">gcc.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">836</td>
            <td class="headerCovTableEntry">862</td>
            <td class="headerCovTableEntryHi">97.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2018-09-22 10:58:49</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">31</td>
            <td class="headerCovTableEntry">31</td>
            <td class="headerCovTableEntryHi">100.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /* SSA Dominator optimizations for trees</a>
<span class="lineNum">       2 </span>            :    Copyright (C) 2001-2018 Free Software Foundation, Inc.
<span class="lineNum">       3 </span>            :    Contributed by Diego Novillo &lt;dnovillo@redhat.com&gt;
<span class="lineNum">       4 </span>            : 
<span class="lineNum">       5 </span>            : This file is part of GCC.
<span class="lineNum">       6 </span>            : 
<span class="lineNum">       7 </span>            : GCC is free software; you can redistribute it and/or modify
<span class="lineNum">       8 </span>            : it under the terms of the GNU General Public License as published by
<span class="lineNum">       9 </span>            : the Free Software Foundation; either version 3, or (at your option)
<span class="lineNum">      10 </span>            : any later version.
<span class="lineNum">      11 </span>            : 
<span class="lineNum">      12 </span>            : GCC is distributed in the hope that it will be useful,
<span class="lineNum">      13 </span>            : but WITHOUT ANY WARRANTY; without even the implied warranty of
<span class="lineNum">      14 </span>            : MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
<span class="lineNum">      15 </span>            : GNU General Public License for more details.
<span class="lineNum">      16 </span>            : 
<span class="lineNum">      17 </span>            : You should have received a copy of the GNU General Public License
<span class="lineNum">      18 </span>            : along with GCC; see the file COPYING3.  If not see
<span class="lineNum">      19 </span>            : &lt;http://www.gnu.org/licenses/&gt;.  */
<span class="lineNum">      20 </span>            : 
<span class="lineNum">      21 </span>            : #include &quot;config.h&quot;
<span class="lineNum">      22 </span>            : #include &quot;system.h&quot;
<span class="lineNum">      23 </span>            : #include &quot;coretypes.h&quot;
<span class="lineNum">      24 </span>            : #include &quot;backend.h&quot;
<span class="lineNum">      25 </span>            : #include &quot;tree.h&quot;
<span class="lineNum">      26 </span>            : #include &quot;gimple.h&quot;
<span class="lineNum">      27 </span>            : #include &quot;tree-pass.h&quot;
<span class="lineNum">      28 </span>            : #include &quot;ssa.h&quot;
<span class="lineNum">      29 </span>            : #include &quot;gimple-pretty-print.h&quot;
<span class="lineNum">      30 </span>            : #include &quot;fold-const.h&quot;
<span class="lineNum">      31 </span>            : #include &quot;cfganal.h&quot;
<span class="lineNum">      32 </span>            : #include &quot;cfgloop.h&quot;
<span class="lineNum">      33 </span>            : #include &quot;gimple-fold.h&quot;
<span class="lineNum">      34 </span>            : #include &quot;tree-eh.h&quot;
<span class="lineNum">      35 </span>            : #include &quot;tree-inline.h&quot;
<span class="lineNum">      36 </span>            : #include &quot;gimple-iterator.h&quot;
<span class="lineNum">      37 </span>            : #include &quot;tree-cfg.h&quot;
<span class="lineNum">      38 </span>            : #include &quot;tree-into-ssa.h&quot;
<span class="lineNum">      39 </span>            : #include &quot;domwalk.h&quot;
<span class="lineNum">      40 </span>            : #include &quot;tree-ssa-propagate.h&quot;
<span class="lineNum">      41 </span>            : #include &quot;tree-ssa-threadupdate.h&quot;
<span class="lineNum">      42 </span>            : #include &quot;params.h&quot;
<span class="lineNum">      43 </span>            : #include &quot;tree-ssa-scopedtables.h&quot;
<span class="lineNum">      44 </span>            : #include &quot;tree-ssa-threadedge.h&quot;
<span class="lineNum">      45 </span>            : #include &quot;tree-ssa-dom.h&quot;
<span class="lineNum">      46 </span>            : #include &quot;gimplify.h&quot;
<span class="lineNum">      47 </span>            : #include &quot;tree-cfgcleanup.h&quot;
<span class="lineNum">      48 </span>            : #include &quot;dbgcnt.h&quot;
<span class="lineNum">      49 </span>            : #include &quot;alloc-pool.h&quot;
<span class="lineNum">      50 </span>            : #include &quot;tree-vrp.h&quot;
<span class="lineNum">      51 </span>            : #include &quot;vr-values.h&quot;
<span class="lineNum">      52 </span>            : #include &quot;gimple-ssa-evrp-analyze.h&quot;
<span class="lineNum">      53 </span>            : 
<span class="lineNum">      54 </span>            : /* This file implements optimizations on the dominator tree.  */
<span class="lineNum">      55 </span>            : 
<span class="lineNum">      56 </span>            : /* Structure for recording edge equivalences.
<span class="lineNum">      57 </span>            : 
<span class="lineNum">      58 </span>            :    Computing and storing the edge equivalences instead of creating
<span class="lineNum">      59 </span>            :    them on-demand can save significant amounts of time, particularly
<span class="lineNum">      60 </span>            :    for pathological cases involving switch statements.
<span class="lineNum">      61 </span>            : 
<span class="lineNum">      62 </span>            :    These structures live for a single iteration of the dominator
<span class="lineNum">      63 </span>            :    optimizer in the edge's AUX field.  At the end of an iteration we
<span class="lineNum">      64 </span>            :    free each of these structures.  */
<span class="lineNum">      65 </span>            : class edge_info
<span class="lineNum">      66 </span>            : {
<span class="lineNum">      67 </span>            :  public:
<span class="lineNum">      68 </span>            :   typedef std::pair &lt;tree, tree&gt; equiv_pair;
<span class="lineNum">      69 </span>            :   edge_info (edge);
<span class="lineNum">      70 </span>            :   ~edge_info ();
<span class="lineNum">      71 </span>            : 
<span class="lineNum">      72 </span>            :   /* Record a simple LHS = RHS equivalence.  This may trigger
<span class="lineNum">      73 </span>            :      calls to derive_equivalences.  */
<span class="lineNum">      74 </span>            :   void record_simple_equiv (tree, tree);
<span class="lineNum">      75 </span>            : 
<span class="lineNum">      76 </span>            :   /* If traversing this edge creates simple equivalences, we store
<span class="lineNum">      77 </span>            :      them as LHS/RHS pairs within this vector.  */
<span class="lineNum">      78 </span>            :   vec&lt;equiv_pair&gt; simple_equivalences;
<span class="lineNum">      79 </span>            : 
<span class="lineNum">      80 </span>            :   /* Traversing an edge may also indicate one or more particular conditions
<span class="lineNum">      81 </span>            :      are true or false.  */
<span class="lineNum">      82 </span>            :   vec&lt;cond_equivalence&gt; cond_equivalences;
<span class="lineNum">      83 </span>            : 
<span class="lineNum">      84 </span>            :  private:
<span class="lineNum">      85 </span>            :   /* Derive equivalences by walking the use-def chains.  */
<span class="lineNum">      86 </span>            :   void derive_equivalences (tree, tree, int);
<span class="lineNum">      87 </span>            : };
<span class="lineNum">      88 </span>            : 
<span class="lineNum">      89 </span>            : /* Track whether or not we have changed the control flow graph.  */
<span class="lineNum">      90 </span>            : static bool cfg_altered;
<span class="lineNum">      91 </span>            : 
<span class="lineNum">      92 </span>            : /* Bitmap of blocks that have had EH statements cleaned.  We should
<span class="lineNum">      93 </span>            :    remove their dead edges eventually.  */
<span class="lineNum">      94 </span>            : static bitmap need_eh_cleanup;
<span class="lineNum">      95 </span>            : static vec&lt;gimple *&gt; need_noreturn_fixup;
<span class="lineNum">      96 </span>            : 
<span class="lineNum">      97 </span>            : /* Statistics for dominator optimizations.  */
<span class="lineNum">      98 </span>            : struct opt_stats_d
<span class="lineNum">      99 </span>            : {
<span class="lineNum">     100 </span>            :   long num_stmts;
<span class="lineNum">     101 </span>            :   long num_exprs_considered;
<span class="lineNum">     102 </span>            :   long num_re;
<span class="lineNum">     103 </span>            :   long num_const_prop;
<span class="lineNum">     104 </span>            :   long num_copy_prop;
<span class="lineNum">     105 </span>            : };
<span class="lineNum">     106 </span>            : 
<span class="lineNum">     107 </span>            : static struct opt_stats_d opt_stats;
<span class="lineNum">     108 </span>            : 
<span class="lineNum">     109 </span>            : /* Local functions.  */
<span class="lineNum">     110 </span>            : static void record_equality (tree, tree, class const_and_copies *);
<span class="lineNum">     111 </span>            : static void record_equivalences_from_phis (basic_block);
<span class="lineNum">     112 </span>            : static void record_equivalences_from_incoming_edge (basic_block,
<span class="lineNum">     113 </span>            :                                                     class const_and_copies *,
<span class="lineNum">     114 </span>            :                                                     class avail_exprs_stack *);
<span class="lineNum">     115 </span>            : static void eliminate_redundant_computations (gimple_stmt_iterator *,
<span class="lineNum">     116 </span>            :                                               class const_and_copies *,
<span class="lineNum">     117 </span>            :                                               class avail_exprs_stack *);
<span class="lineNum">     118 </span>            : static void record_equivalences_from_stmt (gimple *, int,
<span class="lineNum">     119 </span>            :                                            class avail_exprs_stack *);
<span class="lineNum">     120 </span>            : static void dump_dominator_optimization_stats (FILE *file,
<span class="lineNum">     121 </span>            :                                                hash_table&lt;expr_elt_hasher&gt; *);
<span class="lineNum">     122 </span>            : 
<span class="lineNum">     123 </span>            : /* Constructor for EDGE_INFO.  An EDGE_INFO instance is always
<a name="124"><span class="lineNum">     124 </span>            :    associated with an edge E.  */</a>
<span class="lineNum">     125 </span>            : 
<span class="lineNum">     126 </span><span class="lineCov">   19020166 : edge_info::edge_info (edge e)</span>
<span class="lineNum">     127 </span>            : {
<span class="lineNum">     128 </span>            :   /* Free the old one associated with E, if it exists and
<span class="lineNum">     129 </span>            :      associate our new object with E.  */
<span class="lineNum">     130 </span><span class="lineCov">   19020166 :   free_dom_edge_info (e);</span>
<span class="lineNum">     131 </span><span class="lineCov">   19020166 :   e-&gt;aux = this;</span>
<span class="lineNum">     132 </span>            : 
<span class="lineNum">     133 </span>            :   /* And initialize the embedded vectors.  */
<span class="lineNum">     134 </span><span class="lineCov">   19020166 :   simple_equivalences = vNULL;</span>
<span class="lineNum">     135 </span><span class="lineCov">   19020166 :   cond_equivalences = vNULL;</span>
<span class="lineNum">     136 </span><span class="lineCov">   19020166 : }</span>
<span class="lineNum">     137 </span>            : 
<span class="lineNum">     138 </span>            : /* Destructor just needs to release the vectors.  */
<span class="lineNum">     139 </span>            : 
<span class="lineNum">     140 </span><span class="lineCov">   38040332 : edge_info::~edge_info (void)</span>
<span class="lineNum">     141 </span>            : {
<span class="lineNum">     142 </span><span class="lineCov">   19020166 :   this-&gt;cond_equivalences.release ();</span>
<span class="lineNum">     143 </span><span class="lineCov">   19020166 :   this-&gt;simple_equivalences.release ();</span>
<span class="lineNum">     144 </span><span class="lineCov">   19020166 : }</span>
<span class="lineNum">     145 </span>            : 
<span class="lineNum">     146 </span>            : /* NAME is known to have the value VALUE, which must be a constant.
<span class="lineNum">     147 </span>            : 
<span class="lineNum">     148 </span>            :    Walk through its use-def chain to see if there are other equivalences
<span class="lineNum">     149 </span>            :    we might be able to derive.
<span class="lineNum">     150 </span>            : 
<span class="lineNum">     151 </span>            :    RECURSION_LIMIT controls how far back we recurse through the use-def
<span class="lineNum">     152 </span>            :    chains.  */
<a name="153"><span class="lineNum">     153 </span>            : </a>
<span class="lineNum">     154 </span>            : void
<span class="lineNum">     155 </span><span class="lineCov">    8717806 : edge_info::derive_equivalences (tree name, tree value, int recursion_limit)</span>
<span class="lineNum">     156 </span>            : {
<span class="lineNum">     157 </span><span class="lineCov">    8717806 :   if (TREE_CODE (name) != SSA_NAME || TREE_CODE (value) != INTEGER_CST)</span>
<span class="lineNum">     158 </span>            :     return;
<span class="lineNum">     159 </span>            : 
<span class="lineNum">     160 </span>            :   /* This records the equivalence for the toplevel object.  Do
<span class="lineNum">     161 </span>            :      this before checking the recursion limit.  */
<span class="lineNum">     162 </span><span class="lineCov">   17435340 :   simple_equivalences.safe_push (equiv_pair (name, value));</span>
<span class="lineNum">     163 </span>            : 
<span class="lineNum">     164 </span>            :   /* Limit how far up the use-def chains we are willing to walk.  */
<span class="lineNum">     165 </span><span class="lineCov">    8717670 :   if (recursion_limit == 0)</span>
<span class="lineNum">     166 </span>            :     return;
<span class="lineNum">     167 </span>            : 
<span class="lineNum">     168 </span>            :   /* We can walk up the use-def chains to potentially find more
<span class="lineNum">     169 </span>            :      equivalences.  */
<span class="lineNum">     170 </span><span class="lineCov">    8703808 :   gimple *def_stmt = SSA_NAME_DEF_STMT (name);</span>
<span class="lineNum">     171 </span><span class="lineCov">   17407616 :   if (is_gimple_assign (def_stmt))</span>
<span class="lineNum">     172 </span>            :     {
<span class="lineNum">     173 </span>            :       /* We know the result of DEF_STMT was zero.  See if that allows
<span class="lineNum">     174 </span>            :          us to deduce anything about the SSA_NAMEs used on the RHS.  */
<span class="lineNum">     175 </span><span class="lineCov">    5907955 :       enum tree_code code = gimple_assign_rhs_code (def_stmt);</span>
<span class="lineNum">     176 </span><span class="lineCov">    5907955 :       switch (code)</span>
<span class="lineNum">     177 </span>            :         {
<span class="lineNum">     178 </span><span class="lineCov">     736383 :         case BIT_IOR_EXPR:</span>
<span class="lineNum">     179 </span><span class="lineCov">     736383 :           if (integer_zerop (value))</span>
<span class="lineNum">     180 </span>            :             {
<span class="lineNum">     181 </span><span class="lineCov">     381672 :               tree rhs1 = gimple_assign_rhs1 (def_stmt);</span>
<span class="lineNum">     182 </span><span class="lineCov">     381672 :               tree rhs2 = gimple_assign_rhs2 (def_stmt);</span>
<span class="lineNum">     183 </span>            : 
<span class="lineNum">     184 </span><span class="lineCov">     381672 :               value = build_zero_cst (TREE_TYPE (rhs1));</span>
<span class="lineNum">     185 </span><span class="lineCov">     381672 :               derive_equivalences (rhs1, value, recursion_limit - 1);</span>
<span class="lineNum">     186 </span><span class="lineCov">     381672 :               value = build_zero_cst (TREE_TYPE (rhs2));</span>
<span class="lineNum">     187 </span><span class="lineCov">     381672 :               derive_equivalences (rhs2, value, recursion_limit - 1);</span>
<span class="lineNum">     188 </span>            :             }
<span class="lineNum">     189 </span>            :           break;
<span class="lineNum">     190 </span>            : 
<span class="lineNum">     191 </span>            :       /* We know the result of DEF_STMT was one.  See if that allows
<span class="lineNum">     192 </span>            :          us to deduce anything about the SSA_NAMEs used on the RHS.  */
<span class="lineNum">     193 </span><span class="lineCov">     496043 :         case BIT_AND_EXPR:</span>
<span class="lineNum">     194 </span><span class="lineCov">     496043 :           if (!integer_zerop (value))</span>
<span class="lineNum">     195 </span>            :             {
<span class="lineNum">     196 </span><span class="lineCov">     191643 :               tree rhs1 = gimple_assign_rhs1 (def_stmt);</span>
<span class="lineNum">     197 </span><span class="lineCov">     191643 :               tree rhs2 = gimple_assign_rhs2 (def_stmt);</span>
<span class="lineNum">     198 </span>            : 
<span class="lineNum">     199 </span>            :               /* If either operand has a boolean range, then we
<span class="lineNum">     200 </span>            :                  know its value must be one, otherwise we just know it
<span class="lineNum">     201 </span>            :                  is nonzero.  The former is clearly useful, I haven't
<span class="lineNum">     202 </span>            :                  seen cases where the latter is helpful yet.  */
<span class="lineNum">     203 </span><span class="lineCov">     191643 :               if (TREE_CODE (rhs1) == SSA_NAME)</span>
<span class="lineNum">     204 </span>            :                 {
<span class="lineNum">     205 </span><span class="lineCov">     191643 :                   if (ssa_name_has_boolean_range (rhs1))</span>
<span class="lineNum">     206 </span>            :                     {
<span class="lineNum">     207 </span><span class="lineCov">     111902 :                       value = build_one_cst (TREE_TYPE (rhs1));</span>
<span class="lineNum">     208 </span><span class="lineCov">     111902 :                       derive_equivalences (rhs1, value, recursion_limit - 1);</span>
<span class="lineNum">     209 </span>            :                     }
<span class="lineNum">     210 </span>            :                 }
<span class="lineNum">     211 </span><span class="lineCov">     191643 :               if (TREE_CODE (rhs2) == SSA_NAME)</span>
<span class="lineNum">     212 </span>            :                 {
<span class="lineNum">     213 </span><span class="lineCov">     112486 :                   if (ssa_name_has_boolean_range (rhs2))</span>
<span class="lineNum">     214 </span>            :                     {
<span class="lineNum">     215 </span><span class="lineCov">     111725 :                       value = build_one_cst (TREE_TYPE (rhs2));</span>
<span class="lineNum">     216 </span><span class="lineCov">     111725 :                       derive_equivalences (rhs2, value, recursion_limit - 1);</span>
<span class="lineNum">     217 </span>            :                     }
<span class="lineNum">     218 </span>            :                 }
<span class="lineNum">     219 </span>            :             }
<span class="lineNum">     220 </span>            :           break;
<span class="lineNum">     221 </span>            : 
<span class="lineNum">     222 </span>            :         /* If LHS is an SSA_NAME and RHS is a constant integer and LHS was
<span class="lineNum">     223 </span>            :            set via a widening type conversion, then we may be able to record
<span class="lineNum">     224 </span>            :            additional equivalences.  */
<span class="lineNum">     225 </span><span class="lineCov">     231525 :         case NOP_EXPR:</span>
<span class="lineNum">     226 </span><span class="lineCov">     231525 :         case CONVERT_EXPR:</span>
<span class="lineNum">     227 </span><span class="lineCov">     231525 :           {</span>
<span class="lineNum">     228 </span><span class="lineCov">     231525 :             tree rhs = gimple_assign_rhs1 (def_stmt);</span>
<span class="lineNum">     229 </span><span class="lineCov">     231525 :             tree rhs_type = TREE_TYPE (rhs);</span>
<span class="lineNum">     230 </span><span class="lineCov">     231525 :             if (INTEGRAL_TYPE_P (rhs_type)</span>
<span class="lineNum">     231 </span><span class="lineCov">     230927 :                 &amp;&amp; (TYPE_PRECISION (TREE_TYPE (name))</span>
<span class="lineNum">     232 </span><span class="lineCov">     230927 :                     &gt;= TYPE_PRECISION (rhs_type))</span>
<span class="lineNum">     233 </span><span class="lineCov">     359111 :                 &amp;&amp; int_fits_type_p (value, rhs_type))</span>
<span class="lineNum">     234 </span><span class="lineCov">     126181 :               derive_equivalences (rhs,</span>
<span class="lineNum">     235 </span>            :                                    fold_convert (rhs_type, value),
<span class="lineNum">     236 </span>            :                                    recursion_limit - 1);
<span class="lineNum">     237 </span>            :             break;
<span class="lineNum">     238 </span>            :           }
<span class="lineNum">     239 </span>            : 
<span class="lineNum">     240 </span>            :         /* We can invert the operation of these codes trivially if
<span class="lineNum">     241 </span>            :            one of the RHS operands is a constant to produce a known
<span class="lineNum">     242 </span>            :            value for the other RHS operand.  */
<span class="lineNum">     243 </span><span class="lineCov">     413233 :         case POINTER_PLUS_EXPR:</span>
<span class="lineNum">     244 </span><span class="lineCov">     413233 :         case PLUS_EXPR:</span>
<span class="lineNum">     245 </span><span class="lineCov">     413233 :           {</span>
<span class="lineNum">     246 </span><span class="lineCov">     413233 :             tree rhs1 = gimple_assign_rhs1 (def_stmt);</span>
<span class="lineNum">     247 </span><span class="lineCov">     413233 :             tree rhs2 = gimple_assign_rhs2 (def_stmt);</span>
<span class="lineNum">     248 </span>            : 
<span class="lineNum">     249 </span>            :             /* If either argument is a constant, then we can compute
<span class="lineNum">     250 </span>            :                a constant value for the nonconstant argument.  */
<span class="lineNum">     251 </span><span class="lineCov">     413233 :             if (TREE_CODE (rhs1) == INTEGER_CST</span>
<span class="lineNum">     252 </span><span class="lineNoCov">          0 :                 &amp;&amp; TREE_CODE (rhs2) == SSA_NAME)</span>
<span class="lineNum">     253 </span><span class="lineNoCov">          0 :               derive_equivalences (rhs2,</span>
<span class="lineNum">     254 </span><span class="lineNoCov">          0 :                                    fold_binary (MINUS_EXPR, TREE_TYPE (rhs1),</span>
<span class="lineNum">     255 </span>            :                                                 value, rhs1),
<span class="lineNum">     256 </span>            :                                    recursion_limit - 1);
<span class="lineNum">     257 </span><span class="lineCov">     413233 :             else if (TREE_CODE (rhs2) == INTEGER_CST</span>
<span class="lineNum">     258 </span><span class="lineCov">     376337 :                      &amp;&amp; TREE_CODE (rhs1) == SSA_NAME)</span>
<span class="lineNum">     259 </span><span class="lineCov">     376337 :               derive_equivalences (rhs1,</span>
<span class="lineNum">     260 </span><span class="lineCov">     376337 :                                    fold_binary (MINUS_EXPR, TREE_TYPE (rhs1),</span>
<span class="lineNum">     261 </span>            :                                                 value, rhs2),
<span class="lineNum">     262 </span>            :                                    recursion_limit - 1);
<span class="lineNum">     263 </span>            :             break;
<span class="lineNum">     264 </span>            :           }
<span class="lineNum">     265 </span>            : 
<span class="lineNum">     266 </span>            :         /* If one of the operands is a constant, then we can compute
<span class="lineNum">     267 </span>            :            the value of the other operand.  If both operands are
<span class="lineNum">     268 </span>            :            SSA_NAMEs, then they must be equal if the result is zero.  */
<span class="lineNum">     269 </span><span class="lineCov">      46441 :         case MINUS_EXPR:</span>
<span class="lineNum">     270 </span><span class="lineCov">      46441 :           {</span>
<span class="lineNum">     271 </span><span class="lineCov">      46441 :             tree rhs1 = gimple_assign_rhs1 (def_stmt);</span>
<span class="lineNum">     272 </span><span class="lineCov">      46441 :             tree rhs2 = gimple_assign_rhs2 (def_stmt);</span>
<span class="lineNum">     273 </span>            : 
<span class="lineNum">     274 </span>            :             /* If either argument is a constant, then we can compute
<span class="lineNum">     275 </span>            :                a constant value for the nonconstant argument.  */
<span class="lineNum">     276 </span><span class="lineCov">      46441 :             if (TREE_CODE (rhs1) == INTEGER_CST</span>
<span class="lineNum">     277 </span><span class="lineCov">       1376 :                 &amp;&amp; TREE_CODE (rhs2) == SSA_NAME)</span>
<span class="lineNum">     278 </span><span class="lineCov">       1376 :               derive_equivalences (rhs2,</span>
<span class="lineNum">     279 </span><span class="lineCov">       1376 :                                    fold_binary (MINUS_EXPR, TREE_TYPE (rhs1),</span>
<span class="lineNum">     280 </span>            :                                                 rhs1, value),
<span class="lineNum">     281 </span>            :                                    recursion_limit - 1);
<span class="lineNum">     282 </span><span class="lineCov">      45065 :             else if (TREE_CODE (rhs2) == INTEGER_CST</span>
<span class="lineNum">     283 </span><span class="lineCov">      18786 :                      &amp;&amp; TREE_CODE (rhs1) == SSA_NAME)</span>
<span class="lineNum">     284 </span><span class="lineCov">      18786 :               derive_equivalences (rhs1,</span>
<span class="lineNum">     285 </span><span class="lineCov">      18786 :                                    fold_binary (PLUS_EXPR, TREE_TYPE (rhs1),</span>
<span class="lineNum">     286 </span>            :                                                 value, rhs2),
<span class="lineNum">     287 </span>            :                                    recursion_limit - 1);
<span class="lineNum">     288 </span><span class="lineCov">      26279 :             else if (integer_zerop (value))</span>
<span class="lineNum">     289 </span>            :               {
<span class="lineNum">     290 </span><span class="lineCov">      10806 :                 tree cond = build2 (EQ_EXPR, boolean_type_node,</span>
<span class="lineNum">     291 </span>            :                                     gimple_assign_rhs1 (def_stmt),
<span class="lineNum">     292 </span>            :                                     gimple_assign_rhs2 (def_stmt));
<span class="lineNum">     293 </span><span class="lineCov">      10806 :                 tree inverted = invert_truthvalue (cond);</span>
<span class="lineNum">     294 </span><span class="lineCov">      10806 :                 record_conditions (&amp;this-&gt;cond_equivalences, cond, inverted);</span>
<span class="lineNum">     295 </span>            :               }
<span class="lineNum">     296 </span>            :             break;
<span class="lineNum">     297 </span>            :           }
<span class="lineNum">     298 </span>            : 
<span class="lineNum">     299 </span>            : 
<span class="lineNum">     300 </span><span class="lineCov">     461744 :         case EQ_EXPR:</span>
<span class="lineNum">     301 </span><span class="lineCov">     461744 :         case NE_EXPR:</span>
<span class="lineNum">     302 </span><span class="lineCov">     461744 :           {</span>
<span class="lineNum">     303 </span><span class="lineCov">     184349 :             if ((code == EQ_EXPR &amp;&amp; integer_onep (value))</span>
<span class="lineNum">     304 </span><span class="lineCov">     546122 :                 || (code == NE_EXPR &amp;&amp; integer_zerop (value)))</span>
<span class="lineNum">     305 </span>            :               {
<span class="lineNum">     306 </span><span class="lineCov">     295516 :                 tree rhs1 = gimple_assign_rhs1 (def_stmt);</span>
<span class="lineNum">     307 </span><span class="lineCov">     295516 :                 tree rhs2 = gimple_assign_rhs2 (def_stmt);</span>
<span class="lineNum">     308 </span>            : 
<span class="lineNum">     309 </span>            :                 /* If either argument is a constant, then record the
<span class="lineNum">     310 </span>            :                    other argument as being the same as that constant.
<span class="lineNum">     311 </span>            : 
<span class="lineNum">     312 </span>            :                    If neither operand is a constant, then we have a
<span class="lineNum">     313 </span>            :                    conditional name == name equivalence.  */
<span class="lineNum">     314 </span><span class="lineCov">     295516 :                 if (TREE_CODE (rhs1) == INTEGER_CST)</span>
<span class="lineNum">     315 </span><span class="lineNoCov">          0 :                   derive_equivalences (rhs2, rhs1, recursion_limit - 1);</span>
<span class="lineNum">     316 </span><span class="lineCov">     295516 :                 else if (TREE_CODE (rhs2) == INTEGER_CST)</span>
<span class="lineNum">     317 </span><span class="lineCov">     116055 :                   derive_equivalences (rhs1, rhs2, recursion_limit - 1);</span>
<span class="lineNum">     318 </span>            :               }
<span class="lineNum">     319 </span>            :             else
<span class="lineNum">     320 </span>            :               {
<span class="lineNum">     321 </span><span class="lineCov">     166228 :                 tree cond = build2 (code, boolean_type_node,</span>
<span class="lineNum">     322 </span>            :                                     gimple_assign_rhs1 (def_stmt),
<span class="lineNum">     323 </span><span class="lineCov">     166228 :                                     gimple_assign_rhs2 (def_stmt));</span>
<span class="lineNum">     324 </span><span class="lineCov">     166228 :                 tree inverted = invert_truthvalue (cond);</span>
<span class="lineNum">     325 </span><span class="lineCov">     166228 :                 if (integer_zerop (value))</span>
<span class="lineNum">     326 </span><span class="lineCov">      84378 :                   std::swap (cond, inverted);</span>
<span class="lineNum">     327 </span><span class="lineCov">     166228 :                 record_conditions (&amp;this-&gt;cond_equivalences, cond, inverted);</span>
<span class="lineNum">     328 </span>            :               }
<span class="lineNum">     329 </span>            :             break;
<span class="lineNum">     330 </span>            :           }
<span class="lineNum">     331 </span>            : 
<span class="lineNum">     332 </span>            :         /* For BIT_NOT and NEGATE, we can just apply the operation to the
<span class="lineNum">     333 </span>            :            VALUE to get the new equivalence.  It will always be a constant
<span class="lineNum">     334 </span>            :            so we can recurse.  */
<span class="lineNum">     335 </span><span class="lineCov">      42879 :         case BIT_NOT_EXPR:</span>
<span class="lineNum">     336 </span><span class="lineCov">      42879 :         case NEGATE_EXPR:</span>
<span class="lineNum">     337 </span><span class="lineCov">      42879 :           {</span>
<span class="lineNum">     338 </span><span class="lineCov">      42879 :             tree rhs = gimple_assign_rhs1 (def_stmt);</span>
<span class="lineNum">     339 </span><span class="lineCov">      42879 :             tree res = fold_build1 (code, TREE_TYPE (rhs), value);</span>
<span class="lineNum">     340 </span><span class="lineCov">      42879 :             derive_equivalences (rhs, res, recursion_limit - 1);</span>
<span class="lineNum">     341 </span><span class="lineCov">      42879 :             break;</span>
<span class="lineNum">     342 </span>            :           }
<span class="lineNum">     343 </span>            : 
<span class="lineNum">     344 </span><span class="lineCov">    3479707 :         default:</span>
<span class="lineNum">     345 </span><span class="lineCov">    3479707 :           {</span>
<span class="lineNum">     346 </span><span class="lineCov">    3479707 :             if (TREE_CODE_CLASS (code) == tcc_comparison)</span>
<span class="lineNum">     347 </span>            :               {
<span class="lineNum">     348 </span><span class="lineCov">     582455 :                 tree cond = build2 (code, boolean_type_node,</span>
<span class="lineNum">     349 </span>            :                                     gimple_assign_rhs1 (def_stmt),
<span class="lineNum">     350 </span><span class="lineCov">     582455 :                                     gimple_assign_rhs2 (def_stmt));</span>
<span class="lineNum">     351 </span><span class="lineCov">     582455 :                 tree inverted = invert_truthvalue (cond);</span>
<span class="lineNum">     352 </span><span class="lineCov">     582455 :                 if (integer_zerop (value))</span>
<span class="lineNum">     353 </span><span class="lineCov">     491404 :                   std::swap (cond, inverted);</span>
<span class="lineNum">     354 </span><span class="lineCov">     582455 :                 record_conditions (&amp;this-&gt;cond_equivalences, cond, inverted);</span>
<span class="lineNum">     355 </span><span class="lineCov">     582455 :                 break;</span>
<span class="lineNum">     356 </span>            :               }
<span class="lineNum">     357 </span>            :             break;
<span class="lineNum">     358 </span>            :           }
<span class="lineNum">     359 </span>            :         }
<span class="lineNum">     360 </span>            :     }
<span class="lineNum">     361 </span>            : }
<a name="362"><span class="lineNum">     362 </span>            : </a>
<span class="lineNum">     363 </span>            : void
<span class="lineNum">     364 </span><span class="lineCov">    8796520 : edge_info::record_simple_equiv (tree lhs, tree rhs)</span>
<span class="lineNum">     365 </span>            : {
<span class="lineNum">     366 </span>            :   /* If the RHS is a constant, then we may be able to derive
<span class="lineNum">     367 </span>            :      further equivalences.  Else just record the name = name
<span class="lineNum">     368 </span>            :      equivalence.  */
<span class="lineNum">     369 </span><span class="lineCov">    8796520 :   if (TREE_CODE (rhs) == INTEGER_CST)</span>
<span class="lineNum">     370 </span><span class="lineCov">    7049221 :     derive_equivalences (lhs, rhs, 4);</span>
<span class="lineNum">     371 </span>            :   else
<span class="lineNum">     372 </span><span class="lineCov">    3494598 :     simple_equivalences.safe_push (equiv_pair (lhs, rhs));</span>
<span class="lineNum">     373 </span><span class="lineCov">    8796520 : }</span>
<span class="lineNum">     374 </span>            : 
<span class="lineNum">     375 </span>            : /* Free the edge_info data attached to E, if it exists.  */
<a name="376"><span class="lineNum">     376 </span>            : </a>
<span class="lineNum">     377 </span>            : void
<span class="lineNum">     378 </span><span class="lineCov">   37327986 : free_dom_edge_info (edge e)</span>
<span class="lineNum">     379 </span>            : {
<span class="lineNum">     380 </span><span class="lineCov">   37327986 :   class edge_info *edge_info = (struct edge_info *)e-&gt;aux;</span>
<span class="lineNum">     381 </span>            : 
<span class="lineNum">     382 </span><span class="lineCov">   37327986 :   if (edge_info)</span>
<span class="lineNum">     383 </span><span class="lineCov">   19020166 :     delete edge_info;</span>
<span class="lineNum">     384 </span><span class="lineCov">   37327986 : }</span>
<span class="lineNum">     385 </span>            : 
<span class="lineNum">     386 </span>            : /* Free all EDGE_INFO structures associated with edges in the CFG.
<span class="lineNum">     387 </span>            :    If a particular edge can be threaded, copy the redirection
<span class="lineNum">     388 </span>            :    target from the EDGE_INFO structure into the edge's AUX field
<span class="lineNum">     389 </span>            :    as required by code to update the CFG and SSA graph for
<span class="lineNum">     390 </span>            :    jump threading.  */
<a name="391"><span class="lineNum">     391 </span>            : </a>
<span class="lineNum">     392 </span>            : static void
<span class="lineNum">     393 </span><span class="lineCov">    1242367 : free_all_edge_infos (void)</span>
<span class="lineNum">     394 </span>            : {
<span class="lineNum">     395 </span><span class="lineCov">    1242367 :   basic_block bb;</span>
<span class="lineNum">     396 </span><span class="lineCov">    1242367 :   edge_iterator ei;</span>
<span class="lineNum">     397 </span><span class="lineCov">    1242367 :   edge e;</span>
<span class="lineNum">     398 </span>            : 
<span class="lineNum">     399 </span><span class="lineCov">   13447085 :   FOR_EACH_BB_FN (bb, cfun)</span>
<span class="lineNum">     400 </span>            :     {
<span class="lineNum">     401 </span><span class="lineCov">   41786697 :       FOR_EACH_EDGE (e, ei, bb-&gt;preds)</span>
<span class="lineNum">     402 </span>            :         {
<span class="lineNum">     403 </span><span class="lineCov">   17377261 :           free_dom_edge_info (e);</span>
<span class="lineNum">     404 </span><span class="lineCov">   17377261 :           e-&gt;aux = NULL;</span>
<span class="lineNum">     405 </span>            :         }
<span class="lineNum">     406 </span>            :     }
<span class="lineNum">     407 </span><span class="lineCov">    1242367 : }</span>
<span class="lineNum">     408 </span>            : 
<span class="lineNum">     409 </span>            : /* We have finished optimizing BB, record any information implied by
<span class="lineNum">     410 </span>            :    taking a specific outgoing edge from BB.  */
<a name="411"><span class="lineNum">     411 </span>            : </a>
<span class="lineNum">     412 </span>            : static void
<span class="lineNum">     413 </span><span class="lineCov">   25618274 : record_edge_info (basic_block bb)</span>
<span class="lineNum">     414 </span>            : {
<span class="lineNum">     415 </span><span class="lineCov">   25618274 :   gimple_stmt_iterator gsi = gsi_last_bb (bb);</span>
<span class="lineNum">     416 </span><span class="lineCov">   25618274 :   class edge_info *edge_info;</span>
<span class="lineNum">     417 </span>            : 
<span class="lineNum">     418 </span><span class="lineCov">   51236548 :   if (! gsi_end_p (gsi))</span>
<span class="lineNum">     419 </span>            :     {
<span class="lineNum">     420 </span><span class="lineCov">   22216596 :       gimple *stmt = gsi_stmt (gsi);</span>
<span class="lineNum">     421 </span><span class="lineCov">   22216596 :       location_t loc = gimple_location (stmt);</span>
<span class="lineNum">     422 </span>            : 
<span class="lineNum">     423 </span><span class="lineCov">   44433192 :       if (gimple_code (stmt) == GIMPLE_SWITCH)</span>
<span class="lineNum">     424 </span>            :         {
<span class="lineNum">     425 </span><span class="lineCov">      31189 :           gswitch *switch_stmt = as_a &lt;gswitch *&gt; (stmt);</span>
<span class="lineNum">     426 </span><span class="lineCov">      31189 :           tree index = gimple_switch_index (switch_stmt);</span>
<span class="lineNum">     427 </span>            : 
<span class="lineNum">     428 </span><span class="lineCov">      31189 :           if (TREE_CODE (index) == SSA_NAME)</span>
<span class="lineNum">     429 </span>            :             {
<span class="lineNum">     430 </span><span class="lineCov">      31169 :               int i;</span>
<span class="lineNum">     431 </span><span class="lineCov">      31169 :               int n_labels = gimple_switch_num_labels (switch_stmt);</span>
<span class="lineNum">     432 </span><span class="lineCov">      31169 :               tree *info = XCNEWVEC (tree, last_basic_block_for_fn (cfun));</span>
<span class="lineNum">     433 </span><span class="lineCov">      31169 :               edge e;</span>
<span class="lineNum">     434 </span><span class="lineCov">      31169 :               edge_iterator ei;</span>
<span class="lineNum">     435 </span>            : 
<span class="lineNum">     436 </span><span class="lineCov">     239108 :               for (i = 0; i &lt; n_labels; i++)</span>
<span class="lineNum">     437 </span>            :                 {
<span class="lineNum">     438 </span><span class="lineCov">     207939 :                   tree label = gimple_switch_label (switch_stmt, i);</span>
<span class="lineNum">     439 </span><span class="lineCov">     207939 :                   basic_block target_bb</span>
<span class="lineNum">     440 </span><span class="lineCov">     207939 :                     = label_to_block (cfun, CASE_LABEL (label));</span>
<span class="lineNum">     441 </span><span class="lineCov">     207939 :                   if (CASE_HIGH (label)</span>
<span class="lineNum">     442 </span><span class="lineCov">     390940 :                       || !CASE_LOW (label)</span>
<span class="lineNum">     443 </span><span class="lineCov">     372240 :                       || info[target_bb-&gt;index])</span>
<span class="lineNum">     444 </span><span class="lineCov">      59933 :                     info[target_bb-&gt;index] = error_mark_node;</span>
<span class="lineNum">     445 </span>            :                   else
<span class="lineNum">     446 </span><span class="lineCov">     148006 :                     info[target_bb-&gt;index] = label;</span>
<span class="lineNum">     447 </span>            :                 }
<span class="lineNum">     448 </span>            : 
<span class="lineNum">     449 </span><span class="lineCov">     249679 :               FOR_EACH_EDGE (e, ei, bb-&gt;succs)</span>
<span class="lineNum">     450 </span>            :                 {
<span class="lineNum">     451 </span><span class="lineCov">     187341 :                   basic_block target_bb = e-&gt;dest;</span>
<span class="lineNum">     452 </span><span class="lineCov">     187341 :                   tree label = info[target_bb-&gt;index];</span>
<span class="lineNum">     453 </span>            : 
<span class="lineNum">     454 </span><span class="lineCov">     187341 :                   if (label != NULL &amp;&amp; label != error_mark_node)</span>
<span class="lineNum">     455 </span>            :                     {
<span class="lineNum">     456 </span><span class="lineCov">     139832 :                       tree x = fold_convert_loc (loc, TREE_TYPE (index),</span>
<span class="lineNum">     457 </span><span class="lineCov">     139832 :                                                  CASE_LOW (label));</span>
<span class="lineNum">     458 </span><span class="lineCov">     139832 :                       edge_info = new class edge_info (e);</span>
<span class="lineNum">     459 </span><span class="lineCov">     139832 :                       edge_info-&gt;record_simple_equiv (index, x);</span>
<span class="lineNum">     460 </span>            :                     }
<span class="lineNum">     461 </span>            :                 }
<span class="lineNum">     462 </span><span class="lineCov">      31169 :               free (info);</span>
<span class="lineNum">     463 </span>            :             }
<span class="lineNum">     464 </span>            :         }
<span class="lineNum">     465 </span>            : 
<span class="lineNum">     466 </span>            :       /* A COND_EXPR may create equivalences too.  */
<span class="lineNum">     467 </span><span class="lineCov">   44433192 :       if (gimple_code (stmt) == GIMPLE_COND)</span>
<span class="lineNum">     468 </span>            :         {
<span class="lineNum">     469 </span><span class="lineCov">    9529505 :           edge true_edge;</span>
<span class="lineNum">     470 </span><span class="lineCov">    9529505 :           edge false_edge;</span>
<span class="lineNum">     471 </span>            : 
<span class="lineNum">     472 </span><span class="lineCov">    9529505 :           tree op0 = gimple_cond_lhs (stmt);</span>
<span class="lineNum">     473 </span><span class="lineCov">    9529505 :           tree op1 = gimple_cond_rhs (stmt);</span>
<span class="lineNum">     474 </span><span class="lineCov">    9529505 :           enum tree_code code = gimple_cond_code (stmt);</span>
<span class="lineNum">     475 </span>            : 
<span class="lineNum">     476 </span><span class="lineCov">    9529505 :           extract_true_false_edges_from_block (bb, &amp;true_edge, &amp;false_edge);</span>
<span class="lineNum">     477 </span>            : 
<span class="lineNum">     478 </span>            :           /* Special case comparing booleans against a constant as we
<span class="lineNum">     479 </span>            :              know the value of OP0 on both arms of the branch.  i.e., we
<span class="lineNum">     480 </span>            :              can record an equivalence for OP0 rather than COND. 
<span class="lineNum">     481 </span>            : 
<span class="lineNum">     482 </span>            :              However, don't do this if the constant isn't zero or one.
<span class="lineNum">     483 </span>            :              Such conditionals will get optimized more thoroughly during
<span class="lineNum">     484 </span>            :              the domwalk.  */
<span class="lineNum">     485 </span><span class="lineCov">    9529505 :           if ((code == EQ_EXPR || code == NE_EXPR)</span>
<span class="lineNum">     486 </span><span class="lineCov">    7374344 :               &amp;&amp; TREE_CODE (op0) == SSA_NAME</span>
<span class="lineNum">     487 </span><span class="lineCov">    7023242 :               &amp;&amp; ssa_name_has_boolean_range (op0)</span>
<span class="lineNum">     488 </span><span class="lineCov">    1553457 :               &amp;&amp; is_gimple_min_invariant (op1)</span>
<span class="lineNum">     489 </span><span class="lineCov">   11045296 :               &amp;&amp; (integer_zerop (op1) || integer_onep (op1)))</span>
<span class="lineNum">     490 </span>            :             {
<span class="lineNum">     491 </span><span class="lineCov">    1515783 :               tree true_val = constant_boolean_node (true, TREE_TYPE (op0));</span>
<span class="lineNum">     492 </span><span class="lineCov">    1515783 :               tree false_val = constant_boolean_node (false, TREE_TYPE (op0));</span>
<span class="lineNum">     493 </span>            : 
<span class="lineNum">     494 </span><span class="lineCov">    1515783 :               if (code == EQ_EXPR)</span>
<span class="lineNum">     495 </span>            :                 {
<span class="lineNum">     496 </span><span class="lineCov">      49836 :                   edge_info = new class edge_info (true_edge);</span>
<span class="lineNum">     497 </span><span class="lineCov">      85507 :                   edge_info-&gt;record_simple_equiv (op0,</span>
<span class="lineNum">     498 </span><span class="lineCov">      49836 :                                                   (integer_zerop (op1)</span>
<span class="lineNum">     499 </span>            :                                                    ? false_val : true_val));
<span class="lineNum">     500 </span><span class="lineCov">      49836 :                   edge_info = new class edge_info (false_edge);</span>
<span class="lineNum">     501 </span><span class="lineCov">      85507 :                   edge_info-&gt;record_simple_equiv (op0,</span>
<span class="lineNum">     502 </span><span class="lineCov">      49836 :                                                   (integer_zerop (op1)</span>
<span class="lineNum">     503 </span>            :                                                    ? true_val : false_val));
<span class="lineNum">     504 </span>            :                 }
<span class="lineNum">     505 </span>            :               else
<span class="lineNum">     506 </span>            :                 {
<span class="lineNum">     507 </span><span class="lineCov">    1465947 :                   edge_info = new class edge_info (true_edge);</span>
<span class="lineNum">     508 </span><span class="lineCov">    1466457 :                   edge_info-&gt;record_simple_equiv (op0,</span>
<span class="lineNum">     509 </span><span class="lineCov">    1465947 :                                                   (integer_zerop (op1)</span>
<span class="lineNum">     510 </span>            :                                                    ? true_val : false_val));
<span class="lineNum">     511 </span><span class="lineCov">    1465947 :                   edge_info = new class edge_info (false_edge);</span>
<span class="lineNum">     512 </span><span class="lineCov">    1466457 :                   edge_info-&gt;record_simple_equiv (op0,</span>
<span class="lineNum">     513 </span><span class="lineCov">    1465947 :                                                   (integer_zerop (op1)</span>
<span class="lineNum">     514 </span>            :                                                    ? false_val : true_val));
<span class="lineNum">     515 </span>            :                 }
<span class="lineNum">     516 </span>            :             }
<span class="lineNum">     517 </span>            :           /* This can show up in the IL as a result of copy propagation
<span class="lineNum">     518 </span>            :              it will eventually be canonicalized, but we have to cope
<span class="lineNum">     519 </span>            :              with this case within the pass.  */
<span class="lineNum">     520 </span><span class="lineCov">    8013722 :           else if (is_gimple_min_invariant (op0)</span>
<span class="lineNum">     521 </span><span class="lineCov">    8013722 :                    &amp;&amp; TREE_CODE (op1) == SSA_NAME)</span>
<span class="lineNum">     522 </span>            :             {
<span class="lineNum">     523 </span><span class="lineCov">     262693 :               tree cond = build2 (code, boolean_type_node, op0, op1);</span>
<span class="lineNum">     524 </span><span class="lineCov">     262693 :               tree inverted = invert_truthvalue_loc (loc, cond);</span>
<span class="lineNum">     525 </span><span class="lineCov">     262693 :               bool can_infer_simple_equiv</span>
<span class="lineNum">     526 </span><span class="lineCov">     262693 :                 = !(HONOR_SIGNED_ZEROS (op0)</span>
<span class="lineNum">     527 </span><span class="lineNoCov">          0 :                     &amp;&amp; real_zerop (op0));</span>
<span class="lineNum">     528 </span><span class="lineCov">     262693 :               struct edge_info *edge_info;</span>
<span class="lineNum">     529 </span>            : 
<span class="lineNum">     530 </span><span class="lineCov">     262693 :               edge_info = new class edge_info (true_edge);</span>
<span class="lineNum">     531 </span><span class="lineCov">     262693 :               record_conditions (&amp;edge_info-&gt;cond_equivalences, cond, inverted);</span>
<span class="lineNum">     532 </span>            : 
<span class="lineNum">     533 </span><span class="lineCov">     262693 :               if (can_infer_simple_equiv &amp;&amp; code == EQ_EXPR)</span>
<span class="lineNum">     534 </span><span class="lineCov">      24702 :                 edge_info-&gt;record_simple_equiv (op1, op0);</span>
<span class="lineNum">     535 </span>            : 
<span class="lineNum">     536 </span><span class="lineCov">     262693 :               edge_info = new class edge_info (false_edge);</span>
<span class="lineNum">     537 </span><span class="lineCov">     262693 :               record_conditions (&amp;edge_info-&gt;cond_equivalences, inverted, cond);</span>
<span class="lineNum">     538 </span>            : 
<span class="lineNum">     539 </span><span class="lineCov">     262693 :               if (can_infer_simple_equiv &amp;&amp; TREE_CODE (inverted) == EQ_EXPR)</span>
<span class="lineNum">     540 </span><span class="lineCov">     237302 :                 edge_info-&gt;record_simple_equiv (op1, op0);</span>
<span class="lineNum">     541 </span>            :             }
<span class="lineNum">     542 </span>            : 
<span class="lineNum">     543 </span><span class="lineCov">    7751029 :           else if (TREE_CODE (op0) == SSA_NAME</span>
<span class="lineNum">     544 </span><span class="lineCov">    7751029 :                    &amp;&amp; (TREE_CODE (op1) == SSA_NAME</span>
<span class="lineNum">     545 </span><span class="lineCov">    5291902 :                        || is_gimple_min_invariant (op1)))</span>
<span class="lineNum">     546 </span>            :             {
<span class="lineNum">     547 </span><span class="lineCov">    7661691 :               tree cond = build2 (code, boolean_type_node, op0, op1);</span>
<span class="lineNum">     548 </span><span class="lineCov">    7661691 :               tree inverted = invert_truthvalue_loc (loc, cond);</span>
<span class="lineNum">     549 </span><span class="lineCov">    7661691 :               bool can_infer_simple_equiv</span>
<span class="lineNum">     550 </span><span class="lineCov">    7661691 :                 = !(HONOR_SIGNED_ZEROS (op1)</span>
<span class="lineNum">     551 </span><span class="lineCov">     544606 :                     &amp;&amp; (TREE_CODE (op1) == SSA_NAME || real_zerop (op1)));</span>
<span class="lineNum">     552 </span><span class="lineCov">    7661691 :               struct edge_info *edge_info;</span>
<span class="lineNum">     553 </span>            : 
<span class="lineNum">     554 </span><span class="lineCov">    7661691 :               edge_info = new class edge_info (true_edge);</span>
<span class="lineNum">     555 </span><span class="lineCov">    7661691 :               record_conditions (&amp;edge_info-&gt;cond_equivalences, cond, inverted);</span>
<span class="lineNum">     556 </span>            : 
<span class="lineNum">     557 </span><span class="lineCov">    7661691 :               if (can_infer_simple_equiv &amp;&amp; code == EQ_EXPR)</span>
<span class="lineNum">     558 </span><span class="lineCov">    2126242 :                 edge_info-&gt;record_simple_equiv (op0, op1);</span>
<span class="lineNum">     559 </span>            : 
<span class="lineNum">     560 </span><span class="lineCov">    7661691 :               edge_info = new class edge_info (false_edge);</span>
<span class="lineNum">     561 </span><span class="lineCov">    7661691 :               record_conditions (&amp;edge_info-&gt;cond_equivalences, inverted, cond);</span>
<span class="lineNum">     562 </span>            : 
<span class="lineNum">     563 </span><span class="lineCov">    7661691 :               if (can_infer_simple_equiv &amp;&amp; TREE_CODE (inverted) == EQ_EXPR)</span>
<span class="lineNum">     564 </span><span class="lineCov">    3236876 :                 edge_info-&gt;record_simple_equiv (op0, op1);</span>
<span class="lineNum">     565 </span>            :             }
<span class="lineNum">     566 </span>            :         }
<span class="lineNum">     567 </span>            :     }
<span class="lineNum">     568 </span><span class="lineCov">   25618274 : }</span>
<span class="lineNum">     569 </span>            : 
<span class="lineNum">     570 </span>            : 
<span class="lineNum">     571 </span><span class="lineCov">    1242367 : class dom_opt_dom_walker : public dom_walker</span>
<span class="lineNum">     572 </span>            : {
<span class="lineNum">     573 </span>            : public:
<span class="lineNum">     574 </span>            :   dom_opt_dom_walker (cdi_direction direction,
<span class="lineNum">     575 </span>            :                       class const_and_copies *const_and_copies,
<span class="lineNum">     576 </span>            :                       class avail_exprs_stack *avail_exprs_stack,
<span class="lineNum">     577 </span>            :                       gcond *dummy_cond)
<span class="lineNum">     578 </span><span class="lineCov">    1242367 :     : dom_walker (direction, REACHABLE_BLOCKS),</span>
<span class="lineNum">     579 </span>            :       m_const_and_copies (const_and_copies),
<span class="lineNum">     580 </span>            :       m_avail_exprs_stack (avail_exprs_stack),
<span class="lineNum">     581 </span><span class="lineCov">    1242367 :       m_dummy_cond (dummy_cond) { }</span>
<span class="lineNum">     582 </span>            : 
<span class="lineNum">     583 </span>            :   virtual edge before_dom_children (basic_block);
<span class="lineNum">     584 </span>            :   virtual void after_dom_children (basic_block);
<span class="lineNum">     585 </span>            : 
<span class="lineNum">     586 </span>            : private:
<span class="lineNum">     587 </span>            : 
<span class="lineNum">     588 </span>            :   /* Unwindable equivalences, both const/copy and expression varieties.  */
<span class="lineNum">     589 </span>            :   class const_and_copies *m_const_and_copies;
<span class="lineNum">     590 </span>            :   class avail_exprs_stack *m_avail_exprs_stack;
<span class="lineNum">     591 </span>            : 
<span class="lineNum">     592 </span>            :   /* VRP data.  */
<span class="lineNum">     593 </span>            :   class evrp_range_analyzer evrp_range_analyzer;
<span class="lineNum">     594 </span>            : 
<span class="lineNum">     595 </span>            :   /* Dummy condition to avoid creating lots of throw away statements.  */
<span class="lineNum">     596 </span>            :   gcond *m_dummy_cond;
<span class="lineNum">     597 </span>            : 
<span class="lineNum">     598 </span>            :   /* Optimize a single statement within a basic block using the
<span class="lineNum">     599 </span>            :      various tables mantained by DOM.  Returns the taken edge if
<span class="lineNum">     600 </span>            :      the statement is a conditional with a statically determined
<span class="lineNum">     601 </span>            :      value.  */
<span class="lineNum">     602 </span>            :   edge optimize_stmt (basic_block, gimple_stmt_iterator);
<span class="lineNum">     603 </span>            : };
<span class="lineNum">     604 </span>            : 
<span class="lineNum">     605 </span>            : /* Jump threading, redundancy elimination and const/copy propagation.
<span class="lineNum">     606 </span>            : 
<span class="lineNum">     607 </span>            :    This pass may expose new symbols that need to be renamed into SSA.  For
<span class="lineNum">     608 </span>            :    every new symbol exposed, its corresponding bit will be set in
<span class="lineNum">     609 </span>            :    VARS_TO_RENAME.  */
<span class="lineNum">     610 </span>            : 
<span class="lineNum">     611 </span>            : namespace {
<span class="lineNum">     612 </span>            : 
<span class="lineNum">     613 </span>            : const pass_data pass_data_dominator =
<span class="lineNum">     614 </span>            : {
<span class="lineNum">     615 </span>            :   GIMPLE_PASS, /* type */
<span class="lineNum">     616 </span>            :   &quot;dom&quot;, /* name */
<span class="lineNum">     617 </span>            :   OPTGROUP_NONE, /* optinfo_flags */
<span class="lineNum">     618 </span>            :   TV_TREE_SSA_DOMINATOR_OPTS, /* tv_id */
<span class="lineNum">     619 </span>            :   ( PROP_cfg | PROP_ssa ), /* properties_required */
<span class="lineNum">     620 </span>            :   0, /* properties_provided */
<span class="lineNum">     621 </span>            :   0, /* properties_destroyed */
<span class="lineNum">     622 </span>            :   0, /* todo_flags_start */
<span class="lineNum">     623 </span>            :   ( TODO_cleanup_cfg | TODO_update_ssa ), /* todo_flags_finish */
<span class="lineNum">     624 </span>            : };
<span class="lineNum">     625 </span>            : 
<span class="lineNum">     626 </span>            : class pass_dominator : public gimple_opt_pass
<span class="lineNum">     627 </span>            : {
<span class="lineNum">     628 </span>            : public:
<span class="lineNum">     629 </span>            :   pass_dominator (gcc::context *ctxt)
<span class="lineNum">     630 </span><span class="lineCov">     510936 :     : gimple_opt_pass (pass_data_dominator, ctxt),</span>
<span class="lineNum">     631 </span><span class="lineCov">    1021872 :       may_peel_loop_headers_p (false)</span>
<span class="lineNum">     632 </span>            :   {}
<a name="633"><span class="lineNum">     633 </span>            : </a>
<a name="634"><span class="lineNum">     634 </span>            :   /* opt_pass methods: */</a>
<span class="lineNum">     635 </span><span class="lineCov">     340624 :   opt_pass * clone () { return new pass_dominator (m_ctxt); }</span>
<span class="lineNum">     636 </span><span class="lineCov">     510936 :   void set_pass_param (unsigned int n, bool param)</span>
<span class="lineNum">     637 </span>            :     {
<span class="lineNum">     638 </span><span class="lineCov">     510936 :       gcc_assert (n == 0);</span>
<a name="639"><span class="lineNum">     639 </span><span class="lineCov">     510936 :       may_peel_loop_headers_p = param;</span></a>
<span class="lineNum">     640 </span><span class="lineCov">     510936 :     }</span>
<span class="lineNum">     641 </span><span class="lineCov">    1242658 :   virtual bool gate (function *) { return flag_tree_dom != 0; }</span>
<span class="lineNum">     642 </span>            :   virtual unsigned int execute (function *);
<span class="lineNum">     643 </span>            : 
<span class="lineNum">     644 </span>            :  private:
<span class="lineNum">     645 </span>            :   /* This flag is used to prevent loops from being peeled repeatedly in jump
<span class="lineNum">     646 </span>            :      threading; it will be removed once we preserve loop structures throughout
<span class="lineNum">     647 </span>            :      the compilation -- we will be able to mark the affected loops directly in
<span class="lineNum">     648 </span>            :      jump threading, and avoid peeling them next time.  */
<span class="lineNum">     649 </span>            :   bool may_peel_loop_headers_p;
<span class="lineNum">     650 </span>            : }; // class pass_dominator
<span class="lineNum">     651 </span>            : 
<span class="lineNum">     652 </span>            : unsigned int
<span class="lineNum">     653 </span><span class="lineCov">    1242367 : pass_dominator::execute (function *fun)</span>
<span class="lineNum">     654 </span>            : {
<span class="lineNum">     655 </span><span class="lineCov">    1242367 :   memset (&amp;opt_stats, 0, sizeof (opt_stats));</span>
<span class="lineNum">     656 </span>            : 
<span class="lineNum">     657 </span>            :   /* Create our hash tables.  */
<span class="lineNum">     658 </span><span class="lineCov">    1242367 :   hash_table&lt;expr_elt_hasher&gt; *avail_exprs</span>
<span class="lineNum">     659 </span><span class="lineCov">    1242367 :     = new hash_table&lt;expr_elt_hasher&gt; (1024);</span>
<span class="lineNum">     660 </span><span class="lineCov">    1242367 :   class avail_exprs_stack *avail_exprs_stack</span>
<span class="lineNum">     661 </span><span class="lineCov">    1242367 :     = new class avail_exprs_stack (avail_exprs);</span>
<span class="lineNum">     662 </span><span class="lineCov">    1242367 :   class const_and_copies *const_and_copies = new class const_and_copies ();</span>
<span class="lineNum">     663 </span><span class="lineCov">    1242367 :   need_eh_cleanup = BITMAP_ALLOC (NULL);</span>
<span class="lineNum">     664 </span><span class="lineCov">    1242367 :   need_noreturn_fixup.create (0);</span>
<span class="lineNum">     665 </span>            : 
<span class="lineNum">     666 </span><span class="lineCov">    1242367 :   calculate_dominance_info (CDI_DOMINATORS);</span>
<span class="lineNum">     667 </span><span class="lineCov">    1242367 :   cfg_altered = false;</span>
<span class="lineNum">     668 </span>            : 
<span class="lineNum">     669 </span>            :   /* We need to know loop structures in order to avoid destroying them
<span class="lineNum">     670 </span>            :      in jump threading.  Note that we still can e.g. thread through loop
<span class="lineNum">     671 </span>            :      headers to an exit edge, or through loop header to the loop body, assuming
<span class="lineNum">     672 </span>            :      that we update the loop info.
<span class="lineNum">     673 </span>            : 
<span class="lineNum">     674 </span>            :      TODO: We don't need to set LOOPS_HAVE_PREHEADERS generally, but due
<span class="lineNum">     675 </span>            :      to several overly conservative bail-outs in jump threading, case
<span class="lineNum">     676 </span>            :      gcc.dg/tree-ssa/pr21417.c can't be threaded if loop preheader is
<span class="lineNum">     677 </span>            :      missing.  We should improve jump threading in future then
<span class="lineNum">     678 </span>            :      LOOPS_HAVE_PREHEADERS won't be needed here.  */
<span class="lineNum">     679 </span><span class="lineCov">    1242367 :   loop_optimizer_init (LOOPS_HAVE_PREHEADERS | LOOPS_HAVE_SIMPLE_LATCHES);</span>
<span class="lineNum">     680 </span>            : 
<span class="lineNum">     681 </span>            :   /* Initialize the value-handle array.  */
<span class="lineNum">     682 </span><span class="lineCov">    1242367 :   threadedge_initialize_values ();</span>
<span class="lineNum">     683 </span>            : 
<span class="lineNum">     684 </span>            :   /* We need accurate information regarding back edges in the CFG
<span class="lineNum">     685 </span>            :      for jump threading; this may include back edges that are not part of
<span class="lineNum">     686 </span>            :      a single loop.  */
<span class="lineNum">     687 </span><span class="lineCov">    1242367 :   mark_dfs_back_edges ();</span>
<span class="lineNum">     688 </span>            : 
<span class="lineNum">     689 </span>            :   /* We want to create the edge info structures before the dominator walk
<span class="lineNum">     690 </span>            :      so that they'll be in place for the jump threader, particularly when
<span class="lineNum">     691 </span>            :      threading through a join block.
<span class="lineNum">     692 </span>            : 
<span class="lineNum">     693 </span>            :      The conditions will be lazily updated with global equivalences as
<span class="lineNum">     694 </span>            :      we reach them during the dominator walk.  */
<span class="lineNum">     695 </span><span class="lineCov">    1242367 :   basic_block bb;</span>
<span class="lineNum">     696 </span><span class="lineCov">   13447085 :   FOR_EACH_BB_FN (bb, fun)</span>
<span class="lineNum">     697 </span><span class="lineCov">   12204718 :     record_edge_info (bb);</span>
<span class="lineNum">     698 </span>            : 
<span class="lineNum">     699 </span><span class="lineCov">    1242367 :   gcond *dummy_cond = gimple_build_cond (NE_EXPR, integer_zero_node,</span>
<span class="lineNum">     700 </span>            :                                          integer_zero_node, NULL, NULL);
<span class="lineNum">     701 </span>            : 
<span class="lineNum">     702 </span>            :   /* Recursively walk the dominator tree optimizing statements.  */
<span class="lineNum">     703 </span><span class="lineCov">    1242367 :   dom_opt_dom_walker walker (CDI_DOMINATORS, const_and_copies,</span>
<span class="lineNum">     704 </span><span class="lineCov">    1242367 :                              avail_exprs_stack, dummy_cond);</span>
<span class="lineNum">     705 </span><span class="lineCov">    1242367 :   walker.walk (fun-&gt;cfg-&gt;x_entry_block_ptr);</span>
<span class="lineNum">     706 </span>            : 
<span class="lineNum">     707 </span>            :   /* Look for blocks where we cleared EDGE_EXECUTABLE on an outgoing
<span class="lineNum">     708 </span>            :      edge.  When found, remove jump threads which contain any outgoing
<span class="lineNum">     709 </span>            :      edge from the affected block.  */
<span class="lineNum">     710 </span><span class="lineCov">    1242367 :   if (cfg_altered)</span>
<span class="lineNum">     711 </span>            :     {
<span class="lineNum">     712 </span><span class="lineCov">    1229026 :       FOR_EACH_BB_FN (bb, fun)</span>
<span class="lineNum">     713 </span>            :         {
<span class="lineNum">     714 </span><span class="lineCov">    1208404 :           edge_iterator ei;</span>
<span class="lineNum">     715 </span><span class="lineCov">    1208404 :           edge e;</span>
<span class="lineNum">     716 </span>            : 
<span class="lineNum">     717 </span>            :           /* First see if there are any edges without EDGE_EXECUTABLE
<span class="lineNum">     718 </span>            :              set.  */
<span class="lineNum">     719 </span><span class="lineCov">    1208404 :           bool found = false;</span>
<span class="lineNum">     720 </span><span class="lineCov">    4071203 :           FOR_EACH_EDGE (e, ei, bb-&gt;succs)</span>
<span class="lineNum">     721 </span>            :             {
<span class="lineNum">     722 </span><span class="lineCov">    1735689 :               if ((e-&gt;flags &amp; EDGE_EXECUTABLE) == 0)</span>
<span class="lineNum">     723 </span>            :                 {
<span class="lineNum">     724 </span>            :                   found = true;
<span class="lineNum">     725 </span>            :                   break;
<span class="lineNum">     726 </span>            :                 }
<span class="lineNum">     727 </span>            :             }
<span class="lineNum">     728 </span>            : 
<span class="lineNum">     729 </span>            :           /* If there were any such edges found, then remove jump threads
<span class="lineNum">     730 </span>            :              containing any edge leaving BB.  */
<span class="lineNum">     731 </span><span class="lineCov">    1208404 :           if (found)</span>
<span class="lineNum">     732 </span><span class="lineCov">     307485 :             FOR_EACH_EDGE (e, ei, bb-&gt;succs)</span>
<span class="lineNum">     733 </span><span class="lineCov">     144897 :               remove_jump_threads_including (e);</span>
<span class="lineNum">     734 </span>            :         }
<span class="lineNum">     735 </span>            :     }
<span class="lineNum">     736 </span>            : 
<span class="lineNum">     737 </span><span class="lineCov">    1242367 :   {</span>
<span class="lineNum">     738 </span><span class="lineCov">    1242367 :     gimple_stmt_iterator gsi;</span>
<span class="lineNum">     739 </span><span class="lineCov">    1242367 :     basic_block bb;</span>
<span class="lineNum">     740 </span><span class="lineCov">   13447085 :     FOR_EACH_BB_FN (bb, fun)</span>
<span class="lineNum">     741 </span>            :       {
<span class="lineNum">     742 </span><span class="lineCov">  127478642 :         for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&amp;gsi))</span>
<span class="lineNum">     743 </span><span class="lineCov">  206138412 :           update_stmt_if_modified (gsi_stmt (gsi));</span>
<span class="lineNum">     744 </span>            :       }
<span class="lineNum">     745 </span>            :   }
<span class="lineNum">     746 </span>            : 
<span class="lineNum">     747 </span>            :   /* If we exposed any new variables, go ahead and put them into
<span class="lineNum">     748 </span>            :      SSA form now, before we handle jump threading.  This simplifies
<span class="lineNum">     749 </span>            :      interactions between rewriting of _DECL nodes into SSA form
<span class="lineNum">     750 </span>            :      and rewriting SSA_NAME nodes into SSA form after block
<span class="lineNum">     751 </span>            :      duplication and CFG manipulation.  */
<span class="lineNum">     752 </span><span class="lineCov">    1242367 :   update_ssa (TODO_update_ssa);</span>
<span class="lineNum">     753 </span>            : 
<span class="lineNum">     754 </span><span class="lineCov">    1242367 :   free_all_edge_infos ();</span>
<span class="lineNum">     755 </span>            : 
<span class="lineNum">     756 </span>            :   /* Thread jumps, creating duplicate blocks as needed.  */
<span class="lineNum">     757 </span><span class="lineCov">    1242367 :   cfg_altered |= thread_through_all_blocks (may_peel_loop_headers_p);</span>
<span class="lineNum">     758 </span>            : 
<span class="lineNum">     759 </span><span class="lineCov">    1242367 :   if (cfg_altered)</span>
<span class="lineNum">     760 </span><span class="lineCov">      62360 :     free_dominance_info (CDI_DOMINATORS);</span>
<span class="lineNum">     761 </span>            : 
<span class="lineNum">     762 </span>            :   /* Removal of statements may make some EH edges dead.  Purge
<span class="lineNum">     763 </span>            :      such edges from the CFG as needed.  */
<span class="lineNum">     764 </span><span class="lineCov">    2484734 :   if (!bitmap_empty_p (need_eh_cleanup))</span>
<span class="lineNum">     765 </span>            :     {
<span class="lineNum">     766 </span><span class="lineCov">        259 :       unsigned i;</span>
<span class="lineNum">     767 </span><span class="lineCov">        259 :       bitmap_iterator bi;</span>
<span class="lineNum">     768 </span>            : 
<span class="lineNum">     769 </span>            :       /* Jump threading may have created forwarder blocks from blocks
<span class="lineNum">     770 </span>            :          needing EH cleanup; the new successor of these blocks, which
<span class="lineNum">     771 </span>            :          has inherited from the original block, needs the cleanup.
<span class="lineNum">     772 </span>            :          Don't clear bits in the bitmap, as that can break the bitmap
<span class="lineNum">     773 </span>            :          iterator.  */
<span class="lineNum">     774 </span><span class="lineCov">        610 :       EXECUTE_IF_SET_IN_BITMAP (need_eh_cleanup, 0, i, bi)</span>
<span class="lineNum">     775 </span>            :         {
<span class="lineNum">     776 </span><span class="lineCov">        351 :           basic_block bb = BASIC_BLOCK_FOR_FN (fun, i);</span>
<span class="lineNum">     777 </span><span class="lineCov">        351 :           if (bb == NULL)</span>
<span class="lineNum">     778 </span>            :             continue;
<span class="lineNum">     779 </span><span class="lineCov">        361 :           while (single_succ_p (bb)</span>
<span class="lineNum">     780 </span><span class="lineCov">        358 :                  &amp;&amp; (single_succ_edge (bb)-&gt;flags &amp; EDGE_EH) == 0)</span>
<span class="lineNum">     781 </span><span class="lineCov">         20 :             bb = single_succ (bb);</span>
<span class="lineNum">     782 </span><span class="lineCov">        351 :           if (bb == EXIT_BLOCK_PTR_FOR_FN (fun))</span>
<span class="lineNum">     783 </span>            :             continue;
<span class="lineNum">     784 </span><span class="lineCov">        348 :           if ((unsigned) bb-&gt;index != i)</span>
<span class="lineNum">     785 </span><span class="lineCov">          6 :             bitmap_set_bit (need_eh_cleanup, bb-&gt;index);</span>
<span class="lineNum">     786 </span>            :         }
<span class="lineNum">     787 </span>            : 
<span class="lineNum">     788 </span><span class="lineCov">        259 :       gimple_purge_all_dead_eh_edges (need_eh_cleanup);</span>
<span class="lineNum">     789 </span><span class="lineCov">        259 :       bitmap_clear (need_eh_cleanup);</span>
<span class="lineNum">     790 </span>            :     }
<span class="lineNum">     791 </span>            : 
<span class="lineNum">     792 </span>            :   /* Fixup stmts that became noreturn calls.  This may require splitting
<span class="lineNum">     793 </span>            :      blocks and thus isn't possible during the dominator walk or before
<span class="lineNum">     794 </span>            :      jump threading finished.  Do this in reverse order so we don't
<span class="lineNum">     795 </span>            :      inadvertedly remove a stmt we want to fixup by visiting a dominating
<span class="lineNum">     796 </span>            :      now noreturn call first.  */
<span class="lineNum">     797 </span><span class="lineCov">    1242372 :   while (!need_noreturn_fixup.is_empty ())</span>
<span class="lineNum">     798 </span>            :     {
<span class="lineNum">     799 </span><span class="lineCov">          5 :       gimple *stmt = need_noreturn_fixup.pop ();</span>
<span class="lineNum">     800 </span><span class="lineCov">          5 :       if (dump_file &amp;&amp; dump_flags &amp; TDF_DETAILS)</span>
<span class="lineNum">     801 </span>            :         {
<span class="lineNum">     802 </span><span class="lineNoCov">          0 :           fprintf (dump_file, &quot;Fixing up noreturn call &quot;);</span>
<span class="lineNum">     803 </span><span class="lineNoCov">          0 :           print_gimple_stmt (dump_file, stmt, 0);</span>
<span class="lineNum">     804 </span><span class="lineNoCov">          0 :           fprintf (dump_file, &quot;\n&quot;);</span>
<span class="lineNum">     805 </span>            :         }
<span class="lineNum">     806 </span><span class="lineCov">          5 :       fixup_noreturn_call (stmt);</span>
<span class="lineNum">     807 </span>            :     }
<span class="lineNum">     808 </span>            : 
<span class="lineNum">     809 </span><span class="lineCov">    2484734 :   statistics_counter_event (fun, &quot;Redundant expressions eliminated&quot;,</span>
<span class="lineNum">     810 </span><span class="lineCov">    1242367 :                             opt_stats.num_re);</span>
<span class="lineNum">     811 </span><span class="lineCov">    2484734 :   statistics_counter_event (fun, &quot;Constants propagated&quot;,</span>
<span class="lineNum">     812 </span><span class="lineCov">    1242367 :                             opt_stats.num_const_prop);</span>
<span class="lineNum">     813 </span><span class="lineCov">    2484734 :   statistics_counter_event (fun, &quot;Copies propagated&quot;,</span>
<span class="lineNum">     814 </span><span class="lineCov">    1242367 :                             opt_stats.num_copy_prop);</span>
<span class="lineNum">     815 </span>            : 
<span class="lineNum">     816 </span>            :   /* Debugging dumps.  */
<span class="lineNum">     817 </span><span class="lineCov">    1242367 :   if (dump_file &amp;&amp; (dump_flags &amp; TDF_STATS))</span>
<span class="lineNum">     818 </span><span class="lineCov">         45 :     dump_dominator_optimization_stats (dump_file, avail_exprs);</span>
<span class="lineNum">     819 </span>            : 
<span class="lineNum">     820 </span><span class="lineCov">    1242367 :   loop_optimizer_finalize ();</span>
<span class="lineNum">     821 </span>            : 
<span class="lineNum">     822 </span>            :   /* Delete our main hashtable.  */
<span class="lineNum">     823 </span><span class="lineCov">    1242367 :   delete avail_exprs;</span>
<span class="lineNum">     824 </span><span class="lineCov">    1242367 :   avail_exprs = NULL;</span>
<span class="lineNum">     825 </span>            : 
<span class="lineNum">     826 </span>            :   /* Free asserted bitmaps and stacks.  */
<span class="lineNum">     827 </span><span class="lineCov">    1242367 :   BITMAP_FREE (need_eh_cleanup);</span>
<span class="lineNum">     828 </span><span class="lineCov">    1242367 :   need_noreturn_fixup.release ();</span>
<span class="lineNum">     829 </span><span class="lineCov">    2484734 :   delete avail_exprs_stack;</span>
<span class="lineNum">     830 </span><span class="lineCov">    2484734 :   delete const_and_copies;</span>
<span class="lineNum">     831 </span>            : 
<span class="lineNum">     832 </span>            :   /* Free the value-handle array.  */
<span class="lineNum">     833 </span><span class="lineCov">    1242367 :   threadedge_finalize_values ();</span>
<span class="lineNum">     834 </span>            : 
<span class="lineNum">     835 </span><span class="lineCov">    1242367 :   return 0;</span>
<span class="lineNum">     836 </span>            : }
<span class="lineNum">     837 </span>            : 
<span class="lineNum">     838 </span>            : } // anon namespace
<a name="839"><span class="lineNum">     839 </span>            : </a>
<span class="lineNum">     840 </span>            : gimple_opt_pass *
<span class="lineNum">     841 </span><span class="lineCov">     170312 : make_pass_dominator (gcc::context *ctxt)</span>
<span class="lineNum">     842 </span>            : {
<span class="lineNum">     843 </span><span class="lineCov">     170312 :   return new pass_dominator (ctxt);</span>
<span class="lineNum">     844 </span>            : }
<span class="lineNum">     845 </span>            : 
<span class="lineNum">     846 </span>            : /* A hack until we remove threading from tree-vrp.c and bring the
<span class="lineNum">     847 </span>            :    simplification routine into the dom_opt_dom_walker class.  */
<span class="lineNum">     848 </span>            : static class vr_values *x_vr_values;
<span class="lineNum">     849 </span>            : 
<span class="lineNum">     850 </span>            : /* A trivial wrapper so that we can present the generic jump
<a name="851"><span class="lineNum">     851 </span>            :    threading code with a simple API for simplifying statements.  */</a>
<span class="lineNum">     852 </span>            : static tree
<span class="lineNum">     853 </span><span class="lineCov">   18026894 : simplify_stmt_for_jump_threading (gimple *stmt,</span>
<span class="lineNum">     854 </span>            :                                   gimple *within_stmt ATTRIBUTE_UNUSED,
<span class="lineNum">     855 </span>            :                                   class avail_exprs_stack *avail_exprs_stack,
<span class="lineNum">     856 </span>            :                                   basic_block bb ATTRIBUTE_UNUSED)
<span class="lineNum">     857 </span>            : {
<span class="lineNum">     858 </span>            :   /* First query our hash table to see if the the expression is available
<span class="lineNum">     859 </span>            :      there.  A non-NULL return value will be either a constant or another
<span class="lineNum">     860 </span>            :      SSA_NAME.  */
<span class="lineNum">     861 </span><span class="lineCov">   18026894 :   tree cached_lhs =  avail_exprs_stack-&gt;lookup_avail_expr (stmt, false, true);</span>
<span class="lineNum">     862 </span><span class="lineCov">   18026894 :   if (cached_lhs)</span>
<span class="lineNum">     863 </span>            :     return cached_lhs;
<span class="lineNum">     864 </span>            : 
<span class="lineNum">     865 </span>            :   /* If the hash table query failed, query VRP information.  This is
<span class="lineNum">     866 </span>            :      essentially the same as tree-vrp's simplification routine.  The
<span class="lineNum">     867 </span>            :      copy in tree-vrp is scheduled for removal in gcc-9.  */
<span class="lineNum">     868 </span><span class="lineCov">   17530788 :   if (gcond *cond_stmt = dyn_cast &lt;gcond *&gt; (stmt))</span>
<span class="lineNum">     869 </span>            :     {
<span class="lineNum">     870 </span><span class="lineCov">    5653382 :       cached_lhs</span>
<span class="lineNum">     871 </span><span class="lineCov">   16960146 :         = x_vr_values-&gt;vrp_evaluate_conditional (gimple_cond_code (cond_stmt),</span>
<span class="lineNum">     872 </span>            :                                                  gimple_cond_lhs (cond_stmt),
<span class="lineNum">     873 </span>            :                                                  gimple_cond_rhs (cond_stmt),
<span class="lineNum">     874 </span>            :                                                  within_stmt);
<span class="lineNum">     875 </span><span class="lineCov">    5653382 :       return cached_lhs;</span>
<span class="lineNum">     876 </span>            :     }
<span class="lineNum">     877 </span>            : 
<span class="lineNum">     878 </span><span class="lineCov">   11877406 :   if (gswitch *switch_stmt = dyn_cast &lt;gswitch *&gt; (stmt))</span>
<span class="lineNum">     879 </span>            :     {
<span class="lineNum">     880 </span><span class="lineCov">      10570 :       tree op = gimple_switch_index (switch_stmt);</span>
<span class="lineNum">     881 </span><span class="lineCov">      10570 :       if (TREE_CODE (op) != SSA_NAME)</span>
<span class="lineNum">     882 </span>            :         return NULL_TREE;
<span class="lineNum">     883 </span>            : 
<span class="lineNum">     884 </span><span class="lineCov">      10570 :       value_range *vr = x_vr_values-&gt;get_value_range (op);</span>
<span class="lineNum">     885 </span><span class="lineCov">      10570 :       if ((vr-&gt;type != VR_RANGE &amp;&amp; vr-&gt;type != VR_ANTI_RANGE)</span>
<span class="lineNum">     886 </span><span class="lineCov">      10570 :           || symbolic_range_p (vr))</span>
<span class="lineNum">     887 </span><span class="lineCov">       7634 :         return NULL_TREE;</span>
<span class="lineNum">     888 </span>            : 
<span class="lineNum">     889 </span><span class="lineCov">       2936 :       if (vr-&gt;type == VR_RANGE)</span>
<span class="lineNum">     890 </span>            :         {
<span class="lineNum">     891 </span><span class="lineCov">       2431 :           size_t i, j;</span>
<span class="lineNum">     892 </span>            : 
<span class="lineNum">     893 </span><span class="lineCov">       2431 :           find_case_label_range (switch_stmt, vr-&gt;min, vr-&gt;max, &amp;i, &amp;j);</span>
<span class="lineNum">     894 </span>            : 
<span class="lineNum">     895 </span><span class="lineCov">       2431 :           if (i == j)</span>
<span class="lineNum">     896 </span>            :             {
<span class="lineNum">     897 </span><span class="lineCov">         48 :               tree label = gimple_switch_label (switch_stmt, i);</span>
<span class="lineNum">     898 </span>            : 
<span class="lineNum">     899 </span><span class="lineCov">         48 :               if (CASE_HIGH (label) != NULL_TREE</span>
<span class="lineNum">     900 </span><span class="lineCov">         48 :                   ? (tree_int_cst_compare (CASE_LOW (label), vr-&gt;min) &lt;= 0</span>
<span class="lineNum">     901 </span><span class="lineNoCov">          0 :                      &amp;&amp; tree_int_cst_compare (CASE_HIGH (label), vr-&gt;max) &gt;= 0)</span>
<span class="lineNum">     902 </span><span class="lineCov">         96 :                   : (tree_int_cst_equal (CASE_LOW (label), vr-&gt;min)</span>
<span class="lineNum">     903 </span><span class="lineCov">         48 :                      &amp;&amp; tree_int_cst_equal (vr-&gt;min, vr-&gt;max)))</span>
<span class="lineNum">     904 </span><span class="lineNoCov">          0 :                 return label;</span>
<span class="lineNum">     905 </span>            : 
<span class="lineNum">     906 </span><span class="lineCov">         48 :               if (i &gt; j)</span>
<span class="lineNum">     907 </span><span class="lineNoCov">          0 :                 return gimple_switch_label (switch_stmt, 0);</span>
<span class="lineNum">     908 </span>            :             }
<span class="lineNum">     909 </span>            :         }
<span class="lineNum">     910 </span>            : 
<span class="lineNum">     911 </span><span class="lineCov">       2936 :       if (vr-&gt;type == VR_ANTI_RANGE)</span>
<span class="lineNum">     912 </span>            :           {
<span class="lineNum">     913 </span><span class="lineCov">        505 :             unsigned n = gimple_switch_num_labels (switch_stmt);</span>
<span class="lineNum">     914 </span><span class="lineCov">        505 :             tree min_label = gimple_switch_label (switch_stmt, 1);</span>
<span class="lineNum">     915 </span><span class="lineCov">        505 :             tree max_label = gimple_switch_label (switch_stmt, n - 1);</span>
<span class="lineNum">     916 </span>            : 
<span class="lineNum">     917 </span>            :             /* The default label will be taken only if the anti-range of the
<span class="lineNum">     918 </span>            :                operand is entirely outside the bounds of all the (non-default)
<span class="lineNum">     919 </span>            :                case labels.  */
<span class="lineNum">     920 </span><span class="lineCov">        505 :             if (tree_int_cst_compare (vr-&gt;min, CASE_LOW (min_label)) &lt;= 0</span>
<span class="lineNum">     921 </span><span class="lineCov">        521 :                 &amp;&amp; (CASE_HIGH (max_label) != NULL_TREE</span>
<span class="lineNum">     922 </span><span class="lineCov">        325 :                     ? tree_int_cst_compare (vr-&gt;max, CASE_HIGH (max_label)) &gt;= 0</span>
<span class="lineNum">     923 </span><span class="lineCov">        586 :                     : tree_int_cst_compare (vr-&gt;max, CASE_LOW (max_label)) &gt;= 0))</span>
<span class="lineNum">     924 </span><span class="lineNoCov">          0 :             return gimple_switch_label (switch_stmt, 0);</span>
<span class="lineNum">     925 </span>            :           }
<span class="lineNum">     926 </span><span class="lineCov">       2936 :         return NULL_TREE;</span>
<span class="lineNum">     927 </span>            :     }
<span class="lineNum">     928 </span>            : 
<span class="lineNum">     929 </span><span class="lineCov">   11866836 :   if (gassign *assign_stmt = dyn_cast &lt;gassign *&gt; (stmt))</span>
<span class="lineNum">     930 </span>            :     {
<span class="lineNum">     931 </span><span class="lineCov">   10909369 :       tree lhs = gimple_assign_lhs (assign_stmt);</span>
<span class="lineNum">     932 </span><span class="lineCov">   10909369 :       if (TREE_CODE (lhs) == SSA_NAME</span>
<span class="lineNum">     933 </span><span class="lineCov">   10909369 :           &amp;&amp; (INTEGRAL_TYPE_P (TREE_TYPE (lhs))</span>
<span class="lineNum">     934 </span><span class="lineCov">    7218636 :               || POINTER_TYPE_P (TREE_TYPE (lhs)))</span>
<span class="lineNum">     935 </span><span class="lineCov">   20999083 :           &amp;&amp; stmt_interesting_for_vrp (stmt))</span>
<span class="lineNum">     936 </span>            :         {
<span class="lineNum">     937 </span><span class="lineCov">    6403085 :           edge dummy_e;</span>
<span class="lineNum">     938 </span><span class="lineCov">    6403085 :           tree dummy_tree;</span>
<span class="lineNum">     939 </span><span class="lineCov">    6403085 :           value_range new_vr = VR_INITIALIZER;</span>
<span class="lineNum">     940 </span><span class="lineCov">    6403085 :           x_vr_values-&gt;extract_range_from_stmt (stmt, &amp;dummy_e,</span>
<span class="lineNum">     941 </span>            :                                               &amp;dummy_tree, &amp;new_vr);
<span class="lineNum">     942 </span><span class="lineCov">    6403085 :           if (range_int_cst_singleton_p (&amp;new_vr))</span>
<span class="lineNum">     943 </span><span class="lineCov">       9148 :             return new_vr.min;</span>
<span class="lineNum">     944 </span>            :         }
<span class="lineNum">     945 </span>            :     }
<span class="lineNum">     946 </span>            :   return NULL;
<span class="lineNum">     947 </span>            : }
<span class="lineNum">     948 </span>            : 
<span class="lineNum">     949 </span>            : /* Valueize hook for gimple_fold_stmt_to_constant_1.  */
<span class="lineNum">     950 </span>            : 
<span class="lineNum">     951 </span>            : static tree
<span class="lineNum">     952 </span><span class="lineCov">   22422805 : dom_valueize (tree t)</span>
<span class="lineNum">     953 </span>            : {
<span class="lineNum">     954 </span><span class="lineCov">   22422805 :   if (TREE_CODE (t) == SSA_NAME)</span>
<span class="lineNum">     955 </span>            :     {
<span class="lineNum">     956 </span><span class="lineCov">   47133318 :       tree tem = SSA_NAME_VALUE (t);</span>
<span class="lineNum">     957 </span><span class="lineCov">   12404259 :       if (tem)</span>
<span class="lineNum">     958 </span><span class="lineCov">    2478234 :         return tem;</span>
<span class="lineNum">     959 </span>            :     }
<span class="lineNum">     960 </span>            :   return t;
<span class="lineNum">     961 </span>            : }
<span class="lineNum">     962 </span>            : 
<span class="lineNum">     963 </span>            : /* We have just found an equivalence for LHS on an edge E.
<span class="lineNum">     964 </span>            :    Look backwards to other uses of LHS and see if we can derive
<a name="965"><span class="lineNum">     965 </span>            :    additional equivalences that are valid on edge E.  */</a>
<span class="lineNum">     966 </span>            : static void
<span class="lineNum">     967 </span><span class="lineCov">    7112942 : back_propagate_equivalences (tree lhs, edge e,</span>
<span class="lineNum">     968 </span>            :                              class const_and_copies *const_and_copies)
<span class="lineNum">     969 </span>            : {
<span class="lineNum">     970 </span><span class="lineCov">    7112942 :   use_operand_p use_p;</span>
<span class="lineNum">     971 </span><span class="lineCov">    7112942 :   imm_use_iterator iter;</span>
<span class="lineNum">     972 </span><span class="lineCov">    7112942 :   bitmap domby = NULL;</span>
<span class="lineNum">     973 </span><span class="lineCov">    7112942 :   basic_block dest = e-&gt;dest;</span>
<span class="lineNum">     974 </span>            : 
<span class="lineNum">     975 </span>            :   /* Iterate over the uses of LHS to see if any dominate E-&gt;dest.
<span class="lineNum">     976 </span>            :      If so, they may create useful equivalences too.
<span class="lineNum">     977 </span>            : 
<span class="lineNum">     978 </span>            :      ???  If the code gets re-organized to a worklist to catch more
<span class="lineNum">     979 </span>            :      indirect opportunities and it is made to handle PHIs then this
<span class="lineNum">     980 </span>            :      should only consider use_stmts in basic-blocks we have already visited.  */
<span class="lineNum">     981 </span><span class="lineCov">   27408868 :   FOR_EACH_IMM_USE_FAST (use_p, iter, lhs)</span>
<span class="lineNum">     982 </span>            :     {
<span class="lineNum">     983 </span><span class="lineCov">   20295926 :       gimple *use_stmt = USE_STMT (use_p);</span>
<span class="lineNum">     984 </span>            : 
<span class="lineNum">     985 </span>            :       /* Often the use is in DEST, which we trivially know we can't use.
<span class="lineNum">     986 </span>            :          This is cheaper than the dominator set tests below.  */
<span class="lineNum">     987 </span><span class="lineCov">   40591852 :       if (dest == gimple_bb (use_stmt))</span>
<span class="lineNum">     988 </span>            :         continue;
<span class="lineNum">     989 </span>            : 
<span class="lineNum">     990 </span>            :       /* Filter out statements that can never produce a useful
<span class="lineNum">     991 </span>            :          equivalence.  */
<span class="lineNum">     992 </span><span class="lineCov">   20045769 :       tree lhs2 = gimple_get_lhs (use_stmt);</span>
<span class="lineNum">     993 </span><span class="lineCov">   20045769 :       if (!lhs2 || TREE_CODE (lhs2) != SSA_NAME)</span>
<span class="lineNum">     994 </span>            :         continue;
<span class="lineNum">     995 </span>            : 
<span class="lineNum">     996 </span>            :       /* Profiling has shown the domination tests here can be fairly
<span class="lineNum">     997 </span>            :          expensive.  We get significant improvements by building the
<span class="lineNum">     998 </span>            :          set of blocks that dominate BB.  We can then just test
<span class="lineNum">     999 </span>            :          for set membership below.
<span class="lineNum">    1000 </span>            : 
<span class="lineNum">    1001 </span>            :          We also initialize the set lazily since often the only uses
<span class="lineNum">    1002 </span>            :          are going to be in the same block as DEST.  */
<span class="lineNum">    1003 </span><span class="lineCov">    4180224 :       if (!domby)</span>
<span class="lineNum">    1004 </span>            :         {
<span class="lineNum">    1005 </span><span class="lineCov">    2161568 :           domby = BITMAP_ALLOC (NULL);</span>
<span class="lineNum">    1006 </span><span class="lineCov">    2161568 :           basic_block bb = get_immediate_dominator (CDI_DOMINATORS, dest);</span>
<span class="lineNum">    1007 </span><span class="lineCov">   56205081 :           while (bb)</span>
<span class="lineNum">    1008 </span>            :             {
<span class="lineNum">    1009 </span><span class="lineCov">   54043513 :               bitmap_set_bit (domby, bb-&gt;index);</span>
<span class="lineNum">    1010 </span><span class="lineCov">   54043513 :               bb = get_immediate_dominator (CDI_DOMINATORS, bb);</span>
<span class="lineNum">    1011 </span>            :             }
<span class="lineNum">    1012 </span>            :         }
<span class="lineNum">    1013 </span>            : 
<span class="lineNum">    1014 </span>            :       /* This tests if USE_STMT does not dominate DEST.  */
<span class="lineNum">    1015 </span><span class="lineCov">    8360448 :       if (!bitmap_bit_p (domby, gimple_bb (use_stmt)-&gt;index))</span>
<span class="lineNum">    1016 </span>            :         continue;
<span class="lineNum">    1017 </span>            : 
<span class="lineNum">    1018 </span>            :       /* At this point USE_STMT dominates DEST and may result in a
<span class="lineNum">    1019 </span>            :          useful equivalence.  Try to simplify its RHS to a constant
<span class="lineNum">    1020 </span>            :          or SSA_NAME.  */
<span class="lineNum">    1021 </span><span class="lineCov">    2062250 :       tree res = gimple_fold_stmt_to_constant_1 (use_stmt, dom_valueize,</span>
<span class="lineNum">    1022 </span><span class="lineCov">    2062250 :                                                  no_follow_ssa_edges);</span>
<span class="lineNum">    1023 </span><span class="lineCov">    2062250 :       if (res &amp;&amp; (TREE_CODE (res) == SSA_NAME || is_gimple_min_invariant (res)))</span>
<span class="lineNum">    1024 </span><span class="lineCov">    1758301 :         record_equality (lhs2, res, const_and_copies);</span>
<span class="lineNum">    1025 </span>            :     }
<span class="lineNum">    1026 </span>            : 
<span class="lineNum">    1027 </span><span class="lineCov">    7112942 :   if (domby)</span>
<span class="lineNum">    1028 </span><span class="lineCov">    2161568 :     BITMAP_FREE (domby);</span>
<span class="lineNum">    1029 </span><span class="lineCov">    7112942 : }</span>
<span class="lineNum">    1030 </span>            : 
<span class="lineNum">    1031 </span>            : /* Record into CONST_AND_COPIES and AVAIL_EXPRS_STACK any equivalences implied
<span class="lineNum">    1032 </span>            :    by traversing edge E (which are cached in E-&gt;aux).
<span class="lineNum">    1033 </span>            : 
<span class="lineNum">    1034 </span>            :    Callers are responsible for managing the unwinding markers.  */
<span class="lineNum">    1035 </span>            : void
<span class="lineNum">    1036 </span><span class="lineCov">   26217101 : record_temporary_equivalences (edge e,</span>
<span class="lineNum">    1037 </span>            :                                class const_and_copies *const_and_copies,
<span class="lineNum">    1038 </span>            :                                class avail_exprs_stack *avail_exprs_stack)
<span class="lineNum">    1039 </span>            : {
<span class="lineNum">    1040 </span><span class="lineCov">   26217101 :   int i;</span>
<span class="lineNum">    1041 </span><span class="lineCov">   26217101 :   class edge_info *edge_info = (class edge_info *) e-&gt;aux;</span>
<span class="lineNum">    1042 </span>            : 
<span class="lineNum">    1043 </span>            :   /* If we have info associated with this edge, record it into
<span class="lineNum">    1044 </span>            :      our equivalence tables.  */
<span class="lineNum">    1045 </span><span class="lineCov">   26217101 :   if (edge_info)</span>
<span class="lineNum">    1046 </span>            :     {
<span class="lineNum">    1047 </span>            :       cond_equivalence *eq;
<span class="lineNum">    1048 </span>            :       /* If we have 0 = COND or 1 = COND equivalences, record them
<span class="lineNum">    1049 </span>            :          into our expression hash tables.  */
<span class="lineNum">    1050 </span><span class="lineCov">   47318500 :       for (i = 0; edge_info-&gt;cond_equivalences.iterate (i, &amp;eq); ++i)</span>
<span class="lineNum">    1051 </span><span class="lineCov">   34717637 :         avail_exprs_stack-&gt;record_cond (eq);</span>
<span class="lineNum">    1052 </span>            : 
<span class="lineNum">    1053 </span>            :       edge_info::equiv_pair *seq;
<span class="lineNum">    1054 </span><span class="lineCov">   19713805 :       for (i = 0; edge_info-&gt;simple_equivalences.iterate (i, &amp;seq); ++i)</span>
<span class="lineNum">    1055 </span>            :         {
<span class="lineNum">    1056 </span><span class="lineCov">    7112942 :           tree lhs = seq-&gt;first;</span>
<span class="lineNum">    1057 </span><span class="lineCov">    7112942 :           if (!lhs || TREE_CODE (lhs) != SSA_NAME)</span>
<span class="lineNum">    1058 </span>            :             continue;
<span class="lineNum">    1059 </span>            : 
<span class="lineNum">    1060 </span>            :           /* Record the simple NAME = VALUE equivalence.  */
<span class="lineNum">    1061 </span><span class="lineCov">    7112942 :           tree rhs = seq-&gt;second;</span>
<span class="lineNum">    1062 </span>            : 
<span class="lineNum">    1063 </span>            :           /* If this is a SSA_NAME = SSA_NAME equivalence and one operand is
<span class="lineNum">    1064 </span>            :              cheaper to compute than the other, then set up the equivalence
<span class="lineNum">    1065 </span>            :              such that we replace the expensive one with the cheap one.
<span class="lineNum">    1066 </span>            : 
<span class="lineNum">    1067 </span>            :              If they are the same cost to compute, then do not record
<span class="lineNum">    1068 </span>            :              anything.  */
<span class="lineNum">    1069 </span><span class="lineCov">    7112942 :           if (TREE_CODE (lhs) == SSA_NAME &amp;&amp; TREE_CODE (rhs) == SSA_NAME)</span>
<span class="lineNum">    1070 </span>            :             {
<span class="lineNum">    1071 </span><span class="lineCov">     882582 :               gimple *rhs_def = SSA_NAME_DEF_STMT (rhs);</span>
<span class="lineNum">    1072 </span><span class="lineCov">     882582 :               int rhs_cost = estimate_num_insns (rhs_def, &amp;eni_size_weights);</span>
<span class="lineNum">    1073 </span>            : 
<span class="lineNum">    1074 </span><span class="lineCov">     882582 :               gimple *lhs_def = SSA_NAME_DEF_STMT (lhs);</span>
<span class="lineNum">    1075 </span><span class="lineCov">     882582 :               int lhs_cost = estimate_num_insns (lhs_def, &amp;eni_size_weights);</span>
<span class="lineNum">    1076 </span>            : 
<span class="lineNum">    1077 </span><span class="lineCov">     882582 :               if (rhs_cost &gt; lhs_cost)</span>
<span class="lineNum">    1078 </span><span class="lineCov">      98034 :                 record_equality (rhs, lhs, const_and_copies);</span>
<span class="lineNum">    1079 </span><span class="lineCov">     784548 :               else if (rhs_cost &lt; lhs_cost)</span>
<span class="lineNum">    1080 </span><span class="lineCov">     214099 :                 record_equality (lhs, rhs, const_and_copies);</span>
<span class="lineNum">    1081 </span>            :             }
<span class="lineNum">    1082 </span>            :           else
<span class="lineNum">    1083 </span><span class="lineCov">    6230360 :             record_equality (lhs, rhs, const_and_copies);</span>
<span class="lineNum">    1084 </span>            : 
<span class="lineNum">    1085 </span>            : 
<span class="lineNum">    1086 </span>            :           /* Any equivalence found for LHS may result in additional
<span class="lineNum">    1087 </span>            :              equivalences for other uses of LHS that we have already
<span class="lineNum">    1088 </span>            :              processed.  */
<span class="lineNum">    1089 </span><span class="lineCov">    7112942 :           back_propagate_equivalences (lhs, e, const_and_copies);</span>
<span class="lineNum">    1090 </span>            :         }
<span class="lineNum">    1091 </span>            :     }
<span class="lineNum">    1092 </span><span class="lineCov">   26217101 : }</span>
<span class="lineNum">    1093 </span>            : 
<span class="lineNum">    1094 </span>            : /* PHI nodes can create equivalences too.
<span class="lineNum">    1095 </span>            : 
<span class="lineNum">    1096 </span>            :    Ignoring any alternatives which are the same as the result, if
<span class="lineNum">    1097 </span>            :    all the alternatives are equal, then the PHI node creates an
<span class="lineNum">    1098 </span>            :    equivalence.  */
<span class="lineNum">    1099 </span>            : 
<span class="lineNum">    1100 </span>            : static void
<span class="lineNum">    1101 </span><span class="lineCov">   13413556 : record_equivalences_from_phis (basic_block bb)</span>
<span class="lineNum">    1102 </span>            : {
<span class="lineNum">    1103 </span><span class="lineCov">   13413556 :   gphi_iterator gsi;</span>
<span class="lineNum">    1104 </span>            : 
<span class="lineNum">    1105 </span><span class="lineCov">   18353320 :   for (gsi = gsi_start_phis (bb); !gsi_end_p (gsi); gsi_next (&amp;gsi))</span>
<span class="lineNum">    1106 </span>            :     {
<span class="lineNum">    1107 </span><span class="lineCov">    4939764 :       gphi *phi = gsi.phi ();</span>
<span class="lineNum">    1108 </span>            : 
<span class="lineNum">    1109 </span><span class="lineCov">    4939764 :       tree lhs = gimple_phi_result (phi);</span>
<span class="lineNum">    1110 </span><span class="lineCov">    4939764 :       tree rhs = NULL;</span>
<span class="lineNum">    1111 </span><span class="lineCov">    4939764 :       size_t i;</span>
<span class="lineNum">    1112 </span>            : 
<span class="lineNum">    1113 </span><span class="lineCov">   10068467 :       for (i = 0; i &lt; gimple_phi_num_args (phi); i++)</span>
<span class="lineNum">    1114 </span>            :         {
<span class="lineNum">    1115 </span><span class="lineCov">    9441602 :           tree t = gimple_phi_arg_def (phi, i);</span>
<span class="lineNum">    1116 </span>            : 
<span class="lineNum">    1117 </span>            :           /* Ignore alternatives which are the same as our LHS.  Since
<span class="lineNum">    1118 </span>            :              LHS is a PHI_RESULT, it is known to be a SSA_NAME, so we
<span class="lineNum">    1119 </span>            :              can simply compare pointers.  */
<span class="lineNum">    1120 </span><span class="lineCov">    9441602 :           if (lhs == t)</span>
<span class="lineNum">    1121 </span>            :             continue;
<span class="lineNum">    1122 </span>            : 
<span class="lineNum">    1123 </span>            :           /* If the associated edge is not marked as executable, then it
<span class="lineNum">    1124 </span>            :              can be ignored.  */
<span class="lineNum">    1125 </span><span class="lineCov">    9422261 :           if ((gimple_phi_arg_edge (phi, i)-&gt;flags &amp; EDGE_EXECUTABLE) == 0)</span>
<span class="lineNum">    1126 </span>            :             continue;
<span class="lineNum">    1127 </span>            : 
<span class="lineNum">    1128 </span><span class="lineCov">    9376682 :           t = dom_valueize (t);</span>
<span class="lineNum">    1129 </span>            : 
<span class="lineNum">    1130 </span>            :           /* If T is an SSA_NAME and its associated edge is a backedge,
<span class="lineNum">    1131 </span>            :              then quit as we can not utilize this equivalence.  */
<span class="lineNum">    1132 </span><span class="lineCov">    9376682 :           if (TREE_CODE (t) == SSA_NAME</span>
<span class="lineNum">    1133 </span><span class="lineCov">    9376682 :               &amp;&amp; (gimple_phi_arg_edge (phi, i)-&gt;flags &amp; EDGE_DFS_BACK))</span>
<span class="lineNum">    1134 </span>            :             break;
<span class="lineNum">    1135 </span>            : 
<span class="lineNum">    1136 </span>            :           /* If we have not processed an alternative yet, then set
<span class="lineNum">    1137 </span>            :              RHS to this alternative.  */
<span class="lineNum">    1138 </span><span class="lineCov">    7868207 :           if (rhs == NULL)</span>
<span class="lineNum">    1139 </span>            :             rhs = t;
<span class="lineNum">    1140 </span>            :           /* If we have processed an alternative (stored in RHS), then
<span class="lineNum">    1141 </span>            :              see if it is equal to this one.  If it isn't, then stop
<span class="lineNum">    1142 </span>            :              the search.  */
<span class="lineNum">    1143 </span><span class="lineCov">    3030527 :           else if (! operand_equal_for_phi_arg_p (rhs, t))</span>
<span class="lineNum">    1144 </span>            :             break;
<span class="lineNum">    1145 </span>            :         }
<span class="lineNum">    1146 </span>            : 
<span class="lineNum">    1147 </span>            :       /* If we had no interesting alternatives, then all the RHS alternatives
<span class="lineNum">    1148 </span>            :          must have been the same as LHS.  */
<span class="lineNum">    1149 </span><span class="lineCov">    4939764 :       if (!rhs)</span>
<span class="lineNum">    1150 </span><span class="lineCov">     102084 :         rhs = lhs;</span>
<span class="lineNum">    1151 </span>            : 
<span class="lineNum">    1152 </span>            :       /* If we managed to iterate through each PHI alternative without
<span class="lineNum">    1153 </span>            :          breaking out of the loop, then we have a PHI which may create
<span class="lineNum">    1154 </span>            :          a useful equivalence.  We do not need to record unwind data for
<span class="lineNum">    1155 </span>            :          this, since this is a true assignment and not an equivalence
<span class="lineNum">    1156 </span>            :          inferred from a comparison.  All uses of this ssa name are dominated
<span class="lineNum">    1157 </span>            :          by this assignment, so unwinding just costs time and space.  */
<span class="lineNum">    1158 </span><span class="lineCov">    4939764 :       if (i == gimple_phi_num_args (phi)</span>
<span class="lineNum">    1159 </span><span class="lineCov">    4939764 :           &amp;&amp; may_propagate_copy (lhs, rhs))</span>
<span class="lineNum">    1160 </span><span class="lineCov">     492326 :         set_ssa_name_value (lhs, rhs);</span>
<span class="lineNum">    1161 </span>            :     }
<span class="lineNum">    1162 </span><span class="lineCov">   13413556 : }</span>
<span class="lineNum">    1163 </span>            : 
<span class="lineNum">    1164 </span>            : /* Record any equivalences created by the incoming edge to BB into
<span class="lineNum">    1165 </span>            :    CONST_AND_COPIES and AVAIL_EXPRS_STACK.  If BB has more than one
<span class="lineNum">    1166 </span>            :    incoming edge, then no equivalence is created.  */
<a name="1167"><span class="lineNum">    1167 </span>            : </a>
<span class="lineNum">    1168 </span>            : static void
<span class="lineNum">    1169 </span><span class="lineCov">   13413556 : record_equivalences_from_incoming_edge (basic_block bb,</span>
<span class="lineNum">    1170 </span>            :     class const_and_copies *const_and_copies,
<span class="lineNum">    1171 </span>            :     class avail_exprs_stack *avail_exprs_stack)
<span class="lineNum">    1172 </span>            : {
<span class="lineNum">    1173 </span><span class="lineCov">   13413556 :   edge e;</span>
<span class="lineNum">    1174 </span><span class="lineCov">   13413556 :   basic_block parent;</span>
<span class="lineNum">    1175 </span>            : 
<span class="lineNum">    1176 </span>            :   /* If our parent block ended with a control statement, then we may be
<span class="lineNum">    1177 </span>            :      able to record some equivalences based on which outgoing edge from
<span class="lineNum">    1178 </span>            :      the parent was followed.  */
<span class="lineNum">    1179 </span><span class="lineCov">   13413556 :   parent = get_immediate_dominator (CDI_DOMINATORS, bb);</span>
<span class="lineNum">    1180 </span>            : 
<span class="lineNum">    1181 </span><span class="lineCov">   13413556 :   e = single_pred_edge_ignoring_loop_edges (bb, true);</span>
<span class="lineNum">    1182 </span>            : 
<span class="lineNum">    1183 </span>            :   /* If we had a single incoming edge from our parent block, then enter
<span class="lineNum">    1184 </span>            :      any data associated with the edge into our tables.  */
<span class="lineNum">    1185 </span><span class="lineCov">   13413556 :   if (e &amp;&amp; e-&gt;src == parent)</span>
<span class="lineNum">    1186 </span><span class="lineCov">    9919788 :     record_temporary_equivalences (e, const_and_copies, avail_exprs_stack);</span>
<span class="lineNum">    1187 </span><span class="lineCov">   13413556 : }</span>
<span class="lineNum">    1188 </span>            : 
<span class="lineNum">    1189 </span>            : /* Dump statistics for the hash table HTAB.  */
<a name="1190"><span class="lineNum">    1190 </span>            : </a>
<span class="lineNum">    1191 </span>            : static void
<span class="lineNum">    1192 </span><span class="lineCov">         45 : htab_statistics (FILE *file, const hash_table&lt;expr_elt_hasher&gt; &amp;htab)</span>
<span class="lineNum">    1193 </span>            : {
<span class="lineNum">    1194 </span><span class="lineCov">         45 :   fprintf (file, &quot;size %ld, %ld elements, %f collision/search ratio\n&quot;,</span>
<span class="lineNum">    1195 </span><span class="lineCov">         45 :            (long) htab.size (),</span>
<span class="lineNum">    1196 </span><span class="lineCov">         45 :            (long) htab.elements (),</span>
<span class="lineNum">    1197 </span>            :            htab.collisions ());
<span class="lineNum">    1198 </span><span class="lineCov">         45 : }</span>
<span class="lineNum">    1199 </span>            : 
<span class="lineNum">    1200 </span>            : /* Dump SSA statistics on FILE.  */
<a name="1201"><span class="lineNum">    1201 </span>            : </a>
<span class="lineNum">    1202 </span>            : static void
<span class="lineNum">    1203 </span><span class="lineCov">         45 : dump_dominator_optimization_stats (FILE *file,</span>
<span class="lineNum">    1204 </span>            :                                    hash_table&lt;expr_elt_hasher&gt; *avail_exprs)
<span class="lineNum">    1205 </span>            : {
<span class="lineNum">    1206 </span><span class="lineCov">         45 :   fprintf (file, &quot;Total number of statements:                   %6ld\n\n&quot;,</span>
<span class="lineNum">    1207 </span>            :            opt_stats.num_stmts);
<span class="lineNum">    1208 </span><span class="lineCov">         45 :   fprintf (file, &quot;Exprs considered for dominator optimizations: %6ld\n&quot;,</span>
<span class="lineNum">    1209 </span>            :            opt_stats.num_exprs_considered);
<span class="lineNum">    1210 </span>            : 
<span class="lineNum">    1211 </span><span class="lineCov">         45 :   fprintf (file, &quot;\nHash table statistics:\n&quot;);</span>
<span class="lineNum">    1212 </span>            : 
<span class="lineNum">    1213 </span><span class="lineCov">         45 :   fprintf (file, &quot;    avail_exprs: &quot;);</span>
<span class="lineNum">    1214 </span><span class="lineCov">         45 :   htab_statistics (file, *avail_exprs);</span>
<span class="lineNum">    1215 </span><span class="lineCov">         45 : }</span>
<span class="lineNum">    1216 </span>            : 
<span class="lineNum">    1217 </span>            : 
<span class="lineNum">    1218 </span>            : /* Similarly, but assume that X and Y are the two operands of an EQ_EXPR.
<span class="lineNum">    1219 </span>            :    This constrains the cases in which we may treat this as assignment.  */
<span class="lineNum">    1220 </span>            : 
<span class="lineNum">    1221 </span>            : static void
<span class="lineNum">    1222 </span><span class="lineCov">    8300794 : record_equality (tree x, tree y, class const_and_copies *const_and_copies)</span>
<span class="lineNum">    1223 </span>            : {
<span class="lineNum">    1224 </span><span class="lineCov">    8300794 :   tree prev_x = NULL, prev_y = NULL;</span>
<span class="lineNum">    1225 </span>            : 
<span class="lineNum">    1226 </span><span class="lineCov">    8300794 :   if (tree_swap_operands_p (x, y))</span>
<span class="lineNum">    1227 </span><span class="lineCov">     797867 :     std::swap (x, y);</span>
<span class="lineNum">    1228 </span>            : 
<span class="lineNum">    1229 </span>            :   /* Most of the time tree_swap_operands_p does what we want.  But there
<span class="lineNum">    1230 </span>            :      are cases where we know one operand is better for copy propagation than
<span class="lineNum">    1231 </span>            :      the other.  Given no other code cares about ordering of equality
<span class="lineNum">    1232 </span>            :      comparison operators for that purpose, we just handle the special cases
<span class="lineNum">    1233 </span>            :      here.  */
<span class="lineNum">    1234 </span><span class="lineCov">    8300794 :   if (TREE_CODE (x) == SSA_NAME &amp;&amp; TREE_CODE (y) == SSA_NAME)</span>
<span class="lineNum">    1235 </span>            :     {
<span class="lineNum">    1236 </span>            :       /* If one operand is a single use operand, then make it
<span class="lineNum">    1237 </span>            :          X.  This will preserve its single use properly and if this
<span class="lineNum">    1238 </span>            :          conditional is eliminated, the computation of X can be
<span class="lineNum">    1239 </span>            :          eliminated as well.  */
<span class="lineNum">    1240 </span><span class="lineCov">     925920 :       if (has_single_use (y) &amp;&amp; ! has_single_use (x))</span>
<span class="lineNum">    1241 </span>            :         std::swap (x, y);
<span class="lineNum">    1242 </span>            :     }
<span class="lineNum">    1243 </span><span class="lineCov">    8300794 :   if (TREE_CODE (x) == SSA_NAME)</span>
<span class="lineNum">    1244 </span><span class="lineCov">   24351114 :     prev_x = SSA_NAME_VALUE (x);</span>
<span class="lineNum">    1245 </span><span class="lineCov">    8300794 :   if (TREE_CODE (y) == SSA_NAME)</span>
<span class="lineNum">    1246 </span><span class="lineCov">    3329028 :     prev_y = SSA_NAME_VALUE (y);</span>
<span class="lineNum">    1247 </span>            : 
<span class="lineNum">    1248 </span>            :   /* If one of the previous values is invariant, or invariant in more loops
<span class="lineNum">    1249 </span>            :      (by depth), then use that.
<span class="lineNum">    1250 </span>            :      Otherwise it doesn't matter which value we choose, just so
<span class="lineNum">    1251 </span>            :      long as we canonicalize on one value.  */
<span class="lineNum">    1252 </span><span class="lineCov">    8300794 :   if (is_gimple_min_invariant (y))</span>
<span class="lineNum">    1253 </span>            :     ;
<span class="lineNum">    1254 </span><span class="lineCov">    1109676 :   else if (is_gimple_min_invariant (x))</span>
<span class="lineNum">    1255 </span>            :     prev_x = x, x = y, y = prev_x, prev_x = prev_y;
<span class="lineNum">    1256 </span><span class="lineCov">     925920 :   else if (prev_x &amp;&amp; is_gimple_min_invariant (prev_x))</span>
<span class="lineNum">    1257 </span>            :     x = y, y = prev_x, prev_x = prev_y;
<span class="lineNum">    1258 </span><span class="lineCov">     806351 :   else if (prev_y)</span>
<span class="lineNum">    1259 </span><span class="lineCov">     509908 :     y = prev_y;</span>
<span class="lineNum">    1260 </span>            : 
<span class="lineNum">    1261 </span>            :   /* After the swapping, we must have one SSA_NAME.  */
<span class="lineNum">    1262 </span><span class="lineCov">    8300794 :   if (TREE_CODE (x) != SSA_NAME)</span>
<span class="lineNum">    1263 </span>            :     return;
<span class="lineNum">    1264 </span>            : 
<span class="lineNum">    1265 </span>            :   /* For IEEE, -0.0 == 0.0, so we don't necessarily know the sign of a
<span class="lineNum">    1266 </span>            :      variable compared against zero.  If we're honoring signed zeros,
<span class="lineNum">    1267 </span>            :      then we cannot record this value unless we know that the value is
<span class="lineNum">    1268 </span>            :      nonzero.  */
<span class="lineNum">    1269 </span><span class="lineCov">    8300794 :   if (HONOR_SIGNED_ZEROS (x)</span>
<span class="lineNum">    1270 </span><span class="lineCov">    8300794 :       &amp;&amp; (TREE_CODE (y) != REAL_CST</span>
<span class="lineNum">    1271 </span><span class="lineCov">     295652 :           || real_equal (&amp;dconst0, &amp;TREE_REAL_CST (y))))</span>
<span class="lineNum">    1272 </span><span class="lineCov">        432 :     return;</span>
<span class="lineNum">    1273 </span>            : 
<span class="lineNum">    1274 </span><span class="lineCov">    8300362 :   const_and_copies-&gt;record_const_or_copy (x, y, prev_x);</span>
<span class="lineNum">    1275 </span>            : }
<span class="lineNum">    1276 </span>            : 
<span class="lineNum">    1277 </span>            : /* Returns true when STMT is a simple iv increment.  It detects the
<span class="lineNum">    1278 </span>            :    following situation:
<span class="lineNum">    1279 </span>            : 
<span class="lineNum">    1280 </span>            :    i_1 = phi (..., i_k)
<span class="lineNum">    1281 </span>            :    [...]
<span class="lineNum">    1282 </span>            :    i_j = i_{j-1}  for each j : 2 &lt;= j &lt;= k-1
<span class="lineNum">    1283 </span>            :    [...]
<span class="lineNum">    1284 </span>            :    i_k = i_{k-1} +/- ...  */
<a name="1285"><span class="lineNum">    1285 </span>            : </a>
<span class="lineNum">    1286 </span>            : bool
<span class="lineNum">    1287 </span><span class="lineCov">   23531973 : simple_iv_increment_p (gimple *stmt)</span>
<span class="lineNum">    1288 </span>            : {
<span class="lineNum">    1289 </span><span class="lineCov">   23531973 :   enum tree_code code;</span>
<span class="lineNum">    1290 </span><span class="lineCov">   23531973 :   tree lhs, preinc;</span>
<span class="lineNum">    1291 </span><span class="lineCov">   23531973 :   gimple *phi;</span>
<span class="lineNum">    1292 </span><span class="lineCov">   23531973 :   size_t i;</span>
<span class="lineNum">    1293 </span>            : 
<span class="lineNum">    1294 </span><span class="lineCov">   47063946 :   if (gimple_code (stmt) != GIMPLE_ASSIGN)</span>
<span class="lineNum">    1295 </span>            :     return false;
<span class="lineNum">    1296 </span>            : 
<span class="lineNum">    1297 </span><span class="lineCov">   18043382 :   lhs = gimple_assign_lhs (stmt);</span>
<span class="lineNum">    1298 </span><span class="lineCov">   18043382 :   if (TREE_CODE (lhs) != SSA_NAME)</span>
<span class="lineNum">    1299 </span>            :     return false;
<span class="lineNum">    1300 </span>            : 
<span class="lineNum">    1301 </span><span class="lineCov">   18043382 :   code = gimple_assign_rhs_code (stmt);</span>
<span class="lineNum">    1302 </span><span class="lineCov">   36086764 :   if (code != PLUS_EXPR</span>
<span class="lineNum">    1303 </span><span class="lineCov">   18043382 :       &amp;&amp; code != MINUS_EXPR</span>
<span class="lineNum">    1304 </span><span class="lineCov">   18043382 :       &amp;&amp; code != POINTER_PLUS_EXPR)</span>
<span class="lineNum">    1305 </span>            :     return false;
<span class="lineNum">    1306 </span>            : 
<span class="lineNum">    1307 </span><span class="lineCov">    4074218 :   preinc = gimple_assign_rhs1 (stmt);</span>
<span class="lineNum">    1308 </span><span class="lineCov">    4074218 :   if (TREE_CODE (preinc) != SSA_NAME)</span>
<span class="lineNum">    1309 </span>            :     return false;
<span class="lineNum">    1310 </span>            : 
<span class="lineNum">    1311 </span><span class="lineCov">    7841018 :   phi = SSA_NAME_DEF_STMT (preinc);</span>
<span class="lineNum">    1312 </span><span class="lineCov">    7864310 :   while (gimple_code (phi) != GIMPLE_PHI)</span>
<span class="lineNum">    1313 </span>            :     {
<span class="lineNum">    1314 </span>            :       /* Follow trivial copies, but not the DEF used in a back edge,
<span class="lineNum">    1315 </span>            :          so that we don't prevent coalescing.  */
<span class="lineNum">    1316 </span><span class="lineCov">    2665485 :       if (!gimple_assign_ssa_name_copy_p (phi))</span>
<span class="lineNum">    1317 </span>            :         return false;
<span class="lineNum">    1318 </span><span class="lineCov">      11646 :       preinc = gimple_assign_rhs1 (phi);</span>
<span class="lineNum">    1319 </span><span class="lineCov">      11646 :       phi = SSA_NAME_DEF_STMT (preinc);</span>
<span class="lineNum">    1320 </span>            :     }
<span class="lineNum">    1321 </span>            : 
<span class="lineNum">    1322 </span><span class="lineCov">    4303976 :   for (i = 0; i &lt; gimple_phi_num_args (phi); i++)</span>
<span class="lineNum">    1323 </span><span class="lineCov">    2565344 :     if (gimple_phi_arg_def (phi, i) == lhs)</span>
<span class="lineNum">    1324 </span>            :       return true;
<span class="lineNum">    1325 </span>            : 
<span class="lineNum">    1326 </span>            :   return false;
<span class="lineNum">    1327 </span>            : }
<span class="lineNum">    1328 </span>            : 
<span class="lineNum">    1329 </span>            : /* Propagate know values from SSA_NAME_VALUE into the PHI nodes of the
<span class="lineNum">    1330 </span>            :    successors of BB.  */
<span class="lineNum">    1331 </span>            : 
<span class="lineNum">    1332 </span>            : static void
<span class="lineNum">    1333 </span><span class="lineCov">   13413556 : cprop_into_successor_phis (basic_block bb,</span>
<span class="lineNum">    1334 </span>            :                            class const_and_copies *const_and_copies)
<span class="lineNum">    1335 </span>            : {
<span class="lineNum">    1336 </span><span class="lineCov">   13413556 :   edge e;</span>
<span class="lineNum">    1337 </span><span class="lineCov">   13413556 :   edge_iterator ei;</span>
<span class="lineNum">    1338 </span>            : 
<span class="lineNum">    1339 </span><span class="lineCov">   45375204 :   FOR_EACH_EDGE (e, ei, bb-&gt;succs)</span>
<span class="lineNum">    1340 </span>            :     {
<span class="lineNum">    1341 </span><span class="lineCov">   18548092 :       int indx;</span>
<span class="lineNum">    1342 </span><span class="lineCov">   18548092 :       gphi_iterator gsi;</span>
<span class="lineNum">    1343 </span>            : 
<span class="lineNum">    1344 </span>            :       /* If this is an abnormal edge, then we do not want to copy propagate
<span class="lineNum">    1345 </span>            :          into the PHI alternative associated with this edge.  */
<span class="lineNum">    1346 </span><span class="lineCov">   18548092 :       if (e-&gt;flags &amp; EDGE_ABNORMAL)</span>
<span class="lineNum">    1347 </span><span class="lineCov">   11088585 :         continue;</span>
<span class="lineNum">    1348 </span>            : 
<span class="lineNum">    1349 </span><span class="lineCov">   18537105 :       gsi = gsi_start_phis (e-&gt;dest);</span>
<span class="lineNum">    1350 </span><span class="lineCov">   37074210 :       if (gsi_end_p (gsi))</span>
<span class="lineNum">    1351 </span>            :         continue;
<span class="lineNum">    1352 </span>            : 
<span class="lineNum">    1353 </span>            :       /* We may have an equivalence associated with this edge.  While
<span class="lineNum">    1354 </span>            :          we can not propagate it into non-dominated blocks, we can
<span class="lineNum">    1355 </span>            :          propagate them into PHIs in non-dominated blocks.  */
<span class="lineNum">    1356 </span>            : 
<span class="lineNum">    1357 </span>            :       /* Push the unwind marker so we can reset the const and copies
<span class="lineNum">    1358 </span>            :          table back to its original state after processing this edge.  */
<span class="lineNum">    1359 </span><span class="lineCov">    7459507 :       const_and_copies-&gt;push_marker ();</span>
<span class="lineNum">    1360 </span>            : 
<span class="lineNum">    1361 </span>            :       /* Extract and record any simple NAME = VALUE equivalences.
<span class="lineNum">    1362 </span>            : 
<span class="lineNum">    1363 </span>            :          Don't bother with [01] = COND equivalences, they're not useful
<span class="lineNum">    1364 </span>            :          here.  */
<span class="lineNum">    1365 </span><span class="lineCov">    7459507 :       class edge_info *edge_info = (class edge_info *) e-&gt;aux;</span>
<span class="lineNum">    1366 </span>            : 
<span class="lineNum">    1367 </span><span class="lineCov">    7459507 :       if (edge_info)</span>
<span class="lineNum">    1368 </span>            :         {
<span class="lineNum">    1369 </span>            :           edge_info::equiv_pair *seq;
<span class="lineNum">    1370 </span><span class="lineCov">    4621944 :           for (int i = 0; edge_info-&gt;simple_equivalences.iterate (i, &amp;seq); ++i)</span>
<span class="lineNum">    1371 </span>            :             {
<span class="lineNum">    1372 </span><span class="lineCov">    1756156 :               tree lhs = seq-&gt;first;</span>
<span class="lineNum">    1373 </span><span class="lineCov">    1756156 :               tree rhs = seq-&gt;second;</span>
<span class="lineNum">    1374 </span>            : 
<span class="lineNum">    1375 </span><span class="lineCov">    1756156 :               if (lhs &amp;&amp; TREE_CODE (lhs) == SSA_NAME)</span>
<span class="lineNum">    1376 </span><span class="lineCov">    1756156 :                 const_and_copies-&gt;record_const_or_copy (lhs, rhs);</span>
<span class="lineNum">    1377 </span>            :             }
<span class="lineNum">    1378 </span>            : 
<span class="lineNum">    1379 </span>            :         }
<span class="lineNum">    1380 </span>            : 
<span class="lineNum">    1381 </span><span class="lineCov">    7459507 :       indx = e-&gt;dest_idx;</span>
<span class="lineNum">    1382 </span><span class="lineCov">   26772362 :       for ( ; !gsi_end_p (gsi); gsi_next (&amp;gsi))</span>
<span class="lineNum">    1383 </span>            :         {
<span class="lineNum">    1384 </span><span class="lineCov">   11853348 :           tree new_val;</span>
<span class="lineNum">    1385 </span><span class="lineCov">   11853348 :           use_operand_p orig_p;</span>
<span class="lineNum">    1386 </span><span class="lineCov">   11853348 :           tree orig_val;</span>
<span class="lineNum">    1387 </span><span class="lineCov">   11853348 :           gphi *phi = gsi.phi ();</span>
<span class="lineNum">    1388 </span>            : 
<span class="lineNum">    1389 </span>            :           /* The alternative may be associated with a constant, so verify
<span class="lineNum">    1390 </span>            :              it is an SSA_NAME before doing anything with it.  */
<span class="lineNum">    1391 </span><span class="lineCov">   11853348 :           orig_p = gimple_phi_arg_imm_use_ptr (phi, indx);</span>
<span class="lineNum">    1392 </span><span class="lineCov">   11853348 :           orig_val = get_use_from_ptr (orig_p);</span>
<span class="lineNum">    1393 </span><span class="lineCov">   11853348 :           if (TREE_CODE (orig_val) != SSA_NAME)</span>
<span class="lineNum">    1394 </span>            :             continue;
<span class="lineNum">    1395 </span>            : 
<span class="lineNum">    1396 </span>            :           /* If we have *ORIG_P in our constant/copy table, then replace
<span class="lineNum">    1397 </span>            :              ORIG_P with its value in our constant/copy table.  */
<span class="lineNum">    1398 </span><span class="lineCov">   31551180 :           new_val = SSA_NAME_VALUE (orig_val);</span>
<span class="lineNum">    1399 </span><span class="lineCov">    8032008 :           if (new_val</span>
<span class="lineNum">    1400 </span><span class="lineCov">     617363 :               &amp;&amp; new_val != orig_val</span>
<span class="lineNum">    1401 </span><span class="lineCov">    8649350 :               &amp;&amp; may_propagate_copy (orig_val, new_val))</span>
<span class="lineNum">    1402 </span><span class="lineCov">     617027 :             propagate_value (orig_p, new_val);</span>
<span class="lineNum">    1403 </span>            :         }
<span class="lineNum">    1404 </span>            : 
<span class="lineNum">    1405 </span><span class="lineCov">    7459507 :       const_and_copies-&gt;pop_to_marker ();</span>
<span class="lineNum">    1406 </span>            :     }
<span class="lineNum">    1407 </span><span class="lineCov">   13413556 : }</span>
<a name="1408"><span class="lineNum">    1408 </span>            : </a>
<span class="lineNum">    1409 </span>            : edge
<span class="lineNum">    1410 </span><span class="lineCov">   13413556 : dom_opt_dom_walker::before_dom_children (basic_block bb)</span>
<span class="lineNum">    1411 </span>            : {
<span class="lineNum">    1412 </span><span class="lineCov">   13413556 :   gimple_stmt_iterator gsi;</span>
<span class="lineNum">    1413 </span>            : 
<span class="lineNum">    1414 </span><span class="lineCov">   13413556 :   if (dump_file &amp;&amp; (dump_flags &amp; TDF_DETAILS))</span>
<span class="lineNum">    1415 </span><span class="lineCov">        735 :     fprintf (dump_file, &quot;\n\nOptimizing block #%d\n\n&quot;, bb-&gt;index);</span>
<span class="lineNum">    1416 </span>            : 
<span class="lineNum">    1417 </span><span class="lineCov">   13413556 :   evrp_range_analyzer.enter (bb);</span>
<span class="lineNum">    1418 </span>            : 
<span class="lineNum">    1419 </span>            :   /* Push a marker on the stacks of local information so that we know how
<span class="lineNum">    1420 </span>            :      far to unwind when we finalize this block.  */
<span class="lineNum">    1421 </span><span class="lineCov">   13413556 :   m_avail_exprs_stack-&gt;push_marker ();</span>
<span class="lineNum">    1422 </span><span class="lineCov">   13413556 :   m_const_and_copies-&gt;push_marker ();</span>
<span class="lineNum">    1423 </span>            : 
<span class="lineNum">    1424 </span><span class="lineCov">   13413556 :   record_equivalences_from_incoming_edge (bb, m_const_and_copies,</span>
<span class="lineNum">    1425 </span>            :                                           m_avail_exprs_stack);
<span class="lineNum">    1426 </span>            : 
<span class="lineNum">    1427 </span>            :   /* PHI nodes can create equivalences too.  */
<span class="lineNum">    1428 </span><span class="lineCov">   13413556 :   record_equivalences_from_phis (bb);</span>
<span class="lineNum">    1429 </span>            : 
<span class="lineNum">    1430 </span>            :   /* Create equivalences from redundant PHIs.  PHIs are only truly
<span class="lineNum">    1431 </span>            :      redundant when they exist in the same block, so push another
<span class="lineNum">    1432 </span>            :      marker and unwind right afterwards.  */
<span class="lineNum">    1433 </span><span class="lineCov">   13413556 :   m_avail_exprs_stack-&gt;push_marker ();</span>
<span class="lineNum">    1434 </span><span class="lineCov">   18353320 :   for (gsi = gsi_start_phis (bb); !gsi_end_p (gsi); gsi_next (&amp;gsi))</span>
<span class="lineNum">    1435 </span><span class="lineCov">    4939764 :     eliminate_redundant_computations (&amp;gsi, m_const_and_copies,</span>
<span class="lineNum">    1436 </span>            :                                       m_avail_exprs_stack);
<span class="lineNum">    1437 </span><span class="lineCov">   13413556 :   m_avail_exprs_stack-&gt;pop_to_marker ();</span>
<span class="lineNum">    1438 </span>            : 
<span class="lineNum">    1439 </span><span class="lineCov">   13413556 :   edge taken_edge = NULL;</span>
<span class="lineNum">    1440 </span><span class="lineCov">  232455184 :   for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&amp;gsi))</span>
<span class="lineNum">    1441 </span>            :     {
<span class="lineNum">    1442 </span><span class="lineCov">  205628072 :       evrp_range_analyzer.record_ranges_from_stmt (gsi_stmt (gsi), false);</span>
<span class="lineNum">    1443 </span><span class="lineCov">  102814036 :       taken_edge = this-&gt;optimize_stmt (bb, gsi);</span>
<span class="lineNum">    1444 </span>            :     }
<span class="lineNum">    1445 </span>            : 
<span class="lineNum">    1446 </span>            :   /* Now prepare to process dominated blocks.  */
<span class="lineNum">    1447 </span><span class="lineCov">   13413556 :   record_edge_info (bb);</span>
<span class="lineNum">    1448 </span><span class="lineCov">   13413556 :   cprop_into_successor_phis (bb, m_const_and_copies);</span>
<span class="lineNum">    1449 </span><span class="lineCov">   13413556 :   if (taken_edge &amp;&amp; !dbg_cnt (dom_unreachable_edges))</span>
<span class="lineNum">    1450 </span><span class="lineNoCov">          0 :     return NULL;</span>
<span class="lineNum">    1451 </span>            : 
<span class="lineNum">    1452 </span>            :   return taken_edge;
<span class="lineNum">    1453 </span>            : }
<span class="lineNum">    1454 </span>            : 
<span class="lineNum">    1455 </span>            : /* We have finished processing the dominator children of BB, perform
<span class="lineNum">    1456 </span>            :    any finalization actions in preparation for leaving this node in
<span class="lineNum">    1457 </span>            :    the dominator tree.  */
<a name="1458"><span class="lineNum">    1458 </span>            : </a>
<span class="lineNum">    1459 </span>            : void
<span class="lineNum">    1460 </span><span class="lineCov">   13413556 : dom_opt_dom_walker::after_dom_children (basic_block bb)</span>
<span class="lineNum">    1461 </span>            : {
<span class="lineNum">    1462 </span><span class="lineCov">   13413556 :   x_vr_values = evrp_range_analyzer.get_vr_values ();</span>
<span class="lineNum">    1463 </span><span class="lineCov">   13413556 :   thread_outgoing_edges (bb, m_dummy_cond, m_const_and_copies,</span>
<span class="lineNum">    1464 </span>            :                          m_avail_exprs_stack,
<span class="lineNum">    1465 </span>            :                          &amp;evrp_range_analyzer,
<span class="lineNum">    1466 </span>            :                          simplify_stmt_for_jump_threading);
<span class="lineNum">    1467 </span><span class="lineCov">   13413556 :   x_vr_values = NULL;</span>
<span class="lineNum">    1468 </span>            : 
<span class="lineNum">    1469 </span>            :   /* These remove expressions local to BB from the tables.  */
<span class="lineNum">    1470 </span><span class="lineCov">   13413556 :   m_avail_exprs_stack-&gt;pop_to_marker ();</span>
<span class="lineNum">    1471 </span><span class="lineCov">   13413556 :   m_const_and_copies-&gt;pop_to_marker ();</span>
<span class="lineNum">    1472 </span><span class="lineCov">   13413556 :   evrp_range_analyzer.leave (bb);</span>
<span class="lineNum">    1473 </span><span class="lineCov">   13413556 : }</span>
<span class="lineNum">    1474 </span>            : 
<span class="lineNum">    1475 </span>            : /* Search for redundant computations in STMT.  If any are found, then
<span class="lineNum">    1476 </span>            :    replace them with the variable holding the result of the computation.
<span class="lineNum">    1477 </span>            : 
<span class="lineNum">    1478 </span>            :    If safe, record this expression into AVAIL_EXPRS_STACK and
<span class="lineNum">    1479 </span>            :    CONST_AND_COPIES.  */
<a name="1480"><span class="lineNum">    1480 </span>            : </a>
<span class="lineNum">    1481 </span>            : static void
<span class="lineNum">    1482 </span><span class="lineCov">   35827105 : eliminate_redundant_computations (gimple_stmt_iterator* gsi,</span>
<span class="lineNum">    1483 </span>            :                                   class const_and_copies *const_and_copies,
<span class="lineNum">    1484 </span>            :                                   class avail_exprs_stack *avail_exprs_stack)
<span class="lineNum">    1485 </span>            : {
<span class="lineNum">    1486 </span><span class="lineCov">   35827105 :   tree expr_type;</span>
<span class="lineNum">    1487 </span><span class="lineCov">   35827105 :   tree cached_lhs;</span>
<span class="lineNum">    1488 </span><span class="lineCov">   35827105 :   tree def;</span>
<span class="lineNum">    1489 </span><span class="lineCov">   35827105 :   bool insert = true;</span>
<span class="lineNum">    1490 </span><span class="lineCov">   35827105 :   bool assigns_var_p = false;</span>
<span class="lineNum">    1491 </span>            : 
<span class="lineNum">    1492 </span><span class="lineCov">   35827105 :   gimple *stmt = gsi_stmt (*gsi);</span>
<span class="lineNum">    1493 </span>            : 
<span class="lineNum">    1494 </span><span class="lineCov">   71654210 :   if (gimple_code (stmt) == GIMPLE_PHI)</span>
<span class="lineNum">    1495 </span><span class="lineCov">    9879528 :     def = gimple_phi_result (stmt);</span>
<span class="lineNum">    1496 </span>            :   else
<span class="lineNum">    1497 </span><span class="lineCov">   30887341 :     def = gimple_get_lhs (stmt);</span>
<span class="lineNum">    1498 </span>            : 
<span class="lineNum">    1499 </span>            :   /* Certain expressions on the RHS can be optimized away, but can not
<span class="lineNum">    1500 </span>            :      themselves be entered into the hash tables.  */
<span class="lineNum">    1501 </span><span class="lineCov">   35827105 :   if (! def</span>
<span class="lineNum">    1502 </span><span class="lineCov">   31066110 :       || TREE_CODE (def) != SSA_NAME</span>
<span class="lineNum">    1503 </span><span class="lineCov">   45828078 :       || SSA_NAME_OCCURS_IN_ABNORMAL_PHI (def)</span>
<span class="lineNum">    1504 </span><span class="lineCov">   40879775 :       || gimple_vdef (stmt)</span>
<span class="lineNum">    1505 </span>            :       /* Do not record equivalences for increments of ivs.  This would create
<span class="lineNum">    1506 </span>            :          overlapping live ranges for a very questionable gain.  */
<span class="lineNum">    1507 </span><span class="lineCov">   58733685 :       || simple_iv_increment_p (stmt))</span>
<span class="lineNum">    1508 </span>            :     insert = false;
<span class="lineNum">    1509 </span>            : 
<span class="lineNum">    1510 </span>            :   /* Check if the expression has been computed before.  */
<span class="lineNum">    1511 </span><span class="lineCov">   35827105 :   cached_lhs = avail_exprs_stack-&gt;lookup_avail_expr (stmt, insert, true);</span>
<span class="lineNum">    1512 </span>            : 
<span class="lineNum">    1513 </span><span class="lineCov">   35827105 :   opt_stats.num_exprs_considered++;</span>
<span class="lineNum">    1514 </span>            : 
<span class="lineNum">    1515 </span>            :   /* Get the type of the expression we are trying to optimize.  */
<span class="lineNum">    1516 </span><span class="lineCov">   71654210 :   if (is_gimple_assign (stmt))</span>
<span class="lineNum">    1517 </span>            :     {
<span class="lineNum">    1518 </span><span class="lineCov">   51138434 :       expr_type = TREE_TYPE (gimple_assign_lhs (stmt));</span>
<span class="lineNum">    1519 </span><span class="lineCov">   25569217 :       assigns_var_p = true;</span>
<span class="lineNum">    1520 </span>            :     }
<span class="lineNum">    1521 </span><span class="lineCov">   20515776 :   else if (gimple_code (stmt) == GIMPLE_COND)</span>
<span class="lineNum">    1522 </span><span class="lineCov">    4745405 :     expr_type = boolean_type_node;</span>
<span class="lineNum">    1523 </span><span class="lineCov">   11024966 :   else if (is_gimple_call (stmt))</span>
<span class="lineNum">    1524 </span>            :     {
<span class="lineNum">    1525 </span><span class="lineCov">    1114258 :       gcc_assert (gimple_call_lhs (stmt));</span>
<span class="lineNum">    1526 </span><span class="lineCov">    1114258 :       expr_type = TREE_TYPE (gimple_call_lhs (stmt));</span>
<span class="lineNum">    1527 </span><span class="lineCov">     557129 :       assigns_var_p = true;</span>
<span class="lineNum">    1528 </span>            :     }
<span class="lineNum">    1529 </span><span class="lineCov">    4955354 :   else if (gswitch *swtch_stmt = dyn_cast &lt;gswitch *&gt; (stmt))</span>
<span class="lineNum">    1530 </span><span class="lineCov">      31180 :     expr_type = TREE_TYPE (gimple_switch_index (swtch_stmt));</span>
<span class="lineNum">    1531 </span><span class="lineCov">    9879528 :   else if (gimple_code (stmt) == GIMPLE_PHI)</span>
<span class="lineNum">    1532 </span>            :     /* We can't propagate into a phi, so the logic below doesn't apply.
<span class="lineNum">    1533 </span>            :        Instead record an equivalence between the cached LHS and the
<span class="lineNum">    1534 </span>            :        PHI result of this statement, provided they are in the same block.
<span class="lineNum">    1535 </span>            :        This should be sufficient to kill the redundant phi.  */
<span class="lineNum">    1536 </span>            :     {
<span class="lineNum">    1537 </span><span class="lineCov">    4939764 :       if (def &amp;&amp; cached_lhs)</span>
<span class="lineNum">    1538 </span><span class="lineCov">       8638 :         const_and_copies-&gt;record_const_or_copy (def, cached_lhs);</span>
<span class="lineNum">    1539 </span><span class="lineCov">    4939764 :       return;</span>
<span class="lineNum">    1540 </span>            :     }
<span class="lineNum">    1541 </span>            :   else
<span class="lineNum">    1542 </span><span class="lineNoCov">          0 :     gcc_unreachable ();</span>
<span class="lineNum">    1543 </span>            : 
<span class="lineNum">    1544 </span><span class="lineCov">   30887341 :   if (!cached_lhs)</span>
<span class="lineNum">    1545 </span>            :     return;
<span class="lineNum">    1546 </span>            : 
<span class="lineNum">    1547 </span>            :   /* It is safe to ignore types here since we have already done
<span class="lineNum">    1548 </span>            :      type checking in the hashing and equality routines.  In fact
<span class="lineNum">    1549 </span>            :      type checking here merely gets in the way of constant
<span class="lineNum">    1550 </span>            :      propagation.  Also, make sure that it is safe to propagate
<span class="lineNum">    1551 </span>            :      CACHED_LHS into the expression in STMT.  */
<span class="lineNum">    1552 </span><span class="lineCov">     619628 :   if ((TREE_CODE (cached_lhs) != SSA_NAME</span>
<span class="lineNum">    1553 </span><span class="lineCov">      46056 :        &amp;&amp; (assigns_var_p</span>
<span class="lineNum">    1554 </span><span class="lineCov">       1635 :            || useless_type_conversion_p (expr_type, TREE_TYPE (cached_lhs))))</span>
<span class="lineNum">    1555 </span><span class="lineCov">     619628 :       || may_propagate_copy_into_stmt (stmt, cached_lhs))</span>
<span class="lineNum">    1556 </span>            :   {
<span class="lineNum">    1557 </span><span class="lineCov">     619618 :       gcc_checking_assert (TREE_CODE (cached_lhs) == SSA_NAME</span>
<span class="lineNum">    1558 </span>            :                            || is_gimple_min_invariant (cached_lhs));
<span class="lineNum">    1559 </span>            : 
<span class="lineNum">    1560 </span><span class="lineCov">     619618 :       if (dump_file &amp;&amp; (dump_flags &amp; TDF_DETAILS))</span>
<span class="lineNum">    1561 </span>            :         {
<span class="lineNum">    1562 </span><span class="lineCov">         18 :           fprintf (dump_file, &quot;  Replaced redundant expr '&quot;);</span>
<span class="lineNum">    1563 </span><span class="lineCov">         18 :           print_gimple_expr (dump_file, stmt, 0, dump_flags);</span>
<span class="lineNum">    1564 </span><span class="lineCov">         18 :           fprintf (dump_file, &quot;' with '&quot;);</span>
<span class="lineNum">    1565 </span><span class="lineCov">         18 :           print_generic_expr (dump_file, cached_lhs, dump_flags);</span>
<span class="lineNum">    1566 </span><span class="lineCov">         18 :           fprintf (dump_file, &quot;'\n&quot;);</span>
<span class="lineNum">    1567 </span>            :         }
<span class="lineNum">    1568 </span>            : 
<span class="lineNum">    1569 </span><span class="lineCov">     619618 :       opt_stats.num_re++;</span>
<span class="lineNum">    1570 </span>            : 
<span class="lineNum">    1571 </span><span class="lineCov">     619618 :       if (assigns_var_p</span>
<span class="lineNum">    1572 </span><span class="lineCov">     619618 :           &amp;&amp; !useless_type_conversion_p (expr_type, TREE_TYPE (cached_lhs)))</span>
<span class="lineNum">    1573 </span><span class="lineNoCov">          0 :         cached_lhs = fold_convert (expr_type, cached_lhs);</span>
<span class="lineNum">    1574 </span>            : 
<span class="lineNum">    1575 </span><span class="lineCov">     619618 :       propagate_tree_value_into_stmt (gsi, cached_lhs);</span>
<span class="lineNum">    1576 </span>            : 
<span class="lineNum">    1577 </span>            :       /* Since it is always necessary to mark the result as modified,
<span class="lineNum">    1578 </span>            :          perhaps we should move this into propagate_tree_value_into_stmt
<span class="lineNum">    1579 </span>            :          itself.  */
<span class="lineNum">    1580 </span><span class="lineCov">    1239236 :       gimple_set_modified (gsi_stmt (*gsi), true);</span>
<span class="lineNum">    1581 </span>            :   }
<span class="lineNum">    1582 </span>            : }
<span class="lineNum">    1583 </span>            : 
<span class="lineNum">    1584 </span>            : /* STMT, a GIMPLE_ASSIGN, may create certain equivalences, in either
<span class="lineNum">    1585 </span>            :    the available expressions table or the const_and_copies table.
<span class="lineNum">    1586 </span>            :    Detect and record those equivalences into AVAIL_EXPRS_STACK. 
<span class="lineNum">    1587 </span>            : 
<span class="lineNum">    1588 </span>            :    We handle only very simple copy equivalences here.  The heavy
<span class="lineNum">    1589 </span>            :    lifing is done by eliminate_redundant_computations.  */
<a name="1590"><span class="lineNum">    1590 </span>            : </a>
<span class="lineNum">    1591 </span>            : static void
<span class="lineNum">    1592 </span><span class="lineCov">   28102205 : record_equivalences_from_stmt (gimple *stmt, int may_optimize_p,</span>
<span class="lineNum">    1593 </span>            :                                class avail_exprs_stack *avail_exprs_stack)
<span class="lineNum">    1594 </span>            : {
<span class="lineNum">    1595 </span><span class="lineCov">   28102205 :   tree lhs;</span>
<span class="lineNum">    1596 </span><span class="lineCov">   28102205 :   enum tree_code lhs_code;</span>
<span class="lineNum">    1597 </span>            : 
<span class="lineNum">    1598 </span><span class="lineCov">   56204410 :   gcc_assert (is_gimple_assign (stmt));</span>
<span class="lineNum">    1599 </span>            : 
<span class="lineNum">    1600 </span><span class="lineCov">   28102205 :   lhs = gimple_assign_lhs (stmt);</span>
<span class="lineNum">    1601 </span><span class="lineCov">   28102205 :   lhs_code = TREE_CODE (lhs);</span>
<span class="lineNum">    1602 </span>            : 
<span class="lineNum">    1603 </span><span class="lineCov">   28102205 :   if (lhs_code == SSA_NAME</span>
<span class="lineNum">    1604 </span><span class="lineCov">   28102205 :       &amp;&amp; gimple_assign_single_p (stmt))</span>
<span class="lineNum">    1605 </span>            :     {
<span class="lineNum">    1606 </span><span class="lineCov">    9038605 :       tree rhs = gimple_assign_rhs1 (stmt);</span>
<span class="lineNum">    1607 </span>            : 
<span class="lineNum">    1608 </span>            :       /* If the RHS of the assignment is a constant or another variable that
<span class="lineNum">    1609 </span>            :          may be propagated, register it in the CONST_AND_COPIES table.  We
<span class="lineNum">    1610 </span>            :          do not need to record unwind data for this, since this is a true
<span class="lineNum">    1611 </span>            :          assignment and not an equivalence inferred from a comparison.  All
<span class="lineNum">    1612 </span>            :          uses of this ssa name are dominated by this assignment, so unwinding
<span class="lineNum">    1613 </span>            :          just costs time and space.  */
<span class="lineNum">    1614 </span><span class="lineCov">    9038605 :       if (may_optimize_p</span>
<span class="lineNum">    1615 </span><span class="lineCov">    9038605 :           &amp;&amp; (TREE_CODE (rhs) == SSA_NAME</span>
<span class="lineNum">    1616 </span><span class="lineCov">    7305657 :               || is_gimple_min_invariant (rhs)))</span>
<span class="lineNum">    1617 </span>            :         {
<span class="lineNum">    1618 </span><span class="lineCov">    1782315 :           rhs = dom_valueize (rhs);</span>
<span class="lineNum">    1619 </span>            : 
<span class="lineNum">    1620 </span><span class="lineCov">    1782315 :           if (dump_file &amp;&amp; (dump_flags &amp; TDF_DETAILS))</span>
<span class="lineNum">    1621 </span>            :             {
<span class="lineNum">    1622 </span><span class="lineCov">         24 :               fprintf (dump_file, &quot;==== ASGN &quot;);</span>
<span class="lineNum">    1623 </span><span class="lineCov">         24 :               print_generic_expr (dump_file, lhs);</span>
<span class="lineNum">    1624 </span><span class="lineCov">         24 :               fprintf (dump_file, &quot; = &quot;);</span>
<span class="lineNum">    1625 </span><span class="lineCov">         24 :               print_generic_expr (dump_file, rhs);</span>
<span class="lineNum">    1626 </span><span class="lineCov">         24 :               fprintf (dump_file, &quot;\n&quot;);</span>
<span class="lineNum">    1627 </span>            :             }
<span class="lineNum">    1628 </span>            : 
<span class="lineNum">    1629 </span><span class="lineCov">    1782315 :           set_ssa_name_value (lhs, rhs);</span>
<span class="lineNum">    1630 </span>            :         }
<span class="lineNum">    1631 </span>            :     }
<span class="lineNum">    1632 </span>            : 
<span class="lineNum">    1633 </span>            :   /* Make sure we can propagate &amp;x + CST.  */
<span class="lineNum">    1634 </span><span class="lineCov">   28102205 :   if (lhs_code == SSA_NAME</span>
<span class="lineNum">    1635 </span><span class="lineCov">   17954866 :       &amp;&amp; gimple_assign_rhs_code (stmt) == POINTER_PLUS_EXPR</span>
<span class="lineNum">    1636 </span><span class="lineCov">     911911 :       &amp;&amp; TREE_CODE (gimple_assign_rhs1 (stmt)) == ADDR_EXPR</span>
<span class="lineNum">    1637 </span><span class="lineCov">   28195268 :       &amp;&amp; TREE_CODE (gimple_assign_rhs2 (stmt)) == INTEGER_CST)</span>
<span class="lineNum">    1638 </span>            :     {
<span class="lineNum">    1639 </span><span class="lineCov">      46109 :       tree op0 = gimple_assign_rhs1 (stmt);</span>
<span class="lineNum">    1640 </span><span class="lineCov">      46109 :       tree op1 = gimple_assign_rhs2 (stmt);</span>
<span class="lineNum">    1641 </span><span class="lineCov">      46109 :       tree new_rhs</span>
<span class="lineNum">    1642 </span><span class="lineCov">      46109 :         = build_fold_addr_expr (fold_build2 (MEM_REF,</span>
<span class="lineNum">    1643 </span>            :                                              TREE_TYPE (TREE_TYPE (op0)),
<span class="lineNum">    1644 </span>            :                                              unshare_expr (op0),
<span class="lineNum">    1645 </span>            :                                              fold_convert (ptr_type_node,
<span class="lineNum">    1646 </span>            :                                                            op1)));
<span class="lineNum">    1647 </span><span class="lineCov">      46109 :       if (dump_file &amp;&amp; (dump_flags &amp; TDF_DETAILS))</span>
<span class="lineNum">    1648 </span>            :         {
<span class="lineNum">    1649 </span><span class="lineNoCov">          0 :           fprintf (dump_file, &quot;==== ASGN &quot;);</span>
<span class="lineNum">    1650 </span><span class="lineNoCov">          0 :           print_generic_expr (dump_file, lhs);</span>
<span class="lineNum">    1651 </span><span class="lineNoCov">          0 :           fprintf (dump_file, &quot; = &quot;);</span>
<span class="lineNum">    1652 </span><span class="lineNoCov">          0 :           print_generic_expr (dump_file, new_rhs);</span>
<span class="lineNum">    1653 </span><span class="lineNoCov">          0 :           fprintf (dump_file, &quot;\n&quot;);</span>
<span class="lineNum">    1654 </span>            :         }
<span class="lineNum">    1655 </span>            : 
<span class="lineNum">    1656 </span><span class="lineCov">      46109 :       set_ssa_name_value (lhs, new_rhs);</span>
<span class="lineNum">    1657 </span>            :     }
<span class="lineNum">    1658 </span>            : 
<span class="lineNum">    1659 </span>            :   /* A memory store, even an aliased store, creates a useful
<span class="lineNum">    1660 </span>            :      equivalence.  By exchanging the LHS and RHS, creating suitable
<span class="lineNum">    1661 </span>            :      vops and recording the result in the available expression table,
<span class="lineNum">    1662 </span>            :      we may be able to expose more redundant loads.  */
<span class="lineNum">    1663 </span><span class="lineCov">   28102205 :   if (!gimple_has_volatile_ops (stmt)</span>
<span class="lineNum">    1664 </span><span class="lineCov">   25542637 :       &amp;&amp; gimple_references_memory_p (stmt)</span>
<span class="lineNum">    1665 </span><span class="lineCov">   14023320 :       &amp;&amp; gimple_assign_single_p (stmt)</span>
<span class="lineNum">    1666 </span><span class="lineCov">   28046640 :       &amp;&amp; (TREE_CODE (gimple_assign_rhs1 (stmt)) == SSA_NAME</span>
<span class="lineNum">    1667 </span><span class="lineCov">   21501090 :           || is_gimple_min_invariant (gimple_assign_rhs1 (stmt)))</span>
<span class="lineNum">    1668 </span><span class="lineCov">   35695651 :       &amp;&amp; !is_gimple_reg (lhs))</span>
<span class="lineNum">    1669 </span>            :     {
<span class="lineNum">    1670 </span><span class="lineCov">    7495961 :       tree rhs = gimple_assign_rhs1 (stmt);</span>
<span class="lineNum">    1671 </span><span class="lineCov">    7495961 :       gassign *new_stmt;</span>
<span class="lineNum">    1672 </span>            : 
<span class="lineNum">    1673 </span>            :       /* Build a new statement with the RHS and LHS exchanged.  */
<span class="lineNum">    1674 </span><span class="lineCov">    7495961 :       if (TREE_CODE (rhs) == SSA_NAME)</span>
<span class="lineNum">    1675 </span>            :         {
<span class="lineNum">    1676 </span>            :           /* NOTE tuples.  The call to gimple_build_assign below replaced
<span class="lineNum">    1677 </span>            :              a call to build_gimple_modify_stmt, which did not set the
<span class="lineNum">    1678 </span>            :              SSA_NAME_DEF_STMT on the LHS of the assignment.  Doing so
<span class="lineNum">    1679 </span>            :              may cause an SSA validation failure, as the LHS may be a
<span class="lineNum">    1680 </span>            :              default-initialized name and should have no definition.  I'm
<span class="lineNum">    1681 </span>            :              a bit dubious of this, as the artificial statement that we
<span class="lineNum">    1682 </span>            :              generate here may in fact be ill-formed, but it is simply
<span class="lineNum">    1683 </span>            :              used as an internal device in this pass, and never becomes
<span class="lineNum">    1684 </span>            :              part of the CFG.  */
<span class="lineNum">    1685 </span><span class="lineCov">    3191587 :           gimple *defstmt = SSA_NAME_DEF_STMT (rhs);</span>
<span class="lineNum">    1686 </span><span class="lineCov">    3191587 :           new_stmt = gimple_build_assign (rhs, lhs);</span>
<span class="lineNum">    1687 </span><span class="lineCov">    3191587 :           SSA_NAME_DEF_STMT (rhs) = defstmt;</span>
<span class="lineNum">    1688 </span>            :         }
<span class="lineNum">    1689 </span>            :       else
<span class="lineNum">    1690 </span><span class="lineCov">    4304374 :         new_stmt = gimple_build_assign (rhs, lhs);</span>
<span class="lineNum">    1691 </span>            : 
<span class="lineNum">    1692 </span><span class="lineCov">   14991922 :       gimple_set_vuse (new_stmt, gimple_vdef (stmt));</span>
<span class="lineNum">    1693 </span>            : 
<span class="lineNum">    1694 </span>            :       /* Finally enter the statement into the available expression
<span class="lineNum">    1695 </span>            :          table.  */
<span class="lineNum">    1696 </span><span class="lineCov">    7495961 :       avail_exprs_stack-&gt;lookup_avail_expr (new_stmt, true, true);</span>
<span class="lineNum">    1697 </span>            :     }
<span class="lineNum">    1698 </span><span class="lineCov">   28102205 : }</span>
<span class="lineNum">    1699 </span>            : 
<span class="lineNum">    1700 </span>            : /* Replace *OP_P in STMT with any known equivalent value for *OP_P from
<span class="lineNum">    1701 </span>            :    CONST_AND_COPIES.  */
<span class="lineNum">    1702 </span>            : 
<span class="lineNum">    1703 </span>            : static void
<span class="lineNum">    1704 </span><span class="lineCov">   44023588 : cprop_operand (gimple *stmt, use_operand_p op_p, vr_values *vr_values)</span>
<span class="lineNum">    1705 </span>            : {
<span class="lineNum">    1706 </span><span class="lineCov">   44023588 :   tree val;</span>
<span class="lineNum">    1707 </span><span class="lineCov">   44023588 :   tree op = USE_FROM_PTR (op_p);</span>
<span class="lineNum">    1708 </span>            : 
<span class="lineNum">    1709 </span>            :   /* If the operand has a known constant value or it is known to be a
<span class="lineNum">    1710 </span>            :      copy of some other variable, use the value or copy stored in
<span class="lineNum">    1711 </span>            :      CONST_AND_COPIES.  */
<span class="lineNum">    1712 </span><span class="lineCov">   88047176 :   val = SSA_NAME_VALUE (op);</span>
<span class="lineNum">    1713 </span><span class="lineCov">   29989739 :   if (!val)</span>
<span class="lineNum">    1714 </span><span class="lineCov">   40943346 :     val = vr_values-&gt;op_with_constant_singleton_value_range (op);</span>
<span class="lineNum">    1715 </span>            : 
<span class="lineNum">    1716 </span><span class="lineCov">   44023588 :   if (val &amp;&amp; val != op)</span>
<span class="lineNum">    1717 </span>            :     {
<span class="lineNum">    1718 </span>            :       /* Do not replace hard register operands in asm statements.  */
<span class="lineNum">    1719 </span><span class="lineCov">    3085288 :       if (gimple_code (stmt) == GIMPLE_ASM</span>
<span class="lineNum">    1720 </span><span class="lineCov">    3085288 :           &amp;&amp; !may_propagate_copy_into_asm (op))</span>
<span class="lineNum">    1721 </span>            :         return;
<span class="lineNum">    1722 </span>            : 
<span class="lineNum">    1723 </span>            :       /* Certain operands are not allowed to be copy propagated due
<span class="lineNum">    1724 </span>            :          to their interaction with exception handling and some GCC
<span class="lineNum">    1725 </span>            :          extensions.  */
<span class="lineNum">    1726 </span><span class="lineCov">    3085288 :       if (!may_propagate_copy (op, val))</span>
<span class="lineNum">    1727 </span>            :         return;
<span class="lineNum">    1728 </span>            : 
<span class="lineNum">    1729 </span>            :       /* Do not propagate copies into BIVs.
<span class="lineNum">    1730 </span>            :          See PR23821 and PR62217 for how this can disturb IV and
<span class="lineNum">    1731 </span>            :          number of iteration analysis.  */
<span class="lineNum">    1732 </span><span class="lineCov">    3083878 :       if (TREE_CODE (val) != INTEGER_CST)</span>
<span class="lineNum">    1733 </span>            :         {
<span class="lineNum">    1734 </span><span class="lineCov">    2374747 :           gimple *def = SSA_NAME_DEF_STMT (op);</span>
<span class="lineNum">    1735 </span><span class="lineCov">    2374747 :           if (gimple_code (def) == GIMPLE_PHI</span>
<span class="lineNum">    1736 </span><span class="lineCov">    2374747 :               &amp;&amp; gimple_bb (def)-&gt;loop_father-&gt;header == gimple_bb (def))</span>
<span class="lineNum">    1737 </span>            :             return;
<span class="lineNum">    1738 </span>            :         }
<span class="lineNum">    1739 </span>            : 
<span class="lineNum">    1740 </span>            :       /* Dump details.  */
<span class="lineNum">    1741 </span><span class="lineCov">    3053189 :       if (dump_file &amp;&amp; (dump_flags &amp; TDF_DETAILS))</span>
<span class="lineNum">    1742 </span>            :         {
<span class="lineNum">    1743 </span><span class="lineCov">         28 :           fprintf (dump_file, &quot;  Replaced '&quot;);</span>
<span class="lineNum">    1744 </span><span class="lineCov">         28 :           print_generic_expr (dump_file, op, dump_flags);</span>
<span class="lineNum">    1745 </span><span class="lineCov">         28 :           fprintf (dump_file, &quot;' with %s '&quot;,</span>
<span class="lineNum">    1746 </span><span class="lineCov">         28 :                    (TREE_CODE (val) != SSA_NAME ? &quot;constant&quot; : &quot;variable&quot;));</span>
<span class="lineNum">    1747 </span><span class="lineCov">         28 :           print_generic_expr (dump_file, val, dump_flags);</span>
<span class="lineNum">    1748 </span><span class="lineCov">         28 :           fprintf (dump_file, &quot;'\n&quot;);</span>
<span class="lineNum">    1749 </span>            :         }
<span class="lineNum">    1750 </span>            : 
<span class="lineNum">    1751 </span><span class="lineCov">    3053189 :       if (TREE_CODE (val) != SSA_NAME)</span>
<span class="lineNum">    1752 </span><span class="lineCov">     916996 :         opt_stats.num_const_prop++;</span>
<span class="lineNum">    1753 </span>            :       else
<span class="lineNum">    1754 </span><span class="lineCov">    2136193 :         opt_stats.num_copy_prop++;</span>
<span class="lineNum">    1755 </span>            : 
<span class="lineNum">    1756 </span><span class="lineCov">    3053189 :       propagate_value (op_p, val);</span>
<span class="lineNum">    1757 </span>            : 
<span class="lineNum">    1758 </span>            :       /* And note that we modified this statement.  This is now
<span class="lineNum">    1759 </span>            :          safe, even if we changed virtual operands since we will
<span class="lineNum">    1760 </span>            :          rescan the statement and rewrite its operands again.  */
<span class="lineNum">    1761 </span><span class="lineCov">    3053189 :       gimple_set_modified (stmt, true);</span>
<span class="lineNum">    1762 </span>            :     }
<span class="lineNum">    1763 </span>            : }
<span class="lineNum">    1764 </span>            : 
<span class="lineNum">    1765 </span>            : /* CONST_AND_COPIES is a table which maps an SSA_NAME to the current
<span class="lineNum">    1766 </span>            :    known value for that SSA_NAME (or NULL if no value is known).
<span class="lineNum">    1767 </span>            : 
<span class="lineNum">    1768 </span>            :    Propagate values from CONST_AND_COPIES into the uses, vuses and
<span class="lineNum">    1769 </span>            :    vdef_ops of STMT.  */
<a name="1770"><span class="lineNum">    1770 </span>            : </a>
<span class="lineNum">    1771 </span>            : static void
<span class="lineNum">    1772 </span><span class="lineCov">  102814036 : cprop_into_stmt (gimple *stmt, vr_values *vr_values)</span>
<span class="lineNum">    1773 </span>            : {
<span class="lineNum">    1774 </span><span class="lineCov">  102814036 :   use_operand_p op_p;</span>
<span class="lineNum">    1775 </span><span class="lineCov">  102814036 :   ssa_op_iter iter;</span>
<span class="lineNum">    1776 </span><span class="lineCov">  102814036 :   tree last_copy_propagated_op = NULL;</span>
<span class="lineNum">    1777 </span>            : 
<span class="lineNum">    1778 </span><span class="lineCov">  146838407 :   FOR_EACH_SSA_USE_OPERAND (op_p, stmt, iter, SSA_OP_USE)</span>
<span class="lineNum">    1779 </span>            :     {
<span class="lineNum">    1780 </span><span class="lineCov">   44024371 :       tree old_op = USE_FROM_PTR (op_p);</span>
<span class="lineNum">    1781 </span>            : 
<span class="lineNum">    1782 </span>            :       /* If we have A = B and B = A in the copy propagation tables
<span class="lineNum">    1783 </span>            :          (due to an equality comparison), avoid substituting B for A
<span class="lineNum">    1784 </span>            :          then A for B in the trivially discovered cases.   This allows
<span class="lineNum">    1785 </span>            :          optimization of statements were A and B appear as input
<span class="lineNum">    1786 </span>            :          operands.  */
<span class="lineNum">    1787 </span><span class="lineCov">   44024371 :       if (old_op != last_copy_propagated_op)</span>
<span class="lineNum">    1788 </span>            :         {
<span class="lineNum">    1789 </span><span class="lineCov">   44023588 :           cprop_operand (stmt, op_p, vr_values);</span>
<span class="lineNum">    1790 </span>            : 
<span class="lineNum">    1791 </span><span class="lineCov">   44023588 :           tree new_op = USE_FROM_PTR (op_p);</span>
<span class="lineNum">    1792 </span><span class="lineCov">   44023588 :           if (new_op != old_op &amp;&amp; TREE_CODE (new_op) == SSA_NAME)</span>
<span class="lineNum">    1793 </span><span class="lineCov">    2136193 :             last_copy_propagated_op = new_op;</span>
<span class="lineNum">    1794 </span>            :         }
<span class="lineNum">    1795 </span>            :     }
<span class="lineNum">    1796 </span><span class="lineCov">  102814036 : }</span>
<span class="lineNum">    1797 </span>            : 
<span class="lineNum">    1798 </span>            : /* If STMT contains a relational test, try to convert it into an
<span class="lineNum">    1799 </span>            :    equality test if there is only a single value which can ever
<span class="lineNum">    1800 </span>            :    make the test true.
<span class="lineNum">    1801 </span>            : 
<span class="lineNum">    1802 </span>            :    For example, if the expression hash table contains:
<span class="lineNum">    1803 </span>            : 
<span class="lineNum">    1804 </span>            :     TRUE = (i &lt;= 1)
<span class="lineNum">    1805 </span>            : 
<span class="lineNum">    1806 </span>            :    And we have a test within statement of i &gt;= 1, then we can safely
<span class="lineNum">    1807 </span>            :    rewrite the test as i == 1 since there only a single value where
<span class="lineNum">    1808 </span>            :    the test is true.
<span class="lineNum">    1809 </span>            : 
<span class="lineNum">    1810 </span>            :    This is similar to code in VRP.  */
<a name="1811"><span class="lineNum">    1811 </span>            : </a>
<span class="lineNum">    1812 </span>            : static void
<span class="lineNum">    1813 </span><span class="lineCov">   30860064 : test_for_singularity (gimple *stmt, gcond *dummy_cond,</span>
<span class="lineNum">    1814 </span>            :                       avail_exprs_stack *avail_exprs_stack)
<span class="lineNum">    1815 </span>            : {
<span class="lineNum">    1816 </span>            :   /* We want to support gimple conditionals as well as assignments
<span class="lineNum">    1817 </span>            :      where the RHS contains a conditional.  */
<span class="lineNum">    1818 </span><span class="lineCov">   61720128 :   if (is_gimple_assign (stmt) || gimple_code (stmt) == GIMPLE_COND)</span>
<span class="lineNum">    1819 </span>            :     {
<span class="lineNum">    1820 </span><span class="lineCov">   30288042 :       enum tree_code code = ERROR_MARK;</span>
<span class="lineNum">    1821 </span><span class="lineCov">   30288042 :       tree lhs, rhs;</span>
<span class="lineNum">    1822 </span>            : 
<span class="lineNum">    1823 </span>            :       /* Extract the condition of interest from both forms we support.  */
<span class="lineNum">    1824 </span><span class="lineCov">   60576084 :       if (is_gimple_assign (stmt))</span>
<span class="lineNum">    1825 </span>            :         {
<span class="lineNum">    1826 </span><span class="lineCov">   25542637 :           code = gimple_assign_rhs_code (stmt);</span>
<span class="lineNum">    1827 </span><span class="lineCov">   25542637 :           lhs = gimple_assign_rhs1 (stmt);</span>
<span class="lineNum">    1828 </span><span class="lineCov">   25542637 :           rhs = gimple_assign_rhs2 (stmt);</span>
<span class="lineNum">    1829 </span>            :         }
<span class="lineNum">    1830 </span><span class="lineCov">    9490810 :       else if (gimple_code (stmt) == GIMPLE_COND)</span>
<span class="lineNum">    1831 </span>            :         {
<span class="lineNum">    1832 </span><span class="lineCov">    9490810 :           code = gimple_cond_code (as_a &lt;gcond *&gt; (stmt));</span>
<span class="lineNum">    1833 </span><span class="lineCov">    9490810 :           lhs = gimple_cond_lhs (as_a &lt;gcond *&gt; (stmt));</span>
<span class="lineNum">    1834 </span><span class="lineCov">   14236215 :           rhs = gimple_cond_rhs (as_a &lt;gcond *&gt; (stmt));</span>
<span class="lineNum">    1835 </span>            :         }
<span class="lineNum">    1836 </span>            : 
<span class="lineNum">    1837 </span>            :       /* We're looking for a relational test using LE/GE.  Also note we can
<span class="lineNum">    1838 </span>            :          canonicalize LT/GT tests against constants into LE/GT tests.  */
<span class="lineNum">    1839 </span><span class="lineCov">   30288042 :       if (code == LE_EXPR || code == GE_EXPR</span>
<span class="lineNum">    1840 </span><span class="lineCov">   29859233 :           || ((code == LT_EXPR || code == GT_EXPR)</span>
<span class="lineNum">    1841 </span><span class="lineCov">     921831 :                &amp;&amp; TREE_CODE (rhs) == INTEGER_CST))</span>
<span class="lineNum">    1842 </span>            :         {
<span class="lineNum">    1843 </span>            :           /* For LT_EXPR and GT_EXPR, canonicalize to LE_EXPR and GE_EXPR.  */
<span class="lineNum">    1844 </span><span class="lineCov">     836623 :           if (code == LT_EXPR)</span>
<span class="lineNum">    1845 </span><span class="lineCov">     280234 :             rhs = fold_build2 (MINUS_EXPR, TREE_TYPE (rhs),</span>
<span class="lineNum">    1846 </span>            :                                rhs, build_int_cst (TREE_TYPE (rhs), 1));
<span class="lineNum">    1847 </span>            : 
<span class="lineNum">    1848 </span><span class="lineCov">     836623 :           if (code == GT_EXPR)</span>
<span class="lineNum">    1849 </span><span class="lineCov">     535394 :             rhs = fold_build2 (PLUS_EXPR, TREE_TYPE (rhs),</span>
<span class="lineNum">    1850 </span>            :                                rhs, build_int_cst (TREE_TYPE (rhs), 1));
<span class="lineNum">    1851 </span>            : 
<span class="lineNum">    1852 </span>            :           /* Determine the code we want to check for in the hash table.  */
<span class="lineNum">    1853 </span><span class="lineCov">     836623 :           enum tree_code test_code;</span>
<span class="lineNum">    1854 </span><span class="lineCov">     836623 :           if (code == GE_EXPR || code == GT_EXPR)</span>
<span class="lineNum">    1855 </span>            :             test_code = LE_EXPR;
<span class="lineNum">    1856 </span>            :           else
<span class="lineNum">    1857 </span><span class="lineCov">     423646 :             test_code = GE_EXPR;</span>
<span class="lineNum">    1858 </span>            : 
<span class="lineNum">    1859 </span>            :           /* Update the dummy statement so we can query the hash tables.  */
<span class="lineNum">    1860 </span><span class="lineCov">     836623 :           gimple_cond_set_code (dummy_cond, test_code);</span>
<span class="lineNum">    1861 </span><span class="lineCov">     836623 :           gimple_cond_set_lhs (dummy_cond, lhs);</span>
<span class="lineNum">    1862 </span><span class="lineCov">     836623 :           gimple_cond_set_rhs (dummy_cond, rhs);</span>
<span class="lineNum">    1863 </span><span class="lineCov">     836623 :           tree cached_lhs</span>
<span class="lineNum">    1864 </span><span class="lineCov">     836623 :             = avail_exprs_stack-&gt;lookup_avail_expr (dummy_cond, false, false);</span>
<span class="lineNum">    1865 </span>            : 
<span class="lineNum">    1866 </span>            :           /* If the lookup returned 1 (true), then the expression we
<span class="lineNum">    1867 </span>            :              queried was in the hash table.  As a result there is only
<span class="lineNum">    1868 </span>            :              one value that makes the original conditional true.  Update
<span class="lineNum">    1869 </span>            :              STMT accordingly.  */
<span class="lineNum">    1870 </span><span class="lineCov">     836623 :           if (cached_lhs &amp;&amp; integer_onep (cached_lhs))</span>
<span class="lineNum">    1871 </span>            :             {
<span class="lineNum">    1872 </span><span class="lineCov">       1222 :               if (is_gimple_assign (stmt))</span>
<span class="lineNum">    1873 </span>            :                 {
<span class="lineNum">    1874 </span><span class="lineCov">         25 :                   gimple_assign_set_rhs_code (stmt, EQ_EXPR);</span>
<span class="lineNum">    1875 </span><span class="lineCov">         25 :                   gimple_assign_set_rhs2 (stmt, rhs);</span>
<span class="lineNum">    1876 </span><span class="lineCov">         25 :                   gimple_set_modified (stmt, true);</span>
<span class="lineNum">    1877 </span>            :                 }
<span class="lineNum">    1878 </span>            :               else
<span class="lineNum">    1879 </span>            :                 {
<span class="lineNum">    1880 </span><span class="lineCov">        586 :                   gimple_set_modified (stmt, true);</span>
<span class="lineNum">    1881 </span><span class="lineCov">        586 :                   gimple_cond_set_code (as_a &lt;gcond *&gt; (stmt), EQ_EXPR);</span>
<span class="lineNum">    1882 </span><span class="lineCov">       1172 :                   gimple_cond_set_rhs (as_a &lt;gcond *&gt; (stmt), rhs);</span>
<span class="lineNum">    1883 </span><span class="lineCov">        586 :                   gimple_set_modified (stmt, true);</span>
<span class="lineNum">    1884 </span>            :                 }
<span class="lineNum">    1885 </span>            :             }
<span class="lineNum">    1886 </span>            :         }
<span class="lineNum">    1887 </span>            :     }
<span class="lineNum">    1888 </span><span class="lineCov">   30860064 : }</span>
<span class="lineNum">    1889 </span>            : 
<span class="lineNum">    1890 </span>            : /* Optimize the statement in block BB pointed to by iterator SI.
<span class="lineNum">    1891 </span>            : 
<span class="lineNum">    1892 </span>            :    We try to perform some simplistic global redundancy elimination and
<span class="lineNum">    1893 </span>            :    constant propagation:
<span class="lineNum">    1894 </span>            : 
<span class="lineNum">    1895 </span>            :    1- To detect global redundancy, we keep track of expressions that have
<span class="lineNum">    1896 </span>            :       been computed in this block and its dominators.  If we find that the
<span class="lineNum">    1897 </span>            :       same expression is computed more than once, we eliminate repeated
<span class="lineNum">    1898 </span>            :       computations by using the target of the first one.
<span class="lineNum">    1899 </span>            : 
<span class="lineNum">    1900 </span>            :    2- Constant values and copy assignments.  This is used to do very
<span class="lineNum">    1901 </span>            :       simplistic constant and copy propagation.  When a constant or copy
<span class="lineNum">    1902 </span>            :       assignment is found, we map the value on the RHS of the assignment to
<span class="lineNum">    1903 </span>            :       the variable in the LHS in the CONST_AND_COPIES table.
<span class="lineNum">    1904 </span>            : 
<span class="lineNum">    1905 </span>            :    3- Very simple redundant store elimination is performed.
<span class="lineNum">    1906 </span>            : 
<span class="lineNum">    1907 </span>            :    4- We can simpify a condition to a constant or from a relational
<span class="lineNum">    1908 </span>            :       condition to an equality condition.  */
<a name="1909"><span class="lineNum">    1909 </span>            : </a>
<span class="lineNum">    1910 </span>            : edge
<span class="lineNum">    1911 </span><span class="lineCov">  102814036 : dom_opt_dom_walker::optimize_stmt (basic_block bb, gimple_stmt_iterator si)</span>
<span class="lineNum">    1912 </span>            : {
<span class="lineNum">    1913 </span><span class="lineCov">  102814036 :   gimple *stmt, *old_stmt;</span>
<span class="lineNum">    1914 </span><span class="lineCov">  102814036 :   bool may_optimize_p;</span>
<span class="lineNum">    1915 </span><span class="lineCov">  102814036 :   bool modified_p = false;</span>
<span class="lineNum">    1916 </span><span class="lineCov">  102814036 :   bool was_noreturn;</span>
<span class="lineNum">    1917 </span><span class="lineCov">  102814036 :   edge retval = NULL;</span>
<span class="lineNum">    1918 </span>            : 
<span class="lineNum">    1919 </span><span class="lineCov">  102814036 :   old_stmt = stmt = gsi_stmt (si);</span>
<span class="lineNum">    1920 </span><span class="lineCov">  205628072 :   was_noreturn = is_gimple_call (stmt) &amp;&amp; gimple_call_noreturn_p (stmt);</span>
<span class="lineNum">    1921 </span>            : 
<span class="lineNum">    1922 </span><span class="lineCov">  102814036 :   if (dump_file &amp;&amp; (dump_flags &amp; TDF_DETAILS))</span>
<span class="lineNum">    1923 </span>            :     {
<span class="lineNum">    1924 </span><span class="lineCov">       1551 :       fprintf (dump_file, &quot;Optimizing statement &quot;);</span>
<span class="lineNum">    1925 </span><span class="lineCov">       1551 :       print_gimple_stmt (dump_file, stmt, 0, TDF_SLIM);</span>
<span class="lineNum">    1926 </span>            :     }
<span class="lineNum">    1927 </span>            : 
<span class="lineNum">    1928 </span><span class="lineCov">  102814036 :   update_stmt_if_modified (stmt);</span>
<span class="lineNum">    1929 </span><span class="lineCov">  102814036 :   opt_stats.num_stmts++;</span>
<span class="lineNum">    1930 </span>            : 
<span class="lineNum">    1931 </span>            :   /* Const/copy propagate into USES, VUSES and the RHS of VDEFs.  */
<span class="lineNum">    1932 </span><span class="lineCov">  205628072 :   cprop_into_stmt (stmt, evrp_range_analyzer.get_vr_values ());</span>
<span class="lineNum">    1933 </span>            : 
<span class="lineNum">    1934 </span>            :   /* If the statement has been modified with constant replacements,
<span class="lineNum">    1935 </span>            :      fold its RHS before checking for redundant computations.  */
<span class="lineNum">    1936 </span><span class="lineCov">  205391659 :   if (gimple_modified_p (stmt))</span>
<span class="lineNum">    1937 </span>            :     {
<span class="lineNum">    1938 </span><span class="lineCov">    2890834 :       tree rhs = NULL;</span>
<span class="lineNum">    1939 </span>            : 
<span class="lineNum">    1940 </span>            :       /* Try to fold the statement making sure that STMT is kept
<span class="lineNum">    1941 </span>            :          up to date.  */
<span class="lineNum">    1942 </span><span class="lineCov">    2890834 :       if (fold_stmt (&amp;si))</span>
<span class="lineNum">    1943 </span>            :         {
<span class="lineNum">    1944 </span><span class="lineCov">     600461 :           stmt = gsi_stmt (si);</span>
<span class="lineNum">    1945 </span><span class="lineCov">     600461 :           gimple_set_modified (stmt, true);</span>
<span class="lineNum">    1946 </span>            : 
<span class="lineNum">    1947 </span><span class="lineCov">     600461 :           if (dump_file &amp;&amp; (dump_flags &amp; TDF_DETAILS))</span>
<span class="lineNum">    1948 </span>            :             {
<span class="lineNum">    1949 </span><span class="lineCov">         17 :               fprintf (dump_file, &quot;  Folded to: &quot;);</span>
<span class="lineNum">    1950 </span><span class="lineCov">         17 :               print_gimple_stmt (dump_file, stmt, 0, TDF_SLIM);</span>
<span class="lineNum">    1951 </span>            :             }
<span class="lineNum">    1952 </span>            :         }
<span class="lineNum">    1953 </span>            : 
<span class="lineNum">    1954 </span>            :       /* We only need to consider cases that can yield a gimple operand.  */
<span class="lineNum">    1955 </span><span class="lineCov">    2890834 :       if (gimple_assign_single_p (stmt))</span>
<span class="lineNum">    1956 </span><span class="lineCov">    2578658 :         rhs = gimple_assign_rhs1 (stmt);</span>
<span class="lineNum">    1957 </span><span class="lineCov">    3203010 :       else if (gimple_code (stmt) == GIMPLE_GOTO)</span>
<span class="lineNum">    1958 </span><span class="lineCov">          2 :         rhs = gimple_goto_dest (stmt);</span>
<span class="lineNum">    1959 </span><span class="lineCov">    1601503 :       else if (gswitch *swtch_stmt = dyn_cast &lt;gswitch *&gt; (stmt))</span>
<span class="lineNum">    1960 </span>            :         /* This should never be an ADDR_EXPR.  */
<span class="lineNum">    1961 </span><span class="lineCov">       2592 :         rhs = gimple_switch_index (swtch_stmt);</span>
<span class="lineNum">    1962 </span>            : 
<span class="lineNum">    1963 </span><span class="lineCov">    1290627 :       if (rhs &amp;&amp; TREE_CODE (rhs) == ADDR_EXPR)</span>
<span class="lineNum">    1964 </span><span class="lineCov">      19482 :         recompute_tree_invariant_for_addr_expr (rhs);</span>
<span class="lineNum">    1965 </span>            : 
<span class="lineNum">    1966 </span>            :       /* Indicate that maybe_clean_or_replace_eh_stmt needs to be called,
<span class="lineNum">    1967 </span>            :          even if fold_stmt updated the stmt already and thus cleared
<span class="lineNum">    1968 </span>            :          gimple_modified_p flag on it.  */
<span class="lineNum">    1969 </span>            :       modified_p = true;
<span class="lineNum">    1970 </span>            :     }
<span class="lineNum">    1971 </span>            : 
<span class="lineNum">    1972 </span>            :   /* Check for redundant computations.  Do this optimization only
<span class="lineNum">    1973 </span>            :      for assignments that have no volatile ops and conditionals.  */
<span class="lineNum">    1974 </span><span class="lineCov">  102814036 :   may_optimize_p = (!gimple_has_side_effects (stmt)</span>
<span class="lineNum">    1975 </span><span class="lineCov">  102814036 :                     &amp;&amp; (is_gimple_assign (stmt)</span>
<span class="lineNum">    1976 </span><span class="lineCov">  137321116 :                         || (is_gimple_call (stmt)</span>
<span class="lineNum">    1977 </span><span class="lineCov">    1133822 :                             &amp;&amp; gimple_call_lhs (stmt) != NULL_TREE)</span>
<span class="lineNum">    1978 </span><span class="lineCov">  136187452 :                         || gimple_code (stmt) == GIMPLE_COND</span>
<span class="lineNum">    1979 </span><span class="lineCov">  126668724 :                         || gimple_code (stmt) == GIMPLE_SWITCH));</span>
<span class="lineNum">    1980 </span>            : 
<span class="lineNum">    1981 </span><span class="lineCov">   30901300 :   if (may_optimize_p)</span>
<span class="lineNum">    1982 </span>            :     {
<span class="lineNum">    1983 </span><span class="lineCov">   61802600 :       if (gimple_code (stmt) == GIMPLE_CALL)</span>
<span class="lineNum">    1984 </span>            :         {
<span class="lineNum">    1985 </span>            :           /* Resolve __builtin_constant_p.  If it hasn't been
<span class="lineNum">    1986 </span>            :              folded to integer_one_node by now, it's fairly
<span class="lineNum">    1987 </span>            :              certain that the value simply isn't constant.  */
<span class="lineNum">    1988 </span><span class="lineCov">     566832 :           tree callee = gimple_call_fndecl (stmt);</span>
<span class="lineNum">    1989 </span><span class="lineCov">     566832 :           if (callee</span>
<span class="lineNum">    1990 </span><span class="lineCov">     566832 :               &amp;&amp; fndecl_built_in_p (callee, BUILT_IN_CONSTANT_P))</span>
<span class="lineNum">    1991 </span>            :             {
<span class="lineNum">    1992 </span><span class="lineCov">       9703 :               propagate_tree_value_into_stmt (&amp;si, integer_zero_node);</span>
<span class="lineNum">    1993 </span><span class="lineCov">      19406 :               stmt = gsi_stmt (si);</span>
<span class="lineNum">    1994 </span>            :             }
<span class="lineNum">    1995 </span>            :         }
<span class="lineNum">    1996 </span>            : 
<span class="lineNum">    1997 </span><span class="lineCov">   61802600 :       if (gimple_code (stmt) == GIMPLE_COND)</span>
<span class="lineNum">    1998 </span>            :         {
<span class="lineNum">    1999 </span><span class="lineCov">    4759364 :           tree lhs = gimple_cond_lhs (stmt);</span>
<span class="lineNum">    2000 </span><span class="lineCov">    4759364 :           tree rhs = gimple_cond_rhs (stmt);</span>
<span class="lineNum">    2001 </span>            : 
<span class="lineNum">    2002 </span>            :           /* If the LHS has a range [0..1] and the RHS has a range ~[0..1],
<span class="lineNum">    2003 </span>            :              then this conditional is computable at compile time.  We can just
<span class="lineNum">    2004 </span>            :              shove either 0 or 1 into the LHS, mark the statement as modified
<span class="lineNum">    2005 </span>            :              and all the right things will just happen below.
<span class="lineNum">    2006 </span>            : 
<span class="lineNum">    2007 </span>            :              Note this would apply to any case where LHS has a range
<span class="lineNum">    2008 </span>            :              narrower than its type implies and RHS is outside that
<span class="lineNum">    2009 </span>            :              narrower range.  Future work.  */
<span class="lineNum">    2010 </span><span class="lineCov">    4759364 :           if (TREE_CODE (lhs) == SSA_NAME</span>
<span class="lineNum">    2011 </span><span class="lineCov">    4572482 :               &amp;&amp; ssa_name_has_boolean_range (lhs)</span>
<span class="lineNum">    2012 </span><span class="lineCov">     763634 :               &amp;&amp; TREE_CODE (rhs) == INTEGER_CST</span>
<span class="lineNum">    2013 </span><span class="lineCov">    5504140 :               &amp;&amp; ! (integer_zerop (rhs) || integer_onep (rhs)))</span>
<span class="lineNum">    2014 </span>            :             {
<span class="lineNum">    2015 </span><span class="lineCov">          5 :               gimple_cond_set_lhs (as_a &lt;gcond *&gt; (stmt),</span>
<span class="lineNum">    2016 </span><span class="lineCov">          5 :                                    fold_convert (TREE_TYPE (lhs),</span>
<span class="lineNum">    2017 </span>            :                                                  integer_zero_node));
<span class="lineNum">    2018 </span><span class="lineCov">          5 :               gimple_set_modified (stmt, true);</span>
<span class="lineNum">    2019 </span>            :             }
<span class="lineNum">    2020 </span><span class="lineCov">    4759359 :           else if (TREE_CODE (lhs) == SSA_NAME)</span>
<span class="lineNum">    2021 </span>            :             {
<span class="lineNum">    2022 </span>            :               /* Exploiting EVRP data is not yet fully integrated into DOM
<span class="lineNum">    2023 </span>            :                  but we need to do something for this case to avoid regressing
<span class="lineNum">    2024 </span>            :                  udr4.f90 and new1.C which have unexecutable blocks with
<span class="lineNum">    2025 </span>            :                  undefined behavior that get diagnosed if they're left in the
<span class="lineNum">    2026 </span>            :                  IL because we've attached range information to new
<span class="lineNum">    2027 </span>            :                  SSA_NAMES.  */
<span class="lineNum">    2028 </span><span class="lineCov">    4572477 :               update_stmt_if_modified (stmt);</span>
<span class="lineNum">    2029 </span><span class="lineCov">    4572477 :               edge taken_edge = NULL;</span>
<span class="lineNum">    2030 </span><span class="lineCov">    4572477 :               evrp_range_analyzer.vrp_visit_cond_stmt (as_a &lt;gcond *&gt; (stmt),</span>
<span class="lineNum">    2031 </span>            :                                                        &amp;taken_edge);
<span class="lineNum">    2032 </span><span class="lineCov">    4572477 :               if (taken_edge)</span>
<span class="lineNum">    2033 </span>            :                 {
<span class="lineNum">    2034 </span><span class="lineCov">      13959 :                   if (taken_edge-&gt;flags &amp; EDGE_TRUE_VALUE)</span>
<span class="lineNum">    2035 </span><span class="lineCov">       6715 :                     gimple_cond_make_true (as_a &lt;gcond *&gt; (stmt));</span>
<span class="lineNum">    2036 </span><span class="lineCov">       7244 :                   else if (taken_edge-&gt;flags &amp; EDGE_FALSE_VALUE)</span>
<span class="lineNum">    2037 </span><span class="lineCov">       7244 :                     gimple_cond_make_false (as_a &lt;gcond *&gt; (stmt));</span>
<span class="lineNum">    2038 </span>            :                   else
<span class="lineNum">    2039 </span><span class="lineNoCov">          0 :                     gcc_unreachable ();</span>
<span class="lineNum">    2040 </span><span class="lineCov">      13959 :                   gimple_set_modified (stmt, true);</span>
<span class="lineNum">    2041 </span><span class="lineCov">      13959 :                   update_stmt (stmt);</span>
<span class="lineNum">    2042 </span><span class="lineCov">      13959 :                   cfg_altered = true;</span>
<span class="lineNum">    2043 </span><span class="lineCov">      13959 :                   return taken_edge;</span>
<span class="lineNum">    2044 </span>            :                 }
<span class="lineNum">    2045 </span>            :             }
<span class="lineNum">    2046 </span>            :         }
<span class="lineNum">    2047 </span>            : 
<span class="lineNum">    2048 </span><span class="lineCov">   30887341 :       update_stmt_if_modified (stmt);</span>
<span class="lineNum">    2049 </span><span class="lineCov">   30887341 :       eliminate_redundant_computations (&amp;si, m_const_and_copies,</span>
<span class="lineNum">    2050 </span>            :                                         m_avail_exprs_stack);
<span class="lineNum">    2051 </span><span class="lineCov">   30887341 :       stmt = gsi_stmt (si);</span>
<span class="lineNum">    2052 </span>            : 
<span class="lineNum">    2053 </span>            :       /* Perform simple redundant store elimination.  */
<span class="lineNum">    2054 </span><span class="lineCov">   30887341 :       if (gimple_assign_single_p (stmt)</span>
<span class="lineNum">    2055 </span><span class="lineCov">   33307306 :           &amp;&amp; TREE_CODE (gimple_assign_lhs (stmt)) != SSA_NAME)</span>
<span class="lineNum">    2056 </span>            :         {
<span class="lineNum">    2057 </span><span class="lineCov">    8150196 :           tree lhs = gimple_assign_lhs (stmt);</span>
<span class="lineNum">    2058 </span><span class="lineCov">    8150196 :           tree rhs = gimple_assign_rhs1 (stmt);</span>
<span class="lineNum">    2059 </span><span class="lineCov">    8150196 :           tree cached_lhs;</span>
<span class="lineNum">    2060 </span><span class="lineCov">    8150196 :           gassign *new_stmt;</span>
<span class="lineNum">    2061 </span><span class="lineCov">    8150196 :           rhs = dom_valueize (rhs);</span>
<span class="lineNum">    2062 </span>            :           /* Build a new statement with the RHS and LHS exchanged.  */
<span class="lineNum">    2063 </span><span class="lineCov">    8150196 :           if (TREE_CODE (rhs) == SSA_NAME)</span>
<span class="lineNum">    2064 </span>            :             {
<span class="lineNum">    2065 </span><span class="lineCov">    3217706 :               gimple *defstmt = SSA_NAME_DEF_STMT (rhs);</span>
<span class="lineNum">    2066 </span><span class="lineCov">    3217706 :               new_stmt = gimple_build_assign (rhs, lhs);</span>
<span class="lineNum">    2067 </span><span class="lineCov">    3217706 :               SSA_NAME_DEF_STMT (rhs) = defstmt;</span>
<span class="lineNum">    2068 </span>            :             }
<span class="lineNum">    2069 </span>            :           else
<span class="lineNum">    2070 </span><span class="lineCov">    4932490 :             new_stmt = gimple_build_assign (rhs, lhs);</span>
<span class="lineNum">    2071 </span><span class="lineCov">   16300392 :           gimple_set_vuse (new_stmt, gimple_vuse (stmt));</span>
<span class="lineNum">    2072 </span><span class="lineCov">    8150196 :           cached_lhs = m_avail_exprs_stack-&gt;lookup_avail_expr (new_stmt, false,</span>
<span class="lineNum">    2073 </span>            :                                                                false);
<span class="lineNum">    2074 </span><span class="lineCov">    8150196 :           if (cached_lhs &amp;&amp; operand_equal_p (rhs, cached_lhs, 0))</span>
<span class="lineNum">    2075 </span>            :             {
<span class="lineNum">    2076 </span><span class="lineCov">      27277 :               basic_block bb = gimple_bb (stmt);</span>
<span class="lineNum">    2077 </span><span class="lineCov">      27277 :               unlink_stmt_vdef (stmt);</span>
<span class="lineNum">    2078 </span><span class="lineCov">      27277 :               if (gsi_remove (&amp;si, true))</span>
<span class="lineNum">    2079 </span>            :                 {
<span class="lineNum">    2080 </span><span class="lineNoCov">          0 :                   bitmap_set_bit (need_eh_cleanup, bb-&gt;index);</span>
<span class="lineNum">    2081 </span><span class="lineNoCov">          0 :                   if (dump_file &amp;&amp; (dump_flags &amp; TDF_DETAILS))</span>
<span class="lineNum">    2082 </span><span class="lineNoCov">          0 :                     fprintf (dump_file, &quot;  Flagged to clear EH edges.\n&quot;);</span>
<span class="lineNum">    2083 </span>            :                 }
<span class="lineNum">    2084 </span><span class="lineCov">      27277 :               release_defs (stmt);</span>
<span class="lineNum">    2085 </span><span class="lineCov">      27277 :               return retval;</span>
<span class="lineNum">    2086 </span>            :             }
<span class="lineNum">    2087 </span>            :         }
<span class="lineNum">    2088 </span>            : 
<span class="lineNum">    2089 </span>            :       /* If this statement was not redundant, we may still be able to simplify
<span class="lineNum">    2090 </span>            :          it, which may in turn allow other part of DOM or other passes to do
<span class="lineNum">    2091 </span>            :          a better job.  */
<span class="lineNum">    2092 </span><span class="lineCov">   30860064 :       test_for_singularity (stmt, m_dummy_cond, m_avail_exprs_stack);</span>
<span class="lineNum">    2093 </span>            :     }
<span class="lineNum">    2094 </span>            : 
<span class="lineNum">    2095 </span>            :   /* Record any additional equivalences created by this statement.  */
<span class="lineNum">    2096 </span><span class="lineCov">  205545600 :   if (is_gimple_assign (stmt))</span>
<span class="lineNum">    2097 </span><span class="lineCov">   28102205 :     record_equivalences_from_stmt (stmt, may_optimize_p, m_avail_exprs_stack);</span>
<span class="lineNum">    2098 </span>            : 
<span class="lineNum">    2099 </span>            :   /* If STMT is a COND_EXPR or SWITCH_EXPR and it was modified, then we may
<span class="lineNum">    2100 </span>            :      know where it goes.  */
<span class="lineNum">    2101 </span><span class="lineCov">  205545600 :   if (gimple_modified_p (stmt) || modified_p)</span>
<span class="lineNum">    2102 </span>            :     {
<span class="lineNum">    2103 </span><span class="lineCov">    3326063 :       tree val = NULL;</span>
<span class="lineNum">    2104 </span>            : 
<span class="lineNum">    2105 </span><span class="lineCov">    6652126 :       if (gimple_code (stmt) == GIMPLE_COND)</span>
<span class="lineNum">    2106 </span><span class="lineCov">    1534985 :         val = fold_binary_loc (gimple_location (stmt),</span>
<span class="lineNum">    2107 </span>            :                                gimple_cond_code (stmt), boolean_type_node,
<span class="lineNum">    2108 </span>            :                                gimple_cond_lhs (stmt),
<span class="lineNum">    2109 </span>            :                                gimple_cond_rhs (stmt));
<span class="lineNum">    2110 </span><span class="lineCov">    3019066 :       else if (gswitch *swtch_stmt = dyn_cast &lt;gswitch *&gt; (stmt))</span>
<span class="lineNum">    2111 </span><span class="lineCov">       2592 :         val = gimple_switch_index (swtch_stmt);</span>
<span class="lineNum">    2112 </span>            : 
<span class="lineNum">    2113 </span><span class="lineCov">     308293 :       if (val &amp;&amp; TREE_CODE (val) == INTEGER_CST)</span>
<span class="lineNum">    2114 </span>            :         {
<span class="lineNum">    2115 </span><span class="lineCov">      38459 :           retval = find_taken_edge (bb, val);</span>
<span class="lineNum">    2116 </span><span class="lineCov">      38459 :           if (retval)</span>
<span class="lineNum">    2117 </span>            :             {
<span class="lineNum">    2118 </span>            :               /* Fix the condition to be either true or false.  */
<span class="lineNum">    2119 </span><span class="lineCov">      76918 :               if (gimple_code (stmt) == GIMPLE_COND)</span>
<span class="lineNum">    2120 </span>            :                 {
<span class="lineNum">    2121 </span><span class="lineCov">      38439 :                   if (integer_zerop (val))</span>
<span class="lineNum">    2122 </span><span class="lineCov">      23886 :                     gimple_cond_make_false (as_a &lt;gcond *&gt; (stmt));</span>
<span class="lineNum">    2123 </span><span class="lineCov">      14553 :                   else if (integer_onep (val))</span>
<span class="lineNum">    2124 </span><span class="lineCov">      14553 :                     gimple_cond_make_true (as_a &lt;gcond *&gt; (stmt));</span>
<span class="lineNum">    2125 </span>            :                   else
<span class="lineNum">    2126 </span><span class="lineNoCov">          0 :                     gcc_unreachable ();</span>
<span class="lineNum">    2127 </span>            : 
<span class="lineNum">    2128 </span><span class="lineCov">      38439 :                   gimple_set_modified (stmt, true);</span>
<span class="lineNum">    2129 </span>            :                 }
<span class="lineNum">    2130 </span>            : 
<span class="lineNum">    2131 </span>            :               /* Further simplifications may be possible.  */
<span class="lineNum">    2132 </span><span class="lineCov">      38459 :               cfg_altered = true;</span>
<span class="lineNum">    2133 </span>            :             }
<span class="lineNum">    2134 </span>            :         }
<span class="lineNum">    2135 </span>            : 
<span class="lineNum">    2136 </span><span class="lineCov">    3326063 :       update_stmt_if_modified (stmt);</span>
<span class="lineNum">    2137 </span>            : 
<span class="lineNum">    2138 </span>            :       /* If we simplified a statement in such a way as to be shown that it
<span class="lineNum">    2139 </span>            :          cannot trap, update the eh information and the cfg to match.  */
<span class="lineNum">    2140 </span><span class="lineCov">    3326063 :       if (maybe_clean_or_replace_eh_stmt (old_stmt, stmt))</span>
<span class="lineNum">    2141 </span>            :         {
<span class="lineNum">    2142 </span><span class="lineCov">        379 :           bitmap_set_bit (need_eh_cleanup, bb-&gt;index);</span>
<span class="lineNum">    2143 </span><span class="lineCov">        379 :           if (dump_file &amp;&amp; (dump_flags &amp; TDF_DETAILS))</span>
<span class="lineNum">    2144 </span><span class="lineNoCov">          0 :             fprintf (dump_file, &quot;  Flagged to clear EH edges.\n&quot;);</span>
<span class="lineNum">    2145 </span>            :         }
<span class="lineNum">    2146 </span>            : 
<span class="lineNum">    2147 </span><span class="lineCov">    3326063 :       if (!was_noreturn</span>
<span class="lineNum">    2148 </span><span class="lineCov">    3326063 :           &amp;&amp; is_gimple_call (stmt) &amp;&amp; gimple_call_noreturn_p (stmt))</span>
<span class="lineNum">    2149 </span><span class="lineCov">          5 :         need_noreturn_fixup.safe_push (stmt);</span>
<span class="lineNum">    2150 </span>            :     }
<span class="lineNum">    2151 </span>            :   return retval;
<span class="lineNum">    2152 </span>            : }
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.0</a></td></tr>
  </table>
  <br>
<h3>LCOV profile is generated on x86_64 machine using following configure options: configure --disable-bootstrap --enable-coverage=opt --enable-languages=c,c++,fortran,go,jit,lto --enable-host-shared. GCC test suite is run with the built compiler.</h3></body></html>
