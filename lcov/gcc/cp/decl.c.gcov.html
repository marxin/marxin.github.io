<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - gcc.info - gcc/cp/decl.c</title>
  <link rel="stylesheet" type="text/css" href="../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../index.html">top level</a> - <a href="index.html">gcc/cp</a> - decl.c<span style="font-size: 80%;"> (source / <a href="decl.c.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">gcc.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">6713</td>
            <td class="headerCovTableEntry">7170</td>
            <td class="headerCovTableEntryHi">93.6 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2018-09-22 10:58:49</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">193</td>
            <td class="headerCovTableEntry">204</td>
            <td class="headerCovTableEntryHi">94.6 %</td>
          </tr>
          <tr>
            <td class="headerItem">Legend:</td>
            <td class="headerValueLeg">            Lines:
            <span class="coverLegendCov">hit</span>
            <span class="coverLegendNoCov">not hit</span>
</td>
            <td></td>
          </tr>
          <tr><td><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">          Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>            : /* Process declarations and variables for C++ compiler.</a>
<span class="lineNum">       2 </span>            :    Copyright (C) 1988-2018 Free Software Foundation, Inc.
<span class="lineNum">       3 </span>            :    Contributed by Michael Tiemann (tiemann@cygnus.com)
<span class="lineNum">       4 </span>            : 
<span class="lineNum">       5 </span>            : This file is part of GCC.
<span class="lineNum">       6 </span>            : 
<span class="lineNum">       7 </span>            : GCC is free software; you can redistribute it and/or modify
<span class="lineNum">       8 </span>            : it under the terms of the GNU General Public License as published by
<span class="lineNum">       9 </span>            : the Free Software Foundation; either version 3, or (at your option)
<span class="lineNum">      10 </span>            : any later version.
<span class="lineNum">      11 </span>            : 
<span class="lineNum">      12 </span>            : GCC is distributed in the hope that it will be useful,
<span class="lineNum">      13 </span>            : but WITHOUT ANY WARRANTY; without even the implied warranty of
<span class="lineNum">      14 </span>            : MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
<span class="lineNum">      15 </span>            : GNU General Public License for more details.
<span class="lineNum">      16 </span>            : 
<span class="lineNum">      17 </span>            : You should have received a copy of the GNU General Public License
<span class="lineNum">      18 </span>            : along with GCC; see the file COPYING3.  If not see
<span class="lineNum">      19 </span>            : &lt;http://www.gnu.org/licenses/&gt;.  */
<span class="lineNum">      20 </span>            : 
<span class="lineNum">      21 </span>            : 
<span class="lineNum">      22 </span>            : /* Process declarations and symbol lookup for C++ front end.
<span class="lineNum">      23 </span>            :    Also constructs types; the standard scalar types at initialization,
<span class="lineNum">      24 </span>            :    and structure, union, array and enum types when they are declared.  */
<span class="lineNum">      25 </span>            : 
<span class="lineNum">      26 </span>            : /* ??? not all decl nodes are given the most useful possible
<span class="lineNum">      27 </span>            :    line numbers.  For example, the CONST_DECLs for enum values.  */
<span class="lineNum">      28 </span>            : 
<span class="lineNum">      29 </span>            : #include &quot;config.h&quot;
<span class="lineNum">      30 </span>            : #include &quot;system.h&quot;
<span class="lineNum">      31 </span>            : #include &quot;coretypes.h&quot;
<span class="lineNum">      32 </span>            : #include &quot;target.h&quot;
<span class="lineNum">      33 </span>            : #include &quot;c-family/c-target.h&quot;
<span class="lineNum">      34 </span>            : #include &quot;cp-tree.h&quot;
<span class="lineNum">      35 </span>            : #include &quot;timevar.h&quot;
<span class="lineNum">      36 </span>            : #include &quot;stringpool.h&quot;
<span class="lineNum">      37 </span>            : #include &quot;cgraph.h&quot;
<span class="lineNum">      38 </span>            : #include &quot;stor-layout.h&quot;
<span class="lineNum">      39 </span>            : #include &quot;varasm.h&quot;
<span class="lineNum">      40 </span>            : #include &quot;attribs.h&quot;
<span class="lineNum">      41 </span>            : #include &quot;flags.h&quot;
<span class="lineNum">      42 </span>            : #include &quot;tree-iterator.h&quot;
<span class="lineNum">      43 </span>            : #include &quot;decl.h&quot;
<span class="lineNum">      44 </span>            : #include &quot;intl.h&quot;
<span class="lineNum">      45 </span>            : #include &quot;toplev.h&quot;
<span class="lineNum">      46 </span>            : #include &quot;c-family/c-objc.h&quot;
<span class="lineNum">      47 </span>            : #include &quot;c-family/c-pragma.h&quot;
<span class="lineNum">      48 </span>            : #include &quot;c-family/c-ubsan.h&quot;
<span class="lineNum">      49 </span>            : #include &quot;debug.h&quot;
<span class="lineNum">      50 </span>            : #include &quot;plugin.h&quot;
<span class="lineNum">      51 </span>            : #include &quot;builtins.h&quot;
<span class="lineNum">      52 </span>            : #include &quot;gimplify.h&quot;
<span class="lineNum">      53 </span>            : #include &quot;asan.h&quot;
<span class="lineNum">      54 </span>            : #include &quot;gcc-rich-location.h&quot;
<span class="lineNum">      55 </span>            : #include &quot;langhooks.h&quot;
<span class="lineNum">      56 </span>            : 
<span class="lineNum">      57 </span>            : /* Possible cases of bad specifiers type used by bad_specifiers. */
<span class="lineNum">      58 </span>            : enum bad_spec_place {
<span class="lineNum">      59 </span>            :   BSP_VAR,    /* variable */
<span class="lineNum">      60 </span>            :   BSP_PARM,   /* parameter */
<span class="lineNum">      61 </span>            :   BSP_TYPE,   /* type */
<span class="lineNum">      62 </span>            :   BSP_FIELD   /* field */
<span class="lineNum">      63 </span>            : };
<span class="lineNum">      64 </span>            : 
<span class="lineNum">      65 </span>            : static const char *redeclaration_error_message (tree, tree);
<span class="lineNum">      66 </span>            : 
<span class="lineNum">      67 </span>            : static int decl_jump_unsafe (tree);
<span class="lineNum">      68 </span>            : static void require_complete_types_for_parms (tree);
<span class="lineNum">      69 </span>            : static void push_local_name (tree);
<span class="lineNum">      70 </span>            : static tree grok_reference_init (tree, tree, tree, int);
<span class="lineNum">      71 </span>            : static tree grokvardecl (tree, tree, tree, const cp_decl_specifier_seq *,
<span class="lineNum">      72 </span>            :                          int, int, int, bool, int, tree);
<span class="lineNum">      73 </span>            : static void check_static_variable_definition (tree, tree);
<span class="lineNum">      74 </span>            : static void record_unknown_type (tree, const char *);
<span class="lineNum">      75 </span>            : static tree builtin_function_1 (tree, tree, bool);
<span class="lineNum">      76 </span>            : static int member_function_or_else (tree, tree, enum overload_flags);
<span class="lineNum">      77 </span>            : static tree local_variable_p_walkfn (tree *, int *, void *);
<span class="lineNum">      78 </span>            : static const char *tag_name (enum tag_types);
<span class="lineNum">      79 </span>            : static tree lookup_and_check_tag (enum tag_types, tree, tag_scope, bool);
<span class="lineNum">      80 </span>            : static void maybe_deduce_size_from_array_init (tree, tree);
<span class="lineNum">      81 </span>            : static void layout_var_decl (tree);
<span class="lineNum">      82 </span>            : static tree check_initializer (tree, tree, int, vec&lt;tree, va_gc&gt; **);
<span class="lineNum">      83 </span>            : static void make_rtl_for_nonlocal_decl (tree, tree, const char *);
<span class="lineNum">      84 </span>            : static void save_function_data (tree);
<span class="lineNum">      85 </span>            : static void copy_type_enum (tree , tree);
<span class="lineNum">      86 </span>            : static void check_function_type (tree, tree);
<span class="lineNum">      87 </span>            : static void finish_constructor_body (void);
<span class="lineNum">      88 </span>            : static void begin_destructor_body (void);
<span class="lineNum">      89 </span>            : static void finish_destructor_body (void);
<span class="lineNum">      90 </span>            : static void record_key_method_defined (tree);
<span class="lineNum">      91 </span>            : static tree create_array_type_for_decl (tree, tree, tree);
<span class="lineNum">      92 </span>            : static tree get_atexit_node (void);
<span class="lineNum">      93 </span>            : static tree get_dso_handle_node (void);
<span class="lineNum">      94 </span>            : static tree start_cleanup_fn (void);
<span class="lineNum">      95 </span>            : static void end_cleanup_fn (void);
<span class="lineNum">      96 </span>            : static tree cp_make_fname_decl (location_t, tree, int);
<span class="lineNum">      97 </span>            : static void initialize_predefined_identifiers (void);
<span class="lineNum">      98 </span>            : static tree check_special_function_return_type
<span class="lineNum">      99 </span>            :        (special_function_kind, tree, tree, int, const location_t*);
<span class="lineNum">     100 </span>            : static tree push_cp_library_fn (enum tree_code, tree, int);
<span class="lineNum">     101 </span>            : static tree build_cp_library_fn (tree, enum tree_code, tree, int);
<span class="lineNum">     102 </span>            : static void store_parm_decls (tree);
<span class="lineNum">     103 </span>            : static void initialize_local_var (tree, tree);
<span class="lineNum">     104 </span>            : static void expand_static_init (tree, tree);
<span class="lineNum">     105 </span>            : 
<span class="lineNum">     106 </span>            : /* The following symbols are subsumed in the cp_global_trees array, and
<span class="lineNum">     107 </span>            :    listed here individually for documentation purposes.
<span class="lineNum">     108 </span>            : 
<span class="lineNum">     109 </span>            :    C++ extensions
<span class="lineNum">     110 </span>            :         tree wchar_decl_node;
<span class="lineNum">     111 </span>            : 
<span class="lineNum">     112 </span>            :         tree vtable_entry_type;
<span class="lineNum">     113 </span>            :         tree delta_type_node;
<span class="lineNum">     114 </span>            :         tree __t_desc_type_node;
<span class="lineNum">     115 </span>            : 
<span class="lineNum">     116 </span>            :         tree class_type_node;
<span class="lineNum">     117 </span>            :         tree unknown_type_node;
<span class="lineNum">     118 </span>            : 
<span class="lineNum">     119 </span>            :    Array type `vtable_entry_type[]'
<span class="lineNum">     120 </span>            : 
<span class="lineNum">     121 </span>            :         tree vtbl_type_node;
<span class="lineNum">     122 </span>            :         tree vtbl_ptr_type_node;
<span class="lineNum">     123 </span>            : 
<span class="lineNum">     124 </span>            :    Namespaces,
<span class="lineNum">     125 </span>            : 
<span class="lineNum">     126 </span>            :         tree std_node;
<span class="lineNum">     127 </span>            :         tree abi_node;
<span class="lineNum">     128 </span>            : 
<span class="lineNum">     129 </span>            :    A FUNCTION_DECL which can call `abort'.  Not necessarily the
<span class="lineNum">     130 </span>            :    one that the user will declare, but sufficient to be called
<span class="lineNum">     131 </span>            :    by routines that want to abort the program.
<span class="lineNum">     132 </span>            : 
<span class="lineNum">     133 </span>            :         tree abort_fndecl;
<span class="lineNum">     134 </span>            : 
<span class="lineNum">     135 </span>            :    Used by RTTI
<span class="lineNum">     136 </span>            :         tree type_info_type_node, tinfo_decl_id, tinfo_decl_type;
<span class="lineNum">     137 </span>            :         tree tinfo_var_id;  */
<span class="lineNum">     138 </span>            : 
<span class="lineNum">     139 </span>            : tree cp_global_trees[CPTI_MAX];
<span class="lineNum">     140 </span>            : 
<span class="lineNum">     141 </span>            : #define local_names cp_function_chain-&gt;x_local_names
<span class="lineNum">     142 </span>            : 
<span class="lineNum">     143 </span>            : /* A list of objects which have constructors or destructors
<span class="lineNum">     144 </span>            :    which reside in the global scope.  The decl is stored in
<span class="lineNum">     145 </span>            :    the TREE_VALUE slot and the initializer is stored
<span class="lineNum">     146 </span>            :    in the TREE_PURPOSE slot.  */
<span class="lineNum">     147 </span>            : tree static_aggregates;
<span class="lineNum">     148 </span>            : 
<span class="lineNum">     149 </span>            : /* Like static_aggregates, but for thread_local variables.  */
<span class="lineNum">     150 </span>            : tree tls_aggregates;
<span class="lineNum">     151 </span>            : 
<span class="lineNum">     152 </span>            : /* -- end of C++ */
<span class="lineNum">     153 </span>            : 
<span class="lineNum">     154 </span>            : /* A node for the integer constant 2.  */
<span class="lineNum">     155 </span>            : 
<span class="lineNum">     156 </span>            : tree integer_two_node;
<span class="lineNum">     157 </span>            : 
<span class="lineNum">     158 </span>            : /* vector of static decls.  */
<span class="lineNum">     159 </span>            : vec&lt;tree, va_gc&gt; *static_decls;
<span class="lineNum">     160 </span>            : 
<span class="lineNum">     161 </span>            : /* vector of keyed classes.  */
<span class="lineNum">     162 </span>            : vec&lt;tree, va_gc&gt; *keyed_classes;
<span class="lineNum">     163 </span>            : 
<span class="lineNum">     164 </span>            : /* Used only for jumps to as-yet undefined labels, since jumps to
<span class="lineNum">     165 </span>            :    defined labels can have their validity checked immediately.  */
<span class="lineNum">     166 </span>            : 
<span class="lineNum">     167 </span>            : struct GTY((chain_next (&quot;%h.next&quot;))) named_label_use_entry {
<span class="lineNum">     168 </span>            :   struct named_label_use_entry *next;
<span class="lineNum">     169 </span>            :   /* The binding level to which this entry is *currently* attached.
<span class="lineNum">     170 </span>            :      This is initially the binding level in which the goto appeared,
<span class="lineNum">     171 </span>            :      but is modified as scopes are closed.  */
<span class="lineNum">     172 </span>            :   cp_binding_level *binding_level;
<span class="lineNum">     173 </span>            :   /* The head of the names list that was current when the goto appeared,
<span class="lineNum">     174 </span>            :      or the inner scope popped.  These are the decls that will *not* be
<span class="lineNum">     175 </span>            :      skipped when jumping to the label.  */
<span class="lineNum">     176 </span>            :   tree names_in_scope;
<span class="lineNum">     177 </span>            :   /* The location of the goto, for error reporting.  */
<span class="lineNum">     178 </span>            :   location_t o_goto_locus;
<span class="lineNum">     179 </span>            :   /* True if an OpenMP structured block scope has been closed since
<span class="lineNum">     180 </span>            :      the goto appeared.  This means that the branch from the label will
<span class="lineNum">     181 </span>            :      illegally exit an OpenMP scope.  */
<span class="lineNum">     182 </span>            :   bool in_omp_scope;
<span class="lineNum">     183 </span>            : };
<span class="lineNum">     184 </span>            : 
<span class="lineNum">     185 </span>            : /* A list of all LABEL_DECLs in the function that have names.  Here so
<span class="lineNum">     186 </span>            :    we can clear out their names' definitions at the end of the
<span class="lineNum">     187 </span>            :    function, and so we can check the validity of jumps to these labels.  */
<span class="lineNum">     188 </span>            : 
<span class="lineNum">     189 </span>            : struct GTY((for_user)) named_label_entry {
<span class="lineNum">     190 </span>            : 
<span class="lineNum">     191 </span>            :   tree name;  /* Name of decl. */
<span class="lineNum">     192 </span>            : 
<span class="lineNum">     193 </span>            :   tree label_decl; /* LABEL_DECL, unless deleted local label. */
<span class="lineNum">     194 </span>            : 
<span class="lineNum">     195 </span>            :   named_label_entry *outer; /* Outer shadowed chain.  */
<span class="lineNum">     196 </span>            : 
<span class="lineNum">     197 </span>            :   /* The binding level to which the label is *currently* attached.
<span class="lineNum">     198 </span>            :      This is initially set to the binding level in which the label
<span class="lineNum">     199 </span>            :      is defined, but is modified as scopes are closed.  */
<span class="lineNum">     200 </span>            :   cp_binding_level *binding_level;
<span class="lineNum">     201 </span>            : 
<span class="lineNum">     202 </span>            :   /* The head of the names list that was current when the label was
<span class="lineNum">     203 </span>            :      defined, or the inner scope popped.  These are the decls that will
<span class="lineNum">     204 </span>            :      be skipped when jumping to the label.  */
<span class="lineNum">     205 </span>            :   tree names_in_scope;
<span class="lineNum">     206 </span>            : 
<span class="lineNum">     207 </span>            :   /* A vector of all decls from all binding levels that would be
<span class="lineNum">     208 </span>            :      crossed by a backward branch to the label.  */
<span class="lineNum">     209 </span>            :   vec&lt;tree, va_gc&gt; *bad_decls;
<span class="lineNum">     210 </span>            : 
<span class="lineNum">     211 </span>            :   /* A list of uses of the label, before the label is defined.  */
<span class="lineNum">     212 </span>            :   named_label_use_entry *uses;
<span class="lineNum">     213 </span>            : 
<span class="lineNum">     214 </span>            :   /* The following bits are set after the label is defined, and are
<span class="lineNum">     215 </span>            :      updated as scopes are popped.  They indicate that a jump to the
<span class="lineNum">     216 </span>            :      label will illegally enter a scope of the given flavor.  */
<span class="lineNum">     217 </span>            :   bool in_try_scope;
<span class="lineNum">     218 </span>            :   bool in_catch_scope;
<span class="lineNum">     219 </span>            :   bool in_omp_scope;
<span class="lineNum">     220 </span>            :   bool in_transaction_scope;
<span class="lineNum">     221 </span>            :   bool in_constexpr_if;
<span class="lineNum">     222 </span>            : };
<span class="lineNum">     223 </span>            : 
<span class="lineNum">     224 </span>            : #define named_labels cp_function_chain-&gt;x_named_labels
<span class="lineNum">     225 </span>            : 
<span class="lineNum">     226 </span>            : /* The number of function bodies which we are currently processing.
<span class="lineNum">     227 </span>            :    (Zero if we are at namespace scope, one inside the body of a
<span class="lineNum">     228 </span>            :    function, two inside the body of a function in a local class, etc.)  */
<span class="lineNum">     229 </span>            : int function_depth;
<span class="lineNum">     230 </span>            : 
<span class="lineNum">     231 </span>            : /* Whether the exception-specifier is part of a function type (i.e. C++17).  */
<span class="lineNum">     232 </span>            : bool flag_noexcept_type;
<span class="lineNum">     233 </span>            : 
<span class="lineNum">     234 </span>            : /* States indicating how grokdeclarator() should handle declspecs marked
<span class="lineNum">     235 </span>            :    with __attribute__((deprecated)).  An object declared as
<span class="lineNum">     236 </span>            :    __attribute__((deprecated)) suppresses warnings of uses of other
<span class="lineNum">     237 </span>            :    deprecated items.  */
<span class="lineNum">     238 </span>            : enum deprecated_states deprecated_state = DEPRECATED_NORMAL;
<span class="lineNum">     239 </span>            : 
<span class="lineNum">     240 </span>            : 
<span class="lineNum">     241 </span>            : /* A list of VAR_DECLs whose type was incomplete at the time the
<span class="lineNum">     242 </span>            :    variable was declared.  */
<span class="lineNum">     243 </span>            : 
<span class="lineNum">     244 </span>            : struct GTY(()) incomplete_var {
<span class="lineNum">     245 </span>            :   tree decl;
<span class="lineNum">     246 </span>            :   tree incomplete_type;
<span class="lineNum">     247 </span>            : };
<span class="lineNum">     248 </span>            : 
<span class="lineNum">     249 </span>            : 
<span class="lineNum">     250 </span>            : static GTY(()) vec&lt;incomplete_var, va_gc&gt; *incomplete_vars;
<span class="lineNum">     251 </span>            : 
<span class="lineNum">     252 </span>            : /* Returns the kind of template specialization we are currently
<span class="lineNum">     253 </span>            :    processing, given that it's declaration contained N_CLASS_SCOPES
<span class="lineNum">     254 </span>            :    explicit scope qualifications.  */
<a name="255"><span class="lineNum">     255 </span>            : </a>
<span class="lineNum">     256 </span>            : tmpl_spec_kind
<span class="lineNum">     257 </span><span class="lineCov">   12661607 : current_tmpl_spec_kind (int n_class_scopes)</span>
<span class="lineNum">     258 </span>            : {
<span class="lineNum">     259 </span><span class="lineCov">   12661607 :   int n_template_parm_scopes = 0;</span>
<span class="lineNum">     260 </span><span class="lineCov">   12661607 :   int seen_specialization_p = 0;</span>
<span class="lineNum">     261 </span><span class="lineCov">   12661607 :   int innermost_specialization_p = 0;</span>
<span class="lineNum">     262 </span><span class="lineCov">   12661607 :   cp_binding_level *b;</span>
<span class="lineNum">     263 </span>            : 
<span class="lineNum">     264 </span>            :   /* Scan through the template parameter scopes.  */
<span class="lineNum">     265 </span><span class="lineCov">   12661607 :   for (b = current_binding_level;</span>
<span class="lineNum">     266 </span><span class="lineCov">   14952125 :        b-&gt;kind == sk_template_parms;</span>
<span class="lineNum">     267 </span><span class="lineCov">    2290518 :        b = b-&gt;level_chain)</span>
<span class="lineNum">     268 </span>            :     {
<span class="lineNum">     269 </span>            :       /* If we see a specialization scope inside a parameter scope,
<span class="lineNum">     270 </span>            :          then something is wrong.  That corresponds to a declaration
<span class="lineNum">     271 </span>            :          like:
<span class="lineNum">     272 </span>            : 
<span class="lineNum">     273 </span>            :             template &lt;class T&gt; template &lt;&gt; ...
<span class="lineNum">     274 </span>            : 
<span class="lineNum">     275 </span>            :          which is always invalid since [temp.expl.spec] forbids the
<span class="lineNum">     276 </span>            :          specialization of a class member template if the enclosing
<span class="lineNum">     277 </span>            :          class templates are not explicitly specialized as well.  */
<span class="lineNum">     278 </span><span class="lineCov">    2290518 :       if (b-&gt;explicit_spec_p)</span>
<span class="lineNum">     279 </span>            :         {
<span class="lineNum">     280 </span><span class="lineCov">      52194 :           if (n_template_parm_scopes == 0)</span>
<span class="lineNum">     281 </span>            :             innermost_specialization_p = 1;
<span class="lineNum">     282 </span>            :           else
<span class="lineNum">     283 </span><span class="lineCov">        808 :             seen_specialization_p = 1;</span>
<span class="lineNum">     284 </span>            :         }
<span class="lineNum">     285 </span><span class="lineCov">    2238324 :       else if (seen_specialization_p == 1)</span>
<span class="lineNum">     286 </span>            :         return tsk_invalid_member_spec;
<span class="lineNum">     287 </span>            : 
<span class="lineNum">     288 </span><span class="lineCov">    2290518 :       ++n_template_parm_scopes;</span>
<span class="lineNum">     289 </span>            :     }
<span class="lineNum">     290 </span>            : 
<span class="lineNum">     291 </span>            :   /* Handle explicit instantiations.  */
<span class="lineNum">     292 </span><span class="lineCov">   12661607 :   if (processing_explicit_instantiation)</span>
<span class="lineNum">     293 </span>            :     {
<span class="lineNum">     294 </span><span class="lineCov">     106178 :       if (n_template_parm_scopes != 0)</span>
<span class="lineNum">     295 </span>            :         /* We've seen a template parameter list during an explicit
<span class="lineNum">     296 </span>            :            instantiation.  For example:
<span class="lineNum">     297 </span>            : 
<span class="lineNum">     298 </span>            :              template &lt;class T&gt; template void f(int);
<span class="lineNum">     299 </span>            : 
<span class="lineNum">     300 </span>            :            This is erroneous.  */
<span class="lineNum">     301 </span>            :         return tsk_invalid_expl_inst;
<span class="lineNum">     302 </span>            :       else
<span class="lineNum">     303 </span><span class="lineCov">     106178 :         return tsk_expl_inst;</span>
<span class="lineNum">     304 </span>            :     }
<span class="lineNum">     305 </span>            : 
<span class="lineNum">     306 </span><span class="lineCov">   12555429 :   if (n_template_parm_scopes &lt; n_class_scopes)</span>
<span class="lineNum">     307 </span>            :     /* We've not seen enough template headers to match all the
<span class="lineNum">     308 </span>            :        specialized classes present.  For example:
<span class="lineNum">     309 </span>            : 
<span class="lineNum">     310 </span>            :          template &lt;class T&gt; void R&lt;T&gt;::S&lt;T&gt;::f(int);
<span class="lineNum">     311 </span>            : 
<span class="lineNum">     312 </span>            :        This is invalid; there needs to be one set of template
<span class="lineNum">     313 </span>            :        parameters for each class.  */
<span class="lineNum">     314 </span>            :     return tsk_insufficient_parms;
<span class="lineNum">     315 </span><span class="lineCov">   12555429 :   else if (n_template_parm_scopes == n_class_scopes)</span>
<span class="lineNum">     316 </span>            :     /* We're processing a non-template declaration (even though it may
<span class="lineNum">     317 </span>            :        be a member of a template class.)  For example:
<span class="lineNum">     318 </span>            : 
<span class="lineNum">     319 </span>            :          template &lt;class T&gt; void S&lt;T&gt;::f(int);
<span class="lineNum">     320 </span>            : 
<span class="lineNum">     321 </span>            :        The `class T' matches the `S&lt;T&gt;', leaving no template headers
<span class="lineNum">     322 </span>            :        corresponding to the `f'.  */
<span class="lineNum">     323 </span>            :     return tsk_none;
<span class="lineNum">     324 </span><span class="lineCov">    1889313 :   else if (n_template_parm_scopes &gt; n_class_scopes + 1)</span>
<span class="lineNum">     325 </span>            :     /* We've got too many template headers.  For example:
<span class="lineNum">     326 </span>            : 
<span class="lineNum">     327 </span>            :          template &lt;&gt; template &lt;class T&gt; void f (T);
<span class="lineNum">     328 </span>            : 
<span class="lineNum">     329 </span>            :        There need to be more enclosing classes.  */
<span class="lineNum">     330 </span>            :     return tsk_excessive_parms;
<span class="lineNum">     331 </span>            :   else
<span class="lineNum">     332 </span>            :     /* This must be a template.  It's of the form:
<span class="lineNum">     333 </span>            : 
<span class="lineNum">     334 </span>            :          template &lt;class T&gt; template &lt;class U&gt; void S&lt;T&gt;::f(U);
<span class="lineNum">     335 </span>            : 
<span class="lineNum">     336 </span>            :        This is a specialization if the innermost level was a
<span class="lineNum">     337 </span>            :        specialization; otherwise it's just a definition of the
<span class="lineNum">     338 </span>            :        template.  */
<span class="lineNum">     339 </span><span class="lineCov">    3767658 :     return innermost_specialization_p ? tsk_expl_spec : tsk_template;</span>
<span class="lineNum">     340 </span>            : }
<span class="lineNum">     341 </span>            : 
<span class="lineNum">     342 </span>            : /* Exit the current scope.  */
<a name="343"><span class="lineNum">     343 </span>            : </a>
<span class="lineNum">     344 </span>            : void
<span class="lineNum">     345 </span><span class="lineCov">    4694209 : finish_scope (void)</span>
<span class="lineNum">     346 </span>            : {
<span class="lineNum">     347 </span><span class="lineCov">    4694209 :   poplevel (0, 0, 0);</span>
<span class="lineNum">     348 </span><span class="lineCov">    4694209 : }</span>
<span class="lineNum">     349 </span>            : 
<span class="lineNum">     350 </span>            : /* When a label goes out of scope, check to see if that label was used
<span class="lineNum">     351 </span>            :    in a valid manner, and issue any appropriate warnings or errors.  */
<a name="352"><span class="lineNum">     352 </span>            : </a>
<span class="lineNum">     353 </span>            : static void
<span class="lineNum">     354 </span><span class="lineCov">       1146 : check_label_used (tree label)</span>
<span class="lineNum">     355 </span>            : {
<span class="lineNum">     356 </span><span class="lineCov">       1146 :   if (!processing_template_decl)</span>
<span class="lineNum">     357 </span>            :     {
<span class="lineNum">     358 </span><span class="lineCov">        961 :       if (DECL_INITIAL (label) == NULL_TREE)</span>
<span class="lineNum">     359 </span>            :         {
<span class="lineNum">     360 </span><span class="lineCov">          6 :           location_t location;</span>
<span class="lineNum">     361 </span>            : 
<span class="lineNum">     362 </span><span class="lineCov">          6 :           error (&quot;label %q+D used but not defined&quot;, label);</span>
<span class="lineNum">     363 </span><span class="lineCov">          6 :           location = input_location;</span>
<span class="lineNum">     364 </span>            :             /* FIXME want (LOCATION_FILE (input_location), (line)0) */
<span class="lineNum">     365 </span>            :           /* Avoid crashing later.  */
<span class="lineNum">     366 </span><span class="lineCov">          6 :           define_label (location, DECL_NAME (label));</span>
<span class="lineNum">     367 </span>            :         }
<span class="lineNum">     368 </span>            :       else 
<span class="lineNum">     369 </span><span class="lineCov">        955 :         warn_for_unused_label (label);</span>
<span class="lineNum">     370 </span>            :     }
<span class="lineNum">     371 </span><span class="lineCov">       1146 : }</span>
<span class="lineNum">     372 </span>            : 
<span class="lineNum">     373 </span>            : /* Helper function to sort named label entries in a vector by DECL_UID.  */
<a name="374"><span class="lineNum">     374 </span>            : </a>
<span class="lineNum">     375 </span>            : static int
<span class="lineNum">     376 </span><span class="lineCov">       2551 : sort_labels (const void *a, const void *b)</span>
<span class="lineNum">     377 </span>            : {
<span class="lineNum">     378 </span><span class="lineCov">       2551 :   tree label1 = *(tree const *) a;</span>
<span class="lineNum">     379 </span><span class="lineCov">       2551 :   tree label2 = *(tree const *) b;</span>
<span class="lineNum">     380 </span>            : 
<span class="lineNum">     381 </span>            :   /* DECL_UIDs can never be equal.  */
<span class="lineNum">     382 </span><span class="lineCov">       2551 :   return DECL_UID (label1) &gt; DECL_UID (label2) ? -1 : +1;</span>
<span class="lineNum">     383 </span>            : }
<span class="lineNum">     384 </span>            : 
<span class="lineNum">     385 </span>            : /* At the end of a function, all labels declared within the function
<span class="lineNum">     386 </span>            :    go out of scope.  BLOCK is the top-level block for the
<span class="lineNum">     387 </span>            :    function.  */
<a name="388"><span class="lineNum">     388 </span>            : </a>
<span class="lineNum">     389 </span>            : static void
<span class="lineNum">     390 </span><span class="lineCov">   15923020 : pop_labels (tree block)</span>
<span class="lineNum">     391 </span>            : {
<span class="lineNum">     392 </span><span class="lineCov">   15923020 :   if (!named_labels)</span>
<span class="lineNum">     393 </span><span class="lineCov">   15922250 :     return;</span>
<span class="lineNum">     394 </span>            : 
<span class="lineNum">     395 </span>            :   /* We need to add the labels to the block chain, so debug
<span class="lineNum">     396 </span>            :      information is emitted.  But, we want the order to be stable so
<span class="lineNum">     397 </span>            :      need to sort them first.  Otherwise the debug output could be
<span class="lineNum">     398 </span>            :      randomly ordered.  I guess it's mostly stable, unless the hash
<span class="lineNum">     399 </span>            :      table implementation changes.  */
<span class="lineNum">     400 </span><span class="lineCov">       3080 :   auto_vec&lt;tree, 32&gt; labels (named_labels-&gt;elements ());</span>
<span class="lineNum">     401 </span><span class="lineCov">        770 :   hash_table&lt;named_label_hash&gt;::iterator end (named_labels-&gt;end ());</span>
<span class="lineNum">     402 </span><span class="lineCov">        770 :   for (hash_table&lt;named_label_hash&gt;::iterator iter</span>
<span class="lineNum">     403 </span><span class="lineCov">       2665 :          (named_labels-&gt;begin ()); iter != end; ++iter)</span>
<span class="lineNum">     404 </span>            :     {
<span class="lineNum">     405 </span><span class="lineCov">       1125 :       named_label_entry *ent = *iter;</span>
<span class="lineNum">     406 </span>            : 
<span class="lineNum">     407 </span><span class="lineCov">       1125 :       gcc_checking_assert (!ent-&gt;outer);</span>
<span class="lineNum">     408 </span><span class="lineCov">       1125 :       if (ent-&gt;label_decl)</span>
<span class="lineNum">     409 </span><span class="lineCov">       1083 :         labels.quick_push (ent-&gt;label_decl);</span>
<span class="lineNum">     410 </span><span class="lineCov">       1125 :       ggc_free (ent);</span>
<span class="lineNum">     411 </span>            :     }
<span class="lineNum">     412 </span><span class="lineCov">        770 :   named_labels = NULL;</span>
<span class="lineNum">     413 </span><span class="lineCov">        770 :   labels.qsort (sort_labels);</span>
<span class="lineNum">     414 </span>            : 
<span class="lineNum">     415 </span><span class="lineCov">       1853 :   while (labels.length ())</span>
<span class="lineNum">     416 </span>            :     {
<span class="lineNum">     417 </span><span class="lineCov">       1083 :       tree label = labels.pop ();</span>
<span class="lineNum">     418 </span>            : 
<span class="lineNum">     419 </span><span class="lineCov">       1083 :       DECL_CHAIN (label) = BLOCK_VARS (block);</span>
<span class="lineNum">     420 </span><span class="lineCov">       1083 :       BLOCK_VARS (block) = label;</span>
<span class="lineNum">     421 </span>            : 
<span class="lineNum">     422 </span><span class="lineCov">       1083 :       check_label_used (label);</span>
<span class="lineNum">     423 </span>            :     }
<span class="lineNum">     424 </span>            : }
<span class="lineNum">     425 </span>            : 
<span class="lineNum">     426 </span>            : /* At the end of a block with local labels, restore the outer definition.  */
<a name="427"><span class="lineNum">     427 </span>            : </a>
<span class="lineNum">     428 </span>            : static void
<span class="lineNum">     429 </span><span class="lineCov">         63 : pop_local_label (tree id, tree label)</span>
<span class="lineNum">     430 </span>            : {
<span class="lineNum">     431 </span><span class="lineCov">         63 :   check_label_used (label);</span>
<span class="lineNum">     432 </span><span class="lineCov">         63 :   named_label_entry **slot = named_labels-&gt;find_slot_with_hash</span>
<span class="lineNum">     433 </span><span class="lineCov">         63 :     (id, IDENTIFIER_HASH_VALUE (id), NO_INSERT);</span>
<span class="lineNum">     434 </span><span class="lineCov">         63 :   named_label_entry *ent = *slot;</span>
<span class="lineNum">     435 </span>            : 
<span class="lineNum">     436 </span><span class="lineCov">         63 :   if (ent-&gt;outer)</span>
<span class="lineNum">     437 </span>            :     ent = ent-&gt;outer;
<span class="lineNum">     438 </span>            :   else
<span class="lineNum">     439 </span>            :     {
<span class="lineNum">     440 </span><span class="lineCov">         54 :       ent = ggc_cleared_alloc&lt;named_label_entry&gt; ();</span>
<span class="lineNum">     441 </span><span class="lineCov">         54 :       ent-&gt;name = id;</span>
<span class="lineNum">     442 </span>            :     }
<span class="lineNum">     443 </span><span class="lineCov">         63 :   *slot = ent;</span>
<span class="lineNum">     444 </span><span class="lineCov">         63 : }</span>
<span class="lineNum">     445 </span>            : 
<span class="lineNum">     446 </span>            : /* The following two routines are used to interface to Objective-C++.
<span class="lineNum">     447 </span>            :    The binding level is purposely treated as an opaque type.  */
<a name="448"><span class="lineNum">     448 </span>            : </a>
<span class="lineNum">     449 </span>            : void *
<span class="lineNum">     450 </span><span class="lineNoCov">          0 : objc_get_current_scope (void)</span>
<span class="lineNum">     451 </span>            : {
<span class="lineNum">     452 </span><span class="lineNoCov">          0 :   return current_binding_level;</span>
<span class="lineNum">     453 </span>            : }
<span class="lineNum">     454 </span>            : 
<span class="lineNum">     455 </span>            : /* The following routine is used by the NeXT-style SJLJ exceptions;
<span class="lineNum">     456 </span>            :    variables get marked 'volatile' so as to not be clobbered by
<span class="lineNum">     457 </span>            :    _setjmp()/_longjmp() calls.  All variables in the current scope,
<span class="lineNum">     458 </span>            :    as well as parent scopes up to (but not including) ENCLOSING_BLK
<span class="lineNum">     459 </span>            :    shall be thusly marked.  */
<a name="460"><span class="lineNum">     460 </span>            : </a>
<span class="lineNum">     461 </span>            : void
<span class="lineNum">     462 </span><span class="lineNoCov">          0 : objc_mark_locals_volatile (void *enclosing_blk)</span>
<span class="lineNum">     463 </span>            : {
<span class="lineNum">     464 </span><span class="lineNoCov">          0 :   cp_binding_level *scope;</span>
<span class="lineNum">     465 </span>            : 
<span class="lineNum">     466 </span><span class="lineNoCov">          0 :   for (scope = current_binding_level;</span>
<span class="lineNum">     467 </span><span class="lineNoCov">          0 :        scope &amp;&amp; scope != enclosing_blk;</span>
<span class="lineNum">     468 </span><span class="lineNoCov">          0 :        scope = scope-&gt;level_chain)</span>
<span class="lineNum">     469 </span>            :     {
<span class="lineNum">     470 </span><span class="lineNoCov">          0 :       tree decl;</span>
<span class="lineNum">     471 </span>            : 
<span class="lineNum">     472 </span><span class="lineNoCov">          0 :       for (decl = scope-&gt;names; decl; decl = TREE_CHAIN (decl))</span>
<span class="lineNum">     473 </span><span class="lineNoCov">          0 :         objc_volatilize_decl (decl);</span>
<span class="lineNum">     474 </span>            : 
<span class="lineNum">     475 </span>            :       /* Do not climb up past the current function.  */
<span class="lineNum">     476 </span><span class="lineNoCov">          0 :       if (scope-&gt;kind == sk_function_parms)</span>
<span class="lineNum">     477 </span>            :         break;
<span class="lineNum">     478 </span>            :     }
<span class="lineNum">     479 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">     480 </span>            : 
<span class="lineNum">     481 </span>            : /* True if B is the level for the condition of a constexpr if.  */
<a name="482"><span class="lineNum">     482 </span>            : </a>
<span class="lineNum">     483 </span>            : static bool
<span class="lineNum">     484 </span><span class="lineNoCov">          0 : level_for_constexpr_if (cp_binding_level *b)</span>
<span class="lineNum">     485 </span>            : {
<span class="lineNum">     486 </span><span class="lineCov">     128103 :   return (b-&gt;kind == sk_cond &amp;&amp; b-&gt;this_entity</span>
<span class="lineNum">     487 </span><span class="lineCov">        107 :           &amp;&amp; TREE_CODE (b-&gt;this_entity) == IF_STMT</span>
<span class="lineNum">     488 </span><span class="lineCov">        321 :           &amp;&amp; IF_STMT_CONSTEXPR_P (b-&gt;this_entity));</span>
<span class="lineNum">     489 </span>            : }
<span class="lineNum">     490 </span>            : 
<span class="lineNum">     491 </span>            : /* Update data for defined and undefined labels when leaving a scope.  */
<a name="492"><span class="lineNum">     492 </span>            : </a>
<span class="lineNum">     493 </span>            : int
<span class="lineNum">     494 </span><span class="lineCov">      22480 : poplevel_named_label_1 (named_label_entry **slot, cp_binding_level *bl)</span>
<span class="lineNum">     495 </span>            : {
<span class="lineNum">     496 </span><span class="lineCov">      22480 :   named_label_entry *ent = *slot;</span>
<span class="lineNum">     497 </span><span class="lineCov">      22480 :   cp_binding_level *obl = bl-&gt;level_chain;</span>
<span class="lineNum">     498 </span>            : 
<span class="lineNum">     499 </span><span class="lineCov">      22480 :   if (ent-&gt;binding_level == bl)</span>
<span class="lineNum">     500 </span>            :     {
<span class="lineNum">     501 </span><span class="lineCov">       1960 :       tree decl;</span>
<span class="lineNum">     502 </span>            : 
<span class="lineNum">     503 </span>            :       /* ENT-&gt;NAMES_IN_SCOPE may contain a mixture of DECLs and
<span class="lineNum">     504 </span>            :          TREE_LISTs representing OVERLOADs, so be careful.  */
<span class="lineNum">     505 </span><span class="lineCov">       3516 :       for (decl = ent-&gt;names_in_scope; decl; decl = (DECL_P (decl)</span>
<span class="lineNum">     506 </span><span class="lineCov">       1556 :                                                      ? DECL_CHAIN (decl)</span>
<span class="lineNum">     507 </span><span class="lineCov">          3 :                                                      : TREE_CHAIN (decl)))</span>
<span class="lineNum">     508 </span><span class="lineCov">       1556 :         if (decl_jump_unsafe (decl))</span>
<span class="lineNum">     509 </span><span class="lineCov">        704 :           vec_safe_push (ent-&gt;bad_decls, decl);</span>
<span class="lineNum">     510 </span>            : 
<span class="lineNum">     511 </span><span class="lineCov">       1960 :       ent-&gt;binding_level = obl;</span>
<span class="lineNum">     512 </span><span class="lineCov">       1960 :       ent-&gt;names_in_scope = obl-&gt;names;</span>
<span class="lineNum">     513 </span><span class="lineCov">       1960 :       switch (bl-&gt;kind)</span>
<span class="lineNum">     514 </span>            :         {
<span class="lineNum">     515 </span><span class="lineCov">         21 :         case sk_try:</span>
<span class="lineNum">     516 </span><span class="lineCov">         21 :           ent-&gt;in_try_scope = true;</span>
<span class="lineNum">     517 </span><span class="lineCov">         21 :           break;</span>
<span class="lineNum">     518 </span><span class="lineCov">         12 :         case sk_catch:</span>
<span class="lineNum">     519 </span><span class="lineCov">         12 :           ent-&gt;in_catch_scope = true;</span>
<span class="lineNum">     520 </span><span class="lineCov">         12 :           break;</span>
<span class="lineNum">     521 </span><span class="lineCov">         75 :         case sk_omp:</span>
<span class="lineNum">     522 </span><span class="lineCov">         75 :           ent-&gt;in_omp_scope = true;</span>
<span class="lineNum">     523 </span><span class="lineCov">         75 :           break;</span>
<span class="lineNum">     524 </span><span class="lineCov">          3 :         case sk_transaction:</span>
<span class="lineNum">     525 </span><span class="lineCov">          3 :           ent-&gt;in_transaction_scope = true;</span>
<span class="lineNum">     526 </span><span class="lineCov">          3 :           break;</span>
<span class="lineNum">     527 </span><span class="lineCov">       1547 :         case sk_block:</span>
<span class="lineNum">     528 </span><span class="lineCov">       1547 :           if (level_for_constexpr_if (bl-&gt;level_chain))</span>
<span class="lineNum">     529 </span><span class="lineCov">         10 :             ent-&gt;in_constexpr_if = true;</span>
<span class="lineNum">     530 </span>            :           break;
<span class="lineNum">     531 </span>            :         default:
<span class="lineNum">     532 </span>            :           break;
<span class="lineNum">     533 </span>            :         }
<span class="lineNum">     534 </span>            :     }
<span class="lineNum">     535 </span><span class="lineCov">      20520 :   else if (ent-&gt;uses)</span>
<span class="lineNum">     536 </span>            :     {
<span class="lineNum">     537 </span>            :       struct named_label_use_entry *use;
<span class="lineNum">     538 </span>            : 
<span class="lineNum">     539 </span><span class="lineCov">       6064 :       for (use = ent-&gt;uses; use ; use = use-&gt;next)</span>
<span class="lineNum">     540 </span><span class="lineCov">       3364 :         if (use-&gt;binding_level == bl)</span>
<span class="lineNum">     541 </span>            :           {
<span class="lineNum">     542 </span><span class="lineCov">       1301 :             use-&gt;binding_level = obl;</span>
<span class="lineNum">     543 </span><span class="lineCov">       1301 :             use-&gt;names_in_scope = obl-&gt;names;</span>
<span class="lineNum">     544 </span><span class="lineCov">       1301 :             if (bl-&gt;kind == sk_omp)</span>
<span class="lineNum">     545 </span><span class="lineCov">          6 :               use-&gt;in_omp_scope = true;</span>
<span class="lineNum">     546 </span>            :           }
<span class="lineNum">     547 </span>            :     }
<span class="lineNum">     548 </span>            : 
<span class="lineNum">     549 </span><span class="lineCov">      22480 :   return 1;</span>
<span class="lineNum">     550 </span>            : }
<span class="lineNum">     551 </span>            : 
<span class="lineNum">     552 </span>            : /* Saved errorcount to avoid -Wunused-but-set-{parameter,variable} warnings
<span class="lineNum">     553 </span>            :    when errors were reported, except for -Werror-unused-but-set-*.  */
<span class="lineNum">     554 </span>            : static int unused_but_set_errorcount;
<span class="lineNum">     555 </span>            : 
<span class="lineNum">     556 </span>            : /* Exit a binding level.
<span class="lineNum">     557 </span>            :    Pop the level off, and restore the state of the identifier-decl mappings
<span class="lineNum">     558 </span>            :    that were in effect when this level was entered.
<span class="lineNum">     559 </span>            : 
<span class="lineNum">     560 </span>            :    If KEEP == 1, this level had explicit declarations, so
<span class="lineNum">     561 </span>            :    and create a &quot;block&quot; (a BLOCK node) for the level
<span class="lineNum">     562 </span>            :    to record its declarations and subblocks for symbol table output.
<span class="lineNum">     563 </span>            : 
<span class="lineNum">     564 </span>            :    If FUNCTIONBODY is nonzero, this level is the body of a function,
<span class="lineNum">     565 </span>            :    so create a block as if KEEP were set and also clear out all
<span class="lineNum">     566 </span>            :    label names.
<span class="lineNum">     567 </span>            : 
<span class="lineNum">     568 </span>            :    If REVERSE is nonzero, reverse the order of decls before putting
<span class="lineNum">     569 </span>            :    them into the BLOCK.  */
<a name="570"><span class="lineNum">     570 </span>            : </a>
<span class="lineNum">     571 </span>            : tree
<span class="lineNum">     572 </span><span class="lineCov">   44177167 : poplevel (int keep, int reverse, int functionbody)</span>
<span class="lineNum">     573 </span>            : {
<span class="lineNum">     574 </span><span class="lineCov">   44177167 :   tree link;</span>
<span class="lineNum">     575 </span>            :   /* The chain of decls was accumulated in reverse order.
<span class="lineNum">     576 </span>            :      Put it into forward order, just for cleanliness.  */
<span class="lineNum">     577 </span><span class="lineCov">   44177167 :   tree decls;</span>
<span class="lineNum">     578 </span><span class="lineCov">   44177167 :   tree subblocks;</span>
<span class="lineNum">     579 </span><span class="lineCov">   44177167 :   tree block;</span>
<span class="lineNum">     580 </span><span class="lineCov">   44177167 :   tree decl;</span>
<span class="lineNum">     581 </span><span class="lineCov">   44177167 :   scope_kind kind;</span>
<span class="lineNum">     582 </span>            : 
<span class="lineNum">     583 </span><span class="lineCov">   44177167 :   bool subtime = timevar_cond_start (TV_NAME_LOOKUP);</span>
<span class="lineNum">     584 </span><span class="lineCov">   44177244 :  restart:</span>
<span class="lineNum">     585 </span>            : 
<span class="lineNum">     586 </span><span class="lineCov">   44177244 :   block = NULL_TREE;</span>
<span class="lineNum">     587 </span>            : 
<span class="lineNum">     588 </span><span class="lineCov">   44177244 :   gcc_assert (current_binding_level-&gt;kind != sk_class</span>
<span class="lineNum">     589 </span>            :               &amp;&amp; current_binding_level-&gt;kind != sk_namespace);
<span class="lineNum">     590 </span>            : 
<span class="lineNum">     591 </span><span class="lineCov">   44177244 :   if (current_binding_level-&gt;kind == sk_cleanup)</span>
<span class="lineNum">     592 </span>            :     functionbody = 0;
<span class="lineNum">     593 </span><span class="lineCov">   44177244 :   subblocks = functionbody &gt;= 0 ? current_binding_level-&gt;blocks : 0;</span>
<span class="lineNum">     594 </span>            : 
<span class="lineNum">     595 </span><span class="lineCov">   44177244 :   gcc_assert (!vec_safe_length (current_binding_level-&gt;class_shadowed));</span>
<span class="lineNum">     596 </span>            : 
<span class="lineNum">     597 </span>            :   /* We used to use KEEP == 2 to indicate that the new block should go
<span class="lineNum">     598 </span>            :      at the beginning of the list of blocks at this binding level,
<span class="lineNum">     599 </span>            :      rather than the end.  This hack is no longer used.  */
<span class="lineNum">     600 </span><span class="lineCov">   44177244 :   gcc_assert (keep == 0 || keep == 1);</span>
<span class="lineNum">     601 </span>            : 
<span class="lineNum">     602 </span><span class="lineCov">   44177244 :   if (current_binding_level-&gt;keep)</span>
<span class="lineNum">     603 </span><span class="lineCov">    2064500 :     keep = 1;</span>
<span class="lineNum">     604 </span>            : 
<span class="lineNum">     605 </span>            :   /* Any uses of undefined labels, and any defined labels, now operate
<span class="lineNum">     606 </span>            :      under constraints of next binding contour.  */
<span class="lineNum">     607 </span><span class="lineCov">   44177244 :   if (cfun &amp;&amp; !functionbody &amp;&amp; named_labels)</span>
<span class="lineNum">     608 </span><span class="lineCov">      17834 :     named_labels-&gt;traverse&lt;cp_binding_level *, poplevel_named_label_1&gt;</span>
<span class="lineNum">     609 </span><span class="lineCov">      17834 :                    (current_binding_level);</span>
<span class="lineNum">     610 </span>            : 
<span class="lineNum">     611 </span>            :   /* Get the decls in the order they were written.
<span class="lineNum">     612 </span>            :      Usually current_binding_level-&gt;names is in reverse order.
<span class="lineNum">     613 </span>            :      But parameter decls were previously put in forward order.  */
<span class="lineNum">     614 </span>            : 
<span class="lineNum">     615 </span><span class="lineCov">   44177244 :   decls = current_binding_level-&gt;names;</span>
<span class="lineNum">     616 </span><span class="lineCov">   44177244 :   if (reverse)</span>
<span class="lineNum">     617 </span>            :     {
<span class="lineNum">     618 </span><span class="lineCov">   22230154 :       decls = nreverse (decls);</span>
<span class="lineNum">     619 </span><span class="lineCov">   22230154 :       current_binding_level-&gt;names = decls;</span>
<span class="lineNum">     620 </span>            :     }
<span class="lineNum">     621 </span>            : 
<span class="lineNum">     622 </span>            :   /* If there were any declarations or structure tags in that level,
<span class="lineNum">     623 </span>            :      or if this level is a function body,
<span class="lineNum">     624 </span>            :      create a BLOCK to record them for the life of this function.  */
<span class="lineNum">     625 </span><span class="lineCov">   44177244 :   block = NULL_TREE;</span>
<span class="lineNum">     626 </span>            :   /* Avoid function body block if possible.  */
<span class="lineNum">     627 </span><span class="lineCov">   44177244 :   if (functionbody &amp;&amp; subblocks &amp;&amp; BLOCK_CHAIN (subblocks) == NULL_TREE)</span>
<span class="lineNum">     628 </span>            :     keep = 0;
<span class="lineNum">     629 </span><span class="lineCov">   40473815 :   else if (keep == 1 || functionbody)</span>
<span class="lineNum">     630 </span><span class="lineCov">   17216116 :     block = make_node (BLOCK);</span>
<span class="lineNum">     631 </span><span class="lineCov">   17216116 :   if (block != NULL_TREE)</span>
<span class="lineNum">     632 </span>            :     {
<span class="lineNum">     633 </span><span class="lineCov">   17216116 :       BLOCK_VARS (block) = decls;</span>
<span class="lineNum">     634 </span><span class="lineCov">   34432232 :       BLOCK_SUBBLOCKS (block) = subblocks;</span>
<span class="lineNum">     635 </span>            :     }
<span class="lineNum">     636 </span>            : 
<span class="lineNum">     637 </span>            :   /* In each subblock, record that this is its superior.  */
<span class="lineNum">     638 </span><span class="lineCov">   44177244 :   if (keep &gt;= 0)</span>
<span class="lineNum">     639 </span><span class="lineCov">   49173770 :     for (link = subblocks; link; link = BLOCK_CHAIN (link))</span>
<span class="lineNum">     640 </span><span class="lineCov">    4996526 :       BLOCK_SUPERCONTEXT (link) = block;</span>
<span class="lineNum">     641 </span>            : 
<span class="lineNum">     642 </span>            :   /* Before we remove the declarations first check for unused variables.  */
<span class="lineNum">     643 </span><span class="lineCov">   44177244 :   if ((warn_unused_variable || warn_unused_but_set_variable)</span>
<span class="lineNum">     644 </span><span class="lineCov">    3954420 :       &amp;&amp; current_binding_level-&gt;kind != sk_template_parms</span>
<span class="lineNum">     645 </span><span class="lineCov">    3360961 :       &amp;&amp; !processing_template_decl)</span>
<span class="lineNum">     646 </span><span class="lineCov">    4093882 :     for (tree d = get_local_decls (); d; d = TREE_CHAIN (d))</span>
<span class="lineNum">     647 </span>            :       {
<span class="lineNum">     648 </span>            :         /* There are cases where D itself is a TREE_LIST.  See in
<span class="lineNum">     649 </span>            :            push_local_binding where the list of decls returned by
<span class="lineNum">     650 </span>            :            getdecls is built.  */
<span class="lineNum">     651 </span><span class="lineCov">    2114982 :         decl = TREE_CODE (d) == TREE_LIST ? TREE_VALUE (d) : d;</span>
<span class="lineNum">     652 </span>            : 
<span class="lineNum">     653 </span><span class="lineCov">    2114982 :         tree type = TREE_TYPE (decl);</span>
<span class="lineNum">     654 </span><span class="lineCov">    2114982 :         if (VAR_P (decl)</span>
<span class="lineNum">     655 </span><span class="lineCov">     185070 :             &amp;&amp; (! TREE_USED (decl) || !DECL_READ_P (decl))</span>
<span class="lineNum">     656 </span><span class="lineCov">        730 :             &amp;&amp; ! DECL_IN_SYSTEM_HEADER (decl)</span>
<span class="lineNum">     657 </span>            :             /* For structured bindings, consider only real variables, not
<span class="lineNum">     658 </span>            :                subobjects.  */
<span class="lineNum">     659 </span><span class="lineCov">        516 :             &amp;&amp; (DECL_DECOMPOSITION_P (decl) ? !DECL_DECOMP_BASE (decl)</span>
<span class="lineNum">     660 </span><span class="lineCov">        483 :                 : (DECL_NAME (decl) &amp;&amp; !DECL_ARTIFICIAL (decl)))</span>
<span class="lineNum">     661 </span><span class="lineCov">        482 :             &amp;&amp; type != error_mark_node</span>
<span class="lineNum">     662 </span><span class="lineCov">    2115974 :             &amp;&amp; (!CLASS_TYPE_P (type)</span>
<span class="lineNum">     663 </span><span class="lineCov">         64 :                 || !TYPE_HAS_NONTRIVIAL_DESTRUCTOR (type)</span>
<span class="lineNum">     664 </span><span class="lineCov">          3 :                 || lookup_attribute (&quot;warn_unused&quot;,</span>
<span class="lineNum">     665 </span><span class="lineCov">          3 :                                      TYPE_ATTRIBUTES (TREE_TYPE (decl)))))</span>
<span class="lineNum">     666 </span>            :           {
<span class="lineNum">     667 </span><span class="lineCov">        476 :             if (! TREE_USED (decl))</span>
<span class="lineNum">     668 </span>            :               {
<span class="lineNum">     669 </span><span class="lineCov">        341 :                 if (!DECL_NAME (decl) &amp;&amp; DECL_DECOMPOSITION_P (decl))</span>
<span class="lineNum">     670 </span><span class="lineCov">          2 :                   warning_at (DECL_SOURCE_LOCATION (decl),</span>
<span class="lineNum">     671 </span>            :                               OPT_Wunused_variable,
<span class="lineNum">     672 </span>            :                               &quot;unused structured binding declaration&quot;);
<span class="lineNum">     673 </span>            :                 else
<span class="lineNum">     674 </span><span class="lineCov">        680 :                   warning_at (DECL_SOURCE_LOCATION (decl),</span>
<span class="lineNum">     675 </span>            :                               OPT_Wunused_variable, &quot;unused variable %qD&quot;, decl);
<span class="lineNum">     676 </span>            :               }
<span class="lineNum">     677 </span><span class="lineCov">        135 :             else if (DECL_CONTEXT (decl) == current_function_decl</span>
<span class="lineNum">     678 </span>            :                      // For -Wunused-but-set-variable leave references alone.
<span class="lineNum">     679 </span><span class="lineCov">        117 :                      &amp;&amp; !TYPE_REF_P (TREE_TYPE (decl))</span>
<span class="lineNum">     680 </span><span class="lineCov">        252 :                      &amp;&amp; errorcount == unused_but_set_errorcount)</span>
<span class="lineNum">     681 </span>            :               {
<span class="lineNum">     682 </span><span class="lineCov">        216 :                 if (!DECL_NAME (decl) &amp;&amp; DECL_DECOMPOSITION_P (decl))</span>
<span class="lineNum">     683 </span><span class="lineCov">          8 :                   warning_at (DECL_SOURCE_LOCATION (decl),</span>
<span class="lineNum">     684 </span>            :                               OPT_Wunused_but_set_variable, &quot;structured &quot;
<span class="lineNum">     685 </span>            :                               &quot;binding declaration set but not used&quot;);
<span class="lineNum">     686 </span>            :                 else
<span class="lineNum">     687 </span><span class="lineCov">        208 :                   warning_at (DECL_SOURCE_LOCATION (decl),</span>
<span class="lineNum">     688 </span>            :                               OPT_Wunused_but_set_variable,
<span class="lineNum">     689 </span>            :                               &quot;variable %qD set but not used&quot;, decl);
<span class="lineNum">     690 </span><span class="lineCov">        108 :                 unused_but_set_errorcount = errorcount;</span>
<span class="lineNum">     691 </span>            :               }
<span class="lineNum">     692 </span>            :           }
<span class="lineNum">     693 </span>            :       }
<span class="lineNum">     694 </span>            : 
<span class="lineNum">     695 </span>            :   /* Remove declarations for all the DECLs in this level.  */
<span class="lineNum">     696 </span><span class="lineCov">   88435656 :   for (link = decls; link; link = TREE_CHAIN (link))</span>
<span class="lineNum">     697 </span>            :     {
<span class="lineNum">     698 </span><span class="lineCov">   44258412 :       decl = TREE_CODE (link) == TREE_LIST ? TREE_VALUE (link) : link;</span>
<span class="lineNum">     699 </span><span class="lineCov">   88516824 :       tree name = OVL_NAME (decl);</span>
<span class="lineNum">     700 </span>            : 
<span class="lineNum">     701 </span>            :       /* Remove the binding.  */
<span class="lineNum">     702 </span><span class="lineCov">   44258412 :       if (TREE_CODE (decl) == LABEL_DECL)</span>
<span class="lineNum">     703 </span><span class="lineCov">         63 :         pop_local_label (name, decl);</span>
<span class="lineNum">     704 </span>            :       else
<span class="lineNum">     705 </span><span class="lineCov">   44258349 :         pop_local_binding (name, decl);</span>
<span class="lineNum">     706 </span>            :     }
<span class="lineNum">     707 </span>            : 
<span class="lineNum">     708 </span>            :   /* Restore the IDENTIFIER_TYPE_VALUEs.  */
<span class="lineNum">     709 </span><span class="lineCov">   44177244 :   for (link = current_binding_level-&gt;type_shadowed;</span>
<span class="lineNum">     710 </span><span class="lineCov">   55655174 :        link; link = TREE_CHAIN (link))</span>
<span class="lineNum">     711 </span><span class="lineCov">   11477930 :     SET_IDENTIFIER_TYPE_VALUE (TREE_PURPOSE (link), TREE_VALUE (link));</span>
<span class="lineNum">     712 </span>            : 
<span class="lineNum">     713 </span>            :   /* There may be OVERLOADs (wrapped in TREE_LISTs) on the BLOCK_VARs
<span class="lineNum">     714 </span>            :      list if a `using' declaration put them there.  The debugging
<span class="lineNum">     715 </span>            :      back ends won't understand OVERLOAD, so we remove them here.
<span class="lineNum">     716 </span>            :      Because the BLOCK_VARS are (temporarily) shared with
<span class="lineNum">     717 </span>            :      CURRENT_BINDING_LEVEL-&gt;NAMES we must do this fixup after we have
<span class="lineNum">     718 </span>            :      popped all the bindings.  Also remove undeduced 'auto' decls,
<span class="lineNum">     719 </span>            :      which LTO doesn't understand, and can't have been used by anything.  */
<span class="lineNum">     720 </span><span class="lineCov">   44177244 :   if (block)</span>
<span class="lineNum">     721 </span>            :     {
<span class="lineNum">     722 </span><span class="lineCov">   17216116 :       tree* d;</span>
<span class="lineNum">     723 </span>            : 
<span class="lineNum">     724 </span><span class="lineCov">   42900135 :       for (d = &amp;BLOCK_VARS (block); *d; )</span>
<span class="lineNum">     725 </span>            :         {
<span class="lineNum">     726 </span><span class="lineCov">   25684019 :           if (TREE_CODE (*d) == TREE_LIST</span>
<span class="lineNum">     727 </span><span class="lineCov">   25684019 :               || (!processing_template_decl</span>
<span class="lineNum">     728 </span><span class="lineCov">   17751543 :                   &amp;&amp; undeduced_auto_decl (*d)))</span>
<span class="lineNum">     729 </span><span class="lineCov">      26123 :             *d = TREE_CHAIN (*d);</span>
<span class="lineNum">     730 </span>            :           else
<span class="lineNum">     731 </span><span class="lineCov">   25657896 :             d = &amp;DECL_CHAIN (*d);</span>
<span class="lineNum">     732 </span>            :         }
<span class="lineNum">     733 </span>            :     }
<span class="lineNum">     734 </span>            : 
<span class="lineNum">     735 </span>            :   /* If the level being exited is the top level of a function,
<span class="lineNum">     736 </span>            :      check over all the labels.  */
<span class="lineNum">     737 </span><span class="lineCov">   44177244 :   if (functionbody)</span>
<span class="lineNum">     738 </span>            :     {
<span class="lineNum">     739 </span><span class="lineCov">   15923020 :       if (block)</span>
<span class="lineNum">     740 </span>            :         {
<span class="lineNum">     741 </span>            :           /* Since this is the top level block of a function, the vars are
<span class="lineNum">     742 </span>            :              the function's parameters.  Don't leave them in the BLOCK
<span class="lineNum">     743 </span>            :              because they are found in the FUNCTION_DECL instead.  */
<span class="lineNum">     744 </span><span class="lineCov">   12219591 :           BLOCK_VARS (block) = 0;</span>
<span class="lineNum">     745 </span><span class="lineCov">   12219591 :           pop_labels (block);</span>
<span class="lineNum">     746 </span>            :         }
<span class="lineNum">     747 </span>            :       else
<span class="lineNum">     748 </span><span class="lineCov">    3703429 :         pop_labels (subblocks);</span>
<span class="lineNum">     749 </span>            :     }
<span class="lineNum">     750 </span>            : 
<span class="lineNum">     751 </span><span class="lineCov">   44177244 :   kind = current_binding_level-&gt;kind;</span>
<span class="lineNum">     752 </span><span class="lineCov">   44177244 :   if (kind == sk_cleanup)</span>
<span class="lineNum">     753 </span>            :     {
<span class="lineNum">     754 </span><span class="lineCov">         77 :       tree stmt;</span>
<span class="lineNum">     755 </span>            : 
<span class="lineNum">     756 </span>            :       /* If this is a temporary binding created for a cleanup, then we'll
<span class="lineNum">     757 </span>            :          have pushed a statement list level.  Pop that, create a new
<span class="lineNum">     758 </span>            :          BIND_EXPR for the block, and insert it into the stream.  */
<span class="lineNum">     759 </span><span class="lineCov">         77 :       stmt = pop_stmt_list (current_binding_level-&gt;statement_list);</span>
<span class="lineNum">     760 </span><span class="lineCov">         77 :       stmt = c_build_bind_expr (input_location, block, stmt);</span>
<span class="lineNum">     761 </span><span class="lineCov">         77 :       add_stmt (stmt);</span>
<span class="lineNum">     762 </span>            :     }
<span class="lineNum">     763 </span>            : 
<span class="lineNum">     764 </span><span class="lineCov">   44177244 :   leave_scope ();</span>
<span class="lineNum">     765 </span><span class="lineCov">   44177244 :   if (functionbody)</span>
<span class="lineNum">     766 </span>            :     {
<span class="lineNum">     767 </span>            :       /* The current function is being defined, so its DECL_INITIAL
<span class="lineNum">     768 </span>            :          should be error_mark_node.  */
<span class="lineNum">     769 </span><span class="lineCov">   15923020 :       gcc_assert (DECL_INITIAL (current_function_decl) == error_mark_node);</span>
<span class="lineNum">     770 </span><span class="lineCov">   19626449 :       DECL_INITIAL (current_function_decl) = block ? block : subblocks;</span>
<span class="lineNum">     771 </span><span class="lineCov">   15923020 :       if (subblocks)</span>
<span class="lineNum">     772 </span>            :         {
<span class="lineNum">     773 </span><span class="lineCov">    3703586 :           if (FUNCTION_NEEDS_BODY_BLOCK (current_function_decl))</span>
<span class="lineNum">     774 </span>            :             {
<span class="lineNum">     775 </span><span class="lineCov">    2049967 :               if (BLOCK_SUBBLOCKS (subblocks))</span>
<span class="lineNum">     776 </span><span class="lineCov">     216724 :                 BLOCK_OUTER_CURLY_BRACE_P (BLOCK_SUBBLOCKS (subblocks)) = 1;</span>
<span class="lineNum">     777 </span>            :             }
<span class="lineNum">     778 </span>            :           else
<span class="lineNum">     779 </span><span class="lineCov">    1653619 :             BLOCK_OUTER_CURLY_BRACE_P (subblocks) = 1;</span>
<span class="lineNum">     780 </span>            :         }
<span class="lineNum">     781 </span>            :     }
<span class="lineNum">     782 </span><span class="lineCov">   28254224 :   else if (block)</span>
<span class="lineNum">     783 </span><span class="lineCov">    4996525 :     current_binding_level-&gt;blocks</span>
<span class="lineNum">     784 </span><span class="lineCov">    9993050 :       = block_chainon (current_binding_level-&gt;blocks, block);</span>
<span class="lineNum">     785 </span>            : 
<span class="lineNum">     786 </span>            :   /* If we did not make a block for the level just exited,
<span class="lineNum">     787 </span>            :      any blocks made for inner levels
<span class="lineNum">     788 </span>            :      (since they cannot be recorded as subblocks in that level)
<span class="lineNum">     789 </span>            :      must be carried forward so they will later become subblocks
<span class="lineNum">     790 </span>            :      of something else.  */
<span class="lineNum">     791 </span><span class="lineCov">   23257699 :   else if (subblocks)</span>
<span class="lineNum">     792 </span><span class="lineCov">          3 :     current_binding_level-&gt;blocks</span>
<span class="lineNum">     793 </span><span class="lineCov">          6 :       = block_chainon (current_binding_level-&gt;blocks, subblocks);</span>
<span class="lineNum">     794 </span>            : 
<span class="lineNum">     795 </span>            :   /* Each and every BLOCK node created here in `poplevel' is important
<span class="lineNum">     796 </span>            :      (e.g. for proper debugging information) so if we created one
<span class="lineNum">     797 </span>            :      earlier, mark it as &quot;used&quot;.  */
<span class="lineNum">     798 </span><span class="lineCov">   44177244 :   if (block)</span>
<span class="lineNum">     799 </span><span class="lineCov">   17216116 :     TREE_USED (block) = 1;</span>
<span class="lineNum">     800 </span>            : 
<span class="lineNum">     801 </span>            :   /* All temporary bindings created for cleanups are popped silently.  */
<span class="lineNum">     802 </span><span class="lineCov">   44177244 :   if (kind == sk_cleanup)</span>
<span class="lineNum">     803 </span>            :     goto restart;
<span class="lineNum">     804 </span>            : 
<span class="lineNum">     805 </span><span class="lineCov">   44177167 :   timevar_cond_stop (TV_NAME_LOOKUP, subtime);</span>
<span class="lineNum">     806 </span><span class="lineCov">   44177167 :   return block;</span>
<span class="lineNum">     807 </span>            : }
<span class="lineNum">     808 </span>            : 
<span class="lineNum">     809 </span>            : /* Call wrapup_globals_declarations for the globals in NAMESPACE.  */
<span class="lineNum">     810 </span>            : /* Diagnose odr-used extern inline variables without definitions
<span class="lineNum">     811 </span>            :    in the current TU.  */
<a name="812"><span class="lineNum">     812 </span>            : </a>
<span class="lineNum">     813 </span>            : int
<span class="lineNum">     814 </span><span class="lineCov">      78883 : wrapup_namespace_globals ()</span>
<span class="lineNum">     815 </span>            : {
<span class="lineNum">     816 </span><span class="lineCov">      78883 :   if (vec&lt;tree, va_gc&gt; *statics = static_decls)</span>
<span class="lineNum">     817 </span>            :     {
<span class="lineNum">     818 </span>            :       tree decl;
<span class="lineNum">     819 </span>            :       unsigned int i;
<span class="lineNum">     820 </span><span class="lineCov">    6297019 :       FOR_EACH_VEC_ELT (*statics, i, decl)</span>
<span class="lineNum">     821 </span>            :         {
<span class="lineNum">     822 </span><span class="lineCov">    6232965 :           if (warn_unused_function</span>
<span class="lineNum">     823 </span><span class="lineCov">     709049 :               &amp;&amp; TREE_CODE (decl) == FUNCTION_DECL</span>
<span class="lineNum">     824 </span><span class="lineCov">     519410 :               &amp;&amp; DECL_INITIAL (decl) == 0</span>
<span class="lineNum">     825 </span><span class="lineCov">        208 :               &amp;&amp; DECL_EXTERNAL (decl)</span>
<span class="lineNum">     826 </span><span class="lineCov">        104 :               &amp;&amp; !TREE_PUBLIC (decl)</span>
<span class="lineNum">     827 </span><span class="lineCov">         12 :               &amp;&amp; !DECL_ARTIFICIAL (decl)</span>
<span class="lineNum">     828 </span><span class="lineCov">         12 :               &amp;&amp; !DECL_FRIEND_PSEUDO_TEMPLATE_INSTANTIATION (decl)</span>
<span class="lineNum">     829 </span><span class="lineCov">    6232968 :               &amp;&amp; !TREE_NO_WARNING (decl))</span>
<span class="lineNum">     830 </span><span class="lineCov">          3 :             warning_at (DECL_SOURCE_LOCATION (decl),</span>
<span class="lineNum">     831 </span>            :                         OPT_Wunused_function,
<span class="lineNum">     832 </span>            :                         &quot;%qF declared %&lt;static%&gt; but never defined&quot;, decl);
<span class="lineNum">     833 </span>            : 
<span class="lineNum">     834 </span><span class="lineCov">    6232965 :           if (VAR_P (decl)</span>
<span class="lineNum">     835 </span><span class="lineCov">    2128183 :               &amp;&amp; DECL_EXTERNAL (decl)</span>
<span class="lineNum">     836 </span><span class="lineCov">    4381134 :               &amp;&amp; DECL_INLINE_VAR_P (decl)</span>
<span class="lineNum">     837 </span><span class="lineCov">    6232992 :               &amp;&amp; DECL_ODR_USED (decl))</span>
<span class="lineNum">     838 </span><span class="lineCov">          2 :             error_at (DECL_SOURCE_LOCATION (decl),</span>
<span class="lineNum">     839 </span>            :                       &quot;odr-used inline variable %qD is not defined&quot;, decl);
<span class="lineNum">     840 </span>            :         }
<span class="lineNum">     841 </span>            : 
<span class="lineNum">     842 </span>            :       /* Clear out the list, so we don't rescan next time.  */
<span class="lineNum">     843 </span><span class="lineCov">      64054 :       static_decls = NULL;</span>
<span class="lineNum">     844 </span>            : 
<span class="lineNum">     845 </span>            :       /* Write out any globals that need to be output.  */
<span class="lineNum">     846 </span><span class="lineCov">      64054 :       return wrapup_global_declarations (statics-&gt;address (),</span>
<span class="lineNum">     847 </span><span class="lineCov">      64054 :                                          statics-&gt;length ());</span>
<span class="lineNum">     848 </span>            :     }
<span class="lineNum">     849 </span>            :   return 0;
<span class="lineNum">     850 </span>            : }
<span class="lineNum">     851 </span>            : 
<span class="lineNum">     852 </span>            : /* In C++, you don't have to write `struct S' to refer to `S'; you
<span class="lineNum">     853 </span>            :    can just use `S'.  We accomplish this by creating a TYPE_DECL as
<span class="lineNum">     854 </span>            :    if the user had written `typedef struct S S'.  Create and return
<span class="lineNum">     855 </span>            :    the TYPE_DECL for TYPE.  */
<a name="856"><span class="lineNum">     856 </span>            : </a>
<span class="lineNum">     857 </span>            : tree
<span class="lineNum">     858 </span><span class="lineCov">   14101165 : create_implicit_typedef (tree name, tree type)</span>
<span class="lineNum">     859 </span>            : {
<span class="lineNum">     860 </span><span class="lineCov">   14101165 :   tree decl;</span>
<span class="lineNum">     861 </span>            : 
<span class="lineNum">     862 </span><span class="lineCov">   14101165 :   decl = build_decl (input_location, TYPE_DECL, name, type);</span>
<span class="lineNum">     863 </span><span class="lineCov">   14101165 :   DECL_ARTIFICIAL (decl) = 1;</span>
<span class="lineNum">     864 </span>            :   /* There are other implicit type declarations, like the one *within*
<span class="lineNum">     865 </span>            :      a class that allows you to write `S::S'.  We must distinguish
<span class="lineNum">     866 </span>            :      amongst these.  */
<span class="lineNum">     867 </span><span class="lineCov">   14101165 :   SET_DECL_IMPLICIT_TYPEDEF_P (decl);</span>
<span class="lineNum">     868 </span><span class="lineCov">   14101165 :   TYPE_NAME (type) = decl;</span>
<span class="lineNum">     869 </span><span class="lineCov">   14101165 :   TYPE_STUB_DECL (type) = decl;</span>
<span class="lineNum">     870 </span>            : 
<span class="lineNum">     871 </span><span class="lineCov">   14101165 :   return decl;</span>
<span class="lineNum">     872 </span>            : }
<span class="lineNum">     873 </span>            : 
<span class="lineNum">     874 </span>            : /* Remember a local name for name-mangling purposes.  */
<a name="875"><span class="lineNum">     875 </span>            : </a>
<span class="lineNum">     876 </span>            : static void
<span class="lineNum">     877 </span><span class="lineCov">      10350 : push_local_name (tree decl)</span>
<span class="lineNum">     878 </span>            : {
<span class="lineNum">     879 </span><span class="lineCov">      10350 :   size_t i, nelts;</span>
<span class="lineNum">     880 </span><span class="lineCov">      10350 :   tree t, name;</span>
<span class="lineNum">     881 </span>            : 
<span class="lineNum">     882 </span><span class="lineCov">      10350 :   timevar_start (TV_NAME_LOOKUP);</span>
<span class="lineNum">     883 </span>            : 
<span class="lineNum">     884 </span><span class="lineCov">      10350 :   name = DECL_NAME (decl);</span>
<span class="lineNum">     885 </span>            : 
<span class="lineNum">     886 </span><span class="lineCov">      10350 :   nelts = vec_safe_length (local_names);</span>
<span class="lineNum">     887 </span><span class="lineCov">      18362 :   for (i = 0; i &lt; nelts; i++)</span>
<span class="lineNum">     888 </span>            :     {
<span class="lineNum">     889 </span><span class="lineCov">       8095 :       t = (*local_names)[i];</span>
<span class="lineNum">     890 </span><span class="lineCov">       8095 :       if (DECL_NAME (t) == name)</span>
<span class="lineNum">     891 </span>            :         {
<span class="lineNum">     892 </span><span class="lineCov">         83 :           retrofit_lang_decl (decl);</span>
<span class="lineNum">     893 </span><span class="lineCov">         83 :           DECL_LANG_SPECIFIC (decl)-&gt;u.base.u2sel = 1;</span>
<span class="lineNum">     894 </span><span class="lineCov">         83 :           if (DECL_DISCRIMINATOR_SET_P (t))</span>
<span class="lineNum">     895 </span><span class="lineCov">        102 :             DECL_DISCRIMINATOR (decl) = DECL_DISCRIMINATOR (t) + 1;</span>
<span class="lineNum">     896 </span>            :           else
<span class="lineNum">     897 </span><span class="lineCov">         32 :             DECL_DISCRIMINATOR (decl) = 1;</span>
<span class="lineNum">     898 </span>            : 
<span class="lineNum">     899 </span><span class="lineCov">         83 :           (*local_names)[i] = decl;</span>
<span class="lineNum">     900 </span><span class="lineCov">         83 :           timevar_stop (TV_NAME_LOOKUP);</span>
<span class="lineNum">     901 </span><span class="lineCov">         83 :           return;</span>
<span class="lineNum">     902 </span>            :         }
<span class="lineNum">     903 </span>            :     }
<span class="lineNum">     904 </span>            : 
<span class="lineNum">     905 </span><span class="lineCov">      10267 :   vec_safe_push (local_names, decl);</span>
<span class="lineNum">     906 </span><span class="lineCov">      10267 :   timevar_stop (TV_NAME_LOOKUP);</span>
<span class="lineNum">     907 </span>            : }
<span class="lineNum">     908 </span>            : 
<span class="lineNum">     909 </span>            : /* Subroutine of duplicate_decls: return truthvalue of whether
<span class="lineNum">     910 </span>            :    or not types of these decls match.
<span class="lineNum">     911 </span>            : 
<span class="lineNum">     912 </span>            :    For C++, we must compare the parameter list so that `int' can match
<span class="lineNum">     913 </span>            :    `int&amp;' in a parameter position, but `int&amp;' is not confused with
<span class="lineNum">     914 </span>            :    `const int&amp;'.  */
<a name="915"><span class="lineNum">     915 </span>            : </a>
<span class="lineNum">     916 </span>            : int
<span class="lineNum">     917 </span><span class="lineCov">   20179221 : decls_match (tree newdecl, tree olddecl, bool record_versions /* = true */)</span>
<span class="lineNum">     918 </span>            : {
<span class="lineNum">     919 </span><span class="lineCov">   20179221 :   int types_match;</span>
<span class="lineNum">     920 </span>            : 
<span class="lineNum">     921 </span><span class="lineCov">   20179221 :   if (newdecl == olddecl)</span>
<span class="lineNum">     922 </span>            :     return 1;
<span class="lineNum">     923 </span>            : 
<span class="lineNum">     924 </span><span class="lineCov">   20116570 :   if (TREE_CODE (newdecl) != TREE_CODE (olddecl))</span>
<span class="lineNum">     925 </span>            :     /* If the two DECLs are not even the same kind of thing, we're not
<span class="lineNum">     926 </span>            :        interested in their types.  */
<span class="lineNum">     927 </span>            :     return 0;
<span class="lineNum">     928 </span>            : 
<span class="lineNum">     929 </span><span class="lineCov">   11791815 :   gcc_assert (DECL_P (newdecl));</span>
<span class="lineNum">     930 </span>            : 
<span class="lineNum">     931 </span><span class="lineCov">   11791815 :   if (TREE_CODE (newdecl) == FUNCTION_DECL)</span>
<span class="lineNum">     932 </span>            :     {
<span class="lineNum">     933 </span><span class="lineCov">    8287635 :       tree f1 = TREE_TYPE (newdecl);</span>
<span class="lineNum">     934 </span><span class="lineCov">    8287635 :       tree f2 = TREE_TYPE (olddecl);</span>
<span class="lineNum">     935 </span><span class="lineCov">    8287635 :       tree p1 = TYPE_ARG_TYPES (f1);</span>
<span class="lineNum">     936 </span><span class="lineCov">    8287635 :       tree p2 = TYPE_ARG_TYPES (f2);</span>
<span class="lineNum">     937 </span><span class="lineCov">    8287635 :       tree r2;</span>
<span class="lineNum">     938 </span>            : 
<span class="lineNum">     939 </span>            :       /* Specializations of different templates are different functions
<span class="lineNum">     940 </span>            :          even if they have the same type.  */
<span class="lineNum">     941 </span><span class="lineCov">    8287635 :       tree t1 = (DECL_USE_TEMPLATE (newdecl)</span>
<span class="lineNum">     942 </span><span class="lineCov">     113314 :                  ? DECL_TI_TEMPLATE (newdecl)</span>
<span class="lineNum">     943 </span><span class="lineCov">    8287635 :                  : NULL_TREE);</span>
<span class="lineNum">     944 </span><span class="lineCov">    8287635 :       tree t2 = (DECL_USE_TEMPLATE (olddecl)</span>
<span class="lineNum">     945 </span><span class="lineCov">     152122 :                  ? DECL_TI_TEMPLATE (olddecl)</span>
<span class="lineNum">     946 </span><span class="lineCov">    8287635 :                  : NULL_TREE);</span>
<span class="lineNum">     947 </span><span class="lineCov">    8287635 :       if (t1 != t2)</span>
<span class="lineNum">     948 </span>            :         return 0;
<span class="lineNum">     949 </span>            : 
<span class="lineNum">     950 </span><span class="lineCov">    8185859 :       if (CP_DECL_CONTEXT (newdecl) != CP_DECL_CONTEXT (olddecl)</span>
<span class="lineNum">     951 </span><span class="lineCov">    8185859 :           &amp;&amp; ! (DECL_EXTERN_C_P (newdecl)</span>
<span class="lineNum">     952 </span><span class="lineCov">       2958 :                 &amp;&amp; DECL_EXTERN_C_P (olddecl)))</span>
<span class="lineNum">     953 </span>            :         return 0;
<span class="lineNum">     954 </span>            : 
<span class="lineNum">     955 </span>            :       /* A new declaration doesn't match a built-in one unless it
<span class="lineNum">     956 </span>            :          is also extern &quot;C&quot;.  */
<span class="lineNum">     957 </span><span class="lineCov">   23390997 :       if (DECL_IS_BUILTIN (olddecl)</span>
<span class="lineNum">     958 </span><span class="lineCov">    7796999 :           &amp;&amp; DECL_EXTERN_C_P (olddecl) &amp;&amp; !DECL_EXTERN_C_P (newdecl))</span>
<span class="lineNum">     959 </span>            :         return 0;
<span class="lineNum">     960 </span>            : 
<span class="lineNum">     961 </span><span class="lineCov">    7774799 :       if (TREE_CODE (f1) != TREE_CODE (f2))</span>
<span class="lineNum">     962 </span>            :         return 0;
<span class="lineNum">     963 </span>            : 
<span class="lineNum">     964 </span>            :       /* A declaration with deduced return type should use its pre-deduction
<span class="lineNum">     965 </span>            :          type for declaration matching.  */
<span class="lineNum">     966 </span><span class="lineCov">    7752007 :       r2 = fndecl_declared_return_type (olddecl);</span>
<span class="lineNum">     967 </span>            : 
<span class="lineNum">     968 </span><span class="lineCov">    7752007 :       if (same_type_p (TREE_TYPE (f1), r2))</span>
<span class="lineNum">     969 </span>            :         {
<span class="lineNum">     970 </span><span class="lineCov">    6304527 :           if (!prototype_p (f2) &amp;&amp; DECL_EXTERN_C_P (olddecl)</span>
<span class="lineNum">     971 </span><span class="lineCov">    6304509 :               &amp;&amp; fndecl_built_in_p (olddecl))</span>
<span class="lineNum">     972 </span>            :             {
<span class="lineNum">     973 </span><span class="lineCov">         52 :               types_match = self_promoting_args_p (p1);</span>
<span class="lineNum">     974 </span><span class="lineCov">         52 :               if (p1 == void_list_node)</span>
<span class="lineNum">     975 </span><span class="lineCov">          3 :                 TREE_TYPE (newdecl) = TREE_TYPE (olddecl);</span>
<span class="lineNum">     976 </span>            :             }
<span class="lineNum">     977 </span>            :           else
<span class="lineNum">     978 </span><span class="lineCov">    6304396 :             types_match =</span>
<span class="lineNum">     979 </span><span class="lineCov">    6304396 :               compparms (p1, p2)</span>
<span class="lineNum">     980 </span><span class="lineCov">    1352527 :               &amp;&amp; type_memfn_rqual (f1) == type_memfn_rqual (f2)</span>
<span class="lineNum">     981 </span><span class="lineCov">    7656902 :               &amp;&amp; (TYPE_ATTRIBUTES (TREE_TYPE (newdecl)) == NULL_TREE</span>
<span class="lineNum">     982 </span><span class="lineCov">      61403 :                   || comp_type_attributes (TREE_TYPE (newdecl),</span>
<span class="lineNum">     983 </span><span class="lineCov">      61403 :                                            TREE_TYPE (olddecl)) != 0);</span>
<span class="lineNum">     984 </span>            :         }
<span class="lineNum">     985 </span>            :       else
<span class="lineNum">     986 </span>            :         types_match = 0;
<span class="lineNum">     987 </span>            : 
<span class="lineNum">     988 </span>            :       /* The decls dont match if they correspond to two different versions
<span class="lineNum">     989 </span>            :          of the same function.   Disallow extern &quot;C&quot; functions to be
<span class="lineNum">     990 </span>            :          versions for now.  */
<span class="lineNum">     991 </span><span class="lineCov">    6304448 :       if (types_match</span>
<span class="lineNum">     992 </span><span class="lineCov">    1352549 :           &amp;&amp; !DECL_EXTERN_C_P (newdecl)</span>
<span class="lineNum">     993 </span><span class="lineCov">     914122 :           &amp;&amp; !DECL_EXTERN_C_P (olddecl)</span>
<span class="lineNum">     994 </span><span class="lineCov">     911269 :           &amp;&amp; record_versions</span>
<span class="lineNum">     995 </span><span class="lineCov">    6865301 :           &amp;&amp; maybe_version_functions (newdecl, olddecl,</span>
<span class="lineNum">     996 </span><span class="lineCov">     560853 :                                       (!DECL_FUNCTION_VERSIONED (newdecl)</span>
<span class="lineNum">     997 </span><span class="lineCov">     560853 :                                        || !DECL_FUNCTION_VERSIONED (olddecl))))</span>
<span class="lineNum">     998 </span>            :         return 0;
<span class="lineNum">     999 </span>            :     }
<span class="lineNum">    1000 </span><span class="lineCov">    3504180 :   else if (TREE_CODE (newdecl) == TEMPLATE_DECL)</span>
<span class="lineNum">    1001 </span>            :     {
<span class="lineNum">    1002 </span><span class="lineCov">    3351862 :       tree oldres = DECL_TEMPLATE_RESULT (olddecl);</span>
<span class="lineNum">    1003 </span><span class="lineCov">    3351862 :       tree newres = DECL_TEMPLATE_RESULT (newdecl);</span>
<span class="lineNum">    1004 </span>            : 
<span class="lineNum">    1005 </span><span class="lineCov">    3351862 :       if (TREE_CODE (newres) != TREE_CODE (oldres))</span>
<span class="lineNum">    1006 </span>            :         return 0;
<span class="lineNum">    1007 </span>            : 
<span class="lineNum">    1008 </span><span class="lineCov">    3351859 :       if (!comp_template_parms (DECL_TEMPLATE_PARMS (newdecl),</span>
<span class="lineNum">    1009 </span><span class="lineCov">    6703718 :                                 DECL_TEMPLATE_PARMS (olddecl)))</span>
<span class="lineNum">    1010 </span>            :         return 0;
<span class="lineNum">    1011 </span>            : 
<span class="lineNum">    1012 </span><span class="lineCov">    1128777 :       if (TREE_CODE (DECL_TEMPLATE_RESULT (newdecl)) == TYPE_DECL)</span>
<span class="lineNum">    1013 </span><span class="lineCov">         10 :         types_match = (same_type_p (TREE_TYPE (oldres), TREE_TYPE (newres))</span>
<span class="lineNum">    1014 </span><span class="lineCov">          5 :                        &amp;&amp; equivalently_constrained (olddecl, newdecl));</span>
<span class="lineNum">    1015 </span>            :       else
<span class="lineNum">    1016 </span>            :         // We don't need to check equivalently_constrained for variable and
<span class="lineNum">    1017 </span>            :         // function templates because we check it on the results.
<span class="lineNum">    1018 </span><span class="lineCov">    1128772 :         types_match = decls_match (oldres, newres);</span>
<span class="lineNum">    1019 </span>            :     }
<span class="lineNum">    1020 </span>            :   else
<span class="lineNum">    1021 </span>            :     {
<span class="lineNum">    1022 </span>            :       /* Need to check scope for variable declaration (VAR_DECL).
<span class="lineNum">    1023 </span>            :          For typedef (TYPE_DECL), scope is ignored.  */
<span class="lineNum">    1024 </span><span class="lineCov">     152318 :       if (VAR_P (newdecl)</span>
<span class="lineNum">    1025 </span><span class="lineCov">     128127 :           &amp;&amp; CP_DECL_CONTEXT (newdecl) != CP_DECL_CONTEXT (olddecl)</span>
<span class="lineNum">    1026 </span>            :           /* [dcl.link]
<span class="lineNum">    1027 </span>            :              Two declarations for an object with C language linkage
<span class="lineNum">    1028 </span>            :              with the same name (ignoring the namespace that qualify
<span class="lineNum">    1029 </span>            :              it) that appear in different namespace scopes refer to
<span class="lineNum">    1030 </span>            :              the same object.  */
<span class="lineNum">    1031 </span><span class="lineCov">     160879 :           &amp;&amp; !(DECL_EXTERN_C_P (olddecl) &amp;&amp; DECL_EXTERN_C_P (newdecl)))</span>
<span class="lineNum">    1032 </span>            :         return 0;
<span class="lineNum">    1033 </span>            : 
<span class="lineNum">    1034 </span><span class="lineCov">     143805 :       if (TREE_TYPE (newdecl) == error_mark_node)</span>
<span class="lineNum">    1035 </span><span class="lineNoCov">          0 :         types_match = TREE_TYPE (olddecl) == error_mark_node;</span>
<span class="lineNum">    1036 </span><span class="lineCov">     143805 :       else if (TREE_TYPE (olddecl) == NULL_TREE)</span>
<span class="lineNum">    1037 </span><span class="lineNoCov">          0 :         types_match = TREE_TYPE (newdecl) == NULL_TREE;</span>
<span class="lineNum">    1038 </span><span class="lineCov">     287610 :       else if (TREE_TYPE (newdecl) == NULL_TREE)</span>
<span class="lineNum">    1039 </span>            :         types_match = 0;
<span class="lineNum">    1040 </span>            :       else
<span class="lineNum">    1041 </span><span class="lineCov">     143805 :         types_match = comptypes (TREE_TYPE (newdecl),</span>
<span class="lineNum">    1042 </span><span class="lineCov">     287610 :                                  TREE_TYPE (olddecl),</span>
<span class="lineNum">    1043 </span>            :                                  COMPARE_REDECLARATION);
<span class="lineNum">    1044 </span>            :     }
<span class="lineNum">    1045 </span>            : 
<span class="lineNum">    1046 </span>            :   // Normal functions can be constrained, as can variable partial
<span class="lineNum">    1047 </span>            :   // specializations.
<span class="lineNum">    1048 </span><span class="lineCov">    9018298 :   if (types_match &amp;&amp; VAR_OR_FUNCTION_DECL_P (newdecl))</span>
<span class="lineNum">    1049 </span><span class="lineCov">    1465561 :     types_match = equivalently_constrained (newdecl, olddecl);</span>
<span class="lineNum">    1050 </span>            : 
<span class="lineNum">    1051 </span>            :   return types_match;
<span class="lineNum">    1052 </span>            : }
<span class="lineNum">    1053 </span>            : 
<span class="lineNum">    1054 </span>            : /* NEWDECL and OLDDECL have identical signatures.  If they are
<span class="lineNum">    1055 </span>            :    different versions adjust them and return true.
<span class="lineNum">    1056 </span>            :    If RECORD is set to true, record function versions.  */
<a name="1057"><span class="lineNum">    1057 </span>            : </a>
<span class="lineNum">    1058 </span>            : bool
<span class="lineNum">    1059 </span><span class="lineCov">     561696 : maybe_version_functions (tree newdecl, tree olddecl, bool record)</span>
<span class="lineNum">    1060 </span>            : {
<span class="lineNum">    1061 </span><span class="lineCov">     561696 :   if (!targetm.target_option.function_versions (newdecl, olddecl))</span>
<span class="lineNum">    1062 </span>            :     return false;
<span class="lineNum">    1063 </span>            : 
<span class="lineNum">    1064 </span><span class="lineCov">       6318 :   if (!DECL_FUNCTION_VERSIONED (olddecl))</span>
<span class="lineNum">    1065 </span>            :     {
<span class="lineNum">    1066 </span><span class="lineCov">         93 :       DECL_FUNCTION_VERSIONED (olddecl) = 1;</span>
<span class="lineNum">    1067 </span><span class="lineCov">         93 :       if (DECL_ASSEMBLER_NAME_SET_P (olddecl))</span>
<span class="lineNum">    1068 </span><span class="lineCov">         15 :         mangle_decl (olddecl);</span>
<span class="lineNum">    1069 </span>            :     }
<span class="lineNum">    1070 </span>            : 
<span class="lineNum">    1071 </span><span class="lineCov">       6318 :   if (!DECL_FUNCTION_VERSIONED (newdecl))</span>
<span class="lineNum">    1072 </span>            :     {
<span class="lineNum">    1073 </span><span class="lineCov">        600 :       DECL_FUNCTION_VERSIONED (newdecl) = 1;</span>
<span class="lineNum">    1074 </span><span class="lineCov">        600 :       if (DECL_ASSEMBLER_NAME_SET_P (newdecl))</span>
<span class="lineNum">    1075 </span><span class="lineNoCov">          0 :         mangle_decl (newdecl);</span>
<span class="lineNum">    1076 </span>            :     }
<span class="lineNum">    1077 </span>            : 
<span class="lineNum">    1078 </span><span class="lineCov">       6318 :   if (record)</span>
<span class="lineNum">    1079 </span><span class="lineCov">        615 :     cgraph_node::record_function_versions (olddecl, newdecl);</span>
<span class="lineNum">    1080 </span>            : 
<span class="lineNum">    1081 </span>            :   return true;
<span class="lineNum">    1082 </span>            : }
<span class="lineNum">    1083 </span>            : 
<span class="lineNum">    1084 </span>            : /* If NEWDECL is `static' and an `extern' was seen previously,
<span class="lineNum">    1085 </span>            :    warn about it.  OLDDECL is the previous declaration.
<span class="lineNum">    1086 </span>            : 
<span class="lineNum">    1087 </span>            :    Note that this does not apply to the C++ case of declaring
<span class="lineNum">    1088 </span>            :    a variable `extern const' and then later `const'.
<span class="lineNum">    1089 </span>            : 
<span class="lineNum">    1090 </span>            :    Don't complain about built-in functions, since they are beyond
<span class="lineNum">    1091 </span>            :    the user's control.  */
<a name="1092"><span class="lineNum">    1092 </span>            : </a>
<span class="lineNum">    1093 </span>            : void
<span class="lineNum">    1094 </span><span class="lineCov">     942350 : warn_extern_redeclared_static (tree newdecl, tree olddecl)</span>
<span class="lineNum">    1095 </span>            : {
<span class="lineNum">    1096 </span><span class="lineCov">     942350 :   if (TREE_CODE (newdecl) == TYPE_DECL</span>
<span class="lineNum">    1097 </span><span class="lineCov">     939295 :       || TREE_CODE (newdecl) == TEMPLATE_DECL</span>
<span class="lineNum">    1098 </span><span class="lineCov">     835348 :       || TREE_CODE (newdecl) == CONST_DECL</span>
<span class="lineNum">    1099 </span><span class="lineCov">     835348 :       || TREE_CODE (newdecl) == NAMESPACE_DECL)</span>
<span class="lineNum">    1100 </span><span class="lineCov">     942344 :     return;</span>
<span class="lineNum">    1101 </span>            : 
<span class="lineNum">    1102 </span>            :   /* Don't get confused by static member functions; that's a different
<span class="lineNum">    1103 </span>            :      use of `static'.  */
<span class="lineNum">    1104 </span><span class="lineCov">     835348 :   if (TREE_CODE (newdecl) == FUNCTION_DECL</span>
<span class="lineNum">    1105 </span><span class="lineCov">     835348 :       &amp;&amp; DECL_STATIC_FUNCTION_P (newdecl))</span>
<span class="lineNum">    1106 </span>            :     return;
<span class="lineNum">    1107 </span>            : 
<span class="lineNum">    1108 </span>            :   /* If the old declaration was `static', or the new one isn't, then
<span class="lineNum">    1109 </span>            :      everything is OK.  */
<span class="lineNum">    1110 </span><span class="lineCov">    2326850 :   if (DECL_THIS_STATIC (olddecl) || !DECL_THIS_STATIC (newdecl))</span>
<span class="lineNum">    1111 </span>            :     return;
<span class="lineNum">    1112 </span>            : 
<span class="lineNum">    1113 </span>            :   /* It's OK to declare a builtin function as `static'.  */
<span class="lineNum">    1114 </span><span class="lineCov">          6 :   if (TREE_CODE (olddecl) == FUNCTION_DECL</span>
<span class="lineNum">    1115 </span><span class="lineCov">          6 :       &amp;&amp; DECL_ARTIFICIAL (olddecl))</span>
<span class="lineNum">    1116 </span>            :     return;
<span class="lineNum">    1117 </span>            : 
<span class="lineNum">    1118 </span><span class="lineCov">         12 :   auto_diagnostic_group d;</span>
<span class="lineNum">    1119 </span><span class="lineCov">          6 :   if (permerror (DECL_SOURCE_LOCATION (newdecl),</span>
<span class="lineNum">    1120 </span>            :                  &quot;%qD was declared %&lt;extern%&gt; and later %&lt;static%&gt;&quot;, newdecl))
<span class="lineNum">    1121 </span><span class="lineCov">          6 :     inform (DECL_SOURCE_LOCATION (olddecl),</span>
<span class="lineNum">    1122 </span>            :             &quot;previous declaration of %qD&quot;, olddecl);
<span class="lineNum">    1123 </span>            : }
<span class="lineNum">    1124 </span>            : 
<span class="lineNum">    1125 </span>            : /* NEW_DECL is a redeclaration of OLD_DECL; both are functions or
<span class="lineNum">    1126 </span>            :    function templates.  If their exception specifications do not
<span class="lineNum">    1127 </span>            :    match, issue a diagnostic.  */
<a name="1128"><span class="lineNum">    1128 </span>            : </a>
<span class="lineNum">    1129 </span>            : static void
<span class="lineNum">    1130 </span><span class="lineCov">     879594 : check_redeclaration_exception_specification (tree new_decl,</span>
<span class="lineNum">    1131 </span>            :                                              tree old_decl)
<span class="lineNum">    1132 </span>            : {
<span class="lineNum">    1133 </span><span class="lineCov">    1239543 :   tree new_exceptions = TYPE_RAISES_EXCEPTIONS (TREE_TYPE (new_decl));</span>
<span class="lineNum">    1134 </span><span class="lineCov">    1239543 :   tree old_exceptions = TYPE_RAISES_EXCEPTIONS (TREE_TYPE (old_decl));</span>
<span class="lineNum">    1135 </span>            : 
<span class="lineNum">    1136 </span>            :   /* Two default specs are equivalent, don't force evaluation.  */
<span class="lineNum">    1137 </span><span class="lineCov">     351110 :   if (UNEVALUATED_NOEXCEPT_SPEC_P (new_exceptions)</span>
<span class="lineNum">    1138 </span><span class="lineCov">     883151 :       &amp;&amp; UNEVALUATED_NOEXCEPT_SPEC_P (old_exceptions))</span>
<span class="lineNum">    1139 </span>            :     return;
<span class="lineNum">    1140 </span>            : 
<span class="lineNum">    1141 </span><span class="lineCov">     879072 :   if (!type_dependent_expression_p (old_decl))</span>
<span class="lineNum">    1142 </span>            :     {
<span class="lineNum">    1143 </span><span class="lineCov">     568422 :       maybe_instantiate_noexcept (new_decl);</span>
<span class="lineNum">    1144 </span><span class="lineCov">     568422 :       maybe_instantiate_noexcept (old_decl);</span>
<span class="lineNum">    1145 </span>            :     }
<span class="lineNum">    1146 </span><span class="lineCov">    1238499 :   new_exceptions = TYPE_RAISES_EXCEPTIONS (TREE_TYPE (new_decl));</span>
<span class="lineNum">    1147 </span><span class="lineCov">    1238499 :   old_exceptions = TYPE_RAISES_EXCEPTIONS (TREE_TYPE (old_decl));</span>
<span class="lineNum">    1148 </span>            : 
<span class="lineNum">    1149 </span>            :   /* [except.spec]
<span class="lineNum">    1150 </span>            : 
<span class="lineNum">    1151 </span>            :      If any declaration of a function has an exception-specification,
<span class="lineNum">    1152 </span>            :      all declarations, including the definition and an explicit
<span class="lineNum">    1153 </span>            :      specialization, of that function shall have an
<span class="lineNum">    1154 </span>            :      exception-specification with the same set of type-ids.  */
<span class="lineNum">    1155 </span><span class="lineCov">     879072 :   if (! DECL_IS_BUILTIN (old_decl)</span>
<span class="lineNum">    1156 </span><span class="lineCov">     879072 :       &amp;&amp; !comp_except_specs (new_exceptions, old_exceptions, ce_normal))</span>
<span class="lineNum">    1157 </span>            :     {
<span class="lineNum">    1158 </span><span class="lineCov">        233 :       const char *const msg</span>
<span class="lineNum">    1159 </span>            :         = G_(&quot;declaration of %qF has a different exception specifier&quot;);
<span class="lineNum">    1160 </span><span class="lineCov">        233 :       bool complained = true;</span>
<span class="lineNum">    1161 </span><span class="lineCov">        233 :       location_t new_loc = DECL_SOURCE_LOCATION (new_decl);</span>
<span class="lineNum">    1162 </span><span class="lineCov">        466 :       auto_diagnostic_group d;</span>
<span class="lineNum">    1163 </span><span class="lineCov">        233 :       if (DECL_IN_SYSTEM_HEADER (old_decl))</span>
<span class="lineNum">    1164 </span><span class="lineCov">        180 :         complained = pedwarn (new_loc, OPT_Wsystem_headers, msg, new_decl);</span>
<span class="lineNum">    1165 </span><span class="lineCov">         53 :       else if (!flag_exceptions)</span>
<span class="lineNum">    1166 </span>            :         /* We used to silently permit mismatched eh specs with
<span class="lineNum">    1167 </span>            :            -fno-exceptions, so make them a pedwarn now.  */
<span class="lineNum">    1168 </span><span class="lineCov">          2 :         complained = pedwarn (new_loc, OPT_Wpedantic, msg, new_decl);</span>
<span class="lineNum">    1169 </span>            :       else
<span class="lineNum">    1170 </span><span class="lineCov">         51 :         error_at (new_loc, msg, new_decl);</span>
<span class="lineNum">    1171 </span><span class="lineCov">        233 :       if (complained)</span>
<span class="lineNum">    1172 </span><span class="lineCov">         56 :         inform (DECL_SOURCE_LOCATION (old_decl),</span>
<span class="lineNum">    1173 </span>            :                 &quot;from previous declaration %qF&quot;, old_decl);
<span class="lineNum">    1174 </span>            :     }
<span class="lineNum">    1175 </span>            : }
<span class="lineNum">    1176 </span>            : 
<span class="lineNum">    1177 </span>            : /* Return true if OLD_DECL and NEW_DECL agree on constexprness.
<span class="lineNum">    1178 </span>            :    Otherwise issue diagnostics.  */
<a name="1179"><span class="lineNum">    1179 </span>            : </a>
<span class="lineNum">    1180 </span>            : static bool
<span class="lineNum">    1181 </span><span class="lineCov">     942350 : validate_constexpr_redeclaration (tree old_decl, tree new_decl)</span>
<span class="lineNum">    1182 </span>            : {
<span class="lineNum">    1183 </span><span class="lineCov">     942350 :   old_decl = STRIP_TEMPLATE (old_decl);</span>
<span class="lineNum">    1184 </span><span class="lineCov">     942350 :   new_decl = STRIP_TEMPLATE (new_decl);</span>
<span class="lineNum">    1185 </span><span class="lineCov">     942350 :   if (!VAR_OR_FUNCTION_DECL_P (old_decl)</span>
<span class="lineNum">    1186 </span><span class="lineCov">     939293 :       || !VAR_OR_FUNCTION_DECL_P (new_decl))</span>
<span class="lineNum">    1187 </span>            :     return true;
<span class="lineNum">    1188 </span><span class="lineCov">    1819116 :   if (DECL_DECLARED_CONSTEXPR_P (old_decl)</span>
<span class="lineNum">    1189 </span><span class="lineCov">    1819116 :       == DECL_DECLARED_CONSTEXPR_P (new_decl))</span>
<span class="lineNum">    1190 </span>            :     return true;
<span class="lineNum">    1191 </span><span class="lineCov">         30 :   if (TREE_CODE (old_decl) == FUNCTION_DECL)</span>
<span class="lineNum">    1192 </span>            :     {
<span class="lineNum">    1193 </span><span class="lineCov">          8 :       if (fndecl_built_in_p (old_decl))</span>
<span class="lineNum">    1194 </span>            :         {
<span class="lineNum">    1195 </span>            :           /* Hide a built-in declaration.  */
<span class="lineNum">    1196 </span><span class="lineNoCov">          0 :           DECL_DECLARED_CONSTEXPR_P (old_decl)</span>
<span class="lineNum">    1197 </span><span class="lineNoCov">          0 :             = DECL_DECLARED_CONSTEXPR_P (new_decl);</span>
<span class="lineNum">    1198 </span><span class="lineNoCov">          0 :           return true;</span>
<span class="lineNum">    1199 </span>            :         }
<span class="lineNum">    1200 </span>            :       /* 7.1.5 [dcl.constexpr]
<span class="lineNum">    1201 </span>            :          Note: An explicit specialization can differ from the template
<span class="lineNum">    1202 </span>            :          declaration with respect to the constexpr specifier.  */
<span class="lineNum">    1203 </span><span class="lineCov">          8 :       if (! DECL_TEMPLATE_SPECIALIZATION (old_decl)</span>
<span class="lineNum">    1204 </span><span class="lineCov">          8 :           &amp;&amp; DECL_TEMPLATE_SPECIALIZATION (new_decl))</span>
<span class="lineNum">    1205 </span>            :         return true;
<span class="lineNum">    1206 </span>            : 
<span class="lineNum">    1207 </span><span class="lineCov">          4 :       error_at (DECL_SOURCE_LOCATION (new_decl),</span>
<span class="lineNum">    1208 </span>            :                 &quot;redeclaration %qD differs in %&lt;constexpr%&gt; &quot;
<span class="lineNum">    1209 </span>            :                 &quot;from previous declaration&quot;, new_decl);
<span class="lineNum">    1210 </span><span class="lineCov">          4 :       inform (DECL_SOURCE_LOCATION (old_decl),</span>
<span class="lineNum">    1211 </span>            :               &quot;previous declaration %qD&quot;, old_decl);
<span class="lineNum">    1212 </span><span class="lineCov">          4 :       return false;</span>
<span class="lineNum">    1213 </span>            :     }
<span class="lineNum">    1214 </span>            :   return true;
<span class="lineNum">    1215 </span>            : }
<span class="lineNum">    1216 </span>            : 
<span class="lineNum">    1217 </span>            : // If OLDDECL and NEWDECL are concept declarations with the same type
<span class="lineNum">    1218 </span>            : // (i.e., and template parameters), but different requirements,
<a name="1219"><span class="lineNum">    1219 </span>            : // emit diagnostics and return true. Otherwise, return false.</a>
<span class="lineNum">    1220 </span>            : static inline bool
<span class="lineNum">    1221 </span><span class="lineCov">    3247886 : check_concept_refinement (tree olddecl, tree newdecl)</span>
<span class="lineNum">    1222 </span>            : {
<span class="lineNum">    1223 </span><span class="lineCov">    3247886 :   if (!DECL_DECLARED_CONCEPT_P (olddecl) || !DECL_DECLARED_CONCEPT_P (newdecl))</span>
<span class="lineNum">    1224 </span>            :     return false;
<span class="lineNum">    1225 </span>            : 
<span class="lineNum">    1226 </span><span class="lineNoCov">          0 :   tree d1 = DECL_TEMPLATE_RESULT (olddecl);</span>
<span class="lineNum">    1227 </span><span class="lineNoCov">          0 :   tree d2 = DECL_TEMPLATE_RESULT (newdecl);</span>
<span class="lineNum">    1228 </span><span class="lineNoCov">          0 :   if (TREE_CODE (d1) != TREE_CODE (d2))</span>
<span class="lineNum">    1229 </span>            :     return false;
<span class="lineNum">    1230 </span>            : 
<span class="lineNum">    1231 </span><span class="lineNoCov">          0 :   tree t1 = TREE_TYPE (d1);</span>
<span class="lineNum">    1232 </span><span class="lineNoCov">          0 :   tree t2 = TREE_TYPE (d2);</span>
<span class="lineNum">    1233 </span><span class="lineNoCov">          0 :   if (TREE_CODE (d1) == FUNCTION_DECL)</span>
<span class="lineNum">    1234 </span>            :     {
<span class="lineNum">    1235 </span><span class="lineNoCov">          0 :       if (compparms (TYPE_ARG_TYPES (t1), TYPE_ARG_TYPES (t2))</span>
<span class="lineNum">    1236 </span><span class="lineNoCov">          0 :           &amp;&amp; comp_template_parms (DECL_TEMPLATE_PARMS (olddecl),</span>
<span class="lineNum">    1237 </span><span class="lineNoCov">          0 :                                   DECL_TEMPLATE_PARMS (newdecl))</span>
<span class="lineNum">    1238 </span><span class="lineNoCov">          0 :           &amp;&amp; !equivalently_constrained (olddecl, newdecl))</span>
<span class="lineNum">    1239 </span>            :         {
<span class="lineNum">    1240 </span><span class="lineNoCov">          0 :           error (&quot;cannot specialize concept %q#D&quot;, olddecl);</span>
<span class="lineNum">    1241 </span><span class="lineNoCov">          0 :           return true;</span>
<span class="lineNum">    1242 </span>            :         }
<span class="lineNum">    1243 </span>            :     }
<span class="lineNum">    1244 </span>            :   return false;
<span class="lineNum">    1245 </span>            : }
<span class="lineNum">    1246 </span>            : 
<span class="lineNum">    1247 </span>            : /* DECL is a redeclaration of a function or function template.  If
<span class="lineNum">    1248 </span>            :    it does have default arguments issue a diagnostic.  Note: this
<span class="lineNum">    1249 </span>            :    function is used to enforce the requirements in C++11 8.3.6 about
<span class="lineNum">    1250 </span>            :    no default arguments in redeclarations.  */
<a name="1251"><span class="lineNum">    1251 </span>            : </a>
<span class="lineNum">    1252 </span>            : static void
<span class="lineNum">    1253 </span><span class="lineCov">     416503 : check_redeclaration_no_default_args (tree decl)</span>
<span class="lineNum">    1254 </span>            : {
<span class="lineNum">    1255 </span><span class="lineCov">     416503 :   gcc_assert (DECL_DECLARES_FUNCTION_P (decl));</span>
<span class="lineNum">    1256 </span>            : 
<span class="lineNum">    1257 </span><span class="lineCov">     712682 :   for (tree t = FUNCTION_FIRST_USER_PARMTYPE (decl);</span>
<span class="lineNum">    1258 </span><span class="lineCov">    1272254 :        t &amp;&amp; t != void_list_node; t = TREE_CHAIN (t))</span>
<span class="lineNum">    1259 </span><span class="lineCov">     855805 :     if (TREE_PURPOSE (t))</span>
<span class="lineNum">    1260 </span>            :       {
<span class="lineNum">    1261 </span><span class="lineCov">         54 :         permerror (DECL_SOURCE_LOCATION (decl),</span>
<span class="lineNum">    1262 </span>            :                    &quot;redeclaration of %q#D may not have default &quot;
<span class="lineNum">    1263 </span>            :                    &quot;arguments&quot;, decl);
<span class="lineNum">    1264 </span><span class="lineCov">         54 :         return;</span>
<span class="lineNum">    1265 </span>            :       }
<span class="lineNum">    1266 </span>            : }
<span class="lineNum">    1267 </span>            : 
<span class="lineNum">    1268 </span>            : /* NEWDECL is a redeclaration of a function or function template OLDDECL,
<span class="lineNum">    1269 </span>            :    in any case represented as FUNCTION_DECLs (the DECL_TEMPLATE_RESULTs of
<span class="lineNum">    1270 </span>            :    the TEMPLATE_DECLs in case of function templates).  This function is used
<span class="lineNum">    1271 </span>            :    to enforce the final part of C++17 11.3.6/4, about a single declaration:
<span class="lineNum">    1272 </span>            :    &quot;If a friend declaration specifies a default argument expression, that
<span class="lineNum">    1273 </span>            :    declaration shall be a definition and shall be the only declaration of
<span class="lineNum">    1274 </span>            :    the function or function template in the translation unit.&quot;  */
<a name="1275"><span class="lineNum">    1275 </span>            : </a>
<span class="lineNum">    1276 </span>            : static void
<span class="lineNum">    1277 </span><span class="lineCov">     254616 : check_no_redeclaration_friend_default_args (tree olddecl, tree newdecl,</span>
<span class="lineNum">    1278 </span>            :                                             bool olddecl_hidden_friend_p)
<span class="lineNum">    1279 </span>            : {
<span class="lineNum">    1280 </span><span class="lineCov">     502662 :   if (!olddecl_hidden_friend_p &amp;&amp; !DECL_FRIEND_P (newdecl))</span>
<span class="lineNum">    1281 </span>            :     return;
<span class="lineNum">    1282 </span>            : 
<span class="lineNum">    1283 </span><span class="lineCov">      35921 :   tree t1 = FUNCTION_FIRST_USER_PARMTYPE (olddecl);</span>
<span class="lineNum">    1284 </span><span class="lineCov">      35921 :   tree t2 = FUNCTION_FIRST_USER_PARMTYPE (newdecl);</span>
<span class="lineNum">    1285 </span>            : 
<span class="lineNum">    1286 </span><span class="lineCov">      97679 :   for (; t1 &amp;&amp; t1 != void_list_node;</span>
<span class="lineNum">    1287 </span><span class="lineCov">      61758 :        t1 = TREE_CHAIN (t1), t2 = TREE_CHAIN (t2))</span>
<span class="lineNum">    1288 </span><span class="lineCov">      13960 :     if ((olddecl_hidden_friend_p &amp;&amp; TREE_PURPOSE (t1))</span>
<span class="lineNum">    1289 </span><span class="lineCov">     137482 :         || (DECL_FRIEND_P (newdecl) &amp;&amp; TREE_PURPOSE (t2)))</span>
<span class="lineNum">    1290 </span>            :       {
<span class="lineNum">    1291 </span><span class="lineCov">         21 :         auto_diagnostic_group d;</span>
<span class="lineNum">    1292 </span><span class="lineCov">         21 :         if (permerror (DECL_SOURCE_LOCATION (newdecl),</span>
<span class="lineNum">    1293 </span>            :                        &quot;friend declaration of %q#D specifies default &quot;
<span class="lineNum">    1294 </span>            :                        &quot;arguments and isn't the only declaration&quot;, newdecl))
<span class="lineNum">    1295 </span><span class="lineCov">         21 :           inform (DECL_SOURCE_LOCATION (olddecl),</span>
<span class="lineNum">    1296 </span>            :                   &quot;previous declaration of %q#D&quot;, olddecl);
<span class="lineNum">    1297 </span><span class="lineCov">         21 :         return;</span>
<span class="lineNum">    1298 </span>            :       }
<span class="lineNum">    1299 </span>            : }
<span class="lineNum">    1300 </span>            : 
<span class="lineNum">    1301 </span>            : /* Merge tree bits that correspond to attributes noreturn, nothrow,
<span class="lineNum">    1302 </span>            :    const,  malloc, and pure from NEWDECL with those of OLDDECL.  */
<a name="1303"><span class="lineNum">    1303 </span>            : </a>
<span class="lineNum">    1304 </span>            : static void
<span class="lineNum">    1305 </span><span class="lineCov">     829320 : merge_attribute_bits (tree newdecl, tree olddecl)</span>
<span class="lineNum">    1306 </span>            : {
<span class="lineNum">    1307 </span><span class="lineCov">     829320 :   TREE_THIS_VOLATILE (newdecl) |= TREE_THIS_VOLATILE (olddecl);</span>
<span class="lineNum">    1308 </span><span class="lineCov">     829320 :   TREE_THIS_VOLATILE (olddecl) |= TREE_THIS_VOLATILE (newdecl);</span>
<span class="lineNum">    1309 </span><span class="lineCov">     829320 :   TREE_NOTHROW (newdecl) |= TREE_NOTHROW (olddecl);</span>
<span class="lineNum">    1310 </span><span class="lineCov">     829320 :   TREE_NOTHROW (olddecl) |= TREE_NOTHROW (newdecl);</span>
<span class="lineNum">    1311 </span><span class="lineCov">     829320 :   TREE_READONLY (newdecl) |= TREE_READONLY (olddecl);</span>
<span class="lineNum">    1312 </span><span class="lineCov">     829320 :   TREE_READONLY (olddecl) |= TREE_READONLY (newdecl);</span>
<span class="lineNum">    1313 </span><span class="lineCov">     829320 :   DECL_IS_MALLOC (newdecl) |= DECL_IS_MALLOC (olddecl);</span>
<span class="lineNum">    1314 </span><span class="lineCov">    1658640 :   DECL_IS_MALLOC (olddecl) |= DECL_IS_MALLOC (newdecl);</span>
<span class="lineNum">    1315 </span><span class="lineCov">    1658640 :   DECL_PURE_P (newdecl) |= DECL_PURE_P (olddecl);</span>
<span class="lineNum">    1316 </span><span class="lineCov">    1658640 :   DECL_PURE_P (olddecl) |= DECL_PURE_P (newdecl);</span>
<span class="lineNum">    1317 </span><span class="lineCov">    1658640 :   DECL_UNINLINABLE (newdecl) |= DECL_UNINLINABLE (olddecl);</span>
<span class="lineNum">    1318 </span><span class="lineCov">    1658640 :   DECL_UNINLINABLE (olddecl) |= DECL_UNINLINABLE (newdecl);</span>
<span class="lineNum">    1319 </span><span class="lineCov">     829320 : }</span>
<span class="lineNum">    1320 </span>            : 
<span class="lineNum">    1321 </span>            : #define GNU_INLINE_P(fn) (DECL_DECLARED_INLINE_P (fn)                   \
<span class="lineNum">    1322 </span>            :                           &amp;&amp; lookup_attribute (&quot;gnu_inline&quot;,          \
<span class="lineNum">    1323 </span>            :                                                DECL_ATTRIBUTES (fn)))
<span class="lineNum">    1324 </span>            : 
<span class="lineNum">    1325 </span>            : /* If NEWDECL is a redeclaration of OLDDECL, merge the declarations.
<span class="lineNum">    1326 </span>            :    If the redeclaration is invalid, a diagnostic is issued, and the
<span class="lineNum">    1327 </span>            :    error_mark_node is returned.  Otherwise, OLDDECL is returned.
<span class="lineNum">    1328 </span>            : 
<span class="lineNum">    1329 </span>            :    If NEWDECL is not a redeclaration of OLDDECL, NULL_TREE is
<span class="lineNum">    1330 </span>            :    returned.
<span class="lineNum">    1331 </span>            : 
<span class="lineNum">    1332 </span>            :    NEWDECL_IS_FRIEND is true if NEWDECL was declared as a friend.  */
<a name="1333"><span class="lineNum">    1333 </span>            : </a>
<span class="lineNum">    1334 </span>            : tree
<span class="lineNum">    1335 </span><span class="lineCov">    5891160 : duplicate_decls (tree newdecl, tree olddecl, bool newdecl_is_friend)</span>
<span class="lineNum">    1336 </span>            : {
<span class="lineNum">    1337 </span><span class="lineCov">    5891160 :   unsigned olddecl_uid = DECL_UID (olddecl);</span>
<span class="lineNum">    1338 </span><span class="lineCov">    5891160 :   int olddecl_friend = 0, types_match = 0, hidden_friend = 0;</span>
<span class="lineNum">    1339 </span><span class="lineCov">    5891160 :   int olddecl_hidden_friend = 0;</span>
<span class="lineNum">    1340 </span><span class="lineCov">    5891160 :   int new_defines_function = 0;</span>
<span class="lineNum">    1341 </span><span class="lineCov">    5891160 :   tree new_template_info;</span>
<span class="lineNum">    1342 </span><span class="lineCov">    5891160 :   location_t olddecl_loc = DECL_SOURCE_LOCATION (olddecl);</span>
<span class="lineNum">    1343 </span><span class="lineCov">    5891160 :   location_t newdecl_loc = DECL_SOURCE_LOCATION (newdecl);</span>
<span class="lineNum">    1344 </span>            : 
<span class="lineNum">    1345 </span><span class="lineCov">    5891160 :   if (newdecl == olddecl)</span>
<span class="lineNum">    1346 </span>            :     return olddecl;
<span class="lineNum">    1347 </span>            : 
<span class="lineNum">    1348 </span><span class="lineCov">    5827812 :   types_match = decls_match (newdecl, olddecl);</span>
<span class="lineNum">    1349 </span>            : 
<span class="lineNum">    1350 </span>            :   /* If either the type of the new decl or the type of the old decl is an
<span class="lineNum">    1351 </span>            :      error_mark_node, then that implies that we have already issued an
<span class="lineNum">    1352 </span>            :      error (earlier) for some bogus type specification, and in that case,
<span class="lineNum">    1353 </span>            :      it is rather pointless to harass the user with yet more error message
<span class="lineNum">    1354 </span>            :      about the same declaration, so just pretend the types match here.  */
<span class="lineNum">    1355 </span><span class="lineCov">    5827812 :   if (TREE_TYPE (newdecl) == error_mark_node</span>
<span class="lineNum">    1356 </span><span class="lineCov">    5827812 :       || TREE_TYPE (olddecl) == error_mark_node)</span>
<span class="lineNum">    1357 </span>            :     return error_mark_node;
<span class="lineNum">    1358 </span>            : 
<span class="lineNum">    1359 </span><span class="lineCov">    5827782 :   if (DECL_NAME (newdecl)</span>
<span class="lineNum">    1360 </span><span class="lineCov">    5827782 :       &amp;&amp; DECL_NAME (olddecl)</span>
<span class="lineNum">    1361 </span><span class="lineCov">   11655564 :       &amp;&amp; UDLIT_OPER_P (DECL_NAME (newdecl))</span>
<span class="lineNum">    1362 </span><span class="lineCov">    5855048 :       &amp;&amp; UDLIT_OPER_P (DECL_NAME (olddecl)))</span>
<span class="lineNum">    1363 </span>            :     {
<span class="lineNum">    1364 </span><span class="lineCov">      13633 :       if (TREE_CODE (newdecl) == TEMPLATE_DECL</span>
<span class="lineNum">    1365 </span><span class="lineCov">       2592 :           &amp;&amp; TREE_CODE (olddecl) != TEMPLATE_DECL</span>
<span class="lineNum">    1366 </span><span class="lineCov">      16209 :           &amp;&amp; check_raw_literal_operator (olddecl))</span>
<span class="lineNum">    1367 </span><span class="lineCov">          2 :         error_at (newdecl_loc,</span>
<span class="lineNum">    1368 </span>            :                   &quot;literal operator template %qD conflicts with&quot;
<span class="lineNum">    1369 </span>            :                   &quot; raw literal operator %qD&quot;, newdecl, olddecl);
<span class="lineNum">    1370 </span><span class="lineCov">      13631 :       else if (TREE_CODE (newdecl) != TEMPLATE_DECL</span>
<span class="lineNum">    1371 </span><span class="lineCov">      11041 :                &amp;&amp; TREE_CODE (olddecl) == TEMPLATE_DECL</span>
<span class="lineNum">    1372 </span><span class="lineCov">      13644 :                &amp;&amp; check_raw_literal_operator (newdecl))</span>
<span class="lineNum">    1373 </span><span class="lineCov">          2 :         error_at (newdecl_loc,</span>
<span class="lineNum">    1374 </span>            :                   &quot;raw literal operator %qD conflicts with&quot;
<span class="lineNum">    1375 </span>            :                   &quot; literal operator template %qD&quot;, newdecl, olddecl);
<span class="lineNum">    1376 </span>            :     }
<span class="lineNum">    1377 </span>            : 
<span class="lineNum">    1378 </span>            :   /* True to merge attributes between the declarations, false to
<span class="lineNum">    1379 </span>            :      set OLDDECL's attributes to those of NEWDECL (for template
<span class="lineNum">    1380 </span>            :      explicit specializations that specify their own attributes
<span class="lineNum">    1381 </span>            :      independent of those specified for the primary template).  */
<span class="lineNum">    1382 </span><span class="lineCov">    5827782 :   const bool merge_attr = (TREE_CODE (newdecl) != FUNCTION_DECL</span>
<span class="lineNum">    1383 </span><span class="lineCov">    2199072 :                            || !DECL_TEMPLATE_SPECIALIZATION (newdecl)</span>
<span class="lineNum">    1384 </span><span class="lineCov">    5878262 :                            || DECL_TEMPLATE_SPECIALIZATION (olddecl));</span>
<span class="lineNum">    1385 </span>            : 
<span class="lineNum">    1386 </span><span class="lineCov">    5827782 :   if (DECL_P (olddecl)</span>
<span class="lineNum">    1387 </span><span class="lineCov">    5827782 :       &amp;&amp; TREE_CODE (newdecl) == FUNCTION_DECL</span>
<span class="lineNum">    1388 </span><span class="lineCov">    2199072 :       &amp;&amp; TREE_CODE (olddecl) == FUNCTION_DECL</span>
<span class="lineNum">    1389 </span><span class="lineCov">    1834235 :       &amp;&amp; merge_attr</span>
<span class="lineNum">    1390 </span><span class="lineCov">    7611743 :       &amp;&amp; diagnose_mismatched_attributes (olddecl, newdecl))</span>
<span class="lineNum">    1391 </span>            :     {
<span class="lineNum">    1392 </span><span class="lineCov">         24 :       if (DECL_INITIAL (olddecl))</span>
<span class="lineNum">    1393 </span><span class="lineCov">         18 :         inform (olddecl_loc,</span>
<span class="lineNum">    1394 </span>            :                 &quot;previous definition of %qD was here&quot;, olddecl);
<span class="lineNum">    1395 </span>            :       else
<span class="lineNum">    1396 </span><span class="lineCov">          6 :         inform (olddecl_loc,</span>
<span class="lineNum">    1397 </span>            :                 &quot;previous declaration of %qD was here&quot;, olddecl);
<span class="lineNum">    1398 </span>            :     }
<span class="lineNum">    1399 </span>            : 
<span class="lineNum">    1400 </span>            :   /* Check for redeclaration and other discrepancies.  */
<span class="lineNum">    1401 </span><span class="lineCov">    5827782 :   if (TREE_CODE (olddecl) == FUNCTION_DECL</span>
<span class="lineNum">    1402 </span><span class="lineCov">    5827782 :       &amp;&amp; DECL_ARTIFICIAL (olddecl))</span>
<span class="lineNum">    1403 </span>            :     {
<span class="lineNum">    1404 </span><span class="lineCov">     824214 :       gcc_assert (!DECL_HIDDEN_FRIEND_P (olddecl));</span>
<span class="lineNum">    1405 </span><span class="lineCov">     412107 :       if (TREE_CODE (newdecl) != FUNCTION_DECL)</span>
<span class="lineNum">    1406 </span>            :         {
<span class="lineNum">    1407 </span>            :           /* Avoid warnings redeclaring built-ins which have not been
<span class="lineNum">    1408 </span>            :              explicitly declared.  */
<span class="lineNum">    1409 </span><span class="lineCov">      70635 :           if (DECL_ANTICIPATED (olddecl))</span>
<span class="lineNum">    1410 </span>            :             {
<span class="lineNum">    1411 </span><span class="lineCov">      23531 :               if (TREE_PUBLIC (newdecl)</span>
<span class="lineNum">    1412 </span><span class="lineCov">      23531 :                   &amp;&amp; CP_DECL_CONTEXT (newdecl) == global_namespace)</span>
<span class="lineNum">    1413 </span><span class="lineCov">         12 :                 warning_at (newdecl_loc,</span>
<span class="lineNum">    1414 </span>            :                             OPT_Wbuiltin_declaration_mismatch,
<span class="lineNum">    1415 </span>            :                             &quot;built-in function %qD declared as non-function&quot;,
<span class="lineNum">    1416 </span>            :                             newdecl);
<span class="lineNum">    1417 </span><span class="lineCov">      23531 :               return NULL_TREE;</span>
<span class="lineNum">    1418 </span>            :             }
<span class="lineNum">    1419 </span>            : 
<span class="lineNum">    1420 </span>            :           /* If you declare a built-in or predefined function name as static,
<span class="lineNum">    1421 </span>            :              the old definition is overridden, but optionally warn this was a
<span class="lineNum">    1422 </span>            :              bad choice of name.  */
<span class="lineNum">    1423 </span><span class="lineCov">         14 :           if (! TREE_PUBLIC (newdecl))</span>
<span class="lineNum">    1424 </span>            :             {
<span class="lineNum">    1425 </span><span class="lineCov">         14 :               warning_at (newdecl_loc,</span>
<span class="lineNum">    1426 </span>            :                           OPT_Wshadow, 
<span class="lineNum">    1427 </span><span class="lineCov">         14 :                           fndecl_built_in_p (olddecl)</span>
<span class="lineNum">    1428 </span>            :                           ? G_(&quot;shadowing built-in function %q#D&quot;)
<span class="lineNum">    1429 </span>            :                           : G_(&quot;shadowing library function %q#D&quot;), olddecl);
<span class="lineNum">    1430 </span>            :               /* Discard the old built-in function.  */
<span class="lineNum">    1431 </span><span class="lineCov">         14 :               return NULL_TREE;</span>
<span class="lineNum">    1432 </span>            :             }
<span class="lineNum">    1433 </span>            :           /* If the built-in is not ansi, then programs can override
<span class="lineNum">    1434 </span>            :              it even globally without an error.  */
<span class="lineNum">    1435 </span><span class="lineNoCov">          0 :           else if (! fndecl_built_in_p (olddecl))</span>
<span class="lineNum">    1436 </span><span class="lineNoCov">          0 :             warning_at (newdecl_loc, 0,</span>
<span class="lineNum">    1437 </span>            :                         &quot;library function %q#D redeclared as non-function %q#D&quot;,
<span class="lineNum">    1438 </span>            :                         olddecl, newdecl);
<span class="lineNum">    1439 </span>            :           else
<span class="lineNum">    1440 </span><span class="lineNoCov">          0 :             error_at (newdecl_loc,</span>
<span class="lineNum">    1441 </span>            :                       &quot;declaration of %q#D conflicts with built-in &quot;
<span class="lineNum">    1442 </span>            :                       &quot;declaration %q#D&quot;, newdecl, olddecl);
<span class="lineNum">    1443 </span><span class="lineNoCov">          0 :           return NULL_TREE;</span>
<span class="lineNum">    1444 </span>            :         }
<span class="lineNum">    1445 </span><span class="lineCov">    1554248 :       else if (DECL_OMP_DECLARE_REDUCTION_P (olddecl))</span>
<span class="lineNum">    1446 </span>            :         {
<span class="lineNum">    1447 </span><span class="lineCov">         27 :           gcc_assert (DECL_OMP_DECLARE_REDUCTION_P (newdecl));</span>
<span class="lineNum">    1448 </span><span class="lineCov">         27 :           error_at (newdecl_loc,</span>
<span class="lineNum">    1449 </span>            :                     &quot;redeclaration of %&lt;pragma omp declare reduction%&gt;&quot;);
<span class="lineNum">    1450 </span><span class="lineCov">         27 :           inform (olddecl_loc,</span>
<span class="lineNum">    1451 </span>            :                   &quot;previous %&lt;pragma omp declare reduction%&gt; declaration&quot;);
<span class="lineNum">    1452 </span><span class="lineCov">         27 :           return error_mark_node;</span>
<span class="lineNum">    1453 </span>            :         }
<span class="lineNum">    1454 </span><span class="lineCov">     388535 :       else if (!types_match)</span>
<span class="lineNum">    1455 </span>            :         {
<span class="lineNum">    1456 </span>            :           /* Avoid warnings redeclaring built-ins which have not been
<span class="lineNum">    1457 </span>            :              explicitly declared.  */
<span class="lineNum">    1458 </span><span class="lineCov">     395835 :           if (DECL_ANTICIPATED (olddecl))</span>
<span class="lineNum">    1459 </span>            :             {
<span class="lineNum">    1460 </span><span class="lineCov">      39736 :               tree t1, t2;</span>
<span class="lineNum">    1461 </span>            : 
<span class="lineNum">    1462 </span>            :               /* A new declaration doesn't match a built-in one unless it
<span class="lineNum">    1463 </span>            :                  is also extern &quot;C&quot;.  */
<span class="lineNum">    1464 </span><span class="lineCov">      39736 :               gcc_assert (DECL_IS_BUILTIN (olddecl));</span>
<span class="lineNum">    1465 </span><span class="lineCov">      39736 :               gcc_assert (DECL_EXTERN_C_P (olddecl));</span>
<span class="lineNum">    1466 </span><span class="lineCov">      39736 :               if (!DECL_EXTERN_C_P (newdecl))</span>
<span class="lineNum">    1467 </span>            :                 return NULL_TREE;
<span class="lineNum">    1468 </span>            : 
<span class="lineNum">    1469 </span><span class="lineCov">      17536 :               for (t1 = TYPE_ARG_TYPES (TREE_TYPE (newdecl)),</span>
<span class="lineNum">    1470 </span><span class="lineCov">      17536 :                    t2 = TYPE_ARG_TYPES (TREE_TYPE (olddecl));</span>
<span class="lineNum">    1471 </span><span class="lineCov">      34640 :                    t1 || t2;</span>
<span class="lineNum">    1472 </span><span class="lineCov">      17104 :                    t1 = TREE_CHAIN (t1), t2 = TREE_CHAIN (t2))</span>
<span class="lineNum">    1473 </span>            :                 {
<span class="lineNum">    1474 </span><span class="lineCov">      34622 :                   if (!t1 || !t2)</span>
<span class="lineNum">    1475 </span>            :                     break;
<span class="lineNum">    1476 </span>            :                   /* FILE, tm types are not known at the time
<span class="lineNum">    1477 </span>            :                      we create the builtins.  */
<span class="lineNum">    1478 </span><span class="lineCov">     105293 :                   for (unsigned i = 0;</span>
<span class="lineNum">    1479 </span><span class="lineCov">     139753 :                        i &lt; sizeof (builtin_structptr_types)</span>
<span class="lineNum">    1480 </span>            :                            / sizeof (builtin_structptr_type);
<span class="lineNum">    1481 </span>            :                        ++i)
<span class="lineNum">    1482 </span><span class="lineCov">     122643 :                     if (TREE_VALUE (t2) == builtin_structptr_types[i].node)</span>
<span class="lineNum">    1483 </span>            :                       {
<span class="lineNum">    1484 </span><span class="lineCov">      17350 :                         tree t = TREE_VALUE (t1);</span>
<span class="lineNum">    1485 </span>            : 
<span class="lineNum">    1486 </span><span class="lineCov">      17350 :                         if (TYPE_PTR_P (t)</span>
<span class="lineNum">    1487 </span><span class="lineCov">      34700 :                             &amp;&amp; TYPE_IDENTIFIER (TREE_TYPE (t))</span>
<span class="lineNum">    1488 </span><span class="lineCov">      17350 :                             == get_identifier (builtin_structptr_types[i].str)</span>
<span class="lineNum">    1489 </span><span class="lineCov">      34685 :                             &amp;&amp; compparms (TREE_CHAIN (t1), TREE_CHAIN (t2)))</span>
<span class="lineNum">    1490 </span>            :                           {
<span class="lineNum">    1491 </span><span class="lineCov">      17335 :                             tree oldargs = TYPE_ARG_TYPES (TREE_TYPE (olddecl));</span>
<span class="lineNum">    1492 </span>            : 
<span class="lineNum">    1493 </span><span class="lineCov">      17335 :                             TYPE_ARG_TYPES (TREE_TYPE (olddecl))</span>
<span class="lineNum">    1494 </span><span class="lineCov">      17335 :                               = TYPE_ARG_TYPES (TREE_TYPE (newdecl));</span>
<span class="lineNum">    1495 </span><span class="lineCov">      17335 :                             types_match = decls_match (newdecl, olddecl);</span>
<span class="lineNum">    1496 </span><span class="lineCov">      17335 :                             if (types_match)</span>
<span class="lineNum">    1497 </span><span class="lineCov">      17335 :                               return duplicate_decls (newdecl, olddecl,</span>
<span class="lineNum">    1498 </span><span class="lineCov">      17335 :                                                       newdecl_is_friend);</span>
<span class="lineNum">    1499 </span><span class="lineNoCov">          0 :                             TYPE_ARG_TYPES (TREE_TYPE (olddecl)) = oldargs;</span>
<span class="lineNum">    1500 </span>            :                           }
<span class="lineNum">    1501 </span><span class="lineCov">         15 :                         goto next_arg;</span>
<span class="lineNum">    1502 </span>            :                       }
<span class="lineNum">    1503 </span>            : 
<span class="lineNum">    1504 </span><span class="lineCov">      17110 :                   if (! same_type_p (TREE_VALUE (t1), TREE_VALUE (t2)))</span>
<span class="lineNum">    1505 </span>            :                     break;
<span class="lineNum">    1506 </span><span class="lineCov">      17104 : next_arg:;</span>
<span class="lineNum">    1507 </span>            :                 }
<span class="lineNum">    1508 </span>            : 
<span class="lineNum">    1509 </span><span class="lineCov">        201 :               warning_at (newdecl_loc,</span>
<span class="lineNum">    1510 </span>            :                           OPT_Wbuiltin_declaration_mismatch,
<span class="lineNum">    1511 </span>            :                           &quot;declaration of %q#D conflicts with built-in &quot;
<span class="lineNum">    1512 </span>            :                           &quot;declaration %q#D&quot;, newdecl, olddecl);
<span class="lineNum">    1513 </span>            :             }
<span class="lineNum">    1514 </span><span class="lineCov">      92209 :           else if ((DECL_EXTERN_C_P (newdecl)</span>
<span class="lineNum">    1515 </span><span class="lineCov">         45 :                     &amp;&amp; DECL_EXTERN_C_P (olddecl))</span>
<span class="lineNum">    1516 </span><span class="lineCov">     184403 :                    || compparms (TYPE_ARG_TYPES (TREE_TYPE (newdecl)),</span>
<span class="lineNum">    1517 </span><span class="lineCov">      92194 :                                  TYPE_ARG_TYPES (TREE_TYPE (olddecl))))</span>
<span class="lineNum">    1518 </span>            :             {
<span class="lineNum">    1519 </span>            :               /* Don't really override olddecl for __* prefixed builtins
<span class="lineNum">    1520 </span>            :                  except for __[^b]*_chk, the compiler might be using those
<span class="lineNum">    1521 </span>            :                  explicitly.  */
<span class="lineNum">    1522 </span><span class="lineCov">         15 :               if (fndecl_built_in_p (olddecl))</span>
<span class="lineNum">    1523 </span>            :                 {
<span class="lineNum">    1524 </span><span class="lineCov">         15 :                   tree id = DECL_NAME (olddecl);</span>
<span class="lineNum">    1525 </span><span class="lineCov">         15 :                   const char *name = IDENTIFIER_POINTER (id);</span>
<span class="lineNum">    1526 </span><span class="lineCov">         15 :                   size_t len;</span>
<span class="lineNum">    1527 </span>            : 
<span class="lineNum">    1528 </span><span class="lineCov">         15 :                   if (name[0] == '_'</span>
<span class="lineNum">    1529 </span><span class="lineCov">         15 :                       &amp;&amp; name[1] == '_'</span>
<span class="lineNum">    1530 </span><span class="lineCov">         30 :                       &amp;&amp; (strncmp (name + 2, &quot;builtin_&quot;,</span>
<span class="lineNum">    1531 </span>            :                                    strlen (&quot;builtin_&quot;)) == 0
<span class="lineNum">    1532 </span><span class="lineCov">          6 :                           || (len = strlen (name)) &lt;= strlen (&quot;___chk&quot;)</span>
<span class="lineNum">    1533 </span><span class="lineCov">          6 :                           || memcmp (name + len - strlen (&quot;_chk&quot;),</span>
<span class="lineNum">    1534 </span>            :                                      &quot;_chk&quot;, strlen (&quot;_chk&quot;) + 1) != 0))
<span class="lineNum">    1535 </span>            :                     {
<span class="lineNum">    1536 </span><span class="lineCov">         15 :                       if (DECL_INITIAL (newdecl))</span>
<span class="lineNum">    1537 </span>            :                         {
<span class="lineNum">    1538 </span><span class="lineCov">          6 :                           error_at (newdecl_loc,</span>
<span class="lineNum">    1539 </span>            :                                     &quot;definition of %q#D ambiguates built-in &quot;
<span class="lineNum">    1540 </span>            :                                     &quot;declaration %q#D&quot;, newdecl, olddecl);
<span class="lineNum">    1541 </span><span class="lineCov">          6 :                           return error_mark_node;</span>
<span class="lineNum">    1542 </span>            :                         }
<span class="lineNum">    1543 </span><span class="lineCov">         18 :                       auto_diagnostic_group d;</span>
<span class="lineNum">    1544 </span><span class="lineCov">          9 :                       if (permerror (newdecl_loc,</span>
<span class="lineNum">    1545 </span>            :                                      &quot;new declaration %q#D ambiguates built-in&quot;
<span class="lineNum">    1546 </span>            :                                      &quot; declaration %q#D&quot;, newdecl, olddecl)
<span class="lineNum">    1547 </span><span class="lineCov">          9 :                           &amp;&amp; flag_permissive)</span>
<span class="lineNum">    1548 </span><span class="lineCov">          3 :                         inform (newdecl_loc,</span>
<span class="lineNum">    1549 </span>            :                                 &quot;ignoring the %q#D declaration&quot;, newdecl);
<span class="lineNum">    1550 </span><span class="lineCov">          9 :                       return flag_permissive ? olddecl : error_mark_node;</span>
<span class="lineNum">    1551 </span>            :                     }
<span class="lineNum">    1552 </span>            :                 }
<span class="lineNum">    1553 </span>            : 
<span class="lineNum">    1554 </span>            :               /* A near match; override the builtin.  */
<span class="lineNum">    1555 </span>            : 
<span class="lineNum">    1556 </span><span class="lineNoCov">          0 :               if (TREE_PUBLIC (newdecl))</span>
<span class="lineNum">    1557 </span><span class="lineNoCov">          0 :                 warning_at (newdecl_loc,</span>
<span class="lineNum">    1558 </span>            :                             OPT_Wbuiltin_declaration_mismatch,
<span class="lineNum">    1559 </span>            :                             &quot;new declaration %q#D ambiguates built-in &quot;
<span class="lineNum">    1560 </span>            :                             &quot;declaration %q#D&quot;, newdecl, olddecl);
<span class="lineNum">    1561 </span>            :               else
<span class="lineNum">    1562 </span><span class="lineNoCov">          0 :                 warning (OPT_Wshadow, </span>
<span class="lineNum">    1563 </span>            :                          fndecl_built_in_p (olddecl)
<span class="lineNum">    1564 </span>            :                          ? G_(&quot;shadowing built-in function %q#D&quot;)
<span class="lineNum">    1565 </span>            :                          : G_(&quot;shadowing library function %q#D&quot;), olddecl);
<span class="lineNum">    1566 </span>            :             }
<span class="lineNum">    1567 </span>            :           else
<span class="lineNum">    1568 </span>            :             /* Discard the old built-in function.  */
<span class="lineNum">    1569 </span>            :             return NULL_TREE;
<span class="lineNum">    1570 </span>            : 
<span class="lineNum">    1571 </span>            :           /* Replace the old RTL to avoid problems with inlining.  */
<span class="lineNum">    1572 </span><span class="lineCov">        201 :           COPY_DECL_RTL (newdecl, olddecl);</span>
<span class="lineNum">    1573 </span>            :         }
<span class="lineNum">    1574 </span>            :       /* Even if the types match, prefer the new declarations type for
<span class="lineNum">    1575 </span>            :          built-ins which have not been explicitly declared, for
<span class="lineNum">    1576 </span>            :          exception lists, etc...  */
<span class="lineNum">    1577 </span><span class="lineCov">     256590 :       else if (DECL_IS_BUILTIN (olddecl))</span>
<span class="lineNum">    1578 </span>            :         {
<span class="lineNum">    1579 </span><span class="lineCov">     256590 :           tree type = TREE_TYPE (newdecl);</span>
<span class="lineNum">    1580 </span><span class="lineCov">     256590 :           tree attribs = (*targetm.merge_type_attributes)</span>
<span class="lineNum">    1581 </span><span class="lineCov">     256590 :             (TREE_TYPE (olddecl), type);</span>
<span class="lineNum">    1582 </span>            : 
<span class="lineNum">    1583 </span><span class="lineCov">     256590 :           type = cp_build_type_attribute_variant (type, attribs);</span>
<span class="lineNum">    1584 </span><span class="lineCov">     256590 :           TREE_TYPE (newdecl) = TREE_TYPE (olddecl) = type;</span>
<span class="lineNum">    1585 </span>            :         }
<span class="lineNum">    1586 </span>            : 
<span class="lineNum">    1587 </span>            :       /* If a function is explicitly declared &quot;throw ()&quot;, propagate that to
<span class="lineNum">    1588 </span>            :          the corresponding builtin.  */
<span class="lineNum">    1589 </span><span class="lineCov">     256791 :       if (DECL_BUILT_IN_CLASS (olddecl) == BUILT_IN_NORMAL</span>
<span class="lineNum">    1590 </span><span class="lineCov">     483246 :           &amp;&amp; DECL_ANTICIPATED (olddecl)</span>
<span class="lineNum">    1591 </span><span class="lineCov">     241588 :           &amp;&amp; TREE_NOTHROW (newdecl)</span>
<span class="lineNum">    1592 </span><span class="lineCov">     452398 :           &amp;&amp; !TREE_NOTHROW (olddecl))</span>
<span class="lineNum">    1593 </span>            :         {
<span class="lineNum">    1594 </span><span class="lineCov">        139 :           enum built_in_function fncode = DECL_FUNCTION_CODE (olddecl);</span>
<span class="lineNum">    1595 </span><span class="lineCov">        139 :           tree tmpdecl = builtin_decl_explicit (fncode);</span>
<span class="lineNum">    1596 </span><span class="lineCov">        139 :           if (tmpdecl &amp;&amp; tmpdecl != olddecl &amp;&amp; types_match)</span>
<span class="lineNum">    1597 </span><span class="lineCov">        139 :             TREE_NOTHROW (tmpdecl)  = 1;</span>
<span class="lineNum">    1598 </span>            :         }
<span class="lineNum">    1599 </span>            : 
<span class="lineNum">    1600 </span>            :       /* Whether or not the builtin can throw exceptions has no
<span class="lineNum">    1601 </span>            :          bearing on this declarator.  */
<span class="lineNum">    1602 </span><span class="lineCov">     256791 :       TREE_NOTHROW (olddecl) = 0;</span>
<span class="lineNum">    1603 </span>            : 
<span class="lineNum">    1604 </span><span class="lineCov">     513582 :       if (DECL_THIS_STATIC (newdecl) &amp;&amp; !DECL_THIS_STATIC (olddecl))</span>
<span class="lineNum">    1605 </span>            :         {
<span class="lineNum">    1606 </span>            :           /* If a builtin function is redeclared as `static', merge
<span class="lineNum">    1607 </span>            :              the declarations, but make the original one static.  */
<span class="lineNum">    1608 </span><span class="lineNoCov">          0 :           DECL_THIS_STATIC (olddecl) = 1;</span>
<span class="lineNum">    1609 </span><span class="lineNoCov">          0 :           TREE_PUBLIC (olddecl) = 0;</span>
<span class="lineNum">    1610 </span>            : 
<span class="lineNum">    1611 </span>            :           /* Make the old declaration consistent with the new one so
<span class="lineNum">    1612 </span>            :              that all remnants of the builtin-ness of this function
<span class="lineNum">    1613 </span>            :              will be banished.  */
<span class="lineNum">    1614 </span><span class="lineNoCov">          0 :           SET_DECL_LANGUAGE (olddecl, DECL_LANGUAGE (newdecl));</span>
<span class="lineNum">    1615 </span><span class="lineNoCov">          0 :           COPY_DECL_RTL (newdecl, olddecl);</span>
<span class="lineNum">    1616 </span>            :         }
<span class="lineNum">    1617 </span>            :     }
<span class="lineNum">    1618 </span><span class="lineCov">    5415675 :   else if (TREE_CODE (olddecl) != TREE_CODE (newdecl))</span>
<span class="lineNum">    1619 </span>            :     {
<span class="lineNum">    1620 </span>            :       /* C++ Standard, 3.3, clause 4:
<span class="lineNum">    1621 </span>            :          &quot;[Note: a namespace name or a class template name must be unique
<span class="lineNum">    1622 </span>            :          in its declarative region (7.3.2, clause 14). ]&quot;  */
<span class="lineNum">    1623 </span><span class="lineCov">     550773 :       if (TREE_CODE (olddecl) != NAMESPACE_DECL</span>
<span class="lineNum">    1624 </span><span class="lineCov">     550755 :           &amp;&amp; TREE_CODE (newdecl) != NAMESPACE_DECL</span>
<span class="lineNum">    1625 </span><span class="lineCov">     550743 :           &amp;&amp; (TREE_CODE (olddecl) != TEMPLATE_DECL</span>
<span class="lineNum">    1626 </span><span class="lineCov">     710128 :               || TREE_CODE (DECL_TEMPLATE_RESULT (olddecl)) != TYPE_DECL)</span>
<span class="lineNum">    1627 </span><span class="lineCov">    1101513 :           &amp;&amp; (TREE_CODE (newdecl) != TEMPLATE_DECL</span>
<span class="lineNum">    1628 </span><span class="lineCov">     371448 :               || TREE_CODE (DECL_TEMPLATE_RESULT (newdecl)) != TYPE_DECL))</span>
<span class="lineNum">    1629 </span>            :         {
<span class="lineNum">    1630 </span><span class="lineCov">       9868 :           if ((TREE_CODE (olddecl) == TYPE_DECL &amp;&amp; DECL_ARTIFICIAL (olddecl)</span>
<span class="lineNum">    1631 </span><span class="lineCov">       9866 :                &amp;&amp; TREE_CODE (newdecl) != TYPE_DECL)</span>
<span class="lineNum">    1632 </span><span class="lineCov">     550736 :               || (TREE_CODE (newdecl) == TYPE_DECL &amp;&amp; DECL_ARTIFICIAL (newdecl)</span>
<span class="lineNum">    1633 </span><span class="lineCov">         80 :                   &amp;&amp; TREE_CODE (olddecl) != TYPE_DECL))</span>
<span class="lineNum">    1634 </span>            :             {
<span class="lineNum">    1635 </span>            :               /* We do nothing special here, because C++ does such nasty
<span class="lineNum">    1636 </span>            :                  things with TYPE_DECLs.  Instead, just let the TYPE_DECL
<span class="lineNum">    1637 </span>            :                  get shadowed, and know that if we need to find a TYPE_DECL
<span class="lineNum">    1638 </span>            :                  for a given name, we can look in the IDENTIFIER_TYPE_VALUE
<span class="lineNum">    1639 </span>            :                  slot of the identifier.  */
<span class="lineNum">    1640 </span>            :               return NULL_TREE;
<span class="lineNum">    1641 </span>            :             }
<span class="lineNum">    1642 </span>            :             
<span class="lineNum">    1643 </span><span class="lineCov">     540788 :             if ((TREE_CODE (newdecl) == FUNCTION_DECL</span>
<span class="lineNum">    1644 </span><span class="lineCov">     355068 :                  &amp;&amp; DECL_FUNCTION_TEMPLATE_P (olddecl))</span>
<span class="lineNum">    1645 </span><span class="lineCov">     540796 :                 || (TREE_CODE (olddecl) == FUNCTION_DECL</span>
<span class="lineNum">    1646 </span><span class="lineCov">     185712 :                     &amp;&amp; DECL_FUNCTION_TEMPLATE_P (newdecl)))</span>
<span class="lineNum">    1647 </span>            :               return NULL_TREE;
<span class="lineNum">    1648 </span>            :         }
<span class="lineNum">    1649 </span>            : 
<span class="lineNum">    1650 </span><span class="lineCov">         61 :       error (&quot;%q#D redeclared as different kind of symbol&quot;, newdecl);</span>
<span class="lineNum">    1651 </span><span class="lineCov">         61 :       if (TREE_CODE (olddecl) == TREE_LIST)</span>
<span class="lineNum">    1652 </span><span class="lineNoCov">          0 :         olddecl = TREE_VALUE (olddecl);</span>
<span class="lineNum">    1653 </span><span class="lineCov">         61 :       inform (olddecl_loc,</span>
<span class="lineNum">    1654 </span>            :               &quot;previous declaration %q#D&quot;, olddecl);
<span class="lineNum">    1655 </span>            : 
<span class="lineNum">    1656 </span><span class="lineCov">         61 :       return error_mark_node;</span>
<span class="lineNum">    1657 </span>            :     }
<span class="lineNum">    1658 </span><span class="lineCov">    4864902 :   else if (!types_match)</span>
<span class="lineNum">    1659 </span>            :     {
<span class="lineNum">    1660 </span><span class="lineCov">    4174352 :       if (CP_DECL_CONTEXT (newdecl) != CP_DECL_CONTEXT (olddecl))</span>
<span class="lineNum">    1661 </span>            :         /* These are certainly not duplicate declarations; they're
<span class="lineNum">    1662 </span>            :            from different scopes.  */
<span class="lineNum">    1663 </span>            :         return NULL_TREE;
<span class="lineNum">    1664 </span>            : 
<span class="lineNum">    1665 </span><span class="lineCov">    4174319 :       if (TREE_CODE (newdecl) == TEMPLATE_DECL)</span>
<span class="lineNum">    1666 </span>            :         {
<span class="lineNum">    1667 </span>            :           /* The name of a class template may not be declared to refer to
<span class="lineNum">    1668 </span>            :              any other template, class, function, object, namespace, value,
<span class="lineNum">    1669 </span>            :              or type in the same scope.  */
<span class="lineNum">    1670 </span><span class="lineCov">    3247889 :           if (TREE_CODE (DECL_TEMPLATE_RESULT (olddecl)) == TYPE_DECL</span>
<span class="lineNum">    1671 </span><span class="lineCov">    3247889 :               || TREE_CODE (DECL_TEMPLATE_RESULT (newdecl)) == TYPE_DECL)</span>
<span class="lineNum">    1672 </span>            :             {
<span class="lineNum">    1673 </span><span class="lineCov">          3 :               error_at (newdecl_loc,</span>
<span class="lineNum">    1674 </span>            :                         &quot;conflicting declaration of template %q#D&quot;, newdecl);
<span class="lineNum">    1675 </span><span class="lineCov">          3 :               inform (olddecl_loc,</span>
<span class="lineNum">    1676 </span>            :                       &quot;previous declaration %q#D&quot;, olddecl);
<span class="lineNum">    1677 </span><span class="lineCov">          3 :               return error_mark_node;</span>
<span class="lineNum">    1678 </span>            :             }
<span class="lineNum">    1679 </span><span class="lineCov">    3247886 :           else if (TREE_CODE (DECL_TEMPLATE_RESULT (olddecl)) == FUNCTION_DECL</span>
<span class="lineNum">    1680 </span><span class="lineCov">    6495772 :                    &amp;&amp; TREE_CODE (DECL_TEMPLATE_RESULT (newdecl)) == FUNCTION_DECL</span>
<span class="lineNum">    1681 </span><span class="lineCov">    3247886 :                    &amp;&amp; compparms (TYPE_ARG_TYPES (TREE_TYPE (DECL_TEMPLATE_RESULT (olddecl))),</span>
<span class="lineNum">    1682 </span><span class="lineCov">    6495772 :                                  TYPE_ARG_TYPES (TREE_TYPE (DECL_TEMPLATE_RESULT (newdecl))))</span>
<span class="lineNum">    1683 </span><span class="lineCov">      12377 :                    &amp;&amp; comp_template_parms (DECL_TEMPLATE_PARMS (newdecl),</span>
<span class="lineNum">    1684 </span><span class="lineCov">      12377 :                                            DECL_TEMPLATE_PARMS (olddecl))</span>
<span class="lineNum">    1685 </span>            :                    /* Template functions can be disambiguated by
<span class="lineNum">    1686 </span>            :                       return type.  */
<span class="lineNum">    1687 </span><span class="lineCov">       9141 :                    &amp;&amp; same_type_p (TREE_TYPE (TREE_TYPE (newdecl)),</span>
<span class="lineNum">    1688 </span>            :                                    TREE_TYPE (TREE_TYPE (olddecl)))
<span class="lineNum">    1689 </span>            :                    // Template functions can also be disambiguated by
<span class="lineNum">    1690 </span>            :                    // constraints.
<span class="lineNum">    1691 </span><span class="lineCov">    3247905 :                    &amp;&amp; equivalently_constrained (olddecl, newdecl))</span>
<span class="lineNum">    1692 </span>            :             {
<span class="lineNum">    1693 </span><span class="lineNoCov">          0 :               error_at (newdecl_loc, &quot;ambiguating new declaration %q#D&quot;,</span>
<span class="lineNum">    1694 </span>            :                         newdecl);
<span class="lineNum">    1695 </span><span class="lineNoCov">          0 :               inform (olddecl_loc,</span>
<span class="lineNum">    1696 </span>            :                       &quot;old declaration %q#D&quot;, olddecl);
<span class="lineNum">    1697 </span>            :             }
<span class="lineNum">    1698 </span><span class="lineCov">    3247886 :           else if (check_concept_refinement (olddecl, newdecl))</span>
<span class="lineNum">    1699 </span><span class="lineNoCov">          0 :             return error_mark_node;</span>
<span class="lineNum">    1700 </span><span class="lineCov">    3247886 :           return NULL_TREE;</span>
<span class="lineNum">    1701 </span>            :         }
<span class="lineNum">    1702 </span><span class="lineCov">     926430 :       if (TREE_CODE (newdecl) == FUNCTION_DECL)</span>
<span class="lineNum">    1703 </span>            :         {
<span class="lineNum">    1704 </span><span class="lineCov">     926349 :           if (DECL_EXTERN_C_P (newdecl) &amp;&amp; DECL_EXTERN_C_P (olddecl))</span>
<span class="lineNum">    1705 </span>            :             {
<span class="lineNum">    1706 </span><span class="lineCov">          8 :               error_at (newdecl_loc,</span>
<span class="lineNum">    1707 </span>            :                         &quot;conflicting declaration of C function %q#D&quot;,
<span class="lineNum">    1708 </span>            :                         newdecl);
<span class="lineNum">    1709 </span><span class="lineCov">          8 :               inform (olddecl_loc,</span>
<span class="lineNum">    1710 </span>            :                       &quot;previous declaration %q#D&quot;, olddecl);
<span class="lineNum">    1711 </span><span class="lineCov">          8 :               return NULL_TREE;</span>
<span class="lineNum">    1712 </span>            :             }
<span class="lineNum">    1713 </span>            :           /* For function versions, params and types match, but they
<span class="lineNum">    1714 </span>            :              are not ambiguous.  */
<span class="lineNum">    1715 </span><span class="lineCov">     926341 :           else if ((!DECL_FUNCTION_VERSIONED (newdecl)</span>
<span class="lineNum">    1716 </span><span class="lineCov">     920497 :                     &amp;&amp; !DECL_FUNCTION_VERSIONED (olddecl))</span>
<span class="lineNum">    1717 </span>            :                    // The functions have the same parameter types.
<span class="lineNum">    1718 </span><span class="lineCov">     920497 :                    &amp;&amp; compparms (TYPE_ARG_TYPES (TREE_TYPE (newdecl)),</span>
<span class="lineNum">    1719 </span><span class="lineCov">     920497 :                                  TYPE_ARG_TYPES (TREE_TYPE (olddecl)))</span>
<span class="lineNum">    1720 </span>            :                    // And the same constraints.
<span class="lineNum">    1721 </span><span class="lineCov">     926367 :                    &amp;&amp; equivalently_constrained (newdecl, olddecl))</span>
<span class="lineNum">    1722 </span>            :             {
<span class="lineNum">    1723 </span><span class="lineCov">         26 :               error_at (newdecl_loc,</span>
<span class="lineNum">    1724 </span>            :                         &quot;ambiguating new declaration of %q#D&quot;, newdecl);
<span class="lineNum">    1725 </span><span class="lineCov">         26 :               inform (olddecl_loc,</span>
<span class="lineNum">    1726 </span>            :                       &quot;old declaration %q#D&quot;, olddecl);
<span class="lineNum">    1727 </span><span class="lineCov">         26 :               return error_mark_node;</span>
<span class="lineNum">    1728 </span>            :             }
<span class="lineNum">    1729 </span>            :           else
<span class="lineNum">    1730 </span><span class="lineCov">     926315 :             return NULL_TREE;</span>
<span class="lineNum">    1731 </span>            :         }
<span class="lineNum">    1732 </span>            :       else
<span class="lineNum">    1733 </span>            :         {
<span class="lineNum">    1734 </span><span class="lineCov">         81 :           error_at (newdecl_loc, &quot;conflicting declaration %q#D&quot;, newdecl);</span>
<span class="lineNum">    1735 </span><span class="lineCov">         81 :           inform (olddecl_loc,</span>
<span class="lineNum">    1736 </span>            :                   &quot;previous declaration as %q#D&quot;, olddecl);
<span class="lineNum">    1737 </span><span class="lineCov">         81 :           return error_mark_node;</span>
<span class="lineNum">    1738 </span>            :         }
<span class="lineNum">    1739 </span>            :     }
<span class="lineNum">    1740 </span><span class="lineCov">     690550 :   else if (TREE_CODE (newdecl) == FUNCTION_DECL</span>
<span class="lineNum">    1741 </span><span class="lineCov">     690550 :             &amp;&amp; ((DECL_TEMPLATE_SPECIALIZATION (olddecl)</span>
<span class="lineNum">    1742 </span><span class="lineCov">        206 :                  &amp;&amp; (!DECL_TEMPLATE_INFO (newdecl)</span>
<span class="lineNum">    1743 </span><span class="lineCov">        206 :                      || (DECL_TI_TEMPLATE (newdecl)</span>
<span class="lineNum">    1744 </span><span class="lineCov">        206 :                          != DECL_TI_TEMPLATE (olddecl))))</span>
<span class="lineNum">    1745 </span><span class="lineCov">     519300 :                 || (DECL_TEMPLATE_SPECIALIZATION (newdecl)</span>
<span class="lineNum">    1746 </span><span class="lineCov">      50480 :                     &amp;&amp; (!DECL_TEMPLATE_INFO (olddecl)</span>
<span class="lineNum">    1747 </span><span class="lineCov">      50480 :                         || (DECL_TI_TEMPLATE (olddecl)</span>
<span class="lineNum">    1748 </span><span class="lineCov">      50480 :                             != DECL_TI_TEMPLATE (newdecl))))))</span>
<span class="lineNum">    1749 </span>            :     /* It's OK to have a template specialization and a non-template
<span class="lineNum">    1750 </span>            :        with the same type, or to have specializations of two
<span class="lineNum">    1751 </span>            :        different templates with the same type.  Note that if one is a
<span class="lineNum">    1752 </span>            :        specialization, and the other is an instantiation of the same
<span class="lineNum">    1753 </span>            :        template, that we do not exit at this point.  That situation
<span class="lineNum">    1754 </span>            :        can occur if we instantiate a template class, and then
<span class="lineNum">    1755 </span>            :        specialize one of its methods.  This situation is valid, but
<span class="lineNum">    1756 </span>            :        the declarations must be merged in the usual way.  */
<span class="lineNum">    1757 </span>            :     return NULL_TREE;
<span class="lineNum">    1758 </span><span class="lineCov">     690550 :   else if (TREE_CODE (newdecl) == FUNCTION_DECL</span>
<span class="lineNum">    1759 </span><span class="lineCov">     690550 :            &amp;&amp; ((DECL_TEMPLATE_INSTANTIATION (olddecl)</span>
<span class="lineNum">    1760 </span><span class="lineCov">      50313 :                 &amp;&amp; !DECL_USE_TEMPLATE (newdecl))</span>
<span class="lineNum">    1761 </span><span class="lineCov">     519300 :                || (DECL_TEMPLATE_INSTANTIATION (newdecl)</span>
<span class="lineNum">    1762 </span><span class="lineCov">         78 :                    &amp;&amp; !DECL_USE_TEMPLATE (olddecl))))</span>
<span class="lineNum">    1763 </span>            :     /* One of the declarations is a template instantiation, and the
<span class="lineNum">    1764 </span>            :        other is not a template at all.  That's OK.  */
<span class="lineNum">    1765 </span>            :     return NULL_TREE;
<span class="lineNum">    1766 </span><span class="lineCov">     690550 :   else if (TREE_CODE (newdecl) == NAMESPACE_DECL)</span>
<span class="lineNum">    1767 </span>            :     {
<span class="lineNum">    1768 </span>            :       /* In [namespace.alias] we have:
<span class="lineNum">    1769 </span>            : 
<span class="lineNum">    1770 </span>            :            In a declarative region, a namespace-alias-definition can be
<span class="lineNum">    1771 </span>            :            used to redefine a namespace-alias declared in that declarative
<span class="lineNum">    1772 </span>            :            region to refer only to the namespace to which it already
<span class="lineNum">    1773 </span>            :            refers.
<span class="lineNum">    1774 </span>            : 
<span class="lineNum">    1775 </span>            :          Therefore, if we encounter a second alias directive for the same
<span class="lineNum">    1776 </span>            :          alias, we can just ignore the second directive.  */
<span class="lineNum">    1777 </span><span class="lineCov">         36 :       if (DECL_NAMESPACE_ALIAS (newdecl)</span>
<span class="lineNum">    1778 </span><span class="lineCov">         18 :           &amp;&amp; (DECL_NAMESPACE_ALIAS (newdecl)</span>
<span class="lineNum">    1779 </span><span class="lineCov">         15 :               == DECL_NAMESPACE_ALIAS (olddecl)))</span>
<span class="lineNum">    1780 </span><span class="lineCov">          9 :         return olddecl;</span>
<span class="lineNum">    1781 </span>            : 
<span class="lineNum">    1782 </span>            :       /* Leave it to update_binding to merge or report error.  */
<span class="lineNum">    1783 </span>            :       return NULL_TREE;
<span class="lineNum">    1784 </span>            :     }
<span class="lineNum">    1785 </span>            :   else
<span class="lineNum">    1786 </span>            :     {
<span class="lineNum">    1787 </span><span class="lineCov">     690532 :       const char *errmsg = redeclaration_error_message (newdecl, olddecl);</span>
<span class="lineNum">    1788 </span><span class="lineCov">     690532 :       if (errmsg)</span>
<span class="lineNum">    1789 </span>            :         {
<span class="lineNum">    1790 </span><span class="lineCov">        363 :           auto_diagnostic_group d;</span>
<span class="lineNum">    1791 </span><span class="lineCov">        363 :           error_at (newdecl_loc, errmsg, newdecl);</span>
<span class="lineNum">    1792 </span><span class="lineCov">        363 :           if (DECL_NAME (olddecl) != NULL_TREE)</span>
<span class="lineNum">    1793 </span><span class="lineCov">        363 :             inform (olddecl_loc,</span>
<span class="lineNum">    1794 </span><span class="lineCov">        363 :                     (DECL_INITIAL (olddecl) &amp;&amp; namespace_bindings_p ())</span>
<span class="lineNum">    1795 </span>            :                     ? G_(&quot;%q#D previously defined here&quot;)
<span class="lineNum">    1796 </span>            :                     : G_(&quot;%q#D previously declared here&quot;), olddecl);
<span class="lineNum">    1797 </span><span class="lineCov">        363 :           return error_mark_node;</span>
<span class="lineNum">    1798 </span>            :         }
<span class="lineNum">    1799 </span><span class="lineCov">     690169 :       else if (TREE_CODE (olddecl) == FUNCTION_DECL</span>
<span class="lineNum">    1800 </span><span class="lineCov">     519087 :                &amp;&amp; DECL_INITIAL (olddecl) != NULL_TREE</span>
<span class="lineNum">    1801 </span><span class="lineCov">       2000 :                &amp;&amp; !prototype_p (TREE_TYPE (olddecl))</span>
<span class="lineNum">    1802 </span><span class="lineCov">     690169 :                &amp;&amp; prototype_p (TREE_TYPE (newdecl)))</span>
<span class="lineNum">    1803 </span>            :         {
<span class="lineNum">    1804 </span>            :           /* Prototype decl follows defn w/o prototype.  */
<span class="lineNum">    1805 </span><span class="lineNoCov">          0 :           auto_diagnostic_group d;</span>
<span class="lineNum">    1806 </span><span class="lineNoCov">          0 :           if (warning_at (newdecl_loc, 0,</span>
<span class="lineNum">    1807 </span>            :                           &quot;prototype specified for %q#D&quot;, newdecl))
<span class="lineNum">    1808 </span><span class="lineNoCov">          0 :             inform (olddecl_loc,</span>
<span class="lineNum">    1809 </span>            :                     &quot;previous non-prototype definition here&quot;);
<span class="lineNum">    1810 </span>            :         }
<span class="lineNum">    1811 </span><span class="lineCov">     630699 :       else if (VAR_OR_FUNCTION_DECL_P (olddecl)</span>
<span class="lineNum">    1812 </span><span class="lineCov">    1209256 :                &amp;&amp; DECL_LANGUAGE (newdecl) != DECL_LANGUAGE (olddecl))</span>
<span class="lineNum">    1813 </span>            :         {
<span class="lineNum">    1814 </span>            :           /* [dcl.link]
<span class="lineNum">    1815 </span>            :              If two declarations of the same function or object
<span class="lineNum">    1816 </span>            :              specify different linkage-specifications ..., the program
<span class="lineNum">    1817 </span>            :              is ill-formed.... Except for functions with C++ linkage,
<span class="lineNum">    1818 </span>            :              a function declaration without a linkage specification
<span class="lineNum">    1819 </span>            :              shall not precede the first linkage specification for
<span class="lineNum">    1820 </span>            :              that function.  A function can be declared without a
<span class="lineNum">    1821 </span>            :              linkage specification after an explicit linkage
<span class="lineNum">    1822 </span>            :              specification has been seen; the linkage explicitly
<span class="lineNum">    1823 </span>            :              specified in the earlier declaration is not affected by
<span class="lineNum">    1824 </span>            :              such a function declaration.
<span class="lineNum">    1825 </span>            : 
<span class="lineNum">    1826 </span>            :              DR 563 raises the question why the restrictions on
<span class="lineNum">    1827 </span>            :              functions should not also apply to objects.  Older
<span class="lineNum">    1828 </span>            :              versions of G++ silently ignore the linkage-specification
<span class="lineNum">    1829 </span>            :              for this example:
<span class="lineNum">    1830 </span>            : 
<span class="lineNum">    1831 </span>            :                namespace N { 
<span class="lineNum">    1832 </span>            :                  extern int i;
<span class="lineNum">    1833 </span>            :                  extern &quot;C&quot; int i;
<span class="lineNum">    1834 </span>            :                }
<span class="lineNum">    1835 </span>            : 
<span class="lineNum">    1836 </span>            :              which is clearly wrong.  Therefore, we now treat objects
<span class="lineNum">    1837 </span>            :              like functions.  */
<span class="lineNum">    1838 </span><span class="lineCov">       1319 :           if (current_lang_depth () == 0)</span>
<span class="lineNum">    1839 </span>            :             {
<span class="lineNum">    1840 </span>            :               /* There is no explicit linkage-specification, so we use
<span class="lineNum">    1841 </span>            :                  the linkage from the previous declaration.  */
<span class="lineNum">    1842 </span><span class="lineCov">       1313 :               retrofit_lang_decl (newdecl);</span>
<span class="lineNum">    1843 </span><span class="lineCov">       1313 :               SET_DECL_LANGUAGE (newdecl, DECL_LANGUAGE (olddecl));</span>
<span class="lineNum">    1844 </span>            :             }
<span class="lineNum">    1845 </span>            :           else
<span class="lineNum">    1846 </span>            :             {
<span class="lineNum">    1847 </span><span class="lineCov">         12 :               auto_diagnostic_group d;</span>
<span class="lineNum">    1848 </span><span class="lineCov">          6 :               error_at (newdecl_loc,</span>
<span class="lineNum">    1849 </span>            :                         &quot;conflicting declaration of %q#D with %qL linkage&quot;,
<span class="lineNum">    1850 </span><span class="lineCov">          6 :                         newdecl, DECL_LANGUAGE (newdecl));</span>
<span class="lineNum">    1851 </span><span class="lineCov">          6 :               inform (olddecl_loc,</span>
<span class="lineNum">    1852 </span>            :                       &quot;previous declaration with %qL linkage&quot;,
<span class="lineNum">    1853 </span><span class="lineCov">          6 :                       DECL_LANGUAGE (olddecl));</span>
<span class="lineNum">    1854 </span>            :             }
<span class="lineNum">    1855 </span>            :         }
<span class="lineNum">    1856 </span>            : 
<span class="lineNum">    1857 </span><span class="lineCov">     690169 :       if (DECL_LANG_SPECIFIC (olddecl) &amp;&amp; DECL_USE_TEMPLATE (olddecl))</span>
<span class="lineNum">    1858 </span>            :         ;
<span class="lineNum">    1859 </span><span class="lineCov">     638820 :       else if (TREE_CODE (olddecl) == FUNCTION_DECL)</span>
<span class="lineNum">    1860 </span>            :         {
<span class="lineNum">    1861 </span>            :           /* Note: free functions, as TEMPLATE_DECLs, are handled below.  */
<span class="lineNum">    1862 </span><span class="lineCov">     616887 :           if (DECL_FUNCTION_MEMBER_P (olddecl)</span>
<span class="lineNum">    1863 </span><span class="lineCov">     468575 :               &amp;&amp; (/* grokfndecl passes member function templates too</span>
<span class="lineNum">    1864 </span>            :                      as FUNCTION_DECLs.  */
<span class="lineNum">    1865 </span><span class="lineCov">     340098 :                   DECL_TEMPLATE_INFO (olddecl)</span>
<span class="lineNum">    1866 </span>            :                   /* C++11 8.3.6/6.
<span class="lineNum">    1867 </span>            :                      Default arguments for a member function of a class
<span class="lineNum">    1868 </span>            :                      template shall be specified on the initial declaration
<span class="lineNum">    1869 </span>            :                      of the member function within the class template.  */
<span class="lineNum">    1870 </span><span class="lineCov">      29150 :                   || CLASSTYPE_TEMPLATE_INFO (CP_DECL_CONTEXT (olddecl))))</span>
<span class="lineNum">    1871 </span><span class="lineCov">     315231 :             check_redeclaration_no_default_args (newdecl);</span>
<span class="lineNum">    1872 </span>            :           else
<span class="lineNum">    1873 </span>            :             {
<span class="lineNum">    1874 </span><span class="lineCov">     330772 :               tree t1 = FUNCTION_FIRST_USER_PARMTYPE (olddecl);</span>
<span class="lineNum">    1875 </span><span class="lineCov">     153344 :               tree t2 = FUNCTION_FIRST_USER_PARMTYPE (newdecl);</span>
<span class="lineNum">    1876 </span><span class="lineCov">     153344 :               int i = 1;</span>
<span class="lineNum">    1877 </span>            : 
<span class="lineNum">    1878 </span><span class="lineCov">     429336 :               for (; t1 &amp;&amp; t1 != void_list_node;</span>
<span class="lineNum">    1879 </span><span class="lineCov">     275992 :                    t1 = TREE_CHAIN (t1), t2 = TREE_CHAIN (t2), i++)</span>
<span class="lineNum">    1880 </span><span class="lineCov">     275992 :                 if (TREE_PURPOSE (t1) &amp;&amp; TREE_PURPOSE (t2))</span>
<span class="lineNum">    1881 </span>            :                   {
<span class="lineNum">    1882 </span><span class="lineCov">         39 :                     if (simple_cst_equal (TREE_PURPOSE (t1),</span>
<span class="lineNum">    1883 </span><span class="lineCov">         78 :                                           TREE_PURPOSE (t2)) == 1)</span>
<span class="lineNum">    1884 </span>            :                       {
<span class="lineNum">    1885 </span><span class="lineCov">         30 :                         auto_diagnostic_group d;</span>
<span class="lineNum">    1886 </span><span class="lineCov">         15 :                         if (permerror (newdecl_loc,</span>
<span class="lineNum">    1887 </span>            :                                        &quot;default argument given for parameter &quot;
<span class="lineNum">    1888 </span>            :                                        &quot;%d of %q#D&quot;, i, newdecl))
<span class="lineNum">    1889 </span><span class="lineCov">         15 :                           inform (olddecl_loc,</span>
<span class="lineNum">    1890 </span>            :                                   &quot;previous specification in %q#D here&quot;,
<span class="lineNum">    1891 </span>            :                                   olddecl);
<span class="lineNum">    1892 </span>            :                       }
<span class="lineNum">    1893 </span>            :                     else
<span class="lineNum">    1894 </span>            :                       {
<span class="lineNum">    1895 </span><span class="lineCov">         48 :                         auto_diagnostic_group d;</span>
<span class="lineNum">    1896 </span><span class="lineCov">         24 :                         error_at (newdecl_loc,</span>
<span class="lineNum">    1897 </span>            :                                   &quot;default argument given for parameter %d &quot;
<span class="lineNum">    1898 </span>            :                                   &quot;of %q#D&quot;, i, newdecl);
<span class="lineNum">    1899 </span><span class="lineCov">         24 :                         inform (olddecl_loc,</span>
<span class="lineNum">    1900 </span>            :                                 &quot;previous specification in %q#D here&quot;,
<span class="lineNum">    1901 </span>            :                                 olddecl);
<span class="lineNum">    1902 </span>            :                       }
<span class="lineNum">    1903 </span>            :                   }
<span class="lineNum">    1904 </span>            : 
<span class="lineNum">    1905 </span>            :               /* C++17 11.3.6/4: &quot;If a friend declaration specifies a default
<span class="lineNum">    1906 </span>            :                  argument expression, that declaration... shall be the only
<span class="lineNum">    1907 </span>            :                  declaration of the function or function template in the
<span class="lineNum">    1908 </span>            :                  translation unit.&quot;  */
<span class="lineNum">    1909 </span><span class="lineCov">     153344 :               check_no_redeclaration_friend_default_args</span>
<span class="lineNum">    1910 </span><span class="lineCov">     153344 :                 (olddecl, newdecl, DECL_HIDDEN_FRIEND_P (olddecl));</span>
<span class="lineNum">    1911 </span>            :             }
<span class="lineNum">    1912 </span>            :         }
<span class="lineNum">    1913 </span>            :     }
<span class="lineNum">    1914 </span>            : 
<span class="lineNum">    1915 </span>            :   /* Do not merge an implicit typedef with an explicit one.  In:
<span class="lineNum">    1916 </span>            : 
<span class="lineNum">    1917 </span>            :        class A;
<span class="lineNum">    1918 </span>            :        ...
<span class="lineNum">    1919 </span>            :        typedef class A A __attribute__ ((foo));
<span class="lineNum">    1920 </span>            : 
<span class="lineNum">    1921 </span>            :      the attribute should apply only to the typedef.  */
<span class="lineNum">    1922 </span><span class="lineCov">     946960 :   if (TREE_CODE (olddecl) == TYPE_DECL</span>
<span class="lineNum">    1923 </span><span class="lineCov">     946960 :       &amp;&amp; (DECL_IMPLICIT_TYPEDEF_P (olddecl)</span>
<span class="lineNum">    1924 </span><span class="lineCov">       3055 :           || DECL_IMPLICIT_TYPEDEF_P (newdecl)))</span>
<span class="lineNum">    1925 </span>            :     return NULL_TREE;
<span class="lineNum">    1926 </span>            : 
<span class="lineNum">    1927 </span>            :   /* If new decl is `static' and an `extern' was seen previously,
<span class="lineNum">    1928 </span>            :      warn about it.  */
<span class="lineNum">    1929 </span><span class="lineCov">     942350 :   warn_extern_redeclared_static (newdecl, olddecl);</span>
<span class="lineNum">    1930 </span>            : 
<span class="lineNum">    1931 </span><span class="lineCov">     942350 :   if (!validate_constexpr_redeclaration (olddecl, newdecl))</span>
<span class="lineNum">    1932 </span><span class="lineCov">          4 :     return error_mark_node;</span>
<span class="lineNum">    1933 </span>            : 
<span class="lineNum">    1934 </span>            :   /* We have committed to returning 1 at this point.  */
<span class="lineNum">    1935 </span><span class="lineCov">     942346 :   if (TREE_CODE (newdecl) == FUNCTION_DECL)</span>
<span class="lineNum">    1936 </span>            :     {
<span class="lineNum">    1937 </span>            :       /* Now that functions must hold information normally held
<span class="lineNum">    1938 </span>            :          by field decls, there is extra work to do so that
<span class="lineNum">    1939 </span>            :          declaration information does not get destroyed during
<span class="lineNum">    1940 </span>            :          definition.  */
<span class="lineNum">    1941 </span><span class="lineCov">     775874 :       if (DECL_VINDEX (olddecl))</span>
<span class="lineNum">    1942 </span><span class="lineCov">      30537 :         DECL_VINDEX (newdecl) = DECL_VINDEX (olddecl);</span>
<span class="lineNum">    1943 </span><span class="lineCov">     775874 :       if (DECL_CONTEXT (olddecl))</span>
<span class="lineNum">    1944 </span><span class="lineCov">    1068592 :         DECL_CONTEXT (newdecl) = DECL_CONTEXT (olddecl);</span>
<span class="lineNum">    1945 </span><span class="lineCov">     775874 :       DECL_STATIC_CONSTRUCTOR (newdecl) |= DECL_STATIC_CONSTRUCTOR (olddecl);</span>
<span class="lineNum">    1946 </span><span class="lineCov">     775874 :       DECL_STATIC_DESTRUCTOR (newdecl) |= DECL_STATIC_DESTRUCTOR (olddecl);</span>
<span class="lineNum">    1947 </span><span class="lineCov">     775874 :       DECL_PURE_VIRTUAL_P (newdecl) |= DECL_PURE_VIRTUAL_P (olddecl);</span>
<span class="lineNum">    1948 </span><span class="lineCov">     775874 :       DECL_VIRTUAL_P (newdecl) |= DECL_VIRTUAL_P (olddecl);</span>
<span class="lineNum">    1949 </span><span class="lineCov">     775874 :       DECL_INVALID_OVERRIDER_P (newdecl) |= DECL_INVALID_OVERRIDER_P (olddecl);</span>
<span class="lineNum">    1950 </span><span class="lineCov">     775874 :       DECL_FINAL_P (newdecl) |= DECL_FINAL_P (olddecl);</span>
<span class="lineNum">    1951 </span><span class="lineCov">    1551748 :       DECL_OVERRIDE_P (newdecl) |= DECL_OVERRIDE_P (olddecl);</span>
<span class="lineNum">    1952 </span><span class="lineCov">    1551748 :       DECL_THIS_STATIC (newdecl) |= DECL_THIS_STATIC (olddecl);</span>
<span class="lineNum">    1953 </span><span class="lineCov">     775874 :       if (DECL_OVERLOADED_OPERATOR_P (olddecl))</span>
<span class="lineNum">    1954 </span><span class="lineCov">      72848 :         DECL_OVERLOADED_OPERATOR_CODE_RAW (newdecl)</span>
<span class="lineNum">    1955 </span><span class="lineCov">     145696 :           = DECL_OVERLOADED_OPERATOR_CODE_RAW (olddecl);</span>
<span class="lineNum">    1956 </span><span class="lineCov">     775874 :       new_defines_function = DECL_INITIAL (newdecl) != NULL_TREE;</span>
<span class="lineNum">    1957 </span>            : 
<span class="lineNum">    1958 </span>            :       /* Optionally warn about more than one declaration for the same
<span class="lineNum">    1959 </span>            :          name, but don't warn about a function declaration followed by a
<span class="lineNum">    1960 </span>            :          definition.  */
<span class="lineNum">    1961 </span><span class="lineCov">         27 :       if (warn_redundant_decls &amp;&amp; ! DECL_ARTIFICIAL (olddecl)</span>
<span class="lineNum">    1962 </span><span class="lineCov">         27 :           &amp;&amp; !(new_defines_function &amp;&amp; DECL_INITIAL (olddecl) == NULL_TREE)</span>
<span class="lineNum">    1963 </span>            :           /* Don't warn about extern decl followed by definition.  */
<span class="lineNum">    1964 </span><span class="lineCov">         54 :           &amp;&amp; !(DECL_EXTERNAL (olddecl) &amp;&amp; ! DECL_EXTERNAL (newdecl))</span>
<span class="lineNum">    1965 </span>            :           /* Don't warn about friends, let add_friend take care of it.  */
<span class="lineNum">    1966 </span><span class="lineCov">         57 :           &amp;&amp; ! (newdecl_is_friend || DECL_FRIEND_P (olddecl))</span>
<span class="lineNum">    1967 </span>            :           /* Don't warn about declaration followed by specialization.  */
<span class="lineNum">    1968 </span><span class="lineCov">     775898 :           &amp;&amp; (! DECL_TEMPLATE_SPECIALIZATION (newdecl)</span>
<span class="lineNum">    1969 </span><span class="lineCov">         18 :               || DECL_TEMPLATE_SPECIALIZATION (olddecl)))</span>
<span class="lineNum">    1970 </span>            :         {
<span class="lineNum">    1971 </span><span class="lineCov">         12 :           auto_diagnostic_group d;</span>
<span class="lineNum">    1972 </span><span class="lineCov">          6 :           if (warning_at (newdecl_loc,</span>
<span class="lineNum">    1973 </span>            :                           OPT_Wredundant_decls,
<span class="lineNum">    1974 </span>            :                           &quot;redundant redeclaration of %qD in same scope&quot;,
<span class="lineNum">    1975 </span>            :                           newdecl))
<span class="lineNum">    1976 </span><span class="lineCov">          6 :             inform (olddecl_loc,</span>
<span class="lineNum">    1977 </span>            :                     &quot;previous declaration of %qD&quot;, olddecl);
<span class="lineNum">    1978 </span>            :         }
<span class="lineNum">    1979 </span>            : 
<span class="lineNum">    1980 </span><span class="lineCov">     775874 :       if (!(DECL_TEMPLATE_INSTANTIATION (olddecl)</span>
<span class="lineNum">    1981 </span><span class="lineCov">      50313 :             &amp;&amp; DECL_TEMPLATE_SPECIALIZATION (newdecl)))</span>
<span class="lineNum">    1982 </span>            :         {
<span class="lineNum">    1983 </span><span class="lineCov">     725600 :           if (DECL_DELETED_FN (newdecl))</span>
<span class="lineNum">    1984 </span>            :             {
<span class="lineNum">    1985 </span><span class="lineCov">         16 :               auto_diagnostic_group d;</span>
<span class="lineNum">    1986 </span><span class="lineCov">          8 :               error_at (newdecl_loc, &quot;deleted definition of %qD&quot;, newdecl);</span>
<span class="lineNum">    1987 </span><span class="lineCov">          8 :               inform (olddecl_loc,</span>
<span class="lineNum">    1988 </span>            :                       &quot;previous declaration of %qD&quot;, olddecl);
<span class="lineNum">    1989 </span>            :             }
<span class="lineNum">    1990 </span><span class="lineCov">     725600 :           DECL_DELETED_FN (newdecl) |= DECL_DELETED_FN (olddecl);</span>
<span class="lineNum">    1991 </span>            :         }
<span class="lineNum">    1992 </span>            :     }
<span class="lineNum">    1993 </span>            : 
<span class="lineNum">    1994 </span>            :   /* Deal with C++: must preserve virtual function table size.  */
<span class="lineNum">    1995 </span><span class="lineCov">     942346 :   if (TREE_CODE (olddecl) == TYPE_DECL)</span>
<span class="lineNum">    1996 </span>            :     {
<span class="lineNum">    1997 </span><span class="lineCov">       3055 :       tree newtype = TREE_TYPE (newdecl);</span>
<span class="lineNum">    1998 </span><span class="lineCov">       3055 :       tree oldtype = TREE_TYPE (olddecl);</span>
<span class="lineNum">    1999 </span>            : 
<span class="lineNum">    2000 </span><span class="lineCov">       3055 :       if (newtype != error_mark_node &amp;&amp; oldtype != error_mark_node</span>
<span class="lineNum">    2001 </span><span class="lineCov">       6110 :           &amp;&amp; TYPE_LANG_SPECIFIC (newtype) &amp;&amp; TYPE_LANG_SPECIFIC (oldtype))</span>
<span class="lineNum">    2002 </span><span class="lineCov">        354 :         CLASSTYPE_FRIEND_CLASSES (newtype)</span>
<span class="lineNum">    2003 </span><span class="lineCov">        354 :           = CLASSTYPE_FRIEND_CLASSES (oldtype);</span>
<span class="lineNum">    2004 </span>            : 
<span class="lineNum">    2005 </span><span class="lineCov">       3055 :       DECL_ORIGINAL_TYPE (newdecl) = DECL_ORIGINAL_TYPE (olddecl);</span>
<span class="lineNum">    2006 </span>            :     }
<span class="lineNum">    2007 </span>            : 
<span class="lineNum">    2008 </span>            :   /* Copy all the DECL_... slots specified in the new decl except for
<span class="lineNum">    2009 </span>            :      any that we copy here from the old type.  */
<span class="lineNum">    2010 </span><span class="lineCov">     942346 :   if (merge_attr)</span>
<span class="lineNum">    2011 </span><span class="lineCov">    2676216 :     DECL_ATTRIBUTES (newdecl)</span>
<span class="lineNum">    2012 </span><span class="lineCov">     892072 :       = (*targetm.merge_decl_attributes) (olddecl, newdecl);</span>
<span class="lineNum">    2013 </span>            :   else
<span class="lineNum">    2014 </span><span class="lineCov">      50274 :     DECL_ATTRIBUTES (olddecl) = DECL_ATTRIBUTES (newdecl);</span>
<span class="lineNum">    2015 </span>            : 
<span class="lineNum">    2016 </span><span class="lineCov">     942346 :   if (DECL_DECLARES_FUNCTION_P (olddecl) &amp;&amp; DECL_DECLARES_FUNCTION_P (newdecl))</span>
<span class="lineNum">    2017 </span>            :     {
<span class="lineNum">    2018 </span><span class="lineCov">    1759638 :       olddecl_friend = DECL_FRIEND_P (olddecl);</span>
<span class="lineNum">    2019 </span><span class="lineCov">    1759638 :       olddecl_hidden_friend = DECL_HIDDEN_FRIEND_P (olddecl);</span>
<span class="lineNum">    2020 </span><span class="lineCov">    1759638 :       hidden_friend = (DECL_ANTICIPATED (olddecl)</span>
<span class="lineNum">    2021 </span><span class="lineCov">    1003296 :                        &amp;&amp; DECL_HIDDEN_FRIEND_P (olddecl)</span>
<span class="lineNum">    2022 </span><span class="lineCov">     889055 :                        &amp;&amp; newdecl_is_friend);</span>
<span class="lineNum">    2023 </span><span class="lineCov">     877115 :       if (!hidden_friend)</span>
<span class="lineNum">    2024 </span>            :         {
<span class="lineNum">    2025 </span><span class="lineCov">    1754230 :           DECL_ANTICIPATED (olddecl) = 0;</span>
<span class="lineNum">    2026 </span><span class="lineCov">     877115 :           DECL_HIDDEN_FRIEND_P (olddecl) = 0;</span>
<span class="lineNum">    2027 </span>            :         }
<span class="lineNum">    2028 </span>            :     }
<span class="lineNum">    2029 </span>            : 
<span class="lineNum">    2030 </span><span class="lineCov">     942346 :   if (TREE_CODE (newdecl) == TEMPLATE_DECL)</span>
<span class="lineNum">    2031 </span>            :     {
<span class="lineNum">    2032 </span><span class="lineCov">     103947 :       tree old_result = DECL_TEMPLATE_RESULT (olddecl);</span>
<span class="lineNum">    2033 </span><span class="lineCov">     103947 :       tree new_result = DECL_TEMPLATE_RESULT (newdecl);</span>
<span class="lineNum">    2034 </span><span class="lineCov">     103947 :       TREE_TYPE (olddecl) = TREE_TYPE (old_result);</span>
<span class="lineNum">    2035 </span><span class="lineCov">     103947 :       DECL_TEMPLATE_SPECIALIZATIONS (olddecl)</span>
<span class="lineNum">    2036 </span><span class="lineCov">     103947 :         = chainon (DECL_TEMPLATE_SPECIALIZATIONS (olddecl),</span>
<span class="lineNum">    2037 </span><span class="lineCov">     103947 :                    DECL_TEMPLATE_SPECIALIZATIONS (newdecl));</span>
<span class="lineNum">    2038 </span>            : 
<span class="lineNum">    2039 </span><span class="lineCov">     311841 :       DECL_ATTRIBUTES (old_result)</span>
<span class="lineNum">    2040 </span><span class="lineCov">     103947 :         = (*targetm.merge_decl_attributes) (old_result, new_result);</span>
<span class="lineNum">    2041 </span>            : 
<span class="lineNum">    2042 </span><span class="lineCov">     103947 :       if (DECL_FUNCTION_TEMPLATE_P (newdecl))</span>
<span class="lineNum">    2043 </span>            :         {
<span class="lineNum">    2044 </span><span class="lineCov">     103945 :           if (DECL_SOURCE_LOCATION (newdecl)</span>
<span class="lineNum">    2045 </span><span class="lineCov">     103945 :               != DECL_SOURCE_LOCATION (olddecl))</span>
<span class="lineNum">    2046 </span>            :             {
<span class="lineNum">    2047 </span>            :               /* Per C++11 8.3.6/4, default arguments cannot be added in
<span class="lineNum">    2048 </span>            :                  later declarations of a function template.  */
<span class="lineNum">    2049 </span><span class="lineCov">     101272 :               check_redeclaration_no_default_args (newdecl);</span>
<span class="lineNum">    2050 </span>            :               /* C++17 11.3.6/4: &quot;If a friend declaration specifies a default
<span class="lineNum">    2051 </span>            :                  argument expression, that declaration... shall be the only
<span class="lineNum">    2052 </span>            :                  declaration of the function or function template in the
<span class="lineNum">    2053 </span>            :                  translation unit.&quot;  */
<span class="lineNum">    2054 </span><span class="lineCov">     101272 :               check_no_redeclaration_friend_default_args</span>
<span class="lineNum">    2055 </span><span class="lineCov">     101272 :                 (old_result, new_result, olddecl_hidden_friend);</span>
<span class="lineNum">    2056 </span>            :             }
<span class="lineNum">    2057 </span>            : 
<span class="lineNum">    2058 </span><span class="lineCov">     103945 :           check_default_args (newdecl);</span>
<span class="lineNum">    2059 </span>            : 
<span class="lineNum">    2060 </span><span class="lineCov">     123277 :           if (GNU_INLINE_P (old_result) != GNU_INLINE_P (new_result)</span>
<span class="lineNum">    2061 </span><span class="lineCov">     103945 :               &amp;&amp; DECL_INITIAL (new_result))</span>
<span class="lineNum">    2062 </span>            :             {
<span class="lineNum">    2063 </span><span class="lineCov">         24 :               if (DECL_INITIAL (old_result))</span>
<span class="lineNum">    2064 </span><span class="lineCov">         12 :                 DECL_UNINLINABLE (old_result) = 1;</span>
<span class="lineNum">    2065 </span>            :               else
<span class="lineNum">    2066 </span><span class="lineCov">         12 :                 DECL_UNINLINABLE (old_result) = DECL_UNINLINABLE (new_result);</span>
<span class="lineNum">    2067 </span><span class="lineCov">         24 :               DECL_EXTERNAL (old_result) = DECL_EXTERNAL (new_result);</span>
<span class="lineNum">    2068 </span><span class="lineCov">         72 :               DECL_NOT_REALLY_EXTERN (old_result)</span>
<span class="lineNum">    2069 </span><span class="lineCov">         24 :                 = DECL_NOT_REALLY_EXTERN (new_result);</span>
<span class="lineNum">    2070 </span><span class="lineCov">         72 :               DECL_INTERFACE_KNOWN (old_result)</span>
<span class="lineNum">    2071 </span><span class="lineCov">         24 :                 = DECL_INTERFACE_KNOWN (new_result);</span>
<span class="lineNum">    2072 </span><span class="lineCov">         72 :               DECL_DECLARED_INLINE_P (old_result)</span>
<span class="lineNum">    2073 </span><span class="lineCov">         24 :                 = DECL_DECLARED_INLINE_P (new_result);</span>
<span class="lineNum">    2074 </span><span class="lineCov">         72 :               DECL_DISREGARD_INLINE_LIMITS (old_result)</span>
<span class="lineNum">    2075 </span><span class="lineCov">         24 :                 |= DECL_DISREGARD_INLINE_LIMITS (new_result);</span>
<span class="lineNum">    2076 </span>            : 
<span class="lineNum">    2077 </span>            :             }
<span class="lineNum">    2078 </span>            :           else
<span class="lineNum">    2079 </span>            :             {
<span class="lineNum">    2080 </span><span class="lineCov">     311763 :               DECL_DECLARED_INLINE_P (old_result)</span>
<span class="lineNum">    2081 </span><span class="lineCov">     103921 :                 |= DECL_DECLARED_INLINE_P (new_result);</span>
<span class="lineNum">    2082 </span><span class="lineCov">     311763 :               DECL_DISREGARD_INLINE_LIMITS (old_result)</span>
<span class="lineNum">    2083 </span><span class="lineCov">     103921 :                 |= DECL_DISREGARD_INLINE_LIMITS (new_result);</span>
<span class="lineNum">    2084 </span><span class="lineCov">     103921 :               check_redeclaration_exception_specification (newdecl, olddecl);</span>
<span class="lineNum">    2085 </span>            : 
<span class="lineNum">    2086 </span><span class="lineCov">     103921 :               merge_attribute_bits (new_result, old_result);</span>
<span class="lineNum">    2087 </span>            :             }
<span class="lineNum">    2088 </span>            :         }
<span class="lineNum">    2089 </span>            : 
<span class="lineNum">    2090 </span>            :       /* If the new declaration is a definition, update the file and
<span class="lineNum">    2091 </span>            :          line information on the declaration, and also make
<span class="lineNum">    2092 </span>            :          the old declaration the same definition.  */
<span class="lineNum">    2093 </span><span class="lineCov">     103947 :       if (DECL_INITIAL (new_result) != NULL_TREE)</span>
<span class="lineNum">    2094 </span>            :         {
<span class="lineNum">    2095 </span><span class="lineCov">     213828 :           DECL_SOURCE_LOCATION (olddecl)</span>
<span class="lineNum">    2096 </span><span class="lineCov">     213828 :             = DECL_SOURCE_LOCATION (old_result)</span>
<span class="lineNum">    2097 </span><span class="lineCov">      71276 :             = DECL_SOURCE_LOCATION (newdecl);</span>
<span class="lineNum">    2098 </span><span class="lineCov">      71276 :           DECL_INITIAL (old_result) = DECL_INITIAL (new_result);</span>
<span class="lineNum">    2099 </span><span class="lineCov">      71276 :           if (DECL_FUNCTION_TEMPLATE_P (newdecl))</span>
<span class="lineNum">    2100 </span>            :             {
<span class="lineNum">    2101 </span><span class="lineCov">      71276 :               tree parm;</span>
<span class="lineNum">    2102 </span><span class="lineCov">     213828 :               DECL_ARGUMENTS (old_result)</span>
<span class="lineNum">    2103 </span><span class="lineCov">      71276 :                 = DECL_ARGUMENTS (new_result);</span>
<span class="lineNum">    2104 </span><span class="lineCov">     315637 :               for (parm = DECL_ARGUMENTS (old_result); parm;</span>
<span class="lineNum">    2105 </span><span class="lineCov">     173085 :                    parm = DECL_CHAIN (parm))</span>
<span class="lineNum">    2106 </span><span class="lineCov">     173085 :                 DECL_CONTEXT (parm) = old_result;</span>
<span class="lineNum">    2107 </span>            :             }
<span class="lineNum">    2108 </span>            :         }
<span class="lineNum">    2109 </span>            : 
<span class="lineNum">    2110 </span><span class="lineCov">     103947 :       return olddecl;</span>
<span class="lineNum">    2111 </span>            :     }
<span class="lineNum">    2112 </span>            : 
<span class="lineNum">    2113 </span><span class="lineCov">     838399 :   if (types_match)</span>
<span class="lineNum">    2114 </span>            :     {
<span class="lineNum">    2115 </span><span class="lineCov">     838198 :       if (TREE_CODE (newdecl) == FUNCTION_DECL)</span>
<span class="lineNum">    2116 </span><span class="lineCov">     775673 :         check_redeclaration_exception_specification (newdecl, olddecl);</span>
<span class="lineNum">    2117 </span>            : 
<span class="lineNum">    2118 </span>            :       /* Automatically handles default parameters.  */
<span class="lineNum">    2119 </span><span class="lineCov">     838198 :       tree oldtype = TREE_TYPE (olddecl);</span>
<span class="lineNum">    2120 </span><span class="lineCov">     838198 :       tree newtype;</span>
<span class="lineNum">    2121 </span>            : 
<span class="lineNum">    2122 </span>            :       /* For typedefs use the old type, as the new type's DECL_NAME points
<span class="lineNum">    2123 </span>            :          at newdecl, which will be ggc_freed.  */
<span class="lineNum">    2124 </span><span class="lineCov">     838198 :       if (TREE_CODE (newdecl) == TYPE_DECL)</span>
<span class="lineNum">    2125 </span>            :         {
<span class="lineNum">    2126 </span>            :           /* But NEWTYPE might have an attribute, honor that.  */
<span class="lineNum">    2127 </span><span class="lineCov">       3055 :           tree tem = TREE_TYPE (newdecl);</span>
<span class="lineNum">    2128 </span><span class="lineCov">       3055 :           newtype = oldtype;</span>
<span class="lineNum">    2129 </span>            : 
<span class="lineNum">    2130 </span><span class="lineCov">       3055 :           if (TYPE_USER_ALIGN (tem))</span>
<span class="lineNum">    2131 </span>            :             {
<span class="lineNum">    2132 </span><span class="lineCov">         24 :               if (TYPE_ALIGN (tem) &gt; TYPE_ALIGN (newtype))</span>
<span class="lineNum">    2133 </span><span class="lineCov">          8 :                 SET_TYPE_ALIGN (newtype, TYPE_ALIGN (tem));</span>
<span class="lineNum">    2134 </span><span class="lineCov">         12 :               TYPE_USER_ALIGN (newtype) = true;</span>
<span class="lineNum">    2135 </span>            :             }
<span class="lineNum">    2136 </span>            : 
<span class="lineNum">    2137 </span>            :           /* And remove the new type from the variants list.  */
<span class="lineNum">    2138 </span><span class="lineCov">       3055 :           if (TYPE_NAME (TREE_TYPE (newdecl)) == newdecl)</span>
<span class="lineNum">    2139 </span>            :             {
<span class="lineNum">    2140 </span><span class="lineCov">         12 :               tree remove = TREE_TYPE (newdecl);</span>
<span class="lineNum">    2141 </span><span class="lineCov">         24 :               for (tree t = TYPE_MAIN_VARIANT (remove); ;</span>
<span class="lineNum">    2142 </span>            :                    t = TYPE_NEXT_VARIANT (t))
<span class="lineNum">    2143 </span><span class="lineCov">         12 :                 if (TYPE_NEXT_VARIANT (t) == remove)</span>
<span class="lineNum">    2144 </span>            :                   {
<span class="lineNum">    2145 </span><span class="lineCov">         24 :                     TYPE_NEXT_VARIANT (t) = TYPE_NEXT_VARIANT (remove);</span>
<span class="lineNum">    2146 </span><span class="lineCov">         12 :                     break;</span>
<span class="lineNum">    2147 </span>            :                   }
<span class="lineNum">    2148 </span>            :             }
<span class="lineNum">    2149 </span>            :         }
<span class="lineNum">    2150 </span><span class="lineCov">     835143 :       else if (merge_attr)</span>
<span class="lineNum">    2151 </span><span class="lineCov">    1569738 :         newtype = merge_types (TREE_TYPE (newdecl), TREE_TYPE (olddecl));</span>
<span class="lineNum">    2152 </span>            :       else
<span class="lineNum">    2153 </span><span class="lineCov">      50274 :         newtype = TREE_TYPE (newdecl);</span>
<span class="lineNum">    2154 </span>            : 
<span class="lineNum">    2155 </span><span class="lineCov">     838198 :       if (VAR_P (newdecl))</span>
<span class="lineNum">    2156 </span>            :         {
<span class="lineNum">    2157 </span><span class="lineCov">      59470 :           DECL_THIS_EXTERN (newdecl) |= DECL_THIS_EXTERN (olddecl);</span>
<span class="lineNum">    2158 </span>            :           /* For already initialized vars, TREE_READONLY could have been
<span class="lineNum">    2159 </span>            :              cleared in cp_finish_decl, because the var needs runtime
<span class="lineNum">    2160 </span>            :              initialization or destruction.  Make sure not to set
<span class="lineNum">    2161 </span>            :              TREE_READONLY on it again.  */
<span class="lineNum">    2162 </span><span class="lineCov">      59470 :           if (DECL_INITIALIZED_P (olddecl)</span>
<span class="lineNum">    2163 </span><span class="lineCov">       1117 :               &amp;&amp; !DECL_EXTERNAL (olddecl)</span>
<span class="lineNum">    2164 </span><span class="lineCov">      59511 :               &amp;&amp; !TREE_READONLY (olddecl))</span>
<span class="lineNum">    2165 </span><span class="lineCov">         22 :             TREE_READONLY (newdecl) = 0;</span>
<span class="lineNum">    2166 </span><span class="lineCov">      59470 :           DECL_INITIALIZED_P (newdecl) |= DECL_INITIALIZED_P (olddecl);</span>
<span class="lineNum">    2167 </span><span class="lineCov">      59470 :           DECL_NONTRIVIALLY_INITIALIZED_P (newdecl)</span>
<span class="lineNum">    2168 </span><span class="lineCov">      59470 :             |= DECL_NONTRIVIALLY_INITIALIZED_P (olddecl);</span>
<span class="lineNum">    2169 </span><span class="lineCov">      59470 :           if (DECL_DEPENDENT_INIT_P (olddecl))</span>
<span class="lineNum">    2170 </span><span class="lineCov">      42614 :             SET_DECL_DEPENDENT_INIT_P (newdecl, true);</span>
<span class="lineNum">    2171 </span><span class="lineCov">      59470 :           DECL_INITIALIZED_BY_CONSTANT_EXPRESSION_P (newdecl)</span>
<span class="lineNum">    2172 </span><span class="lineCov">      59470 :             |= DECL_INITIALIZED_BY_CONSTANT_EXPRESSION_P (olddecl);</span>
<span class="lineNum">    2173 </span><span class="lineCov">      59470 :           if (DECL_CLASS_SCOPE_P (olddecl))</span>
<span class="lineNum">    2174 </span><span class="lineCov">      56565 :             DECL_DECLARED_CONSTEXPR_P (newdecl)</span>
<span class="lineNum">    2175 </span><span class="lineCov">     113130 :               |= DECL_DECLARED_CONSTEXPR_P (olddecl);</span>
<span class="lineNum">    2176 </span>            : 
<span class="lineNum">    2177 </span>            :           /* Merge the threadprivate attribute from OLDDECL into NEWDECL.  */
<span class="lineNum">    2178 </span><span class="lineCov">      59470 :           if (DECL_LANG_SPECIFIC (olddecl)</span>
<span class="lineNum">    2179 </span><span class="lineCov">      59470 :               &amp;&amp; CP_DECL_THREADPRIVATE_P (olddecl))</span>
<span class="lineNum">    2180 </span>            :             {
<span class="lineNum">    2181 </span>            :               /* Allocate a LANG_SPECIFIC structure for NEWDECL, if needed.  */
<span class="lineNum">    2182 </span><span class="lineCov">         15 :               retrofit_lang_decl (newdecl);</span>
<span class="lineNum">    2183 </span><span class="lineCov">         15 :               CP_DECL_THREADPRIVATE_P (newdecl) = 1;</span>
<span class="lineNum">    2184 </span>            :             }
<span class="lineNum">    2185 </span>            :         }
<span class="lineNum">    2186 </span>            : 
<span class="lineNum">    2187 </span>            :       /* An explicit specialization of a function template or of a member
<span class="lineNum">    2188 </span>            :          function of a class template can be declared transaction_safe
<span class="lineNum">    2189 </span>            :          independently of whether the corresponding template entity is declared
<span class="lineNum">    2190 </span>            :          transaction_safe. */
<span class="lineNum">    2191 </span><span class="lineCov">        775 :       if (flag_tm &amp;&amp; TREE_CODE (newdecl) == FUNCTION_DECL</span>
<span class="lineNum">    2192 </span><span class="lineCov">        691 :           &amp;&amp; DECL_TEMPLATE_INSTANTIATION (olddecl)</span>
<span class="lineNum">    2193 </span><span class="lineCov">         49 :           &amp;&amp; DECL_TEMPLATE_SPECIALIZATION (newdecl)</span>
<span class="lineNum">    2194 </span><span class="lineCov">         49 :           &amp;&amp; tx_safe_fn_type_p (newtype)</span>
<span class="lineNum">    2195 </span><span class="lineCov">     838198 :           &amp;&amp; !tx_safe_fn_type_p (TREE_TYPE (newdecl)))</span>
<span class="lineNum">    2196 </span><span class="lineNoCov">          0 :         newtype = tx_unsafe_fn_variant (newtype);</span>
<span class="lineNum">    2197 </span>            : 
<span class="lineNum">    2198 </span><span class="lineCov">     838198 :       TREE_TYPE (newdecl) = TREE_TYPE (olddecl) = newtype;</span>
<span class="lineNum">    2199 </span>            : 
<span class="lineNum">    2200 </span><span class="lineCov">     838198 :       if (TREE_CODE (newdecl) == FUNCTION_DECL)</span>
<span class="lineNum">    2201 </span><span class="lineCov">     775673 :         check_default_args (newdecl);</span>
<span class="lineNum">    2202 </span>            : 
<span class="lineNum">    2203 </span>            :       /* Lay the type out, unless already done.  */
<span class="lineNum">    2204 </span><span class="lineCov">     838198 :       if (! same_type_p (newtype, oldtype)</span>
<span class="lineNum">    2205 </span><span class="lineCov">        156 :           &amp;&amp; TREE_TYPE (newdecl) != error_mark_node</span>
<span class="lineNum">    2206 </span><span class="lineCov">     838354 :           &amp;&amp; !(processing_template_decl &amp;&amp; uses_template_parms (newdecl)))</span>
<span class="lineNum">    2207 </span><span class="lineCov">         76 :         layout_type (TREE_TYPE (newdecl));</span>
<span class="lineNum">    2208 </span>            : 
<span class="lineNum">    2209 </span><span class="lineCov">     838198 :       if ((VAR_P (newdecl)</span>
<span class="lineNum">    2210 </span><span class="lineCov">     778728 :            || TREE_CODE (newdecl) == PARM_DECL</span>
<span class="lineNum">    2211 </span><span class="lineCov">     778728 :            || TREE_CODE (newdecl) == RESULT_DECL</span>
<span class="lineNum">    2212 </span><span class="lineCov">     778728 :            || TREE_CODE (newdecl) == FIELD_DECL</span>
<span class="lineNum">    2213 </span><span class="lineCov">     778728 :            || TREE_CODE (newdecl) == TYPE_DECL)</span>
<span class="lineNum">    2214 </span><span class="lineCov">     841253 :           &amp;&amp; !(processing_template_decl &amp;&amp; uses_template_parms (newdecl)))</span>
<span class="lineNum">    2215 </span><span class="lineCov">      23227 :         layout_decl (newdecl, 0);</span>
<span class="lineNum">    2216 </span>            : 
<span class="lineNum">    2217 </span>            :       /* Merge deprecatedness.  */
<span class="lineNum">    2218 </span><span class="lineCov">     838198 :       if (TREE_DEPRECATED (newdecl))</span>
<span class="lineNum">    2219 </span><span class="lineCov">          3 :         TREE_DEPRECATED (olddecl) = 1;</span>
<span class="lineNum">    2220 </span>            : 
<span class="lineNum">    2221 </span>            :       /* Preserve function specific target and optimization options */
<span class="lineNum">    2222 </span><span class="lineCov">     838198 :       if (TREE_CODE (newdecl) == FUNCTION_DECL)</span>
<span class="lineNum">    2223 </span>            :         {
<span class="lineNum">    2224 </span><span class="lineCov">     775673 :           if (DECL_FUNCTION_SPECIFIC_TARGET (olddecl)</span>
<span class="lineNum">    2225 </span><span class="lineCov">     775673 :               &amp;&amp; !DECL_FUNCTION_SPECIFIC_TARGET (newdecl))</span>
<span class="lineNum">    2226 </span><span class="lineNoCov">          0 :             DECL_FUNCTION_SPECIFIC_TARGET (newdecl)</span>
<span class="lineNum">    2227 </span><span class="lineNoCov">          0 :               = DECL_FUNCTION_SPECIFIC_TARGET (olddecl);</span>
<span class="lineNum">    2228 </span>            : 
<span class="lineNum">    2229 </span><span class="lineCov">     775673 :           if (DECL_FUNCTION_SPECIFIC_OPTIMIZATION (olddecl)</span>
<span class="lineNum">    2230 </span><span class="lineCov">     775673 :               &amp;&amp; !DECL_FUNCTION_SPECIFIC_OPTIMIZATION (newdecl))</span>
<span class="lineNum">    2231 </span><span class="lineCov">          9 :             DECL_FUNCTION_SPECIFIC_OPTIMIZATION (newdecl)</span>
<span class="lineNum">    2232 </span><span class="lineCov">          9 :               = DECL_FUNCTION_SPECIFIC_OPTIMIZATION (olddecl);</span>
<span class="lineNum">    2233 </span>            :         }
<span class="lineNum">    2234 </span>            :       else
<span class="lineNum">    2235 </span>            :         {
<span class="lineNum">    2236 </span>            :           /* Merge the const type qualifier.  */
<span class="lineNum">    2237 </span><span class="lineCov">      62525 :           if (TREE_READONLY (newdecl))</span>
<span class="lineNum">    2238 </span><span class="lineCov">       1273 :             TREE_READONLY (olddecl) = 1;</span>
<span class="lineNum">    2239 </span>            :           /* Merge the volatile type qualifier.  */
<span class="lineNum">    2240 </span><span class="lineCov">      62525 :           if (TREE_THIS_VOLATILE (newdecl))</span>
<span class="lineNum">    2241 </span><span class="lineCov">          2 :             TREE_THIS_VOLATILE (olddecl) = 1;</span>
<span class="lineNum">    2242 </span>            :         }
<span class="lineNum">    2243 </span>            : 
<span class="lineNum">    2244 </span>            :       /* Merge the initialization information.  */
<span class="lineNum">    2245 </span><span class="lineCov">     838198 :       if (DECL_INITIAL (newdecl) == NULL_TREE</span>
<span class="lineNum">    2246 </span><span class="lineCov">     838198 :           &amp;&amp; DECL_INITIAL (olddecl) != NULL_TREE)</span>
<span class="lineNum">    2247 </span>            :         {
<span class="lineNum">    2248 </span><span class="lineCov">      86204 :           DECL_INITIAL (newdecl) = DECL_INITIAL (olddecl);</span>
<span class="lineNum">    2249 </span><span class="lineCov">      43102 :           DECL_SOURCE_LOCATION (newdecl) = DECL_SOURCE_LOCATION (olddecl);</span>
<span class="lineNum">    2250 </span><span class="lineCov">      43102 :           if (TREE_CODE (newdecl) == FUNCTION_DECL)</span>
<span class="lineNum">    2251 </span>            :             {
<span class="lineNum">    2252 </span><span class="lineCov">       1925 :               DECL_SAVED_TREE (newdecl) = DECL_SAVED_TREE (olddecl);</span>
<span class="lineNum">    2253 </span><span class="lineCov">       1925 :               DECL_STRUCT_FUNCTION (newdecl) = DECL_STRUCT_FUNCTION (olddecl);</span>
<span class="lineNum">    2254 </span>            :             }
<span class="lineNum">    2255 </span>            :         }
<span class="lineNum">    2256 </span>            : 
<span class="lineNum">    2257 </span><span class="lineCov">     838198 :       if (TREE_CODE (newdecl) == FUNCTION_DECL)</span>
<span class="lineNum">    2258 </span>            :         {
<span class="lineNum">    2259 </span><span class="lineCov">    2327019 :           DECL_NO_INSTRUMENT_FUNCTION_ENTRY_EXIT (newdecl)</span>
<span class="lineNum">    2260 </span><span class="lineCov">     775673 :             |= DECL_NO_INSTRUMENT_FUNCTION_ENTRY_EXIT (olddecl);</span>
<span class="lineNum">    2261 </span><span class="lineCov">     775673 :           DECL_NO_LIMIT_STACK (newdecl) |= DECL_NO_LIMIT_STACK (olddecl);</span>
<span class="lineNum">    2262 </span><span class="lineCov">     775673 :           DECL_IS_OPERATOR_NEW (newdecl) |= DECL_IS_OPERATOR_NEW (olddecl);</span>
<span class="lineNum">    2263 </span><span class="lineCov">    2327019 :           DECL_LOOPING_CONST_OR_PURE_P (newdecl)</span>
<span class="lineNum">    2264 </span><span class="lineCov">     775673 :             |= DECL_LOOPING_CONST_OR_PURE_P (olddecl);</span>
<span class="lineNum">    2265 </span>            : 
<span class="lineNum">    2266 </span><span class="lineCov">     775673 :           if (merge_attr)</span>
<span class="lineNum">    2267 </span><span class="lineCov">     725399 :             merge_attribute_bits (newdecl, olddecl);</span>
<span class="lineNum">    2268 </span>            :           else
<span class="lineNum">    2269 </span>            :             {
<span class="lineNum">    2270 </span>            :               /* Merge the noreturn bit.  */
<span class="lineNum">    2271 </span><span class="lineCov">      50274 :               TREE_THIS_VOLATILE (olddecl) = TREE_THIS_VOLATILE (newdecl);</span>
<span class="lineNum">    2272 </span><span class="lineCov">      50274 :               TREE_READONLY (olddecl) = TREE_READONLY (newdecl);</span>
<span class="lineNum">    2273 </span><span class="lineCov">      50274 :               TREE_NOTHROW (olddecl) = TREE_NOTHROW (newdecl);</span>
<span class="lineNum">    2274 </span><span class="lineCov">      50274 :               DECL_IS_MALLOC (olddecl) = DECL_IS_MALLOC (newdecl);</span>
<span class="lineNum">    2275 </span><span class="lineCov">      50274 :               DECL_PURE_P (olddecl) = DECL_PURE_P (newdecl);</span>
<span class="lineNum">    2276 </span>            :             }
<span class="lineNum">    2277 </span>            :           /* Keep the old RTL.  */
<span class="lineNum">    2278 </span><span class="lineCov">     775673 :           COPY_DECL_RTL (olddecl, newdecl);</span>
<span class="lineNum">    2279 </span>            :         }
<span class="lineNum">    2280 </span><span class="lineCov">      62525 :       else if (VAR_P (newdecl)</span>
<span class="lineNum">    2281 </span><span class="lineCov">      62525 :                &amp;&amp; (DECL_SIZE (olddecl) || !DECL_SIZE (newdecl)))</span>
<span class="lineNum">    2282 </span>            :         {
<span class="lineNum">    2283 </span>            :           /* Keep the old RTL.  We cannot keep the old RTL if the old
<span class="lineNum">    2284 </span>            :              declaration was for an incomplete object and the new
<span class="lineNum">    2285 </span>            :              declaration is not since many attributes of the RTL will
<span class="lineNum">    2286 </span>            :              change.  */
<span class="lineNum">    2287 </span><span class="lineCov">      59372 :           COPY_DECL_RTL (olddecl, newdecl);</span>
<span class="lineNum">    2288 </span>            :         }
<span class="lineNum">    2289 </span>            :     }
<span class="lineNum">    2290 </span>            :   /* If cannot merge, then use the new type and qualifiers,
<span class="lineNum">    2291 </span>            :      and don't preserve the old rtl.  */
<span class="lineNum">    2292 </span>            :   else
<span class="lineNum">    2293 </span>            :     {
<span class="lineNum">    2294 </span>            :       /* Clean out any memory we had of the old declaration.  */
<span class="lineNum">    2295 </span><span class="lineCov">        201 :       tree oldstatic = value_member (olddecl, static_aggregates);</span>
<span class="lineNum">    2296 </span><span class="lineCov">        201 :       if (oldstatic)</span>
<span class="lineNum">    2297 </span><span class="lineNoCov">          0 :         TREE_VALUE (oldstatic) = error_mark_node;</span>
<span class="lineNum">    2298 </span>            : 
<span class="lineNum">    2299 </span><span class="lineCov">        201 :       TREE_TYPE (olddecl) = TREE_TYPE (newdecl);</span>
<span class="lineNum">    2300 </span><span class="lineCov">        201 :       TREE_READONLY (olddecl) = TREE_READONLY (newdecl);</span>
<span class="lineNum">    2301 </span><span class="lineCov">        201 :       TREE_THIS_VOLATILE (olddecl) = TREE_THIS_VOLATILE (newdecl);</span>
<span class="lineNum">    2302 </span><span class="lineCov">        201 :       TREE_NOTHROW (olddecl) = TREE_NOTHROW (newdecl);</span>
<span class="lineNum">    2303 </span><span class="lineCov">        201 :       TREE_SIDE_EFFECTS (olddecl) = TREE_SIDE_EFFECTS (newdecl);</span>
<span class="lineNum">    2304 </span>            :     }
<span class="lineNum">    2305 </span>            : 
<span class="lineNum">    2306 </span>            :   /* Merge the storage class information.  */
<span class="lineNum">    2307 </span><span class="lineCov">     838399 :   merge_weak (newdecl, olddecl);</span>
<span class="lineNum">    2308 </span>            : 
<span class="lineNum">    2309 </span><span class="lineCov">     838399 :   DECL_DEFER_OUTPUT (newdecl) |= DECL_DEFER_OUTPUT (olddecl);</span>
<span class="lineNum">    2310 </span><span class="lineCov">     838399 :   TREE_PUBLIC (newdecl) = TREE_PUBLIC (olddecl);</span>
<span class="lineNum">    2311 </span><span class="lineCov">     838399 :   TREE_STATIC (olddecl) = TREE_STATIC (newdecl) |= TREE_STATIC (olddecl);</span>
<span class="lineNum">    2312 </span><span class="lineCov">     838399 :   if (! DECL_EXTERNAL (olddecl))</span>
<span class="lineNum">    2313 </span><span class="lineCov">       7704 :     DECL_EXTERNAL (newdecl) = 0;</span>
<span class="lineNum">    2314 </span><span class="lineCov">     838399 :   if (! DECL_COMDAT (olddecl))</span>
<span class="lineNum">    2315 </span><span class="lineCov">     442851 :     DECL_COMDAT (newdecl) = 0;</span>
<span class="lineNum">    2316 </span>            : 
<span class="lineNum">    2317 </span><span class="lineCov">     838399 :   new_template_info = NULL_TREE;</span>
<span class="lineNum">    2318 </span><span class="lineCov">     838399 :   if (DECL_LANG_SPECIFIC (newdecl) &amp;&amp; DECL_LANG_SPECIFIC (olddecl))</span>
<span class="lineNum">    2319 </span>            :     {
<span class="lineNum">    2320 </span><span class="lineCov">     832501 :       bool new_redefines_gnu_inline = false;</span>
<span class="lineNum">    2321 </span>            : 
<span class="lineNum">    2322 </span><span class="lineCov">     832501 :       if (new_defines_function</span>
<span class="lineNum">    2323 </span><span class="lineCov">     832501 :           &amp;&amp; ((DECL_INTERFACE_KNOWN (olddecl)</span>
<span class="lineNum">    2324 </span><span class="lineCov">     470502 :                &amp;&amp; TREE_CODE (olddecl) == FUNCTION_DECL)</span>
<span class="lineNum">    2325 </span><span class="lineCov">     469839 :               || (TREE_CODE (olddecl) == TEMPLATE_DECL</span>
<span class="lineNum">    2326 </span><span class="lineNoCov">          0 :                   &amp;&amp; (TREE_CODE (DECL_TEMPLATE_RESULT (olddecl))</span>
<span class="lineNum">    2327 </span>            :                       == FUNCTION_DECL))))
<span class="lineNum">    2328 </span>            :         {
<span class="lineNum">    2329 </span><span class="lineCov">        663 :           tree fn = olddecl;</span>
<span class="lineNum">    2330 </span>            : 
<span class="lineNum">    2331 </span><span class="lineCov">        663 :           if (TREE_CODE (fn) == TEMPLATE_DECL)</span>
<span class="lineNum">    2332 </span><span class="lineNoCov">          0 :             fn = DECL_TEMPLATE_RESULT (olddecl);</span>
<span class="lineNum">    2333 </span>            : 
<span class="lineNum">    2334 </span><span class="lineCov">        663 :           new_redefines_gnu_inline = GNU_INLINE_P (fn) &amp;&amp; DECL_INITIAL (fn);</span>
<span class="lineNum">    2335 </span>            :         }
<span class="lineNum">    2336 </span>            : 
<span class="lineNum">    2337 </span><span class="lineCov">        663 :       if (!new_redefines_gnu_inline)</span>
<span class="lineNum">    2338 </span>            :         {
<span class="lineNum">    2339 </span><span class="lineCov">     832426 :           DECL_INTERFACE_KNOWN (newdecl) |= DECL_INTERFACE_KNOWN (olddecl);</span>
<span class="lineNum">    2340 </span><span class="lineCov">     832426 :           DECL_NOT_REALLY_EXTERN (newdecl) |= DECL_NOT_REALLY_EXTERN (olddecl);</span>
<span class="lineNum">    2341 </span><span class="lineCov">     832426 :           DECL_COMDAT (newdecl) |= DECL_COMDAT (olddecl);</span>
<span class="lineNum">    2342 </span>            :         }
<span class="lineNum">    2343 </span><span class="lineCov">     832501 :       DECL_TEMPLATE_INSTANTIATED (newdecl)</span>
<span class="lineNum">    2344 </span><span class="lineCov">    1608375 :         |= DECL_TEMPLATE_INSTANTIATED (olddecl);</span>
<span class="lineNum">    2345 </span><span class="lineCov">    2384249 :       DECL_ODR_USED (newdecl) |= DECL_ODR_USED (olddecl);</span>
<span class="lineNum">    2346 </span>            : 
<span class="lineNum">    2347 </span>            :       /* If the OLDDECL is an instantiation and/or specialization,
<span class="lineNum">    2348 </span>            :          then the NEWDECL must be too.  But, it may not yet be marked
<span class="lineNum">    2349 </span>            :          as such if the caller has created NEWDECL, but has not yet
<span class="lineNum">    2350 </span>            :          figured out that it is a redeclaration.  */
<span class="lineNum">    2351 </span><span class="lineCov">     832501 :       if (!DECL_USE_TEMPLATE (newdecl))</span>
<span class="lineNum">    2352 </span><span class="lineCov">     781993 :         DECL_USE_TEMPLATE (newdecl) = DECL_USE_TEMPLATE (olddecl);</span>
<span class="lineNum">    2353 </span>            : 
<span class="lineNum">    2354 </span>            :       /* Don't really know how much of the language-specific
<span class="lineNum">    2355 </span>            :          values we should copy from old to new.  */
<span class="lineNum">    2356 </span><span class="lineCov">     832501 :       DECL_IN_AGGR_P (newdecl) = DECL_IN_AGGR_P (olddecl);</span>
<span class="lineNum">    2357 </span><span class="lineCov">     832501 :       DECL_REPO_AVAILABLE_P (newdecl) = DECL_REPO_AVAILABLE_P (olddecl);</span>
<span class="lineNum">    2358 </span><span class="lineCov">     832501 :       DECL_INITIALIZED_IN_CLASS_P (newdecl)</span>
<span class="lineNum">    2359 </span><span class="lineCov">    1608375 :         |= DECL_INITIALIZED_IN_CLASS_P (olddecl);</span>
<span class="lineNum">    2360 </span>            : 
<span class="lineNum">    2361 </span><span class="lineCov">     832501 :       if (LANG_DECL_HAS_MIN (newdecl))</span>
<span class="lineNum">    2362 </span>            :         {
<span class="lineNum">    2363 </span><span class="lineCov">    2497503 :           DECL_LANG_SPECIFIC (newdecl)-&gt;u.min.u2 =</span>
<span class="lineNum">    2364 </span><span class="lineCov">     832501 :             DECL_LANG_SPECIFIC (olddecl)-&gt;u.min.u2;</span>
<span class="lineNum">    2365 </span><span class="lineCov">     832501 :           if (DECL_TEMPLATE_INFO (newdecl))</span>
<span class="lineNum">    2366 </span>            :             {
<span class="lineNum">    2367 </span><span class="lineCov">      50570 :               new_template_info = DECL_TEMPLATE_INFO (newdecl);</span>
<span class="lineNum">    2368 </span><span class="lineCov">      50570 :               if (DECL_TEMPLATE_INSTANTIATION (olddecl)</span>
<span class="lineNum">    2369 </span><span class="lineCov">      50570 :                   &amp;&amp; DECL_TEMPLATE_SPECIALIZATION (newdecl))</span>
<span class="lineNum">    2370 </span>            :                 /* Remember the presence of explicit specialization args.  */
<span class="lineNum">    2371 </span><span class="lineCov">      50274 :                 TINFO_USED_TEMPLATE_ID (DECL_TEMPLATE_INFO (olddecl))</span>
<span class="lineNum">    2372 </span><span class="lineCov">     100548 :                   = TINFO_USED_TEMPLATE_ID (new_template_info);</span>
<span class="lineNum">    2373 </span>            :             }
<span class="lineNum">    2374 </span><span class="lineCov">     832501 :           DECL_TEMPLATE_INFO (newdecl) = DECL_TEMPLATE_INFO (olddecl);</span>
<span class="lineNum">    2375 </span>            :         }
<span class="lineNum">    2376 </span>            :       /* Only functions have these fields.  */
<span class="lineNum">    2377 </span><span class="lineCov">     832501 :       if (DECL_DECLARES_FUNCTION_P (newdecl))</span>
<span class="lineNum">    2378 </span>            :         {
<span class="lineNum">    2379 </span><span class="lineCov">     775874 :           DECL_NONCONVERTING_P (newdecl) = DECL_NONCONVERTING_P (olddecl);</span>
<span class="lineNum">    2380 </span><span class="lineCov">     775874 :           DECL_BEFRIENDING_CLASSES (newdecl)</span>
<span class="lineNum">    2381 </span><span class="lineCov">     775874 :             = chainon (DECL_BEFRIENDING_CLASSES (newdecl),</span>
<span class="lineNum">    2382 </span><span class="lineCov">     775874 :                        DECL_BEFRIENDING_CLASSES (olddecl));</span>
<span class="lineNum">    2383 </span>            :           /* DECL_THUNKS is only valid for virtual functions,
<span class="lineNum">    2384 </span>            :              otherwise it is a DECL_FRIEND_CONTEXT.  */
<span class="lineNum">    2385 </span><span class="lineCov">     775874 :           if (DECL_VIRTUAL_P (newdecl))</span>
<span class="lineNum">    2386 </span><span class="lineCov">      34239 :             SET_DECL_THUNKS (newdecl, DECL_THUNKS (olddecl));</span>
<span class="lineNum">    2387 </span>            :         }
<span class="lineNum">    2388 </span>            :       /* Only variables have this field.  */
<span class="lineNum">    2389 </span><span class="lineCov">      56627 :       else if (VAR_P (newdecl)</span>
<span class="lineNum">    2390 </span><span class="lineCov">      56627 :                &amp;&amp; VAR_HAD_UNKNOWN_BOUND (olddecl))</span>
<span class="lineNum">    2391 </span><span class="lineCov">        378 :         SET_VAR_HAD_UNKNOWN_BOUND (newdecl);</span>
<span class="lineNum">    2392 </span>            :     }
<span class="lineNum">    2393 </span>            : 
<span class="lineNum">    2394 </span><span class="lineCov">     838399 :   if (TREE_CODE (newdecl) == FUNCTION_DECL)</span>
<span class="lineNum">    2395 </span>            :     {
<span class="lineNum">    2396 </span><span class="lineCov">     775874 :       tree parm;</span>
<span class="lineNum">    2397 </span>            : 
<span class="lineNum">    2398 </span>            :       /* Merge parameter attributes. */
<span class="lineNum">    2399 </span><span class="lineCov">     775874 :       tree oldarg, newarg;</span>
<span class="lineNum">    2400 </span><span class="lineCov">     775874 :       for (oldarg = DECL_ARGUMENTS(olddecl), </span>
<span class="lineNum">    2401 </span><span class="lineCov">    1551748 :                newarg = DECL_ARGUMENTS(newdecl);</span>
<span class="lineNum">    2402 </span><span class="lineCov">    2117696 :            oldarg &amp;&amp; newarg;</span>
<span class="lineNum">    2403 </span><span class="lineCov">    1341822 :            oldarg = DECL_CHAIN(oldarg), newarg = DECL_CHAIN(newarg)) {</span>
<span class="lineNum">    2404 </span><span class="lineCov">    4025466 :           DECL_ATTRIBUTES (newarg)</span>
<span class="lineNum">    2405 </span><span class="lineCov">    1341822 :               = (*targetm.merge_decl_attributes) (oldarg, newarg);</span>
<span class="lineNum">    2406 </span><span class="lineCov">    1341822 :           DECL_ATTRIBUTES (oldarg) = DECL_ATTRIBUTES (newarg);</span>
<span class="lineNum">    2407 </span>            :       }
<span class="lineNum">    2408 </span>            :       
<span class="lineNum">    2409 </span><span class="lineCov">     775874 :       if (DECL_TEMPLATE_INSTANTIATION (olddecl)</span>
<span class="lineNum">    2410 </span><span class="lineCov">     775874 :           &amp;&amp; !DECL_TEMPLATE_INSTANTIATION (newdecl))</span>
<span class="lineNum">    2411 </span>            :         {
<span class="lineNum">    2412 </span>            :           /* If newdecl is not a specialization, then it is not a
<span class="lineNum">    2413 </span>            :              template-related function at all.  And that means that we
<span class="lineNum">    2414 </span>            :              should have exited above, returning 0.  */
<span class="lineNum">    2415 </span><span class="lineCov">     100548 :           gcc_assert (DECL_TEMPLATE_SPECIALIZATION (newdecl));</span>
<span class="lineNum">    2416 </span>            : 
<span class="lineNum">    2417 </span><span class="lineCov">     150822 :           if (DECL_ODR_USED (olddecl))</span>
<span class="lineNum">    2418 </span>            :             /* From [temp.expl.spec]:
<span class="lineNum">    2419 </span>            : 
<span class="lineNum">    2420 </span>            :                If a template, a member template or the member of a class
<span class="lineNum">    2421 </span>            :                template is explicitly specialized then that
<span class="lineNum">    2422 </span>            :                specialization shall be declared before the first use of
<span class="lineNum">    2423 </span>            :                that specialization that would cause an implicit
<span class="lineNum">    2424 </span>            :                instantiation to take place, in every translation unit in
<span class="lineNum">    2425 </span>            :                which such a use occurs.  */
<span class="lineNum">    2426 </span><span class="lineNoCov">          0 :             error (&quot;explicit specialization of %qD after first use&quot;,</span>
<span class="lineNum">    2427 </span>            :                       olddecl);
<span class="lineNum">    2428 </span>            : 
<span class="lineNum">    2429 </span><span class="lineCov">      50274 :           SET_DECL_TEMPLATE_SPECIALIZATION (olddecl);</span>
<span class="lineNum">    2430 </span><span class="lineCov">      50274 :           DECL_COMDAT (newdecl) = (TREE_PUBLIC (newdecl)</span>
<span class="lineNum">    2431 </span><span class="lineCov">      50274 :                                    &amp;&amp; DECL_DECLARED_INLINE_P (newdecl));</span>
<span class="lineNum">    2432 </span>            : 
<span class="lineNum">    2433 </span>            :           /* Don't propagate visibility from the template to the
<span class="lineNum">    2434 </span>            :              specialization here.  We'll do that in determine_visibility if
<span class="lineNum">    2435 </span>            :              appropriate.  */
<span class="lineNum">    2436 </span><span class="lineCov">      50274 :           DECL_VISIBILITY_SPECIFIED (olddecl) = 0;</span>
<span class="lineNum">    2437 </span>            : 
<span class="lineNum">    2438 </span>            :           /* [temp.expl.spec/14] We don't inline explicit specialization
<span class="lineNum">    2439 </span>            :              just because the primary template says so.  */
<span class="lineNum">    2440 </span><span class="lineCov">      50274 :           gcc_assert (!merge_attr);</span>
<span class="lineNum">    2441 </span>            : 
<span class="lineNum">    2442 </span><span class="lineCov">     150822 :           DECL_DECLARED_INLINE_P (olddecl)</span>
<span class="lineNum">    2443 </span><span class="lineCov">      50274 :             = DECL_DECLARED_INLINE_P (newdecl);</span>
<span class="lineNum">    2444 </span>            : 
<span class="lineNum">    2445 </span><span class="lineCov">     150822 :           DECL_DISREGARD_INLINE_LIMITS (olddecl)</span>
<span class="lineNum">    2446 </span><span class="lineCov">      50274 :             = DECL_DISREGARD_INLINE_LIMITS (newdecl);</span>
<span class="lineNum">    2447 </span>            : 
<span class="lineNum">    2448 </span><span class="lineCov">      50274 :           DECL_UNINLINABLE (olddecl) = DECL_UNINLINABLE (newdecl);</span>
<span class="lineNum">    2449 </span>            :         }
<span class="lineNum">    2450 </span><span class="lineCov">     725600 :       else if (new_defines_function &amp;&amp; DECL_INITIAL (olddecl))</span>
<span class="lineNum">    2451 </span>            :         {
<span class="lineNum">    2452 </span>            :           /* Never inline re-defined extern inline functions.
<span class="lineNum">    2453 </span>            :              FIXME: this could be better handled by keeping both
<span class="lineNum">    2454 </span>            :              function as separate declarations.  */
<span class="lineNum">    2455 </span><span class="lineCov">         75 :           DECL_UNINLINABLE (newdecl) = 1;</span>
<span class="lineNum">    2456 </span>            :         }
<span class="lineNum">    2457 </span>            :       else
<span class="lineNum">    2458 </span>            :         {
<span class="lineNum">    2459 </span><span class="lineCov">     725525 :           if (DECL_PENDING_INLINE_P (olddecl))</span>
<span class="lineNum">    2460 </span>            :             {
<span class="lineNum">    2461 </span><span class="lineCov">          6 :               DECL_PENDING_INLINE_P (newdecl) = 1;</span>
<span class="lineNum">    2462 </span><span class="lineCov">          6 :               DECL_PENDING_INLINE_INFO (newdecl)</span>
<span class="lineNum">    2463 </span><span class="lineCov">         12 :                 = DECL_PENDING_INLINE_INFO (olddecl);</span>
<span class="lineNum">    2464 </span>            :             }
<span class="lineNum">    2465 </span><span class="lineCov">     725519 :           else if (DECL_PENDING_INLINE_P (newdecl))</span>
<span class="lineNum">    2466 </span>            :             ;
<span class="lineNum">    2467 </span><span class="lineCov">     725519 :           else if (DECL_SAVED_FUNCTION_DATA (newdecl) == NULL)</span>
<span class="lineNum">    2468 </span><span class="lineCov">    1451038 :             DECL_SAVED_FUNCTION_DATA (newdecl)</span>
<span class="lineNum">    2469 </span><span class="lineCov">     725519 :               = DECL_SAVED_FUNCTION_DATA (olddecl);</span>
<span class="lineNum">    2470 </span>            : 
<span class="lineNum">    2471 </span><span class="lineCov">     725525 :           DECL_DECLARED_INLINE_P (newdecl) |= DECL_DECLARED_INLINE_P (olddecl);</span>
<span class="lineNum">    2472 </span>            : 
<span class="lineNum">    2473 </span><span class="lineCov">     725525 :           DECL_UNINLINABLE (newdecl) = DECL_UNINLINABLE (olddecl)</span>
<span class="lineNum">    2474 </span><span class="lineCov">    2176575 :             = (DECL_UNINLINABLE (newdecl) || DECL_UNINLINABLE (olddecl));</span>
<span class="lineNum">    2475 </span>            : 
<span class="lineNum">    2476 </span><span class="lineCov">    2176575 :           DECL_DISREGARD_INLINE_LIMITS (newdecl)</span>
<span class="lineNum">    2477 </span><span class="lineCov">    1451050 :             = DECL_DISREGARD_INLINE_LIMITS (olddecl)</span>
<span class="lineNum">    2478 </span><span class="lineCov">    1451050 :             = (DECL_DISREGARD_INLINE_LIMITS (newdecl)</span>
<span class="lineNum">    2479 </span><span class="lineCov">     725525 :                || DECL_DISREGARD_INLINE_LIMITS (olddecl));</span>
<span class="lineNum">    2480 </span>            :         }
<span class="lineNum">    2481 </span>            : 
<span class="lineNum">    2482 </span>            :       /* Preserve abstractness on cloned [cd]tors.  */
<span class="lineNum">    2483 </span><span class="lineCov">     775874 :       DECL_ABSTRACT_P (newdecl) = DECL_ABSTRACT_P (olddecl);</span>
<span class="lineNum">    2484 </span>            : 
<span class="lineNum">    2485 </span>            :       /* Update newdecl's parms to point at olddecl.  */
<span class="lineNum">    2486 </span><span class="lineCov">    2527145 :       for (parm = DECL_ARGUMENTS (newdecl); parm;</span>
<span class="lineNum">    2487 </span><span class="lineCov">    1751271 :            parm = DECL_CHAIN (parm))</span>
<span class="lineNum">    2488 </span><span class="lineCov">    1751271 :         DECL_CONTEXT (parm) = olddecl;</span>
<span class="lineNum">    2489 </span>            : 
<span class="lineNum">    2490 </span><span class="lineCov">     775874 :       if (! types_match)</span>
<span class="lineNum">    2491 </span>            :         {
<span class="lineNum">    2492 </span><span class="lineCov">        201 :           SET_DECL_LANGUAGE (olddecl, DECL_LANGUAGE (newdecl));</span>
<span class="lineNum">    2493 </span><span class="lineCov">        201 :           COPY_DECL_ASSEMBLER_NAME (newdecl, olddecl);</span>
<span class="lineNum">    2494 </span><span class="lineCov">        201 :           COPY_DECL_RTL (newdecl, olddecl);</span>
<span class="lineNum">    2495 </span>            :         }
<span class="lineNum">    2496 </span><span class="lineCov">     775874 :       if (! types_match || new_defines_function)</span>
<span class="lineNum">    2497 </span>            :         {
<span class="lineNum">    2498 </span>            :           /* These need to be copied so that the names are available.
<span class="lineNum">    2499 </span>            :              Note that if the types do match, we'll preserve inline
<span class="lineNum">    2500 </span>            :              info and other bits, but if not, we won't.  */
<span class="lineNum">    2501 </span><span class="lineCov">     470703 :           DECL_ARGUMENTS (olddecl) = DECL_ARGUMENTS (newdecl);</span>
<span class="lineNum">    2502 </span><span class="lineCov">     470703 :           DECL_RESULT (olddecl) = DECL_RESULT (newdecl);</span>
<span class="lineNum">    2503 </span>            :         }
<span class="lineNum">    2504 </span>            :       /* If redeclaring a builtin function, it stays built in
<span class="lineNum">    2505 </span>            :          if newdecl is a gnu_inline definition, or if newdecl is just
<span class="lineNum">    2506 </span>            :          a declaration.  */
<span class="lineNum">    2507 </span><span class="lineCov">     775874 :       if (fndecl_built_in_p (olddecl)</span>
<span class="lineNum">    2508 </span><span class="lineCov">     775874 :           &amp;&amp; (new_defines_function ? GNU_INLINE_P (newdecl) : types_match))</span>
<span class="lineNum">    2509 </span>            :         {
<span class="lineNum">    2510 </span><span class="lineCov">     248879 :           DECL_BUILT_IN_CLASS (newdecl) = DECL_BUILT_IN_CLASS (olddecl);</span>
<span class="lineNum">    2511 </span><span class="lineCov">     248879 :           DECL_FUNCTION_CODE (newdecl) = DECL_FUNCTION_CODE (olddecl);</span>
<span class="lineNum">    2512 </span>            :           /* If we're keeping the built-in definition, keep the rtl,
<span class="lineNum">    2513 </span>            :              regardless of declaration matches.  */
<span class="lineNum">    2514 </span><span class="lineCov">     248879 :           COPY_DECL_RTL (olddecl, newdecl);</span>
<span class="lineNum">    2515 </span><span class="lineCov">     497758 :           if (DECL_BUILT_IN_CLASS (newdecl) == BUILT_IN_NORMAL)</span>
<span class="lineNum">    2516 </span>            :             {
<span class="lineNum">    2517 </span><span class="lineCov">     248879 :               enum built_in_function fncode = DECL_FUNCTION_CODE (newdecl);</span>
<span class="lineNum">    2518 </span><span class="lineCov">     248879 :               switch (fncode)</span>
<span class="lineNum">    2519 </span>            :                 {
<span class="lineNum">    2520 </span>            :                   /* If a compatible prototype of these builtin functions
<span class="lineNum">    2521 </span>            :                      is seen, assume the runtime implements it with the
<span class="lineNum">    2522 </span>            :                      expected semantics.  */
<span class="lineNum">    2523 </span><span class="lineCov">        441 :                 case BUILT_IN_STPCPY:</span>
<span class="lineNum">    2524 </span><span class="lineCov">        882 :                   if (builtin_decl_explicit_p (fncode))</span>
<span class="lineNum">    2525 </span><span class="lineCov">        441 :                     set_builtin_decl_implicit_p (fncode, true);</span>
<span class="lineNum">    2526 </span>            :                   break;
<span class="lineNum">    2527 </span><span class="lineCov">     248438 :                 default:</span>
<span class="lineNum">    2528 </span><span class="lineCov">     248438 :                   if (builtin_decl_explicit_p (fncode))</span>
<span class="lineNum">    2529 </span><span class="lineCov">     248438 :                     set_builtin_decl_declared_p (fncode, true);</span>
<span class="lineNum">    2530 </span>            :                   break;
<span class="lineNum">    2531 </span>            :                 }
<span class="lineNum">    2532 </span>            :             }
<span class="lineNum">    2533 </span>            : 
<span class="lineNum">    2534 </span><span class="lineCov">     248879 :           copy_attributes_to_builtin (newdecl);</span>
<span class="lineNum">    2535 </span>            :         }
<span class="lineNum">    2536 </span><span class="lineCov">     775874 :       if (new_defines_function)</span>
<span class="lineNum">    2537 </span>            :         /* If defining a function declared with other language
<span class="lineNum">    2538 </span>            :            linkage, use the previously declared language linkage.  */
<span class="lineNum">    2539 </span><span class="lineCov">     470502 :         SET_DECL_LANGUAGE (newdecl, DECL_LANGUAGE (olddecl));</span>
<span class="lineNum">    2540 </span><span class="lineCov">     305372 :       else if (types_match)</span>
<span class="lineNum">    2541 </span>            :         {
<span class="lineNum">    2542 </span><span class="lineCov">     305171 :           DECL_RESULT (newdecl) = DECL_RESULT (olddecl);</span>
<span class="lineNum">    2543 </span>            :           /* Don't clear out the arguments if we're just redeclaring a
<span class="lineNum">    2544 </span>            :              function.  */
<span class="lineNum">    2545 </span><span class="lineCov">     305171 :           if (DECL_ARGUMENTS (olddecl))</span>
<span class="lineNum">    2546 </span><span class="lineCov">     137079 :             DECL_ARGUMENTS (newdecl) = DECL_ARGUMENTS (olddecl);</span>
<span class="lineNum">    2547 </span>            :         }
<span class="lineNum">    2548 </span>            :     }
<span class="lineNum">    2549 </span><span class="lineCov">      62525 :   else if (TREE_CODE (newdecl) == NAMESPACE_DECL)</span>
<span class="lineNum">    2550 </span><span class="lineNoCov">          0 :     NAMESPACE_LEVEL (newdecl) = NAMESPACE_LEVEL (olddecl);</span>
<span class="lineNum">    2551 </span>            : 
<span class="lineNum">    2552 </span>            :   /* Now preserve various other info from the definition.  */
<span class="lineNum">    2553 </span><span class="lineCov">     838399 :   TREE_ADDRESSABLE (newdecl) = TREE_ADDRESSABLE (olddecl);</span>
<span class="lineNum">    2554 </span><span class="lineCov">     838399 :   TREE_ASM_WRITTEN (newdecl) = TREE_ASM_WRITTEN (olddecl);</span>
<span class="lineNum">    2555 </span><span class="lineCov">     838399 :   DECL_COMMON (newdecl) = DECL_COMMON (olddecl);</span>
<span class="lineNum">    2556 </span><span class="lineCov">     838399 :   COPY_DECL_ASSEMBLER_NAME (olddecl, newdecl);</span>
<span class="lineNum">    2557 </span>            : 
<span class="lineNum">    2558 </span>            :   /* Warn about conflicting visibility specifications.  */
<span class="lineNum">    2559 </span><span class="lineCov">     838399 :   if (DECL_VISIBILITY_SPECIFIED (olddecl)</span>
<span class="lineNum">    2560 </span><span class="lineCov">     308015 :       &amp;&amp; DECL_VISIBILITY_SPECIFIED (newdecl)</span>
<span class="lineNum">    2561 </span><span class="lineCov">     839107 :       &amp;&amp; DECL_VISIBILITY (newdecl) != DECL_VISIBILITY (olddecl))</span>
<span class="lineNum">    2562 </span>            :     {
<span class="lineNum">    2563 </span><span class="lineCov">         16 :       auto_diagnostic_group d;</span>
<span class="lineNum">    2564 </span><span class="lineCov">          8 :       if (warning_at (newdecl_loc, OPT_Wattributes,</span>
<span class="lineNum">    2565 </span>            :                       &quot;%qD: visibility attribute ignored because it &quot;
<span class="lineNum">    2566 </span>            :                       &quot;conflicts with previous declaration&quot;, newdecl))
<span class="lineNum">    2567 </span><span class="lineCov">          8 :         inform (olddecl_loc,</span>
<span class="lineNum">    2568 </span>            :                 &quot;previous declaration of %qD&quot;, olddecl);
<span class="lineNum">    2569 </span>            :     }
<span class="lineNum">    2570 </span>            :   /* Choose the declaration which specified visibility.  */
<span class="lineNum">    2571 </span><span class="lineCov">     838399 :   if (DECL_VISIBILITY_SPECIFIED (olddecl))</span>
<span class="lineNum">    2572 </span>            :     {
<span class="lineNum">    2573 </span><span class="lineCov">     616030 :       DECL_VISIBILITY (newdecl) = DECL_VISIBILITY (olddecl);</span>
<span class="lineNum">    2574 </span><span class="lineCov">     308015 :       DECL_VISIBILITY_SPECIFIED (newdecl) = 1;</span>
<span class="lineNum">    2575 </span>            :     }
<span class="lineNum">    2576 </span>            :   /* Init priority used to be merged from newdecl to olddecl by the memcpy,
<span class="lineNum">    2577 </span>            :      so keep this behavior.  */
<span class="lineNum">    2578 </span><span class="lineCov">     838399 :   if (VAR_P (newdecl) &amp;&amp; DECL_HAS_INIT_PRIORITY_P (newdecl))</span>
<span class="lineNum">    2579 </span>            :     {
<span class="lineNum">    2580 </span><span class="lineCov">          4 :       SET_DECL_INIT_PRIORITY (olddecl, DECL_INIT_PRIORITY (newdecl));</span>
<span class="lineNum">    2581 </span><span class="lineCov">          4 :       DECL_HAS_INIT_PRIORITY_P (olddecl) = 1;</span>
<span class="lineNum">    2582 </span>            :     }
<span class="lineNum">    2583 </span>            :   /* Likewise for DECL_ALIGN, DECL_USER_ALIGN and DECL_PACKED.  */
<span class="lineNum">    2584 </span><span class="lineCov">     838399 :   if (DECL_ALIGN (olddecl) &gt; DECL_ALIGN (newdecl))</span>
<span class="lineNum">    2585 </span>            :     {
<span class="lineNum">    2586 </span><span class="lineCov">         86 :       SET_DECL_ALIGN (newdecl, DECL_ALIGN (olddecl));</span>
<span class="lineNum">    2587 </span><span class="lineCov">         43 :       DECL_USER_ALIGN (newdecl) |= DECL_USER_ALIGN (olddecl);</span>
<span class="lineNum">    2588 </span>            :     }
<span class="lineNum">    2589 </span><span class="lineCov">     838399 :   DECL_USER_ALIGN (olddecl) = DECL_USER_ALIGN (newdecl);</span>
<span class="lineNum">    2590 </span><span class="lineCov">    1676798 :   if (DECL_WARN_IF_NOT_ALIGN (olddecl)</span>
<span class="lineNum">    2591 </span><span class="lineCov">     838399 :       &gt; DECL_WARN_IF_NOT_ALIGN (newdecl))</span>
<span class="lineNum">    2592 </span><span class="lineNoCov">          0 :     SET_DECL_WARN_IF_NOT_ALIGN (newdecl,</span>
<span class="lineNum">    2593 </span>            :                                 DECL_WARN_IF_NOT_ALIGN (olddecl));
<span class="lineNum">    2594 </span><span class="lineCov">     838399 :   if (TREE_CODE (newdecl) == FIELD_DECL)</span>
<span class="lineNum">    2595 </span><span class="lineNoCov">          0 :     DECL_PACKED (olddecl) = DECL_PACKED (newdecl);</span>
<span class="lineNum">    2596 </span>            : 
<span class="lineNum">    2597 </span>            :   /* The DECL_LANG_SPECIFIC information in OLDDECL will be replaced
<span class="lineNum">    2598 </span>            :      with that from NEWDECL below.  */
<span class="lineNum">    2599 </span><span class="lineCov">     838399 :   if (DECL_LANG_SPECIFIC (olddecl))</span>
<span class="lineNum">    2600 </span>            :     {
<span class="lineNum">    2601 </span><span class="lineCov">    1665002 :       gcc_assert (DECL_LANG_SPECIFIC (olddecl)</span>
<span class="lineNum">    2602 </span>            :                   != DECL_LANG_SPECIFIC (newdecl));
<span class="lineNum">    2603 </span><span class="lineCov">    1665002 :       ggc_free (DECL_LANG_SPECIFIC (olddecl));</span>
<span class="lineNum">    2604 </span>            :     }
<span class="lineNum">    2605 </span>            : 
<span class="lineNum">    2606 </span>            :   /* Merge the USED information.  */
<span class="lineNum">    2607 </span><span class="lineCov">     838399 :   if (TREE_USED (olddecl))</span>
<span class="lineNum">    2608 </span><span class="lineCov">      28502 :     TREE_USED (newdecl) = 1;</span>
<span class="lineNum">    2609 </span><span class="lineCov">     809897 :   else if (TREE_USED (newdecl))</span>
<span class="lineNum">    2610 </span><span class="lineCov">         19 :     TREE_USED (olddecl) = 1;</span>
<span class="lineNum">    2611 </span><span class="lineCov">     838399 :   if (VAR_P (newdecl))</span>
<span class="lineNum">    2612 </span>            :     {
<span class="lineNum">    2613 </span><span class="lineCov">      59470 :       if (DECL_READ_P (olddecl))</span>
<span class="lineNum">    2614 </span><span class="lineCov">      10514 :         DECL_READ_P (newdecl) = 1;</span>
<span class="lineNum">    2615 </span><span class="lineCov">     108426 :       else if (DECL_READ_P (newdecl))</span>
<span class="lineNum">    2616 </span><span class="lineNoCov">          0 :         DECL_READ_P (olddecl) = 1;</span>
<span class="lineNum">    2617 </span>            :     }
<span class="lineNum">    2618 </span><span class="lineCov">     838399 :   if (DECL_PRESERVE_P (olddecl))</span>
<span class="lineNum">    2619 </span><span class="lineCov">         21 :     DECL_PRESERVE_P (newdecl) = 1;</span>
<span class="lineNum">    2620 </span><span class="lineCov">     838378 :   else if (DECL_PRESERVE_P (newdecl))</span>
<span class="lineNum">    2621 </span><span class="lineCov">         50 :     DECL_PRESERVE_P (olddecl) = 1;</span>
<span class="lineNum">    2622 </span>            : 
<span class="lineNum">    2623 </span>            :   /* Merge the DECL_FUNCTION_VERSIONED information.  newdecl will be copied
<span class="lineNum">    2624 </span>            :      to olddecl and deleted.  */
<span class="lineNum">    2625 </span><span class="lineCov">     838399 :   if (TREE_CODE (newdecl) == FUNCTION_DECL</span>
<span class="lineNum">    2626 </span><span class="lineCov">     838399 :       &amp;&amp; DECL_FUNCTION_VERSIONED (olddecl))</span>
<span class="lineNum">    2627 </span>            :     {
<span class="lineNum">    2628 </span>            :       /* Set the flag for newdecl so that it gets copied to olddecl.  */
<span class="lineNum">    2629 </span><span class="lineCov">        222 :       DECL_FUNCTION_VERSIONED (newdecl) = 1;</span>
<span class="lineNum">    2630 </span>            :       /* newdecl will be purged after copying to olddecl and is no longer
<span class="lineNum">    2631 </span>            :          a version.  */
<span class="lineNum">    2632 </span><span class="lineCov">        222 :       cgraph_node::delete_function_version_by_decl (newdecl);</span>
<span class="lineNum">    2633 </span>            :     }
<span class="lineNum">    2634 </span>            : 
<span class="lineNum">    2635 </span><span class="lineCov">     838399 :   if (TREE_CODE (newdecl) == FUNCTION_DECL)</span>
<span class="lineNum">    2636 </span>            :     {
<span class="lineNum">    2637 </span><span class="lineCov">     775874 :       int function_size;</span>
<span class="lineNum">    2638 </span><span class="lineCov">     775874 :       struct symtab_node *snode = symtab_node::get (olddecl);</span>
<span class="lineNum">    2639 </span>            : 
<span class="lineNum">    2640 </span><span class="lineCov">     775874 :       function_size = sizeof (struct tree_decl_common);</span>
<span class="lineNum">    2641 </span>            : 
<span class="lineNum">    2642 </span><span class="lineCov">     775874 :       memcpy ((char *) olddecl + sizeof (struct tree_common),</span>
<span class="lineNum">    2643 </span>            :               (char *) newdecl + sizeof (struct tree_common),
<span class="lineNum">    2644 </span>            :               function_size - sizeof (struct tree_common));
<span class="lineNum">    2645 </span>            : 
<span class="lineNum">    2646 </span><span class="lineCov">     775874 :       memcpy ((char *) olddecl + sizeof (struct tree_decl_common),</span>
<span class="lineNum">    2647 </span>            :               (char *) newdecl + sizeof (struct tree_decl_common),
<span class="lineNum">    2648 </span>            :               sizeof (struct tree_function_decl) - sizeof (struct tree_decl_common));
<span class="lineNum">    2649 </span>            : 
<span class="lineNum">    2650 </span>            :       /* Preserve symtab node mapping.  */
<span class="lineNum">    2651 </span><span class="lineCov">     775874 :       olddecl-&gt;decl_with_vis.symtab_node = snode;</span>
<span class="lineNum">    2652 </span>            : 
<span class="lineNum">    2653 </span><span class="lineCov">     775874 :       if (new_template_info)</span>
<span class="lineNum">    2654 </span>            :         /* If newdecl is a template instantiation, it is possible that
<span class="lineNum">    2655 </span>            :            the following sequence of events has occurred:
<span class="lineNum">    2656 </span>            : 
<span class="lineNum">    2657 </span>            :            o A friend function was declared in a class template.  The
<span class="lineNum">    2658 </span>            :            class template was instantiated.
<span class="lineNum">    2659 </span>            : 
<span class="lineNum">    2660 </span>            :            o The instantiation of the friend declaration was
<span class="lineNum">    2661 </span>            :            recorded on the instantiation list, and is newdecl.
<span class="lineNum">    2662 </span>            : 
<span class="lineNum">    2663 </span>            :            o Later, however, instantiate_class_template called pushdecl
<span class="lineNum">    2664 </span>            :            on the newdecl to perform name injection.  But, pushdecl in
<span class="lineNum">    2665 </span>            :            turn called duplicate_decls when it discovered that another
<span class="lineNum">    2666 </span>            :            declaration of a global function with the same name already
<span class="lineNum">    2667 </span>            :            existed.
<span class="lineNum">    2668 </span>            : 
<span class="lineNum">    2669 </span>            :            o Here, in duplicate_decls, we decided to clobber newdecl.
<span class="lineNum">    2670 </span>            : 
<span class="lineNum">    2671 </span>            :            If we're going to do that, we'd better make sure that
<span class="lineNum">    2672 </span>            :            olddecl, and not newdecl, is on the list of
<span class="lineNum">    2673 </span>            :            instantiations so that if we try to do the instantiation
<span class="lineNum">    2674 </span>            :            again we won't get the clobbered declaration.  */
<span class="lineNum">    2675 </span><span class="lineCov">      50570 :         reregister_specialization (newdecl,</span>
<span class="lineNum">    2676 </span>            :                                    new_template_info,
<span class="lineNum">    2677 </span>            :                                    olddecl);
<span class="lineNum">    2678 </span>            :     }
<span class="lineNum">    2679 </span>            :   else
<span class="lineNum">    2680 </span>            :     {
<span class="lineNum">    2681 </span><span class="lineCov">      62525 :       size_t size = tree_code_size (TREE_CODE (newdecl));</span>
<span class="lineNum">    2682 </span>            : 
<span class="lineNum">    2683 </span><span class="lineCov">      62525 :       memcpy ((char *) olddecl + sizeof (struct tree_common),</span>
<span class="lineNum">    2684 </span>            :               (char *) newdecl + sizeof (struct tree_common),
<span class="lineNum">    2685 </span>            :               sizeof (struct tree_decl_common) - sizeof (struct tree_common));
<span class="lineNum">    2686 </span><span class="lineCov">      62525 :       switch (TREE_CODE (newdecl))</span>
<span class="lineNum">    2687 </span>            :         {
<span class="lineNum">    2688 </span><span class="lineCov">      62525 :         case LABEL_DECL:</span>
<span class="lineNum">    2689 </span><span class="lineCov">      62525 :         case VAR_DECL:</span>
<span class="lineNum">    2690 </span><span class="lineCov">      62525 :         case RESULT_DECL:</span>
<span class="lineNum">    2691 </span><span class="lineCov">      62525 :         case PARM_DECL:</span>
<span class="lineNum">    2692 </span><span class="lineCov">      62525 :         case FIELD_DECL:</span>
<span class="lineNum">    2693 </span><span class="lineCov">      62525 :         case TYPE_DECL:</span>
<span class="lineNum">    2694 </span><span class="lineCov">      62525 :         case CONST_DECL:</span>
<span class="lineNum">    2695 </span><span class="lineCov">      62525 :           {</span>
<span class="lineNum">    2696 </span><span class="lineCov">      62525 :             struct symtab_node *snode = NULL;</span>
<span class="lineNum">    2697 </span>            : 
<span class="lineNum">    2698 </span><span class="lineCov">      62525 :             if (VAR_P (newdecl)</span>
<span class="lineNum">    2699 </span><span class="lineCov">      62525 :                 &amp;&amp; (TREE_STATIC (olddecl) || TREE_PUBLIC (olddecl)</span>
<span class="lineNum">    2700 </span><span class="lineCov">          2 :                     || DECL_EXTERNAL (olddecl)))</span>
<span class="lineNum">    2701 </span><span class="lineCov">      59470 :               snode = symtab_node::get (olddecl);</span>
<span class="lineNum">    2702 </span><span class="lineCov">     125050 :             memcpy ((char *) olddecl + sizeof (struct tree_decl_common),</span>
<span class="lineNum">    2703 </span>            :                     (char *) newdecl + sizeof (struct tree_decl_common),
<span class="lineNum">    2704 </span>            :                     size - sizeof (struct tree_decl_common)
<span class="lineNum">    2705 </span><span class="lineCov">      62525 :                     + TREE_CODE_LENGTH (TREE_CODE (newdecl)) * sizeof (char *));</span>
<span class="lineNum">    2706 </span><span class="lineCov">      62525 :             if (VAR_P (newdecl))</span>
<span class="lineNum">    2707 </span><span class="lineCov">      59470 :               olddecl-&gt;decl_with_vis.symtab_node = snode;</span>
<span class="lineNum">    2708 </span>            :           }
<span class="lineNum">    2709 </span>            :           break;
<span class="lineNum">    2710 </span><span class="lineNoCov">          0 :         default:</span>
<span class="lineNum">    2711 </span><span class="lineNoCov">          0 :           memcpy ((char *) olddecl + sizeof (struct tree_decl_common),</span>
<span class="lineNum">    2712 </span>            :                   (char *) newdecl + sizeof (struct tree_decl_common),
<span class="lineNum">    2713 </span>            :                   sizeof (struct tree_decl_non_common) - sizeof (struct tree_decl_common)
<span class="lineNum">    2714 </span><span class="lineNoCov">          0 :                   + TREE_CODE_LENGTH (TREE_CODE (newdecl)) * sizeof (char *));</span>
<span class="lineNum">    2715 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">    2716 </span>            :         }
<span class="lineNum">    2717 </span>            :     }
<span class="lineNum">    2718 </span>            : 
<span class="lineNum">    2719 </span><span class="lineCov">     838399 :   if (VAR_OR_FUNCTION_DECL_P (newdecl))</span>
<span class="lineNum">    2720 </span>            :     {
<span class="lineNum">    2721 </span><span class="lineCov">     835344 :       if (DECL_EXTERNAL (olddecl)</span>
<span class="lineNum">    2722 </span><span class="lineCov">     835344 :           || TREE_PUBLIC (olddecl)</span>
<span class="lineNum">    2723 </span><span class="lineCov">     835344 :           || TREE_STATIC (olddecl))</span>
<span class="lineNum">    2724 </span>            :         {
<span class="lineNum">    2725 </span>            :           /* Merge the section attribute.
<span class="lineNum">    2726 </span>            :              We want to issue an error if the sections conflict but that must be
<span class="lineNum">    2727 </span>            :              done later in decl_attributes since we are called before attributes
<span class="lineNum">    2728 </span>            :              are assigned.  */
<span class="lineNum">    2729 </span><span class="lineCov">     835344 :           if (DECL_SECTION_NAME (newdecl) != NULL)</span>
<span class="lineNum">    2730 </span><span class="lineCov">          7 :             set_decl_section_name (olddecl, DECL_SECTION_NAME (newdecl));</span>
<span class="lineNum">    2731 </span>            : 
<span class="lineNum">    2732 </span><span class="lineCov">     835344 :           if (DECL_ONE_ONLY (newdecl))</span>
<span class="lineNum">    2733 </span>            :             {
<span class="lineNum">    2734 </span><span class="lineNoCov">          0 :               struct symtab_node *oldsym, *newsym;</span>
<span class="lineNum">    2735 </span><span class="lineNoCov">          0 :               if (TREE_CODE (olddecl) == FUNCTION_DECL)</span>
<span class="lineNum">    2736 </span><span class="lineNoCov">          0 :                 oldsym = cgraph_node::get_create (olddecl);</span>
<span class="lineNum">    2737 </span>            :               else
<span class="lineNum">    2738 </span><span class="lineNoCov">          0 :                 oldsym = varpool_node::get_create (olddecl);</span>
<span class="lineNum">    2739 </span><span class="lineNoCov">          0 :               newsym = symtab_node::get (newdecl);</span>
<span class="lineNum">    2740 </span><span class="lineNoCov">          0 :               oldsym-&gt;set_comdat_group (newsym-&gt;get_comdat_group ());</span>
<span class="lineNum">    2741 </span>            :             }
<span class="lineNum">    2742 </span>            :         }
<span class="lineNum">    2743 </span>            : 
<span class="lineNum">    2744 </span><span class="lineCov">     835344 :       if (VAR_P (newdecl)</span>
<span class="lineNum">    2745 </span><span class="lineCov">     835344 :           &amp;&amp; CP_DECL_THREAD_LOCAL_P (newdecl))</span>
<span class="lineNum">    2746 </span>            :         {
<span class="lineNum">    2747 </span><span class="lineCov">         24 :           CP_DECL_THREAD_LOCAL_P (olddecl) = true;</span>
<span class="lineNum">    2748 </span><span class="lineCov">         24 :           if (!processing_template_decl)</span>
<span class="lineNum">    2749 </span><span class="lineCov">         17 :             set_decl_tls_model (olddecl, DECL_TLS_MODEL (newdecl));</span>
<span class="lineNum">    2750 </span>            :         }
<span class="lineNum">    2751 </span>            :     }
<span class="lineNum">    2752 </span>            : 
<span class="lineNum">    2753 </span><span class="lineCov">     838399 :   DECL_UID (olddecl) = olddecl_uid;</span>
<span class="lineNum">    2754 </span><span class="lineCov">     838399 :   if (olddecl_friend)</span>
<span class="lineNum">    2755 </span><span class="lineCov">       7704 :     DECL_FRIEND_P (olddecl) = 1;</span>
<span class="lineNum">    2756 </span><span class="lineCov">     838399 :   if (hidden_friend)</span>
<span class="lineNum">    2757 </span>            :     {
<span class="lineNum">    2758 </span><span class="lineCov">         64 :       DECL_ANTICIPATED (olddecl) = 1;</span>
<span class="lineNum">    2759 </span><span class="lineCov">         32 :       DECL_HIDDEN_FRIEND_P (olddecl) = 1;</span>
<span class="lineNum">    2760 </span>            :     }
<span class="lineNum">    2761 </span>            : 
<span class="lineNum">    2762 </span>            :   /* NEWDECL contains the merged attribute lists.
<span class="lineNum">    2763 </span>            :      Update OLDDECL to be the same.  */
<span class="lineNum">    2764 </span><span class="lineCov">     838399 :   DECL_ATTRIBUTES (olddecl) = DECL_ATTRIBUTES (newdecl);</span>
<span class="lineNum">    2765 </span>            : 
<span class="lineNum">    2766 </span>            :   /* If OLDDECL had its DECL_RTL instantiated, re-invoke make_decl_rtl
<span class="lineNum">    2767 </span>            :     so that encode_section_info has a chance to look at the new decl
<span class="lineNum">    2768 </span>            :     flags and attributes.  */
<span class="lineNum">    2769 </span><span class="lineCov">    1676798 :   if (DECL_RTL_SET_P (olddecl)</span>
<span class="lineNum">    2770 </span><span class="lineCov">     838399 :       &amp;&amp; (TREE_CODE (olddecl) == FUNCTION_DECL</span>
<span class="lineNum">    2771 </span><span class="lineNoCov">          0 :           || (VAR_P (olddecl)</span>
<span class="lineNum">    2772 </span><span class="lineNoCov">          0 :               &amp;&amp; TREE_STATIC (olddecl))))</span>
<span class="lineNum">    2773 </span><span class="lineNoCov">          0 :     make_decl_rtl (olddecl);</span>
<span class="lineNum">    2774 </span>            : 
<span class="lineNum">    2775 </span>            :   /* The NEWDECL will no longer be needed.  Because every out-of-class
<span class="lineNum">    2776 </span>            :      declaration of a member results in a call to duplicate_decls,
<span class="lineNum">    2777 </span>            :      freeing these nodes represents in a significant savings.
<span class="lineNum">    2778 </span>            : 
<span class="lineNum">    2779 </span>            :      Before releasing the node, be sore to remove function from symbol
<span class="lineNum">    2780 </span>            :      table that might have been inserted there to record comdat group.
<span class="lineNum">    2781 </span>            :      Be sure to however do not free DECL_STRUCT_FUNCTION because this
<span class="lineNum">    2782 </span>            :      structure is shared in between newdecl and oldecl.  */
<span class="lineNum">    2783 </span><span class="lineCov">     838399 :   if (TREE_CODE (newdecl) == FUNCTION_DECL)</span>
<span class="lineNum">    2784 </span><span class="lineCov">    1551748 :     DECL_STRUCT_FUNCTION (newdecl) = NULL;</span>
<span class="lineNum">    2785 </span><span class="lineCov">     838399 :   if (VAR_OR_FUNCTION_DECL_P (newdecl))</span>
<span class="lineNum">    2786 </span>            :     {
<span class="lineNum">    2787 </span><span class="lineCov">     835344 :       struct symtab_node *snode = symtab_node::get (newdecl);</span>
<span class="lineNum">    2788 </span><span class="lineCov">     835344 :       if (snode)</span>
<span class="lineNum">    2789 </span><span class="lineCov">         28 :         snode-&gt;remove ();</span>
<span class="lineNum">    2790 </span>            :     }
<span class="lineNum">    2791 </span>            : 
<span class="lineNum">    2792 </span>            :   /* Remove the associated constraints for newdecl, if any, before
<span class="lineNum">    2793 </span>            :      reclaiming memory. */
<span class="lineNum">    2794 </span><span class="lineCov">     838399 :   if (flag_concepts)</span>
<span class="lineNum">    2795 </span><span class="lineCov">        463 :     remove_constraints (newdecl);</span>
<span class="lineNum">    2796 </span>            : 
<span class="lineNum">    2797 </span><span class="lineCov">     838399 :   ggc_free (newdecl);</span>
<span class="lineNum">    2798 </span>            : 
<span class="lineNum">    2799 </span><span class="lineCov">     838399 :   return olddecl;</span>
<span class="lineNum">    2800 </span>            : }
<span class="lineNum">    2801 </span>            : 
<span class="lineNum">    2802 </span>            : /* Return zero if the declaration NEWDECL is valid
<span class="lineNum">    2803 </span>            :    when the declaration OLDDECL (assumed to be for the same name)
<span class="lineNum">    2804 </span>            :    has already been seen.
<span class="lineNum">    2805 </span>            :    Otherwise return an error message format string with a %s
<span class="lineNum">    2806 </span>            :    where the identifier should go.  */
<a name="2807"><span class="lineNum">    2807 </span>            : </a>
<span class="lineNum">    2808 </span>            : static const char *
<span class="lineNum">    2809 </span><span class="lineCov">     690532 : redeclaration_error_message (tree newdecl, tree olddecl)</span>
<span class="lineNum">    2810 </span>            : {
<span class="lineNum">    2811 </span><span class="lineCov">     690532 :   if (TREE_CODE (newdecl) == TYPE_DECL)</span>
<span class="lineNum">    2812 </span>            :     {
<span class="lineNum">    2813 </span>            :       /* Because C++ can put things into name space for free,
<span class="lineNum">    2814 </span>            :          constructs like &quot;typedef struct foo { ... } foo&quot;
<span class="lineNum">    2815 </span>            :          would look like an erroneous redeclaration.  */
<span class="lineNum">    2816 </span><span class="lineCov">       7665 :       if (same_type_p (TREE_TYPE (newdecl), TREE_TYPE (olddecl)))</span>
<span class="lineNum">    2817 </span>            :         return NULL;
<span class="lineNum">    2818 </span>            :       else
<span class="lineNum">    2819 </span><span class="lineNoCov">          0 :         return G_(&quot;redefinition of %q#D&quot;);</span>
<span class="lineNum">    2820 </span>            :     }
<span class="lineNum">    2821 </span><span class="lineCov">     682867 :   else if (TREE_CODE (newdecl) == FUNCTION_DECL)</span>
<span class="lineNum">    2822 </span>            :     {
<span class="lineNum">    2823 </span>            :       /* If this is a pure function, its olddecl will actually be
<span class="lineNum">    2824 </span>            :          the original initialization to `0' (which we force to call
<span class="lineNum">    2825 </span>            :          abort()).  Don't complain about redefinition in this case.  */
<span class="lineNum">    2826 </span><span class="lineCov">    1038600 :       if (DECL_LANG_SPECIFIC (olddecl) &amp;&amp; DECL_PURE_VIRTUAL_P (olddecl)</span>
<span class="lineNum">    2827 </span><span class="lineCov">     519336 :           &amp;&amp; DECL_INITIAL (olddecl) == NULL_TREE)</span>
<span class="lineNum">    2828 </span>            :         return NULL;
<span class="lineNum">    2829 </span>            : 
<span class="lineNum">    2830 </span>            :       /* If both functions come from different namespaces, this is not
<span class="lineNum">    2831 </span>            :          a redeclaration - this is a conflict with a used function.  */
<span class="lineNum">    2832 </span><span class="lineCov">     519285 :       if (DECL_NAMESPACE_SCOPE_P (olddecl)</span>
<span class="lineNum">    2833 </span><span class="lineCov">     278860 :           &amp;&amp; DECL_CONTEXT (olddecl) != DECL_CONTEXT (newdecl)</span>
<span class="lineNum">    2834 </span><span class="lineCov">     519288 :           &amp;&amp; ! decls_match (olddecl, newdecl))</span>
<span class="lineNum">    2835 </span>            :         return G_(&quot;%qD conflicts with used function&quot;);
<span class="lineNum">    2836 </span>            : 
<span class="lineNum">    2837 </span>            :       /* We'll complain about linkage mismatches in
<span class="lineNum">    2838 </span>            :          warn_extern_redeclared_static.  */
<span class="lineNum">    2839 </span>            : 
<span class="lineNum">    2840 </span>            :       /* Defining the same name twice is no good.  */
<span class="lineNum">    2841 </span><span class="lineCov">     519285 :       if (decl_defined_p (olddecl)</span>
<span class="lineNum">    2842 </span><span class="lineCov">     519285 :           &amp;&amp; decl_defined_p (newdecl))</span>
<span class="lineNum">    2843 </span>            :         {
<span class="lineNum">    2844 </span><span class="lineCov">        279 :           if (DECL_NAME (olddecl) == NULL_TREE)</span>
<span class="lineNum">    2845 </span>            :             return G_(&quot;%q#D not declared in class&quot;);
<span class="lineNum">    2846 </span><span class="lineCov">        400 :           else if (!GNU_INLINE_P (olddecl)</span>
<span class="lineNum">    2847 </span><span class="lineCov">        363 :                    || GNU_INLINE_P (newdecl))</span>
<span class="lineNum">    2848 </span><span class="lineCov">        198 :             return G_(&quot;redefinition of %q#D&quot;);</span>
<span class="lineNum">    2849 </span>            :         }
<span class="lineNum">    2850 </span>            : 
<span class="lineNum">    2851 </span><span class="lineCov">     519087 :       if (DECL_DECLARED_INLINE_P (olddecl) &amp;&amp; DECL_DECLARED_INLINE_P (newdecl))</span>
<span class="lineNum">    2852 </span>            :         {
<span class="lineNum">    2853 </span><span class="lineCov">      94310 :           bool olda = GNU_INLINE_P (olddecl);</span>
<span class="lineNum">    2854 </span><span class="lineCov">      47155 :           bool newa = GNU_INLINE_P (newdecl);</span>
<span class="lineNum">    2855 </span>            : 
<span class="lineNum">    2856 </span><span class="lineCov">      47155 :           if (olda != newa)</span>
<span class="lineNum">    2857 </span>            :             {
<span class="lineNum">    2858 </span><span class="lineCov">         15 :               if (newa)</span>
<span class="lineNum">    2859 </span>            :                 return G_(&quot;%q+D redeclared inline with &quot;
<span class="lineNum">    2860 </span>            :                           &quot;%&lt;gnu_inline%&gt; attribute&quot;);
<span class="lineNum">    2861 </span>            :               else
<span class="lineNum">    2862 </span><span class="lineCov">          9 :                 return G_(&quot;%q+D redeclared inline without &quot;</span>
<span class="lineNum">    2863 </span>            :                           &quot;%&lt;gnu_inline%&gt; attribute&quot;);
<span class="lineNum">    2864 </span>            :             }
<span class="lineNum">    2865 </span>            :         }
<span class="lineNum">    2866 </span>            : 
<span class="lineNum">    2867 </span><span class="lineCov">     519072 :       check_abi_tag_redeclaration</span>
<span class="lineNum">    2868 </span><span class="lineCov">     519072 :         (olddecl, lookup_attribute (&quot;abi_tag&quot;, DECL_ATTRIBUTES (olddecl)),</span>
<span class="lineNum">    2869 </span><span class="lineCov">     519072 :          lookup_attribute (&quot;abi_tag&quot;, DECL_ATTRIBUTES (newdecl)));</span>
<span class="lineNum">    2870 </span>            : 
<span class="lineNum">    2871 </span><span class="lineCov">     519072 :       return NULL;</span>
<span class="lineNum">    2872 </span>            :     }
<span class="lineNum">    2873 </span><span class="lineCov">     163567 :   else if (TREE_CODE (newdecl) == TEMPLATE_DECL)</span>
<span class="lineNum">    2874 </span>            :     {
<span class="lineNum">    2875 </span><span class="lineCov">     103958 :       tree nt, ot;</span>
<span class="lineNum">    2876 </span>            : 
<span class="lineNum">    2877 </span><span class="lineCov">     207916 :       if (TREE_CODE (DECL_TEMPLATE_RESULT (newdecl)) == TYPE_DECL)</span>
<span class="lineNum">    2878 </span>            :         {
<span class="lineNum">    2879 </span><span class="lineCov">          2 :           if (COMPLETE_TYPE_P (TREE_TYPE (newdecl))</span>
<span class="lineNum">    2880 </span><span class="lineCov">          2 :               &amp;&amp; COMPLETE_TYPE_P (TREE_TYPE (olddecl)))</span>
<span class="lineNum">    2881 </span><span class="lineNoCov">          0 :             return G_(&quot;redefinition of %q#D&quot;);</span>
<span class="lineNum">    2882 </span>            :           return NULL;
<span class="lineNum">    2883 </span>            :         }
<span class="lineNum">    2884 </span>            : 
<span class="lineNum">    2885 </span><span class="lineCov">     103956 :       if (TREE_CODE (DECL_TEMPLATE_RESULT (newdecl)) != FUNCTION_DECL</span>
<span class="lineNum">    2886 </span><span class="lineCov">     103956 :           || (DECL_TEMPLATE_RESULT (newdecl)</span>
<span class="lineNum">    2887 </span><span class="lineCov">     103956 :               == DECL_TEMPLATE_RESULT (olddecl)))</span>
<span class="lineNum">    2888 </span>            :         return NULL;
<span class="lineNum">    2889 </span>            : 
<span class="lineNum">    2890 </span><span class="lineCov">     103949 :       nt = DECL_TEMPLATE_RESULT (newdecl);</span>
<span class="lineNum">    2891 </span><span class="lineCov">     103949 :       if (DECL_TEMPLATE_INFO (nt))</span>
<span class="lineNum">    2892 </span><span class="lineCov">      20461 :         nt = DECL_TEMPLATE_RESULT (template_for_substitution (nt));</span>
<span class="lineNum">    2893 </span><span class="lineCov">     103949 :       ot = DECL_TEMPLATE_RESULT (olddecl);</span>
<span class="lineNum">    2894 </span><span class="lineCov">     103949 :       if (DECL_TEMPLATE_INFO (ot))</span>
<span class="lineNum">    2895 </span><span class="lineCov">     103949 :         ot = DECL_TEMPLATE_RESULT (template_for_substitution (ot));</span>
<span class="lineNum">    2896 </span><span class="lineCov">     175242 :       if (DECL_INITIAL (nt) &amp;&amp; DECL_INITIAL (ot)</span>
<span class="lineNum">    2897 </span><span class="lineCov">     103970 :           &amp;&amp; (!GNU_INLINE_P (ot) || GNU_INLINE_P (nt)))</span>
<span class="lineNum">    2898 </span><span class="lineCov">          9 :         return G_(&quot;redefinition of %q#D&quot;);</span>
<span class="lineNum">    2899 </span>            : 
<span class="lineNum">    2900 </span><span class="lineCov">     103940 :       if (DECL_DECLARED_INLINE_P (ot) &amp;&amp; DECL_DECLARED_INLINE_P (nt))</span>
<span class="lineNum">    2901 </span>            :         {
<span class="lineNum">    2902 </span><span class="lineCov">      16732 :           bool olda = GNU_INLINE_P (ot);</span>
<span class="lineNum">    2903 </span><span class="lineCov">       8366 :           bool newa = GNU_INLINE_P (nt);</span>
<span class="lineNum">    2904 </span>            : 
<span class="lineNum">    2905 </span><span class="lineCov">       8366 :           if (olda != newa)</span>
<span class="lineNum">    2906 </span>            :             {
<span class="lineNum">    2907 </span><span class="lineNoCov">          0 :               if (newa)</span>
<span class="lineNum">    2908 </span>            :                 return G_(&quot;%q+D redeclared inline with &quot;
<span class="lineNum">    2909 </span>            :                           &quot;%&lt;gnu_inline%&gt; attribute&quot;);
<span class="lineNum">    2910 </span>            :               else
<span class="lineNum">    2911 </span><span class="lineNoCov">          0 :                 return G_(&quot;%q+D redeclared inline without &quot;</span>
<span class="lineNum">    2912 </span>            :                           &quot;%&lt;gnu_inline%&gt; attribute&quot;);
<span class="lineNum">    2913 </span>            :             }
<span class="lineNum">    2914 </span>            :         }
<span class="lineNum">    2915 </span>            : 
<span class="lineNum">    2916 </span>            :       /* Core issue #226 (C++0x): 
<span class="lineNum">    2917 </span>            :            
<span class="lineNum">    2918 </span>            :            If a friend function template declaration specifies a
<span class="lineNum">    2919 </span>            :            default template-argument, that declaration shall be a
<span class="lineNum">    2920 </span>            :            definition and shall be the only declaration of the
<span class="lineNum">    2921 </span>            :            function template in the translation unit.  */
<span class="lineNum">    2922 </span><span class="lineCov">     103940 :       if ((cxx_dialect != cxx98) </span>
<span class="lineNum">    2923 </span><span class="lineCov">      92630 :           &amp;&amp; TREE_CODE (ot) == FUNCTION_DECL &amp;&amp; DECL_FRIEND_P (ot)</span>
<span class="lineNum">    2924 </span><span class="lineCov">     117005 :           &amp;&amp; !check_default_tmpl_args (nt, DECL_TEMPLATE_PARMS (newdecl), </span>
<span class="lineNum">    2925 </span>            :                                        /*is_primary=*/true,
<span class="lineNum">    2926 </span>            :                                        /*is_partial=*/false,
<span class="lineNum">    2927 </span>            :                                        /*is_friend_decl=*/2))
<span class="lineNum">    2928 </span>            :         return G_(&quot;redeclaration of friend %q#D &quot;
<span class="lineNum">    2929 </span>            :                   &quot;may not have default template arguments&quot;);
<span class="lineNum">    2930 </span>            : 
<span class="lineNum">    2931 </span><span class="lineCov">     103938 :       return NULL;</span>
<span class="lineNum">    2932 </span>            :     }
<span class="lineNum">    2933 </span><span class="lineCov">      59609 :   else if (VAR_P (newdecl)</span>
<span class="lineNum">    2934 </span><span class="lineCov">     178668 :            &amp;&amp; CP_DECL_THREAD_LOCAL_P (newdecl) != CP_DECL_THREAD_LOCAL_P (olddecl)</span>
<span class="lineNum">    2935 </span><span class="lineCov">      59630 :            &amp;&amp; (! DECL_LANG_SPECIFIC (olddecl)</span>
<span class="lineNum">    2936 </span><span class="lineCov">         54 :                || ! CP_DECL_THREADPRIVATE_P (olddecl)</span>
<span class="lineNum">    2937 </span><span class="lineCov">         45 :                || CP_DECL_THREAD_LOCAL_P (newdecl)))</span>
<span class="lineNum">    2938 </span>            :     {
<span class="lineNum">    2939 </span>            :       /* Only variables can be thread-local, and all declarations must
<span class="lineNum">    2940 </span>            :          agree on this property.  */
<span class="lineNum">    2941 </span><span class="lineCov">         18 :       if (CP_DECL_THREAD_LOCAL_P (newdecl))</span>
<span class="lineNum">    2942 </span>            :         return G_(&quot;thread-local declaration of %q#D follows &quot;
<span class="lineNum">    2943 </span>            :                   &quot;non-thread-local declaration&quot;);
<span class="lineNum">    2944 </span>            :       else
<span class="lineNum">    2945 </span><span class="lineCov">          3 :         return G_(&quot;non-thread-local declaration of %q#D follows &quot;</span>
<span class="lineNum">    2946 </span>            :                   &quot;thread-local declaration&quot;);
<span class="lineNum">    2947 </span>            :     }
<span class="lineNum">    2948 </span><span class="lineCov">      59603 :   else if (toplevel_bindings_p () || DECL_NAMESPACE_SCOPE_P (newdecl))</span>
<span class="lineNum">    2949 </span>            :     {
<span class="lineNum">    2950 </span>            :       /* The objects have been declared at namespace scope.  If either
<span class="lineNum">    2951 </span>            :          is a member of an anonymous union, then this is an invalid
<span class="lineNum">    2952 </span>            :          redeclaration.  For example:
<span class="lineNum">    2953 </span>            : 
<span class="lineNum">    2954 </span>            :            int i;
<span class="lineNum">    2955 </span>            :            union { int i; };
<span class="lineNum">    2956 </span>            : 
<span class="lineNum">    2957 </span>            :            is invalid.  */
<span class="lineNum">    2958 </span><span class="lineCov">     119048 :       if ((VAR_P (newdecl) &amp;&amp; DECL_ANON_UNION_VAR_P (newdecl))</span>
<span class="lineNum">    2959 </span><span class="lineCov">     119090 :           || (VAR_P (olddecl) &amp;&amp; DECL_ANON_UNION_VAR_P (olddecl)))</span>
<span class="lineNum">    2960 </span>            :         return G_(&quot;redeclaration of %q#D&quot;);
<span class="lineNum">    2961 </span>            :       /* If at least one declaration is a reference, there is no
<span class="lineNum">    2962 </span>            :          conflict.  For example:
<span class="lineNum">    2963 </span>            : 
<span class="lineNum">    2964 </span>            :            int i = 3;
<span class="lineNum">    2965 </span>            :            extern int i;
<span class="lineNum">    2966 </span>            : 
<span class="lineNum">    2967 </span>            :          is valid.  */
<span class="lineNum">    2968 </span><span class="lineCov">      59563 :       if (DECL_EXTERNAL (newdecl) || DECL_EXTERNAL (olddecl))</span>
<span class="lineNum">    2969 </span>            :         return NULL;
<span class="lineNum">    2970 </span>            : 
<span class="lineNum">    2971 </span>            :       /* Static data member declared outside a class definition
<span class="lineNum">    2972 </span>            :          if the variable is defined within the class with constexpr
<span class="lineNum">    2973 </span>            :          specifier is declaration rather than definition (and
<span class="lineNum">    2974 </span>            :          deprecated).  */
<span class="lineNum">    2975 </span><span class="lineCov">       2875 :       if (cxx_dialect &gt;= cxx17</span>
<span class="lineNum">    2976 </span><span class="lineCov">       2783 :           &amp;&amp; VAR_P (olddecl)</span>
<span class="lineNum">    2977 </span><span class="lineCov">       2782 :           &amp;&amp; DECL_CLASS_SCOPE_P (olddecl)</span>
<span class="lineNum">    2978 </span><span class="lineCov">       2782 :           &amp;&amp; DECL_DECLARED_CONSTEXPR_P (olddecl)</span>
<span class="lineNum">    2979 </span><span class="lineCov">       8439 :           &amp;&amp; !DECL_INITIAL (newdecl))</span>
<span class="lineNum">    2980 </span>            :         {
<span class="lineNum">    2981 </span><span class="lineCov">       2782 :           DECL_EXTERNAL (newdecl) = 1;</span>
<span class="lineNum">    2982 </span>            :           /* For now, only warn with explicit -Wdeprecated.  */
<span class="lineNum">    2983 </span><span class="lineCov">       2782 :           if (global_options_set.x_warn_deprecated)</span>
<span class="lineNum">    2984 </span>            :             {
<span class="lineNum">    2985 </span><span class="lineCov">         24 :               auto_diagnostic_group d;</span>
<span class="lineNum">    2986 </span><span class="lineCov">         12 :               if (warning_at (DECL_SOURCE_LOCATION (newdecl), OPT_Wdeprecated,</span>
<span class="lineNum">    2987 </span>            :                                 &quot;redundant redeclaration of %&lt;constexpr%&gt; &quot;
<span class="lineNum">    2988 </span>            :                                 &quot;static data member %qD&quot;, newdecl))
<span class="lineNum">    2989 </span><span class="lineNoCov">          0 :                 inform (DECL_SOURCE_LOCATION (olddecl),</span>
<span class="lineNum">    2990 </span>            :                           &quot;previous declaration of %qD&quot;, olddecl);
<span class="lineNum">    2991 </span>            :             }
<span class="lineNum">    2992 </span><span class="lineCov">       2782 :           return NULL;</span>
<span class="lineNum">    2993 </span>            :         }
<span class="lineNum">    2994 </span>            : 
<span class="lineNum">    2995 </span>            :       /* Reject two definitions.  */
<span class="lineNum">    2996 </span>            :       return G_(&quot;redefinition of %q#D&quot;);
<span class="lineNum">    2997 </span>            :     }
<span class="lineNum">    2998 </span>            :   else
<span class="lineNum">    2999 </span>            :     {
<span class="lineNum">    3000 </span>            :       /* Objects declared with block scope:  */
<span class="lineNum">    3001 </span>            :       /* Reject two definitions, and reject a definition
<span class="lineNum">    3002 </span>            :          together with an external reference.  */
<span class="lineNum">    3003 </span><span class="lineCov">         56 :       if (!(DECL_EXTERNAL (newdecl) &amp;&amp; DECL_EXTERNAL (olddecl)))</span>
<span class="lineNum">    3004 </span><span class="lineCov">         28 :         return G_(&quot;redeclaration of %q#D&quot;);</span>
<span class="lineNum">    3005 </span>            :       return NULL;
<span class="lineNum">    3006 </span>            :     }
<span class="lineNum">    3007 </span>            : }
<span class="lineNum">    3008 </span>            : 
<span class="lineNum">    3009 </span>            : 
<span class="lineNum">    3010 </span>            : /* Hash and equality functions for the named_label table.  */
<a name="3011"><span class="lineNum">    3011 </span>            : </a>
<span class="lineNum">    3012 </span>            : hashval_t
<span class="lineNum">    3013 </span><span class="lineNoCov">          0 : named_label_hash::hash (const value_type entry)</span>
<span class="lineNum">    3014 </span>            : {
<span class="lineNum">    3015 </span><span class="lineCov">         60 :   return IDENTIFIER_HASH_VALUE (entry-&gt;name);</span>
<span class="lineNum">    3016 </span>            : }
<a name="3017"><span class="lineNum">    3017 </span>            : </a>
<span class="lineNum">    3018 </span>            : bool
<span class="lineNum">    3019 </span><span class="lineNoCov">          0 : named_label_hash::equal (const value_type entry, compare_type name)</span>
<span class="lineNum">    3020 </span>            : {
<span class="lineNum">    3021 </span><span class="lineCov">       2079 :   return name == entry-&gt;name;</span>
<span class="lineNum">    3022 </span>            : }
<span class="lineNum">    3023 </span>            : 
<span class="lineNum">    3024 </span>            : /* Look for a label named ID in the current function.  If one cannot
<span class="lineNum">    3025 </span>            :    be found, create one.  Return the named_label_entry, or NULL on
<span class="lineNum">    3026 </span>            :    failure.  */
<a name="3027"><span class="lineNum">    3027 </span>            : </a>
<span class="lineNum">    3028 </span>            : static named_label_entry *
<span class="lineNum">    3029 </span><span class="lineCov">       2247 : lookup_label_1 (tree id, bool making_local_p)</span>
<span class="lineNum">    3030 </span>            : {
<span class="lineNum">    3031 </span>            :   /* You can't use labels at global scope.  */
<span class="lineNum">    3032 </span><span class="lineCov">       2247 :   if (current_function_decl == NULL_TREE)</span>
<span class="lineNum">    3033 </span>            :     {
<span class="lineNum">    3034 </span><span class="lineCov">          3 :       error (&quot;label %qE referenced outside of any function&quot;, id);</span>
<span class="lineNum">    3035 </span><span class="lineCov">          3 :       return NULL;</span>
<span class="lineNum">    3036 </span>            :     }
<span class="lineNum">    3037 </span>            : 
<span class="lineNum">    3038 </span><span class="lineCov">       2244 :   if (!named_labels)</span>
<span class="lineNum">    3039 </span><span class="lineCov">        776 :     named_labels = hash_table&lt;named_label_hash&gt;::create_ggc (13);</span>
<span class="lineNum">    3040 </span>            : 
<span class="lineNum">    3041 </span><span class="lineCov">       2244 :   hashval_t hash = IDENTIFIER_HASH_VALUE (id);</span>
<span class="lineNum">    3042 </span><span class="lineCov">       2244 :   named_label_entry **slot</span>
<span class="lineNum">    3043 </span><span class="lineCov">       2244 :     = named_labels-&gt;find_slot_with_hash (id, hash, INSERT);</span>
<span class="lineNum">    3044 </span><span class="lineCov">       2244 :   named_label_entry *old = *slot;</span>
<span class="lineNum">    3045 </span>            :   
<span class="lineNum">    3046 </span><span class="lineCov">       2244 :   if (old &amp;&amp; old-&gt;label_decl)</span>
<span class="lineNum">    3047 </span>            :     {
<span class="lineNum">    3048 </span><span class="lineCov">       1101 :       if (!making_local_p)</span>
<span class="lineNum">    3049 </span>            :         return old;
<span class="lineNum">    3050 </span>            : 
<span class="lineNum">    3051 </span><span class="lineCov">          9 :       if (old-&gt;binding_level == current_binding_level)</span>
<span class="lineNum">    3052 </span>            :         {
<span class="lineNum">    3053 </span><span class="lineNoCov">          0 :           error (&quot;local label %qE conflicts with existing label&quot;, id);</span>
<span class="lineNum">    3054 </span><span class="lineNoCov">          0 :           inform (DECL_SOURCE_LOCATION (old-&gt;label_decl), &quot;previous label&quot;);</span>
<span class="lineNum">    3055 </span><span class="lineNoCov">          0 :           return NULL;</span>
<span class="lineNum">    3056 </span>            :         }
<span class="lineNum">    3057 </span>            :     }
<span class="lineNum">    3058 </span>            : 
<span class="lineNum">    3059 </span>            :   /* We are making a new decl, create or reuse the named_label_entry  */
<span class="lineNum">    3060 </span><span class="lineCov">       1152 :   named_label_entry *ent = NULL;</span>
<span class="lineNum">    3061 </span><span class="lineCov">       1152 :   if (old &amp;&amp; !old-&gt;label_decl)</span>
<span class="lineNum">    3062 </span>            :     ent = old;
<span class="lineNum">    3063 </span>            :   else
<span class="lineNum">    3064 </span>            :     {
<span class="lineNum">    3065 </span><span class="lineCov">       1140 :       ent = ggc_cleared_alloc&lt;named_label_entry&gt; ();</span>
<span class="lineNum">    3066 </span><span class="lineCov">       1140 :       ent-&gt;name = id;</span>
<span class="lineNum">    3067 </span><span class="lineCov">       1140 :       ent-&gt;outer = old;</span>
<span class="lineNum">    3068 </span><span class="lineCov">       1140 :       *slot = ent;</span>
<span class="lineNum">    3069 </span>            :     }
<span class="lineNum">    3070 </span>            : 
<span class="lineNum">    3071 </span>            :   /* Now create the LABEL_DECL.  */
<span class="lineNum">    3072 </span><span class="lineCov">       1152 :   tree decl = build_decl (input_location, LABEL_DECL, id, void_type_node);</span>
<span class="lineNum">    3073 </span>            : 
<span class="lineNum">    3074 </span><span class="lineCov">       1152 :   DECL_CONTEXT (decl) = current_function_decl;</span>
<span class="lineNum">    3075 </span><span class="lineCov">       1152 :   SET_DECL_MODE (decl, VOIDmode);</span>
<span class="lineNum">    3076 </span><span class="lineCov">       1152 :   if (making_local_p)</span>
<span class="lineNum">    3077 </span>            :     {
<span class="lineNum">    3078 </span><span class="lineCov">         63 :       C_DECLARED_LABEL_FLAG (decl) = true;</span>
<span class="lineNum">    3079 </span><span class="lineCov">         63 :       DECL_CHAIN (decl) = current_binding_level-&gt;names;</span>
<span class="lineNum">    3080 </span><span class="lineCov">         63 :       current_binding_level-&gt;names = decl;</span>
<span class="lineNum">    3081 </span>            :     }
<span class="lineNum">    3082 </span>            : 
<span class="lineNum">    3083 </span><span class="lineCov">       1152 :   ent-&gt;label_decl = decl;</span>
<span class="lineNum">    3084 </span>            : 
<span class="lineNum">    3085 </span><span class="lineCov">       1152 :   return ent;</span>
<span class="lineNum">    3086 </span>            : }
<span class="lineNum">    3087 </span>            : 
<span class="lineNum">    3088 </span>            : /* Wrapper for lookup_label_1.  */
<a name="3089"><span class="lineNum">    3089 </span>            : </a>
<span class="lineNum">    3090 </span>            : tree
<span class="lineNum">    3091 </span><span class="lineCov">       1032 : lookup_label (tree id)</span>
<span class="lineNum">    3092 </span>            : {
<span class="lineNum">    3093 </span><span class="lineCov">       1032 :   bool subtime = timevar_cond_start (TV_NAME_LOOKUP);</span>
<span class="lineNum">    3094 </span><span class="lineCov">       1032 :   named_label_entry *ent = lookup_label_1 (id, false);</span>
<span class="lineNum">    3095 </span><span class="lineCov">       1032 :   timevar_cond_stop (TV_NAME_LOOKUP, subtime);</span>
<span class="lineNum">    3096 </span><span class="lineCov">       1032 :   return ent ? ent-&gt;label_decl : NULL_TREE;</span>
<span class="lineNum">    3097 </span>            : }
<a name="3098"><span class="lineNum">    3098 </span>            : </a>
<span class="lineNum">    3099 </span>            : tree
<span class="lineNum">    3100 </span><span class="lineCov">         63 : declare_local_label (tree id)</span>
<span class="lineNum">    3101 </span>            : {
<span class="lineNum">    3102 </span><span class="lineCov">         63 :   bool subtime = timevar_cond_start (TV_NAME_LOOKUP);</span>
<span class="lineNum">    3103 </span><span class="lineCov">         63 :   named_label_entry *ent = lookup_label_1 (id, true);</span>
<span class="lineNum">    3104 </span><span class="lineCov">         63 :   timevar_cond_stop (TV_NAME_LOOKUP, subtime);</span>
<span class="lineNum">    3105 </span><span class="lineCov">         63 :   return ent ? ent-&gt;label_decl : NULL_TREE;</span>
<span class="lineNum">    3106 </span>            : }
<span class="lineNum">    3107 </span>            : 
<span class="lineNum">    3108 </span>            : /* Returns nonzero if it is ill-formed to jump past the declaration of
<span class="lineNum">    3109 </span>            :    DECL.  Returns 2 if it's also a real problem.  */
<a name="3110"><span class="lineNum">    3110 </span>            : </a>
<span class="lineNum">    3111 </span>            : static int
<span class="lineNum">    3112 </span><span class="lineCov">      10240 : decl_jump_unsafe (tree decl)</span>
<span class="lineNum">    3113 </span>            : {
<span class="lineNum">    3114 </span>            :   /* [stmt.dcl]/3: A program that jumps from a point where a local variable
<span class="lineNum">    3115 </span>            :      with automatic storage duration is not in scope to a point where it is
<span class="lineNum">    3116 </span>            :      in scope is ill-formed unless the variable has scalar type, class type
<span class="lineNum">    3117 </span>            :      with a trivial default constructor and a trivial destructor, a
<span class="lineNum">    3118 </span>            :      cv-qualified version of one of these types, or an array of one of the
<span class="lineNum">    3119 </span>            :      preceding types and is declared without an initializer (8.5).  */
<span class="lineNum">    3120 </span><span class="lineCov">      10240 :   tree type = TREE_TYPE (decl);</span>
<span class="lineNum">    3121 </span>            : 
<span class="lineNum">    3122 </span><span class="lineCov">      10240 :   if (!VAR_P (decl) || TREE_STATIC (decl)</span>
<span class="lineNum">    3123 </span><span class="lineCov">      10011 :       || type == error_mark_node)</span>
<span class="lineNum">    3124 </span>            :     return 0;
<span class="lineNum">    3125 </span>            : 
<span class="lineNum">    3126 </span><span class="lineCov">       9993 :   if (DECL_NONTRIVIALLY_INITIALIZED_P (decl)</span>
<span class="lineNum">    3127 </span><span class="lineCov">       9993 :       || variably_modified_type_p (type, NULL_TREE))</span>
<span class="lineNum">    3128 </span><span class="lineCov">        731 :     return 2;</span>
<span class="lineNum">    3129 </span>            : 
<span class="lineNum">    3130 </span><span class="lineCov">       9262 :   if (TYPE_HAS_NONTRIVIAL_DESTRUCTOR (type))</span>
<span class="lineNum">    3131 </span><span class="lineCov">         15 :     return 1;</span>
<span class="lineNum">    3132 </span>            : 
<span class="lineNum">    3133 </span>            :   return 0;
<span class="lineNum">    3134 </span>            : }
<span class="lineNum">    3135 </span>            : 
<span class="lineNum">    3136 </span>            : /* A subroutine of check_previous_goto_1 and check_goto to identify a branch
<span class="lineNum">    3137 </span>            :    to the user.  */
<a name="3138"><span class="lineNum">    3138 </span>            : </a>
<span class="lineNum">    3139 </span>            : static bool
<span class="lineNum">    3140 </span><span class="lineCov">        191 : identify_goto (tree decl, location_t loc, const location_t *locus,</span>
<span class="lineNum">    3141 </span>            :                diagnostic_t diag_kind)
<span class="lineNum">    3142 </span>            : {
<span class="lineNum">    3143 </span><span class="lineCov">        191 :   bool complained</span>
<span class="lineNum">    3144 </span><span class="lineCov">        268 :     = emit_diagnostic (diag_kind, loc, 0,</span>
<span class="lineNum">    3145 </span>            :                        decl ? N_(&quot;jump to label %qD&quot;)
<span class="lineNum">    3146 </span>            :                        : N_(&quot;jump to case label&quot;), decl);
<span class="lineNum">    3147 </span><span class="lineCov">        191 :   if (complained &amp;&amp; locus)</span>
<span class="lineNum">    3148 </span><span class="lineCov">        114 :     inform (*locus, &quot;  from here&quot;);</span>
<span class="lineNum">    3149 </span><span class="lineCov">        191 :   return complained;</span>
<span class="lineNum">    3150 </span>            : }
<span class="lineNum">    3151 </span>            : 
<span class="lineNum">    3152 </span>            : /* Check that a single previously seen jump to a newly defined label
<span class="lineNum">    3153 </span>            :    is OK.  DECL is the LABEL_DECL or 0; LEVEL is the binding_level for
<span class="lineNum">    3154 </span>            :    the jump context; NAMES are the names in scope in LEVEL at the jump
<span class="lineNum">    3155 </span>            :    context; LOCUS is the source position of the jump or 0.  Returns
<span class="lineNum">    3156 </span>            :    true if all is well.  */
<a name="3157"><span class="lineNum">    3157 </span>            : </a>
<span class="lineNum">    3158 </span>            : static bool
<span class="lineNum">    3159 </span><span class="lineCov">     128396 : check_previous_goto_1 (tree decl, cp_binding_level* level, tree names,</span>
<span class="lineNum">    3160 </span>            :                        bool exited_omp, const location_t *locus)
<span class="lineNum">    3161 </span>            : {
<span class="lineNum">    3162 </span><span class="lineCov">     128396 :   cp_binding_level *b;</span>
<span class="lineNum">    3163 </span><span class="lineCov">     128396 :   bool complained = false;</span>
<span class="lineNum">    3164 </span><span class="lineCov">     128396 :   int identified = 0;</span>
<span class="lineNum">    3165 </span><span class="lineCov">     128396 :   bool saw_eh = false, saw_omp = false, saw_tm = false, saw_cxif = false;</span>
<span class="lineNum">    3166 </span>            : 
<span class="lineNum">    3167 </span><span class="lineCov">     128396 :   if (exited_omp)</span>
<span class="lineNum">    3168 </span>            :     {
<span class="lineNum">    3169 </span><span class="lineCov">          6 :       complained = identify_goto (decl, input_location, locus, DK_ERROR);</span>
<span class="lineNum">    3170 </span><span class="lineCov">          6 :       if (complained)</span>
<span class="lineNum">    3171 </span><span class="lineCov">          6 :         inform (input_location, &quot;  exits OpenMP structured block&quot;);</span>
<span class="lineNum">    3172 </span>            :       saw_omp = true;
<span class="lineNum">    3173 </span>            :       identified = 2;
<span class="lineNum">    3174 </span>            :     }
<span class="lineNum">    3175 </span>            : 
<span class="lineNum">    3176 </span><span class="lineCov">     256520 :   for (b = current_binding_level; b ; b = b-&gt;level_chain)</span>
<span class="lineNum">    3177 </span>            :     {
<span class="lineNum">    3178 </span><span class="lineCov">     256520 :       tree new_decls, old_decls = (b == level ? names : NULL_TREE);</span>
<span class="lineNum">    3179 </span>            : 
<span class="lineNum">    3180 </span><span class="lineCov">     265198 :       for (new_decls = b-&gt;names; new_decls != old_decls;</span>
<span class="lineNum">    3181 </span><span class="lineCov">       8678 :            new_decls = (DECL_P (new_decls) ? DECL_CHAIN (new_decls)</span>
<span class="lineNum">    3182 </span><span class="lineCov">          3 :                         : TREE_CHAIN (new_decls)))</span>
<span class="lineNum">    3183 </span>            :         {
<span class="lineNum">    3184 </span><span class="lineCov">       8678 :           int problem = decl_jump_unsafe (new_decls);</span>
<span class="lineNum">    3185 </span><span class="lineCov">       8678 :           if (! problem)</span>
<span class="lineNum">    3186 </span>            :             continue;
<span class="lineNum">    3187 </span>            : 
<span class="lineNum">    3188 </span><span class="lineCov">         36 :           if (!identified)</span>
<span class="lineNum">    3189 </span>            :             {
<span class="lineNum">    3190 </span><span class="lineCov">         36 :               complained = identify_goto (decl, input_location, locus,</span>
<span class="lineNum">    3191 </span>            :                                           problem &gt; 1
<span class="lineNum">    3192 </span>            :                                           ? DK_ERROR : DK_PERMERROR);
<span class="lineNum">    3193 </span><span class="lineCov">         36 :               identified = 1;</span>
<span class="lineNum">    3194 </span>            :             }
<span class="lineNum">    3195 </span><span class="lineCov">         36 :           if (complained)</span>
<span class="lineNum">    3196 </span>            :             {
<span class="lineNum">    3197 </span><span class="lineCov">         36 :               if (problem &gt; 1)</span>
<span class="lineNum">    3198 </span><span class="lineCov">         33 :                 inform (DECL_SOURCE_LOCATION (new_decls),</span>
<span class="lineNum">    3199 </span>            :                         &quot;  crosses initialization of %q#D&quot;, new_decls);
<span class="lineNum">    3200 </span>            :               else
<span class="lineNum">    3201 </span><span class="lineCov">          3 :                 inform (DECL_SOURCE_LOCATION (new_decls),</span>
<span class="lineNum">    3202 </span>            :                         &quot;  enters scope of %q#D, which has &quot;
<span class="lineNum">    3203 </span>            :                         &quot;non-trivial destructor&quot;, new_decls);
<span class="lineNum">    3204 </span>            :             }
<span class="lineNum">    3205 </span>            :         }
<span class="lineNum">    3206 </span>            : 
<span class="lineNum">    3207 </span><span class="lineCov">     256520 :       if (b == level)</span>
<span class="lineNum">    3208 </span>            :         break;
<span class="lineNum">    3209 </span>            : 
<span class="lineNum">    3210 </span><span class="lineCov">     128124 :       const char *inf = NULL;</span>
<span class="lineNum">    3211 </span><span class="lineCov">     128124 :       location_t loc = input_location;</span>
<span class="lineNum">    3212 </span><span class="lineCov">     128124 :       switch (b-&gt;kind)</span>
<span class="lineNum">    3213 </span>            :         {
<span class="lineNum">    3214 </span><span class="lineCov">          3 :         case sk_try:</span>
<span class="lineNum">    3215 </span><span class="lineCov">          3 :           if (!saw_eh)</span>
<span class="lineNum">    3216 </span><span class="lineCov">          3 :             inf = N_(&quot;enters try block&quot;);</span>
<span class="lineNum">    3217 </span>            :           saw_eh = true;
<span class="lineNum">    3218 </span>            :           break;
<span class="lineNum">    3219 </span>            : 
<span class="lineNum">    3220 </span><span class="lineCov">          9 :         case sk_catch:</span>
<span class="lineNum">    3221 </span><span class="lineCov">          9 :           if (!saw_eh)</span>
<span class="lineNum">    3222 </span><span class="lineCov">          9 :             inf = N_(&quot;enters catch block&quot;);</span>
<span class="lineNum">    3223 </span>            :           saw_eh = true;
<span class="lineNum">    3224 </span>            :           break;
<span class="lineNum">    3225 </span>            : 
<span class="lineNum">    3226 </span><span class="lineCov">         96 :         case sk_omp:</span>
<span class="lineNum">    3227 </span><span class="lineCov">         96 :           if (!saw_omp)</span>
<span class="lineNum">    3228 </span><span class="lineCov">         81 :             inf = N_(&quot;enters OpenMP structured block&quot;);</span>
<span class="lineNum">    3229 </span>            :           saw_omp = true;
<span class="lineNum">    3230 </span>            :           break;
<span class="lineNum">    3231 </span>            : 
<span class="lineNum">    3232 </span><span class="lineCov">          3 :         case sk_transaction:</span>
<span class="lineNum">    3233 </span><span class="lineCov">          3 :           if (!saw_tm)</span>
<span class="lineNum">    3234 </span><span class="lineCov">          3 :             inf = N_(&quot;enters synchronized or atomic statement&quot;);</span>
<span class="lineNum">    3235 </span>            :           saw_tm = true;
<span class="lineNum">    3236 </span>            :           break;
<span class="lineNum">    3237 </span>            : 
<span class="lineNum">    3238 </span><span class="lineCov">     127968 :         case sk_block:</span>
<span class="lineNum">    3239 </span><span class="lineCov">     127968 :           if (!saw_cxif &amp;&amp; level_for_constexpr_if (b-&gt;level_chain))</span>
<span class="lineNum">    3240 </span>            :             {
<span class="lineNum">    3241 </span><span class="lineCov">          6 :               inf = N_(&quot;enters constexpr if statement&quot;);</span>
<span class="lineNum">    3242 </span><span class="lineCov">          6 :               loc = EXPR_LOCATION (b-&gt;level_chain-&gt;this_entity);</span>
<span class="lineNum">    3243 </span>            :               saw_cxif = true;
<span class="lineNum">    3244 </span>            :             }
<span class="lineNum">    3245 </span>            :           break;
<span class="lineNum">    3246 </span>            : 
<span class="lineNum">    3247 </span>            :         default:
<span class="lineNum">    3248 </span>            :           break;
<span class="lineNum">    3249 </span>            :         }
<span class="lineNum">    3250 </span>            : 
<span class="lineNum">    3251 </span><span class="lineCov">     128124 :       if (inf)</span>
<span class="lineNum">    3252 </span>            :         {
<span class="lineNum">    3253 </span><span class="lineCov">        102 :           if (identified &lt; 2)</span>
<span class="lineNum">    3254 </span><span class="lineCov">        102 :             complained = identify_goto (decl, input_location, locus, DK_ERROR);</span>
<span class="lineNum">    3255 </span><span class="lineCov">        102 :           identified = 2;</span>
<span class="lineNum">    3256 </span><span class="lineCov">        102 :           if (complained)</span>
<span class="lineNum">    3257 </span><span class="lineCov">        102 :             inform (loc, &quot;  %s&quot;, inf);</span>
<span class="lineNum">    3258 </span>            :         }
<span class="lineNum">    3259 </span>            :     }
<span class="lineNum">    3260 </span>            : 
<span class="lineNum">    3261 </span><span class="lineCov">     128396 :   return !identified;</span>
<span class="lineNum">    3262 </span>            : }
<a name="3263"><span class="lineNum">    3263 </span>            : </a>
<span class="lineNum">    3264 </span>            : static void
<span class="lineNum">    3265 </span><span class="lineNoCov">          0 : check_previous_goto (tree decl, struct named_label_use_entry *use)</span>
<span class="lineNum">    3266 </span>            : {
<span class="lineNum">    3267 </span><span class="lineCov">       1130 :   check_previous_goto_1 (decl, use-&gt;binding_level,</span>
<span class="lineNum">    3268 </span><span class="lineCov">        565 :                          use-&gt;names_in_scope, use-&gt;in_omp_scope,</span>
<span class="lineNum">    3269 </span><span class="lineNoCov">          0 :                          &amp;use-&gt;o_goto_locus);</span>
<span class="lineNum">    3270 </span><span class="lineNoCov">          0 : }</span>
<a name="3271"><span class="lineNum">    3271 </span>            : </a>
<span class="lineNum">    3272 </span>            : static bool
<span class="lineNum">    3273 </span><span class="lineNoCov">          0 : check_switch_goto (cp_binding_level* level)</span>
<span class="lineNum">    3274 </span>            : {
<span class="lineNum">    3275 </span><span class="lineNoCov">          0 :   return check_previous_goto_1 (NULL_TREE, level, level-&gt;names, false, NULL);</span>
<span class="lineNum">    3276 </span>            : }
<span class="lineNum">    3277 </span>            : 
<span class="lineNum">    3278 </span>            : /* Check that a new jump to a label DECL is OK.  Called by
<span class="lineNum">    3279 </span>            :    finish_goto_stmt.  */
<a name="3280"><span class="lineNum">    3280 </span>            : </a>
<span class="lineNum">    3281 </span>            : void
<span class="lineNum">    3282 </span><span class="lineCov">       1049 : check_goto (tree decl)</span>
<span class="lineNum">    3283 </span>            : {
<span class="lineNum">    3284 </span>            :   /* We can't know where a computed goto is jumping.
<span class="lineNum">    3285 </span>            :      So we assume that it's OK.  */
<span class="lineNum">    3286 </span><span class="lineCov">       1049 :   if (TREE_CODE (decl) != LABEL_DECL)</span>
<span class="lineNum">    3287 </span>            :     return;
<span class="lineNum">    3288 </span>            : 
<span class="lineNum">    3289 </span>            :   /* We didn't record any information about this label when we created it,
<span class="lineNum">    3290 </span>            :      and there's not much point since it's trivial to analyze as a return.  */
<span class="lineNum">    3291 </span><span class="lineCov">        962 :   if (decl == cdtor_label)</span>
<span class="lineNum">    3292 </span>            :     return;
<span class="lineNum">    3293 </span>            : 
<span class="lineNum">    3294 </span><span class="lineCov">        852 :   hashval_t hash = IDENTIFIER_HASH_VALUE (DECL_NAME (decl));</span>
<span class="lineNum">    3295 </span><span class="lineCov">        852 :   named_label_entry **slot</span>
<span class="lineNum">    3296 </span><span class="lineCov">       1704 :     = named_labels-&gt;find_slot_with_hash (DECL_NAME (decl), hash, NO_INSERT);</span>
<span class="lineNum">    3297 </span><span class="lineCov">        852 :   named_label_entry *ent = *slot;</span>
<span class="lineNum">    3298 </span>            : 
<span class="lineNum">    3299 </span>            :   /* If the label hasn't been defined yet, defer checking.  */
<span class="lineNum">    3300 </span><span class="lineCov">        852 :   if (! DECL_INITIAL (decl))</span>
<span class="lineNum">    3301 </span>            :     {
<span class="lineNum">    3302 </span>            :       /* Don't bother creating another use if the last goto had the
<span class="lineNum">    3303 </span>            :          same data, and will therefore create the same set of errors.  */
<span class="lineNum">    3304 </span><span class="lineCov">        647 :       if (ent-&gt;uses</span>
<span class="lineNum">    3305 </span><span class="lineCov">        104 :           &amp;&amp; ent-&gt;uses-&gt;names_in_scope == current_binding_level-&gt;names)</span>
<span class="lineNum">    3306 </span>            :         return;
<span class="lineNum">    3307 </span>            : 
<span class="lineNum">    3308 </span><span class="lineCov">        571 :       named_label_use_entry *new_use</span>
<span class="lineNum">    3309 </span><span class="lineCov">        571 :         = ggc_alloc&lt;named_label_use_entry&gt; ();</span>
<span class="lineNum">    3310 </span><span class="lineCov">        571 :       new_use-&gt;binding_level = current_binding_level;</span>
<span class="lineNum">    3311 </span><span class="lineCov">        571 :       new_use-&gt;names_in_scope = current_binding_level-&gt;names;</span>
<span class="lineNum">    3312 </span><span class="lineCov">        571 :       new_use-&gt;o_goto_locus = input_location;</span>
<span class="lineNum">    3313 </span><span class="lineCov">        571 :       new_use-&gt;in_omp_scope = false;</span>
<span class="lineNum">    3314 </span>            : 
<span class="lineNum">    3315 </span><span class="lineCov">        571 :       new_use-&gt;next = ent-&gt;uses;</span>
<span class="lineNum">    3316 </span><span class="lineCov">        571 :       ent-&gt;uses = new_use;</span>
<span class="lineNum">    3317 </span><span class="lineCov">        571 :       return;</span>
<span class="lineNum">    3318 </span>            :     }
<span class="lineNum">    3319 </span>            : 
<span class="lineNum">    3320 </span><span class="lineCov">        205 :   bool saw_catch = false, complained = false;</span>
<span class="lineNum">    3321 </span><span class="lineCov">        205 :   int identified = 0;</span>
<span class="lineNum">    3322 </span><span class="lineCov">        205 :   tree bad;</span>
<span class="lineNum">    3323 </span><span class="lineCov">        205 :   unsigned ix;</span>
<span class="lineNum">    3324 </span>            : 
<span class="lineNum">    3325 </span><span class="lineCov">        196 :   if (ent-&gt;in_try_scope || ent-&gt;in_catch_scope || ent-&gt;in_transaction_scope</span>
<span class="lineNum">    3326 </span><span class="lineCov">        190 :       || ent-&gt;in_constexpr_if</span>
<span class="lineNum">    3327 </span><span class="lineCov">        393 :       || ent-&gt;in_omp_scope || !vec_safe_is_empty (ent-&gt;bad_decls))</span>
<span class="lineNum">    3328 </span>            :     {
<span class="lineNum">    3329 </span><span class="lineCov">         26 :       diagnostic_t diag_kind = DK_PERMERROR;</span>
<span class="lineNum">    3330 </span><span class="lineCov">         26 :       if (ent-&gt;in_try_scope || ent-&gt;in_catch_scope || ent-&gt;in_constexpr_if</span>
<span class="lineNum">    3331 </span><span class="lineCov">         12 :           || ent-&gt;in_transaction_scope || ent-&gt;in_omp_scope)</span>
<span class="lineNum">    3332 </span><span class="lineCov">         20 :         diag_kind = DK_ERROR;</span>
<span class="lineNum">    3333 </span><span class="lineCov">         26 :       complained = identify_goto (decl, DECL_SOURCE_LOCATION (decl),</span>
<span class="lineNum">    3334 </span>            :                                   &amp;input_location, diag_kind);
<span class="lineNum">    3335 </span><span class="lineCov">         26 :       identified = 1 + (diag_kind == DK_ERROR);</span>
<span class="lineNum">    3336 </span>            :     }
<span class="lineNum">    3337 </span>            : 
<span class="lineNum">    3338 </span><span class="lineCov">        211 :   FOR_EACH_VEC_SAFE_ELT (ent-&gt;bad_decls, ix, bad)</span>
<span class="lineNum">    3339 </span>            :     {
<span class="lineNum">    3340 </span><span class="lineCov">          6 :       int u = decl_jump_unsafe (bad);</span>
<span class="lineNum">    3341 </span>            : 
<span class="lineNum">    3342 </span><span class="lineCov">          6 :       if (u &gt; 1 &amp;&amp; DECL_ARTIFICIAL (bad))</span>
<span class="lineNum">    3343 </span>            :         {
<span class="lineNum">    3344 </span>            :           /* Can't skip init of __exception_info.  */
<span class="lineNum">    3345 </span><span class="lineNoCov">          0 :           if (identified == 1)</span>
<span class="lineNum">    3346 </span>            :             {
<span class="lineNum">    3347 </span><span class="lineNoCov">          0 :               complained = identify_goto (decl, DECL_SOURCE_LOCATION (decl),</span>
<span class="lineNum">    3348 </span>            :                                           &amp;input_location, DK_ERROR);
<span class="lineNum">    3349 </span><span class="lineNoCov">          0 :               identified = 2;</span>
<span class="lineNum">    3350 </span>            :             }
<span class="lineNum">    3351 </span><span class="lineNoCov">          0 :           if (complained)</span>
<span class="lineNum">    3352 </span><span class="lineNoCov">          0 :             inform (DECL_SOURCE_LOCATION (bad), &quot;  enters catch block&quot;);</span>
<span class="lineNum">    3353 </span>            :           saw_catch = true;
<span class="lineNum">    3354 </span>            :         }
<span class="lineNum">    3355 </span><span class="lineCov">          6 :       else if (complained)</span>
<span class="lineNum">    3356 </span>            :         {
<span class="lineNum">    3357 </span><span class="lineCov">          6 :           if (u &gt; 1)</span>
<span class="lineNum">    3358 </span><span class="lineCov">          6 :             inform (DECL_SOURCE_LOCATION (bad),</span>
<span class="lineNum">    3359 </span>            :                     &quot;  skips initialization of %q#D&quot;, bad);
<span class="lineNum">    3360 </span>            :           else
<span class="lineNum">    3361 </span><span class="lineNoCov">          0 :             inform (DECL_SOURCE_LOCATION (bad),</span>
<span class="lineNum">    3362 </span>            :                     &quot;  enters scope of %q#D which has &quot;
<span class="lineNum">    3363 </span>            :                     &quot;non-trivial destructor&quot;, bad);
<span class="lineNum">    3364 </span>            :         }
<span class="lineNum">    3365 </span>            :     }
<span class="lineNum">    3366 </span>            : 
<span class="lineNum">    3367 </span><span class="lineCov">        205 :   if (complained)</span>
<span class="lineNum">    3368 </span>            :     {
<span class="lineNum">    3369 </span><span class="lineCov">         26 :       if (ent-&gt;in_try_scope)</span>
<span class="lineNum">    3370 </span><span class="lineCov">          9 :         inform (input_location, &quot;  enters try block&quot;);</span>
<span class="lineNum">    3371 </span><span class="lineCov">         17 :       else if (ent-&gt;in_catch_scope &amp;&amp; !saw_catch)</span>
<span class="lineNum">    3372 </span><span class="lineCov">          3 :         inform (input_location, &quot;  enters catch block&quot;);</span>
<span class="lineNum">    3373 </span><span class="lineCov">         14 :       else if (ent-&gt;in_transaction_scope)</span>
<span class="lineNum">    3374 </span><span class="lineCov">          3 :         inform (input_location, &quot;  enters synchronized or atomic statement&quot;);</span>
<span class="lineNum">    3375 </span><span class="lineCov">         11 :       else if (ent-&gt;in_constexpr_if)</span>
<span class="lineNum">    3376 </span><span class="lineCov">          2 :         inform (input_location, &quot;  enters %&lt;constexpr%&gt; if statement&quot;);</span>
<span class="lineNum">    3377 </span>            :     }
<span class="lineNum">    3378 </span>            : 
<span class="lineNum">    3379 </span><span class="lineCov">        205 :   if (ent-&gt;in_omp_scope)</span>
<span class="lineNum">    3380 </span>            :     {
<span class="lineNum">    3381 </span><span class="lineCov">          3 :       if (complained)</span>
<span class="lineNum">    3382 </span><span class="lineCov">          3 :         inform (input_location, &quot;  enters OpenMP structured block&quot;);</span>
<span class="lineNum">    3383 </span>            :     }
<span class="lineNum">    3384 </span><span class="lineCov">        202 :   else if (flag_openmp)</span>
<span class="lineNum">    3385 </span><span class="lineCov">         21 :     for (cp_binding_level *b = current_binding_level; b ; b = b-&gt;level_chain)</span>
<span class="lineNum">    3386 </span>            :       {
<span class="lineNum">    3387 </span><span class="lineCov">         21 :         if (b == ent-&gt;binding_level)</span>
<span class="lineNum">    3388 </span>            :           break;
<span class="lineNum">    3389 </span><span class="lineCov">         21 :         if (b-&gt;kind == sk_omp)</span>
<span class="lineNum">    3390 </span>            :           {
<span class="lineNum">    3391 </span><span class="lineCov">         21 :             if (identified &lt; 2)</span>
<span class="lineNum">    3392 </span>            :               {
<span class="lineNum">    3393 </span><span class="lineCov">         42 :                 complained = identify_goto (decl,</span>
<span class="lineNum">    3394 </span><span class="lineCov">         21 :                                             DECL_SOURCE_LOCATION (decl),</span>
<span class="lineNum">    3395 </span>            :                                             &amp;input_location, DK_ERROR);
<span class="lineNum">    3396 </span><span class="lineCov">         21 :                 identified = 2;</span>
<span class="lineNum">    3397 </span>            :               }
<span class="lineNum">    3398 </span><span class="lineCov">         21 :             if (complained)</span>
<span class="lineNum">    3399 </span><span class="lineCov">         21 :               inform (input_location, &quot;  exits OpenMP structured block&quot;);</span>
<span class="lineNum">    3400 </span>            :             break;
<span class="lineNum">    3401 </span>            :           }
<span class="lineNum">    3402 </span>            :       }
<span class="lineNum">    3403 </span>            : }
<span class="lineNum">    3404 </span>            : 
<span class="lineNum">    3405 </span>            : /* Check that a return is ok wrt OpenMP structured blocks.
<span class="lineNum">    3406 </span>            :    Called by finish_return_stmt.  Returns true if all is well.  */
<a name="3407"><span class="lineNum">    3407 </span>            : </a>
<span class="lineNum">    3408 </span>            : bool
<span class="lineNum">    3409 </span><span class="lineCov">      15203 : check_omp_return (void)</span>
<span class="lineNum">    3410 </span>            : {
<span class="lineNum">    3411 </span><span class="lineCov">      41579 :   for (cp_binding_level *b = current_binding_level; b ; b = b-&gt;level_chain)</span>
<span class="lineNum">    3412 </span><span class="lineCov">      41579 :     if (b-&gt;kind == sk_omp)</span>
<span class="lineNum">    3413 </span>            :       {
<span class="lineNum">    3414 </span><span class="lineCov">         12 :         error (&quot;invalid exit from OpenMP structured block&quot;);</span>
<span class="lineNum">    3415 </span><span class="lineCov">         12 :         return false;</span>
<span class="lineNum">    3416 </span>            :       }
<span class="lineNum">    3417 </span><span class="lineCov">      41567 :     else if (b-&gt;kind == sk_function_parms)</span>
<span class="lineNum">    3418 </span>            :       break;
<span class="lineNum">    3419 </span>            :   return true;
<span class="lineNum">    3420 </span>            : }
<span class="lineNum">    3421 </span>            : 
<span class="lineNum">    3422 </span>            : /* Define a label, specifying the location in the source file.
<span class="lineNum">    3423 </span>            :    Return the LABEL_DECL node for the label.  */
<a name="3424"><span class="lineNum">    3424 </span>            : </a>
<span class="lineNum">    3425 </span>            : static tree
<span class="lineNum">    3426 </span><span class="lineCov">       1152 : define_label_1 (location_t location, tree name)</span>
<span class="lineNum">    3427 </span>            : {
<span class="lineNum">    3428 </span>            :   /* After labels, make any new cleanups in the function go into their
<span class="lineNum">    3429 </span>            :      own new (temporary) binding contour.  */
<span class="lineNum">    3430 </span><span class="lineCov">       1152 :   for (cp_binding_level *p = current_binding_level;</span>
<span class="lineNum">    3431 </span><span class="lineCov">       3172 :        p-&gt;kind != sk_function_parms;</span>
<span class="lineNum">    3432 </span><span class="lineCov">       2020 :        p = p-&gt;level_chain)</span>
<span class="lineNum">    3433 </span><span class="lineCov">       2020 :     p-&gt;more_cleanups_ok = 0;</span>
<span class="lineNum">    3434 </span>            : 
<span class="lineNum">    3435 </span><span class="lineCov">       1152 :   named_label_entry *ent = lookup_label_1 (name, false);</span>
<span class="lineNum">    3436 </span><span class="lineCov">       1152 :   tree decl = ent-&gt;label_decl;</span>
<span class="lineNum">    3437 </span>            : 
<span class="lineNum">    3438 </span><span class="lineCov">       1152 :   if (DECL_INITIAL (decl) != NULL_TREE)</span>
<span class="lineNum">    3439 </span>            :     {
<span class="lineNum">    3440 </span><span class="lineCov">          6 :       error (&quot;duplicate label %qD&quot;, decl);</span>
<span class="lineNum">    3441 </span><span class="lineCov">          6 :       return error_mark_node;</span>
<span class="lineNum">    3442 </span>            :     }
<span class="lineNum">    3443 </span>            :   else
<span class="lineNum">    3444 </span>            :     {
<span class="lineNum">    3445 </span>            :       /* Mark label as having been defined.  */
<span class="lineNum">    3446 </span><span class="lineCov">       1146 :       DECL_INITIAL (decl) = error_mark_node;</span>
<span class="lineNum">    3447 </span>            :       /* Say where in the source.  */
<span class="lineNum">    3448 </span><span class="lineCov">       1146 :       DECL_SOURCE_LOCATION (decl) = location;</span>
<span class="lineNum">    3449 </span>            : 
<span class="lineNum">    3450 </span><span class="lineCov">       1146 :       ent-&gt;binding_level = current_binding_level;</span>
<span class="lineNum">    3451 </span><span class="lineCov">       1146 :       ent-&gt;names_in_scope = current_binding_level-&gt;names;</span>
<span class="lineNum">    3452 </span>            : 
<span class="lineNum">    3453 </span><span class="lineCov">       1711 :       for (named_label_use_entry *use = ent-&gt;uses; use; use = use-&gt;next)</span>
<span class="lineNum">    3454 </span><span class="lineCov">        565 :         check_previous_goto (decl, use);</span>
<span class="lineNum">    3455 </span><span class="lineCov">       1146 :       ent-&gt;uses = NULL;</span>
<span class="lineNum">    3456 </span>            :     }
<span class="lineNum">    3457 </span>            : 
<span class="lineNum">    3458 </span><span class="lineCov">       1146 :   return decl;</span>
<span class="lineNum">    3459 </span>            : }
<span class="lineNum">    3460 </span>            : 
<span class="lineNum">    3461 </span>            : /* Wrapper for define_label_1.  */
<a name="3462"><span class="lineNum">    3462 </span>            : </a>
<span class="lineNum">    3463 </span>            : tree
<span class="lineNum">    3464 </span><span class="lineCov">       1152 : define_label (location_t location, tree name)</span>
<span class="lineNum">    3465 </span>            : {
<span class="lineNum">    3466 </span><span class="lineCov">       1152 :   bool running = timevar_cond_start (TV_NAME_LOOKUP);</span>
<span class="lineNum">    3467 </span><span class="lineCov">       1152 :   tree ret = define_label_1 (location, name);</span>
<span class="lineNum">    3468 </span><span class="lineCov">       1152 :   timevar_cond_stop (TV_NAME_LOOKUP, running);</span>
<span class="lineNum">    3469 </span><span class="lineCov">       1152 :   return ret;</span>
<span class="lineNum">    3470 </span>            : }
<span class="lineNum">    3471 </span>            : 
<span class="lineNum">    3472 </span>            : 
<span class="lineNum">    3473 </span>            : struct cp_switch
<span class="lineNum">    3474 </span>            : {
<span class="lineNum">    3475 </span>            :   cp_binding_level *level;
<span class="lineNum">    3476 </span>            :   struct cp_switch *next;
<span class="lineNum">    3477 </span>            :   /* The SWITCH_STMT being built.  */
<span class="lineNum">    3478 </span>            :   tree switch_stmt;
<span class="lineNum">    3479 </span>            :   /* A splay-tree mapping the low element of a case range to the high
<span class="lineNum">    3480 </span>            :      element, or NULL_TREE if there is no high element.  Used to
<span class="lineNum">    3481 </span>            :      determine whether or not a new case label duplicates an old case
<span class="lineNum">    3482 </span>            :      label.  We need a tree, rather than simply a hash table, because
<span class="lineNum">    3483 </span>            :      of the GNU case range extension.  */
<span class="lineNum">    3484 </span>            :   splay_tree cases;
<span class="lineNum">    3485 </span>            :   /* Remember whether there was a case value that is outside the
<span class="lineNum">    3486 </span>            :      range of the original type of the controlling expression.  */
<span class="lineNum">    3487 </span>            :   bool outside_range_p;
<span class="lineNum">    3488 </span>            :   /* Remember whether a default: case label has been seen.  */
<span class="lineNum">    3489 </span>            :   bool has_default_p;
<span class="lineNum">    3490 </span>            :   /* Remember whether a BREAK_STMT has been seen in this SWITCH_STMT.  */
<span class="lineNum">    3491 </span>            :   bool break_stmt_seen_p;
<span class="lineNum">    3492 </span>            :   /* Set if inside of {FOR,DO,WHILE}_BODY nested inside of a switch,
<span class="lineNum">    3493 </span>            :      where BREAK_STMT doesn't belong to the SWITCH_STMT.  */
<span class="lineNum">    3494 </span>            :   bool in_loop_body_p;
<span class="lineNum">    3495 </span>            : };
<span class="lineNum">    3496 </span>            : 
<span class="lineNum">    3497 </span>            : /* A stack of the currently active switch statements.  The innermost
<span class="lineNum">    3498 </span>            :    switch statement is on the top of the stack.  There is no need to
<span class="lineNum">    3499 </span>            :    mark the stack for garbage collection because it is only active
<span class="lineNum">    3500 </span>            :    during the processing of the body of a function, and we never
<span class="lineNum">    3501 </span>            :    collect at that point.  */
<span class="lineNum">    3502 </span>            : 
<span class="lineNum">    3503 </span>            : static struct cp_switch *switch_stack;
<span class="lineNum">    3504 </span>            : 
<span class="lineNum">    3505 </span>            : /* Called right after a switch-statement condition is parsed.
<span class="lineNum">    3506 </span>            :    SWITCH_STMT is the switch statement being parsed.  */
<a name="3507"><span class="lineNum">    3507 </span>            : </a>
<span class="lineNum">    3508 </span>            : void
<span class="lineNum">    3509 </span><span class="lineCov">      27420 : push_switch (tree switch_stmt)</span>
<span class="lineNum">    3510 </span>            : {
<span class="lineNum">    3511 </span><span class="lineCov">      27420 :   struct cp_switch *p = XNEW (struct cp_switch);</span>
<span class="lineNum">    3512 </span><span class="lineCov">      27420 :   p-&gt;level = current_binding_level;</span>
<span class="lineNum">    3513 </span><span class="lineCov">      27420 :   p-&gt;next = switch_stack;</span>
<span class="lineNum">    3514 </span><span class="lineCov">      27420 :   p-&gt;switch_stmt = switch_stmt;</span>
<span class="lineNum">    3515 </span><span class="lineCov">      27420 :   p-&gt;cases = splay_tree_new (case_compare, NULL, NULL);</span>
<span class="lineNum">    3516 </span><span class="lineCov">      27420 :   p-&gt;outside_range_p = false;</span>
<span class="lineNum">    3517 </span><span class="lineCov">      27420 :   p-&gt;has_default_p = false;</span>
<span class="lineNum">    3518 </span><span class="lineCov">      27420 :   p-&gt;break_stmt_seen_p = false;</span>
<span class="lineNum">    3519 </span><span class="lineCov">      27420 :   p-&gt;in_loop_body_p = false;</span>
<span class="lineNum">    3520 </span><span class="lineCov">      27420 :   switch_stack = p;</span>
<span class="lineNum">    3521 </span><span class="lineCov">      27420 : }</span>
<a name="3522"><span class="lineNum">    3522 </span>            : </a>
<span class="lineNum">    3523 </span>            : void
<span class="lineNum">    3524 </span><span class="lineCov">      27420 : pop_switch (void)</span>
<span class="lineNum">    3525 </span>            : {
<span class="lineNum">    3526 </span><span class="lineCov">      27420 :   struct cp_switch *cs = switch_stack;</span>
<span class="lineNum">    3527 </span><span class="lineCov">      27420 :   location_t switch_location;</span>
<span class="lineNum">    3528 </span>            : 
<span class="lineNum">    3529 </span>            :   /* Emit warnings as needed.  */
<span class="lineNum">    3530 </span><span class="lineCov">      27420 :   switch_location = cp_expr_loc_or_loc (cs-&gt;switch_stmt, input_location);</span>
<span class="lineNum">    3531 </span><span class="lineCov">      27420 :   const bool bool_cond_p</span>
<span class="lineNum">    3532 </span><span class="lineCov">      27420 :     = (SWITCH_STMT_TYPE (cs-&gt;switch_stmt)</span>
<span class="lineNum">    3533 </span><span class="lineCov">      27420 :        &amp;&amp; TREE_CODE (SWITCH_STMT_TYPE (cs-&gt;switch_stmt)) == BOOLEAN_TYPE);</span>
<span class="lineNum">    3534 </span><span class="lineCov">      27420 :   if (!processing_template_decl)</span>
<span class="lineNum">    3535 </span><span class="lineCov">      22697 :     c_do_switch_warnings (cs-&gt;cases, switch_location,</span>
<span class="lineNum">    3536 </span><span class="lineCov">      45394 :                           SWITCH_STMT_TYPE (cs-&gt;switch_stmt),</span>
<span class="lineNum">    3537 </span><span class="lineCov">      22697 :                           SWITCH_STMT_COND (cs-&gt;switch_stmt),</span>
<span class="lineNum">    3538 </span><span class="lineCov">      22697 :                           bool_cond_p, cs-&gt;outside_range_p);</span>
<span class="lineNum">    3539 </span>            : 
<span class="lineNum">    3540 </span>            :   /* For the benefit of block_may_fallthru remember if the switch body
<span class="lineNum">    3541 </span>            :      case labels cover all possible values and if there are break; stmts.  */
<span class="lineNum">    3542 </span><span class="lineCov">      27420 :   if (cs-&gt;has_default_p</span>
<span class="lineNum">    3543 </span><span class="lineCov">      27420 :       || (!processing_template_decl</span>
<span class="lineNum">    3544 </span><span class="lineCov">      17526 :           &amp;&amp; c_switch_covers_all_cases_p (cs-&gt;cases,</span>
<span class="lineNum">    3545 </span><span class="lineCov">      17526 :                                           SWITCH_STMT_TYPE (cs-&gt;switch_stmt))))</span>
<span class="lineNum">    3546 </span><span class="lineCov">       7984 :     SWITCH_STMT_ALL_CASES_P (cs-&gt;switch_stmt) = 1;</span>
<span class="lineNum">    3547 </span><span class="lineCov">      27420 :   if (!cs-&gt;break_stmt_seen_p)</span>
<span class="lineNum">    3548 </span><span class="lineCov">       3353 :     SWITCH_STMT_NO_BREAK_P (cs-&gt;switch_stmt) = 1;</span>
<span class="lineNum">    3549 </span><span class="lineCov">      27420 :   gcc_assert (!cs-&gt;in_loop_body_p);</span>
<span class="lineNum">    3550 </span><span class="lineCov">      27420 :   splay_tree_delete (cs-&gt;cases);</span>
<span class="lineNum">    3551 </span><span class="lineCov">      27420 :   switch_stack = switch_stack-&gt;next;</span>
<span class="lineNum">    3552 </span><span class="lineCov">      27420 :   free (cs);</span>
<span class="lineNum">    3553 </span><span class="lineCov">      27420 : }</span>
<span class="lineNum">    3554 </span>            : 
<span class="lineNum">    3555 </span>            : /* Note that a BREAK_STMT is about to be added.  If it is inside of
<span class="lineNum">    3556 </span>            :    a SWITCH_STMT and not inside of a loop body inside of it, note
<span class="lineNum">    3557 </span>            :    in switch_stack we've seen a BREAK_STMT.  */
<a name="3558"><span class="lineNum">    3558 </span>            : </a>
<span class="lineNum">    3559 </span>            : void
<span class="lineNum">    3560 </span><span class="lineCov">     182193 : note_break_stmt (void)</span>
<span class="lineNum">    3561 </span>            : {
<span class="lineNum">    3562 </span><span class="lineCov">     182193 :   if (switch_stack &amp;&amp; !switch_stack-&gt;in_loop_body_p)</span>
<span class="lineNum">    3563 </span><span class="lineCov">     103718 :     switch_stack-&gt;break_stmt_seen_p = true;</span>
<span class="lineNum">    3564 </span><span class="lineCov">     182193 : }</span>
<span class="lineNum">    3565 </span>            : 
<span class="lineNum">    3566 </span>            : /* Note the start of processing of an iteration statement's body.
<span class="lineNum">    3567 </span>            :    The note_break_stmt function will do nothing while processing it.
<span class="lineNum">    3568 </span>            :    Return a flag that should be passed to note_iteration_stmt_body_end.  */
<a name="3569"><span class="lineNum">    3569 </span>            : </a>
<span class="lineNum">    3570 </span>            : bool
<span class="lineNum">    3571 </span><span class="lineCov">     557440 : note_iteration_stmt_body_start (void)</span>
<span class="lineNum">    3572 </span>            : {
<span class="lineNum">    3573 </span><span class="lineCov">     557440 :   if (!switch_stack)</span>
<span class="lineNum">    3574 </span>            :     return false;
<span class="lineNum">    3575 </span><span class="lineCov">       1968 :   bool ret = switch_stack-&gt;in_loop_body_p;</span>
<span class="lineNum">    3576 </span><span class="lineCov">       1968 :   switch_stack-&gt;in_loop_body_p = true;</span>
<span class="lineNum">    3577 </span><span class="lineCov">       1968 :   return ret;</span>
<span class="lineNum">    3578 </span>            : }
<span class="lineNum">    3579 </span>            : 
<span class="lineNum">    3580 </span>            : /* Note the end of processing of an iteration statement's body.  */
<a name="3581"><span class="lineNum">    3581 </span>            : </a>
<span class="lineNum">    3582 </span>            : void
<span class="lineNum">    3583 </span><span class="lineCov">     557440 : note_iteration_stmt_body_end (bool prev)</span>
<span class="lineNum">    3584 </span>            : {
<span class="lineNum">    3585 </span><span class="lineCov">     557440 :   if (switch_stack)</span>
<span class="lineNum">    3586 </span><span class="lineCov">       1968 :     switch_stack-&gt;in_loop_body_p = prev;</span>
<span class="lineNum">    3587 </span><span class="lineCov">     557440 : }</span>
<span class="lineNum">    3588 </span>            : 
<span class="lineNum">    3589 </span>            : /* Convert a case constant VALUE in a switch to the type TYPE of the switch
<span class="lineNum">    3590 </span>            :    condition.  Note that if TYPE and VALUE are already integral we don't
<span class="lineNum">    3591 </span>            :    really do the conversion because the language-independent
<span class="lineNum">    3592 </span>            :    warning/optimization code will work better that way.  */
<a name="3593"><span class="lineNum">    3593 </span>            : </a>
<span class="lineNum">    3594 </span>            : static tree
<span class="lineNum">    3595 </span><span class="lineCov">     255480 : case_conversion (tree type, tree value)</span>
<span class="lineNum">    3596 </span>            : {
<span class="lineNum">    3597 </span><span class="lineCov">     255480 :   if (value == NULL_TREE)</span>
<span class="lineNum">    3598 </span>            :     return value;
<span class="lineNum">    3599 </span>            : 
<span class="lineNum">    3600 </span><span class="lineCov">     122677 :   value = mark_rvalue_use (value);</span>
<span class="lineNum">    3601 </span>            : 
<span class="lineNum">    3602 </span><span class="lineCov">     122677 :   if (cxx_dialect &gt;= cxx11</span>
<span class="lineNum">    3603 </span><span class="lineCov">     122677 :       &amp;&amp; (SCOPED_ENUM_P (type)</span>
<span class="lineNum">    3604 </span><span class="lineCov">     120917 :           || !INTEGRAL_OR_UNSCOPED_ENUMERATION_TYPE_P (TREE_TYPE (value))))</span>
<span class="lineNum">    3605 </span>            :     {
<span class="lineNum">    3606 </span><span class="lineCov">        257 :       if (INTEGRAL_OR_UNSCOPED_ENUMERATION_TYPE_P (type))</span>
<span class="lineNum">    3607 </span><span class="lineCov">         22 :         type = type_promotes_to (type);</span>
<span class="lineNum">    3608 </span><span class="lineCov">        514 :       value = (perform_implicit_conversion_flags</span>
<span class="lineNum">    3609 </span><span class="lineCov">        257 :                (type, value, tf_warning_or_error,</span>
<span class="lineNum">    3610 </span>            :                 LOOKUP_IMPLICIT | LOOKUP_NO_NON_INTEGRAL));
<span class="lineNum">    3611 </span>            :     }
<span class="lineNum">    3612 </span><span class="lineCov">     122677 :   return cxx_constant_value (value);</span>
<span class="lineNum">    3613 </span>            : }
<span class="lineNum">    3614 </span>            : 
<span class="lineNum">    3615 </span>            : /* Note that we've seen a definition of a case label, and complain if this
<span class="lineNum">    3616 </span>            :    is a bad place for one.  */
<a name="3617"><span class="lineNum">    3617 </span>            : </a>
<span class="lineNum">    3618 </span>            : tree
<span class="lineNum">    3619 </span><span class="lineCov">     155897 : finish_case_label (location_t loc, tree low_value, tree high_value)</span>
<span class="lineNum">    3620 </span>            : {
<span class="lineNum">    3621 </span><span class="lineCov">     155897 :   tree cond, r;</span>
<span class="lineNum">    3622 </span><span class="lineCov">     155897 :   cp_binding_level *p;</span>
<span class="lineNum">    3623 </span><span class="lineCov">     155897 :   tree type;</span>
<span class="lineNum">    3624 </span>            : 
<span class="lineNum">    3625 </span><span class="lineCov">     155897 :   if (low_value == NULL_TREE &amp;&amp; high_value == NULL_TREE)</span>
<span class="lineNum">    3626 </span><span class="lineCov">       7960 :     switch_stack-&gt;has_default_p = true;</span>
<span class="lineNum">    3627 </span>            : 
<span class="lineNum">    3628 </span><span class="lineCov">     155897 :   if (processing_template_decl)</span>
<span class="lineNum">    3629 </span>            :     {
<span class="lineNum">    3630 </span><span class="lineCov">      28066 :       tree label;</span>
<span class="lineNum">    3631 </span>            : 
<span class="lineNum">    3632 </span>            :       /* For templates, just add the case label; we'll do semantic
<span class="lineNum">    3633 </span>            :          analysis at instantiation-time.  */
<span class="lineNum">    3634 </span><span class="lineCov">      28066 :       label = build_decl (loc, LABEL_DECL, NULL_TREE, NULL_TREE);</span>
<span class="lineNum">    3635 </span><span class="lineCov">      28066 :       return add_stmt (build_case_label (low_value, high_value, label));</span>
<span class="lineNum">    3636 </span>            :     }
<span class="lineNum">    3637 </span>            : 
<span class="lineNum">    3638 </span>            :   /* Find the condition on which this switch statement depends.  */
<span class="lineNum">    3639 </span><span class="lineCov">     127831 :   cond = SWITCH_STMT_COND (switch_stack-&gt;switch_stmt);</span>
<span class="lineNum">    3640 </span><span class="lineCov">     127831 :   if (cond &amp;&amp; TREE_CODE (cond) == TREE_LIST)</span>
<span class="lineNum">    3641 </span><span class="lineNoCov">          0 :     cond = TREE_VALUE (cond);</span>
<span class="lineNum">    3642 </span>            : 
<span class="lineNum">    3643 </span><span class="lineCov">     127831 :   if (!check_switch_goto (switch_stack-&gt;level))</span>
<span class="lineNum">    3644 </span><span class="lineCov">         77 :     return error_mark_node;</span>
<span class="lineNum">    3645 </span>            : 
<span class="lineNum">    3646 </span><span class="lineCov">     127754 :   type = SWITCH_STMT_TYPE (switch_stack-&gt;switch_stmt);</span>
<span class="lineNum">    3647 </span><span class="lineCov">     127754 :   if (type == error_mark_node)</span>
<span class="lineNum">    3648 </span>            :     return error_mark_node;
<span class="lineNum">    3649 </span>            : 
<span class="lineNum">    3650 </span><span class="lineCov">     127740 :   low_value = case_conversion (type, low_value);</span>
<span class="lineNum">    3651 </span><span class="lineCov">     127740 :   high_value = case_conversion (type, high_value);</span>
<span class="lineNum">    3652 </span>            : 
<span class="lineNum">    3653 </span><span class="lineCov">     383220 :   r = c_add_case_label (loc, switch_stack-&gt;cases, cond, type,</span>
<span class="lineNum">    3654 </span>            :                         low_value, high_value,
<span class="lineNum">    3655 </span><span class="lineCov">     127740 :                         &amp;switch_stack-&gt;outside_range_p);</span>
<span class="lineNum">    3656 </span>            : 
<span class="lineNum">    3657 </span>            :   /* After labels, make any new cleanups in the function go into their
<span class="lineNum">    3658 </span>            :      own new (temporary) binding contour.  */
<span class="lineNum">    3659 </span><span class="lineCov">     127740 :   for (p = current_binding_level;</span>
<span class="lineNum">    3660 </span><span class="lineCov">     669441 :        p-&gt;kind != sk_function_parms;</span>
<span class="lineNum">    3661 </span><span class="lineCov">     541701 :        p = p-&gt;level_chain)</span>
<span class="lineNum">    3662 </span><span class="lineCov">     541701 :     p-&gt;more_cleanups_ok = 0;</span>
<span class="lineNum">    3663 </span>            : 
<span class="lineNum">    3664 </span>            :   return r;
<span class="lineNum">    3665 </span>            : }
<span class="lineNum">    3666 </span>            : 
<span class="lineNum">    3667 </span>            : struct typename_info {
<span class="lineNum">    3668 </span>            :   tree scope;
<span class="lineNum">    3669 </span>            :   tree name;
<span class="lineNum">    3670 </span>            :   tree template_id;
<span class="lineNum">    3671 </span>            :   bool enum_p;
<span class="lineNum">    3672 </span>            :   bool class_p;
<span class="lineNum">    3673 </span>            : };
<span class="lineNum">    3674 </span>            : 
<span class="lineNum">    3675 </span>            : struct typename_hasher : ggc_ptr_hash&lt;tree_node&gt;
<span class="lineNum">    3676 </span>            : {
<span class="lineNum">    3677 </span>            :   typedef typename_info *compare_type;
<span class="lineNum">    3678 </span>            : 
<span class="lineNum">    3679 </span>            :   /* Hash a TYPENAME_TYPE.  */
<a name="3680"><span class="lineNum">    3680 </span>            : </a>
<span class="lineNum">    3681 </span>            :   static hashval_t
<span class="lineNum">    3682 </span><span class="lineCov">    1712438 :   hash (tree t)</span>
<span class="lineNum">    3683 </span>            :   {
<span class="lineNum">    3684 </span><span class="lineCov">    1712438 :     hashval_t hash;</span>
<span class="lineNum">    3685 </span>            : 
<span class="lineNum">    3686 </span><span class="lineCov">    1712438 :     hash = (htab_hash_pointer (TYPE_CONTEXT (t))</span>
<span class="lineNum">    3687 </span><span class="lineCov">    1712438 :             ^ htab_hash_pointer (TYPE_IDENTIFIER (t)));</span>
<span class="lineNum">    3688 </span>            : 
<span class="lineNum">    3689 </span><span class="lineCov">    1712438 :     return hash;</span>
<span class="lineNum">    3690 </span>            :   }
<span class="lineNum">    3691 </span>            : 
<span class="lineNum">    3692 </span>            :   /* Compare two TYPENAME_TYPEs.  */
<a name="3693"><span class="lineNum">    3693 </span>            : </a>
<span class="lineNum">    3694 </span>            :   static bool
<span class="lineNum">    3695 </span><span class="lineCov">    5347588 :   equal (tree t1, const typename_info *t2)</span>
<span class="lineNum">    3696 </span>            :   {
<span class="lineNum">    3697 </span><span class="lineCov">    5347588 :     return (TYPE_IDENTIFIER (t1) == t2-&gt;name</span>
<span class="lineNum">    3698 </span><span class="lineCov">    5749050 :             &amp;&amp; TYPE_CONTEXT (t1) == t2-&gt;scope</span>
<span class="lineNum">    3699 </span><span class="lineCov">    1763948 :             &amp;&amp; TYPENAME_TYPE_FULLNAME (t1) == t2-&gt;template_id</span>
<span class="lineNum">    3700 </span><span class="lineCov">    4960989 :             &amp;&amp; TYPENAME_IS_ENUM_P (t1) == t2-&gt;enum_p</span>
<span class="lineNum">    3701 </span><span class="lineCov">   10308463 :             &amp;&amp; TYPENAME_IS_CLASS_P (t1) == t2-&gt;class_p);</span>
<span class="lineNum">    3702 </span>            :   }
<span class="lineNum">    3703 </span>            : };
<span class="lineNum">    3704 </span>            : 
<span class="lineNum">    3705 </span>            : /* Build a TYPENAME_TYPE.  If the type is `typename T::t', CONTEXT is
<span class="lineNum">    3706 </span>            :    the type of `T', NAME is the IDENTIFIER_NODE for `t'.
<span class="lineNum">    3707 </span>            : 
<span class="lineNum">    3708 </span>            :    Returns the new TYPENAME_TYPE.  */
<span class="lineNum">    3709 </span>            : 
<span class="lineNum">    3710 </span>            : static GTY (()) hash_table&lt;typename_hasher&gt; *typename_htab;
<a name="3711"><span class="lineNum">    3711 </span>            : </a>
<span class="lineNum">    3712 </span>            : tree
<span class="lineNum">    3713 </span><span class="lineCov">    3240801 : build_typename_type (tree context, tree name, tree fullname,</span>
<span class="lineNum">    3714 </span>            :                      enum tag_types tag_type)
<span class="lineNum">    3715 </span>            : {
<span class="lineNum">    3716 </span><span class="lineCov">    3240801 :   tree t;</span>
<span class="lineNum">    3717 </span><span class="lineCov">    3240801 :   tree d;</span>
<span class="lineNum">    3718 </span><span class="lineCov">    3240801 :   typename_info ti;</span>
<span class="lineNum">    3719 </span><span class="lineCov">    3240801 :   tree *e;</span>
<span class="lineNum">    3720 </span><span class="lineCov">    3240801 :   hashval_t hash;</span>
<span class="lineNum">    3721 </span>            : 
<span class="lineNum">    3722 </span><span class="lineCov">    3240801 :   if (typename_htab == NULL)</span>
<span class="lineNum">    3723 </span><span class="lineCov">       5095 :     typename_htab = hash_table&lt;typename_hasher&gt;::create_ggc (61);</span>
<span class="lineNum">    3724 </span>            : 
<span class="lineNum">    3725 </span><span class="lineCov">    3240801 :   ti.scope = FROB_CONTEXT (context);</span>
<span class="lineNum">    3726 </span><span class="lineCov">    3240801 :   ti.name = name;</span>
<span class="lineNum">    3727 </span><span class="lineCov">    3240801 :   ti.template_id = fullname;</span>
<span class="lineNum">    3728 </span><span class="lineCov">    3240801 :   ti.enum_p = tag_type == enum_type;</span>
<span class="lineNum">    3729 </span><span class="lineCov">    6481602 :   ti.class_p = (tag_type == class_type</span>
<span class="lineNum">    3730 </span>            :                 || tag_type == record_type
<span class="lineNum">    3731 </span><span class="lineCov">    3240801 :                 || tag_type == union_type);</span>
<span class="lineNum">    3732 </span><span class="lineCov">    3240801 :   hash =  (htab_hash_pointer (ti.scope)</span>
<span class="lineNum">    3733 </span><span class="lineCov">    3240801 :            ^ htab_hash_pointer (ti.name));</span>
<span class="lineNum">    3734 </span>            : 
<span class="lineNum">    3735 </span>            :   /* See if we already have this type.  */
<span class="lineNum">    3736 </span><span class="lineCov">    3240801 :   e = typename_htab-&gt;find_slot_with_hash (&amp;ti, hash, INSERT);</span>
<span class="lineNum">    3737 </span><span class="lineCov">    3240801 :   if (*e)</span>
<span class="lineNum">    3738 </span>            :     t = *e;
<span class="lineNum">    3739 </span>            :   else
<span class="lineNum">    3740 </span>            :     {
<span class="lineNum">    3741 </span>            :       /* Build the TYPENAME_TYPE.  */
<span class="lineNum">    3742 </span><span class="lineCov">    1587185 :       t = cxx_make_type (TYPENAME_TYPE);</span>
<span class="lineNum">    3743 </span><span class="lineCov">    1587185 :       TYPE_CONTEXT (t) = ti.scope;</span>
<span class="lineNum">    3744 </span><span class="lineCov">    1587185 :       TYPENAME_TYPE_FULLNAME (t) = ti.template_id;</span>
<span class="lineNum">    3745 </span><span class="lineCov">    3174370 :       TYPENAME_IS_ENUM_P (t) = ti.enum_p;</span>
<span class="lineNum">    3746 </span><span class="lineCov">    3174370 :       TYPENAME_IS_CLASS_P (t) = ti.class_p;</span>
<span class="lineNum">    3747 </span>            : 
<span class="lineNum">    3748 </span>            :       /* Build the corresponding TYPE_DECL.  */
<span class="lineNum">    3749 </span><span class="lineCov">    1587185 :       d = build_decl (input_location, TYPE_DECL, name, t);</span>
<span class="lineNum">    3750 </span><span class="lineCov">    1587185 :       TYPE_NAME (TREE_TYPE (d)) = d;</span>
<span class="lineNum">    3751 </span><span class="lineCov">    1587185 :       TYPE_STUB_DECL (TREE_TYPE (d)) = d;</span>
<span class="lineNum">    3752 </span><span class="lineCov">    1587185 :       DECL_CONTEXT (d) = FROB_CONTEXT (context);</span>
<span class="lineNum">    3753 </span><span class="lineCov">    1587185 :       DECL_ARTIFICIAL (d) = 1;</span>
<span class="lineNum">    3754 </span>            : 
<span class="lineNum">    3755 </span>            :       /* Store it in the hash table.  */
<span class="lineNum">    3756 </span><span class="lineCov">    1587185 :       *e = t;</span>
<span class="lineNum">    3757 </span>            : 
<span class="lineNum">    3758 </span>            :       /* TYPENAME_TYPEs must always be compared structurally, because
<span class="lineNum">    3759 </span>            :          they may or may not resolve down to another type depending on
<span class="lineNum">    3760 </span>            :          the currently open classes. */
<span class="lineNum">    3761 </span><span class="lineCov">    1587185 :       SET_TYPE_STRUCTURAL_EQUALITY (t);</span>
<span class="lineNum">    3762 </span>            :     }
<span class="lineNum">    3763 </span>            : 
<span class="lineNum">    3764 </span><span class="lineCov">    3240801 :   return t;</span>
<span class="lineNum">    3765 </span>            : }
<span class="lineNum">    3766 </span>            : 
<span class="lineNum">    3767 </span>            : /* Resolve `typename CONTEXT::NAME'.  TAG_TYPE indicates the tag
<span class="lineNum">    3768 </span>            :    provided to name the type.  Returns an appropriate type, unless an
<span class="lineNum">    3769 </span>            :    error occurs, in which case error_mark_node is returned.  If we
<span class="lineNum">    3770 </span>            :    locate a non-artificial TYPE_DECL and TF_KEEP_TYPE_DECL is set, we
<span class="lineNum">    3771 </span>            :    return that, rather than the _TYPE it corresponds to, in other
<span class="lineNum">    3772 </span>            :    cases we look through the type decl.  If TF_ERROR is set, complain
<span class="lineNum">    3773 </span>            :    about errors, otherwise be quiet.  */
<a name="3774"><span class="lineNum">    3774 </span>            : </a>
<span class="lineNum">    3775 </span>            : tree
<span class="lineNum">    3776 </span><span class="lineCov">   13844940 : make_typename_type (tree context, tree name, enum tag_types tag_type,</span>
<span class="lineNum">    3777 </span>            :                     tsubst_flags_t complain)
<span class="lineNum">    3778 </span>            : {
<span class="lineNum">    3779 </span><span class="lineCov">   13844940 :   tree fullname;</span>
<span class="lineNum">    3780 </span><span class="lineCov">   13844940 :   tree t;</span>
<span class="lineNum">    3781 </span><span class="lineCov">   13844940 :   bool want_template;</span>
<span class="lineNum">    3782 </span>            : 
<span class="lineNum">    3783 </span><span class="lineCov">   13844940 :   if (name == error_mark_node</span>
<span class="lineNum">    3784 </span><span class="lineCov">   13844940 :       || context == NULL_TREE</span>
<span class="lineNum">    3785 </span><span class="lineCov">   13844925 :       || context == error_mark_node)</span>
<span class="lineNum">    3786 </span>            :     return error_mark_node;
<span class="lineNum">    3787 </span>            : 
<span class="lineNum">    3788 </span><span class="lineCov">   13844913 :   if (TYPE_P (name))</span>
<span class="lineNum">    3789 </span>            :     {
<span class="lineNum">    3790 </span><span class="lineNoCov">          0 :       if (!(TYPE_LANG_SPECIFIC (name)</span>
<span class="lineNum">    3791 </span><span class="lineNoCov">          0 :             &amp;&amp; (CLASSTYPE_IS_TEMPLATE (name)</span>
<span class="lineNum">    3792 </span><span class="lineNoCov">          0 :                 || CLASSTYPE_USE_TEMPLATE (name))))</span>
<span class="lineNum">    3793 </span><span class="lineNoCov">          0 :         name = TYPE_IDENTIFIER (name);</span>
<span class="lineNum">    3794 </span>            :       else
<span class="lineNum">    3795 </span>            :         /* Create a TEMPLATE_ID_EXPR for the type.  */
<span class="lineNum">    3796 </span><span class="lineNoCov">          0 :         name = build_nt (TEMPLATE_ID_EXPR,</span>
<span class="lineNum">    3797 </span><span class="lineNoCov">          0 :                          CLASSTYPE_TI_TEMPLATE (name),</span>
<span class="lineNum">    3798 </span><span class="lineNoCov">          0 :                          CLASSTYPE_TI_ARGS (name));</span>
<span class="lineNum">    3799 </span>            :     }
<span class="lineNum">    3800 </span><span class="lineCov">   13844913 :   else if (TREE_CODE (name) == TYPE_DECL)</span>
<span class="lineNum">    3801 </span><span class="lineNoCov">          0 :     name = DECL_NAME (name);</span>
<span class="lineNum">    3802 </span>            : 
<span class="lineNum">    3803 </span><span class="lineCov">   13844913 :   fullname = name;</span>
<span class="lineNum">    3804 </span>            : 
<span class="lineNum">    3805 </span><span class="lineCov">   13844913 :   if (TREE_CODE (name) == TEMPLATE_ID_EXPR)</span>
<span class="lineNum">    3806 </span>            :     {
<span class="lineNum">    3807 </span><span class="lineCov">     606779 :       name = TREE_OPERAND (name, 0);</span>
<span class="lineNum">    3808 </span><span class="lineCov">     606779 :       if (DECL_TYPE_TEMPLATE_P (name))</span>
<span class="lineNum">    3809 </span><span class="lineNoCov">          0 :         name = TREE_OPERAND (fullname, 0) = DECL_NAME (name);</span>
<span class="lineNum">    3810 </span><span class="lineCov">     606779 :       if (TREE_CODE (name) != IDENTIFIER_NODE)</span>
<span class="lineNum">    3811 </span>            :         {
<span class="lineNum">    3812 </span><span class="lineNoCov">          0 :           if (complain &amp; tf_error)</span>
<span class="lineNum">    3813 </span><span class="lineNoCov">          0 :             error (&quot;%qD is not a type&quot;, name);</span>
<span class="lineNum">    3814 </span><span class="lineNoCov">          0 :           return error_mark_node;</span>
<span class="lineNum">    3815 </span>            :         }
<span class="lineNum">    3816 </span>            :     }
<span class="lineNum">    3817 </span><span class="lineCov">   13844913 :   if (TREE_CODE (name) == TEMPLATE_DECL)</span>
<span class="lineNum">    3818 </span>            :     {
<span class="lineNum">    3819 </span><span class="lineNoCov">          0 :       if (complain &amp; tf_error)</span>
<span class="lineNum">    3820 </span><span class="lineNoCov">          0 :         error (&quot;%qD used without template arguments&quot;, name);</span>
<span class="lineNum">    3821 </span><span class="lineNoCov">          0 :       return error_mark_node;</span>
<span class="lineNum">    3822 </span>            :     }
<span class="lineNum">    3823 </span><span class="lineCov">   13844913 :   gcc_assert (identifier_p (name));</span>
<span class="lineNum">    3824 </span><span class="lineCov">   13844913 :   gcc_assert (TYPE_P (context));</span>
<span class="lineNum">    3825 </span>            : 
<span class="lineNum">    3826 </span><span class="lineCov">   13844913 :   if (!MAYBE_CLASS_TYPE_P (context))</span>
<span class="lineNum">    3827 </span>            :     {
<span class="lineNum">    3828 </span><span class="lineCov">          2 :       if (complain &amp; tf_error)</span>
<span class="lineNum">    3829 </span><span class="lineCov">          2 :         error (&quot;%q#T is not a class&quot;, context);</span>
<span class="lineNum">    3830 </span><span class="lineCov">          2 :       return error_mark_node;</span>
<span class="lineNum">    3831 </span>            :     }
<span class="lineNum">    3832 </span>            :   
<span class="lineNum">    3833 </span>            :   /* When the CONTEXT is a dependent type,  NAME could refer to a
<span class="lineNum">    3834 </span>            :      dependent base class of CONTEXT.  But look inside it anyway
<span class="lineNum">    3835 </span>            :      if CONTEXT is a currently open scope, in case it refers to a
<span class="lineNum">    3836 </span>            :      member of the current instantiation or a non-dependent base;
<span class="lineNum">    3837 </span>            :      lookup will stop when we hit a dependent base.  */
<span class="lineNum">    3838 </span><span class="lineCov">   13844911 :   if (!dependent_scope_p (context))</span>
<span class="lineNum">    3839 </span>            :     /* We should only set WANT_TYPE when we're a nested typename type.
<span class="lineNum">    3840 </span>            :        Then we can give better diagnostics if we find a non-type.  */
<span class="lineNum">    3841 </span><span class="lineCov">   10921675 :     t = lookup_field (context, name, 2, /*want_type=*/true);</span>
<span class="lineNum">    3842 </span>            :   else
<span class="lineNum">    3843 </span>            :     t = NULL_TREE;
<span class="lineNum">    3844 </span>            : 
<span class="lineNum">    3845 </span><span class="lineCov">   13844911 :   if ((!t || TREE_CODE (t) == TREE_LIST) &amp;&amp; dependent_type_p (context))</span>
<span class="lineNum">    3846 </span><span class="lineCov">    2929549 :     return build_typename_type (context, name, fullname, tag_type);</span>
<span class="lineNum">    3847 </span>            : 
<span class="lineNum">    3848 </span><span class="lineCov">   10915362 :   want_template = TREE_CODE (fullname) == TEMPLATE_ID_EXPR;</span>
<span class="lineNum">    3849 </span>            :   
<span class="lineNum">    3850 </span><span class="lineCov">   10915362 :   if (!t)</span>
<span class="lineNum">    3851 </span>            :     {
<span class="lineNum">    3852 </span><span class="lineCov">     845344 :       if (complain &amp; tf_error)</span>
<span class="lineNum">    3853 </span>            :         {
<span class="lineNum">    3854 </span><span class="lineCov">         95 :           if (!COMPLETE_TYPE_P (context))</span>
<span class="lineNum">    3855 </span><span class="lineCov">         15 :             cxx_incomplete_type_error (NULL_TREE, context);</span>
<span class="lineNum">    3856 </span>            :           else
<span class="lineNum">    3857 </span><span class="lineCov">        153 :             error (want_template ? G_(&quot;no class template named %q#T in %q#T&quot;)</span>
<span class="lineNum">    3858 </span>            :                    : G_(&quot;no type named %q#T in %q#T&quot;), name, context);
<span class="lineNum">    3859 </span>            :         }
<span class="lineNum">    3860 </span><span class="lineCov">     845344 :       return error_mark_node;</span>
<span class="lineNum">    3861 </span>            :     }
<span class="lineNum">    3862 </span>            :   
<span class="lineNum">    3863 </span>            :   /* Pull out the template from an injected-class-name (or multiple).  */
<span class="lineNum">    3864 </span><span class="lineCov">   10070018 :   if (want_template)</span>
<span class="lineNum">    3865 </span><span class="lineCov">     561103 :     t = maybe_get_template_decl_from_type_decl (t);</span>
<span class="lineNum">    3866 </span>            : 
<span class="lineNum">    3867 </span><span class="lineCov">   10070018 :   if (TREE_CODE (t) == TREE_LIST)</span>
<span class="lineNum">    3868 </span>            :     {
<span class="lineNum">    3869 </span><span class="lineCov">          3 :       if (complain &amp; tf_error)</span>
<span class="lineNum">    3870 </span>            :         {
<span class="lineNum">    3871 </span><span class="lineCov">          3 :           error (&quot;lookup of %qT in %qT is ambiguous&quot;, name, context);</span>
<span class="lineNum">    3872 </span><span class="lineCov">          3 :           print_candidates (t);</span>
<span class="lineNum">    3873 </span>            :         }
<span class="lineNum">    3874 </span><span class="lineCov">          3 :       return error_mark_node;</span>
<span class="lineNum">    3875 </span>            :     }
<span class="lineNum">    3876 </span>            : 
<span class="lineNum">    3877 </span><span class="lineCov">   10070015 :   if (want_template &amp;&amp; !DECL_TYPE_TEMPLATE_P (t))</span>
<span class="lineNum">    3878 </span>            :     {
<span class="lineNum">    3879 </span><span class="lineCov">          2 :       if (complain &amp; tf_error)</span>
<span class="lineNum">    3880 </span><span class="lineCov">          2 :         error (&quot;%&lt;typename %T::%D%&gt; names %q#T, which is not a class template&quot;,</span>
<span class="lineNum">    3881 </span>            :                context, name, t);
<span class="lineNum">    3882 </span><span class="lineCov">          2 :       return error_mark_node;</span>
<span class="lineNum">    3883 </span>            :     }
<span class="lineNum">    3884 </span><span class="lineCov">   10070013 :   if (!want_template &amp;&amp; TREE_CODE (t) != TYPE_DECL)</span>
<span class="lineNum">    3885 </span>            :     {
<span class="lineNum">    3886 </span><span class="lineCov">          6 :       if (complain &amp; tf_error)</span>
<span class="lineNum">    3887 </span><span class="lineCov">          3 :         error (&quot;%&lt;typename %T::%D%&gt; names %q#T, which is not a type&quot;,</span>
<span class="lineNum">    3888 </span>            :                context, name, t);
<span class="lineNum">    3889 </span><span class="lineCov">          6 :       return error_mark_node;</span>
<span class="lineNum">    3890 </span>            :     }
<span class="lineNum">    3891 </span>            : 
<span class="lineNum">    3892 </span><span class="lineCov">   10070007 :   if (!perform_or_defer_access_check (TYPE_BINFO (context), t, t, complain))</span>
<span class="lineNum">    3893 </span><span class="lineCov">          1 :     return error_mark_node;</span>
<span class="lineNum">    3894 </span>            : 
<span class="lineNum">    3895 </span>            :   /* If we are currently parsing a template and if T is a typedef accessed
<span class="lineNum">    3896 </span>            :      through CONTEXT then we need to remember and check access of T at
<span class="lineNum">    3897 </span>            :      template instantiation time.  */
<span class="lineNum">    3898 </span><span class="lineCov">   10070006 :   add_typedef_to_current_template_for_access_check (t, context, input_location);</span>
<span class="lineNum">    3899 </span>            : 
<span class="lineNum">    3900 </span><span class="lineCov">   10070006 :   if (want_template)</span>
<span class="lineNum">    3901 </span><span class="lineCov">     561101 :     return lookup_template_class (t, TREE_OPERAND (fullname, 1),</span>
<span class="lineNum">    3902 </span>            :                                   NULL_TREE, context,
<span class="lineNum">    3903 </span>            :                                   /*entering_scope=*/0,
<span class="lineNum">    3904 </span><span class="lineCov">     561101 :                                   complain | tf_user);</span>
<span class="lineNum">    3905 </span>            :   
<span class="lineNum">    3906 </span><span class="lineCov">    9508905 :   if (DECL_ARTIFICIAL (t) || !(complain &amp; tf_keep_type_decl))</span>
<span class="lineNum">    3907 </span><span class="lineCov">      36260 :     t = TREE_TYPE (t);</span>
<span class="lineNum">    3908 </span>            : 
<span class="lineNum">    3909 </span><span class="lineCov">    9508905 :   maybe_record_typedef_use (t);</span>
<span class="lineNum">    3910 </span>            : 
<span class="lineNum">    3911 </span><span class="lineCov">    9508905 :   return t;</span>
<span class="lineNum">    3912 </span>            : }
<span class="lineNum">    3913 </span>            : 
<span class="lineNum">    3914 </span>            : /* Resolve `CONTEXT::template NAME'.  Returns a TEMPLATE_DECL if the name
<span class="lineNum">    3915 </span>            :    can be resolved or an UNBOUND_CLASS_TEMPLATE, unless an error occurs,
<span class="lineNum">    3916 </span>            :    in which case error_mark_node is returned.
<span class="lineNum">    3917 </span>            : 
<span class="lineNum">    3918 </span>            :    If PARM_LIST is non-NULL, also make sure that the template parameter
<span class="lineNum">    3919 </span>            :    list of TEMPLATE_DECL matches.
<span class="lineNum">    3920 </span>            : 
<span class="lineNum">    3921 </span>            :    If COMPLAIN zero, don't complain about any errors that occur.  */
<a name="3922"><span class="lineNum">    3922 </span>            : </a>
<span class="lineNum">    3923 </span>            : tree
<span class="lineNum">    3924 </span><span class="lineCov">        348 : make_unbound_class_template (tree context, tree name, tree parm_list,</span>
<span class="lineNum">    3925 </span>            :                              tsubst_flags_t complain)
<span class="lineNum">    3926 </span>            : {
<span class="lineNum">    3927 </span><span class="lineCov">        348 :   tree t;</span>
<span class="lineNum">    3928 </span><span class="lineCov">        348 :   tree d;</span>
<span class="lineNum">    3929 </span>            : 
<span class="lineNum">    3930 </span><span class="lineCov">        348 :   if (TYPE_P (name))</span>
<span class="lineNum">    3931 </span><span class="lineNoCov">          0 :     name = TYPE_IDENTIFIER (name);</span>
<span class="lineNum">    3932 </span><span class="lineCov">        348 :   else if (DECL_P (name))</span>
<span class="lineNum">    3933 </span><span class="lineNoCov">          0 :     name = DECL_NAME (name);</span>
<span class="lineNum">    3934 </span><span class="lineCov">        348 :   gcc_assert (identifier_p (name));</span>
<span class="lineNum">    3935 </span>            : 
<span class="lineNum">    3936 </span><span class="lineCov">        348 :   if (!dependent_type_p (context)</span>
<span class="lineNum">    3937 </span><span class="lineCov">        348 :       || currently_open_class (context))</span>
<span class="lineNum">    3938 </span>            :     {
<span class="lineNum">    3939 </span><span class="lineCov">        100 :       tree tmpl = NULL_TREE;</span>
<span class="lineNum">    3940 </span>            : 
<span class="lineNum">    3941 </span><span class="lineCov">        100 :       if (MAYBE_CLASS_TYPE_P (context))</span>
<span class="lineNum">    3942 </span><span class="lineCov">         94 :         tmpl = lookup_field (context, name, 0, false);</span>
<span class="lineNum">    3943 </span>            : 
<span class="lineNum">    3944 </span><span class="lineCov">         94 :       if (tmpl &amp;&amp; TREE_CODE (tmpl) == TYPE_DECL)</span>
<span class="lineNum">    3945 </span><span class="lineCov">          3 :         tmpl = maybe_get_template_decl_from_type_decl (tmpl);</span>
<span class="lineNum">    3946 </span>            : 
<span class="lineNum">    3947 </span><span class="lineCov">        100 :       if (!tmpl || !DECL_TYPE_TEMPLATE_P (tmpl))</span>
<span class="lineNum">    3948 </span>            :         {
<span class="lineNum">    3949 </span><span class="lineCov">          9 :           if (complain &amp; tf_error)</span>
<span class="lineNum">    3950 </span><span class="lineCov">          6 :             error (&quot;no class template named %q#T in %q#T&quot;, name, context);</span>
<span class="lineNum">    3951 </span><span class="lineCov">          9 :           return error_mark_node;</span>
<span class="lineNum">    3952 </span>            :         }
<span class="lineNum">    3953 </span>            : 
<span class="lineNum">    3954 </span><span class="lineCov">         91 :       if (parm_list</span>
<span class="lineNum">    3955 </span><span class="lineCov">         91 :           &amp;&amp; !comp_template_parms (DECL_TEMPLATE_PARMS (tmpl), parm_list))</span>
<span class="lineNum">    3956 </span>            :         {
<span class="lineNum">    3957 </span><span class="lineNoCov">          0 :           if (complain &amp; tf_error)</span>
<span class="lineNum">    3958 </span>            :             {
<span class="lineNum">    3959 </span><span class="lineNoCov">          0 :               error (&quot;template parameters do not match template %qD&quot;, tmpl);</span>
<span class="lineNum">    3960 </span><span class="lineNoCov">          0 :               inform (DECL_SOURCE_LOCATION (tmpl),</span>
<span class="lineNum">    3961 </span>            :                       &quot;%qD declared here&quot;, tmpl);
<span class="lineNum">    3962 </span>            :             }
<span class="lineNum">    3963 </span><span class="lineNoCov">          0 :           return error_mark_node;</span>
<span class="lineNum">    3964 </span>            :         }
<span class="lineNum">    3965 </span>            : 
<span class="lineNum">    3966 </span><span class="lineCov">         91 :       if (!perform_or_defer_access_check (TYPE_BINFO (context), tmpl, tmpl,</span>
<span class="lineNum">    3967 </span>            :                                           complain))
<span class="lineNum">    3968 </span><span class="lineNoCov">          0 :         return error_mark_node;</span>
<span class="lineNum">    3969 </span>            : 
<span class="lineNum">    3970 </span>            :       return tmpl;
<span class="lineNum">    3971 </span>            :     }
<span class="lineNum">    3972 </span>            : 
<span class="lineNum">    3973 </span>            :   /* Build the UNBOUND_CLASS_TEMPLATE.  */
<span class="lineNum">    3974 </span><span class="lineCov">        248 :   t = cxx_make_type (UNBOUND_CLASS_TEMPLATE);</span>
<span class="lineNum">    3975 </span><span class="lineCov">        248 :   TYPE_CONTEXT (t) = FROB_CONTEXT (context);</span>
<span class="lineNum">    3976 </span><span class="lineCov">        248 :   TREE_TYPE (t) = NULL_TREE;</span>
<span class="lineNum">    3977 </span><span class="lineCov">        248 :   SET_TYPE_STRUCTURAL_EQUALITY (t);</span>
<span class="lineNum">    3978 </span>            : 
<span class="lineNum">    3979 </span>            :   /* Build the corresponding TEMPLATE_DECL.  */
<span class="lineNum">    3980 </span><span class="lineCov">        248 :   d = build_decl (input_location, TEMPLATE_DECL, name, t);</span>
<span class="lineNum">    3981 </span><span class="lineCov">        248 :   TYPE_NAME (TREE_TYPE (d)) = d;</span>
<span class="lineNum">    3982 </span><span class="lineCov">        248 :   TYPE_STUB_DECL (TREE_TYPE (d)) = d;</span>
<span class="lineNum">    3983 </span><span class="lineCov">        248 :   DECL_CONTEXT (d) = FROB_CONTEXT (context);</span>
<span class="lineNum">    3984 </span><span class="lineCov">        248 :   DECL_ARTIFICIAL (d) = 1;</span>
<span class="lineNum">    3985 </span><span class="lineCov">        248 :   DECL_TEMPLATE_PARMS (d) = parm_list;</span>
<span class="lineNum">    3986 </span>            : 
<span class="lineNum">    3987 </span><span class="lineCov">        248 :   return t;</span>
<span class="lineNum">    3988 </span>            : }
<span class="lineNum">    3989 </span>            : 
<span class="lineNum">    3990 </span>            : 
<span class="lineNum">    3991 </span>            : 
<span class="lineNum">    3992 </span>            : /* Push the declarations of builtin types into the global namespace.
<span class="lineNum">    3993 </span>            :    RID_INDEX is the index of the builtin type in the array
<span class="lineNum">    3994 </span>            :    RID_POINTERS.  NAME is the name used when looking up the builtin
<span class="lineNum">    3995 </span>            :    type.  TYPE is the _TYPE node for the builtin type.
<span class="lineNum">    3996 </span>            : 
<span class="lineNum">    3997 </span>            :    The calls to set_global_binding below should be
<span class="lineNum">    3998 </span>            :    eliminated.  Built-in types should not be looked up name; their
<span class="lineNum">    3999 </span>            :    names are keywords that the parser can recognize.  However, there
<span class="lineNum">    4000 </span>            :    is code in c-common.c that uses identifier_global_value to look up
<span class="lineNum">    4001 </span>            :    built-in types by name.  */
<a name="4002"><span class="lineNum">    4002 </span>            : </a>
<span class="lineNum">    4003 </span>            : void
<span class="lineNum">    4004 </span><span class="lineCov">    1827242 : record_builtin_type (enum rid rid_index,</span>
<span class="lineNum">    4005 </span>            :                      const char* name,
<span class="lineNum">    4006 </span>            :                      tree type)
<span class="lineNum">    4007 </span>            : {
<span class="lineNum">    4008 </span><span class="lineCov">    1827242 :   tree decl = NULL_TREE;</span>
<span class="lineNum">    4009 </span>            : 
<span class="lineNum">    4010 </span><span class="lineCov">    1827242 :   if (name)</span>
<span class="lineNum">    4011 </span>            :     {
<span class="lineNum">    4012 </span><span class="lineCov">    1249672 :       tree tname = get_identifier (name);</span>
<span class="lineNum">    4013 </span><span class="lineCov">    1249672 :       tree tdecl = build_decl (BUILTINS_LOCATION, TYPE_DECL, tname, type);</span>
<span class="lineNum">    4014 </span><span class="lineCov">    1249672 :       DECL_ARTIFICIAL (tdecl) = 1;</span>
<span class="lineNum">    4015 </span><span class="lineCov">    1249672 :       set_global_binding (tdecl);</span>
<span class="lineNum">    4016 </span><span class="lineCov">    1249672 :       decl = tdecl;</span>
<span class="lineNum">    4017 </span>            :     }
<span class="lineNum">    4018 </span>            : 
<span class="lineNum">    4019 </span><span class="lineCov">    1827242 :   if ((int) rid_index &lt; (int) RID_MAX)</span>
<span class="lineNum">    4020 </span><span class="lineCov">     960887 :     if (tree rname = ridpointers[(int) rid_index])</span>
<span class="lineNum">    4021 </span><span class="lineCov">     729859 :       if (!decl || DECL_NAME (decl) != rname)</span>
<span class="lineNum">    4022 </span>            :         {
<span class="lineNum">    4023 </span><span class="lineCov">     462056 :           tree rdecl = build_decl (BUILTINS_LOCATION, TYPE_DECL, rname, type);</span>
<span class="lineNum">    4024 </span><span class="lineCov">     462056 :           DECL_ARTIFICIAL (rdecl) = 1;</span>
<span class="lineNum">    4025 </span><span class="lineCov">     462056 :           set_global_binding (rdecl);</span>
<span class="lineNum">    4026 </span><span class="lineCov">     462056 :           if (!decl)</span>
<span class="lineNum">    4027 </span><span class="lineCov">     288785 :             decl = rdecl;</span>
<span class="lineNum">    4028 </span>            :         }
<span class="lineNum">    4029 </span>            : 
<span class="lineNum">    4030 </span><span class="lineCov">    1827242 :   if (decl)</span>
<span class="lineNum">    4031 </span>            :     {
<span class="lineNum">    4032 </span><span class="lineCov">    1538457 :       if (!TYPE_NAME (type))</span>
<span class="lineNum">    4033 </span><span class="lineCov">    2614858 :         TYPE_NAME (type) = decl;</span>
<span class="lineNum">    4034 </span><span class="lineCov">    1538457 :       debug_hooks-&gt;type_decl (decl, 0);</span>
<span class="lineNum">    4035 </span>            :     }
<span class="lineNum">    4036 </span><span class="lineCov">    1827242 : }</span>
<span class="lineNum">    4037 </span>            : 
<span class="lineNum">    4038 </span>            : /* Push a type into the namespace so that the back ends ignore it.  */
<a name="4039"><span class="lineNum">    4039 </span>            : </a>
<span class="lineNum">    4040 </span>            : static void
<span class="lineNum">    4041 </span><span class="lineCov">     231028 : record_unknown_type (tree type, const char* name)</span>
<span class="lineNum">    4042 </span>            : {
<span class="lineNum">    4043 </span><span class="lineCov">     231028 :   tree decl = pushdecl (build_decl (UNKNOWN_LOCATION,</span>
<span class="lineNum">    4044 </span><span class="lineCov">     231028 :                                     TYPE_DECL, get_identifier (name), type));</span>
<span class="lineNum">    4045 </span>            :   /* Make sure the &quot;unknown type&quot; typedecl gets ignored for debug info.  */
<span class="lineNum">    4046 </span><span class="lineCov">     231028 :   DECL_IGNORED_P (decl) = 1;</span>
<span class="lineNum">    4047 </span><span class="lineCov">     231028 :   TYPE_DECL_SUPPRESS_DEBUG (decl) = 1;</span>
<span class="lineNum">    4048 </span><span class="lineCov">     231028 :   TYPE_SIZE (type) = TYPE_SIZE (void_type_node);</span>
<span class="lineNum">    4049 </span><span class="lineCov">     462056 :   SET_TYPE_ALIGN (type, 1);</span>
<span class="lineNum">    4050 </span><span class="lineCov">     231028 :   TYPE_USER_ALIGN (type) = 0;</span>
<span class="lineNum">    4051 </span><span class="lineCov">     231028 :   SET_TYPE_MODE (type, TYPE_MODE (void_type_node));</span>
<span class="lineNum">    4052 </span><span class="lineCov">     231028 : }</span>
<span class="lineNum">    4053 </span>            : 
<span class="lineNum">    4054 </span>            : /* Create all the predefined identifiers.  */
<a name="4055"><span class="lineNum">    4055 </span>            : </a>
<span class="lineNum">    4056 </span>            : static void
<span class="lineNum">    4057 </span><span class="lineCov">      57757 : initialize_predefined_identifiers (void)</span>
<span class="lineNum">    4058 </span>            : {
<span class="lineNum">    4059 </span><span class="lineCov">      57757 :   struct predefined_identifier</span>
<span class="lineNum">    4060 </span>            :   {
<span class="lineNum">    4061 </span>            :     const char *name; /* Name.  */
<span class="lineNum">    4062 </span>            :     tree *node;  /* Node to store it in.  */
<span class="lineNum">    4063 </span>            :     cp_identifier_kind kind;  /* Kind of identifier.  */
<span class="lineNum">    4064 </span>            :   };
<span class="lineNum">    4065 </span>            : 
<span class="lineNum">    4066 </span>            :   /* A table of identifiers to create at startup.  */
<span class="lineNum">    4067 </span><span class="lineCov">      57757 :   static const predefined_identifier predefined_identifiers[] = {</span>
<span class="lineNum">    4068 </span>            :     {&quot;C++&quot;, &amp;lang_name_cplusplus, cik_normal},
<span class="lineNum">    4069 </span>            :     {&quot;C&quot;, &amp;lang_name_c, cik_normal},
<span class="lineNum">    4070 </span>            :     /* Some of these names have a trailing space so that it is
<span class="lineNum">    4071 </span>            :        impossible for them to conflict with names written by users.  */
<span class="lineNum">    4072 </span>            :     {&quot;__ct &quot;, &amp;ctor_identifier, cik_ctor},
<span class="lineNum">    4073 </span>            :     {&quot;__ct_base &quot;, &amp;base_ctor_identifier, cik_ctor},
<span class="lineNum">    4074 </span>            :     {&quot;__ct_comp &quot;, &amp;complete_ctor_identifier, cik_ctor},
<span class="lineNum">    4075 </span>            :     {&quot;__dt &quot;, &amp;dtor_identifier, cik_dtor},
<span class="lineNum">    4076 </span>            :     {&quot;__dt_base &quot;, &amp;base_dtor_identifier, cik_dtor},
<span class="lineNum">    4077 </span>            :     {&quot;__dt_comp &quot;, &amp;complete_dtor_identifier, cik_dtor},
<span class="lineNum">    4078 </span>            :     {&quot;__dt_del &quot;, &amp;deleting_dtor_identifier, cik_dtor},
<span class="lineNum">    4079 </span>            :     {&quot;__conv_op &quot;, &amp;conv_op_identifier, cik_conv_op},
<span class="lineNum">    4080 </span>            :     {&quot;__in_chrg&quot;, &amp;in_charge_identifier, cik_normal},
<span class="lineNum">    4081 </span>            :     {&quot;this&quot;, &amp;this_identifier, cik_normal},
<span class="lineNum">    4082 </span>            :     {&quot;__delta&quot;, &amp;delta_identifier, cik_normal},
<span class="lineNum">    4083 </span>            :     {&quot;__pfn&quot;, &amp;pfn_identifier, cik_normal},
<span class="lineNum">    4084 </span>            :     {&quot;_vptr&quot;, &amp;vptr_identifier, cik_normal},
<span class="lineNum">    4085 </span>            :     {&quot;__vtt_parm&quot;, &amp;vtt_parm_identifier, cik_normal},
<span class="lineNum">    4086 </span>            :     {&quot;::&quot;, &amp;global_identifier, cik_normal},
<span class="lineNum">    4087 </span>            :     {&quot;std&quot;, &amp;std_identifier, cik_normal},
<span class="lineNum">    4088 </span>            :       /* The demangler expects anonymous namespaces to be called
<span class="lineNum">    4089 </span>            :          something starting with '_GLOBAL__N_'.  It no longer needs
<span class="lineNum">    4090 </span>            :          to be unique to the TU.  */
<span class="lineNum">    4091 </span>            :     {&quot;_GLOBAL__N_1&quot;, &amp;anon_identifier, cik_normal},
<span class="lineNum">    4092 </span>            :     {&quot;auto&quot;, &amp;auto_identifier, cik_normal},
<span class="lineNum">    4093 </span>            :     {&quot;decltype(auto)&quot;, &amp;decltype_auto_identifier, cik_normal},
<span class="lineNum">    4094 </span>            :     {&quot;initializer_list&quot;, &amp;init_list_identifier, cik_normal},
<span class="lineNum">    4095 </span>            :     {&quot;__for_range &quot;, &amp;for_range__identifier, cik_normal},
<span class="lineNum">    4096 </span>            :     {&quot;__for_begin &quot;, &amp;for_begin__identifier, cik_normal},
<span class="lineNum">    4097 </span>            :     {&quot;__for_end &quot;, &amp;for_end__identifier, cik_normal},
<span class="lineNum">    4098 </span>            :     {&quot;__for_range&quot;, &amp;for_range_identifier, cik_normal},
<span class="lineNum">    4099 </span>            :     {&quot;__for_begin&quot;, &amp;for_begin_identifier, cik_normal},
<span class="lineNum">    4100 </span>            :     {&quot;__for_end&quot;, &amp;for_end_identifier, cik_normal},
<span class="lineNum">    4101 </span>            :     {&quot;abi_tag&quot;, &amp;abi_tag_identifier, cik_normal},
<span class="lineNum">    4102 </span>            :     {&quot;aligned&quot;, &amp;aligned_identifier, cik_normal},
<span class="lineNum">    4103 </span>            :     {&quot;begin&quot;, &amp;begin_identifier, cik_normal},
<span class="lineNum">    4104 </span>            :     {&quot;end&quot;, &amp;end_identifier, cik_normal},
<span class="lineNum">    4105 </span>            :     {&quot;get&quot;, &amp;get__identifier, cik_normal},
<span class="lineNum">    4106 </span>            :     {&quot;gnu&quot;, &amp;gnu_identifier, cik_normal},
<span class="lineNum">    4107 </span>            :     {&quot;tuple_element&quot;, &amp;tuple_element_identifier, cik_normal},
<span class="lineNum">    4108 </span>            :     {&quot;tuple_size&quot;, &amp;tuple_size_identifier, cik_normal},
<span class="lineNum">    4109 </span>            :     {&quot;type&quot;, &amp;type_identifier, cik_normal},
<span class="lineNum">    4110 </span>            :     {&quot;value&quot;, &amp;value_identifier, cik_normal},
<span class="lineNum">    4111 </span>            :     {&quot;_FUN&quot;, &amp;fun_identifier, cik_normal},
<span class="lineNum">    4112 </span>            :     {&quot;__closure&quot;, &amp;closure_identifier, cik_normal},
<span class="lineNum">    4113 </span>            :     {NULL, NULL, cik_normal}
<span class="lineNum">    4114 </span>            :   };
<span class="lineNum">    4115 </span>            : 
<span class="lineNum">    4116 </span><span class="lineCov">    2368037 :   for (const predefined_identifier *pid = predefined_identifiers;</span>
<span class="lineNum">    4117 </span><span class="lineCov">    2368037 :        pid-&gt;name; ++pid)</span>
<span class="lineNum">    4118 </span>            :     {
<span class="lineNum">    4119 </span><span class="lineCov">    2310280 :       *pid-&gt;node = get_identifier (pid-&gt;name);</span>
<span class="lineNum">    4120 </span>            :       /* Some of these identifiers already have a special kind.  */
<span class="lineNum">    4121 </span><span class="lineCov">    2310280 :       if (pid-&gt;kind != cik_normal)</span>
<span class="lineNum">    4122 </span><span class="lineCov">     462056 :         set_identifier_kind (*pid-&gt;node, pid-&gt;kind);</span>
<span class="lineNum">    4123 </span>            :     }
<span class="lineNum">    4124 </span><span class="lineCov">      57757 : }</span>
<span class="lineNum">    4125 </span>            : 
<span class="lineNum">    4126 </span>            : /* Create the predefined scalar types of C,
<span class="lineNum">    4127 </span>            :    and some nodes representing standard constants (0, 1, (void *)0).
<span class="lineNum">    4128 </span>            :    Initialize the global binding level.
<span class="lineNum">    4129 </span>            :    Make definitions for built-in primitive functions.  */
<a name="4130"><span class="lineNum">    4130 </span>            : </a>
<span class="lineNum">    4131 </span>            : void
<span class="lineNum">    4132 </span><span class="lineCov">      57757 : cxx_init_decl_processing (void)</span>
<span class="lineNum">    4133 </span>            : {
<span class="lineNum">    4134 </span><span class="lineCov">      57757 :   tree void_ftype;</span>
<span class="lineNum">    4135 </span><span class="lineCov">      57757 :   tree void_ftype_ptr;</span>
<span class="lineNum">    4136 </span>            : 
<span class="lineNum">    4137 </span>            :   /* Create all the identifiers we need.  */
<span class="lineNum">    4138 </span><span class="lineCov">      57757 :   initialize_predefined_identifiers ();</span>
<span class="lineNum">    4139 </span>            : 
<span class="lineNum">    4140 </span>            :   /* Create the global variables.  */
<span class="lineNum">    4141 </span><span class="lineCov">      57757 :   push_to_top_level ();</span>
<span class="lineNum">    4142 </span>            : 
<span class="lineNum">    4143 </span><span class="lineCov">      57757 :   current_function_decl = NULL_TREE;</span>
<span class="lineNum">    4144 </span><span class="lineCov">      57757 :   current_binding_level = NULL;</span>
<span class="lineNum">    4145 </span>            :   /* Enter the global namespace.  */
<span class="lineNum">    4146 </span><span class="lineCov">      57757 :   gcc_assert (global_namespace == NULL_TREE);</span>
<span class="lineNum">    4147 </span><span class="lineCov">      57757 :   global_namespace = build_lang_decl (NAMESPACE_DECL, global_identifier,</span>
<span class="lineNum">    4148 </span>            :                                       void_type_node);
<span class="lineNum">    4149 </span><span class="lineCov">      57757 :   TREE_PUBLIC (global_namespace) = 1;</span>
<span class="lineNum">    4150 </span><span class="lineCov">      57757 :   DECL_CONTEXT (global_namespace)</span>
<span class="lineNum">    4151 </span><span class="lineCov">     115514 :     = build_translation_unit_decl (get_identifier (main_input_filename));</span>
<span class="lineNum">    4152 </span>            :   /* Remember whether we want the empty class passing ABI change warning
<span class="lineNum">    4153 </span>            :      in this TU.  */
<span class="lineNum">    4154 </span><span class="lineCov">      57757 :   TRANSLATION_UNIT_WARN_EMPTY_P (DECL_CONTEXT (global_namespace))</span>
<span class="lineNum">    4155 </span><span class="lineCov">      58289 :     = warn_abi &amp;&amp; abi_version_crosses (12);</span>
<span class="lineNum">    4156 </span><span class="lineCov">      57757 :   debug_hooks-&gt;register_main_translation_unit</span>
<span class="lineNum">    4157 </span><span class="lineCov">      57757 :     (DECL_CONTEXT (global_namespace));</span>
<span class="lineNum">    4158 </span><span class="lineCov">      57757 :   begin_scope (sk_namespace, global_namespace);</span>
<span class="lineNum">    4159 </span><span class="lineCov">      57757 :   current_namespace = global_namespace;</span>
<span class="lineNum">    4160 </span>            : 
<span class="lineNum">    4161 </span><span class="lineCov">      57757 :   if (flag_visibility_ms_compat)</span>
<span class="lineNum">    4162 </span><span class="lineCov">          6 :     default_visibility = VISIBILITY_HIDDEN;</span>
<span class="lineNum">    4163 </span>            : 
<span class="lineNum">    4164 </span>            :   /* Initially, C.  */
<span class="lineNum">    4165 </span><span class="lineCov">      57757 :   current_lang_name = lang_name_c;</span>
<span class="lineNum">    4166 </span>            : 
<span class="lineNum">    4167 </span>            :   /* Create the `std' namespace.  */
<span class="lineNum">    4168 </span><span class="lineCov">      57757 :   push_namespace (std_identifier);</span>
<span class="lineNum">    4169 </span><span class="lineCov">      57757 :   std_node = current_namespace;</span>
<span class="lineNum">    4170 </span><span class="lineCov">      57757 :   pop_namespace ();</span>
<span class="lineNum">    4171 </span>            : 
<span class="lineNum">    4172 </span><span class="lineCov">      57757 :   flag_noexcept_type = (cxx_dialect &gt;= cxx17);</span>
<span class="lineNum">    4173 </span>            : 
<span class="lineNum">    4174 </span><span class="lineCov">      57757 :   c_common_nodes_and_builtins ();</span>
<span class="lineNum">    4175 </span>            : 
<span class="lineNum">    4176 </span><span class="lineCov">      57757 :   tree bool_ftype = build_function_type_list (boolean_type_node, NULL_TREE);</span>
<span class="lineNum">    4177 </span><span class="lineCov">      57757 :   tree decl</span>
<span class="lineNum">    4178 </span><span class="lineCov">      57757 :     = add_builtin_function (&quot;__builtin_is_constant_evaluated&quot;,</span>
<span class="lineNum">    4179 </span>            :                             bool_ftype, CP_BUILT_IN_IS_CONSTANT_EVALUATED,
<span class="lineNum">    4180 </span>            :                             BUILT_IN_FRONTEND, NULL, NULL_TREE);
<span class="lineNum">    4181 </span><span class="lineCov">      57757 :   set_call_expr_flags (decl, ECF_CONST | ECF_NOTHROW | ECF_LEAF);</span>
<span class="lineNum">    4182 </span>            : 
<span class="lineNum">    4183 </span><span class="lineCov">     115514 :   integer_two_node = build_int_cst (NULL_TREE, 2);</span>
<span class="lineNum">    4184 </span>            : 
<span class="lineNum">    4185 </span>            :   /* Guess at the initial static decls size.  */
<span class="lineNum">    4186 </span><span class="lineCov">      57757 :   vec_alloc (static_decls, 500);</span>
<span class="lineNum">    4187 </span>            : 
<span class="lineNum">    4188 </span>            :   /* ... and keyed classes.  */
<span class="lineNum">    4189 </span><span class="lineCov">      57757 :   vec_alloc (keyed_classes, 100);</span>
<span class="lineNum">    4190 </span>            : 
<span class="lineNum">    4191 </span><span class="lineCov">      57757 :   record_builtin_type (RID_BOOL, &quot;bool&quot;, boolean_type_node);</span>
<span class="lineNum">    4192 </span><span class="lineCov">      57757 :   truthvalue_type_node = boolean_type_node;</span>
<span class="lineNum">    4193 </span><span class="lineCov">      57757 :   truthvalue_false_node = boolean_false_node;</span>
<span class="lineNum">    4194 </span><span class="lineCov">      57757 :   truthvalue_true_node = boolean_true_node;</span>
<span class="lineNum">    4195 </span>            : 
<span class="lineNum">    4196 </span><span class="lineCov">      57757 :   empty_except_spec = build_tree_list (NULL_TREE, NULL_TREE);</span>
<span class="lineNum">    4197 </span><span class="lineCov">      57757 :   noexcept_true_spec = build_tree_list (boolean_true_node, NULL_TREE);</span>
<span class="lineNum">    4198 </span><span class="lineCov">      57757 :   noexcept_false_spec = build_tree_list (boolean_false_node, NULL_TREE);</span>
<span class="lineNum">    4199 </span><span class="lineCov">      57757 :   noexcept_deferred_spec = build_tree_list (make_node (DEFERRED_NOEXCEPT),</span>
<span class="lineNum">    4200 </span>            :                                             NULL_TREE);
<span class="lineNum">    4201 </span>            : 
<span class="lineNum">    4202 </span>            : #if 0
<span class="lineNum">    4203 </span>            :   record_builtin_type (RID_MAX, NULL, string_type_node);
<span class="lineNum">    4204 </span>            : #endif
<span class="lineNum">    4205 </span>            : 
<span class="lineNum">    4206 </span><span class="lineCov">      57757 :   delta_type_node = ptrdiff_type_node;</span>
<span class="lineNum">    4207 </span><span class="lineCov">      57757 :   vtable_index_type = ptrdiff_type_node;</span>
<span class="lineNum">    4208 </span>            : 
<span class="lineNum">    4209 </span><span class="lineCov">      57757 :   vtt_parm_type = build_pointer_type (const_ptr_type_node);</span>
<span class="lineNum">    4210 </span><span class="lineCov">      57757 :   void_ftype = build_function_type_list (void_type_node, NULL_TREE);</span>
<span class="lineNum">    4211 </span><span class="lineCov">      57757 :   void_ftype_ptr = build_function_type_list (void_type_node,</span>
<span class="lineNum">    4212 </span>            :                                              ptr_type_node, NULL_TREE);
<span class="lineNum">    4213 </span><span class="lineCov">      57757 :   void_ftype_ptr</span>
<span class="lineNum">    4214 </span><span class="lineCov">      57757 :     = build_exception_variant (void_ftype_ptr, empty_except_spec);</span>
<span class="lineNum">    4215 </span>            : 
<span class="lineNum">    4216 </span>            :   /* Create the conversion operator marker.  This operator's DECL_NAME
<span class="lineNum">    4217 </span>            :      is in the identifier table, so we can use identifier equality to
<span class="lineNum">    4218 </span>            :      find it.  */
<span class="lineNum">    4219 </span><span class="lineCov">      57757 :   conv_op_marker = build_lang_decl (FUNCTION_DECL, conv_op_identifier,</span>
<span class="lineNum">    4220 </span>            :                                     void_ftype);
<span class="lineNum">    4221 </span>            : 
<span class="lineNum">    4222 </span>            :   /* C++ extensions */
<span class="lineNum">    4223 </span>            : 
<span class="lineNum">    4224 </span><span class="lineCov">      57757 :   unknown_type_node = make_node (LANG_TYPE);</span>
<span class="lineNum">    4225 </span><span class="lineCov">      57757 :   record_unknown_type (unknown_type_node, &quot;unknown type&quot;);</span>
<span class="lineNum">    4226 </span>            : 
<span class="lineNum">    4227 </span>            :   /* Indirecting an UNKNOWN_TYPE node yields an UNKNOWN_TYPE node.  */
<span class="lineNum">    4228 </span><span class="lineCov">      57757 :   TREE_TYPE (unknown_type_node) = unknown_type_node;</span>
<span class="lineNum">    4229 </span>            : 
<span class="lineNum">    4230 </span>            :   /* Looking up TYPE_POINTER_TO and TYPE_REFERENCE_TO yield the same
<span class="lineNum">    4231 </span>            :      result.  */
<span class="lineNum">    4232 </span><span class="lineCov">      57757 :   TYPE_POINTER_TO (unknown_type_node) = unknown_type_node;</span>
<span class="lineNum">    4233 </span><span class="lineCov">      57757 :   TYPE_REFERENCE_TO (unknown_type_node) = unknown_type_node;</span>
<span class="lineNum">    4234 </span>            : 
<span class="lineNum">    4235 </span><span class="lineCov">      57757 :   init_list_type_node = make_node (LANG_TYPE);</span>
<span class="lineNum">    4236 </span><span class="lineCov">      57757 :   record_unknown_type (init_list_type_node, &quot;init list&quot;);</span>
<span class="lineNum">    4237 </span>            : 
<span class="lineNum">    4238 </span><span class="lineCov">      57757 :   {</span>
<span class="lineNum">    4239 </span>            :     /* Make sure we get a unique function type, so we can give
<span class="lineNum">    4240 </span>            :        its pointer type a name.  (This wins for gdb.) */
<span class="lineNum">    4241 </span><span class="lineCov">      57757 :     tree vfunc_type = make_node (FUNCTION_TYPE);</span>
<span class="lineNum">    4242 </span><span class="lineCov">      57757 :     TREE_TYPE (vfunc_type) = integer_type_node;</span>
<span class="lineNum">    4243 </span><span class="lineCov">      57757 :     TYPE_ARG_TYPES (vfunc_type) = NULL_TREE;</span>
<span class="lineNum">    4244 </span><span class="lineCov">      57757 :     layout_type (vfunc_type);</span>
<span class="lineNum">    4245 </span>            : 
<span class="lineNum">    4246 </span><span class="lineCov">      57757 :     vtable_entry_type = build_pointer_type (vfunc_type);</span>
<span class="lineNum">    4247 </span>            :   }
<span class="lineNum">    4248 </span><span class="lineCov">      57757 :   record_builtin_type (RID_MAX, &quot;__vtbl_ptr_type&quot;, vtable_entry_type);</span>
<span class="lineNum">    4249 </span>            : 
<span class="lineNum">    4250 </span><span class="lineCov">      57757 :   vtbl_type_node</span>
<span class="lineNum">    4251 </span><span class="lineCov">      57757 :     = build_cplus_array_type (vtable_entry_type, NULL_TREE);</span>
<span class="lineNum">    4252 </span><span class="lineCov">      57757 :   layout_type (vtbl_type_node);</span>
<span class="lineNum">    4253 </span><span class="lineCov">      57757 :   vtbl_type_node = cp_build_qualified_type (vtbl_type_node, TYPE_QUAL_CONST);</span>
<span class="lineNum">    4254 </span><span class="lineCov">      57757 :   record_builtin_type (RID_MAX, NULL, vtbl_type_node);</span>
<span class="lineNum">    4255 </span><span class="lineCov">      57757 :   vtbl_ptr_type_node = build_pointer_type (vtable_entry_type);</span>
<span class="lineNum">    4256 </span><span class="lineCov">      57757 :   layout_type (vtbl_ptr_type_node);</span>
<span class="lineNum">    4257 </span><span class="lineCov">      57757 :   record_builtin_type (RID_MAX, NULL, vtbl_ptr_type_node);</span>
<span class="lineNum">    4258 </span>            : 
<span class="lineNum">    4259 </span><span class="lineCov">      57757 :   push_namespace (get_identifier (&quot;__cxxabiv1&quot;));</span>
<span class="lineNum">    4260 </span><span class="lineCov">      57757 :   abi_node = current_namespace;</span>
<span class="lineNum">    4261 </span><span class="lineCov">      57757 :   pop_namespace ();</span>
<span class="lineNum">    4262 </span>            : 
<span class="lineNum">    4263 </span><span class="lineCov">      57757 :   global_type_node = make_node (LANG_TYPE);</span>
<span class="lineNum">    4264 </span><span class="lineCov">      57757 :   record_unknown_type (global_type_node, &quot;global type&quot;);</span>
<span class="lineNum">    4265 </span>            : 
<span class="lineNum">    4266 </span><span class="lineCov">      57757 :   any_targ_node = make_node (LANG_TYPE);</span>
<span class="lineNum">    4267 </span><span class="lineCov">      57757 :   record_unknown_type (any_targ_node, &quot;any type&quot;);</span>
<span class="lineNum">    4268 </span>            : 
<span class="lineNum">    4269 </span>            :   /* Now, C++.  */
<span class="lineNum">    4270 </span><span class="lineCov">      57757 :   current_lang_name = lang_name_cplusplus;</span>
<span class="lineNum">    4271 </span>            : 
<span class="lineNum">    4272 </span><span class="lineCov">      57757 :   if (aligned_new_threshold &gt; 1</span>
<span class="lineNum">    4273 </span><span class="lineCov">      57757 :       &amp;&amp; !pow2p_hwi (aligned_new_threshold))</span>
<span class="lineNum">    4274 </span>            :     {
<span class="lineNum">    4275 </span><span class="lineNoCov">          0 :       error (&quot;-faligned-new=%d is not a power of two&quot;, aligned_new_threshold);</span>
<span class="lineNum">    4276 </span><span class="lineNoCov">          0 :       aligned_new_threshold = 1;</span>
<span class="lineNum">    4277 </span>            :     }
<span class="lineNum">    4278 </span><span class="lineCov">      57757 :   if (aligned_new_threshold == -1)</span>
<span class="lineNum">    4279 </span><span class="lineCov">     114476 :     aligned_new_threshold = (cxx_dialect &gt;= cxx17) ? 1 : 0;</span>
<span class="lineNum">    4280 </span><span class="lineCov">      57757 :   if (aligned_new_threshold == 1)</span>
<span class="lineNum">    4281 </span><span class="lineCov">       1027 :     aligned_new_threshold = malloc_alignment () / BITS_PER_UNIT;</span>
<span class="lineNum">    4282 </span>            : 
<span class="lineNum">    4283 </span><span class="lineCov">      57757 :   {</span>
<span class="lineNum">    4284 </span><span class="lineCov">      57757 :     tree newattrs, extvisattr;</span>
<span class="lineNum">    4285 </span><span class="lineCov">      57757 :     tree newtype, deltype;</span>
<span class="lineNum">    4286 </span><span class="lineCov">      57757 :     tree ptr_ftype_sizetype;</span>
<span class="lineNum">    4287 </span><span class="lineCov">      57757 :     tree new_eh_spec;</span>
<span class="lineNum">    4288 </span>            : 
<span class="lineNum">    4289 </span><span class="lineCov">      57757 :     ptr_ftype_sizetype</span>
<span class="lineNum">    4290 </span><span class="lineCov">      57757 :       = build_function_type_list (ptr_type_node, size_type_node, NULL_TREE);</span>
<span class="lineNum">    4291 </span><span class="lineCov">      57757 :     if (cxx_dialect == cxx98)</span>
<span class="lineNum">    4292 </span>            :       {
<span class="lineNum">    4293 </span><span class="lineCov">      10491 :         tree bad_alloc_id;</span>
<span class="lineNum">    4294 </span><span class="lineCov">      10491 :         tree bad_alloc_type_node;</span>
<span class="lineNum">    4295 </span><span class="lineCov">      10491 :         tree bad_alloc_decl;</span>
<span class="lineNum">    4296 </span>            : 
<span class="lineNum">    4297 </span><span class="lineCov">      10491 :         push_namespace (std_identifier);</span>
<span class="lineNum">    4298 </span><span class="lineCov">      10491 :         bad_alloc_id = get_identifier (&quot;bad_alloc&quot;);</span>
<span class="lineNum">    4299 </span><span class="lineCov">      10491 :         bad_alloc_type_node = make_class_type (RECORD_TYPE);</span>
<span class="lineNum">    4300 </span><span class="lineCov">      10491 :         TYPE_CONTEXT (bad_alloc_type_node) = current_namespace;</span>
<span class="lineNum">    4301 </span><span class="lineCov">      10491 :         bad_alloc_decl</span>
<span class="lineNum">    4302 </span><span class="lineCov">      10491 :           = create_implicit_typedef (bad_alloc_id, bad_alloc_type_node);</span>
<span class="lineNum">    4303 </span><span class="lineCov">      10491 :         DECL_CONTEXT (bad_alloc_decl) = current_namespace;</span>
<span class="lineNum">    4304 </span><span class="lineCov">      10491 :         pop_namespace ();</span>
<span class="lineNum">    4305 </span>            : 
<span class="lineNum">    4306 </span><span class="lineCov">      10491 :         new_eh_spec</span>
<span class="lineNum">    4307 </span><span class="lineCov">      10491 :           = add_exception_specifier (NULL_TREE, bad_alloc_type_node, -1);</span>
<span class="lineNum">    4308 </span>            :       }
<span class="lineNum">    4309 </span>            :     else
<span class="lineNum">    4310 </span><span class="lineCov">      47266 :       new_eh_spec = noexcept_false_spec;</span>
<span class="lineNum">    4311 </span>            : 
<span class="lineNum">    4312 </span>            :     /* Ensure attribs.c is initialized.  */
<span class="lineNum">    4313 </span><span class="lineCov">      57757 :     init_attributes ();</span>
<span class="lineNum">    4314 </span>            : 
<span class="lineNum">    4315 </span>            :     /* Ensure constraint.cc is initialized. */
<span class="lineNum">    4316 </span><span class="lineCov">      57757 :     init_constraint_processing ();</span>
<span class="lineNum">    4317 </span>            : 
<span class="lineNum">    4318 </span><span class="lineCov">      57757 :     extvisattr = build_tree_list (get_identifier (&quot;externally_visible&quot;),</span>
<span class="lineNum">    4319 </span>            :                                   NULL_TREE);
<span class="lineNum">    4320 </span><span class="lineCov">      57757 :     newattrs = tree_cons (get_identifier (&quot;alloc_size&quot;),</span>
<span class="lineNum">    4321 </span>            :                           build_tree_list (NULL_TREE, integer_one_node),
<span class="lineNum">    4322 </span>            :                           extvisattr);
<span class="lineNum">    4323 </span><span class="lineCov">      57757 :     newtype = cp_build_type_attribute_variant (ptr_ftype_sizetype, newattrs);</span>
<span class="lineNum">    4324 </span><span class="lineCov">      57757 :     newtype = build_exception_variant (newtype, new_eh_spec);</span>
<span class="lineNum">    4325 </span><span class="lineCov">      57757 :     deltype = cp_build_type_attribute_variant (void_ftype_ptr, extvisattr);</span>
<span class="lineNum">    4326 </span><span class="lineCov">      57757 :     deltype = build_exception_variant (deltype, empty_except_spec);</span>
<span class="lineNum">    4327 </span><span class="lineCov">      57757 :     tree opnew = push_cp_library_fn (NEW_EXPR, newtype, 0);</span>
<span class="lineNum">    4328 </span><span class="lineCov">      57757 :     DECL_IS_MALLOC (opnew) = 1;</span>
<span class="lineNum">    4329 </span><span class="lineCov">      57757 :     DECL_IS_OPERATOR_NEW (opnew) = 1;</span>
<span class="lineNum">    4330 </span><span class="lineCov">      57757 :     opnew = push_cp_library_fn (VEC_NEW_EXPR, newtype, 0);</span>
<span class="lineNum">    4331 </span><span class="lineCov">      57757 :     DECL_IS_MALLOC (opnew) = 1;</span>
<span class="lineNum">    4332 </span><span class="lineCov">      57757 :     DECL_IS_OPERATOR_NEW (opnew) = 1;</span>
<span class="lineNum">    4333 </span><span class="lineCov">      57757 :     push_cp_library_fn (DELETE_EXPR, deltype, ECF_NOTHROW);</span>
<span class="lineNum">    4334 </span><span class="lineCov">      57757 :     push_cp_library_fn (VEC_DELETE_EXPR, deltype, ECF_NOTHROW);</span>
<span class="lineNum">    4335 </span><span class="lineCov">      57757 :     if (flag_sized_deallocation)</span>
<span class="lineNum">    4336 </span>            :       {
<span class="lineNum">    4337 </span>            :         /* Also push the sized deallocation variants:
<span class="lineNum">    4338 </span>            :              void operator delete(void*, std::size_t) throw();
<span class="lineNum">    4339 </span>            :              void operator delete[](void*, std::size_t) throw();  */
<span class="lineNum">    4340 </span><span class="lineCov">      33082 :         tree void_ftype_ptr_size</span>
<span class="lineNum">    4341 </span><span class="lineCov">      33082 :           = build_function_type_list (void_type_node, ptr_type_node,</span>
<span class="lineNum">    4342 </span>            :                                       size_type_node, NULL_TREE);
<span class="lineNum">    4343 </span><span class="lineCov">      33082 :         deltype = cp_build_type_attribute_variant (void_ftype_ptr_size,</span>
<span class="lineNum">    4344 </span>            :                                                    extvisattr);
<span class="lineNum">    4345 </span><span class="lineCov">      33082 :         deltype = build_exception_variant (deltype, empty_except_spec);</span>
<span class="lineNum">    4346 </span><span class="lineCov">      33082 :         push_cp_library_fn (DELETE_EXPR, deltype, ECF_NOTHROW);</span>
<span class="lineNum">    4347 </span><span class="lineCov">      33082 :         push_cp_library_fn (VEC_DELETE_EXPR, deltype, ECF_NOTHROW);</span>
<span class="lineNum">    4348 </span>            :       }
<span class="lineNum">    4349 </span>            : 
<span class="lineNum">    4350 </span><span class="lineCov">      57757 :     if (aligned_new_threshold)</span>
<span class="lineNum">    4351 </span>            :       {
<span class="lineNum">    4352 </span><span class="lineCov">       1027 :         push_namespace (std_identifier);</span>
<span class="lineNum">    4353 </span><span class="lineCov">       1027 :         tree align_id = get_identifier (&quot;align_val_t&quot;);</span>
<span class="lineNum">    4354 </span><span class="lineCov">       1027 :         align_type_node = start_enum (align_id, NULL_TREE, size_type_node,</span>
<span class="lineNum">    4355 </span>            :                                       NULL_TREE, /*scoped*/true, NULL);
<span class="lineNum">    4356 </span><span class="lineCov">       1027 :         pop_namespace ();</span>
<span class="lineNum">    4357 </span>            : 
<span class="lineNum">    4358 </span>            :         /* operator new (size_t, align_val_t); */
<span class="lineNum">    4359 </span><span class="lineCov">       1027 :         newtype = build_function_type_list (ptr_type_node, size_type_node,</span>
<span class="lineNum">    4360 </span>            :                                             align_type_node, NULL_TREE);
<span class="lineNum">    4361 </span><span class="lineCov">       1027 :         newtype = cp_build_type_attribute_variant (newtype, newattrs);</span>
<span class="lineNum">    4362 </span><span class="lineCov">       1027 :         newtype = build_exception_variant (newtype, new_eh_spec);</span>
<span class="lineNum">    4363 </span><span class="lineCov">       1027 :         opnew = push_cp_library_fn (NEW_EXPR, newtype, 0);</span>
<span class="lineNum">    4364 </span><span class="lineCov">       1027 :         DECL_IS_MALLOC (opnew) = 1;</span>
<span class="lineNum">    4365 </span><span class="lineCov">       1027 :         DECL_IS_OPERATOR_NEW (opnew) = 1;</span>
<span class="lineNum">    4366 </span><span class="lineCov">       1027 :         opnew = push_cp_library_fn (VEC_NEW_EXPR, newtype, 0);</span>
<span class="lineNum">    4367 </span><span class="lineCov">       1027 :         DECL_IS_MALLOC (opnew) = 1;</span>
<span class="lineNum">    4368 </span><span class="lineCov">       1027 :         DECL_IS_OPERATOR_NEW (opnew) = 1;</span>
<span class="lineNum">    4369 </span>            : 
<span class="lineNum">    4370 </span>            :         /* operator delete (void *, align_val_t); */
<span class="lineNum">    4371 </span><span class="lineCov">       1027 :         deltype = build_function_type_list (void_type_node, ptr_type_node,</span>
<span class="lineNum">    4372 </span>            :                                             align_type_node, NULL_TREE);
<span class="lineNum">    4373 </span><span class="lineCov">       1027 :         deltype = cp_build_type_attribute_variant (deltype, extvisattr);</span>
<span class="lineNum">    4374 </span><span class="lineCov">       1027 :         deltype = build_exception_variant (deltype, empty_except_spec);</span>
<span class="lineNum">    4375 </span><span class="lineCov">       1027 :         push_cp_library_fn (DELETE_EXPR, deltype, ECF_NOTHROW);</span>
<span class="lineNum">    4376 </span><span class="lineCov">       1027 :         push_cp_library_fn (VEC_DELETE_EXPR, deltype, ECF_NOTHROW);</span>
<span class="lineNum">    4377 </span>            : 
<span class="lineNum">    4378 </span><span class="lineCov">       1027 :         if (flag_sized_deallocation)</span>
<span class="lineNum">    4379 </span>            :           {
<span class="lineNum">    4380 </span>            :             /* operator delete (void *, size_t, align_val_t); */
<span class="lineNum">    4381 </span><span class="lineCov">       1024 :             deltype = build_function_type_list (void_type_node, ptr_type_node,</span>
<span class="lineNum">    4382 </span>            :                                                 size_type_node, align_type_node,
<span class="lineNum">    4383 </span>            :                                                 NULL_TREE);
<span class="lineNum">    4384 </span><span class="lineCov">       1024 :             deltype = cp_build_type_attribute_variant (deltype, extvisattr);</span>
<span class="lineNum">    4385 </span><span class="lineCov">       1024 :             deltype = build_exception_variant (deltype, empty_except_spec);</span>
<span class="lineNum">    4386 </span><span class="lineCov">       1024 :             push_cp_library_fn (DELETE_EXPR, deltype, ECF_NOTHROW);</span>
<span class="lineNum">    4387 </span><span class="lineCov">       1024 :             push_cp_library_fn (VEC_DELETE_EXPR, deltype, ECF_NOTHROW);</span>
<span class="lineNum">    4388 </span>            :           }
<span class="lineNum">    4389 </span>            :       }
<span class="lineNum">    4390 </span>            : 
<span class="lineNum">    4391 </span><span class="lineCov">      57757 :     nullptr_type_node = make_node (NULLPTR_TYPE);</span>
<span class="lineNum">    4392 </span><span class="lineCov">     173271 :     TYPE_SIZE (nullptr_type_node) = bitsize_int (GET_MODE_BITSIZE (ptr_mode));</span>
<span class="lineNum">    4393 </span><span class="lineCov">     173271 :     TYPE_SIZE_UNIT (nullptr_type_node) = size_int (GET_MODE_SIZE (ptr_mode));</span>
<span class="lineNum">    4394 </span><span class="lineCov">      57757 :     TYPE_UNSIGNED (nullptr_type_node) = 1;</span>
<span class="lineNum">    4395 </span><span class="lineCov">     115514 :     TYPE_PRECISION (nullptr_type_node) = GET_MODE_BITSIZE (ptr_mode);</span>
<span class="lineNum">    4396 </span><span class="lineCov">      57757 :     if (abi_version_at_least (9))</span>
<span class="lineNum">    4397 </span><span class="lineCov">     115194 :       SET_TYPE_ALIGN (nullptr_type_node, GET_MODE_ALIGNMENT (ptr_mode));</span>
<span class="lineNum">    4398 </span><span class="lineCov">     115514 :     SET_TYPE_MODE (nullptr_type_node, ptr_mode);</span>
<span class="lineNum">    4399 </span><span class="lineCov">      57757 :     record_builtin_type (RID_MAX, &quot;decltype(nullptr)&quot;, nullptr_type_node);</span>
<span class="lineNum">    4400 </span><span class="lineCov">     115514 :     nullptr_node = build_int_cst (nullptr_type_node, 0);</span>
<span class="lineNum">    4401 </span>            :   }
<span class="lineNum">    4402 </span>            : 
<span class="lineNum">    4403 </span><span class="lineCov">      57757 :   abort_fndecl</span>
<span class="lineNum">    4404 </span><span class="lineCov">      57757 :     = build_library_fn_ptr (&quot;__cxa_pure_virtual&quot;, void_ftype,</span>
<span class="lineNum">    4405 </span>            :                             ECF_NORETURN | ECF_NOTHROW | ECF_COLD);
<span class="lineNum">    4406 </span>            : 
<span class="lineNum">    4407 </span>            :   /* Perform other language dependent initializations.  */
<span class="lineNum">    4408 </span><span class="lineCov">      57757 :   init_class_processing ();</span>
<span class="lineNum">    4409 </span><span class="lineCov">      57757 :   init_rtti_processing ();</span>
<span class="lineNum">    4410 </span><span class="lineCov">      57757 :   init_template_processing ();</span>
<span class="lineNum">    4411 </span>            : 
<span class="lineNum">    4412 </span><span class="lineCov">      57757 :   if (flag_exceptions)</span>
<span class="lineNum">    4413 </span><span class="lineCov">      57027 :     init_exception_processing ();</span>
<span class="lineNum">    4414 </span>            : 
<span class="lineNum">    4415 </span><span class="lineCov">      57757 :   if (! supports_one_only ())</span>
<span class="lineNum">    4416 </span><span class="lineNoCov">          0 :     flag_weak = 0;</span>
<span class="lineNum">    4417 </span>            : 
<span class="lineNum">    4418 </span><span class="lineCov">      57757 :   make_fname_decl = cp_make_fname_decl;</span>
<span class="lineNum">    4419 </span><span class="lineCov">      57757 :   start_fname_decls ();</span>
<span class="lineNum">    4420 </span>            : 
<span class="lineNum">    4421 </span>            :   /* Show we use EH for cleanups.  */
<span class="lineNum">    4422 </span><span class="lineCov">      57757 :   if (flag_exceptions)</span>
<span class="lineNum">    4423 </span><span class="lineCov">      57027 :     using_eh_for_cleanups ();</span>
<span class="lineNum">    4424 </span><span class="lineCov">      57757 : }</span>
<span class="lineNum">    4425 </span>            : 
<span class="lineNum">    4426 </span>            : /* Generate an initializer for a function naming variable from
<span class="lineNum">    4427 </span>            :    NAME. NAME may be NULL, to indicate a dependent name.  TYPE_P is
<span class="lineNum">    4428 </span>            :    filled in with the type of the init.  */
<a name="4429"><span class="lineNum">    4429 </span>            : </a>
<span class="lineNum">    4430 </span>            : tree
<span class="lineNum">    4431 </span><span class="lineCov">      27012 : cp_fname_init (const char* name, tree *type_p)</span>
<span class="lineNum">    4432 </span>            : {
<span class="lineNum">    4433 </span><span class="lineCov">      27012 :   tree domain = NULL_TREE;</span>
<span class="lineNum">    4434 </span><span class="lineCov">      27012 :   tree type;</span>
<span class="lineNum">    4435 </span><span class="lineCov">      27012 :   tree init = NULL_TREE;</span>
<span class="lineNum">    4436 </span><span class="lineCov">      27012 :   size_t length = 0;</span>
<span class="lineNum">    4437 </span>            : 
<span class="lineNum">    4438 </span><span class="lineCov">      27012 :   if (name)</span>
<span class="lineNum">    4439 </span>            :     {
<span class="lineNum">    4440 </span><span class="lineCov">      11400 :       length = strlen (name);</span>
<span class="lineNum">    4441 </span><span class="lineCov">      22800 :       domain = build_index_type (size_int (length));</span>
<span class="lineNum">    4442 </span><span class="lineCov">      11400 :       init = build_string (length + 1, name);</span>
<span class="lineNum">    4443 </span>            :     }
<span class="lineNum">    4444 </span>            : 
<span class="lineNum">    4445 </span><span class="lineCov">      27012 :   type = cp_build_qualified_type (char_type_node, TYPE_QUAL_CONST);</span>
<span class="lineNum">    4446 </span><span class="lineCov">      27012 :   type = build_cplus_array_type (type, domain);</span>
<span class="lineNum">    4447 </span>            : 
<span class="lineNum">    4448 </span><span class="lineCov">      27012 :   *type_p = type;</span>
<span class="lineNum">    4449 </span>            : 
<span class="lineNum">    4450 </span><span class="lineCov">      27012 :   if (init)</span>
<span class="lineNum">    4451 </span><span class="lineCov">      11400 :     TREE_TYPE (init) = type;</span>
<span class="lineNum">    4452 </span>            :   else
<span class="lineNum">    4453 </span><span class="lineCov">      15612 :     init = error_mark_node;</span>
<span class="lineNum">    4454 </span>            : 
<span class="lineNum">    4455 </span><span class="lineCov">      27012 :   return init;</span>
<span class="lineNum">    4456 </span>            : }
<span class="lineNum">    4457 </span>            : 
<span class="lineNum">    4458 </span>            : /* Create the VAR_DECL for __FUNCTION__ etc. ID is the name to give
<span class="lineNum">    4459 </span>            :    the decl, LOC is the location to give the decl, NAME is the
<span class="lineNum">    4460 </span>            :    initialization string and TYPE_DEP indicates whether NAME depended
<span class="lineNum">    4461 </span>            :    on the type of the function. We make use of that to detect
<span class="lineNum">    4462 </span>            :    __PRETTY_FUNCTION__ inside a template fn. This is being done lazily
<span class="lineNum">    4463 </span>            :    at the point of first use, so we mustn't push the decl now.  */
<a name="4464"><span class="lineNum">    4464 </span>            : </a>
<span class="lineNum">    4465 </span>            : static tree
<span class="lineNum">    4466 </span><span class="lineCov">      23526 : cp_make_fname_decl (location_t loc, tree id, int type_dep)</span>
<span class="lineNum">    4467 </span>            : {
<span class="lineNum">    4468 </span><span class="lineCov">      22861 :   const char *const name = (type_dep &amp;&amp; processing_template_decl</span>
<span class="lineNum">    4469 </span><span class="lineCov">      30775 :                             ? NULL : fname_as_string (type_dep));</span>
<span class="lineNum">    4470 </span><span class="lineCov">      23526 :   tree type;</span>
<span class="lineNum">    4471 </span><span class="lineCov">      23526 :   tree init = cp_fname_init (name, &amp;type);</span>
<span class="lineNum">    4472 </span><span class="lineCov">      23526 :   tree decl = build_decl (loc, VAR_DECL, id, type);</span>
<span class="lineNum">    4473 </span>            : 
<span class="lineNum">    4474 </span><span class="lineCov">      23526 :   if (name)</span>
<span class="lineNum">    4475 </span><span class="lineCov">       7914 :     free (CONST_CAST (char *, name));</span>
<span class="lineNum">    4476 </span>            : 
<span class="lineNum">    4477 </span><span class="lineCov">      23526 :   TREE_STATIC (decl) = 1;</span>
<span class="lineNum">    4478 </span><span class="lineCov">      23526 :   TREE_READONLY (decl) = 1;</span>
<span class="lineNum">    4479 </span><span class="lineCov">      23526 :   DECL_ARTIFICIAL (decl) = 1;</span>
<span class="lineNum">    4480 </span>            : 
<span class="lineNum">    4481 </span><span class="lineCov">      23526 :   TREE_USED (decl) = 1;</span>
<span class="lineNum">    4482 </span>            : 
<span class="lineNum">    4483 </span><span class="lineCov">      23526 :   if (current_function_decl)</span>
<span class="lineNum">    4484 </span>            :     {
<span class="lineNum">    4485 </span><span class="lineCov">      23512 :       DECL_CONTEXT (decl) = current_function_decl;</span>
<span class="lineNum">    4486 </span><span class="lineCov">      23512 :       decl = pushdecl_outermost_localscope (decl);</span>
<span class="lineNum">    4487 </span><span class="lineCov">      23512 :       cp_finish_decl (decl, init, /*init_const_expr_p=*/false, NULL_TREE,</span>
<span class="lineNum">    4488 </span>            :                       LOOKUP_ONLYCONVERTING);
<span class="lineNum">    4489 </span>            :     }
<span class="lineNum">    4490 </span>            :   else
<span class="lineNum">    4491 </span>            :     {
<span class="lineNum">    4492 </span><span class="lineCov">         14 :       DECL_THIS_STATIC (decl) = true;</span>
<span class="lineNum">    4493 </span><span class="lineCov">         14 :       pushdecl_top_level_and_finish (decl, init);</span>
<span class="lineNum">    4494 </span>            :     }
<span class="lineNum">    4495 </span>            : 
<span class="lineNum">    4496 </span><span class="lineCov">      23526 :   return decl;</span>
<span class="lineNum">    4497 </span>            : }
<a name="4498"><span class="lineNum">    4498 </span>            : </a>
<span class="lineNum">    4499 </span>            : static tree
<span class="lineNum">    4500 </span><span class="lineCov">  115997803 : builtin_function_1 (tree decl, tree context, bool is_global)</span>
<span class="lineNum">    4501 </span>            : {
<span class="lineNum">    4502 </span><span class="lineCov">  115997803 :   tree          id = DECL_NAME (decl);</span>
<span class="lineNum">    4503 </span><span class="lineCov">  115997803 :   const char *name = IDENTIFIER_POINTER (id);</span>
<span class="lineNum">    4504 </span>            : 
<span class="lineNum">    4505 </span><span class="lineCov">  115997803 :   retrofit_lang_decl (decl);</span>
<span class="lineNum">    4506 </span>            : 
<span class="lineNum">    4507 </span><span class="lineCov">  115997803 :   DECL_ARTIFICIAL (decl) = 1;</span>
<span class="lineNum">    4508 </span><span class="lineCov">  115997803 :   SET_DECL_LANGUAGE (decl, lang_c);</span>
<span class="lineNum">    4509 </span>            :   /* Runtime library routines are, by definition, available in an
<span class="lineNum">    4510 </span>            :      external shared object.  */
<span class="lineNum">    4511 </span><span class="lineCov">  115997803 :   DECL_VISIBILITY (decl) = VISIBILITY_DEFAULT;</span>
<span class="lineNum">    4512 </span><span class="lineCov">  115997803 :   DECL_VISIBILITY_SPECIFIED (decl) = 1;</span>
<span class="lineNum">    4513 </span>            : 
<span class="lineNum">    4514 </span><span class="lineCov">  115997803 :   DECL_CONTEXT (decl) = context;</span>
<span class="lineNum">    4515 </span>            : 
<span class="lineNum">    4516 </span>            :   /* A function in the user's namespace should have an explicit
<span class="lineNum">    4517 </span>            :      declaration before it is used.  Mark the built-in function as
<span class="lineNum">    4518 </span>            :      anticipated but not actually declared.  */
<span class="lineNum">    4519 </span><span class="lineCov">  115997803 :   if (name[0] != '_' || name[1] != '_')</span>
<span class="lineNum">    4520 </span><span class="lineCov">   79348778 :     DECL_ANTICIPATED (decl) = 1;</span>
<span class="lineNum">    4521 </span><span class="lineCov">   76323414 :   else if (strncmp (name + 2, &quot;builtin_&quot;, strlen (&quot;builtin_&quot;)) != 0)</span>
<span class="lineNum">    4522 </span>            :     {
<span class="lineNum">    4523 </span><span class="lineCov">   13059937 :       size_t len = strlen (name);</span>
<span class="lineNum">    4524 </span>            : 
<span class="lineNum">    4525 </span>            :       /* Treat __*_chk fortification functions as anticipated as well,
<span class="lineNum">    4526 </span>            :          unless they are __builtin_*.  */
<span class="lineNum">    4527 </span><span class="lineCov">   13059937 :       if (len &gt; strlen (&quot;___chk&quot;)</span>
<span class="lineNum">    4528 </span><span class="lineCov">   13059937 :           &amp;&amp; memcmp (name + len - strlen (&quot;_chk&quot;),</span>
<span class="lineNum">    4529 </span>            :                      &quot;_chk&quot;, strlen (&quot;_chk&quot;) + 1) == 0)
<span class="lineNum">    4530 </span><span class="lineCov">    1067940 :         DECL_ANTICIPATED (decl) = 1;</span>
<span class="lineNum">    4531 </span>            :     }
<span class="lineNum">    4532 </span>            : 
<span class="lineNum">    4533 </span><span class="lineCov">  115997803 :   if (is_global)</span>
<span class="lineNum">    4534 </span><span class="lineCov">     358698 :     pushdecl_top_level (decl);</span>
<span class="lineNum">    4535 </span>            :   else
<span class="lineNum">    4536 </span><span class="lineCov">  115639105 :     pushdecl (decl);</span>
<span class="lineNum">    4537 </span>            : 
<span class="lineNum">    4538 </span><span class="lineCov">  115997803 :   return decl;</span>
<span class="lineNum">    4539 </span>            : }
<a name="4540"><span class="lineNum">    4540 </span>            : </a>
<span class="lineNum">    4541 </span>            : tree
<span class="lineNum">    4542 </span><span class="lineCov">   95841176 : cxx_builtin_function (tree decl)</span>
<span class="lineNum">    4543 </span>            : {
<span class="lineNum">    4544 </span><span class="lineCov">   95841176 :   tree          id = DECL_NAME (decl);</span>
<span class="lineNum">    4545 </span><span class="lineCov">   95841176 :   const char *name = IDENTIFIER_POINTER (id);</span>
<span class="lineNum">    4546 </span>            :   /* All builtins that don't begin with an '_' should additionally
<span class="lineNum">    4547 </span>            :      go in the 'std' namespace.  */
<span class="lineNum">    4548 </span><span class="lineCov">   95841176 :   if (name[0] != '_')</span>
<span class="lineNum">    4549 </span>            :     {
<span class="lineNum">    4550 </span><span class="lineCov">   19797929 :       tree decl2 = copy_node(decl);</span>
<span class="lineNum">    4551 </span><span class="lineCov">   19797929 :       push_namespace (std_identifier);</span>
<span class="lineNum">    4552 </span><span class="lineCov">   19797929 :       builtin_function_1 (decl2, std_node, false);</span>
<span class="lineNum">    4553 </span><span class="lineCov">   19797929 :       pop_namespace ();</span>
<span class="lineNum">    4554 </span>            :     }
<span class="lineNum">    4555 </span>            : 
<span class="lineNum">    4556 </span><span class="lineCov">   95841176 :   return builtin_function_1 (decl, NULL_TREE, false);</span>
<span class="lineNum">    4557 </span>            : }
<span class="lineNum">    4558 </span>            : 
<span class="lineNum">    4559 </span>            : /* Like cxx_builtin_function, but guarantee the function is added to the global
<span class="lineNum">    4560 </span>            :    scope.  This is to allow function specific options to add new machine
<span class="lineNum">    4561 </span>            :    dependent builtins when the target ISA changes via attribute((target(...)))
<span class="lineNum">    4562 </span>            :    which saves space on program startup if the program does not use non-generic
<span class="lineNum">    4563 </span>            :    ISAs.  */
<a name="4564"><span class="lineNum">    4564 </span>            : </a>
<span class="lineNum">    4565 </span>            : tree
<span class="lineNum">    4566 </span><span class="lineCov">     358698 : cxx_builtin_function_ext_scope (tree decl)</span>
<span class="lineNum">    4567 </span>            : {
<span class="lineNum">    4568 </span>            : 
<span class="lineNum">    4569 </span><span class="lineCov">     358698 :   tree          id = DECL_NAME (decl);</span>
<span class="lineNum">    4570 </span><span class="lineCov">     358698 :   const char *name = IDENTIFIER_POINTER (id);</span>
<span class="lineNum">    4571 </span>            :   /* All builtins that don't begin with an '_' should additionally
<span class="lineNum">    4572 </span>            :      go in the 'std' namespace.  */
<span class="lineNum">    4573 </span><span class="lineCov">     358698 :   if (name[0] != '_')</span>
<span class="lineNum">    4574 </span>            :     {
<span class="lineNum">    4575 </span><span class="lineNoCov">          0 :       tree decl2 = copy_node(decl);</span>
<span class="lineNum">    4576 </span><span class="lineNoCov">          0 :       push_namespace (std_identifier);</span>
<span class="lineNum">    4577 </span><span class="lineNoCov">          0 :       builtin_function_1 (decl2, std_node, true);</span>
<span class="lineNum">    4578 </span><span class="lineNoCov">          0 :       pop_namespace ();</span>
<span class="lineNum">    4579 </span>            :     }
<span class="lineNum">    4580 </span>            : 
<span class="lineNum">    4581 </span><span class="lineCov">     358698 :   return builtin_function_1 (decl, NULL_TREE, true);</span>
<span class="lineNum">    4582 </span>            : }
<span class="lineNum">    4583 </span>            : 
<span class="lineNum">    4584 </span>            : /* Generate a FUNCTION_DECL with the typical flags for a runtime library
<span class="lineNum">    4585 </span>            :    function.  Not called directly.  */
<a name="4586"><span class="lineNum">    4586 </span>            : </a>
<span class="lineNum">    4587 </span>            : static tree
<span class="lineNum">    4588 </span><span class="lineCov">     554775 : build_library_fn (tree name, enum tree_code operator_code, tree type,</span>
<span class="lineNum">    4589 </span>            :                   int ecf_flags)
<span class="lineNum">    4590 </span>            : {
<span class="lineNum">    4591 </span><span class="lineCov">     554775 :   tree fn = build_lang_decl (FUNCTION_DECL, name, type);</span>
<span class="lineNum">    4592 </span><span class="lineCov">     554775 :   DECL_EXTERNAL (fn) = 1;</span>
<span class="lineNum">    4593 </span><span class="lineCov">     554775 :   TREE_PUBLIC (fn) = 1;</span>
<span class="lineNum">    4594 </span><span class="lineCov">     554775 :   DECL_ARTIFICIAL (fn) = 1;</span>
<span class="lineNum">    4595 </span><span class="lineCov">     554775 :   DECL_OVERLOADED_OPERATOR_CODE_RAW (fn)</span>
<span class="lineNum">    4596 </span><span class="lineCov">     554775 :     = OVL_OP_INFO (false, operator_code)-&gt;ovl_op_code;</span>
<span class="lineNum">    4597 </span><span class="lineCov">     554775 :   SET_DECL_LANGUAGE (fn, lang_c);</span>
<span class="lineNum">    4598 </span>            :   /* Runtime library routines are, by definition, available in an
<span class="lineNum">    4599 </span>            :      external shared object.  */
<span class="lineNum">    4600 </span><span class="lineCov">     554775 :   DECL_VISIBILITY (fn) = VISIBILITY_DEFAULT;</span>
<span class="lineNum">    4601 </span><span class="lineCov">     554775 :   DECL_VISIBILITY_SPECIFIED (fn) = 1;</span>
<span class="lineNum">    4602 </span><span class="lineCov">     554775 :   set_call_expr_flags (fn, ecf_flags);</span>
<span class="lineNum">    4603 </span><span class="lineCov">     554775 :   return fn;</span>
<span class="lineNum">    4604 </span>            : }
<span class="lineNum">    4605 </span>            : 
<span class="lineNum">    4606 </span>            : /* Returns the _DECL for a library function with C++ linkage.  */
<a name="4607"><span class="lineNum">    4607 </span>            : </a>
<span class="lineNum">    4608 </span>            : static tree
<span class="lineNum">    4609 </span><span class="lineCov">     360375 : build_cp_library_fn (tree name, enum tree_code operator_code, tree type,</span>
<span class="lineNum">    4610 </span>            :                      int ecf_flags)
<span class="lineNum">    4611 </span>            : {
<span class="lineNum">    4612 </span><span class="lineCov">     360375 :   tree fn = build_library_fn (name, operator_code, type, ecf_flags);</span>
<span class="lineNum">    4613 </span><span class="lineCov">     360375 :   DECL_CONTEXT (fn) = FROB_CONTEXT (current_namespace);</span>
<span class="lineNum">    4614 </span><span class="lineCov">     360375 :   SET_DECL_LANGUAGE (fn, lang_cplusplus);</span>
<span class="lineNum">    4615 </span><span class="lineCov">     360375 :   return fn;</span>
<span class="lineNum">    4616 </span>            : }
<span class="lineNum">    4617 </span>            : 
<span class="lineNum">    4618 </span>            : /* Like build_library_fn, but takes a C string instead of an
<span class="lineNum">    4619 </span>            :    IDENTIFIER_NODE.  */
<a name="4620"><span class="lineNum">    4620 </span>            : </a>
<span class="lineNum">    4621 </span>            : tree
<span class="lineNum">    4622 </span><span class="lineCov">      65395 : build_library_fn_ptr (const char* name, tree type, int ecf_flags)</span>
<span class="lineNum">    4623 </span>            : {
<span class="lineNum">    4624 </span><span class="lineCov">      65395 :   return build_library_fn (get_identifier (name), ERROR_MARK, type, ecf_flags);</span>
<span class="lineNum">    4625 </span>            : }
<span class="lineNum">    4626 </span>            : 
<span class="lineNum">    4627 </span>            : /* Like build_cp_library_fn, but takes a C string instead of an
<span class="lineNum">    4628 </span>            :    IDENTIFIER_NODE.  */
<a name="4629"><span class="lineNum">    4629 </span>            : </a>
<span class="lineNum">    4630 </span>            : tree
<span class="lineNum">    4631 </span><span class="lineCov">      57027 : build_cp_library_fn_ptr (const char* name, tree type, int ecf_flags)</span>
<span class="lineNum">    4632 </span>            : {
<span class="lineNum">    4633 </span><span class="lineCov">      57027 :   return build_cp_library_fn (get_identifier (name), ERROR_MARK, type,</span>
<span class="lineNum">    4634 </span><span class="lineCov">      57027 :                               ecf_flags);</span>
<span class="lineNum">    4635 </span>            : }
<span class="lineNum">    4636 </span>            : 
<span class="lineNum">    4637 </span>            : /* Like build_library_fn, but also pushes the function so that we will
<span class="lineNum">    4638 </span>            :    be able to find it via get_global_binding.  Also, the function
<span class="lineNum">    4639 </span>            :    may throw exceptions listed in RAISES.  */
<a name="4640"><span class="lineNum">    4640 </span>            : </a>
<span class="lineNum">    4641 </span>            : tree
<span class="lineNum">    4642 </span><span class="lineCov">     129005 : push_library_fn (tree name, tree type, tree raises, int ecf_flags)</span>
<span class="lineNum">    4643 </span>            : {
<span class="lineNum">    4644 </span><span class="lineCov">     129005 :   tree fn;</span>
<span class="lineNum">    4645 </span>            : 
<span class="lineNum">    4646 </span><span class="lineCov">     129005 :   if (raises)</span>
<span class="lineNum">    4647 </span><span class="lineCov">       7304 :     type = build_exception_variant (type, raises);</span>
<span class="lineNum">    4648 </span>            : 
<span class="lineNum">    4649 </span><span class="lineCov">     129005 :   fn = build_library_fn (name, ERROR_MARK, type, ecf_flags);</span>
<span class="lineNum">    4650 </span><span class="lineCov">     129005 :   pushdecl_top_level (fn);</span>
<span class="lineNum">    4651 </span><span class="lineCov">     129005 :   return fn;</span>
<span class="lineNum">    4652 </span>            : }
<span class="lineNum">    4653 </span>            : 
<span class="lineNum">    4654 </span>            : /* Like build_cp_library_fn, but also pushes the function so that it
<span class="lineNum">    4655 </span>            :    will be found by normal lookup.  */
<a name="4656"><span class="lineNum">    4656 </span>            : </a>
<span class="lineNum">    4657 </span>            : static tree
<span class="lineNum">    4658 </span><span class="lineCov">     303348 : push_cp_library_fn (enum tree_code operator_code, tree type,</span>
<span class="lineNum">    4659 </span>            :                     int ecf_flags)
<span class="lineNum">    4660 </span>            : {
<span class="lineNum">    4661 </span><span class="lineCov">     303348 :   tree fn = build_cp_library_fn (ovl_op_identifier (false, operator_code),</span>
<span class="lineNum">    4662 </span>            :                                  operator_code, type, ecf_flags);
<span class="lineNum">    4663 </span><span class="lineCov">     303348 :   pushdecl (fn);</span>
<span class="lineNum">    4664 </span><span class="lineCov">     303348 :   if (flag_tm)</span>
<span class="lineNum">    4665 </span><span class="lineCov">       1326 :     apply_tm_attr (fn, get_identifier (&quot;transaction_safe&quot;));</span>
<span class="lineNum">    4666 </span><span class="lineCov">     303348 :   return fn;</span>
<span class="lineNum">    4667 </span>            : }
<span class="lineNum">    4668 </span>            : 
<span class="lineNum">    4669 </span>            : /* Like push_library_fn, but takes a TREE_LIST of parm types rather than
<span class="lineNum">    4670 </span>            :    a FUNCTION_TYPE.  */
<a name="4671"><span class="lineNum">    4671 </span>            : </a>
<span class="lineNum">    4672 </span>            : tree
<span class="lineNum">    4673 </span><span class="lineNoCov">          0 : push_void_library_fn (tree name, tree parmtypes, int ecf_flags)</span>
<span class="lineNum">    4674 </span>            : {
<span class="lineNum">    4675 </span><span class="lineNoCov">          0 :   tree type = build_function_type (void_type_node, parmtypes);</span>
<span class="lineNum">    4676 </span><span class="lineNoCov">          0 :   return push_library_fn (name, type, NULL_TREE, ecf_flags);</span>
<span class="lineNum">    4677 </span>            : }
<span class="lineNum">    4678 </span>            : 
<span class="lineNum">    4679 </span>            : /* Like push_library_fn, but also note that this function throws
<span class="lineNum">    4680 </span>            :    and does not return.  Used for __throw_foo and the like.  */
<a name="4681"><span class="lineNum">    4681 </span>            : </a>
<span class="lineNum">    4682 </span>            : tree
<span class="lineNum">    4683 </span><span class="lineCov">      67910 : push_throw_library_fn (tree name, tree type)</span>
<span class="lineNum">    4684 </span>            : {
<span class="lineNum">    4685 </span><span class="lineCov">      67910 :   tree fn = push_library_fn (name, type, NULL_TREE, ECF_NORETURN | ECF_COLD);</span>
<span class="lineNum">    4686 </span><span class="lineCov">      67910 :   return fn;</span>
<span class="lineNum">    4687 </span>            : }
<span class="lineNum">    4688 </span>            : 
<span class="lineNum">    4689 </span>            : /* When we call finish_struct for an anonymous union, we create
<span class="lineNum">    4690 </span>            :    default copy constructors and such.  But, an anonymous union
<span class="lineNum">    4691 </span>            :    shouldn't have such things; this function undoes the damage to the
<span class="lineNum">    4692 </span>            :    anonymous union type T.
<span class="lineNum">    4693 </span>            : 
<span class="lineNum">    4694 </span>            :    (The reason that we create the synthesized methods is that we don't
<span class="lineNum">    4695 </span>            :    distinguish `union { int i; }' from `typedef union { int i; } U'.
<span class="lineNum">    4696 </span>            :    The first is an anonymous union; the second is just an ordinary
<span class="lineNum">    4697 </span>            :    union type.)  */
<a name="4698"><span class="lineNum">    4698 </span>            : </a>
<span class="lineNum">    4699 </span>            : void
<span class="lineNum">    4700 </span><span class="lineCov">      12933 : fixup_anonymous_aggr (tree t)</span>
<span class="lineNum">    4701 </span>            : {
<span class="lineNum">    4702 </span>            :   /* Wipe out memory of synthesized methods.  */
<span class="lineNum">    4703 </span><span class="lineCov">      12933 :   TYPE_HAS_USER_CONSTRUCTOR (t) = 0;</span>
<span class="lineNum">    4704 </span><span class="lineCov">      12933 :   TYPE_HAS_DEFAULT_CONSTRUCTOR (t) = 0;</span>
<span class="lineNum">    4705 </span><span class="lineCov">      12933 :   TYPE_HAS_COPY_CTOR (t) = 0;</span>
<span class="lineNum">    4706 </span><span class="lineCov">      12933 :   TYPE_HAS_CONST_COPY_CTOR (t) = 0;</span>
<span class="lineNum">    4707 </span><span class="lineCov">      12933 :   TYPE_HAS_COPY_ASSIGN (t) = 0;</span>
<span class="lineNum">    4708 </span><span class="lineCov">      12933 :   TYPE_HAS_CONST_COPY_ASSIGN (t) = 0;</span>
<span class="lineNum">    4709 </span>            : 
<span class="lineNum">    4710 </span>            :   /* Splice the implicitly generated functions out of TYPE_FIELDS.  */
<span class="lineNum">    4711 </span><span class="lineCov">      71147 :   for (tree probe, *prev_p = &amp;TYPE_FIELDS (t); (probe = *prev_p);)</span>
<span class="lineNum">    4712 </span><span class="lineCov">      45546 :     if (TREE_CODE (probe) == FUNCTION_DECL &amp;&amp; DECL_ARTIFICIAL (probe))</span>
<span class="lineNum">    4713 </span><span class="lineNoCov">          0 :       *prev_p = DECL_CHAIN (probe);</span>
<span class="lineNum">    4714 </span>            :     else
<span class="lineNum">    4715 </span><span class="lineCov">      45546 :       prev_p = &amp;DECL_CHAIN (probe);</span>
<span class="lineNum">    4716 </span>            : 
<span class="lineNum">    4717 </span>            :   /* Anonymous aggregates cannot have fields with ctors, dtors or complex
<span class="lineNum">    4718 </span>            :      assignment operators (because they cannot have these methods themselves).
<span class="lineNum">    4719 </span>            :      For anonymous unions this is already checked because they are not allowed
<span class="lineNum">    4720 </span>            :      in any union, otherwise we have to check it.  */
<span class="lineNum">    4721 </span><span class="lineCov">      12933 :   if (TREE_CODE (t) != UNION_TYPE)</span>
<span class="lineNum">    4722 </span>            :     {
<span class="lineNum">    4723 </span><span class="lineCov">        265 :       tree field, type;</span>
<span class="lineNum">    4724 </span>            : 
<span class="lineNum">    4725 </span><span class="lineCov">       1005 :       for (field = TYPE_FIELDS (t); field; field = DECL_CHAIN (field))</span>
<span class="lineNum">    4726 </span><span class="lineCov">        740 :         if (TREE_CODE (field) == FIELD_DECL)</span>
<span class="lineNum">    4727 </span>            :           {
<span class="lineNum">    4728 </span><span class="lineCov">        419 :             type = TREE_TYPE (field);</span>
<span class="lineNum">    4729 </span><span class="lineCov">        419 :             if (CLASS_TYPE_P (type))</span>
<span class="lineNum">    4730 </span>            :               {
<span class="lineNum">    4731 </span><span class="lineCov">         78 :                 if (TYPE_NEEDS_CONSTRUCTING (type))</span>
<span class="lineNum">    4732 </span><span class="lineCov">          3 :                   error (&quot;member %q+#D with constructor not allowed &quot;</span>
<span class="lineNum">    4733 </span>            :                          &quot;in anonymous aggregate&quot;, field);
<span class="lineNum">    4734 </span><span class="lineCov">         39 :                 if (TYPE_HAS_NONTRIVIAL_DESTRUCTOR (type))</span>
<span class="lineNum">    4735 </span><span class="lineNoCov">          0 :                   error (&quot;member %q+#D with destructor not allowed &quot;</span>
<span class="lineNum">    4736 </span>            :                          &quot;in anonymous aggregate&quot;, field);
<span class="lineNum">    4737 </span><span class="lineCov">         39 :                 if (TYPE_HAS_COMPLEX_COPY_ASSIGN (type))</span>
<span class="lineNum">    4738 </span><span class="lineNoCov">          0 :                   error (&quot;member %q+#D with copy assignment operator &quot;</span>
<span class="lineNum">    4739 </span>            :                          &quot;not allowed in anonymous aggregate&quot;, field);
<span class="lineNum">    4740 </span>            :               }
<span class="lineNum">    4741 </span>            :           }
<span class="lineNum">    4742 </span>            :     }
<span class="lineNum">    4743 </span><span class="lineCov">      12933 : }</span>
<span class="lineNum">    4744 </span>            : 
<span class="lineNum">    4745 </span>            : /* Warn for an attribute located at LOCATION that appertains to the
<span class="lineNum">    4746 </span>            :    class type CLASS_TYPE that has not been properly placed after its
<span class="lineNum">    4747 </span>            :    class-key, in it class-specifier.  */
<a name="4748"><span class="lineNum">    4748 </span>            : </a>
<span class="lineNum">    4749 </span>            : void
<span class="lineNum">    4750 </span><span class="lineCov">         14 : warn_misplaced_attr_for_class_type (source_location location,</span>
<span class="lineNum">    4751 </span>            :                                     tree class_type)
<span class="lineNum">    4752 </span>            : {
<span class="lineNum">    4753 </span><span class="lineCov">         14 :   gcc_assert (OVERLOAD_TYPE_P (class_type));</span>
<span class="lineNum">    4754 </span>            : 
<span class="lineNum">    4755 </span><span class="lineCov">         28 :   auto_diagnostic_group d;</span>
<span class="lineNum">    4756 </span><span class="lineCov">         14 :   if (warning_at (location, OPT_Wattributes,</span>
<span class="lineNum">    4757 </span>            :                   &quot;attribute ignored in declaration &quot;
<span class="lineNum">    4758 </span>            :                   &quot;of %q#T&quot;, class_type))
<span class="lineNum">    4759 </span><span class="lineCov">         14 :     inform (location,</span>
<span class="lineNum">    4760 </span>            :             &quot;attribute for %q#T must follow the %qs keyword&quot;,
<span class="lineNum">    4761 </span>            :             class_type, class_key_or_enum_as_string (class_type));
<span class="lineNum">    4762 </span><span class="lineCov">         14 : }</span>
<span class="lineNum">    4763 </span>            : 
<span class="lineNum">    4764 </span>            : /* Make sure that a declaration with no declarator is well-formed, i.e.
<span class="lineNum">    4765 </span>            :    just declares a tagged type or anonymous union.
<span class="lineNum">    4766 </span>            : 
<span class="lineNum">    4767 </span>            :    Returns the type declared; or NULL_TREE if none.  */
<a name="4768"><span class="lineNum">    4768 </span>            : </a>
<span class="lineNum">    4769 </span>            : tree
<span class="lineNum">    4770 </span><span class="lineCov">    2920046 : check_tag_decl (cp_decl_specifier_seq *declspecs,</span>
<span class="lineNum">    4771 </span>            :                 bool explicit_type_instantiation_p)
<span class="lineNum">    4772 </span>            : {
<span class="lineNum">    4773 </span><span class="lineCov">    2920046 :   int saw_friend = decl_spec_seq_has_spec_p (declspecs, ds_friend);</span>
<span class="lineNum">    4774 </span><span class="lineCov">    2920046 :   int saw_typedef = decl_spec_seq_has_spec_p (declspecs, ds_typedef);</span>
<span class="lineNum">    4775 </span>            :   /* If a class, struct, or enum type is declared by the DECLSPECS
<span class="lineNum">    4776 </span>            :      (i.e, if a class-specifier, enum-specifier, or non-typename
<span class="lineNum">    4777 </span>            :      elaborated-type-specifier appears in the DECLSPECS),
<span class="lineNum">    4778 </span>            :      DECLARED_TYPE is set to the corresponding type.  */
<span class="lineNum">    4779 </span><span class="lineCov">    2920046 :   tree declared_type = NULL_TREE;</span>
<span class="lineNum">    4780 </span><span class="lineCov">    2920046 :   bool error_p = false;</span>
<span class="lineNum">    4781 </span>            : 
<span class="lineNum">    4782 </span><span class="lineCov">    2920046 :   if (declspecs-&gt;multiple_types_p)</span>
<span class="lineNum">    4783 </span><span class="lineCov">         17 :     error (&quot;multiple types in one declaration&quot;);</span>
<span class="lineNum">    4784 </span><span class="lineCov">    2920029 :   else if (declspecs-&gt;redefined_builtin_type)</span>
<span class="lineNum">    4785 </span>            :     {
<span class="lineNum">    4786 </span><span class="lineCov">         13 :       if (!in_system_header_at (input_location))</span>
<span class="lineNum">    4787 </span><span class="lineCov">          4 :         permerror (declspecs-&gt;locations[ds_redefined_builtin_type_spec],</span>
<span class="lineNum">    4788 </span>            :                    &quot;redeclaration of C++ built-in type %qT&quot;,
<span class="lineNum">    4789 </span>            :                    declspecs-&gt;redefined_builtin_type);
<span class="lineNum">    4790 </span><span class="lineCov">         13 :       return NULL_TREE;</span>
<span class="lineNum">    4791 </span>            :     }
<span class="lineNum">    4792 </span>            : 
<span class="lineNum">    4793 </span><span class="lineCov">    2920033 :   if (declspecs-&gt;type</span>
<span class="lineNum">    4794 </span><span class="lineCov">    2920021 :       &amp;&amp; TYPE_P (declspecs-&gt;type)</span>
<span class="lineNum">    4795 </span><span class="lineCov">    5838923 :       &amp;&amp; ((TREE_CODE (declspecs-&gt;type) != TYPENAME_TYPE</span>
<span class="lineNum">    4796 </span><span class="lineCov">    2918815 :            &amp;&amp; MAYBE_CLASS_TYPE_P (declspecs-&gt;type))</span>
<span class="lineNum">    4797 </span><span class="lineCov">     167320 :           || TREE_CODE (declspecs-&gt;type) == ENUMERAL_TYPE))</span>
<span class="lineNum">    4798 </span>            :     declared_type = declspecs-&gt;type;
<span class="lineNum">    4799 </span><span class="lineCov">       1236 :   else if (declspecs-&gt;type == error_mark_node)</span>
<span class="lineNum">    4800 </span><span class="lineCov">        581 :     error_p = true;</span>
<span class="lineNum">    4801 </span><span class="lineCov">    2920033 :   if (declared_type == NULL_TREE &amp;&amp; ! saw_friend &amp;&amp; !error_p)</span>
<span class="lineNum">    4802 </span><span class="lineCov">         63 :     permerror (input_location, &quot;declaration does not declare anything&quot;);</span>
<span class="lineNum">    4803 </span><span class="lineCov">    2919970 :   else if (declared_type != NULL_TREE &amp;&amp; type_uses_auto (declared_type))</span>
<span class="lineNum">    4804 </span>            :     {
<span class="lineNum">    4805 </span><span class="lineCov">          6 :       error_at (declspecs-&gt;locations[ds_type_spec],</span>
<span class="lineNum">    4806 </span>            :                 &quot;%&lt;auto%&gt; can only be specified for variables &quot;
<span class="lineNum">    4807 </span>            :                 &quot;or function declarations&quot;);
<span class="lineNum">    4808 </span><span class="lineCov">          6 :       return error_mark_node;</span>
<span class="lineNum">    4809 </span>            :     }
<span class="lineNum">    4810 </span>            :   /* Check for an anonymous union.  */
<span class="lineNum">    4811 </span><span class="lineCov">    2918791 :   else if (declared_type &amp;&amp; RECORD_OR_UNION_CODE_P (TREE_CODE (declared_type))</span>
<span class="lineNum">    4812 </span><span class="lineCov">    5671517 :            &amp;&amp; TYPE_UNNAMED_P (declared_type))</span>
<span class="lineNum">    4813 </span>            :     {
<span class="lineNum">    4814 </span>            :       /* 7/3 In a simple-declaration, the optional init-declarator-list
<span class="lineNum">    4815 </span>            :          can be omitted only when declaring a class (clause 9) or
<span class="lineNum">    4816 </span>            :          enumeration (7.2), that is, when the decl-specifier-seq contains
<span class="lineNum">    4817 </span>            :          either a class-specifier, an elaborated-type-specifier with
<span class="lineNum">    4818 </span>            :          a class-key (9.1), or an enum-specifier.  In these cases and
<span class="lineNum">    4819 </span>            :          whenever a class-specifier or enum-specifier is present in the
<span class="lineNum">    4820 </span>            :          decl-specifier-seq, the identifiers in these specifiers are among
<span class="lineNum">    4821 </span>            :          the names being declared by the declaration (as class-name,
<span class="lineNum">    4822 </span>            :          enum-names, or enumerators, depending on the syntax).  In such
<span class="lineNum">    4823 </span>            :          cases, and except for the declaration of an unnamed bit-field (9.6),
<span class="lineNum">    4824 </span>            :          the decl-specifier-seq shall introduce one or more names into the
<span class="lineNum">    4825 </span>            :          program, or shall redeclare a name introduced by a previous
<span class="lineNum">    4826 </span>            :          declaration.  [Example:
<span class="lineNum">    4827 </span>            :              enum { };                  // ill-formed
<span class="lineNum">    4828 </span>            :              typedef class { };         // ill-formed
<span class="lineNum">    4829 </span>            :          --end example]  */
<span class="lineNum">    4830 </span><span class="lineCov">      12939 :       if (saw_typedef)</span>
<span class="lineNum">    4831 </span>            :         {
<span class="lineNum">    4832 </span><span class="lineCov">          6 :           error (&quot;missing type-name in typedef-declaration&quot;);</span>
<span class="lineNum">    4833 </span><span class="lineCov">          6 :           return NULL_TREE;</span>
<span class="lineNum">    4834 </span>            :         }
<span class="lineNum">    4835 </span><span class="lineCov">      12933 :       /* Anonymous unions are objects, so they can have specifiers.  */;</span>
<span class="lineNum">    4836 </span><span class="lineCov">      12933 :       SET_ANON_AGGR_TYPE_P (declared_type);</span>
<span class="lineNum">    4837 </span>            : 
<span class="lineNum">    4838 </span><span class="lineCov">      12933 :       if (TREE_CODE (declared_type) != UNION_TYPE</span>
<span class="lineNum">    4839 </span><span class="lineCov">      12933 :           &amp;&amp; !in_system_header_at (input_location))</span>
<span class="lineNum">    4840 </span><span class="lineCov">        210 :         pedwarn (input_location, OPT_Wpedantic, &quot;ISO C++ prohibits anonymous structs&quot;);</span>
<span class="lineNum">    4841 </span>            :     }
<span class="lineNum">    4842 </span>            : 
<span class="lineNum">    4843 </span>            :   else
<span class="lineNum">    4844 </span>            :     {
<span class="lineNum">    4845 </span><span class="lineCov">    2907025 :       if (decl_spec_seq_has_spec_p (declspecs, ds_inline))</span>
<span class="lineNum">    4846 </span><span class="lineCov">          8 :         error_at (declspecs-&gt;locations[ds_inline],</span>
<span class="lineNum">    4847 </span>            :                   &quot;%&lt;inline%&gt; can only be specified for functions&quot;);
<span class="lineNum">    4848 </span><span class="lineCov">    2907017 :       else if (decl_spec_seq_has_spec_p (declspecs, ds_virtual))</span>
<span class="lineNum">    4849 </span><span class="lineCov">          2 :         error_at (declspecs-&gt;locations[ds_virtual],</span>
<span class="lineNum">    4850 </span>            :                   &quot;%&lt;virtual%&gt; can only be specified for functions&quot;);
<span class="lineNum">    4851 </span><span class="lineCov">    2907015 :       else if (saw_friend</span>
<span class="lineNum">    4852 </span><span class="lineCov">    2907015 :                &amp;&amp; (!current_class_type</span>
<span class="lineNum">    4853 </span><span class="lineCov">      44418 :                    || current_scope () != current_class_type))</span>
<span class="lineNum">    4854 </span><span class="lineNoCov">          0 :         error_at (declspecs-&gt;locations[ds_friend],</span>
<span class="lineNum">    4855 </span>            :                   &quot;%&lt;friend%&gt; can only be specified inside a class&quot;);
<span class="lineNum">    4856 </span><span class="lineCov">    2907015 :       else if (decl_spec_seq_has_spec_p (declspecs, ds_explicit))</span>
<span class="lineNum">    4857 </span><span class="lineCov">          2 :         error_at (declspecs-&gt;locations[ds_explicit],</span>
<span class="lineNum">    4858 </span>            :                   &quot;%&lt;explicit%&gt; can only be specified for constructors&quot;);
<span class="lineNum">    4859 </span><span class="lineCov">    2907013 :       else if (declspecs-&gt;storage_class)</span>
<span class="lineNum">    4860 </span><span class="lineCov">          2 :         error_at (declspecs-&gt;locations[ds_storage_class],</span>
<span class="lineNum">    4861 </span>            :                   &quot;a storage class can only be specified for objects &quot;
<span class="lineNum">    4862 </span>            :                   &quot;and functions&quot;);
<span class="lineNum">    4863 </span><span class="lineCov">    2907011 :       else if (decl_spec_seq_has_spec_p (declspecs, ds_const))</span>
<span class="lineNum">    4864 </span><span class="lineCov">          8 :         error_at (declspecs-&gt;locations[ds_const],</span>
<span class="lineNum">    4865 </span>            :                   &quot;%&lt;const%&gt; can only be specified for objects and &quot;
<span class="lineNum">    4866 </span>            :                   &quot;functions&quot;);
<span class="lineNum">    4867 </span><span class="lineCov">    2907003 :       else if (decl_spec_seq_has_spec_p (declspecs, ds_volatile))</span>
<span class="lineNum">    4868 </span><span class="lineCov">          2 :         error_at (declspecs-&gt;locations[ds_volatile],</span>
<span class="lineNum">    4869 </span>            :                   &quot;%&lt;volatile%&gt; can only be specified for objects and &quot;
<span class="lineNum">    4870 </span>            :                   &quot;functions&quot;);
<span class="lineNum">    4871 </span><span class="lineCov">    2907001 :       else if (decl_spec_seq_has_spec_p (declspecs, ds_restrict))</span>
<span class="lineNum">    4872 </span><span class="lineCov">          2 :         error_at (declspecs-&gt;locations[ds_restrict],</span>
<span class="lineNum">    4873 </span>            :                   &quot;%&lt;__restrict%&gt; can only be specified for objects and &quot;
<span class="lineNum">    4874 </span>            :                   &quot;functions&quot;);
<span class="lineNum">    4875 </span><span class="lineCov">    2906999 :       else if (decl_spec_seq_has_spec_p (declspecs, ds_thread))</span>
<span class="lineNum">    4876 </span><span class="lineCov">          2 :         error_at (declspecs-&gt;locations[ds_thread],</span>
<span class="lineNum">    4877 </span>            :                   &quot;%&lt;__thread%&gt; can only be specified for objects &quot;
<span class="lineNum">    4878 </span>            :                   &quot;and functions&quot;);
<span class="lineNum">    4879 </span><span class="lineCov">    2906997 :       else if (saw_typedef)</span>
<span class="lineNum">    4880 </span><span class="lineCov">         23 :         warning_at (declspecs-&gt;locations[ds_typedef], 0,</span>
<span class="lineNum">    4881 </span>            :                     &quot;%&lt;typedef%&gt; was ignored in this declaration&quot;);
<span class="lineNum">    4882 </span><span class="lineCov">    2906974 :       else if (decl_spec_seq_has_spec_p (declspecs,  ds_constexpr))</span>
<span class="lineNum">    4883 </span><span class="lineCov">          6 :         error_at (declspecs-&gt;locations[ds_constexpr],</span>
<span class="lineNum">    4884 </span>            :                   &quot;%&lt;constexpr%&gt; cannot be used for type declarations&quot;);
<span class="lineNum">    4885 </span>            :     }
<span class="lineNum">    4886 </span>            : 
<span class="lineNum">    4887 </span><span class="lineCov">    2920021 :   if (declspecs-&gt;attributes &amp;&amp; warn_attributes &amp;&amp; declared_type)</span>
<span class="lineNum">    4888 </span>            :     {
<span class="lineNum">    4889 </span><span class="lineCov">         15 :       location_t loc;</span>
<span class="lineNum">    4890 </span><span class="lineCov">         10 :       if (!CLASS_TYPE_P (declared_type)</span>
<span class="lineNum">    4891 </span><span class="lineCov">         35 :           || !CLASSTYPE_TEMPLATE_INSTANTIATION (declared_type))</span>
<span class="lineNum">    4892 </span>            :         /* For a non-template class, use the name location.  */
<span class="lineNum">    4893 </span><span class="lineCov">         10 :         loc = location_of (declared_type);</span>
<span class="lineNum">    4894 </span>            :       else
<span class="lineNum">    4895 </span>            :         /* For a template class (an explicit instantiation), use the
<span class="lineNum">    4896 </span>            :            current location.  */
<span class="lineNum">    4897 </span><span class="lineCov">          5 :         loc = input_location;</span>
<span class="lineNum">    4898 </span>            : 
<span class="lineNum">    4899 </span><span class="lineCov">         15 :       if (explicit_type_instantiation_p)</span>
<span class="lineNum">    4900 </span>            :         /* [dcl.attr.grammar]/4:
<span class="lineNum">    4901 </span>            : 
<span class="lineNum">    4902 </span>            :                No attribute-specifier-seq shall appertain to an explicit
<span class="lineNum">    4903 </span>            :                instantiation.  */
<span class="lineNum">    4904 </span>            :         {
<span class="lineNum">    4905 </span><span class="lineCov">          5 :           if (warning_at (loc, OPT_Wattributes,</span>
<span class="lineNum">    4906 </span>            :                           &quot;attribute ignored in explicit instantiation %q#T&quot;,
<span class="lineNum">    4907 </span>            :                           declared_type))
<span class="lineNum">    4908 </span><span class="lineCov">          5 :             inform (loc,</span>
<span class="lineNum">    4909 </span>            :                     &quot;no attribute can be applied to &quot;
<span class="lineNum">    4910 </span>            :                     &quot;an explicit instantiation&quot;);
<span class="lineNum">    4911 </span>            :         }
<span class="lineNum">    4912 </span>            :       else
<span class="lineNum">    4913 </span><span class="lineCov">         10 :         warn_misplaced_attr_for_class_type (loc, declared_type);</span>
<span class="lineNum">    4914 </span>            :     }
<span class="lineNum">    4915 </span>            : 
<span class="lineNum">    4916 </span>            :   return declared_type;
<span class="lineNum">    4917 </span>            : }
<span class="lineNum">    4918 </span>            : 
<span class="lineNum">    4919 </span>            : /* Called when a declaration is seen that contains no names to declare.
<span class="lineNum">    4920 </span>            :    If its type is a reference to a structure, union or enum inherited
<span class="lineNum">    4921 </span>            :    from a containing scope, shadow that tag name for the current scope
<span class="lineNum">    4922 </span>            :    with a forward reference.
<span class="lineNum">    4923 </span>            :    If its type defines a new named structure or union
<span class="lineNum">    4924 </span>            :    or defines an enum, it is valid but we need not do anything here.
<span class="lineNum">    4925 </span>            :    Otherwise, it is an error.
<span class="lineNum">    4926 </span>            : 
<span class="lineNum">    4927 </span>            :    C++: may have to grok the declspecs to learn about static,
<span class="lineNum">    4928 </span>            :    complain for anonymous unions.
<span class="lineNum">    4929 </span>            : 
<span class="lineNum">    4930 </span>            :    Returns the TYPE declared -- or NULL_TREE if none.  */
<a name="4931"><span class="lineNum">    4931 </span>            : </a>
<span class="lineNum">    4932 </span>            : tree
<span class="lineNum">    4933 </span><span class="lineCov">    2686492 : shadow_tag (cp_decl_specifier_seq *declspecs)</span>
<span class="lineNum">    4934 </span>            : {
<span class="lineNum">    4935 </span><span class="lineCov">    2686492 :   tree t = check_tag_decl (declspecs,</span>
<span class="lineNum">    4936 </span><span class="lineCov">    2686492 :                            /*explicit_type_instantiation_p=*/false);</span>
<span class="lineNum">    4937 </span>            : 
<span class="lineNum">    4938 </span><span class="lineCov">    2686492 :   if (!t)</span>
<span class="lineNum">    4939 </span>            :     return NULL_TREE;
<span class="lineNum">    4940 </span>            : 
<span class="lineNum">    4941 </span><span class="lineCov">    2685919 :   if (maybe_process_partial_specialization (t) == error_mark_node)</span>
<span class="lineNum">    4942 </span>            :     return NULL_TREE;
<span class="lineNum">    4943 </span>            : 
<span class="lineNum">    4944 </span>            :   /* This is where the variables in an anonymous union are
<span class="lineNum">    4945 </span>            :      declared.  An anonymous union declaration looks like:
<span class="lineNum">    4946 </span>            :      union { ... } ;
<span class="lineNum">    4947 </span>            :      because there is no declarator after the union, the parser
<span class="lineNum">    4948 </span>            :      sends that declaration here.  */
<span class="lineNum">    4949 </span><span class="lineCov">    2684977 :   if (ANON_AGGR_TYPE_P (t))</span>
<span class="lineNum">    4950 </span>            :     {
<span class="lineNum">    4951 </span><span class="lineCov">        227 :       fixup_anonymous_aggr (t);</span>
<span class="lineNum">    4952 </span>            : 
<span class="lineNum">    4953 </span><span class="lineCov">        448 :       if (TYPE_FIELDS (t))</span>
<span class="lineNum">    4954 </span>            :         {
<span class="lineNum">    4955 </span><span class="lineCov">        227 :           tree decl = grokdeclarator (/*declarator=*/NULL,</span>
<span class="lineNum">    4956 </span>            :                                       declspecs, NORMAL, 0, NULL);
<span class="lineNum">    4957 </span><span class="lineCov">        227 :           finish_anon_union (decl);</span>
<span class="lineNum">    4958 </span>            :         }
<span class="lineNum">    4959 </span>            :     }
<span class="lineNum">    4960 </span>            : 
<span class="lineNum">    4961 </span>            :   return t;
<span class="lineNum">    4962 </span>            : }
<span class="lineNum">    4963 </span>            : 
<span class="lineNum">    4964 </span>            : /* Decode a &quot;typename&quot;, such as &quot;int **&quot;, returning a ..._TYPE node.  */
<a name="4965"><span class="lineNum">    4965 </span>            : </a>
<span class="lineNum">    4966 </span>            : tree
<span class="lineNum">    4967 </span><span class="lineCov">   16626584 : groktypename (cp_decl_specifier_seq *type_specifiers,</span>
<span class="lineNum">    4968 </span>            :               const cp_declarator *declarator,
<span class="lineNum">    4969 </span>            :               bool is_template_arg)
<span class="lineNum">    4970 </span>            : {
<span class="lineNum">    4971 </span><span class="lineCov">   16626584 :   tree attrs;</span>
<span class="lineNum">    4972 </span><span class="lineCov">   16626584 :   tree type;</span>
<span class="lineNum">    4973 </span><span class="lineCov">   33253168 :   enum decl_context context</span>
<span class="lineNum">    4974 </span><span class="lineCov">   16626584 :     = is_template_arg ? TEMPLATE_TYPE_ARG : TYPENAME;</span>
<span class="lineNum">    4975 </span><span class="lineCov">   16626584 :   attrs = type_specifiers-&gt;attributes;</span>
<span class="lineNum">    4976 </span><span class="lineCov">   16626584 :   type_specifiers-&gt;attributes = NULL_TREE;</span>
<span class="lineNum">    4977 </span><span class="lineCov">   16626584 :   type = grokdeclarator (declarator, type_specifiers, context, 0, &amp;attrs);</span>
<span class="lineNum">    4978 </span><span class="lineCov">   16626584 :   if (attrs &amp;&amp; type != error_mark_node)</span>
<span class="lineNum">    4979 </span>            :     {
<span class="lineNum">    4980 </span><span class="lineCov">        482 :       if (CLASS_TYPE_P (type))</span>
<span class="lineNum">    4981 </span><span class="lineCov">          5 :         warning (OPT_Wattributes, &quot;ignoring attributes applied to class type %qT &quot;</span>
<span class="lineNum">    4982 </span>            :                  &quot;outside of definition&quot;, type);
<span class="lineNum">    4983 </span><span class="lineCov">        477 :       else if (MAYBE_CLASS_TYPE_P (type))</span>
<span class="lineNum">    4984 </span>            :         /* A template type parameter or other dependent type.  */
<span class="lineNum">    4985 </span><span class="lineCov">          3 :         warning (OPT_Wattributes, &quot;ignoring attributes applied to dependent &quot;</span>
<span class="lineNum">    4986 </span>            :                  &quot;type %qT without an associated declaration&quot;, type);
<span class="lineNum">    4987 </span>            :       else
<span class="lineNum">    4988 </span><span class="lineCov">        474 :         cplus_decl_attributes (&amp;type, attrs, 0);</span>
<span class="lineNum">    4989 </span>            :     }
<span class="lineNum">    4990 </span><span class="lineCov">   16626584 :   return type;</span>
<span class="lineNum">    4991 </span>            : }
<span class="lineNum">    4992 </span>            : 
<span class="lineNum">    4993 </span>            : /* Process a DECLARATOR for a function-scope variable declaration,
<span class="lineNum">    4994 </span>            :    namespace-scope variable declaration, or function declaration.
<span class="lineNum">    4995 </span>            :    (Function definitions go through start_function; class member
<span class="lineNum">    4996 </span>            :    declarations appearing in the body of the class go through
<span class="lineNum">    4997 </span>            :    grokfield.)  The DECL corresponding to the DECLARATOR is returned.
<span class="lineNum">    4998 </span>            :    If an error occurs, the error_mark_node is returned instead.
<span class="lineNum">    4999 </span>            :    
<span class="lineNum">    5000 </span>            :    DECLSPECS are the decl-specifiers for the declaration.  INITIALIZED is
<span class="lineNum">    5001 </span>            :    SD_INITIALIZED if an explicit initializer is present, or SD_DEFAULTED
<span class="lineNum">    5002 </span>            :    for an explicitly defaulted function, or SD_DELETED for an explicitly
<span class="lineNum">    5003 </span>            :    deleted function, but 0 (SD_UNINITIALIZED) if this is a variable
<span class="lineNum">    5004 </span>            :    implicitly initialized via a default constructor.  ATTRIBUTES and
<span class="lineNum">    5005 </span>            :    PREFIX_ATTRIBUTES are GNU attributes associated with this declaration.
<span class="lineNum">    5006 </span>            : 
<span class="lineNum">    5007 </span>            :    The scope represented by the context of the returned DECL is pushed
<span class="lineNum">    5008 </span>            :    (if it is not the global namespace) and is assigned to
<span class="lineNum">    5009 </span>            :    *PUSHED_SCOPE_P.  The caller is then responsible for calling
<span class="lineNum">    5010 </span>            :    pop_scope on *PUSHED_SCOPE_P if it is set.  */
<a name="5011"><span class="lineNum">    5011 </span>            : </a>
<span class="lineNum">    5012 </span>            : tree
<span class="lineNum">    5013 </span><span class="lineCov">    7010511 : start_decl (const cp_declarator *declarator,</span>
<span class="lineNum">    5014 </span>            :             cp_decl_specifier_seq *declspecs,
<span class="lineNum">    5015 </span>            :             int initialized,
<span class="lineNum">    5016 </span>            :             tree attributes,
<span class="lineNum">    5017 </span>            :             tree prefix_attributes,
<span class="lineNum">    5018 </span>            :             tree *pushed_scope_p)
<span class="lineNum">    5019 </span>            : {
<span class="lineNum">    5020 </span><span class="lineCov">    7010511 :   tree decl;</span>
<span class="lineNum">    5021 </span><span class="lineCov">    7010511 :   tree context;</span>
<span class="lineNum">    5022 </span><span class="lineCov">    7010511 :   bool was_public;</span>
<span class="lineNum">    5023 </span><span class="lineCov">    7010511 :   int flags;</span>
<span class="lineNum">    5024 </span><span class="lineCov">    7010511 :   bool alias;</span>
<span class="lineNum">    5025 </span>            : 
<span class="lineNum">    5026 </span><span class="lineCov">    7010511 :   *pushed_scope_p = NULL_TREE;</span>
<span class="lineNum">    5027 </span>            : 
<span class="lineNum">    5028 </span>            :   /* An object declared as __attribute__((deprecated)) suppresses
<span class="lineNum">    5029 </span>            :      warnings of uses of other deprecated items.  */
<span class="lineNum">    5030 </span><span class="lineCov">    7010511 :   if (lookup_attribute (&quot;deprecated&quot;, attributes))</span>
<span class="lineNum">    5031 </span><span class="lineCov">       9875 :     deprecated_state = DEPRECATED_SUPPRESS;</span>
<span class="lineNum">    5032 </span>            : 
<span class="lineNum">    5033 </span><span class="lineCov">    7010511 :   attributes = chainon (attributes, prefix_attributes);</span>
<span class="lineNum">    5034 </span>            : 
<span class="lineNum">    5035 </span><span class="lineCov">    7010511 :   decl = grokdeclarator (declarator, declspecs, NORMAL, initialized,</span>
<span class="lineNum">    5036 </span>            :                          &amp;attributes);
<span class="lineNum">    5037 </span>            : 
<span class="lineNum">    5038 </span><span class="lineCov">    7010511 :   deprecated_state = DEPRECATED_NORMAL;</span>
<span class="lineNum">    5039 </span>            : 
<span class="lineNum">    5040 </span><span class="lineCov">    7010511 :   if (decl == NULL_TREE || VOID_TYPE_P (decl)</span>
<span class="lineNum">    5041 </span><span class="lineCov">    7010511 :       || decl == error_mark_node)</span>
<span class="lineNum">    5042 </span><span class="lineCov">       1826 :     return error_mark_node;</span>
<span class="lineNum">    5043 </span>            : 
<span class="lineNum">    5044 </span><span class="lineCov">    7008685 :   context = CP_DECL_CONTEXT (decl);</span>
<span class="lineNum">    5045 </span><span class="lineCov">    7008685 :   if (context != global_namespace)</span>
<span class="lineNum">    5046 </span><span class="lineCov">     962375 :     *pushed_scope_p = push_scope (context);</span>
<span class="lineNum">    5047 </span>            : 
<span class="lineNum">    5048 </span>            :   /* Is it valid for this decl to have an initializer at all?
<span class="lineNum">    5049 </span>            :      If not, set INITIALIZED to zero, which will indirectly
<span class="lineNum">    5050 </span>            :      tell `cp_finish_decl' to ignore the initializer once it is parsed.  */
<span class="lineNum">    5051 </span><span class="lineCov">    7008685 :   if (initialized</span>
<span class="lineNum">    5052 </span><span class="lineCov">    1926638 :       &amp;&amp; TREE_CODE (decl) == TYPE_DECL)</span>
<span class="lineNum">    5053 </span>            :     {
<span class="lineNum">    5054 </span><span class="lineCov">          6 :       error (&quot;typedef %qD is initialized (use decltype instead)&quot;, decl);</span>
<span class="lineNum">    5055 </span><span class="lineCov">          6 :       return error_mark_node;</span>
<span class="lineNum">    5056 </span>            :     }
<span class="lineNum">    5057 </span>            : 
<span class="lineNum">    5058 </span><span class="lineCov">    7008679 :   if (initialized)</span>
<span class="lineNum">    5059 </span>            :     {
<span class="lineNum">    5060 </span><span class="lineCov">    1926632 :       if (! toplevel_bindings_p ()</span>
<span class="lineNum">    5061 </span><span class="lineCov">    1926632 :           &amp;&amp; DECL_EXTERNAL (decl))</span>
<span class="lineNum">    5062 </span><span class="lineCov">          3 :         warning (0, &quot;declaration of %q#D has %&lt;extern%&gt; and is initialized&quot;,</span>
<span class="lineNum">    5063 </span>            :                  decl);
<span class="lineNum">    5064 </span><span class="lineCov">    1926632 :       DECL_EXTERNAL (decl) = 0;</span>
<span class="lineNum">    5065 </span><span class="lineCov">    1926632 :       if (toplevel_bindings_p ())</span>
<span class="lineNum">    5066 </span><span class="lineCov">     152899 :         TREE_STATIC (decl) = 1;</span>
<span class="lineNum">    5067 </span>            :     }
<span class="lineNum">    5068 </span><span class="lineCov">    7008679 :   alias = lookup_attribute (&quot;alias&quot;, DECL_ATTRIBUTES (decl)) != 0;</span>
<span class="lineNum">    5069 </span>            :   
<span class="lineNum">    5070 </span><span class="lineCov">    7008679 :   if (alias &amp;&amp; TREE_CODE (decl) == FUNCTION_DECL)</span>
<span class="lineNum">    5071 </span><span class="lineCov">      50359 :     record_key_method_defined (decl);</span>
<span class="lineNum">    5072 </span>            : 
<span class="lineNum">    5073 </span>            :   /* If this is a typedef that names the class for linkage purposes
<span class="lineNum">    5074 </span>            :      (7.1.3p8), apply any attributes directly to the type.  */
<span class="lineNum">    5075 </span><span class="lineCov">    7008679 :   if (TREE_CODE (decl) == TYPE_DECL</span>
<span class="lineNum">    5076 </span><span class="lineCov">    1248766 :       &amp;&amp; OVERLOAD_TYPE_P (TREE_TYPE (decl))</span>
<span class="lineNum">    5077 </span><span class="lineCov">    7749807 :       &amp;&amp; decl == TYPE_NAME (TYPE_MAIN_VARIANT (TREE_TYPE (decl))))</span>
<span class="lineNum">    5078 </span>            :     flags = ATTR_FLAG_TYPE_IN_PLACE;
<span class="lineNum">    5079 </span>            :   else
<span class="lineNum">    5080 </span>            :     flags = 0;
<span class="lineNum">    5081 </span>            : 
<span class="lineNum">    5082 </span>            :   /* Set attributes here so if duplicate decl, will have proper attributes.  */
<span class="lineNum">    5083 </span><span class="lineCov">    7008679 :   cplus_decl_attributes (&amp;decl, attributes, flags);</span>
<span class="lineNum">    5084 </span>            : 
<span class="lineNum">    5085 </span>            :   /* Dllimported symbols cannot be defined.  Static data members (which
<span class="lineNum">    5086 </span>            :      can be initialized in-class and dllimported) go through grokfield,
<span class="lineNum">    5087 </span>            :      not here, so we don't need to exclude those decls when checking for
<span class="lineNum">    5088 </span>            :      a definition.  */
<span class="lineNum">    5089 </span><span class="lineCov">    7008679 :   if (initialized &amp;&amp; DECL_DLLIMPORT_P (decl))</span>
<span class="lineNum">    5090 </span>            :     {
<span class="lineNum">    5091 </span><span class="lineNoCov">          0 :       error (&quot;definition of %q#D is marked %&lt;dllimport%&gt;&quot;, decl);</span>
<span class="lineNum">    5092 </span><span class="lineNoCov">          0 :       DECL_DLLIMPORT_P (decl) = 0;</span>
<span class="lineNum">    5093 </span>            :     }
<span class="lineNum">    5094 </span>            : 
<span class="lineNum">    5095 </span>            :   /* If #pragma weak was used, mark the decl weak now.  */
<span class="lineNum">    5096 </span><span class="lineCov">    7008679 :   if (!processing_template_decl &amp;&amp; !DECL_DECOMPOSITION_P (decl))</span>
<span class="lineNum">    5097 </span><span class="lineCov">    4717118 :     maybe_apply_pragma_weak (decl);</span>
<span class="lineNum">    5098 </span>            : 
<span class="lineNum">    5099 </span><span class="lineCov">    7008679 :   if (TREE_CODE (decl) == FUNCTION_DECL</span>
<span class="lineNum">    5100 </span><span class="lineCov">    6411402 :       &amp;&amp; DECL_DECLARED_INLINE_P (decl)</span>
<span class="lineNum">    5101 </span><span class="lineCov">      17270 :       &amp;&amp; DECL_UNINLINABLE (decl)</span>
<span class="lineNum">    5102 </span><span class="lineCov">    7008679 :       &amp;&amp; lookup_attribute (&quot;noinline&quot;, DECL_ATTRIBUTES (decl)))</span>
<span class="lineNum">    5103 </span><span class="lineNoCov">          0 :     warning_at (DECL_SOURCE_LOCATION (decl), 0,</span>
<span class="lineNum">    5104 </span>            :                 &quot;inline function %qD given attribute noinline&quot;, decl);
<span class="lineNum">    5105 </span>            : 
<span class="lineNum">    5106 </span><span class="lineCov">    7008679 :   if (TYPE_P (context) &amp;&amp; COMPLETE_TYPE_P (complete_type (context)))</span>
<span class="lineNum">    5107 </span>            :     {
<span class="lineNum">    5108 </span><span class="lineCov">      79527 :       bool this_tmpl = (processing_template_decl</span>
<span class="lineNum">    5109 </span><span class="lineCov">      79527 :                         &gt; template_class_depth (context));</span>
<span class="lineNum">    5110 </span><span class="lineCov">      79527 :       if (VAR_P (decl))</span>
<span class="lineNum">    5111 </span>            :         {
<span class="lineNum">    5112 </span><span class="lineCov">      56619 :           tree field = lookup_field (context, DECL_NAME (decl), 0, false);</span>
<span class="lineNum">    5113 </span><span class="lineCov">      56619 :           if (field == NULL_TREE</span>
<span class="lineNum">    5114 </span><span class="lineCov">      56619 :               || !(VAR_P (field) || variable_template_p (field)))</span>
<span class="lineNum">    5115 </span><span class="lineCov">          4 :             error (&quot;%q+#D is not a static data member of %q#T&quot;, decl, context);</span>
<span class="lineNum">    5116 </span><span class="lineCov">      56615 :           else if (variable_template_p (field)</span>
<span class="lineNum">    5117 </span><span class="lineCov">      56615 :                    &amp;&amp; (DECL_LANG_SPECIFIC (decl)</span>
<span class="lineNum">    5118 </span><span class="lineCov">         28 :                        &amp;&amp; DECL_TEMPLATE_SPECIALIZATION (decl)))</span>
<span class="lineNum">    5119 </span>            :             /* OK, specialization was already checked.  */;
<span class="lineNum">    5120 </span><span class="lineCov">      56610 :           else if (variable_template_p (field) &amp;&amp; !this_tmpl)</span>
<span class="lineNum">    5121 </span>            :             {
<span class="lineNum">    5122 </span><span class="lineCov">          1 :               error_at (DECL_SOURCE_LOCATION (decl),</span>
<span class="lineNum">    5123 </span>            :                         &quot;non-member-template declaration of %qD&quot;, decl);
<span class="lineNum">    5124 </span><span class="lineCov">          1 :               inform (DECL_SOURCE_LOCATION (field), &quot;does not match &quot;</span>
<span class="lineNum">    5125 </span>            :                       &quot;member template declaration here&quot;);
<span class="lineNum">    5126 </span><span class="lineCov">          1 :               return error_mark_node;</span>
<span class="lineNum">    5127 </span>            :             }
<span class="lineNum">    5128 </span>            :           else
<span class="lineNum">    5129 </span>            :             {
<span class="lineNum">    5130 </span><span class="lineCov">      56609 :               if (variable_template_p (field))</span>
<span class="lineNum">    5131 </span><span class="lineCov">          8 :                 field = DECL_TEMPLATE_RESULT (field);</span>
<span class="lineNum">    5132 </span>            : 
<span class="lineNum">    5133 </span><span class="lineCov">      56609 :               if (DECL_CONTEXT (field) != context)</span>
<span class="lineNum">    5134 </span>            :                 {
<span class="lineNum">    5135 </span><span class="lineCov">          6 :                   if (!same_type_p (DECL_CONTEXT (field), context))</span>
<span class="lineNum">    5136 </span><span class="lineCov">          9 :                     permerror (input_location, &quot;ISO C++ does not permit %&lt;%T::%D%&gt; &quot;</span>
<span class="lineNum">    5137 </span>            :                                &quot;to be defined as %&lt;%T::%D%&gt;&quot;,
<span class="lineNum">    5138 </span><span class="lineCov">          3 :                                DECL_CONTEXT (field), DECL_NAME (decl),</span>
<span class="lineNum">    5139 </span><span class="lineCov">          3 :                                context, DECL_NAME (decl));</span>
<span class="lineNum">    5140 </span><span class="lineCov">          3 :                   DECL_CONTEXT (decl) = DECL_CONTEXT (field);</span>
<span class="lineNum">    5141 </span>            :                 }
<span class="lineNum">    5142 </span>            :               /* Static data member are tricky; an in-class initialization
<span class="lineNum">    5143 </span>            :                  still doesn't provide a definition, so the in-class
<span class="lineNum">    5144 </span>            :                  declaration will have DECL_EXTERNAL set, but will have an
<span class="lineNum">    5145 </span>            :                  initialization.  Thus, duplicate_decls won't warn
<span class="lineNum">    5146 </span>            :                  about this situation, and so we check here.  */
<span class="lineNum">    5147 </span><span class="lineCov">      56609 :               if (initialized &amp;&amp; DECL_INITIALIZED_IN_CLASS_P (field))</span>
<span class="lineNum">    5148 </span><span class="lineCov">          9 :                 error (&quot;duplicate initialization of %qD&quot;, decl);</span>
<span class="lineNum">    5149 </span><span class="lineCov">      56609 :               field = duplicate_decls (decl, field,</span>
<span class="lineNum">    5150 </span>            :                                        /*newdecl_is_friend=*/false);
<span class="lineNum">    5151 </span><span class="lineCov">      56609 :               if (field == error_mark_node)</span>
<span class="lineNum">    5152 </span>            :                 return error_mark_node;
<span class="lineNum">    5153 </span><span class="lineCov">      56565 :               else if (field)</span>
<span class="lineNum">    5154 </span><span class="lineCov">      56565 :                 decl = field;</span>
<span class="lineNum">    5155 </span>            :             }
<span class="lineNum">    5156 </span>            :         }
<span class="lineNum">    5157 </span>            :       else
<span class="lineNum">    5158 </span>            :         {
<span class="lineNum">    5159 </span><span class="lineCov">      22915 :           tree field = check_classfn (context, decl,</span>
<span class="lineNum">    5160 </span>            :                                       this_tmpl
<span class="lineNum">    5161 </span><span class="lineCov">          7 :                                       ? current_template_parms</span>
<span class="lineNum">    5162 </span>            :                                       : NULL_TREE);
<span class="lineNum">    5163 </span><span class="lineCov">      22852 :           if (field &amp;&amp; field != error_mark_node</span>
<span class="lineNum">    5164 </span><span class="lineCov">      45760 :               &amp;&amp; duplicate_decls (decl, field,</span>
<span class="lineNum">    5165 </span>            :                                  /*newdecl_is_friend=*/false))
<span class="lineNum">    5166 </span><span class="lineCov">      22852 :             decl = field;</span>
<span class="lineNum">    5167 </span>            :         }
<span class="lineNum">    5168 </span>            : 
<span class="lineNum">    5169 </span>            :       /* cp_finish_decl sets DECL_EXTERNAL if DECL_IN_AGGR_P is set.  */
<span class="lineNum">    5170 </span><span class="lineCov">      79482 :       DECL_IN_AGGR_P (decl) = 0;</span>
<span class="lineNum">    5171 </span>            :       /* Do not mark DECL as an explicit specialization if it was not
<span class="lineNum">    5172 </span>            :          already marked as an instantiation; a declaration should
<span class="lineNum">    5173 </span>            :          never be marked as a specialization unless we know what
<span class="lineNum">    5174 </span>            :          template is being specialized.  */
<span class="lineNum">    5175 </span><span class="lineCov">      79482 :       if (DECL_LANG_SPECIFIC (decl) &amp;&amp; DECL_USE_TEMPLATE (decl))</span>
<span class="lineNum">    5176 </span>            :         {
<span class="lineNum">    5177 </span><span class="lineCov">      22196 :           SET_DECL_TEMPLATE_SPECIALIZATION (decl);</span>
<span class="lineNum">    5178 </span><span class="lineCov">      22196 :           if (TREE_CODE (decl) == FUNCTION_DECL)</span>
<span class="lineNum">    5179 </span><span class="lineCov">      21361 :             DECL_COMDAT (decl) = (TREE_PUBLIC (decl)</span>
<span class="lineNum">    5180 </span><span class="lineCov">      21361 :                                   &amp;&amp; DECL_DECLARED_INLINE_P (decl));</span>
<span class="lineNum">    5181 </span>            :           else
<span class="lineNum">    5182 </span><span class="lineCov">        835 :             DECL_COMDAT (decl) = false;</span>
<span class="lineNum">    5183 </span>            : 
<span class="lineNum">    5184 </span>            :           /* [temp.expl.spec] An explicit specialization of a static data
<span class="lineNum">    5185 </span>            :              member of a template is a definition if the declaration
<span class="lineNum">    5186 </span>            :              includes an initializer; otherwise, it is a declaration.
<span class="lineNum">    5187 </span>            : 
<span class="lineNum">    5188 </span>            :              We check for processing_specialization so this only applies
<span class="lineNum">    5189 </span>            :              to the new specialization syntax.  */
<span class="lineNum">    5190 </span><span class="lineCov">      22196 :           if (!initialized &amp;&amp; processing_specialization)</span>
<span class="lineNum">    5191 </span><span class="lineCov">      22090 :             DECL_EXTERNAL (decl) = 1;</span>
<span class="lineNum">    5192 </span>            :         }
<span class="lineNum">    5193 </span>            : 
<span class="lineNum">    5194 </span><span class="lineCov">     123736 :       if (DECL_EXTERNAL (decl) &amp;&amp; ! DECL_TEMPLATE_SPECIALIZATION (decl)</span>
<span class="lineNum">    5195 </span>            :           /* Aliases are definitions. */
<span class="lineNum">    5196 </span><span class="lineCov">      79512 :           &amp;&amp; !alias)</span>
<span class="lineNum">    5197 </span><span class="lineCov">          3 :         permerror (input_location, &quot;declaration of %q#D outside of class is not definition&quot;,</span>
<span class="lineNum">    5198 </span>            :                    decl);
<span class="lineNum">    5199 </span>            :     }
<span class="lineNum">    5200 </span>            : 
<span class="lineNum">    5201 </span><span class="lineCov">    7008634 :   was_public = TREE_PUBLIC (decl);</span>
<span class="lineNum">    5202 </span>            : 
<span class="lineNum">    5203 </span>            :   /* Enter this declaration into the symbol table.  Don't push the plain
<span class="lineNum">    5204 </span>            :      VAR_DECL for a variable template.  */
<span class="lineNum">    5205 </span><span class="lineCov">    7008634 :   if (!template_parm_scope_p ()</span>
<span class="lineNum">    5206 </span><span class="lineCov">    7008634 :       || !VAR_P (decl))</span>
<span class="lineNum">    5207 </span><span class="lineCov">    6946966 :     decl = maybe_push_decl (decl);</span>
<span class="lineNum">    5208 </span>            : 
<span class="lineNum">    5209 </span><span class="lineCov">    7008634 :   if (processing_template_decl)</span>
<span class="lineNum">    5210 </span><span class="lineCov">    2291289 :     decl = push_template_decl (decl);</span>
<span class="lineNum">    5211 </span><span class="lineCov">    7008634 :   if (decl == error_mark_node)</span>
<span class="lineNum">    5212 </span>            :     return error_mark_node;
<span class="lineNum">    5213 </span>            : 
<span class="lineNum">    5214 </span><span class="lineCov">    7008479 :   if (VAR_P (decl)</span>
<span class="lineNum">    5215 </span><span class="lineCov">    2554069 :       &amp;&amp; DECL_NAMESPACE_SCOPE_P (decl) &amp;&amp; !TREE_PUBLIC (decl) &amp;&amp; !was_public</span>
<span class="lineNum">    5216 </span><span class="lineCov">    7219322 :       &amp;&amp; !DECL_THIS_STATIC (decl) &amp;&amp; !DECL_ARTIFICIAL (decl))</span>
<span class="lineNum">    5217 </span>            :     {
<span class="lineNum">    5218 </span>            :       /* This is a const variable with implicit 'static'.  Set
<span class="lineNum">    5219 </span>            :          DECL_THIS_STATIC so we can tell it from variables that are
<span class="lineNum">    5220 </span>            :          !TREE_PUBLIC because of the anonymous namespace.  */
<span class="lineNum">    5221 </span><span class="lineCov">      31067 :       gcc_assert (CP_TYPE_CONST_P (TREE_TYPE (decl)) || errorcount);</span>
<span class="lineNum">    5222 </span><span class="lineCov">      31067 :       DECL_THIS_STATIC (decl) = 1;</span>
<span class="lineNum">    5223 </span>            :     }
<span class="lineNum">    5224 </span>            : 
<span class="lineNum">    5225 </span><span class="lineCov">    2431109 :   if (current_function_decl &amp;&amp; VAR_P (decl)</span>
<span class="lineNum">    5226 </span><span class="lineCov">   11184307 :       &amp;&amp; DECL_DECLARED_CONSTEXPR_P (current_function_decl))</span>
<span class="lineNum">    5227 </span>            :     {
<span class="lineNum">    5228 </span><span class="lineCov">      25412 :       bool ok = false;</span>
<span class="lineNum">    5229 </span><span class="lineCov">      76236 :       if (CP_DECL_THREAD_LOCAL_P (decl))</span>
<span class="lineNum">    5230 </span><span class="lineCov">          1 :         error (&quot;%qD declared %&lt;thread_local%&gt; in %&lt;constexpr%&gt; function&quot;,</span>
<span class="lineNum">    5231 </span>            :                decl);
<span class="lineNum">    5232 </span><span class="lineCov">      25411 :       else if (TREE_STATIC (decl))</span>
<span class="lineNum">    5233 </span><span class="lineCov">          1 :         error (&quot;%qD declared %&lt;static%&gt; in %&lt;constexpr%&gt; function&quot;, decl);</span>
<span class="lineNum">    5234 </span>            :       else
<span class="lineNum">    5235 </span>            :         ok = true;
<span class="lineNum">    5236 </span><span class="lineCov">          2 :       if (!ok)</span>
<span class="lineNum">    5237 </span><span class="lineCov">          2 :         cp_function_chain-&gt;invalid_constexpr = true;</span>
<span class="lineNum">    5238 </span>            :     }
<span class="lineNum">    5239 </span>            : 
<span class="lineNum">    5240 </span><span class="lineCov">    7008479 :   if (!processing_template_decl &amp;&amp; VAR_P (decl))</span>
<span class="lineNum">    5241 </span><span class="lineCov">     825154 :     start_decl_1 (decl, initialized);</span>
<span class="lineNum">    5242 </span>            : 
<span class="lineNum">    5243 </span><span class="lineCov">    7008476 :   return decl;</span>
<span class="lineNum">    5244 </span>            : }
<span class="lineNum">    5245 </span>            : 
<span class="lineNum">    5246 </span>            : /* Process the declaration of a variable DECL.  INITIALIZED is true
<span class="lineNum">    5247 </span>            :    iff DECL is explicitly initialized.  (INITIALIZED is false if the
<span class="lineNum">    5248 </span>            :    variable is initialized via an implicitly-called constructor.)
<span class="lineNum">    5249 </span>            :    This function must be called for ordinary variables (including, for
<span class="lineNum">    5250 </span>            :    example, implicit instantiations of templates), but must not be
<span class="lineNum">    5251 </span>            :    called for template declarations.  */
<a name="5252"><span class="lineNum">    5252 </span>            : </a>
<span class="lineNum">    5253 </span>            : void
<span class="lineNum">    5254 </span><span class="lineCov">     830132 : start_decl_1 (tree decl, bool initialized)</span>
<span class="lineNum">    5255 </span>            : {
<span class="lineNum">    5256 </span><span class="lineCov">     830132 :   tree type;</span>
<span class="lineNum">    5257 </span><span class="lineCov">     830132 :   bool complete_p;</span>
<span class="lineNum">    5258 </span><span class="lineCov">     830132 :   bool aggregate_definition_p;</span>
<span class="lineNum">    5259 </span>            : 
<span class="lineNum">    5260 </span><span class="lineCov">     830132 :   gcc_assert (!processing_template_decl);</span>
<span class="lineNum">    5261 </span>            : 
<span class="lineNum">    5262 </span><span class="lineCov">     830132 :   if (error_operand_p (decl))</span>
<span class="lineNum">    5263 </span>            :     return;
<span class="lineNum">    5264 </span>            : 
<span class="lineNum">    5265 </span><span class="lineCov">     830122 :   gcc_assert (VAR_P (decl));</span>
<span class="lineNum">    5266 </span>            : 
<span class="lineNum">    5267 </span><span class="lineCov">     830122 :   type = TREE_TYPE (decl);</span>
<span class="lineNum">    5268 </span><span class="lineCov">     830122 :   complete_p = COMPLETE_TYPE_P (type);</span>
<span class="lineNum">    5269 </span><span class="lineCov">     830122 :   aggregate_definition_p = MAYBE_CLASS_TYPE_P (type) &amp;&amp; !DECL_EXTERNAL (decl);</span>
<span class="lineNum">    5270 </span>            : 
<span class="lineNum">    5271 </span>            :   /* If an explicit initializer is present, or if this is a definition
<span class="lineNum">    5272 </span>            :      of an aggregate, then we need a complete type at this point.
<span class="lineNum">    5273 </span>            :      (Scalars are always complete types, so there is nothing to
<span class="lineNum">    5274 </span>            :      check.)  This code just sets COMPLETE_P; errors (if necessary)
<span class="lineNum">    5275 </span>            :      are issued below.  */
<span class="lineNum">    5276 </span><span class="lineCov">     830122 :   if ((initialized || aggregate_definition_p) </span>
<span class="lineNum">    5277 </span><span class="lineCov">     460309 :       &amp;&amp; !complete_p</span>
<span class="lineNum">    5278 </span><span class="lineCov">     891471 :       &amp;&amp; COMPLETE_TYPE_P (complete_type (type)))</span>
<span class="lineNum">    5279 </span>            :     {
<span class="lineNum">    5280 </span><span class="lineCov">      18917 :       complete_p = true;</span>
<span class="lineNum">    5281 </span>            :       /* We will not yet have set TREE_READONLY on DECL if the type
<span class="lineNum">    5282 </span>            :          was &quot;const&quot;, but incomplete, before this point.  But, now, we
<span class="lineNum">    5283 </span>            :          have a complete type, so we can try again.  */
<span class="lineNum">    5284 </span><span class="lineCov">      18917 :       cp_apply_type_quals_to_decl (cp_type_quals (type), decl);</span>
<span class="lineNum">    5285 </span>            :     }
<span class="lineNum">    5286 </span>            : 
<span class="lineNum">    5287 </span><span class="lineCov">     830119 :   if (initialized)</span>
<span class="lineNum">    5288 </span>            :     /* Is it valid for this decl to have an initializer at all?  */
<span class="lineNum">    5289 </span>            :     {
<span class="lineNum">    5290 </span>            :       /* Don't allow initializations for incomplete types except for
<span class="lineNum">    5291 </span>            :          arrays which might be completed by the initialization.  */
<span class="lineNum">    5292 </span><span class="lineCov">     389237 :       if (complete_p)</span>
<span class="lineNum">    5293 </span>            :         ;                       /* A complete type is ok.  */
<span class="lineNum">    5294 </span><span class="lineCov">      42313 :       else if (type_uses_auto (type))</span>
<span class="lineNum">    5295 </span>            :         ;                       /* An auto type is ok.  */
<span class="lineNum">    5296 </span><span class="lineCov">      34121 :       else if (TREE_CODE (type) != ARRAY_TYPE)</span>
<span class="lineNum">    5297 </span>            :         {
<span class="lineNum">    5298 </span><span class="lineCov">         19 :           error (&quot;variable %q#D has initializer but incomplete type&quot;, decl);</span>
<span class="lineNum">    5299 </span><span class="lineCov">         19 :           type = TREE_TYPE (decl) = error_mark_node;</span>
<span class="lineNum">    5300 </span>            :         }
<span class="lineNum">    5301 </span><span class="lineCov">      34102 :       else if (!COMPLETE_TYPE_P (complete_type (TREE_TYPE (type))))</span>
<span class="lineNum">    5302 </span>            :         {
<span class="lineNum">    5303 </span><span class="lineNoCov">          0 :           if (DECL_LANG_SPECIFIC (decl) &amp;&amp; DECL_TEMPLATE_INFO (decl))</span>
<span class="lineNum">    5304 </span><span class="lineNoCov">          0 :             error (&quot;elements of array %q#D have incomplete type&quot;, decl);</span>
<span class="lineNum">    5305 </span>            :           /* else we already gave an error in start_decl.  */
<span class="lineNum">    5306 </span>            :         }
<span class="lineNum">    5307 </span>            :     }
<span class="lineNum">    5308 </span><span class="lineCov">     440882 :   else if (aggregate_definition_p &amp;&amp; !complete_p)</span>
<span class="lineNum">    5309 </span>            :     {
<span class="lineNum">    5310 </span><span class="lineCov">        116 :       if (type_uses_auto (type))</span>
<span class="lineNum">    5311 </span><span class="lineCov">          4 :         gcc_assert (CLASS_PLACEHOLDER_TEMPLATE (type));</span>
<span class="lineNum">    5312 </span>            :       else
<span class="lineNum">    5313 </span>            :         {
<span class="lineNum">    5314 </span><span class="lineCov">        112 :           error (&quot;aggregate %q#D has incomplete type and cannot be defined&quot;,</span>
<span class="lineNum">    5315 </span>            :                  decl);
<span class="lineNum">    5316 </span>            :           /* Change the type so that assemble_variable will give
<span class="lineNum">    5317 </span>            :              DECL an rtl we can live with: (mem (const_int 0)).  */
<span class="lineNum">    5318 </span><span class="lineCov">        112 :           type = TREE_TYPE (decl) = error_mark_node;</span>
<span class="lineNum">    5319 </span>            :         }
<span class="lineNum">    5320 </span>            :     }
<span class="lineNum">    5321 </span>            : 
<span class="lineNum">    5322 </span>            :   /* Create a new scope to hold this declaration if necessary.
<span class="lineNum">    5323 </span>            :      Whether or not a new scope is necessary cannot be determined
<span class="lineNum">    5324 </span>            :      until after the type has been completed; if the type is a
<span class="lineNum">    5325 </span>            :      specialization of a class template it is not until after
<span class="lineNum">    5326 </span>            :      instantiation has occurred that TYPE_HAS_NONTRIVIAL_DESTRUCTOR
<span class="lineNum">    5327 </span>            :      will be set correctly.  */
<span class="lineNum">    5328 </span><span class="lineCov">     830119 :   maybe_push_cleanup_level (type);</span>
<span class="lineNum">    5329 </span>            : }
<span class="lineNum">    5330 </span>            : 
<span class="lineNum">    5331 </span>            : /* Handle initialization of references.  DECL, TYPE, and INIT have the
<span class="lineNum">    5332 </span>            :    same meaning as in cp_finish_decl.  *CLEANUP must be NULL on entry,
<span class="lineNum">    5333 </span>            :    but will be set to a new CLEANUP_STMT if a temporary is created
<span class="lineNum">    5334 </span>            :    that must be destroyed subsequently.
<span class="lineNum">    5335 </span>            : 
<span class="lineNum">    5336 </span>            :    Returns an initializer expression to use to initialize DECL, or
<span class="lineNum">    5337 </span>            :    NULL if the initialization can be performed statically.
<span class="lineNum">    5338 </span>            : 
<span class="lineNum">    5339 </span>            :    Quotes on semantics can be found in ARM 8.4.3.  */
<a name="5340"><span class="lineNum">    5340 </span>            : </a>
<span class="lineNum">    5341 </span>            : static tree
<span class="lineNum">    5342 </span><span class="lineCov">      63129 : grok_reference_init (tree decl, tree type, tree init, int flags)</span>
<span class="lineNum">    5343 </span>            : {
<span class="lineNum">    5344 </span><span class="lineCov">      63129 :   if (init == NULL_TREE)</span>
<span class="lineNum">    5345 </span>            :     {
<span class="lineNum">    5346 </span><span class="lineCov">          8 :       if ((DECL_LANG_SPECIFIC (decl) == 0</span>
<span class="lineNum">    5347 </span><span class="lineCov">          6 :            || DECL_IN_AGGR_P (decl) == 0)</span>
<span class="lineNum">    5348 </span><span class="lineCov">         11 :           &amp;&amp; ! DECL_THIS_EXTERN (decl))</span>
<span class="lineNum">    5349 </span><span class="lineCov">          8 :         error (&quot;%qD declared as reference but not initialized&quot;, decl);</span>
<span class="lineNum">    5350 </span><span class="lineCov">          8 :       return NULL_TREE;</span>
<span class="lineNum">    5351 </span>            :     }
<span class="lineNum">    5352 </span>            : 
<span class="lineNum">    5353 </span><span class="lineCov">      63121 :   if (TREE_CODE (init) == TREE_LIST)</span>
<span class="lineNum">    5354 </span><span class="lineCov">        890 :     init = build_x_compound_expr_from_list (init, ELK_INIT,</span>
<span class="lineNum">    5355 </span>            :                                             tf_warning_or_error);
<span class="lineNum">    5356 </span>            : 
<span class="lineNum">    5357 </span><span class="lineCov">      63121 :   tree ttype = TREE_TYPE (type);</span>
<span class="lineNum">    5358 </span><span class="lineCov">      63121 :   if (TREE_CODE (ttype) != ARRAY_TYPE</span>
<span class="lineNum">    5359 </span><span class="lineCov">      63121 :       &amp;&amp; TREE_CODE (TREE_TYPE (init)) == ARRAY_TYPE)</span>
<span class="lineNum">    5360 </span>            :     /* Note: default conversion is only called in very special cases.  */
<span class="lineNum">    5361 </span><span class="lineCov">         11 :     init = decay_conversion (init, tf_warning_or_error);</span>
<span class="lineNum">    5362 </span>            : 
<span class="lineNum">    5363 </span>            :   /* check_initializer handles this for non-reference variables, but for
<span class="lineNum">    5364 </span>            :      references we need to do it here or the initializer will get the
<span class="lineNum">    5365 </span>            :      incomplete array type and confuse later calls to
<span class="lineNum">    5366 </span>            :      cp_complete_array_type.  */
<span class="lineNum">    5367 </span><span class="lineCov">      63121 :   if (TREE_CODE (ttype) == ARRAY_TYPE</span>
<span class="lineNum">    5368 </span><span class="lineCov">       1196 :       &amp;&amp; TYPE_DOMAIN (ttype) == NULL_TREE</span>
<span class="lineNum">    5369 </span><span class="lineCov">      63145 :       &amp;&amp; (BRACE_ENCLOSED_INITIALIZER_P (init)</span>
<span class="lineNum">    5370 </span><span class="lineCov">         22 :           || TREE_CODE (init) == STRING_CST))</span>
<span class="lineNum">    5371 </span>            :     {
<span class="lineNum">    5372 </span><span class="lineCov">          2 :       cp_complete_array_type (&amp;ttype, init, false);</span>
<span class="lineNum">    5373 </span><span class="lineCov">          2 :       if (ttype != TREE_TYPE (type))</span>
<span class="lineNum">    5374 </span><span class="lineCov">          2 :         type = cp_build_reference_type (ttype, TYPE_REF_IS_RVALUE (type));</span>
<span class="lineNum">    5375 </span>            :     }
<span class="lineNum">    5376 </span>            : 
<span class="lineNum">    5377 </span>            :   /* Convert INIT to the reference type TYPE.  This may involve the
<span class="lineNum">    5378 </span>            :      creation of a temporary, whose lifetime must be the same as that
<span class="lineNum">    5379 </span>            :      of the reference.  If so, a DECL_EXPR for the temporary will be
<span class="lineNum">    5380 </span>            :      added just after the DECL_EXPR for DECL.  That's why we don't set
<span class="lineNum">    5381 </span>            :      DECL_INITIAL for local references (instead assigning to them
<span class="lineNum">    5382 </span>            :      explicitly); we need to allow the temporary to be initialized
<span class="lineNum">    5383 </span>            :      first.  */
<span class="lineNum">    5384 </span><span class="lineCov">      63121 :   return initialize_reference (type, init, flags,</span>
<span class="lineNum">    5385 </span><span class="lineCov">      63121 :                                tf_warning_or_error);</span>
<span class="lineNum">    5386 </span>            : }
<span class="lineNum">    5387 </span>            : 
<span class="lineNum">    5388 </span>            : /* Designated initializers in arrays are not supported in GNU C++.
<span class="lineNum">    5389 </span>            :    The parser cannot detect this error since it does not know whether
<span class="lineNum">    5390 </span>            :    a given brace-enclosed initializer is for a class type or for an
<span class="lineNum">    5391 </span>            :    array.  This function checks that CE does not use a designated
<span class="lineNum">    5392 </span>            :    initializer.  If it does, an error is issued.  Returns true if CE
<span class="lineNum">    5393 </span>            :    is valid, i.e., does not have a designated initializer.  */
<a name="5394"><span class="lineNum">    5394 </span>            : </a>
<span class="lineNum">    5395 </span>            : bool
<span class="lineNum">    5396 </span><span class="lineCov">     739703 : check_array_designated_initializer (constructor_elt *ce,</span>
<span class="lineNum">    5397 </span>            :                                     unsigned HOST_WIDE_INT index)
<span class="lineNum">    5398 </span>            : {
<span class="lineNum">    5399 </span>            :   /* Designated initializers for array elements are not supported.  */
<span class="lineNum">    5400 </span><span class="lineCov">     739703 :   if (ce-&gt;index)</span>
<span class="lineNum">    5401 </span>            :     {
<span class="lineNum">    5402 </span>            :       /* The parser only allows identifiers as designated
<span class="lineNum">    5403 </span>            :          initializers.  */
<span class="lineNum">    5404 </span><span class="lineCov">     388853 :       if (ce-&gt;index == error_mark_node)</span>
<span class="lineNum">    5405 </span>            :         {
<span class="lineNum">    5406 </span><span class="lineNoCov">          0 :           error (&quot;name used in a GNU-style designated &quot;</span>
<span class="lineNum">    5407 </span>            :                  &quot;initializer for an array&quot;);
<span class="lineNum">    5408 </span><span class="lineNoCov">          0 :           return false;</span>
<span class="lineNum">    5409 </span>            :         }
<span class="lineNum">    5410 </span><span class="lineCov">     388853 :       else if (identifier_p (ce-&gt;index))</span>
<span class="lineNum">    5411 </span>            :         {
<span class="lineNum">    5412 </span><span class="lineCov">         24 :           error (&quot;name %qD used in a GNU-style designated &quot;</span>
<span class="lineNum">    5413 </span>            :                  &quot;initializer for an array&quot;, ce-&gt;index);
<span class="lineNum">    5414 </span><span class="lineCov">         24 :           return false;</span>
<span class="lineNum">    5415 </span>            :         }
<span class="lineNum">    5416 </span>            : 
<span class="lineNum">    5417 </span><span class="lineCov">     388829 :       tree ce_index = build_expr_type_conversion (WANT_INT | WANT_ENUM,</span>
<span class="lineNum">    5418 </span><span class="lineCov">     388829 :                                                   ce-&gt;index, true);</span>
<span class="lineNum">    5419 </span><span class="lineCov">     388829 :       if (ce_index</span>
<span class="lineNum">    5420 </span><span class="lineCov">     388826 :           &amp;&amp; INTEGRAL_OR_UNSCOPED_ENUMERATION_TYPE_P (TREE_TYPE (ce_index))</span>
<span class="lineNum">    5421 </span><span class="lineCov">     777653 :           &amp;&amp; (TREE_CODE (ce_index = fold_non_dependent_expr (ce_index))</span>
<span class="lineNum">    5422 </span>            :               == INTEGER_CST))
<span class="lineNum">    5423 </span>            :         {
<span class="lineNum">    5424 </span>            :           /* A C99 designator is OK if it matches the current index.  */
<span class="lineNum">    5425 </span><span class="lineCov">     388824 :           if (wi::to_wide (ce_index) == index)</span>
<span class="lineNum">    5426 </span>            :             {
<span class="lineNum">    5427 </span><span class="lineCov">     388818 :               ce-&gt;index = ce_index;</span>
<span class="lineNum">    5428 </span><span class="lineCov">     388818 :               return true;</span>
<span class="lineNum">    5429 </span>            :             }
<span class="lineNum">    5430 </span>            :           else
<span class="lineNum">    5431 </span><span class="lineCov">          6 :             sorry (&quot;non-trivial designated initializers not supported&quot;);</span>
<span class="lineNum">    5432 </span>            :         }
<span class="lineNum">    5433 </span>            :       else
<span class="lineNum">    5434 </span><span class="lineCov">          5 :         error (&quot;C99 designator %qE is not an integral constant-expression&quot;,</span>
<span class="lineNum">    5435 </span>            :                ce-&gt;index);
<span class="lineNum">    5436 </span>            : 
<span class="lineNum">    5437 </span><span class="lineCov">         11 :       return false;</span>
<span class="lineNum">    5438 </span>            :     }
<span class="lineNum">    5439 </span>            : 
<span class="lineNum">    5440 </span>            :   return true;
<span class="lineNum">    5441 </span>            : }
<span class="lineNum">    5442 </span>            : 
<span class="lineNum">    5443 </span>            : /* When parsing `int a[] = {1, 2};' we don't know the size of the
<span class="lineNum">    5444 </span>            :    array until we finish parsing the initializer.  If that's the
<span class="lineNum">    5445 </span>            :    situation we're in, update DECL accordingly.  */
<a name="5446"><span class="lineNum">    5446 </span>            : </a>
<span class="lineNum">    5447 </span>            : static void
<span class="lineNum">    5448 </span><span class="lineCov">    3428494 : maybe_deduce_size_from_array_init (tree decl, tree init)</span>
<span class="lineNum">    5449 </span>            : {
<span class="lineNum">    5450 </span><span class="lineCov">    3428494 :   tree type = TREE_TYPE (decl);</span>
<span class="lineNum">    5451 </span>            : 
<span class="lineNum">    5452 </span><span class="lineCov">    3428494 :   if (TREE_CODE (type) == ARRAY_TYPE</span>
<span class="lineNum">    5453 </span><span class="lineCov">     415116 :       &amp;&amp; TYPE_DOMAIN (type) == NULL_TREE</span>
<span class="lineNum">    5454 </span><span class="lineCov">    3613838 :       &amp;&amp; TREE_CODE (decl) != TYPE_DECL)</span>
<span class="lineNum">    5455 </span>            :     {
<span class="lineNum">    5456 </span>            :       /* do_default is really a C-ism to deal with tentative definitions.
<span class="lineNum">    5457 </span>            :          But let's leave it here to ease the eventual merge.  */
<span class="lineNum">    5458 </span><span class="lineCov">     185344 :       int do_default = !DECL_EXTERNAL (decl);</span>
<span class="lineNum">    5459 </span><span class="lineCov">     185344 :       tree initializer = init ? init : DECL_INITIAL (decl);</span>
<span class="lineNum">    5460 </span><span class="lineCov">     185344 :       int failure = 0;</span>
<span class="lineNum">    5461 </span>            : 
<span class="lineNum">    5462 </span>            :       /* Check that there are no designated initializers in INIT, as
<span class="lineNum">    5463 </span>            :          those are not supported in GNU C++, and as the middle-end
<span class="lineNum">    5464 </span>            :          will crash if presented with a non-numeric designated
<span class="lineNum">    5465 </span>            :          initializer.  */
<span class="lineNum">    5466 </span><span class="lineCov">     185344 :       if (initializer &amp;&amp; BRACE_ENCLOSED_INITIALIZER_P (initializer))</span>
<span class="lineNum">    5467 </span>            :         {
<span class="lineNum">    5468 </span><span class="lineCov">       3843 :           vec&lt;constructor_elt, va_gc&gt; *v = CONSTRUCTOR_ELTS (initializer);</span>
<span class="lineNum">    5469 </span><span class="lineCov">       3843 :           constructor_elt *ce;</span>
<span class="lineNum">    5470 </span><span class="lineCov">       3843 :           HOST_WIDE_INT i;</span>
<span class="lineNum">    5471 </span><span class="lineCov">      60212 :           FOR_EACH_VEC_SAFE_ELT (v, i, ce)</span>
<span class="lineNum">    5472 </span>            :             {
<span class="lineNum">    5473 </span><span class="lineCov">      56375 :               if (instantiation_dependent_expression_p (ce-&gt;index))</span>
<span class="lineNum">    5474 </span>            :                 return;
<span class="lineNum">    5475 </span><span class="lineCov">      56369 :               if (!check_array_designated_initializer (ce, i))</span>
<span class="lineNum">    5476 </span><span class="lineCov">          3 :                 failure = 1;</span>
<span class="lineNum">    5477 </span>            :             }
<span class="lineNum">    5478 </span>            :         }
<span class="lineNum">    5479 </span>            : 
<span class="lineNum">    5480 </span><span class="lineCov">       3837 :       if (failure)</span>
<span class="lineNum">    5481 </span><span class="lineCov">          3 :         TREE_TYPE (decl) = error_mark_node;</span>
<span class="lineNum">    5482 </span>            :       else
<span class="lineNum">    5483 </span>            :         {
<span class="lineNum">    5484 </span><span class="lineCov">     185335 :           failure = cp_complete_array_type (&amp;TREE_TYPE (decl), initializer,</span>
<span class="lineNum">    5485 </span>            :                                             do_default);
<span class="lineNum">    5486 </span><span class="lineCov">     185335 :           if (failure == 1)</span>
<span class="lineNum">    5487 </span>            :             {
<span class="lineNum">    5488 </span><span class="lineCov">         30 :               error_at (cp_expr_loc_or_loc (initializer,</span>
<span class="lineNum">    5489 </span><span class="lineCov">         30 :                                          DECL_SOURCE_LOCATION (decl)),</span>
<span class="lineNum">    5490 </span>            :                         &quot;initializer fails to determine size of %qD&quot;, decl);
<span class="lineNum">    5491 </span>            :             }
<span class="lineNum">    5492 </span><span class="lineCov">     185305 :           else if (failure == 2)</span>
<span class="lineNum">    5493 </span>            :             {
<span class="lineNum">    5494 </span><span class="lineCov">         34 :               if (do_default)</span>
<span class="lineNum">    5495 </span>            :                 {
<span class="lineNum">    5496 </span><span class="lineCov">          6 :                   error_at (DECL_SOURCE_LOCATION (decl),</span>
<span class="lineNum">    5497 </span>            :                             &quot;array size missing in %qD&quot;, decl);
<span class="lineNum">    5498 </span>            :                 }
<span class="lineNum">    5499 </span>            :               /* If a `static' var's size isn't known, make it extern as
<span class="lineNum">    5500 </span>            :                  well as static, so it does not get allocated.  If it's not
<span class="lineNum">    5501 </span>            :                  `static', then don't mark it extern; finish_incomplete_decl
<span class="lineNum">    5502 </span>            :                  will give it a default size and it will get allocated.  */
<span class="lineNum">    5503 </span><span class="lineCov">         28 :               else if (!pedantic &amp;&amp; TREE_STATIC (decl) &amp;&amp; !TREE_PUBLIC (decl))</span>
<span class="lineNum">    5504 </span><span class="lineNoCov">          0 :                 DECL_EXTERNAL (decl) = 1;</span>
<span class="lineNum">    5505 </span>            :             }
<span class="lineNum">    5506 </span><span class="lineCov">     185271 :           else if (failure == 3)</span>
<span class="lineNum">    5507 </span>            :             {
<span class="lineNum">    5508 </span><span class="lineCov">          6 :               error_at (DECL_SOURCE_LOCATION (decl),</span>
<span class="lineNum">    5509 </span>            :                         &quot;zero-size array %qD&quot;, decl);
<span class="lineNum">    5510 </span>            :             }
<span class="lineNum">    5511 </span>            :         }
<span class="lineNum">    5512 </span>            : 
<span class="lineNum">    5513 </span><span class="lineCov">     185338 :       cp_apply_type_quals_to_decl (cp_type_quals (TREE_TYPE (decl)), decl);</span>
<span class="lineNum">    5514 </span>            : 
<span class="lineNum">    5515 </span><span class="lineCov">     185338 :       relayout_decl (decl);</span>
<span class="lineNum">    5516 </span>            :     }
<span class="lineNum">    5517 </span>            : }
<span class="lineNum">    5518 </span>            : 
<span class="lineNum">    5519 </span>            : /* Set DECL_SIZE, DECL_ALIGN, etc. for DECL (a VAR_DECL), and issue
<span class="lineNum">    5520 </span>            :    any appropriate error messages regarding the layout.  */
<a name="5521"><span class="lineNum">    5521 </span>            : </a>
<span class="lineNum">    5522 </span>            : static void
<span class="lineNum">    5523 </span><span class="lineCov">    4039179 : layout_var_decl (tree decl)</span>
<span class="lineNum">    5524 </span>            : {
<span class="lineNum">    5525 </span><span class="lineCov">    4039179 :   tree type;</span>
<span class="lineNum">    5526 </span>            : 
<span class="lineNum">    5527 </span><span class="lineCov">    4039179 :   type = TREE_TYPE (decl);</span>
<span class="lineNum">    5528 </span><span class="lineCov">    4039179 :   if (type == error_mark_node)</span>
<span class="lineNum">    5529 </span>            :     return;
<span class="lineNum">    5530 </span>            : 
<span class="lineNum">    5531 </span>            :   /* If we haven't already laid out this declaration, do so now.
<span class="lineNum">    5532 </span>            :      Note that we must not call complete type for an external object
<span class="lineNum">    5533 </span>            :      because it's type might involve templates that we are not
<span class="lineNum">    5534 </span>            :      supposed to instantiate yet.  (And it's perfectly valid to say
<span class="lineNum">    5535 </span>            :      `extern X x' for some incomplete type `X'.)  */
<span class="lineNum">    5536 </span><span class="lineCov">    4039143 :   if (!DECL_EXTERNAL (decl))</span>
<span class="lineNum">    5537 </span><span class="lineCov">    2806645 :     complete_type (type);</span>
<span class="lineNum">    5538 </span><span class="lineCov">    4039143 :   if (!DECL_SIZE (decl)</span>
<span class="lineNum">    5539 </span><span class="lineCov">     132365 :       &amp;&amp; TREE_TYPE (decl) != error_mark_node</span>
<span class="lineNum">    5540 </span><span class="lineCov">    4171508 :       &amp;&amp; complete_or_array_type_p (type))</span>
<span class="lineNum">    5541 </span><span class="lineCov">     121442 :     layout_decl (decl, 0);</span>
<span class="lineNum">    5542 </span>            : 
<span class="lineNum">    5543 </span><span class="lineCov">    4039143 :   if (!DECL_EXTERNAL (decl) &amp;&amp; DECL_SIZE (decl) == NULL_TREE)</span>
<span class="lineNum">    5544 </span>            :     {
<span class="lineNum">    5545 </span>            :       /* An automatic variable with an incomplete type: that is an error.
<span class="lineNum">    5546 </span>            :          Don't talk about array types here, since we took care of that
<span class="lineNum">    5547 </span>            :          message in grokdeclarator.  */
<span class="lineNum">    5548 </span><span class="lineCov">         15 :       error_at (DECL_SOURCE_LOCATION (decl),</span>
<span class="lineNum">    5549 </span>            :                 &quot;storage size of %qD isn%'t known&quot;, decl);
<span class="lineNum">    5550 </span><span class="lineCov">         15 :       TREE_TYPE (decl) = error_mark_node;</span>
<span class="lineNum">    5551 </span>            :     }
<span class="lineNum">    5552 </span>            : #if 0
<span class="lineNum">    5553 </span>            :   /* Keep this code around in case we later want to control debug info
<span class="lineNum">    5554 </span>            :      based on whether a type is &quot;used&quot;.  (jason 1999-11-11) */
<span class="lineNum">    5555 </span>            : 
<span class="lineNum">    5556 </span>            :   else if (!DECL_EXTERNAL (decl) &amp;&amp; MAYBE_CLASS_TYPE_P (ttype))
<span class="lineNum">    5557 </span>            :     /* Let debugger know it should output info for this type.  */
<span class="lineNum">    5558 </span>            :     note_debug_info_needed (ttype);
<span class="lineNum">    5559 </span>            : 
<span class="lineNum">    5560 </span>            :   if (TREE_STATIC (decl) &amp;&amp; DECL_CLASS_SCOPE_P (decl))
<span class="lineNum">    5561 </span>            :     note_debug_info_needed (DECL_CONTEXT (decl));
<span class="lineNum">    5562 </span>            : #endif
<span class="lineNum">    5563 </span>            : 
<span class="lineNum">    5564 </span><span class="lineCov">    6845788 :   if ((DECL_EXTERNAL (decl) || TREE_STATIC (decl))</span>
<span class="lineNum">    5565 </span><span class="lineCov">    3941732 :       &amp;&amp; DECL_SIZE (decl) != NULL_TREE</span>
<span class="lineNum">    5566 </span><span class="lineCov">    7879695 :       &amp;&amp; ! TREE_CONSTANT (DECL_SIZE (decl)))</span>
<span class="lineNum">    5567 </span>            :     {
<span class="lineNum">    5568 </span><span class="lineCov">         12 :       if (TREE_CODE (DECL_SIZE (decl)) == INTEGER_CST)</span>
<span class="lineNum">    5569 </span><span class="lineNoCov">          0 :         constant_expression_warning (DECL_SIZE (decl));</span>
<span class="lineNum">    5570 </span>            :       else
<span class="lineNum">    5571 </span>            :         {
<span class="lineNum">    5572 </span><span class="lineCov">          6 :           error_at (DECL_SOURCE_LOCATION (decl),</span>
<span class="lineNum">    5573 </span>            :                     &quot;storage size of %qD isn%'t constant&quot;, decl);
<span class="lineNum">    5574 </span><span class="lineCov">          6 :           TREE_TYPE (decl) = error_mark_node;</span>
<span class="lineNum">    5575 </span>            :         }
<span class="lineNum">    5576 </span>            :     }
<span class="lineNum">    5577 </span>            : }
<span class="lineNum">    5578 </span>            : 
<span class="lineNum">    5579 </span>            : /* If a local static variable is declared in an inline function, or if
<span class="lineNum">    5580 </span>            :    we have a weak definition, we must endeavor to create only one
<span class="lineNum">    5581 </span>            :    instance of the variable at link-time.  */
<a name="5582"><span class="lineNum">    5582 </span>            : </a>
<span class="lineNum">    5583 </span>            : void
<span class="lineNum">    5584 </span><span class="lineCov">    4039366 : maybe_commonize_var (tree decl)</span>
<span class="lineNum">    5585 </span>            : {
<span class="lineNum">    5586 </span>            :   /* Don't mess with __FUNCTION__ and similar.  */
<span class="lineNum">    5587 </span><span class="lineCov">    4039366 :   if (DECL_ARTIFICIAL (decl))</span>
<span class="lineNum">    5588 </span>            :     return;
<span class="lineNum">    5589 </span>            : 
<span class="lineNum">    5590 </span>            :   /* Static data in a function with comdat linkage also has comdat
<span class="lineNum">    5591 </span>            :      linkage.  */
<span class="lineNum">    5592 </span><span class="lineCov">    3341165 :   if ((TREE_STATIC (decl)</span>
<span class="lineNum">    5593 </span><span class="lineCov">    1051582 :        &amp;&amp; DECL_FUNCTION_SCOPE_P (decl)</span>
<span class="lineNum">    5594 </span><span class="lineCov">      20766 :        &amp;&amp; vague_linkage_p (DECL_CONTEXT (decl)))</span>
<span class="lineNum">    5595 </span><span class="lineCov">    4385683 :       || (TREE_PUBLIC (decl) &amp;&amp; DECL_INLINE_VAR_P (decl)))</span>
<span class="lineNum">    5596 </span>            :     {
<span class="lineNum">    5597 </span><span class="lineCov">     277871 :       if (flag_weak)</span>
<span class="lineNum">    5598 </span>            :         {
<span class="lineNum">    5599 </span>            :           /* With weak symbols, we simply make the variable COMDAT;
<span class="lineNum">    5600 </span>            :              that will cause copies in multiple translations units to
<span class="lineNum">    5601 </span>            :              be merged.  */
<span class="lineNum">    5602 </span><span class="lineCov">     277865 :           comdat_linkage (decl);</span>
<span class="lineNum">    5603 </span>            :         }
<span class="lineNum">    5604 </span>            :       else
<span class="lineNum">    5605 </span>            :         {
<span class="lineNum">    5606 </span><span class="lineCov">          6 :           if (DECL_INITIAL (decl) == NULL_TREE</span>
<span class="lineNum">    5607 </span><span class="lineCov">          6 :               || DECL_INITIAL (decl) == error_mark_node)</span>
<span class="lineNum">    5608 </span>            :             {
<span class="lineNum">    5609 </span>            :               /* Without weak symbols, we can use COMMON to merge
<span class="lineNum">    5610 </span>            :                  uninitialized variables.  */
<span class="lineNum">    5611 </span><span class="lineCov">          6 :               TREE_PUBLIC (decl) = 1;</span>
<span class="lineNum">    5612 </span><span class="lineCov">          6 :               DECL_COMMON (decl) = 1;</span>
<span class="lineNum">    5613 </span>            :             }
<span class="lineNum">    5614 </span>            :           else
<span class="lineNum">    5615 </span>            :             {
<span class="lineNum">    5616 </span>            :               /* While for initialized variables, we must use internal
<span class="lineNum">    5617 </span>            :                  linkage -- which means that multiple copies will not
<span class="lineNum">    5618 </span>            :                  be merged.  */
<span class="lineNum">    5619 </span><span class="lineNoCov">          0 :               TREE_PUBLIC (decl) = 0;</span>
<span class="lineNum">    5620 </span><span class="lineNoCov">          0 :               DECL_COMMON (decl) = 0;</span>
<span class="lineNum">    5621 </span><span class="lineNoCov">          0 :               const char *msg;</span>
<span class="lineNum">    5622 </span><span class="lineNoCov">          0 :               if (DECL_INLINE_VAR_P (decl))</span>
<span class="lineNum">    5623 </span>            :                 msg = G_(&quot;sorry: semantics of inline variable &quot;
<span class="lineNum">    5624 </span>            :                          &quot;%q#D are wrong (you%'ll wind up with &quot;
<span class="lineNum">    5625 </span>            :                          &quot;multiple copies)&quot;);
<span class="lineNum">    5626 </span>            :               else
<span class="lineNum">    5627 </span>            :                 msg = G_(&quot;sorry: semantics of inline function &quot;
<span class="lineNum">    5628 </span>            :                          &quot;static data %q#D are wrong (you%'ll wind &quot;
<span class="lineNum">    5629 </span>            :                          &quot;up with multiple copies)&quot;);
<span class="lineNum">    5630 </span><span class="lineNoCov">          0 :               if (warning_at (DECL_SOURCE_LOCATION (decl), 0,</span>
<span class="lineNum">    5631 </span>            :                               msg, decl))
<span class="lineNum">    5632 </span><span class="lineNoCov">          0 :                 inform (DECL_SOURCE_LOCATION (decl),</span>
<span class="lineNum">    5633 </span>            :                         &quot;you can work around this by removing the initializer&quot;);
<span class="lineNum">    5634 </span>            :             }
<span class="lineNum">    5635 </span>            :         }
<span class="lineNum">    5636 </span>            :     }
<span class="lineNum">    5637 </span>            : }
<span class="lineNum">    5638 </span>            : 
<span class="lineNum">    5639 </span>            : /* Issue an error message if DECL is an uninitialized const variable.
<span class="lineNum">    5640 </span>            :    CONSTEXPR_CONTEXT_P is true when the function is called in a constexpr
<span class="lineNum">    5641 </span>            :    context from potential_constant_expression.  Returns true if all is well,
<span class="lineNum">    5642 </span>            :    false otherwise.  */
<a name="5643"><span class="lineNum">    5643 </span>            : </a>
<span class="lineNum">    5644 </span>            : bool
<span class="lineNum">    5645 </span><span class="lineCov">     674910 : check_for_uninitialized_const_var (tree decl, bool constexpr_context_p,</span>
<span class="lineNum">    5646 </span>            :                                    tsubst_flags_t complain)
<span class="lineNum">    5647 </span>            : {
<span class="lineNum">    5648 </span><span class="lineCov">     674910 :   tree type = strip_array_types (TREE_TYPE (decl));</span>
<span class="lineNum">    5649 </span>            : 
<span class="lineNum">    5650 </span>            :   /* ``Unless explicitly declared extern, a const object does not have
<span class="lineNum">    5651 </span>            :      external linkage and must be initialized. ($8.4; $12.1)'' ARM
<span class="lineNum">    5652 </span>            :      7.1.6 */
<span class="lineNum">    5653 </span><span class="lineCov">     674910 :   if (VAR_P (decl)</span>
<span class="lineNum">    5654 </span><span class="lineCov">     674910 :       &amp;&amp; !TYPE_REF_P (type)</span>
<span class="lineNum">    5655 </span><span class="lineCov">     674780 :       &amp;&amp; (constexpr_context_p</span>
<span class="lineNum">    5656 </span><span class="lineCov">     661113 :           || CP_TYPE_CONST_P (type) || var_in_constexpr_fn (decl))</span>
<span class="lineNum">    5657 </span><span class="lineCov">     809249 :       &amp;&amp; !DECL_NONTRIVIALLY_INITIALIZED_P (decl))</span>
<span class="lineNum">    5658 </span>            :     {
<span class="lineNum">    5659 </span><span class="lineCov">     120745 :       tree field = default_init_uninitialized_part (type);</span>
<span class="lineNum">    5660 </span><span class="lineCov">     120745 :       if (!field)</span>
<span class="lineNum">    5661 </span>            :         return true;
<span class="lineNum">    5662 </span>            : 
<span class="lineNum">    5663 </span><span class="lineCov">        114 :       if (!constexpr_context_p)</span>
<span class="lineNum">    5664 </span>            :         {
<span class="lineNum">    5665 </span><span class="lineCov">         51 :           if (CP_TYPE_CONST_P (type))</span>
<span class="lineNum">    5666 </span>            :             {
<span class="lineNum">    5667 </span><span class="lineCov">         48 :               if (complain &amp; tf_error)</span>
<span class="lineNum">    5668 </span><span class="lineCov">         48 :                 permerror (DECL_SOURCE_LOCATION (decl),</span>
<span class="lineNum">    5669 </span>            :                            &quot;uninitialized const %qD&quot;, decl);
<span class="lineNum">    5670 </span>            :             }
<span class="lineNum">    5671 </span>            :           else
<span class="lineNum">    5672 </span>            :             {
<span class="lineNum">    5673 </span><span class="lineCov">          3 :               if (!is_instantiation_of_constexpr (current_function_decl)</span>
<span class="lineNum">    5674 </span><span class="lineCov">          3 :                   &amp;&amp; (complain &amp; tf_error))</span>
<span class="lineNum">    5675 </span><span class="lineCov">          3 :                 error_at (DECL_SOURCE_LOCATION (decl),</span>
<span class="lineNum">    5676 </span>            :                           &quot;uninitialized variable %qD in %&lt;constexpr%&gt; &quot;
<span class="lineNum">    5677 </span>            :                           &quot;function&quot;, decl);
<span class="lineNum">    5678 </span><span class="lineCov">          3 :               cp_function_chain-&gt;invalid_constexpr = true;</span>
<span class="lineNum">    5679 </span>            :             }
<span class="lineNum">    5680 </span>            :         }
<span class="lineNum">    5681 </span><span class="lineCov">         63 :       else if (complain &amp; tf_error)</span>
<span class="lineNum">    5682 </span><span class="lineCov">          2 :         error_at (DECL_SOURCE_LOCATION (decl),</span>
<span class="lineNum">    5683 </span>            :                   &quot;uninitialized variable %qD in %&lt;constexpr%&gt; context&quot;,
<span class="lineNum">    5684 </span>            :                   decl);
<span class="lineNum">    5685 </span>            : 
<span class="lineNum">    5686 </span><span class="lineCov">        114 :       if (CLASS_TYPE_P (type) &amp;&amp; (complain &amp; tf_error))</span>
<span class="lineNum">    5687 </span>            :         {
<span class="lineNum">    5688 </span><span class="lineCov">         38 :           tree defaulted_ctor;</span>
<span class="lineNum">    5689 </span>            : 
<span class="lineNum">    5690 </span><span class="lineCov">         76 :           inform (DECL_SOURCE_LOCATION (TYPE_MAIN_DECL (type)),</span>
<span class="lineNum">    5691 </span>            :                   &quot;%q#T has no user-provided default constructor&quot;, type);
<span class="lineNum">    5692 </span><span class="lineCov">         38 :           defaulted_ctor = in_class_defaulted_default_constructor (type);</span>
<span class="lineNum">    5693 </span><span class="lineCov">         38 :           if (defaulted_ctor)</span>
<span class="lineNum">    5694 </span><span class="lineCov">         12 :             inform (DECL_SOURCE_LOCATION (defaulted_ctor),</span>
<span class="lineNum">    5695 </span>            :                     &quot;constructor is not user-provided because it is &quot;
<span class="lineNum">    5696 </span>            :                     &quot;explicitly defaulted in the class body&quot;);
<span class="lineNum">    5697 </span><span class="lineCov">         38 :           inform (DECL_SOURCE_LOCATION (field),</span>
<span class="lineNum">    5698 </span>            :                   &quot;and the implicitly-defined constructor does not &quot;
<span class="lineNum">    5699 </span>            :                   &quot;initialize %q#D&quot;, field);
<span class="lineNum">    5700 </span>            :         }
<span class="lineNum">    5701 </span>            : 
<span class="lineNum">    5702 </span><span class="lineCov">        114 :       return false;</span>
<span class="lineNum">    5703 </span>            :     }
<span class="lineNum">    5704 </span>            : 
<span class="lineNum">    5705 </span>            :   return true;
<span class="lineNum">    5706 </span>            : }
<span class="lineNum">    5707 </span>            : 
<span class="lineNum">    5708 </span>            : /* Structure holding the current initializer being processed by reshape_init.
<span class="lineNum">    5709 </span>            :    CUR is a pointer to the current element being processed, END is a pointer
<span class="lineNum">    5710 </span>            :    after the last element present in the initializer.  */
<span class="lineNum">    5711 </span>            : struct reshape_iter
<span class="lineNum">    5712 </span>            : {
<span class="lineNum">    5713 </span>            :   constructor_elt *cur;
<span class="lineNum">    5714 </span>            :   constructor_elt *end;
<span class="lineNum">    5715 </span>            : };
<span class="lineNum">    5716 </span>            : 
<span class="lineNum">    5717 </span>            : static tree reshape_init_r (tree, reshape_iter *, bool, tsubst_flags_t);
<span class="lineNum">    5718 </span>            : 
<span class="lineNum">    5719 </span>            : /* FIELD is a FIELD_DECL or NULL.  In the former case, the value
<span class="lineNum">    5720 </span>            :    returned is the next FIELD_DECL (possibly FIELD itself) that can be
<span class="lineNum">    5721 </span>            :    initialized.  If there are no more such fields, the return value
<span class="lineNum">    5722 </span>            :    will be NULL.  */
<a name="5723"><span class="lineNum">    5723 </span>            : </a>
<span class="lineNum">    5724 </span>            : tree
<span class="lineNum">    5725 </span><span class="lineCov">    1335840 : next_initializable_field (tree field)</span>
<span class="lineNum">    5726 </span>            : {
<span class="lineNum">    5727 </span><span class="lineCov">    2887524 :   while (field</span>
<span class="lineNum">    5728 </span><span class="lineCov">    2111682 :          &amp;&amp; (TREE_CODE (field) != FIELD_DECL</span>
<span class="lineNum">    5729 </span><span class="lineCov">    1849100 :              || DECL_UNNAMED_BIT_FIELD (field)</span>
<span class="lineNum">    5730 </span><span class="lineCov">     924543 :              || (DECL_ARTIFICIAL (field)</span>
<span class="lineNum">    5731 </span><span class="lineCov">     924543 :                  &amp;&amp; !(cxx_dialect &gt;= cxx17 &amp;&amp; DECL_FIELD_IS_BASE (field)))))</span>
<span class="lineNum">    5732 </span><span class="lineCov">     775842 :     field = DECL_CHAIN (field);</span>
<span class="lineNum">    5733 </span>            : 
<span class="lineNum">    5734 </span><span class="lineCov">    1335840 :   return field;</span>
<span class="lineNum">    5735 </span>            : }
<span class="lineNum">    5736 </span>            : 
<span class="lineNum">    5737 </span>            : /* Return true for [dcl.init.list] direct-list-initialization from
<span class="lineNum">    5738 </span>            :    single element of enumeration with a fixed underlying type.  */
<a name="5739"><span class="lineNum">    5739 </span>            : </a>
<span class="lineNum">    5740 </span>            : bool
<span class="lineNum">    5741 </span><span class="lineCov">   11579323 : is_direct_enum_init (tree type, tree init)</span>
<span class="lineNum">    5742 </span>            : {
<span class="lineNum">    5743 </span><span class="lineCov">   11579323 :   if (cxx_dialect &gt;= cxx17</span>
<span class="lineNum">    5744 </span><span class="lineCov">    1077247 :       &amp;&amp; TREE_CODE (type) == ENUMERAL_TYPE</span>
<span class="lineNum">    5745 </span><span class="lineCov">      53097 :       &amp;&amp; ENUM_FIXED_UNDERLYING_TYPE_P (type)</span>
<span class="lineNum">    5746 </span><span class="lineCov">      14485 :       &amp;&amp; TREE_CODE (init) == CONSTRUCTOR</span>
<span class="lineNum">    5747 </span><span class="lineCov">       1119 :       &amp;&amp; CONSTRUCTOR_IS_DIRECT_INIT (init)</span>
<span class="lineNum">    5748 </span><span class="lineCov">   11579707 :       &amp;&amp; CONSTRUCTOR_NELTS (init) == 1)</span>
<span class="lineNum">    5749 </span><span class="lineCov">        145 :     return true;</span>
<span class="lineNum">    5750 </span>            :   return false;
<span class="lineNum">    5751 </span>            : }
<span class="lineNum">    5752 </span>            : 
<span class="lineNum">    5753 </span>            : /* Subroutine of reshape_init_array and reshape_init_vector, which does
<span class="lineNum">    5754 </span>            :    the actual work. ELT_TYPE is the element type of the array. MAX_INDEX is an
<span class="lineNum">    5755 </span>            :    INTEGER_CST representing the size of the array minus one (the maximum index),
<span class="lineNum">    5756 </span>            :    or NULL_TREE if the array was declared without specifying the size. D is
<span class="lineNum">    5757 </span>            :    the iterator within the constructor.  */
<a name="5758"><span class="lineNum">    5758 </span>            : </a>
<span class="lineNum">    5759 </span>            : static tree
<span class="lineNum">    5760 </span><span class="lineCov">      56859 : reshape_init_array_1 (tree elt_type, tree max_index, reshape_iter *d,</span>
<span class="lineNum">    5761 </span>            :                       tsubst_flags_t complain)
<span class="lineNum">    5762 </span>            : {
<span class="lineNum">    5763 </span><span class="lineCov">      56859 :   tree new_init;</span>
<span class="lineNum">    5764 </span><span class="lineCov">      56859 :   bool sized_array_p = (max_index &amp;&amp; TREE_CONSTANT (max_index));</span>
<span class="lineNum">    5765 </span><span class="lineCov">      56859 :   unsigned HOST_WIDE_INT max_index_cst = 0;</span>
<span class="lineNum">    5766 </span><span class="lineCov">      56859 :   unsigned HOST_WIDE_INT index;</span>
<span class="lineNum">    5767 </span>            : 
<span class="lineNum">    5768 </span>            :   /* The initializer for an array is always a CONSTRUCTOR.  */
<span class="lineNum">    5769 </span><span class="lineCov">      56859 :   new_init = build_constructor (init_list_type_node, NULL);</span>
<span class="lineNum">    5770 </span>            : 
<span class="lineNum">    5771 </span><span class="lineCov">      56859 :   if (sized_array_p)</span>
<span class="lineNum">    5772 </span>            :     {
<span class="lineNum">    5773 </span>            :       /* Minus 1 is used for zero sized arrays.  */
<span class="lineNum">    5774 </span><span class="lineCov">      53177 :       if (integer_all_onesp (max_index))</span>
<span class="lineNum">    5775 </span>            :         return new_init;
<span class="lineNum">    5776 </span>            : 
<span class="lineNum">    5777 </span><span class="lineCov">      53156 :       if (tree_fits_uhwi_p (max_index))</span>
<span class="lineNum">    5778 </span><span class="lineCov">      53156 :         max_index_cst = tree_to_uhwi (max_index);</span>
<span class="lineNum">    5779 </span>            :       /* sizetype is sign extended, not zero extended.  */
<span class="lineNum">    5780 </span>            :       else
<span class="lineNum">    5781 </span><span class="lineNoCov">          0 :         max_index_cst = tree_to_uhwi (fold_convert (size_type_node, max_index));</span>
<span class="lineNum">    5782 </span>            :     }
<span class="lineNum">    5783 </span>            : 
<span class="lineNum">    5784 </span>            :   /* Loop until there are no more initializers.  */
<span class="lineNum">    5785 </span><span class="lineCov">     401167 :   for (index = 0;</span>
<span class="lineNum">    5786 </span><span class="lineCov">     401167 :        d-&gt;cur != d-&gt;end &amp;&amp; (!sized_array_p || index &lt;= max_index_cst);</span>
<span class="lineNum">    5787 </span>            :        ++index)
<span class="lineNum">    5788 </span>            :     {
<span class="lineNum">    5789 </span><span class="lineCov">     344372 :       tree elt_init;</span>
<span class="lineNum">    5790 </span><span class="lineCov">     344372 :       constructor_elt *old_cur = d-&gt;cur;</span>
<span class="lineNum">    5791 </span>            : 
<span class="lineNum">    5792 </span><span class="lineCov">     344372 :       check_array_designated_initializer (d-&gt;cur, index);</span>
<span class="lineNum">    5793 </span><span class="lineCov">     344372 :       elt_init = reshape_init_r (elt_type, d, /*first_initializer_p=*/false,</span>
<span class="lineNum">    5794 </span>            :                                  complain);
<span class="lineNum">    5795 </span><span class="lineCov">     344372 :       if (elt_init == error_mark_node)</span>
<span class="lineNum">    5796 </span><span class="lineCov">         40 :         return error_mark_node;</span>
<span class="lineNum">    5797 </span><span class="lineCov">     688664 :       CONSTRUCTOR_APPEND_ELT (CONSTRUCTOR_ELTS (new_init),</span>
<span class="lineNum">    5798 </span>            :                               size_int (index), elt_init);
<span class="lineNum">    5799 </span><span class="lineCov">     344332 :       if (!TREE_CONSTANT (elt_init))</span>
<span class="lineNum">    5800 </span><span class="lineCov">      61551 :         TREE_CONSTANT (new_init) = false;</span>
<span class="lineNum">    5801 </span>            : 
<span class="lineNum">    5802 </span>            :       /* This can happen with an invalid initializer (c++/54501).  */
<span class="lineNum">    5803 </span><span class="lineCov">     344332 :       if (d-&gt;cur == old_cur &amp;&amp; !sized_array_p)</span>
<span class="lineNum">    5804 </span>            :         break;
<span class="lineNum">    5805 </span>            :     }
<span class="lineNum">    5806 </span>            : 
<span class="lineNum">    5807 </span>            :   return new_init;
<span class="lineNum">    5808 </span>            : }
<span class="lineNum">    5809 </span>            : 
<span class="lineNum">    5810 </span>            : /* Subroutine of reshape_init_r, processes the initializers for arrays.
<span class="lineNum">    5811 </span>            :    Parameters are the same of reshape_init_r.  */
<a name="5812"><span class="lineNum">    5812 </span>            : </a>
<span class="lineNum">    5813 </span>            : static tree
<span class="lineNum">    5814 </span><span class="lineCov">      31317 : reshape_init_array (tree type, reshape_iter *d, tsubst_flags_t complain)</span>
<span class="lineNum">    5815 </span>            : {
<span class="lineNum">    5816 </span><span class="lineCov">      31317 :   tree max_index = NULL_TREE;</span>
<span class="lineNum">    5817 </span>            : 
<span class="lineNum">    5818 </span><span class="lineCov">      31317 :   gcc_assert (TREE_CODE (type) == ARRAY_TYPE);</span>
<span class="lineNum">    5819 </span>            : 
<span class="lineNum">    5820 </span><span class="lineCov">      62634 :   if (TYPE_DOMAIN (type))</span>
<span class="lineNum">    5821 </span><span class="lineCov">      27670 :     max_index = array_type_nelts (type);</span>
<span class="lineNum">    5822 </span>            : 
<span class="lineNum">    5823 </span><span class="lineCov">      31317 :   return reshape_init_array_1 (TREE_TYPE (type), max_index, d, complain);</span>
<span class="lineNum">    5824 </span>            : }
<span class="lineNum">    5825 </span>            : 
<span class="lineNum">    5826 </span>            : /* Subroutine of reshape_init_r, processes the initializers for vectors.
<span class="lineNum">    5827 </span>            :    Parameters are the same of reshape_init_r.  */
<a name="5828"><span class="lineNum">    5828 </span>            : </a>
<span class="lineNum">    5829 </span>            : static tree
<span class="lineNum">    5830 </span><span class="lineCov">      25551 : reshape_init_vector (tree type, reshape_iter *d, tsubst_flags_t complain)</span>
<span class="lineNum">    5831 </span>            : {
<span class="lineNum">    5832 </span><span class="lineCov">      25551 :   tree max_index = NULL_TREE;</span>
<span class="lineNum">    5833 </span>            : 
<span class="lineNum">    5834 </span><span class="lineCov">      25551 :   gcc_assert (VECTOR_TYPE_P (type));</span>
<span class="lineNum">    5835 </span>            : 
<span class="lineNum">    5836 </span><span class="lineCov">      25551 :   if (COMPOUND_LITERAL_P (d-&gt;cur-&gt;value))</span>
<span class="lineNum">    5837 </span>            :     {
<span class="lineNum">    5838 </span><span class="lineCov">          9 :       tree value = d-&gt;cur-&gt;value;</span>
<span class="lineNum">    5839 </span><span class="lineCov">          9 :       if (!same_type_p (TREE_TYPE (value), type))</span>
<span class="lineNum">    5840 </span>            :         {
<span class="lineNum">    5841 </span><span class="lineNoCov">          0 :           if (complain &amp; tf_error)</span>
<span class="lineNum">    5842 </span><span class="lineNoCov">          0 :             error (&quot;invalid type %qT as initializer for a vector of type %qT&quot;,</span>
<span class="lineNum">    5843 </span><span class="lineNoCov">          0 :                    TREE_TYPE (d-&gt;cur-&gt;value), type);</span>
<span class="lineNum">    5844 </span><span class="lineNoCov">          0 :           value = error_mark_node;</span>
<span class="lineNum">    5845 </span>            :         }
<span class="lineNum">    5846 </span><span class="lineCov">          9 :       ++d-&gt;cur;</span>
<span class="lineNum">    5847 </span><span class="lineCov">          9 :       return value;</span>
<span class="lineNum">    5848 </span>            :     }
<span class="lineNum">    5849 </span>            : 
<span class="lineNum">    5850 </span>            :   /* For a vector, we initialize it as an array of the appropriate size.  */
<span class="lineNum">    5851 </span><span class="lineCov">      25542 :   if (VECTOR_TYPE_P (type))</span>
<span class="lineNum">    5852 </span><span class="lineCov">      25542 :     max_index = size_int (TYPE_VECTOR_SUBPARTS (type) - 1);</span>
<span class="lineNum">    5853 </span>            : 
<span class="lineNum">    5854 </span><span class="lineCov">      25542 :   return reshape_init_array_1 (TREE_TYPE (type), max_index, d, complain);</span>
<span class="lineNum">    5855 </span>            : }
<span class="lineNum">    5856 </span>            : 
<span class="lineNum">    5857 </span>            : /* Subroutine of reshape_init_r, processes the initializers for classes
<span class="lineNum">    5858 </span>            :    or union. Parameters are the same of reshape_init_r.  */
<a name="5859"><span class="lineNum">    5859 </span>            : </a>
<span class="lineNum">    5860 </span>            : static tree
<span class="lineNum">    5861 </span><span class="lineCov">     411916 : reshape_init_class (tree type, reshape_iter *d, bool first_initializer_p,</span>
<span class="lineNum">    5862 </span>            :                     tsubst_flags_t complain)
<span class="lineNum">    5863 </span>            : {
<span class="lineNum">    5864 </span><span class="lineCov">     411916 :   tree field;</span>
<span class="lineNum">    5865 </span><span class="lineCov">     411916 :   tree new_init;</span>
<span class="lineNum">    5866 </span>            : 
<span class="lineNum">    5867 </span><span class="lineCov">     411916 :   gcc_assert (CLASS_TYPE_P (type));</span>
<span class="lineNum">    5868 </span>            : 
<span class="lineNum">    5869 </span>            :   /* The initializer for a class is always a CONSTRUCTOR.  */
<span class="lineNum">    5870 </span><span class="lineCov">     411916 :   new_init = build_constructor (init_list_type_node, NULL);</span>
<span class="lineNum">    5871 </span><span class="lineCov">     416016 :   field = next_initializable_field (TYPE_FIELDS (type));</span>
<span class="lineNum">    5872 </span>            : 
<span class="lineNum">    5873 </span><span class="lineCov">     411916 :   if (!field)</span>
<span class="lineNum">    5874 </span>            :     {
<span class="lineNum">    5875 </span>            :       /* [dcl.init.aggr]
<span class="lineNum">    5876 </span>            : 
<span class="lineNum">    5877 </span>            :         An initializer for an aggregate member that is an
<span class="lineNum">    5878 </span>            :         empty class shall have the form of an empty
<span class="lineNum">    5879 </span>            :         initializer-list {}.  */
<span class="lineNum">    5880 </span><span class="lineCov">         74 :       if (!first_initializer_p)</span>
<span class="lineNum">    5881 </span>            :         {
<span class="lineNum">    5882 </span><span class="lineCov">         63 :           if (complain &amp; tf_error)</span>
<span class="lineNum">    5883 </span><span class="lineCov">         11 :             error (&quot;initializer for %qT must be brace-enclosed&quot;, type);</span>
<span class="lineNum">    5884 </span><span class="lineCov">         63 :           return error_mark_node;</span>
<span class="lineNum">    5885 </span>            :         }
<span class="lineNum">    5886 </span>            :       return new_init;
<span class="lineNum">    5887 </span>            :     }
<span class="lineNum">    5888 </span>            : 
<span class="lineNum">    5889 </span>            :   /* Loop through the initializable fields, gathering initializers.  */
<span class="lineNum">    5890 </span><span class="lineCov">    1321515 :   while (d-&gt;cur != d-&gt;end)</span>
<span class="lineNum">    5891 </span>            :     {
<span class="lineNum">    5892 </span><span class="lineCov">     914040 :       tree field_init;</span>
<span class="lineNum">    5893 </span><span class="lineCov">     914040 :       constructor_elt *old_cur = d-&gt;cur;</span>
<span class="lineNum">    5894 </span>            : 
<span class="lineNum">    5895 </span>            :       /* Handle designated initializers, as an extension.  */
<span class="lineNum">    5896 </span><span class="lineCov">     914040 :       if (d-&gt;cur-&gt;index)</span>
<span class="lineNum">    5897 </span>            :         {
<span class="lineNum">    5898 </span><span class="lineCov">      41473 :           if (d-&gt;cur-&gt;index == error_mark_node)</span>
<span class="lineNum">    5899 </span><span class="lineCov">          5 :             return error_mark_node;</span>
<span class="lineNum">    5900 </span>            : 
<span class="lineNum">    5901 </span><span class="lineCov">      41468 :           if (TREE_CODE (d-&gt;cur-&gt;index) == FIELD_DECL)</span>
<span class="lineNum">    5902 </span>            :             {
<span class="lineNum">    5903 </span>            :               /* We already reshaped this.  */
<span class="lineNum">    5904 </span><span class="lineCov">         78 :               if (field != d-&gt;cur-&gt;index)</span>
<span class="lineNum">    5905 </span>            :                 {
<span class="lineNum">    5906 </span><span class="lineCov">          4 :                   tree id = DECL_NAME (d-&gt;cur-&gt;index);</span>
<span class="lineNum">    5907 </span><span class="lineCov">          4 :                   gcc_assert (id);</span>
<span class="lineNum">    5908 </span><span class="lineCov">          4 :                   gcc_checking_assert (d-&gt;cur-&gt;index</span>
<span class="lineNum">    5909 </span>            :                                        == get_class_binding (type, id, false));
<span class="lineNum">    5910 </span><span class="lineCov">          4 :                   field = d-&gt;cur-&gt;index;</span>
<span class="lineNum">    5911 </span>            :                 }
<span class="lineNum">    5912 </span>            :             }
<span class="lineNum">    5913 </span><span class="lineCov">      41390 :           else if (TREE_CODE (d-&gt;cur-&gt;index) == IDENTIFIER_NODE)</span>
<span class="lineNum">    5914 </span><span class="lineCov">      41384 :             field = get_class_binding (type, d-&gt;cur-&gt;index, false);</span>
<span class="lineNum">    5915 </span>            :           else
<span class="lineNum">    5916 </span>            :             {
<span class="lineNum">    5917 </span><span class="lineCov">          6 :               if (complain &amp; tf_error)</span>
<span class="lineNum">    5918 </span><span class="lineCov">          6 :                 error (&quot;%&lt;[%E] =%&gt; used in a GNU-style designated initializer&quot;</span>
<span class="lineNum">    5919 </span>            :                        &quot; for class %qT&quot;, d-&gt;cur-&gt;index, type);
<span class="lineNum">    5920 </span><span class="lineCov">          6 :               return error_mark_node;</span>
<span class="lineNum">    5921 </span>            :             }
<span class="lineNum">    5922 </span>            : 
<span class="lineNum">    5923 </span><span class="lineCov">      41462 :           if (!field || TREE_CODE (field) != FIELD_DECL)</span>
<span class="lineNum">    5924 </span>            :             {
<span class="lineNum">    5925 </span><span class="lineCov">          9 :               if (complain &amp; tf_error)</span>
<span class="lineNum">    5926 </span><span class="lineCov">          6 :                 error (&quot;%qT has no non-static data member named %qD&quot;, type,</span>
<span class="lineNum">    5927 </span><span class="lineCov">          3 :                        d-&gt;cur-&gt;index);</span>
<span class="lineNum">    5928 </span><span class="lineCov">          9 :               return error_mark_node;</span>
<span class="lineNum">    5929 </span>            :             }
<span class="lineNum">    5930 </span>            :         }
<span class="lineNum">    5931 </span>            : 
<span class="lineNum">    5932 </span>            :       /* If we processed all the member of the class, we are done.  */
<span class="lineNum">    5933 </span><span class="lineCov">     914020 :       if (!field)</span>
<span class="lineNum">    5934 </span>            :         break;
<span class="lineNum">    5935 </span>            : 
<span class="lineNum">    5936 </span><span class="lineCov">     913849 :       field_init = reshape_init_r (TREE_TYPE (field), d,</span>
<span class="lineNum">    5937 </span>            :                                    /*first_initializer_p=*/false, complain);
<span class="lineNum">    5938 </span><span class="lineCov">     913849 :       if (field_init == error_mark_node)</span>
<span class="lineNum">    5939 </span><span class="lineCov">         83 :         return error_mark_node;</span>
<span class="lineNum">    5940 </span>            : 
<span class="lineNum">    5941 </span><span class="lineCov">     913766 :       if (d-&gt;cur == old_cur &amp;&amp; d-&gt;cur-&gt;index)</span>
<span class="lineNum">    5942 </span>            :         {
<span class="lineNum">    5943 </span>            :           /* This can happen with an invalid initializer for a flexible
<span class="lineNum">    5944 </span>            :              array member (c++/54441).  */
<span class="lineNum">    5945 </span><span class="lineNoCov">          0 :           if (complain &amp; tf_error)</span>
<span class="lineNum">    5946 </span><span class="lineNoCov">          0 :             error (&quot;invalid initializer for %q#D&quot;, field);</span>
<span class="lineNum">    5947 </span><span class="lineNoCov">          0 :           return error_mark_node;</span>
<span class="lineNum">    5948 </span>            :         }
<span class="lineNum">    5949 </span>            : 
<span class="lineNum">    5950 </span><span class="lineCov">     913766 :       CONSTRUCTOR_APPEND_ELT (CONSTRUCTOR_ELTS (new_init), field, field_init);</span>
<span class="lineNum">    5951 </span>            : 
<span class="lineNum">    5952 </span>            :       /* [dcl.init.aggr]
<span class="lineNum">    5953 </span>            : 
<span class="lineNum">    5954 </span>            :         When a union  is  initialized with a brace-enclosed
<span class="lineNum">    5955 </span>            :         initializer, the braces shall only contain an
<span class="lineNum">    5956 </span>            :         initializer for the first member of the union.  */
<span class="lineNum">    5957 </span><span class="lineCov">     913766 :       if (TREE_CODE (type) == UNION_TYPE)</span>
<span class="lineNum">    5958 </span>            :         break;
<span class="lineNum">    5959 </span>            : 
<span class="lineNum">    5960 </span><span class="lineCov">     909673 :       field = next_initializable_field (DECL_CHAIN (field));</span>
<span class="lineNum">    5961 </span>            :     }
<span class="lineNum">    5962 </span>            : 
<span class="lineNum">    5963 </span>            :   return new_init;
<span class="lineNum">    5964 </span>            : }
<span class="lineNum">    5965 </span>            : 
<span class="lineNum">    5966 </span>            : /* Subroutine of reshape_init_r.  We're in a context where C99 initializer
<span class="lineNum">    5967 </span>            :    designators are not valid; either complain or return true to indicate
<span class="lineNum">    5968 </span>            :    that reshape_init_r should return error_mark_node.  */
<a name="5969"><span class="lineNum">    5969 </span>            : </a>
<span class="lineNum">    5970 </span>            : static bool
<span class="lineNum">    5971 </span><span class="lineNoCov">          0 : has_designator_problem (reshape_iter *d, tsubst_flags_t complain)</span>
<span class="lineNum">    5972 </span>            : {
<span class="lineNum">    5973 </span><span class="lineNoCov">          0 :   if (d-&gt;cur-&gt;index)</span>
<span class="lineNum">    5974 </span>            :     {
<span class="lineNum">    5975 </span><span class="lineCov">         21 :       if (complain &amp; tf_error)</span>
<span class="lineNum">    5976 </span><span class="lineNoCov">          0 :         error (&quot;C99 designator %qE outside aggregate initializer&quot;,</span>
<span class="lineNum">    5977 </span>            :                d-&gt;cur-&gt;index);
<span class="lineNum">    5978 </span>            :       else
<span class="lineNum">    5979 </span>            :         return true;
<span class="lineNum">    5980 </span>            :     }
<span class="lineNum">    5981 </span>            :   return false;
<span class="lineNum">    5982 </span>            : }
<span class="lineNum">    5983 </span>            : 
<span class="lineNum">    5984 </span>            : /* Subroutine of reshape_init, which processes a single initializer (part of
<span class="lineNum">    5985 </span>            :    a CONSTRUCTOR). TYPE is the type of the variable being initialized, D is the
<span class="lineNum">    5986 </span>            :    iterator within the CONSTRUCTOR which points to the initializer to process.
<span class="lineNum">    5987 </span>            :    FIRST_INITIALIZER_P is true if this is the first initializer of the
<span class="lineNum">    5988 </span>            :    outermost CONSTRUCTOR node.  */
<a name="5989"><span class="lineNum">    5989 </span>            : </a>
<span class="lineNum">    5990 </span>            : static tree
<span class="lineNum">    5991 </span><span class="lineCov">    1726923 : reshape_init_r (tree type, reshape_iter *d, bool first_initializer_p,</span>
<span class="lineNum">    5992 </span>            :                 tsubst_flags_t complain)
<span class="lineNum">    5993 </span>            : {
<span class="lineNum">    5994 </span><span class="lineCov">    1726923 :   tree init = d-&gt;cur-&gt;value;</span>
<span class="lineNum">    5995 </span>            : 
<span class="lineNum">    5996 </span><span class="lineCov">    1726923 :   if (error_operand_p (init))</span>
<span class="lineNum">    5997 </span>            :     return error_mark_node;
<span class="lineNum">    5998 </span>            : 
<span class="lineNum">    5999 </span><span class="lineCov">     468634 :   if (first_initializer_p &amp;&amp; !CP_AGGREGATE_TYPE_P (type)</span>
<span class="lineNum">    6000 </span><span class="lineCov">    1727304 :       &amp;&amp; has_designator_problem (d, complain))</span>
<span class="lineNum">    6001 </span>            :     return error_mark_node;
<span class="lineNum">    6002 </span>            : 
<span class="lineNum">    6003 </span><span class="lineCov">    1726852 :   if (TREE_CODE (type) == COMPLEX_TYPE)</span>
<span class="lineNum">    6004 </span>            :     {
<span class="lineNum">    6005 </span>            :       /* A complex type can be initialized from one or two initializers,
<span class="lineNum">    6006 </span>            :          but braces are not elided.  */
<span class="lineNum">    6007 </span><span class="lineCov">         49 :       d-&gt;cur++;</span>
<span class="lineNum">    6008 </span><span class="lineCov">         49 :       if (BRACE_ENCLOSED_INITIALIZER_P (init))</span>
<span class="lineNum">    6009 </span>            :         {
<span class="lineNum">    6010 </span><span class="lineCov">         14 :           if (CONSTRUCTOR_NELTS (init) &gt; 2)</span>
<span class="lineNum">    6011 </span>            :             {
<span class="lineNum">    6012 </span><span class="lineNoCov">          0 :               if (complain &amp; tf_error)</span>
<span class="lineNum">    6013 </span><span class="lineNoCov">          0 :                 error (&quot;too many initializers for %qT&quot;, type);</span>
<span class="lineNum">    6014 </span>            :               else
<span class="lineNum">    6015 </span><span class="lineNoCov">          0 :                 return error_mark_node;</span>
<span class="lineNum">    6016 </span>            :             }
<span class="lineNum">    6017 </span>            :         }
<span class="lineNum">    6018 </span><span class="lineCov">         42 :       else if (first_initializer_p &amp;&amp; d-&gt;cur != d-&gt;end)</span>
<span class="lineNum">    6019 </span>            :         {
<span class="lineNum">    6020 </span><span class="lineCov">         20 :           vec&lt;constructor_elt, va_gc&gt; *v = 0;</span>
<span class="lineNum">    6021 </span><span class="lineCov">         20 :           CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, init);</span>
<span class="lineNum">    6022 </span><span class="lineCov">         20 :           CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, d-&gt;cur-&gt;value);</span>
<span class="lineNum">    6023 </span><span class="lineCov">         26 :           if (has_designator_problem (d, complain))</span>
<span class="lineNum">    6024 </span><span class="lineNoCov">          0 :             return error_mark_node;</span>
<span class="lineNum">    6025 </span><span class="lineCov">         20 :           d-&gt;cur++;</span>
<span class="lineNum">    6026 </span><span class="lineCov">         20 :           init = build_constructor (init_list_type_node, v);</span>
<span class="lineNum">    6027 </span>            :         }
<span class="lineNum">    6028 </span><span class="lineCov">         49 :       return init;</span>
<span class="lineNum">    6029 </span>            :     }
<span class="lineNum">    6030 </span>            : 
<span class="lineNum">    6031 </span>            :   /* A non-aggregate type is always initialized with a single
<span class="lineNum">    6032 </span>            :      initializer.  */
<span class="lineNum">    6033 </span><span class="lineCov">    1726803 :   if (!CP_AGGREGATE_TYPE_P (type))</span>
<span class="lineNum">    6034 </span>            :     {
<span class="lineNum">    6035 </span>            :       /* It is invalid to initialize a non-aggregate type with a
<span class="lineNum">    6036 </span>            :          brace-enclosed initializer before C++0x.
<span class="lineNum">    6037 </span>            :          We need to check for BRACE_ENCLOSED_INITIALIZER_P here because
<span class="lineNum">    6038 </span>            :          of g++.old-deja/g++.mike/p7626.C: a pointer-to-member constant is
<span class="lineNum">    6039 </span>            :          a CONSTRUCTOR (with a record type).  */
<span class="lineNum">    6040 </span><span class="lineCov">    1004535 :       if (TREE_CODE (init) == CONSTRUCTOR</span>
<span class="lineNum">    6041 </span>            :           /* Don't complain about a capture-init.  */
<span class="lineNum">    6042 </span><span class="lineCov">       9648 :           &amp;&amp; !CONSTRUCTOR_IS_DIRECT_INIT (init)</span>
<span class="lineNum">    6043 </span><span class="lineCov">    1007750 :           &amp;&amp; BRACE_ENCLOSED_INITIALIZER_P (init))  /* p7626.C */</span>
<span class="lineNum">    6044 </span>            :         {
<span class="lineNum">    6045 </span><span class="lineCov">       3200 :           if (SCALAR_TYPE_P (type))</span>
<span class="lineNum">    6046 </span>            :             {
<span class="lineNum">    6047 </span><span class="lineCov">         58 :               if (cxx_dialect &lt; cxx11</span>
<span class="lineNum">    6048 </span>            :                   /* Isn't value-initialization.  */
<span class="lineNum">    6049 </span><span class="lineCov">         58 :                   || CONSTRUCTOR_NELTS (init) &gt; 0)</span>
<span class="lineNum">    6050 </span>            :                 {
<span class="lineNum">    6051 </span><span class="lineCov">         39 :                   if (complain &amp; tf_error)</span>
<span class="lineNum">    6052 </span><span class="lineCov">         39 :                     error (&quot;braces around scalar initializer for type %qT&quot;,</span>
<span class="lineNum">    6053 </span>            :                            type);
<span class="lineNum">    6054 </span><span class="lineCov">         39 :                   init = error_mark_node;</span>
<span class="lineNum">    6055 </span>            :                 }
<span class="lineNum">    6056 </span>            :             }
<span class="lineNum">    6057 </span>            :           else
<span class="lineNum">    6058 </span><span class="lineCov">       3142 :             maybe_warn_cpp0x (CPP0X_INITIALIZER_LISTS);</span>
<span class="lineNum">    6059 </span>            :         }
<span class="lineNum">    6060 </span>            : 
<span class="lineNum">    6061 </span><span class="lineCov">    1004535 :       d-&gt;cur++;</span>
<span class="lineNum">    6062 </span><span class="lineCov">    1004535 :       return init;</span>
<span class="lineNum">    6063 </span>            :     }
<span class="lineNum">    6064 </span>            : 
<span class="lineNum">    6065 </span>            :   /* &quot;If T is a class type and the initializer list has a single element of
<span class="lineNum">    6066 </span>            :      type cv U, where U is T or a class derived from T, the object is
<span class="lineNum">    6067 </span>            :      initialized from that element.&quot;  Even if T is an aggregate.  */
<span class="lineNum">    6068 </span><span class="lineCov">     705125 :   if (cxx_dialect &gt;= cxx11 &amp;&amp; (CLASS_TYPE_P (type) || VECTOR_TYPE_P (type))</span>
<span class="lineNum">    6069 </span><span class="lineCov">     655331 :       &amp;&amp; first_initializer_p</span>
<span class="lineNum">    6070 </span><span class="lineCov">     427640 :       &amp;&amp; d-&gt;end - d-&gt;cur == 1</span>
<span class="lineNum">    6071 </span><span class="lineCov">     790322 :       &amp;&amp; reference_related_p (type, TREE_TYPE (init)))</span>
<span class="lineNum">    6072 </span>            :     {
<span class="lineNum">    6073 </span><span class="lineCov">         23 :       d-&gt;cur++;</span>
<span class="lineNum">    6074 </span><span class="lineCov">         23 :       return init;</span>
<span class="lineNum">    6075 </span>            :     }
<span class="lineNum">    6076 </span>            : 
<span class="lineNum">    6077 </span>            :   /* [dcl.init.aggr]
<span class="lineNum">    6078 </span>            : 
<span class="lineNum">    6079 </span>            :      All implicit type conversions (clause _conv_) are considered when
<span class="lineNum">    6080 </span>            :      initializing the aggregate member with an initializer from an
<span class="lineNum">    6081 </span>            :      initializer-list.  If the initializer can initialize a member,
<span class="lineNum">    6082 </span>            :      the member is initialized.  Otherwise, if the member is itself a
<span class="lineNum">    6083 </span>            :      non-empty subaggregate, brace elision is assumed and the
<span class="lineNum">    6084 </span>            :      initializer is considered for the initialization of the first
<span class="lineNum">    6085 </span>            :      member of the subaggregate.  */
<span class="lineNum">    6086 </span><span class="lineCov">     722245 :   if (TREE_CODE (init) != CONSTRUCTOR</span>
<span class="lineNum">    6087 </span>            :       /* But don't try this for the first initializer, since that would be
<span class="lineNum">    6088 </span>            :          looking through the outermost braces; A a2 = { a1 }; is not a
<span class="lineNum">    6089 </span>            :          valid aggregate initialization.  */
<span class="lineNum">    6090 </span><span class="lineCov">     293212 :       &amp;&amp; !first_initializer_p</span>
<span class="lineNum">    6091 </span><span class="lineCov">     723320 :       &amp;&amp; (same_type_ignoring_top_level_qualifiers_p (type, TREE_TYPE (init))</span>
<span class="lineNum">    6092 </span><span class="lineCov">        730 :           || can_convert_arg (type, TREE_TYPE (init), init, LOOKUP_NORMAL,</span>
<span class="lineNum">    6093 </span>            :                               complain)))
<span class="lineNum">    6094 </span>            :     {
<span class="lineNum">    6095 </span><span class="lineCov">        349 :       d-&gt;cur++;</span>
<span class="lineNum">    6096 </span><span class="lineCov">        349 :       return init;</span>
<span class="lineNum">    6097 </span>            :     }
<span class="lineNum">    6098 </span>            : 
<span class="lineNum">    6099 </span>            :   /* [dcl.init.string]
<span class="lineNum">    6100 </span>            : 
<span class="lineNum">    6101 </span>            :       A char array (whether plain char, signed char, or unsigned char)
<span class="lineNum">    6102 </span>            :       can be initialized by a string-literal (optionally enclosed in
<span class="lineNum">    6103 </span>            :       braces); a wchar_t array can be initialized by a wide
<span class="lineNum">    6104 </span>            :       string-literal (optionally enclosed in braces).  */
<span class="lineNum">    6105 </span><span class="lineCov">     721896 :   if (TREE_CODE (type) == ARRAY_TYPE</span>
<span class="lineNum">    6106 </span><span class="lineCov">     721896 :       &amp;&amp; char_type_p (TYPE_MAIN_VARIANT (TREE_TYPE (type))))</span>
<span class="lineNum">    6107 </span>            :     {
<span class="lineNum">    6108 </span><span class="lineCov">       1360 :       tree str_init = init;</span>
<span class="lineNum">    6109 </span>            : 
<span class="lineNum">    6110 </span>            :       /* Strip one level of braces if and only if they enclose a single
<span class="lineNum">    6111 </span>            :          element (as allowed by [dcl.init.string]).  */
<span class="lineNum">    6112 </span><span class="lineCov">       1360 :       if (!first_initializer_p</span>
<span class="lineNum">    6113 </span><span class="lineCov">        327 :           &amp;&amp; TREE_CODE (str_init) == CONSTRUCTOR</span>
<span class="lineNum">    6114 </span><span class="lineCov">       1774 :           &amp;&amp; CONSTRUCTOR_NELTS (str_init) == 1)</span>
<span class="lineNum">    6115 </span>            :         {
<span class="lineNum">    6116 </span><span class="lineCov">         90 :           str_init = (*CONSTRUCTOR_ELTS (str_init))[0].value;</span>
<span class="lineNum">    6117 </span>            :         }
<span class="lineNum">    6118 </span>            : 
<span class="lineNum">    6119 </span>            :       /* If it's a string literal, then it's the initializer for the array
<span class="lineNum">    6120 </span>            :          as a whole. Otherwise, continue with normal initialization for
<span class="lineNum">    6121 </span>            :          array types (one value per array element).  */
<span class="lineNum">    6122 </span><span class="lineCov">       1360 :       if (TREE_CODE (str_init) == STRING_CST)</span>
<span class="lineNum">    6123 </span>            :         {
<span class="lineNum">    6124 </span><span class="lineCov">        152 :           if (has_designator_problem (d, complain))</span>
<span class="lineNum">    6125 </span><span class="lineNoCov">          0 :             return error_mark_node;</span>
<span class="lineNum">    6126 </span><span class="lineCov">        149 :           d-&gt;cur++;</span>
<span class="lineNum">    6127 </span><span class="lineCov">        149 :           return str_init;</span>
<span class="lineNum">    6128 </span>            :         }
<span class="lineNum">    6129 </span>            :     }
<span class="lineNum">    6130 </span>            : 
<span class="lineNum">    6131 </span>            :   /* The following cases are about aggregates. If we are not within a full
<span class="lineNum">    6132 </span>            :      initializer already, and there is not a CONSTRUCTOR, it means that there
<span class="lineNum">    6133 </span>            :      is a missing set of braces (that is, we are processing the case for
<span class="lineNum">    6134 </span>            :      which reshape_init exists).  */
<span class="lineNum">    6135 </span><span class="lineCov">     721747 :   if (!first_initializer_p)</span>
<span class="lineNum">    6136 </span>            :     {
<span class="lineNum">    6137 </span><span class="lineCov">     253594 :       if (TREE_CODE (init) == CONSTRUCTOR)</span>
<span class="lineNum">    6138 </span>            :         {
<span class="lineNum">    6139 </span><span class="lineCov">     252978 :           if (TREE_TYPE (init) &amp;&amp; TYPE_PTRMEMFUNC_P (TREE_TYPE (init)))</span>
<span class="lineNum">    6140 </span>            :             /* There is no need to reshape pointer-to-member function
<span class="lineNum">    6141 </span>            :                initializers, as they are always constructed correctly
<span class="lineNum">    6142 </span>            :                by the front end.  */
<span class="lineNum">    6143 </span>            :            ;
<span class="lineNum">    6144 </span><span class="lineCov">     505944 :           else if (COMPOUND_LITERAL_P (init))</span>
<span class="lineNum">    6145 </span>            :           /* For a nested compound literal, there is no need to reshape since
<span class="lineNum">    6146 </span>            :              brace elision is not allowed. Even if we decided to allow it,
<span class="lineNum">    6147 </span>            :              we should add a call to reshape_init in finish_compound_literal,
<span class="lineNum">    6148 </span>            :              before calling digest_init, so changing this code would still
<span class="lineNum">    6149 </span>            :              not be necessary.  */
<span class="lineNum">    6150 </span><span class="lineCov">         18 :             gcc_assert (!BRACE_ENCLOSED_INITIALIZER_P (init));</span>
<span class="lineNum">    6151 </span>            :           else
<span class="lineNum">    6152 </span>            :             {
<span class="lineNum">    6153 </span><span class="lineCov">     252963 :               ++d-&gt;cur;</span>
<span class="lineNum">    6154 </span><span class="lineCov">     252963 :               gcc_assert (BRACE_ENCLOSED_INITIALIZER_P (init));</span>
<span class="lineNum">    6155 </span><span class="lineCov">     252963 :               return reshape_init (type, init, complain);</span>
<span class="lineNum">    6156 </span>            :             }
<span class="lineNum">    6157 </span>            :         }
<span class="lineNum">    6158 </span>            : 
<span class="lineNum">    6159 </span><span class="lineCov">        631 :       if (complain &amp; tf_warning)</span>
<span class="lineNum">    6160 </span><span class="lineCov">        615 :         warning (OPT_Wmissing_braces,</span>
<span class="lineNum">    6161 </span>            :                  &quot;missing braces around initializer for %qT&quot;,
<span class="lineNum">    6162 </span>            :                  type);
<span class="lineNum">    6163 </span>            :     }
<span class="lineNum">    6164 </span>            : 
<span class="lineNum">    6165 </span>            :   /* Dispatch to specialized routines.  */
<span class="lineNum">    6166 </span><span class="lineCov">     468784 :   if (CLASS_TYPE_P (type))</span>
<span class="lineNum">    6167 </span><span class="lineCov">     411916 :     return reshape_init_class (type, d, first_initializer_p, complain);</span>
<span class="lineNum">    6168 </span><span class="lineCov">      56868 :   else if (TREE_CODE (type) == ARRAY_TYPE)</span>
<span class="lineNum">    6169 </span><span class="lineCov">      31317 :     return reshape_init_array (type, d, complain);</span>
<span class="lineNum">    6170 </span><span class="lineCov">      25551 :   else if (VECTOR_TYPE_P (type))</span>
<span class="lineNum">    6171 </span><span class="lineCov">      25551 :     return reshape_init_vector (type, d, complain);</span>
<span class="lineNum">    6172 </span>            :   else
<span class="lineNum">    6173 </span><span class="lineNoCov">          0 :     gcc_unreachable();</span>
<span class="lineNum">    6174 </span>            : }
<span class="lineNum">    6175 </span>            : 
<span class="lineNum">    6176 </span>            : /* Undo the brace-elision allowed by [dcl.init.aggr] in a
<span class="lineNum">    6177 </span>            :    brace-enclosed aggregate initializer.
<span class="lineNum">    6178 </span>            : 
<span class="lineNum">    6179 </span>            :    INIT is the CONSTRUCTOR containing the list of initializers describing
<span class="lineNum">    6180 </span>            :    a brace-enclosed initializer for an entity of the indicated aggregate TYPE.
<span class="lineNum">    6181 </span>            :    It may not presently match the shape of the TYPE; for example:
<span class="lineNum">    6182 </span>            : 
<span class="lineNum">    6183 </span>            :      struct S { int a; int b; };
<span class="lineNum">    6184 </span>            :      struct S a[] = { 1, 2, 3, 4 };
<span class="lineNum">    6185 </span>            : 
<span class="lineNum">    6186 </span>            :    Here INIT will hold a vector of four elements, rather than a
<span class="lineNum">    6187 </span>            :    vector of two elements, each itself a vector of two elements.  This
<span class="lineNum">    6188 </span>            :    routine transforms INIT from the former form into the latter.  The
<span class="lineNum">    6189 </span>            :    revised CONSTRUCTOR node is returned.  */
<a name="6190"><span class="lineNum">    6190 </span>            : </a>
<span class="lineNum">    6191 </span>            : tree
<span class="lineNum">    6192 </span><span class="lineCov">     527227 : reshape_init (tree type, tree init, tsubst_flags_t complain)</span>
<span class="lineNum">    6193 </span>            : {
<span class="lineNum">    6194 </span><span class="lineCov">     527227 :   vec&lt;constructor_elt, va_gc&gt; *v;</span>
<span class="lineNum">    6195 </span><span class="lineCov">     527227 :   reshape_iter d;</span>
<span class="lineNum">    6196 </span><span class="lineCov">     527227 :   tree new_init;</span>
<span class="lineNum">    6197 </span>            : 
<span class="lineNum">    6198 </span><span class="lineCov">     527227 :   gcc_assert (BRACE_ENCLOSED_INITIALIZER_P (init));</span>
<span class="lineNum">    6199 </span>            : 
<span class="lineNum">    6200 </span><span class="lineCov">     527227 :   v = CONSTRUCTOR_ELTS (init);</span>
<span class="lineNum">    6201 </span>            : 
<span class="lineNum">    6202 </span>            :   /* An empty constructor does not need reshaping, and it is always a valid
<span class="lineNum">    6203 </span>            :      initializer.  */
<span class="lineNum">    6204 </span><span class="lineCov">     527227 :   if (vec_safe_is_empty (v))</span>
<span class="lineNum">    6205 </span>            :     return init;
<span class="lineNum">    6206 </span>            : 
<span class="lineNum">    6207 </span>            :   /* Handle [dcl.init.list] direct-list-initialization from
<span class="lineNum">    6208 </span>            :      single element of enumeration with a fixed underlying type.  */
<span class="lineNum">    6209 </span><span class="lineCov">     468847 :   if (is_direct_enum_init (type, init))</span>
<span class="lineNum">    6210 </span>            :     {
<span class="lineNum">    6211 </span><span class="lineCov">        145 :       tree elt = CONSTRUCTOR_ELT (init, 0)-&gt;value;</span>
<span class="lineNum">    6212 </span><span class="lineCov">        145 :       type = cv_unqualified (type);</span>
<span class="lineNum">    6213 </span><span class="lineCov">        145 :       if (check_narrowing (ENUM_UNDERLYING_TYPE (type), elt, complain))</span>
<span class="lineNum">    6214 </span>            :         {
<span class="lineNum">    6215 </span><span class="lineCov">        145 :           warning_sentinel w (warn_useless_cast);</span>
<span class="lineNum">    6216 </span><span class="lineCov">        145 :           warning_sentinel w2 (warn_ignored_qualifiers);</span>
<span class="lineNum">    6217 </span><span class="lineCov">        145 :           return cp_build_c_cast (type, elt, tf_warning_or_error);</span>
<span class="lineNum">    6218 </span>            :         }
<span class="lineNum">    6219 </span>            :       else
<span class="lineNum">    6220 </span><span class="lineNoCov">          0 :         return error_mark_node;</span>
<span class="lineNum">    6221 </span>            :     }
<span class="lineNum">    6222 </span>            : 
<span class="lineNum">    6223 </span>            :   /* Recurse on this CONSTRUCTOR.  */
<span class="lineNum">    6224 </span><span class="lineCov">     468702 :   d.cur = &amp;(*v)[0];</span>
<span class="lineNum">    6225 </span><span class="lineCov">     468702 :   d.end = d.cur + v-&gt;length ();</span>
<span class="lineNum">    6226 </span>            : 
<span class="lineNum">    6227 </span><span class="lineCov">     468702 :   new_init = reshape_init_r (type, &amp;d, true, complain);</span>
<span class="lineNum">    6228 </span><span class="lineCov">     468702 :   if (new_init == error_mark_node)</span>
<span class="lineNum">    6229 </span>            :     return error_mark_node;
<span class="lineNum">    6230 </span>            : 
<span class="lineNum">    6231 </span>            :   /* Make sure all the element of the constructor were used. Otherwise,
<span class="lineNum">    6232 </span>            :      issue an error about exceeding initializers.  */
<span class="lineNum">    6233 </span><span class="lineCov">     468491 :   if (d.cur != d.end)</span>
<span class="lineNum">    6234 </span>            :     {
<span class="lineNum">    6235 </span><span class="lineCov">         59 :       if (complain &amp; tf_error)</span>
<span class="lineNum">    6236 </span><span class="lineCov">         40 :         error (&quot;too many initializers for %qT&quot;, type);</span>
<span class="lineNum">    6237 </span><span class="lineCov">         59 :       return error_mark_node;</span>
<span class="lineNum">    6238 </span>            :     }
<span class="lineNum">    6239 </span>            : 
<span class="lineNum">    6240 </span><span class="lineCov">     468432 :   if (CONSTRUCTOR_IS_DIRECT_INIT (init)</span>
<span class="lineNum">    6241 </span><span class="lineCov">     468432 :       &amp;&amp; BRACE_ENCLOSED_INITIALIZER_P (new_init))</span>
<span class="lineNum">    6242 </span><span class="lineCov">      86103 :     CONSTRUCTOR_IS_DIRECT_INIT (new_init) = true;</span>
<span class="lineNum">    6243 </span>            : 
<span class="lineNum">    6244 </span>            :   return new_init;
<span class="lineNum">    6245 </span>            : }
<span class="lineNum">    6246 </span>            : 
<span class="lineNum">    6247 </span>            : /* Verify array initializer.  Returns true if errors have been reported.  */
<a name="6248"><span class="lineNum">    6248 </span>            : </a>
<span class="lineNum">    6249 </span>            : bool
<span class="lineNum">    6250 </span><span class="lineCov">     234666 : check_array_initializer (tree decl, tree type, tree init)</span>
<span class="lineNum">    6251 </span>            : {
<span class="lineNum">    6252 </span><span class="lineCov">     234666 :   tree element_type = TREE_TYPE (type);</span>
<span class="lineNum">    6253 </span>            : 
<span class="lineNum">    6254 </span>            :   /* The array type itself need not be complete, because the
<span class="lineNum">    6255 </span>            :      initializer may tell us how many elements are in the array.
<span class="lineNum">    6256 </span>            :      But, the elements of the array must be complete.  */
<span class="lineNum">    6257 </span><span class="lineCov">     234666 :   if (!COMPLETE_TYPE_P (complete_type (element_type)))</span>
<span class="lineNum">    6258 </span>            :     {
<span class="lineNum">    6259 </span><span class="lineCov">         14 :       if (decl)</span>
<span class="lineNum">    6260 </span><span class="lineCov">          8 :         error_at (DECL_SOURCE_LOCATION (decl),</span>
<span class="lineNum">    6261 </span>            :                   &quot;elements of array %q#D have incomplete type&quot;, decl);
<span class="lineNum">    6262 </span>            :       else
<span class="lineNum">    6263 </span><span class="lineCov">          6 :         error (&quot;elements of array %q#T have incomplete type&quot;, type);</span>
<span class="lineNum">    6264 </span><span class="lineCov">         14 :       return true;</span>
<span class="lineNum">    6265 </span>            :     }
<span class="lineNum">    6266 </span>            :   /* A compound literal can't have variable size.  */
<span class="lineNum">    6267 </span><span class="lineCov">     204047 :   if (init &amp;&amp; !decl</span>
<span class="lineNum">    6268 </span><span class="lineCov">     235821 :       &amp;&amp; ((COMPLETE_TYPE_P (type) &amp;&amp; !TREE_CONSTANT (TYPE_SIZE (type)))</span>
<span class="lineNum">    6269 </span><span class="lineCov">       1166 :           || !TREE_CONSTANT (TYPE_SIZE (element_type))))</span>
<span class="lineNum">    6270 </span>            :     {
<span class="lineNum">    6271 </span><span class="lineCov">          3 :       error (&quot;variable-sized compound literal&quot;);</span>
<span class="lineNum">    6272 </span><span class="lineCov">          3 :       return true;</span>
<span class="lineNum">    6273 </span>            :     }
<span class="lineNum">    6274 </span>            :   return false;
<span class="lineNum">    6275 </span>            : }
<span class="lineNum">    6276 </span>            : 
<span class="lineNum">    6277 </span>            : /* Subroutine of check_initializer; args are passed down from that function.
<span class="lineNum">    6278 </span>            :    Set stmts_are_full_exprs_p to 1 across a call to build_aggr_init.  */
<a name="6279"><span class="lineNum">    6279 </span>            : </a>
<span class="lineNum">    6280 </span>            : static tree
<span class="lineNum">    6281 </span><span class="lineCov">     333013 : build_aggr_init_full_exprs (tree decl, tree init, int flags)</span>
<span class="lineNum">    6282 </span>            :      
<span class="lineNum">    6283 </span>            : {
<span class="lineNum">    6284 </span><span class="lineCov">     333013 :   gcc_assert (stmts_are_full_exprs_p ());</span>
<span class="lineNum">    6285 </span><span class="lineCov">     333013 :   return build_aggr_init (decl, init, flags, tf_warning_or_error);</span>
<span class="lineNum">    6286 </span>            : }
<span class="lineNum">    6287 </span>            : 
<span class="lineNum">    6288 </span>            : /* Verify INIT (the initializer for DECL), and record the
<span class="lineNum">    6289 </span>            :    initialization in DECL_INITIAL, if appropriate.  CLEANUP is as for
<span class="lineNum">    6290 </span>            :    grok_reference_init.
<span class="lineNum">    6291 </span>            : 
<span class="lineNum">    6292 </span>            :    If the return value is non-NULL, it is an expression that must be
<span class="lineNum">    6293 </span>            :    evaluated dynamically to initialize DECL.  */
<a name="6294"><span class="lineNum">    6294 </span>            : </a>
<span class="lineNum">    6295 </span>            : static tree
<span class="lineNum">    6296 </span><span class="lineCov">    3241433 : check_initializer (tree decl, tree init, int flags, vec&lt;tree, va_gc&gt; **cleanups)</span>
<span class="lineNum">    6297 </span>            : {
<span class="lineNum">    6298 </span><span class="lineCov">    3241433 :   tree type = TREE_TYPE (decl);</span>
<span class="lineNum">    6299 </span><span class="lineCov">    3241433 :   tree init_code = NULL;</span>
<span class="lineNum">    6300 </span><span class="lineCov">    3241433 :   tree core_type;</span>
<span class="lineNum">    6301 </span>            : 
<span class="lineNum">    6302 </span>            :   /* Things that are going to be initialized need to have complete
<span class="lineNum">    6303 </span>            :      type.  */
<span class="lineNum">    6304 </span><span class="lineCov">    6482866 :   TREE_TYPE (decl) = type = complete_type (TREE_TYPE (decl));</span>
<span class="lineNum">    6305 </span>            : 
<span class="lineNum">    6306 </span><span class="lineCov">    3241433 :   if (DECL_HAS_VALUE_EXPR_P (decl))</span>
<span class="lineNum">    6307 </span>            :     {
<span class="lineNum">    6308 </span>            :       /* A variable with DECL_HAS_VALUE_EXPR_P set is just a placeholder,
<span class="lineNum">    6309 </span>            :          it doesn't have storage to be initialized.  */
<span class="lineNum">    6310 </span><span class="lineCov">        132 :       gcc_assert (init == NULL_TREE);</span>
<span class="lineNum">    6311 </span>            :       return NULL_TREE;
<span class="lineNum">    6312 </span>            :     }
<span class="lineNum">    6313 </span>            : 
<span class="lineNum">    6314 </span><span class="lineCov">    3241301 :   if (type == error_mark_node)</span>
<span class="lineNum">    6315 </span>            :     /* We will have already complained.  */
<span class="lineNum">    6316 </span>            :     return NULL_TREE;
<span class="lineNum">    6317 </span>            : 
<span class="lineNum">    6318 </span><span class="lineCov">    3241301 :   if (TREE_CODE (type) == ARRAY_TYPE)</span>
<span class="lineNum">    6319 </span>            :     {
<span class="lineNum">    6320 </span><span class="lineCov">     233485 :       if (check_array_initializer (decl, type, init))</span>
<span class="lineNum">    6321 </span>            :         return NULL_TREE;
<span class="lineNum">    6322 </span>            :     }
<span class="lineNum">    6323 </span><span class="lineCov">    3007816 :   else if (!COMPLETE_TYPE_P (type))</span>
<span class="lineNum">    6324 </span>            :     {
<span class="lineNum">    6325 </span><span class="lineCov">         24 :       error_at (DECL_SOURCE_LOCATION (decl),</span>
<span class="lineNum">    6326 </span>            :                 &quot;%q#D has incomplete type&quot;, decl);
<span class="lineNum">    6327 </span><span class="lineCov">         24 :       TREE_TYPE (decl) = error_mark_node;</span>
<span class="lineNum">    6328 </span><span class="lineCov">         24 :       return NULL_TREE;</span>
<span class="lineNum">    6329 </span>            :     }
<span class="lineNum">    6330 </span>            :   else
<span class="lineNum">    6331 </span>            :     /* There is no way to make a variable-sized class type in GNU C++.  */
<span class="lineNum">    6332 </span><span class="lineCov">    6015584 :     gcc_assert (TREE_CONSTANT (TYPE_SIZE (type)));</span>
<span class="lineNum">    6333 </span>            : 
<span class="lineNum">    6334 </span><span class="lineCov">    3241269 :   if (init &amp;&amp; BRACE_ENCLOSED_INITIALIZER_P (init))</span>
<span class="lineNum">    6335 </span>            :     {
<span class="lineNum">    6336 </span><span class="lineCov">     366336 :       int init_len = CONSTRUCTOR_NELTS (init);</span>
<span class="lineNum">    6337 </span><span class="lineCov">     183168 :       if (SCALAR_TYPE_P (type))</span>
<span class="lineNum">    6338 </span>            :         {
<span class="lineNum">    6339 </span><span class="lineCov">        535 :           if (init_len == 0)</span>
<span class="lineNum">    6340 </span>            :             {
<span class="lineNum">    6341 </span><span class="lineCov">        165 :               maybe_warn_cpp0x (CPP0X_INITIALIZER_LISTS);</span>
<span class="lineNum">    6342 </span><span class="lineCov">        165 :               init = build_zero_init (type, NULL_TREE, false);</span>
<span class="lineNum">    6343 </span>            :             }
<span class="lineNum">    6344 </span><span class="lineCov">        370 :           else if (init_len != 1 &amp;&amp; TREE_CODE (type) != COMPLEX_TYPE)</span>
<span class="lineNum">    6345 </span>            :             {
<span class="lineNum">    6346 </span><span class="lineCov">         12 :               error_at (cp_expr_loc_or_loc (init, DECL_SOURCE_LOCATION (decl)),</span>
<span class="lineNum">    6347 </span>            :                         &quot;scalar object %qD requires one element in &quot;
<span class="lineNum">    6348 </span>            :                         &quot;initializer&quot;, decl);
<span class="lineNum">    6349 </span><span class="lineCov">          6 :               TREE_TYPE (decl) = error_mark_node;</span>
<span class="lineNum">    6350 </span><span class="lineCov">          6 :               return NULL_TREE;</span>
<span class="lineNum">    6351 </span>            :             }
<span class="lineNum">    6352 </span>            :         }
<span class="lineNum">    6353 </span>            :     }
<span class="lineNum">    6354 </span>            : 
<span class="lineNum">    6355 </span><span class="lineCov">    3241263 :   if (TREE_CODE (decl) == CONST_DECL)</span>
<span class="lineNum">    6356 </span>            :     {
<span class="lineNum">    6357 </span><span class="lineNoCov">          0 :       gcc_assert (!TYPE_REF_P (type));</span>
<span class="lineNum">    6358 </span>            : 
<span class="lineNum">    6359 </span><span class="lineNoCov">          0 :       DECL_INITIAL (decl) = init;</span>
<span class="lineNum">    6360 </span>            : 
<span class="lineNum">    6361 </span><span class="lineNoCov">          0 :       gcc_assert (init != NULL_TREE);</span>
<span class="lineNum">    6362 </span>            :       init = NULL_TREE;
<span class="lineNum">    6363 </span>            :     }
<span class="lineNum">    6364 </span><span class="lineCov">    3241263 :   else if (!init &amp;&amp; DECL_REALLY_EXTERN (decl))</span>
<span class="lineNum">    6365 </span>            :     ;
<span class="lineNum">    6366 </span><span class="lineCov">     661121 :   else if (init || type_build_ctor_call (type)</span>
<span class="lineNum">    6367 </span><span class="lineCov">    3747168 :            || TYPE_REF_P (type))</span>
<span class="lineNum">    6368 </span>            :     {
<span class="lineNum">    6369 </span><span class="lineCov">    2735366 :       if (TYPE_REF_P (type))</span>
<span class="lineNum">    6370 </span>            :         {
<span class="lineNum">    6371 </span><span class="lineCov">      63129 :           init = grok_reference_init (decl, type, init, flags);</span>
<span class="lineNum">    6372 </span><span class="lineCov">      63129 :           flags |= LOOKUP_ALREADY_DIGESTED;</span>
<span class="lineNum">    6373 </span>            :         }
<span class="lineNum">    6374 </span><span class="lineCov">    2672237 :       else if (!init)</span>
<span class="lineNum">    6375 </span><span class="lineCov">     155216 :         check_for_uninitialized_const_var (decl, /*constexpr_context_p=*/false,</span>
<span class="lineNum">    6376 </span>            :                                            tf_warning_or_error);
<span class="lineNum">    6377 </span>            :       /* Do not reshape constructors of vectors (they don't need to be
<span class="lineNum">    6378 </span>            :          reshaped.  */
<span class="lineNum">    6379 </span><span class="lineCov">    2517021 :       else if (BRACE_ENCLOSED_INITIALIZER_P (init))</span>
<span class="lineNum">    6380 </span>            :         {
<span class="lineNum">    6381 </span><span class="lineCov">     182917 :           if (is_std_init_list (type))</span>
<span class="lineNum">    6382 </span>            :             {
<span class="lineNum">    6383 </span><span class="lineCov">         68 :               init = perform_implicit_conversion (type, init,</span>
<span class="lineNum">    6384 </span>            :                                                   tf_warning_or_error);
<span class="lineNum">    6385 </span><span class="lineCov">         68 :               flags |= LOOKUP_ALREADY_DIGESTED;</span>
<span class="lineNum">    6386 </span>            :             }
<span class="lineNum">    6387 </span><span class="lineCov">     182849 :           else if (TYPE_NON_AGGREGATE_CLASS (type))</span>
<span class="lineNum">    6388 </span>            :             {
<span class="lineNum">    6389 </span>            :               /* Don't reshape if the class has constructors.  */
<span class="lineNum">    6390 </span><span class="lineCov">      16848 :               if (cxx_dialect == cxx98)</span>
<span class="lineNum">    6391 </span><span class="lineCov">          6 :                 error_at (cp_expr_loc_or_loc (init, DECL_SOURCE_LOCATION (decl)),</span>
<span class="lineNum">    6392 </span>            :                           &quot;in C++98 %qD must be initialized by &quot;
<span class="lineNum">    6393 </span>            :                           &quot;constructor, not by %&lt;{...}%&gt;&quot;,
<span class="lineNum">    6394 </span>            :                           decl);
<span class="lineNum">    6395 </span>            :             }
<span class="lineNum">    6396 </span><span class="lineCov">     166001 :           else if (VECTOR_TYPE_P (type) &amp;&amp; TYPE_VECTOR_OPAQUE (type))</span>
<span class="lineNum">    6397 </span>            :             {
<span class="lineNum">    6398 </span><span class="lineNoCov">          0 :               error (&quot;opaque vector types cannot be initialized&quot;);</span>
<span class="lineNum">    6399 </span><span class="lineNoCov">          0 :               init = error_mark_node;</span>
<span class="lineNum">    6400 </span>            :             }
<span class="lineNum">    6401 </span>            :           else
<span class="lineNum">    6402 </span>            :             {
<span class="lineNum">    6403 </span><span class="lineCov">     166001 :               init = reshape_init (type, init, tf_warning_or_error);</span>
<span class="lineNum">    6404 </span><span class="lineCov">     166001 :               flags |= LOOKUP_NO_NARROWING;</span>
<span class="lineNum">    6405 </span>            :             }
<span class="lineNum">    6406 </span>            :         }
<span class="lineNum">    6407 </span><span class="lineCov">    2334104 :       else if (TREE_CODE (init) == TREE_LIST</span>
<span class="lineNum">    6408 </span><span class="lineCov">      68147 :                &amp;&amp; TREE_TYPE (init) != unknown_type_node</span>
<span class="lineNum">    6409 </span><span class="lineCov">    2402251 :                &amp;&amp; !MAYBE_CLASS_TYPE_P (type))</span>
<span class="lineNum">    6410 </span>            :         {
<span class="lineNum">    6411 </span><span class="lineCov">       6097 :           gcc_assert (TREE_CODE (decl) != RESULT_DECL);</span>
<span class="lineNum">    6412 </span>            : 
<span class="lineNum">    6413 </span>            :           /* We get here with code like `int a (2);' */
<span class="lineNum">    6414 </span><span class="lineCov">       6097 :           init = build_x_compound_expr_from_list (init, ELK_INIT,</span>
<span class="lineNum">    6415 </span>            :                                                   tf_warning_or_error);
<span class="lineNum">    6416 </span>            :         }
<span class="lineNum">    6417 </span>            : 
<span class="lineNum">    6418 </span>            :       /* If DECL has an array type without a specific bound, deduce the
<span class="lineNum">    6419 </span>            :          array size from the initializer.  */
<span class="lineNum">    6420 </span><span class="lineCov">    2735366 :       maybe_deduce_size_from_array_init (decl, init);</span>
<span class="lineNum">    6421 </span><span class="lineCov">    2735366 :       type = TREE_TYPE (decl);</span>
<span class="lineNum">    6422 </span><span class="lineCov">    2735366 :       if (type == error_mark_node)</span>
<span class="lineNum">    6423 </span>            :         return NULL_TREE;
<span class="lineNum">    6424 </span>            : 
<span class="lineNum">    6425 </span><span class="lineCov">    4996668 :       if (((type_build_ctor_call (type) || CLASS_TYPE_P (type))</span>
<span class="lineNum">    6426 </span><span class="lineCov">     489344 :            &amp;&amp; !(flags &amp; LOOKUP_ALREADY_DIGESTED)</span>
<span class="lineNum">    6427 </span><span class="lineCov">     489276 :            &amp;&amp; !(init &amp;&amp; BRACE_ENCLOSED_INITIALIZER_P (init)</span>
<span class="lineNum">    6428 </span><span class="lineCov">     173632 :                 &amp;&amp; CP_AGGREGATE_TYPE_P (type)</span>
<span class="lineNum">    6429 </span><span class="lineCov">     156784 :                 &amp;&amp; (CLASS_TYPE_P (type)</span>
<span class="lineNum">    6430 </span><span class="lineCov">        516 :                     || !TYPE_NEEDS_CONSTRUCTING (type)</span>
<span class="lineNum">    6431 </span><span class="lineCov">        506 :                     || type_has_extended_temps (type))))</span>
<span class="lineNum">    6432 </span><span class="lineCov">    5137727 :           || (DECL_DECOMPOSITION_P (decl) &amp;&amp; TREE_CODE (type) == ARRAY_TYPE))</span>
<span class="lineNum">    6433 </span>            :         {
<span class="lineNum">    6434 </span><span class="lineCov">     333013 :           init_code = build_aggr_init_full_exprs (decl, init, flags);</span>
<span class="lineNum">    6435 </span>            : 
<span class="lineNum">    6436 </span>            :           /* A constructor call is a non-trivial initializer even if
<span class="lineNum">    6437 </span>            :              it isn't explicitly written.  */
<span class="lineNum">    6438 </span><span class="lineCov">     333013 :           if (TREE_SIDE_EFFECTS (init_code))</span>
<span class="lineNum">    6439 </span><span class="lineCov">     331703 :             DECL_NONTRIVIALLY_INITIALIZED_P (decl) = true;</span>
<span class="lineNum">    6440 </span>            : 
<span class="lineNum">    6441 </span>            :           /* If this is a constexpr initializer, expand_default_init will
<span class="lineNum">    6442 </span>            :              have returned an INIT_EXPR rather than a CALL_EXPR.  In that
<span class="lineNum">    6443 </span>            :              case, pull the initializer back out and pass it down into
<span class="lineNum">    6444 </span>            :              store_init_value.  */
<span class="lineNum">    6445 </span><span class="lineCov">    1203549 :           while (TREE_CODE (init_code) == EXPR_STMT</span>
<span class="lineNum">    6446 </span><span class="lineCov">     768281 :                  || TREE_CODE (init_code) == CONVERT_EXPR)</span>
<span class="lineNum">    6447 </span><span class="lineCov">     435268 :             init_code = TREE_OPERAND (init_code, 0);</span>
<span class="lineNum">    6448 </span><span class="lineCov">     333013 :           if (TREE_CODE (init_code) == INIT_EXPR)</span>
<span class="lineNum">    6449 </span>            :             {
<span class="lineNum">    6450 </span><span class="lineCov">     104768 :               init = TREE_OPERAND (init_code, 1);</span>
<span class="lineNum">    6451 </span><span class="lineCov">     104768 :               init_code = NULL_TREE;</span>
<span class="lineNum">    6452 </span>            :               /* Don't call digest_init; it's unnecessary and will complain
<span class="lineNum">    6453 </span>            :                  about aggregate initialization of non-aggregate classes.  */
<span class="lineNum">    6454 </span><span class="lineCov">     104768 :               flags |= LOOKUP_ALREADY_DIGESTED;</span>
<span class="lineNum">    6455 </span>            :             }
<span class="lineNum">    6456 </span><span class="lineCov">     228245 :           else if (DECL_DECLARED_CONSTEXPR_P (decl))</span>
<span class="lineNum">    6457 </span>            :             {
<span class="lineNum">    6458 </span>            :               /* Declared constexpr, but no suitable initializer; massage
<span class="lineNum">    6459 </span>            :                  init appropriately so we can pass it into store_init_value
<span class="lineNum">    6460 </span>            :                  for the error.  */
<span class="lineNum">    6461 </span><span class="lineCov">         33 :               if (CLASS_TYPE_P (type)</span>
<span class="lineNum">    6462 </span><span class="lineCov">         68 :                   &amp;&amp; (!init || TREE_CODE (init) == TREE_LIST))</span>
<span class="lineNum">    6463 </span>            :                 {
<span class="lineNum">    6464 </span><span class="lineCov">         22 :                   init = build_functional_cast (type, init, tf_none);</span>
<span class="lineNum">    6465 </span><span class="lineCov">         22 :                   if (TREE_CODE (init) == TARGET_EXPR)</span>
<span class="lineNum">    6466 </span><span class="lineCov">         48 :                     TARGET_EXPR_DIRECT_INIT_P (init) = true;</span>
<span class="lineNum">    6467 </span>            :                 }
<span class="lineNum">    6468 </span>            :               init_code = NULL_TREE;
<span class="lineNum">    6469 </span>            :             }
<span class="lineNum">    6470 </span>            :           else
<span class="lineNum">    6471 </span>            :             init = NULL_TREE;
<span class="lineNum">    6472 </span>            :         }
<span class="lineNum">    6473 </span>            : 
<span class="lineNum">    6474 </span><span class="lineCov">    2735360 :       if (init &amp;&amp; TREE_CODE (init) != TREE_VEC)</span>
<span class="lineNum">    6475 </span>            :         {
<span class="lineNum">    6476 </span>            :           /* In aggregate initialization of a variable, each element
<span class="lineNum">    6477 </span>            :              initialization is a full-expression because there is no
<span class="lineNum">    6478 </span>            :              enclosing expression.  */
<span class="lineNum">    6479 </span><span class="lineCov">    2507142 :           gcc_assert (stmts_are_full_exprs_p ());</span>
<span class="lineNum">    6480 </span>            : 
<span class="lineNum">    6481 </span><span class="lineCov">    2507142 :           init_code = store_init_value (decl, init, cleanups, flags);</span>
<span class="lineNum">    6482 </span>            : 
<span class="lineNum">    6483 </span><span class="lineCov">    2507142 :           if (DECL_INITIAL (decl)</span>
<span class="lineNum">    6484 </span><span class="lineCov">    2797110 :               &amp;&amp; TREE_CODE (DECL_INITIAL (decl)) == CONSTRUCTOR</span>
<span class="lineNum">    6485 </span><span class="lineCov">    3024756 :               &amp;&amp; !vec_safe_is_empty (CONSTRUCTOR_ELTS (DECL_INITIAL (decl))))</span>
<span class="lineNum">    6486 </span>            :             {
<span class="lineNum">    6487 </span><span class="lineCov">     496494 :               tree elt = CONSTRUCTOR_ELTS (DECL_INITIAL (decl))-&gt;last ().value;</span>
<span class="lineNum">    6488 </span><span class="lineCov">     165498 :               if (TREE_CODE (TREE_TYPE (elt)) == ARRAY_TYPE</span>
<span class="lineNum">    6489 </span><span class="lineCov">     165498 :                   &amp;&amp; TYPE_SIZE (TREE_TYPE (elt)) == NULL_TREE)</span>
<span class="lineNum">    6490 </span><span class="lineCov">         66 :                 cp_complete_array_type (&amp;TREE_TYPE (elt), elt, false);</span>
<span class="lineNum">    6491 </span>            :             }
<span class="lineNum">    6492 </span>            : 
<span class="lineNum">    6493 </span><span class="lineCov">     222015 :           if (pedantic &amp;&amp; TREE_CODE (type) == ARRAY_TYPE</span>
<span class="lineNum">    6494 </span><span class="lineCov">      36668 :               &amp;&amp; DECL_INITIAL (decl)</span>
<span class="lineNum">    6495 </span><span class="lineCov">      73202 :               &amp;&amp; TREE_CODE (DECL_INITIAL (decl)) == STRING_CST</span>
<span class="lineNum">    6496 </span><span class="lineCov">    2650786 :               &amp;&amp; PAREN_STRING_LITERAL_P (DECL_INITIAL (decl)))</span>
<span class="lineNum">    6497 </span><span class="lineCov">          6 :             warning_at (cp_expr_loc_or_loc (DECL_INITIAL (decl),</span>
<span class="lineNum">    6498 </span><span class="lineCov">          3 :                                          DECL_SOURCE_LOCATION (decl)),</span>
<span class="lineNum">    6499 </span>            :                         0, &quot;array %qD initialized by parenthesized &quot;
<span class="lineNum">    6500 </span>            :                         &quot;string literal %qE&quot;,
<span class="lineNum">    6501 </span><span class="lineCov">          6 :                         decl, DECL_INITIAL (decl));</span>
<span class="lineNum">    6502 </span>            :           init = NULL;
<span class="lineNum">    6503 </span>            :         }
<span class="lineNum">    6504 </span>            :     }
<span class="lineNum">    6505 </span>            :   else
<span class="lineNum">    6506 </span>            :     {
<span class="lineNum">    6507 </span><span class="lineCov">    1011794 :       if (CLASS_TYPE_P (core_type = strip_array_types (type))</span>
<span class="lineNum">    6508 </span><span class="lineCov">     601693 :           &amp;&amp; (CLASSTYPE_READONLY_FIELDS_NEED_INIT (core_type)</span>
<span class="lineNum">    6509 </span><span class="lineCov">      47898 :               || CLASSTYPE_REF_FIELDS_NEED_INIT (core_type)))</span>
<span class="lineNum">    6510 </span><span class="lineCov">         21 :         diagnose_uninitialized_cst_or_ref_member (core_type, /*using_new=*/false,</span>
<span class="lineNum">    6511 </span>            :                                                   /*complain=*/true);
<span class="lineNum">    6512 </span>            : 
<span class="lineNum">    6513 </span><span class="lineCov">     505897 :       check_for_uninitialized_const_var (decl, /*constexpr_context_p=*/false,</span>
<span class="lineNum">    6514 </span>            :                                          tf_warning_or_error);
<span class="lineNum">    6515 </span>            :     }
<span class="lineNum">    6516 </span>            : 
<span class="lineNum">    6517 </span><span class="lineCov">    3241257 :   if (init &amp;&amp; init != error_mark_node)</span>
<span class="lineNum">    6518 </span><span class="lineNoCov">          0 :     init_code = build2 (INIT_EXPR, type, decl, init);</span>
<span class="lineNum">    6519 </span>            : 
<span class="lineNum">    6520 </span><span class="lineCov">    3241257 :   if (init_code)</span>
<span class="lineNum">    6521 </span>            :     {
<span class="lineNum">    6522 </span>            :       /* We might have set these in cp_finish_decl.  */
<span class="lineNum">    6523 </span><span class="lineCov">    1337508 :       DECL_INITIALIZED_BY_CONSTANT_EXPRESSION_P (decl) = false;</span>
<span class="lineNum">    6524 </span><span class="lineCov">    1337508 :       TREE_CONSTANT (decl) = false;</span>
<span class="lineNum">    6525 </span>            :     }
<span class="lineNum">    6526 </span>            : 
<span class="lineNum">    6527 </span><span class="lineCov">    3241257 :   if (init_code</span>
<span class="lineNum">    6528 </span><span class="lineCov">    3241257 :       &amp;&amp; (DECL_IN_AGGR_P (decl)</span>
<span class="lineNum">    6529 </span><span class="lineCov">    1337508 :           &amp;&amp; DECL_INITIALIZED_IN_CLASS_P (decl)</span>
<span class="lineNum">    6530 </span><span class="lineCov">         15 :           &amp;&amp; !DECL_VAR_DECLARED_INLINE_P (decl)))</span>
<span class="lineNum">    6531 </span>            :     {
<span class="lineNum">    6532 </span><span class="lineNoCov">          0 :       static int explained = 0;</span>
<span class="lineNum">    6533 </span>            : 
<span class="lineNum">    6534 </span><span class="lineNoCov">          0 :       if (cxx_dialect &lt; cxx11)</span>
<span class="lineNum">    6535 </span><span class="lineNoCov">          0 :         error (&quot;initializer invalid for static member with constructor&quot;);</span>
<span class="lineNum">    6536 </span><span class="lineNoCov">          0 :       else if (cxx_dialect &lt; cxx17)</span>
<span class="lineNum">    6537 </span><span class="lineNoCov">          0 :         error (&quot;non-constant in-class initialization invalid for static &quot;</span>
<span class="lineNum">    6538 </span>            :                &quot;member %qD&quot;, decl);
<span class="lineNum">    6539 </span>            :       else
<span class="lineNum">    6540 </span><span class="lineNoCov">          0 :         error (&quot;non-constant in-class initialization invalid for non-inline &quot;</span>
<span class="lineNum">    6541 </span>            :                &quot;static member %qD&quot;, decl);
<span class="lineNum">    6542 </span><span class="lineNoCov">          0 :       if (!explained)</span>
<span class="lineNum">    6543 </span>            :         {
<span class="lineNum">    6544 </span><span class="lineNoCov">          0 :           inform (input_location,</span>
<span class="lineNum">    6545 </span>            :                   &quot;(an out of class initialization is required)&quot;);
<span class="lineNum">    6546 </span><span class="lineNoCov">          0 :           explained = 1;</span>
<span class="lineNum">    6547 </span>            :         }
<span class="lineNum">    6548 </span><span class="lineNoCov">          0 :       return NULL_TREE;</span>
<span class="lineNum">    6549 </span>            :     }
<span class="lineNum">    6550 </span>            : 
<span class="lineNum">    6551 </span>            :   return init_code;
<span class="lineNum">    6552 </span>            : }
<span class="lineNum">    6553 </span>            : 
<span class="lineNum">    6554 </span>            : /* If DECL is not a local variable, give it RTL.  */
<a name="6555"><span class="lineNum">    6555 </span>            : </a>
<span class="lineNum">    6556 </span>            : static void
<span class="lineNum">    6557 </span><span class="lineCov">    8446954 : make_rtl_for_nonlocal_decl (tree decl, tree init, const char* asmspec)</span>
<span class="lineNum">    6558 </span>            : {
<span class="lineNum">    6559 </span><span class="lineCov">    8446954 :   int toplev = toplevel_bindings_p ();</span>
<span class="lineNum">    6560 </span><span class="lineCov">    8446954 :   int defer_p;</span>
<span class="lineNum">    6561 </span>            : 
<span class="lineNum">    6562 </span>            :   /* Set the DECL_ASSEMBLER_NAME for the object.  */
<span class="lineNum">    6563 </span><span class="lineCov">    8446954 :   if (asmspec)</span>
<span class="lineNum">    6564 </span>            :     {
<span class="lineNum">    6565 </span>            :       /* The `register' keyword, when used together with an
<span class="lineNum">    6566 </span>            :          asm-specification, indicates that the variable should be
<span class="lineNum">    6567 </span>            :          placed in a particular register.  */
<span class="lineNum">    6568 </span><span class="lineCov">      41205 :       if (VAR_P (decl) &amp;&amp; DECL_REGISTER (decl))</span>
<span class="lineNum">    6569 </span>            :         {
<span class="lineNum">    6570 </span><span class="lineCov">         48 :           set_user_assembler_name (decl, asmspec);</span>
<span class="lineNum">    6571 </span><span class="lineCov">         48 :           DECL_HARD_REGISTER (decl) = 1;</span>
<span class="lineNum">    6572 </span>            :         }
<span class="lineNum">    6573 </span>            :       else
<span class="lineNum">    6574 </span>            :         {
<span class="lineNum">    6575 </span><span class="lineCov">      41157 :           if (TREE_CODE (decl) == FUNCTION_DECL</span>
<span class="lineNum">    6576 </span><span class="lineCov">      41157 :               &amp;&amp; fndecl_built_in_p (decl, BUILT_IN_NORMAL))</span>
<span class="lineNum">    6577 </span><span class="lineCov">        316 :             set_builtin_user_assembler_name (decl, asmspec);</span>
<span class="lineNum">    6578 </span><span class="lineCov">      41157 :           set_user_assembler_name (decl, asmspec);</span>
<span class="lineNum">    6579 </span>            :         }
<span class="lineNum">    6580 </span>            :     }
<span class="lineNum">    6581 </span>            : 
<span class="lineNum">    6582 </span>            :   /* Handle non-variables up front.  */
<span class="lineNum">    6583 </span><span class="lineCov">    8446954 :   if (!VAR_P (decl))</span>
<span class="lineNum">    6584 </span>            :     {
<span class="lineNum">    6585 </span><span class="lineCov">    4407775 :       rest_of_decl_compilation (decl, toplev, at_eof);</span>
<span class="lineNum">    6586 </span><span class="lineCov">    4407775 :       return;</span>
<span class="lineNum">    6587 </span>            :     }
<span class="lineNum">    6588 </span>            : 
<span class="lineNum">    6589 </span>            :   /* If we see a class member here, it should be a static data
<span class="lineNum">    6590 </span>            :      member.  */
<span class="lineNum">    6591 </span><span class="lineCov">    4039179 :   if (DECL_LANG_SPECIFIC (decl) &amp;&amp; DECL_IN_AGGR_P (decl))</span>
<span class="lineNum">    6592 </span>            :     {
<span class="lineNum">    6593 </span><span class="lineCov">     865513 :       gcc_assert (TREE_STATIC (decl));</span>
<span class="lineNum">    6594 </span>            :       /* An in-class declaration of a static data member should be
<span class="lineNum">    6595 </span>            :          external; it is only a declaration, and not a definition.  */
<span class="lineNum">    6596 </span><span class="lineCov">     865513 :       if (init == NULL_TREE)</span>
<span class="lineNum">    6597 </span><span class="lineCov">    1730982 :         gcc_assert (DECL_EXTERNAL (decl)</span>
<span class="lineNum">    6598 </span>            :                     || !TREE_PUBLIC (decl)
<span class="lineNum">    6599 </span>            :                     || DECL_INLINE_VAR_P (decl));
<span class="lineNum">    6600 </span>            :     }
<span class="lineNum">    6601 </span>            : 
<span class="lineNum">    6602 </span>            :   /* We don't create any RTL for local variables.  */
<span class="lineNum">    6603 </span><span class="lineCov">    4039179 :   if (DECL_FUNCTION_SCOPE_P (decl) &amp;&amp; !TREE_STATIC (decl))</span>
<span class="lineNum">    6604 </span>            :     return;
<span class="lineNum">    6605 </span>            : 
<span class="lineNum">    6606 </span>            :   /* We defer emission of local statics until the corresponding
<span class="lineNum">    6607 </span>            :      DECL_EXPR is expanded.  But with constexpr its function might never
<span class="lineNum">    6608 </span>            :      be expanded, so go ahead and tell cgraph about the variable now.  */
<span class="lineNum">    6609 </span><span class="lineCov">    1970890 :   defer_p = ((DECL_FUNCTION_SCOPE_P (decl)</span>
<span class="lineNum">    6610 </span><span class="lineCov">      22110 :               &amp;&amp; !var_in_maybe_constexpr_fn (decl))</span>
<span class="lineNum">    6611 </span><span class="lineCov">    3449796 :              || DECL_VIRTUAL_P (decl));</span>
<span class="lineNum">    6612 </span>            : 
<span class="lineNum">    6613 </span>            :   /* Defer template instantiations.  */
<span class="lineNum">    6614 </span><span class="lineCov">    1970890 :   if (DECL_LANG_SPECIFIC (decl)</span>
<span class="lineNum">    6615 </span><span class="lineCov">    1970890 :       &amp;&amp; DECL_IMPLICIT_INSTANTIATION (decl))</span>
<span class="lineNum">    6616 </span>            :     defer_p = 1;
<span class="lineNum">    6617 </span>            : 
<span class="lineNum">    6618 </span>            :   /* If we're not deferring, go ahead and assemble the variable.  */
<span class="lineNum">    6619 </span><span class="lineCov">    1682324 :   if (!defer_p)</span>
<span class="lineNum">    6620 </span><span class="lineCov">    1465741 :     rest_of_decl_compilation (decl, toplev, at_eof);</span>
<span class="lineNum">    6621 </span>            : }
<span class="lineNum">    6622 </span>            : 
<span class="lineNum">    6623 </span>            : /* walk_tree helper for wrap_temporary_cleanups, below.  */
<a name="6624"><span class="lineNum">    6624 </span>            : </a>
<span class="lineNum">    6625 </span>            : static tree
<span class="lineNum">    6626 </span><span class="lineCov">    2193158 : wrap_cleanups_r (tree *stmt_p, int *walk_subtrees, void *data)</span>
<span class="lineNum">    6627 </span>            : {
<span class="lineNum">    6628 </span>            :   /* Stop at types or full-expression boundaries.  */
<span class="lineNum">    6629 </span><span class="lineCov">    2193158 :   if (TYPE_P (*stmt_p)</span>
<span class="lineNum">    6630 </span><span class="lineCov">    2193123 :       || TREE_CODE (*stmt_p) == CLEANUP_POINT_EXPR)</span>
<span class="lineNum">    6631 </span>            :     {
<span class="lineNum">    6632 </span><span class="lineCov">        340 :       *walk_subtrees = 0;</span>
<span class="lineNum">    6633 </span><span class="lineCov">        340 :       return NULL_TREE;</span>
<span class="lineNum">    6634 </span>            :     }
<span class="lineNum">    6635 </span>            : 
<span class="lineNum">    6636 </span><span class="lineCov">    2192818 :   if (TREE_CODE (*stmt_p) == TARGET_EXPR)</span>
<span class="lineNum">    6637 </span>            :     {
<span class="lineNum">    6638 </span><span class="lineCov">      14113 :       tree guard = (tree)data;</span>
<span class="lineNum">    6639 </span><span class="lineCov">      14113 :       tree tcleanup = TARGET_EXPR_CLEANUP (*stmt_p);</span>
<span class="lineNum">    6640 </span>            : 
<span class="lineNum">    6641 </span><span class="lineCov">      14113 :       tcleanup = build2 (TRY_CATCH_EXPR, void_type_node, tcleanup, guard);</span>
<span class="lineNum">    6642 </span>            :       /* Tell honor_protect_cleanup_actions to handle this as a separate
<span class="lineNum">    6643 </span>            :          cleanup.  */
<span class="lineNum">    6644 </span><span class="lineCov">      14113 :       TRY_CATCH_IS_CLEANUP (tcleanup) = 1;</span>
<span class="lineNum">    6645 </span>            :  
<span class="lineNum">    6646 </span><span class="lineCov">      14113 :       TARGET_EXPR_CLEANUP (*stmt_p) = tcleanup;</span>
<span class="lineNum">    6647 </span>            :     }
<span class="lineNum">    6648 </span>            : 
<span class="lineNum">    6649 </span>            :   return NULL_TREE;
<span class="lineNum">    6650 </span>            : }
<span class="lineNum">    6651 </span>            : 
<span class="lineNum">    6652 </span>            : /* We're initializing a local variable which has a cleanup GUARD.  If there
<span class="lineNum">    6653 </span>            :    are any temporaries used in the initializer INIT of this variable, we
<span class="lineNum">    6654 </span>            :    need to wrap their cleanups with TRY_CATCH_EXPR (, GUARD) so that the
<span class="lineNum">    6655 </span>            :    variable will be cleaned up properly if one of them throws.
<span class="lineNum">    6656 </span>            : 
<span class="lineNum">    6657 </span>            :    Unfortunately, there's no way to express this properly in terms of
<span class="lineNum">    6658 </span>            :    nesting, as the regions for the temporaries overlap the region for the
<span class="lineNum">    6659 </span>            :    variable itself; if there are two temporaries, the variable needs to be
<span class="lineNum">    6660 </span>            :    the first thing destroyed if either of them throws.  However, we only
<span class="lineNum">    6661 </span>            :    want to run the variable's cleanup if it actually got constructed.  So
<span class="lineNum">    6662 </span>            :    we need to guard the temporary cleanups with the variable's cleanup if
<span class="lineNum">    6663 </span>            :    they are run on the normal path, but not if they are run on the
<span class="lineNum">    6664 </span>            :    exceptional path.  We implement this by telling
<span class="lineNum">    6665 </span>            :    honor_protect_cleanup_actions to strip the variable cleanup from the
<span class="lineNum">    6666 </span>            :    exceptional path.  */
<a name="6667"><span class="lineNum">    6667 </span>            : </a>
<span class="lineNum">    6668 </span>            : static void
<span class="lineNum">    6669 </span><span class="lineNoCov">          0 : wrap_temporary_cleanups (tree init, tree guard)</span>
<span class="lineNum">    6670 </span>            : {
<span class="lineNum">    6671 </span><span class="lineNoCov">          0 :   cp_walk_tree_without_duplicates (&amp;init, wrap_cleanups_r, (void *)guard);</span>
<span class="lineNum">    6672 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    6673 </span>            : 
<span class="lineNum">    6674 </span>            : /* Generate code to initialize DECL (a local variable).  */
<a name="6675"><span class="lineNum">    6675 </span>            : </a>
<span class="lineNum">    6676 </span>            : static void
<span class="lineNum">    6677 </span><span class="lineCov">    2068274 : initialize_local_var (tree decl, tree init)</span>
<span class="lineNum">    6678 </span>            : {
<span class="lineNum">    6679 </span><span class="lineCov">    2068274 :   tree type = TREE_TYPE (decl);</span>
<span class="lineNum">    6680 </span><span class="lineCov">    2068274 :   tree cleanup;</span>
<span class="lineNum">    6681 </span><span class="lineCov">    2068274 :   int already_used;</span>
<span class="lineNum">    6682 </span>            : 
<span class="lineNum">    6683 </span><span class="lineCov">    2068274 :   gcc_assert (VAR_P (decl)</span>
<span class="lineNum">    6684 </span>            :               || TREE_CODE (decl) == RESULT_DECL);
<span class="lineNum">    6685 </span><span class="lineCov">    2068274 :   gcc_assert (!TREE_STATIC (decl));</span>
<span class="lineNum">    6686 </span>            : 
<span class="lineNum">    6687 </span><span class="lineCov">    2068274 :   if (DECL_SIZE (decl) == NULL_TREE)</span>
<span class="lineNum">    6688 </span>            :     {
<span class="lineNum">    6689 </span>            :       /* If we used it already as memory, it must stay in memory.  */
<span class="lineNum">    6690 </span><span class="lineNoCov">          0 :       DECL_INITIAL (decl) = NULL_TREE;</span>
<span class="lineNum">    6691 </span><span class="lineNoCov">          0 :       TREE_ADDRESSABLE (decl) = TREE_USED (decl);</span>
<span class="lineNum">    6692 </span><span class="lineNoCov">          0 :       return;</span>
<span class="lineNum">    6693 </span>            :     }
<span class="lineNum">    6694 </span>            : 
<span class="lineNum">    6695 </span><span class="lineCov">    2068274 :   if (type == error_mark_node)</span>
<span class="lineNum">    6696 </span>            :     return;
<span class="lineNum">    6697 </span>            : 
<span class="lineNum">    6698 </span>            :   /* Compute and store the initial value.  */
<span class="lineNum">    6699 </span><span class="lineCov">    2068274 :   already_used = TREE_USED (decl) || TREE_USED (type);</span>
<span class="lineNum">    6700 </span><span class="lineCov">    2068274 :   if (TREE_USED (type))</span>
<span class="lineNum">    6701 </span><span class="lineCov">         29 :     DECL_READ_P (decl) = 1;</span>
<span class="lineNum">    6702 </span>            : 
<span class="lineNum">    6703 </span>            :   /* Generate a cleanup, if necessary.  */
<span class="lineNum">    6704 </span><span class="lineCov">    2068274 :   cleanup = cxx_maybe_build_cleanup (decl, tf_warning_or_error);</span>
<span class="lineNum">    6705 </span>            : 
<span class="lineNum">    6706 </span>            :   /* Perform the initialization.  */
<span class="lineNum">    6707 </span><span class="lineCov">    2068274 :   if (init)</span>
<span class="lineNum">    6708 </span>            :     {
<span class="lineNum">    6709 </span><span class="lineCov">    1313903 :       tree rinit = (TREE_CODE (init) == INIT_EXPR</span>
<span class="lineNum">    6710 </span><span class="lineCov">    1313903 :                     ? TREE_OPERAND (init, 1) : NULL_TREE);</span>
<span class="lineNum">    6711 </span><span class="lineCov">    1075275 :       if (rinit &amp;&amp; !TREE_SIDE_EFFECTS (rinit))</span>
<span class="lineNum">    6712 </span>            :         {
<span class="lineNum">    6713 </span>            :           /* Stick simple initializers in DECL_INITIAL so that
<span class="lineNum">    6714 </span>            :              -Wno-init-self works (c++/34772).  */
<span class="lineNum">    6715 </span><span class="lineCov">     304894 :           gcc_assert (TREE_OPERAND (init, 0) == decl);</span>
<span class="lineNum">    6716 </span><span class="lineCov">     304894 :           DECL_INITIAL (decl) = rinit;</span>
<span class="lineNum">    6717 </span>            : 
<span class="lineNum">    6718 </span><span class="lineCov">     304894 :           if (warn_init_self &amp;&amp; TYPE_REF_P (type))</span>
<span class="lineNum">    6719 </span>            :             {
<span class="lineNum">    6720 </span><span class="lineCov">       1296 :               STRIP_NOPS (rinit);</span>
<span class="lineNum">    6721 </span><span class="lineCov">       1296 :               if (rinit == decl)</span>
<span class="lineNum">    6722 </span><span class="lineCov">          3 :                 warning_at (DECL_SOURCE_LOCATION (decl),</span>
<span class="lineNum">    6723 </span>            :                             OPT_Winit_self,
<span class="lineNum">    6724 </span>            :                             &quot;reference %qD is initialized with itself&quot;, decl);
<span class="lineNum">    6725 </span>            :             }
<span class="lineNum">    6726 </span>            :         }
<span class="lineNum">    6727 </span>            :       else
<span class="lineNum">    6728 </span>            :         {
<span class="lineNum">    6729 </span><span class="lineCov">    1009009 :           int saved_stmts_are_full_exprs_p;</span>
<span class="lineNum">    6730 </span>            : 
<span class="lineNum">    6731 </span>            :           /* If we're only initializing a single object, guard the
<span class="lineNum">    6732 </span>            :              destructors of any temporaries used in its initializer with
<span class="lineNum">    6733 </span>            :              its destructor.  This isn't right for arrays because each
<span class="lineNum">    6734 </span>            :              element initialization is a full-expression.  */
<span class="lineNum">    6735 </span><span class="lineCov">    1009009 :           if (cleanup &amp;&amp; TREE_CODE (type) != ARRAY_TYPE)</span>
<span class="lineNum">    6736 </span><span class="lineCov">     217088 :             wrap_temporary_cleanups (init, cleanup);</span>
<span class="lineNum">    6737 </span>            : 
<span class="lineNum">    6738 </span><span class="lineCov">    1009009 :           gcc_assert (building_stmt_list_p ());</span>
<span class="lineNum">    6739 </span><span class="lineCov">    1009009 :           saved_stmts_are_full_exprs_p = stmts_are_full_exprs_p ();</span>
<span class="lineNum">    6740 </span><span class="lineCov">    1009009 :           current_stmt_tree ()-&gt;stmts_are_full_exprs_p = 1;</span>
<span class="lineNum">    6741 </span><span class="lineCov">    1009009 :           finish_expr_stmt (init);</span>
<span class="lineNum">    6742 </span><span class="lineCov">    1009009 :           current_stmt_tree ()-&gt;stmts_are_full_exprs_p =</span>
<span class="lineNum">    6743 </span>            :             saved_stmts_are_full_exprs_p;
<span class="lineNum">    6744 </span>            :         }
<span class="lineNum">    6745 </span>            :     }
<span class="lineNum">    6746 </span>            : 
<span class="lineNum">    6747 </span>            :   /* Set this to 0 so we can tell whether an aggregate which was
<span class="lineNum">    6748 </span>            :      initialized was ever used.  Don't do this if it has a
<span class="lineNum">    6749 </span>            :      destructor, so we don't complain about the 'resource
<span class="lineNum">    6750 </span>            :      allocation is initialization' idiom.  Now set
<span class="lineNum">    6751 </span>            :      attribute((unused)) on types so decls of that type will be
<span class="lineNum">    6752 </span>            :      marked used. (see TREE_USED, above.)  */
<span class="lineNum">    6753 </span><span class="lineCov">    2068274 :   if (TYPE_NEEDS_CONSTRUCTING (type)</span>
<span class="lineNum">    6754 </span><span class="lineCov">     297382 :       &amp;&amp; ! already_used</span>
<span class="lineNum">    6755 </span><span class="lineCov">       1668 :       &amp;&amp; TYPE_HAS_TRIVIAL_DESTRUCTOR (type)</span>
<span class="lineNum">    6756 </span><span class="lineCov">    2068861 :       &amp;&amp; DECL_NAME (decl))</span>
<span class="lineNum">    6757 </span><span class="lineCov">        585 :     TREE_USED (decl) = 0;</span>
<span class="lineNum">    6758 </span><span class="lineCov">    2067689 :   else if (already_used)</span>
<span class="lineNum">    6759 </span><span class="lineCov">    1578463 :     TREE_USED (decl) = 1;</span>
<span class="lineNum">    6760 </span>            : 
<span class="lineNum">    6761 </span><span class="lineCov">    2068274 :   if (cleanup)</span>
<span class="lineNum">    6762 </span><span class="lineCov">     218229 :     finish_decl_cleanup (decl, cleanup);</span>
<span class="lineNum">    6763 </span>            : }
<span class="lineNum">    6764 </span>            : 
<span class="lineNum">    6765 </span>            : /* DECL is a VAR_DECL for a compiler-generated variable with static
<span class="lineNum">    6766 </span>            :    storage duration (like a virtual table) whose initializer is a
<span class="lineNum">    6767 </span>            :    compile-time constant.  Initialize the variable and provide it to the
<span class="lineNum">    6768 </span>            :    back end.  */
<a name="6769"><span class="lineNum">    6769 </span>            : </a>
<span class="lineNum">    6770 </span>            : void
<span class="lineNum">    6771 </span><span class="lineCov">     167654 : initialize_artificial_var (tree decl, vec&lt;constructor_elt, va_gc&gt; *v)</span>
<span class="lineNum">    6772 </span>            : {
<span class="lineNum">    6773 </span><span class="lineCov">     167654 :   tree init;</span>
<span class="lineNum">    6774 </span><span class="lineCov">     167654 :   gcc_assert (DECL_ARTIFICIAL (decl));</span>
<span class="lineNum">    6775 </span><span class="lineCov">     167654 :   init = build_constructor (TREE_TYPE (decl), v);</span>
<span class="lineNum">    6776 </span><span class="lineCov">     167654 :   gcc_assert (TREE_CODE (init) == CONSTRUCTOR);</span>
<span class="lineNum">    6777 </span><span class="lineCov">     167654 :   DECL_INITIAL (decl) = init;</span>
<span class="lineNum">    6778 </span><span class="lineCov">     167654 :   DECL_INITIALIZED_P (decl) = 1;</span>
<span class="lineNum">    6779 </span>            :   /* Mark the decl as constexpr so that we can access its content
<span class="lineNum">    6780 </span>            :      at compile time.  */
<span class="lineNum">    6781 </span><span class="lineCov">     335308 :   DECL_INITIALIZED_BY_CONSTANT_EXPRESSION_P (decl) = true;</span>
<span class="lineNum">    6782 </span><span class="lineCov">     167654 :   DECL_DECLARED_CONSTEXPR_P (decl) = true;</span>
<span class="lineNum">    6783 </span><span class="lineCov">     167654 :   determine_visibility (decl);</span>
<span class="lineNum">    6784 </span><span class="lineCov">     167654 :   layout_var_decl (decl);</span>
<span class="lineNum">    6785 </span><span class="lineCov">     167654 :   maybe_commonize_var (decl);</span>
<span class="lineNum">    6786 </span><span class="lineCov">     167654 :   make_rtl_for_nonlocal_decl (decl, init, /*asmspec=*/NULL);</span>
<span class="lineNum">    6787 </span><span class="lineCov">     167654 : }</span>
<span class="lineNum">    6788 </span>            : 
<span class="lineNum">    6789 </span>            : /* INIT is the initializer for a variable, as represented by the
<span class="lineNum">    6790 </span>            :    parser.  Returns true iff INIT is value-dependent.  */
<a name="6791"><span class="lineNum">    6791 </span>            : </a>
<span class="lineNum">    6792 </span>            : static bool
<span class="lineNum">    6793 </span><span class="lineCov">     287399 : value_dependent_init_p (tree init)</span>
<span class="lineNum">    6794 </span>            : {
<span class="lineNum">    6795 </span><span class="lineCov">     287399 :   if (TREE_CODE (init) == TREE_LIST)</span>
<span class="lineNum">    6796 </span>            :     /* A parenthesized initializer, e.g.: int i (3, 2); ? */
<span class="lineNum">    6797 </span><span class="lineCov">         67 :     return any_value_dependent_elements_p (init);</span>
<span class="lineNum">    6798 </span><span class="lineCov">     287332 :   else if (TREE_CODE (init) == CONSTRUCTOR)</span>
<span class="lineNum">    6799 </span>            :   /* A brace-enclosed initializer, e.g.: int i = { 3 }; ? */
<span class="lineNum">    6800 </span>            :     {
<span class="lineNum">    6801 </span><span class="lineCov">        190 :       if (dependent_type_p (TREE_TYPE (init)))</span>
<span class="lineNum">    6802 </span>            :         return true;
<span class="lineNum">    6803 </span>            : 
<span class="lineNum">    6804 </span><span class="lineCov">        186 :       vec&lt;constructor_elt, va_gc&gt; *elts;</span>
<span class="lineNum">    6805 </span><span class="lineCov">        186 :       size_t nelts;</span>
<span class="lineNum">    6806 </span><span class="lineCov">        186 :       size_t i;</span>
<span class="lineNum">    6807 </span>            : 
<span class="lineNum">    6808 </span><span class="lineCov">        186 :       elts = CONSTRUCTOR_ELTS (init);</span>
<span class="lineNum">    6809 </span><span class="lineCov">        186 :       nelts = vec_safe_length (elts);</span>
<span class="lineNum">    6810 </span><span class="lineCov">        203 :       for (i = 0; i &lt; nelts; ++i)</span>
<span class="lineNum">    6811 </span><span class="lineCov">        188 :         if (value_dependent_init_p ((*elts)[i].value))</span>
<span class="lineNum">    6812 </span>            :           return true;
<span class="lineNum">    6813 </span>            :     }
<span class="lineNum">    6814 </span>            :   else
<span class="lineNum">    6815 </span>            :     /* It must be a simple expression, e.g., int i = 3;  */
<span class="lineNum">    6816 </span><span class="lineCov">     287142 :     return value_dependent_expression_p (init);</span>
<span class="lineNum">    6817 </span>            :   
<span class="lineNum">    6818 </span>            :   return false;
<span class="lineNum">    6819 </span>            : }
<span class="lineNum">    6820 </span>            : 
<a name="6821"><span class="lineNum">    6821 </span>            : // Returns true if a DECL is VAR_DECL with the concept specifier.</a>
<span class="lineNum">    6822 </span>            : static inline bool
<span class="lineNum">    6823 </span><span class="lineCov">      81510 : is_concept_var (tree decl)</span>
<span class="lineNum">    6824 </span>            : {
<span class="lineNum">    6825 </span><span class="lineCov">      81510 :   return (VAR_P (decl)</span>
<span class="lineNum">    6826 </span>            :           // Not all variables have DECL_LANG_SPECIFIC.
<span class="lineNum">    6827 </span><span class="lineCov">      81510 :           &amp;&amp; DECL_LANG_SPECIFIC (decl)</span>
<span class="lineNum">    6828 </span><span class="lineCov">     168188 :           &amp;&amp; DECL_DECLARED_CONCEPT_P (decl));</span>
<span class="lineNum">    6829 </span>            : }
<span class="lineNum">    6830 </span>            : 
<span class="lineNum">    6831 </span>            : /* A helper function to be called via walk_tree.  If any label exists
<span class="lineNum">    6832 </span>            :    under *TP, it is (going to be) forced.  Set has_forced_label_in_static.  */
<a name="6833"><span class="lineNum">    6833 </span>            : </a>
<span class="lineNum">    6834 </span>            : static tree
<span class="lineNum">    6835 </span><span class="lineCov">        366 : notice_forced_label_r (tree *tp, int *walk_subtrees, void *)</span>
<span class="lineNum">    6836 </span>            : {
<span class="lineNum">    6837 </span><span class="lineCov">        366 :   if (TYPE_P (*tp))</span>
<span class="lineNum">    6838 </span><span class="lineCov">         18 :     *walk_subtrees = 0;</span>
<span class="lineNum">    6839 </span><span class="lineCov">        366 :   if (TREE_CODE (*tp) == LABEL_DECL)</span>
<span class="lineNum">    6840 </span><span class="lineCov">          6 :     cfun-&gt;has_forced_label_in_static = 1;</span>
<span class="lineNum">    6841 </span><span class="lineCov">        366 :   return NULL_TREE;</span>
<span class="lineNum">    6842 </span>            : }
<span class="lineNum">    6843 </span>            : 
<span class="lineNum">    6844 </span>            : /* Finish processing of a declaration;
<span class="lineNum">    6845 </span>            :    install its line number and initial value.
<span class="lineNum">    6846 </span>            :    If the length of an array type is not known before,
<span class="lineNum">    6847 </span>            :    it must be determined now, from the initial value, or it is an error.
<span class="lineNum">    6848 </span>            : 
<span class="lineNum">    6849 </span>            :    INIT is the initializer (if any) for DECL.  If INIT_CONST_EXPR_P is
<span class="lineNum">    6850 </span>            :    true, then INIT is an integral constant expression.
<span class="lineNum">    6851 </span>            : 
<span class="lineNum">    6852 </span>            :    FLAGS is LOOKUP_ONLYCONVERTING if the = init syntax was used, else 0
<span class="lineNum">    6853 </span>            :    if the (init) syntax was used.  */
<a name="6854"><span class="lineNum">    6854 </span>            : </a>
<span class="lineNum">    6855 </span>            : void
<span class="lineNum">    6856 </span><span class="lineCov">   16659590 : cp_finish_decl (tree decl, tree init, bool init_const_expr_p,</span>
<span class="lineNum">    6857 </span>            :                 tree asmspec_tree, int flags)
<span class="lineNum">    6858 </span>            : {
<span class="lineNum">    6859 </span><span class="lineCov">   16659590 :   tree type;</span>
<span class="lineNum">    6860 </span><span class="lineCov">   16659590 :   vec&lt;tree, va_gc&gt; *cleanups = NULL;</span>
<span class="lineNum">    6861 </span><span class="lineCov">   16659590 :   const char *asmspec = NULL;</span>
<span class="lineNum">    6862 </span><span class="lineCov">   16659590 :   int was_readonly = 0;</span>
<span class="lineNum">    6863 </span><span class="lineCov">   16659590 :   bool var_definition_p = false;</span>
<span class="lineNum">    6864 </span><span class="lineCov">   16659590 :   tree auto_node;</span>
<span class="lineNum">    6865 </span>            : 
<span class="lineNum">    6866 </span><span class="lineCov">   16659590 :   if (decl == error_mark_node)</span>
<span class="lineNum">    6867 </span><span class="lineCov">    7300276 :     return;</span>
<span class="lineNum">    6868 </span><span class="lineCov">   16659572 :   else if (! decl)</span>
<span class="lineNum">    6869 </span>            :     {
<span class="lineNum">    6870 </span><span class="lineNoCov">          0 :       if (init)</span>
<span class="lineNum">    6871 </span><span class="lineNoCov">          0 :         error (&quot;assignment (not initialization) in declaration&quot;);</span>
<span class="lineNum">    6872 </span><span class="lineNoCov">          0 :       return;</span>
<span class="lineNum">    6873 </span>            :     }
<span class="lineNum">    6874 </span>            : 
<span class="lineNum">    6875 </span><span class="lineCov">   16659572 :   gcc_assert (TREE_CODE (decl) != RESULT_DECL);</span>
<span class="lineNum">    6876 </span>            :   /* Parameters are handled by store_parm_decls, not cp_finish_decl.  */
<span class="lineNum">    6877 </span><span class="lineCov">   16659572 :   gcc_assert (TREE_CODE (decl) != PARM_DECL);</span>
<span class="lineNum">    6878 </span>            : 
<span class="lineNum">    6879 </span><span class="lineCov">   16659572 :   type = TREE_TYPE (decl);</span>
<span class="lineNum">    6880 </span><span class="lineCov">   16659572 :   if (type == error_mark_node)</span>
<span class="lineNum">    6881 </span>            :     return;
<span class="lineNum">    6882 </span>            : 
<span class="lineNum">    6883 </span>            :   /* Warn about register storage specifiers except when in GNU global
<span class="lineNum">    6884 </span>            :      or local register variable extension.  */
<span class="lineNum">    6885 </span><span class="lineCov">   16659309 :   if (VAR_P (decl) &amp;&amp; DECL_REGISTER (decl) &amp;&amp; asmspec_tree == NULL_TREE)</span>
<span class="lineNum">    6886 </span>            :     {
<span class="lineNum">    6887 </span><span class="lineCov">       2118 :       if (cxx_dialect &gt;= cxx17)</span>
<span class="lineNum">    6888 </span><span class="lineNoCov">          0 :         pedwarn (DECL_SOURCE_LOCATION (decl), OPT_Wregister,</span>
<span class="lineNum">    6889 </span>            :                  &quot;ISO C++17 does not allow %&lt;register%&gt; storage &quot;
<span class="lineNum">    6890 </span>            :                  &quot;class specifier&quot;);
<span class="lineNum">    6891 </span>            :       else
<span class="lineNum">    6892 </span><span class="lineCov">       2118 :         warning_at (DECL_SOURCE_LOCATION (decl), OPT_Wregister,</span>
<span class="lineNum">    6893 </span>            :                     &quot;%&lt;register%&gt; storage class specifier used&quot;);
<span class="lineNum">    6894 </span>            :     }
<span class="lineNum">    6895 </span>            : 
<span class="lineNum">    6896 </span>            :   /* If a name was specified, get the string.  */
<span class="lineNum">    6897 </span><span class="lineCov">   16659309 :   if (at_namespace_scope_p ())</span>
<span class="lineNum">    6898 </span><span class="lineCov">    5009672 :     asmspec_tree = maybe_apply_renaming_pragma (decl, asmspec_tree);</span>
<span class="lineNum">    6899 </span><span class="lineCov">   16659309 :   if (asmspec_tree &amp;&amp; asmspec_tree != error_mark_node)</span>
<span class="lineNum">    6900 </span><span class="lineCov">      41205 :     asmspec = TREE_STRING_POINTER (asmspec_tree);</span>
<span class="lineNum">    6901 </span>            : 
<span class="lineNum">    6902 </span><span class="lineCov">   16659309 :   if (current_class_type</span>
<span class="lineNum">    6903 </span><span class="lineCov">    8936730 :       &amp;&amp; CP_DECL_CONTEXT (decl) == current_class_type</span>
<span class="lineNum">    6904 </span><span class="lineCov">    5557165 :       &amp;&amp; TYPE_BEING_DEFINED (current_class_type)</span>
<span class="lineNum">    6905 </span><span class="lineCov">   10845606 :       &amp;&amp; !CLASSTYPE_TEMPLATE_INSTANTIATION (current_class_type)</span>
<span class="lineNum">    6906 </span><span class="lineCov">   21855443 :       &amp;&amp; (DECL_INITIAL (decl) || init))</span>
<span class="lineNum">    6907 </span><span class="lineCov">   10038295 :     DECL_INITIALIZED_IN_CLASS_P (decl) = 1;</span>
<span class="lineNum">    6908 </span>            : 
<span class="lineNum">    6909 </span>            :   /* Do auto deduction unless decl is a function or an uninstantiated
<span class="lineNum">    6910 </span>            :      template specialization.  */
<span class="lineNum">    6911 </span><span class="lineCov">   16659309 :   if (TREE_CODE (decl) != FUNCTION_DECL</span>
<span class="lineNum">    6912 </span><span class="lineCov">    9241172 :       &amp;&amp; !(init == NULL_TREE</span>
<span class="lineNum">    6913 </span><span class="lineCov">    5047852 :            &amp;&amp; DECL_LANG_SPECIFIC (decl)</span>
<span class="lineNum">    6914 </span><span class="lineCov">    1854590 :            &amp;&amp; DECL_TEMPLATE_INSTANTIATION (decl)</span>
<span class="lineNum">    6915 </span><span class="lineCov">     182807 :            &amp;&amp; !DECL_TEMPLATE_INSTANTIATED (decl))</span>
<span class="lineNum">    6916 </span><span class="lineCov">   25718503 :       &amp;&amp; (auto_node = type_uses_auto (type)))</span>
<span class="lineNum">    6917 </span>            :     {
<span class="lineNum">    6918 </span><span class="lineCov">     141864 :       tree d_init;</span>
<span class="lineNum">    6919 </span><span class="lineCov">     141864 :       if (init == NULL_TREE)</span>
<span class="lineNum">    6920 </span><span class="lineCov">          4 :         gcc_assert (CLASS_PLACEHOLDER_TEMPLATE (auto_node));</span>
<span class="lineNum">    6921 </span><span class="lineCov">     141864 :       d_init = init;</span>
<span class="lineNum">    6922 </span><span class="lineCov">     141864 :       if (d_init)</span>
<span class="lineNum">    6923 </span>            :         {
<span class="lineNum">    6924 </span><span class="lineCov">     141860 :           if (TREE_CODE (d_init) == TREE_LIST</span>
<span class="lineNum">    6925 </span><span class="lineCov">     141860 :               &amp;&amp; !CLASS_PLACEHOLDER_TEMPLATE (auto_node))</span>
<span class="lineNum">    6926 </span><span class="lineCov">         55 :             d_init = build_x_compound_expr_from_list (d_init, ELK_INIT,</span>
<span class="lineNum">    6927 </span>            :                                                       tf_warning_or_error);
<span class="lineNum">    6928 </span><span class="lineCov">     141860 :           d_init = resolve_nondeduced_context (d_init, tf_warning_or_error);</span>
<span class="lineNum">    6929 </span>            :         }
<span class="lineNum">    6930 </span><span class="lineCov">     141864 :       enum auto_deduction_context adc = adc_variable_type;</span>
<span class="lineNum">    6931 </span><span class="lineCov">     141864 :       if (VAR_P (decl) &amp;&amp; DECL_DECOMPOSITION_P (decl))</span>
<span class="lineNum">    6932 </span>            :         adc = adc_decomp_type;
<span class="lineNum">    6933 </span><span class="lineCov">     141864 :       type = TREE_TYPE (decl) = do_auto_deduction (type, d_init, auto_node,</span>
<span class="lineNum">    6934 </span>            :                                                    tf_warning_or_error, adc,
<span class="lineNum">    6935 </span>            :                                                    NULL_TREE, flags);
<span class="lineNum">    6936 </span><span class="lineCov">     141864 :       if (type == error_mark_node)</span>
<span class="lineNum">    6937 </span>            :         return;
<span class="lineNum">    6938 </span><span class="lineCov">     141721 :       if (TREE_CODE (type) == FUNCTION_TYPE)</span>
<span class="lineNum">    6939 </span>            :         {
<span class="lineNum">    6940 </span><span class="lineCov">          1 :           error (&quot;initializer for %&lt;decltype(auto) %D%&gt; has function type &quot;</span>
<span class="lineNum">    6941 </span>            :                  &quot;(did you forget the %&lt;()%&gt; ?)&quot;, decl);
<span class="lineNum">    6942 </span><span class="lineCov">          1 :           TREE_TYPE (decl) = error_mark_node;</span>
<span class="lineNum">    6943 </span><span class="lineCov">          1 :           return;</span>
<span class="lineNum">    6944 </span>            :         }
<span class="lineNum">    6945 </span><span class="lineCov">     141720 :       cp_apply_type_quals_to_decl (cp_type_quals (type), decl);</span>
<span class="lineNum">    6946 </span>            :     }
<span class="lineNum">    6947 </span>            : 
<span class="lineNum">    6948 </span><span class="lineCov">   16659165 :   if (ensure_literal_type_for_constexpr_object (decl) == error_mark_node)</span>
<span class="lineNum">    6949 </span>            :     {
<span class="lineNum">    6950 </span><span class="lineCov">         25 :       DECL_DECLARED_CONSTEXPR_P (decl) = 0;</span>
<span class="lineNum">    6951 </span><span class="lineCov">         25 :       if (VAR_P (decl) &amp;&amp; DECL_CLASS_SCOPE_P (decl))</span>
<span class="lineNum">    6952 </span>            :         {
<span class="lineNum">    6953 </span><span class="lineCov">          4 :           init = NULL_TREE;</span>
<span class="lineNum">    6954 </span><span class="lineCov">          4 :           DECL_EXTERNAL (decl) = 1;</span>
<span class="lineNum">    6955 </span>            :         }
<span class="lineNum">    6956 </span>            :     }
<span class="lineNum">    6957 </span>            : 
<span class="lineNum">    6958 </span><span class="lineCov">   16659165 :   if (VAR_P (decl)</span>
<span class="lineNum">    6959 </span><span class="lineCov">    5741380 :       &amp;&amp; DECL_CLASS_SCOPE_P (decl)</span>
<span class="lineNum">    6960 </span><span class="lineCov">   18913725 :       &amp;&amp; DECL_INITIALIZED_IN_CLASS_P (decl))</span>
<span class="lineNum">    6961 </span><span class="lineCov">     993877 :     check_static_variable_definition (decl, type);</span>
<span class="lineNum">    6962 </span>            : 
<span class="lineNum">    6963 </span><span class="lineCov">   16659165 :   if (init &amp;&amp; TREE_CODE (decl) == FUNCTION_DECL)</span>
<span class="lineNum">    6964 </span>            :     {
<span class="lineNum">    6965 </span><span class="lineCov">      13906 :       tree clone;</span>
<span class="lineNum">    6966 </span><span class="lineCov">      13906 :       if (init == ridpointers[(int)RID_DELETE])</span>
<span class="lineNum">    6967 </span>            :         {
<span class="lineNum">    6968 </span>            :           /* FIXME check this is 1st decl.  */
<span class="lineNum">    6969 </span><span class="lineCov">      12373 :           DECL_DELETED_FN (decl) = 1;</span>
<span class="lineNum">    6970 </span><span class="lineCov">      12373 :           DECL_DECLARED_INLINE_P (decl) = 1;</span>
<span class="lineNum">    6971 </span><span class="lineCov">      12373 :           DECL_INITIAL (decl) = error_mark_node;</span>
<span class="lineNum">    6972 </span><span class="lineCov">      12385 :           FOR_EACH_CLONE (clone, decl)</span>
<span class="lineNum">    6973 </span>            :             {
<span class="lineNum">    6974 </span><span class="lineCov">         12 :               DECL_DELETED_FN (clone) = 1;</span>
<span class="lineNum">    6975 </span><span class="lineCov">         12 :               DECL_DECLARED_INLINE_P (clone) = 1;</span>
<span class="lineNum">    6976 </span><span class="lineCov">         12 :               DECL_INITIAL (clone) = error_mark_node;</span>
<span class="lineNum">    6977 </span>            :             }
<span class="lineNum">    6978 </span><span class="lineCov">      12373 :           init = NULL_TREE;</span>
<span class="lineNum">    6979 </span>            :         }
<span class="lineNum">    6980 </span><span class="lineCov">       1533 :       else if (init == ridpointers[(int)RID_DEFAULT])</span>
<span class="lineNum">    6981 </span>            :         {
<span class="lineNum">    6982 </span><span class="lineCov">       1521 :           if (defaultable_fn_check (decl))</span>
<span class="lineNum">    6983 </span><span class="lineCov">       1515 :             DECL_DEFAULTED_FN (decl) = 1;</span>
<span class="lineNum">    6984 </span>            :           else
<span class="lineNum">    6985 </span><span class="lineCov">          6 :             DECL_INITIAL (decl) = NULL_TREE;</span>
<span class="lineNum">    6986 </span>            :         }
<span class="lineNum">    6987 </span>            :     }
<span class="lineNum">    6988 </span>            : 
<span class="lineNum">    6989 </span><span class="lineCov">   16659165 :   if (init &amp;&amp; VAR_P (decl))</span>
<span class="lineNum">    6990 </span>            :     {
<span class="lineNum">    6991 </span><span class="lineCov">    8369802 :       DECL_NONTRIVIALLY_INITIALIZED_P (decl) = 1;</span>
<span class="lineNum">    6992 </span>            :       /* If DECL is a reference, then we want to know whether init is a
<span class="lineNum">    6993 </span>            :          reference constant; init_const_expr_p as passed tells us whether
<span class="lineNum">    6994 </span>            :          it's an rvalue constant.  */
<span class="lineNum">    6995 </span><span class="lineCov">    4184901 :       if (TYPE_REF_P (type))</span>
<span class="lineNum">    6996 </span><span class="lineCov">     111671 :         init_const_expr_p = potential_constant_expression (init);</span>
<span class="lineNum">    6997 </span><span class="lineCov">    4184901 :       if (init_const_expr_p)</span>
<span class="lineNum">    6998 </span>            :         {
<span class="lineNum">    6999 </span>            :           /* Set these flags now for templates.  We'll update the flags in
<span class="lineNum">    7000 </span>            :              store_init_value for instantiations.  */
<span class="lineNum">    7001 </span><span class="lineCov">    3298719 :           DECL_INITIALIZED_BY_CONSTANT_EXPRESSION_P (decl) = 1;</span>
<span class="lineNum">    7002 </span><span class="lineCov">    3298719 :           if (decl_maybe_constant_var_p (decl)</span>
<span class="lineNum">    7003 </span>            :               /* FIXME setting TREE_CONSTANT on refs breaks the back end.  */
<span class="lineNum">    7004 </span><span class="lineCov">    3298719 :               &amp;&amp; !TYPE_REF_P (type))</span>
<span class="lineNum">    7005 </span><span class="lineCov">    1203055 :             TREE_CONSTANT (decl) = 1;</span>
<span class="lineNum">    7006 </span>            :         }
<span class="lineNum">    7007 </span>            :     }
<span class="lineNum">    7008 </span>            : 
<span class="lineNum">    7009 </span><span class="lineCov">   16659165 :   if (processing_template_decl)</span>
<span class="lineNum">    7010 </span>            :     {
<span class="lineNum">    7011 </span><span class="lineCov">    5872492 :       bool type_dependent_p;</span>
<span class="lineNum">    7012 </span>            : 
<span class="lineNum">    7013 </span>            :       /* Add this declaration to the statement-tree.  */
<span class="lineNum">    7014 </span><span class="lineCov">    5872492 :       if (at_function_scope_p ())</span>
<span class="lineNum">    7015 </span><span class="lineCov">    1961111 :         add_decl_expr (decl);</span>
<span class="lineNum">    7016 </span>            : 
<span class="lineNum">    7017 </span><span class="lineCov">    5872492 :       type_dependent_p = dependent_type_p (type);</span>
<span class="lineNum">    7018 </span>            : 
<span class="lineNum">    7019 </span><span class="lineCov">    5872492 :       if (check_for_bare_parameter_packs (init))</span>
<span class="lineNum">    7020 </span>            :         {
<span class="lineNum">    7021 </span><span class="lineCov">          2 :           init = NULL_TREE;</span>
<span class="lineNum">    7022 </span><span class="lineCov">          2 :           DECL_INITIAL (decl) = NULL_TREE;</span>
<span class="lineNum">    7023 </span>            :         }
<span class="lineNum">    7024 </span>            : 
<span class="lineNum">    7025 </span>            :       /* Generally, initializers in templates are expanded when the
<span class="lineNum">    7026 </span>            :          template is instantiated.  But, if DECL is a variable constant
<span class="lineNum">    7027 </span>            :          then it can be used in future constant expressions, so its value
<span class="lineNum">    7028 </span>            :          must be available. */
<span class="lineNum">    7029 </span>            : 
<span class="lineNum">    7030 </span><span class="lineCov">    5872492 :       bool dep_init = false;</span>
<span class="lineNum">    7031 </span>            : 
<span class="lineNum">    7032 </span><span class="lineCov">    5872492 :       if (!VAR_P (decl) || type_dependent_p)</span>
<span class="lineNum">    7033 </span>            :         /* We can't do anything if the decl has dependent type.  */;
<span class="lineNum">    7034 </span><span class="lineCov">     759155 :       else if (!init &amp;&amp; is_concept_var (decl))</span>
<span class="lineNum">    7035 </span>            :         {
<span class="lineNum">    7036 </span><span class="lineCov">          2 :           error (&quot;variable concept has no initializer&quot;);</span>
<span class="lineNum">    7037 </span><span class="lineCov">          2 :           init = boolean_true_node;</span>
<span class="lineNum">    7038 </span>            :         }
<span class="lineNum">    7039 </span><span class="lineCov">     759153 :       else if (init</span>
<span class="lineNum">    7040 </span><span class="lineCov">     677645 :                &amp;&amp; init_const_expr_p</span>
<span class="lineNum">    7041 </span><span class="lineCov">     579014 :                &amp;&amp; !TYPE_REF_P (type)</span>
<span class="lineNum">    7042 </span><span class="lineCov">     566026 :                &amp;&amp; decl_maybe_constant_var_p (decl)</span>
<span class="lineNum">    7043 </span><span class="lineCov">    1046364 :                &amp;&amp; !(dep_init = value_dependent_init_p (init)))</span>
<span class="lineNum">    7044 </span>            :         {
<span class="lineNum">    7045 </span>            :           /* This variable seems to be a non-dependent constant, so process
<span class="lineNum">    7046 </span>            :              its initializer.  If check_initializer returns non-null the
<span class="lineNum">    7047 </span>            :              initialization wasn't constant after all.  */
<span class="lineNum">    7048 </span><span class="lineCov">      50415 :           tree init_code;</span>
<span class="lineNum">    7049 </span><span class="lineCov">      50415 :           cleanups = make_tree_vector ();</span>
<span class="lineNum">    7050 </span><span class="lineCov">      50415 :           init_code = check_initializer (decl, init, flags, &amp;cleanups);</span>
<span class="lineNum">    7051 </span><span class="lineCov">      50415 :           if (init_code == NULL_TREE)</span>
<span class="lineNum">    7052 </span><span class="lineCov">      34692 :             init = NULL_TREE;</span>
<span class="lineNum">    7053 </span><span class="lineCov">      50415 :           release_tree_vector (cleanups);</span>
<span class="lineNum">    7054 </span>            :         }
<span class="lineNum">    7055 </span><span class="lineCov">     708738 :       else if (!DECL_PRETTY_FUNCTION_P (decl))</span>
<span class="lineNum">    7056 </span>            :         {
<span class="lineNum">    7057 </span>            :           /* Deduce array size even if the initializer is dependent.  */
<span class="lineNum">    7058 </span><span class="lineCov">     693128 :           maybe_deduce_size_from_array_init (decl, init);</span>
<span class="lineNum">    7059 </span>            :           /* And complain about multiple initializers.  */
<span class="lineNum">    7060 </span><span class="lineCov">     611620 :           if (init &amp;&amp; TREE_CODE (init) == TREE_LIST &amp;&amp; TREE_CHAIN (init)</span>
<span class="lineNum">    7061 </span><span class="lineCov">     695859 :               &amp;&amp; !MAYBE_CLASS_TYPE_P (type))</span>
<span class="lineNum">    7062 </span><span class="lineCov">          6 :             init = build_x_compound_expr_from_list (init, ELK_INIT,</span>
<span class="lineNum">    7063 </span>            :                                                     tf_warning_or_error);
<span class="lineNum">    7064 </span>            :         }
<span class="lineNum">    7065 </span>            : 
<span class="lineNum">    7066 </span><span class="lineCov">    5872492 :       if (init)</span>
<span class="lineNum">    7067 </span><span class="lineCov">    1625181 :         DECL_INITIAL (decl) = init;</span>
<span class="lineNum">    7068 </span>            : 
<span class="lineNum">    7069 </span><span class="lineCov">    5872492 :       if (dep_init)</span>
<span class="lineNum">    7070 </span>            :         {
<span class="lineNum">    7071 </span><span class="lineCov">     236796 :           retrofit_lang_decl (decl);</span>
<span class="lineNum">    7072 </span><span class="lineCov">     236796 :           SET_DECL_DEPENDENT_INIT_P (decl, true);</span>
<span class="lineNum">    7073 </span>            :         }
<span class="lineNum">    7074 </span><span class="lineCov">    5872492 :       return;</span>
<span class="lineNum">    7075 </span>            :     }
<span class="lineNum">    7076 </span>            : 
<span class="lineNum">    7077 </span>            :   /* Just store non-static data member initializers for later.  */
<span class="lineNum">    7078 </span><span class="lineCov">   10786673 :   if (init &amp;&amp; TREE_CODE (decl) == FIELD_DECL)</span>
<span class="lineNum">    7079 </span><span class="lineCov">       4967 :     DECL_INITIAL (decl) = init;</span>
<span class="lineNum">    7080 </span>            : 
<span class="lineNum">    7081 </span>            :   /* Take care of TYPE_DECLs up front.  */
<span class="lineNum">    7082 </span><span class="lineCov">   10786673 :   if (TREE_CODE (decl) == TYPE_DECL)</span>
<span class="lineNum">    7083 </span>            :     {
<span class="lineNum">    7084 </span><span class="lineCov">    1427359 :       if (type != error_mark_node</span>
<span class="lineNum">    7085 </span><span class="lineCov">    1427359 :           &amp;&amp; MAYBE_CLASS_TYPE_P (type) &amp;&amp; DECL_NAME (decl))</span>
<span class="lineNum">    7086 </span>            :         {
<span class="lineNum">    7087 </span><span class="lineCov">    1487816 :           if (TREE_TYPE (DECL_NAME (decl)) &amp;&amp; TREE_TYPE (decl) != type)</span>
<span class="lineNum">    7088 </span><span class="lineNoCov">          0 :             warning (0, &quot;shadowing previous type declaration of %q#D&quot;, decl);</span>
<span class="lineNum">    7089 </span><span class="lineCov">     743908 :           set_identifier_type_value (DECL_NAME (decl), decl);</span>
<span class="lineNum">    7090 </span>            :         }
<span class="lineNum">    7091 </span>            : 
<span class="lineNum">    7092 </span>            :       /* If we have installed this as the canonical typedef for this
<span class="lineNum">    7093 </span>            :          type, and that type has not been defined yet, delay emitting
<span class="lineNum">    7094 </span>            :          the debug information for it, as we will emit it later.  */
<span class="lineNum">    7095 </span><span class="lineCov">    1427359 :       if (TYPE_MAIN_DECL (TREE_TYPE (decl)) == decl</span>
<span class="lineNum">    7096 </span><span class="lineCov">    1427359 :           &amp;&amp; !COMPLETE_TYPE_P (TREE_TYPE (decl)))</span>
<span class="lineNum">    7097 </span><span class="lineCov">     238523 :         TYPE_DECL_SUPPRESS_DEBUG (decl) = 1;</span>
<span class="lineNum">    7098 </span>            : 
<span class="lineNum">    7099 </span><span class="lineCov">    1427359 :       rest_of_decl_compilation (decl, DECL_FILE_SCOPE_P (decl),</span>
<span class="lineNum">    7100 </span>            :                                 at_eof);
<span class="lineNum">    7101 </span><span class="lineCov">    1427359 :       return;</span>
<span class="lineNum">    7102 </span>            :     }
<span class="lineNum">    7103 </span>            : 
<span class="lineNum">    7104 </span>            :   /* A reference will be modified here, as it is initialized.  */
<span class="lineNum">    7105 </span><span class="lineCov">    9359314 :   if (! DECL_EXTERNAL (decl)</span>
<span class="lineNum">    7106 </span><span class="lineCov">    3890623 :       &amp;&amp; TREE_READONLY (decl)</span>
<span class="lineNum">    7107 </span><span class="lineCov">   10618641 :       &amp;&amp; TYPE_REF_P (type))</span>
<span class="lineNum">    7108 </span>            :     {
<span class="lineNum">    7109 </span><span class="lineCov">      61109 :       was_readonly = 1;</span>
<span class="lineNum">    7110 </span><span class="lineCov">     122218 :       TREE_READONLY (decl) = 0;</span>
<span class="lineNum">    7111 </span>            :     }
<span class="lineNum">    7112 </span>            : 
<span class="lineNum">    7113 </span><span class="lineCov">    9359314 :   if (VAR_P (decl))</span>
<span class="lineNum">    7114 </span>            :     {
<span class="lineNum">    7115 </span>            :       /* If this is a local variable that will need a mangled name,
<span class="lineNum">    7116 </span>            :          register it now.  We must do this before processing the
<span class="lineNum">    7117 </span>            :          initializer for the variable, since the initialization might
<span class="lineNum">    7118 </span>            :          require a guard variable, and since the mangled name of the
<span class="lineNum">    7119 </span>            :          guard variable will depend on the mangled name of this
<span class="lineNum">    7120 </span>            :          variable.  */
<span class="lineNum">    7121 </span><span class="lineCov">   10674757 :       if (DECL_FUNCTION_SCOPE_P (decl)</span>
<span class="lineNum">    7122 </span><span class="lineCov">    2090399 :           &amp;&amp; TREE_STATIC (decl)</span>
<span class="lineNum">    7123 </span><span class="lineCov">    3893635 :           &amp;&amp; !DECL_ARTIFICIAL (decl))</span>
<span class="lineNum">    7124 </span>            :         {
<span class="lineNum">    7125 </span><span class="lineCov">      10350 :           push_local_name (decl);</span>
<span class="lineNum">    7126 </span>            :           /* Normally has_forced_label_in_static is set during GIMPLE
<span class="lineNum">    7127 </span>            :              lowering, but [cd]tors are never actually compiled directly.
<span class="lineNum">    7128 </span>            :              We need to set this early so we can deal with the label
<span class="lineNum">    7129 </span>            :              address extension.  */
<span class="lineNum">    7130 </span><span class="lineCov">      10350 :           if ((DECL_CONSTRUCTOR_P (current_function_decl)</span>
<span class="lineNum">    7131 </span><span class="lineCov">      20624 :                || DECL_DESTRUCTOR_P (current_function_decl))</span>
<span class="lineNum">    7132 </span><span class="lineCov">      10360 :               &amp;&amp; init)</span>
<span class="lineNum">    7133 </span>            :             {
<span class="lineNum">    7134 </span><span class="lineCov">         38 :               walk_tree (&amp;init, notice_forced_label_r, NULL, NULL);</span>
<span class="lineNum">    7135 </span><span class="lineCov">         38 :               add_local_decl (cfun, decl);</span>
<span class="lineNum">    7136 </span>            :             }
<span class="lineNum">    7137 </span>            :           /* And make sure it's in the symbol table for
<span class="lineNum">    7138 </span>            :              c_parse_final_cleanups to find.  */
<span class="lineNum">    7139 </span><span class="lineCov">      10350 :           varpool_node::get_create (decl);</span>
<span class="lineNum">    7140 </span>            :         }
<span class="lineNum">    7141 </span>            : 
<span class="lineNum">    7142 </span>            :       /* Convert the initializer to the type of DECL, if we have not
<span class="lineNum">    7143 </span>            :          already initialized DECL.  */
<span class="lineNum">    7144 </span><span class="lineCov">    3871525 :       if (!DECL_INITIALIZED_P (decl)</span>
<span class="lineNum">    7145 </span>            :           /* If !DECL_EXTERNAL then DECL is being defined.  In the
<span class="lineNum">    7146 </span>            :              case of a static data member initialized inside the
<span class="lineNum">    7147 </span>            :              class-specifier, there can be an initializer even if DECL
<span class="lineNum">    7148 </span>            :              is *not* defined.  */
<span class="lineNum">    7149 </span><span class="lineCov">    3871525 :           &amp;&amp; (!DECL_EXTERNAL (decl) || init))</span>
<span class="lineNum">    7150 </span>            :         {
<span class="lineNum">    7151 </span><span class="lineCov">    3191018 :           cleanups = make_tree_vector ();</span>
<span class="lineNum">    7152 </span><span class="lineCov">    3191018 :           init = check_initializer (decl, init, flags, &amp;cleanups);</span>
<span class="lineNum">    7153 </span>            : 
<span class="lineNum">    7154 </span>            :           /* Handle:
<span class="lineNum">    7155 </span>            : 
<span class="lineNum">    7156 </span>            :              [dcl.init]
<span class="lineNum">    7157 </span>            : 
<span class="lineNum">    7158 </span>            :              The memory occupied by any object of static storage
<span class="lineNum">    7159 </span>            :              duration is zero-initialized at program startup before
<span class="lineNum">    7160 </span>            :              any other initialization takes place.
<span class="lineNum">    7161 </span>            : 
<span class="lineNum">    7162 </span>            :              We cannot create an appropriate initializer until after
<span class="lineNum">    7163 </span>            :              the type of DECL is finalized.  If DECL_INITIAL is set,
<span class="lineNum">    7164 </span>            :              then the DECL is statically initialized, and any
<span class="lineNum">    7165 </span>            :              necessary zero-initialization has already been performed.  */
<span class="lineNum">    7166 </span><span class="lineCov">    3191018 :           if (TREE_STATIC (decl) &amp;&amp; !DECL_INITIAL (decl))</span>
<span class="lineNum">    7167 </span><span class="lineCov">      47224 :             DECL_INITIAL (decl) = build_zero_init (TREE_TYPE (decl),</span>
<span class="lineNum">    7168 </span>            :                                                    /*nelts=*/NULL_TREE,
<span class="lineNum">    7169 </span>            :                                                    /*static_storage_p=*/true);
<span class="lineNum">    7170 </span>            :           /* Remember that the initialization for this variable has
<span class="lineNum">    7171 </span>            :              taken place.  */
<span class="lineNum">    7172 </span><span class="lineCov">    3191018 :           DECL_INITIALIZED_P (decl) = 1;</span>
<span class="lineNum">    7173 </span>            :           /* This declaration is the definition of this variable,
<span class="lineNum">    7174 </span>            :              unless we are initializing a static data member within
<span class="lineNum">    7175 </span>            :              the class specifier.  */
<span class="lineNum">    7176 </span><span class="lineCov">    3191018 :           if (!DECL_EXTERNAL (decl))</span>
<span class="lineNum">    7177 </span><span class="lineCov">    2805554 :             var_definition_p = true;</span>
<span class="lineNum">    7178 </span>            :         }
<span class="lineNum">    7179 </span>            :       /* If the variable has an array type, lay out the type, even if
<span class="lineNum">    7180 </span>            :          there is no initializer.  It is valid to index through the
<span class="lineNum">    7181 </span>            :          array, and we must get TYPE_ALIGN set correctly on the array
<span class="lineNum">    7182 </span>            :          type.  */
<span class="lineNum">    7183 </span><span class="lineCov">     680507 :       else if (TREE_CODE (type) == ARRAY_TYPE)</span>
<span class="lineNum">    7184 </span><span class="lineCov">      50615 :         layout_type (type);</span>
<span class="lineNum">    7185 </span>            : 
<span class="lineNum">    7186 </span><span class="lineCov">    3871525 :       if (TREE_STATIC (decl)</span>
<span class="lineNum">    7187 </span><span class="lineCov">    1560084 :           &amp;&amp; !at_function_scope_p ()</span>
<span class="lineNum">    7188 </span><span class="lineCov">    5409499 :           &amp;&amp; current_function_decl == NULL)</span>
<span class="lineNum">    7189 </span>            :         /* So decl is a global variable or a static member of a
<span class="lineNum">    7190 </span>            :            non local class. Record the types it uses
<span class="lineNum">    7191 </span>            :            so that we can decide later to emit debug info for them.  */
<span class="lineNum">    7192 </span><span class="lineCov">    1537962 :         record_types_used_by_current_var_decl (decl);</span>
<span class="lineNum">    7193 </span>            :     }
<span class="lineNum">    7194 </span>            : 
<span class="lineNum">    7195 </span>            :   /* Add this declaration to the statement-tree.  This needs to happen
<span class="lineNum">    7196 </span>            :      after the call to check_initializer so that the DECL_EXPR for a
<span class="lineNum">    7197 </span>            :      reference temp is added before the DECL_EXPR for the reference itself.  */
<span class="lineNum">    7198 </span><span class="lineCov">    9359314 :   if (DECL_FUNCTION_SCOPE_P (decl))</span>
<span class="lineNum">    7199 </span>            :     {
<span class="lineNum">    7200 </span>            :       /* If we're building a variable sized type, and we might be
<span class="lineNum">    7201 </span>            :          reachable other than via the top of the current binding
<span class="lineNum">    7202 </span>            :          level, then create a new BIND_EXPR so that we deallocate
<span class="lineNum">    7203 </span>            :          the object at the right time.  */
<span class="lineNum">    7204 </span><span class="lineCov">    2090399 :       if (VAR_P (decl)</span>
<span class="lineNum">    7205 </span><span class="lineCov">    2090399 :           &amp;&amp; DECL_SIZE (decl)</span>
<span class="lineNum">    7206 </span><span class="lineCov">    4038996 :           &amp;&amp; !TREE_CONSTANT (DECL_SIZE (decl))</span>
<span class="lineNum">    7207 </span><span class="lineCov">    2091059 :           &amp;&amp; STATEMENT_LIST_HAS_LABEL (cur_stmt_list))</span>
<span class="lineNum">    7208 </span>            :         {
<span class="lineNum">    7209 </span><span class="lineCov">          3 :           tree bind;</span>
<span class="lineNum">    7210 </span><span class="lineCov">          3 :           bind = build3 (BIND_EXPR, void_type_node, NULL, NULL, NULL);</span>
<span class="lineNum">    7211 </span><span class="lineCov">          3 :           TREE_SIDE_EFFECTS (bind) = 1;</span>
<span class="lineNum">    7212 </span><span class="lineCov">          3 :           add_stmt (bind);</span>
<span class="lineNum">    7213 </span><span class="lineCov">          3 :           BIND_EXPR_BODY (bind) = push_stmt_list ();</span>
<span class="lineNum">    7214 </span>            :         }
<span class="lineNum">    7215 </span><span class="lineCov">    2090399 :       add_decl_expr (decl);</span>
<span class="lineNum">    7216 </span>            :     }
<span class="lineNum">    7217 </span>            : 
<span class="lineNum">    7218 </span>            :   /* Let the middle end know about variables and functions -- but not
<span class="lineNum">    7219 </span>            :      static data members in uninstantiated class templates.  */
<span class="lineNum">    7220 </span><span class="lineCov">    9359314 :   if (VAR_OR_FUNCTION_DECL_P (decl))</span>
<span class="lineNum">    7221 </span>            :     {
<span class="lineNum">    7222 </span><span class="lineCov">    8279300 :       if (VAR_P (decl))</span>
<span class="lineNum">    7223 </span>            :         {
<span class="lineNum">    7224 </span><span class="lineCov">    3871525 :           layout_var_decl (decl);</span>
<span class="lineNum">    7225 </span><span class="lineCov">    3871525 :           maybe_commonize_var (decl);</span>
<span class="lineNum">    7226 </span>            :         }
<span class="lineNum">    7227 </span>            : 
<span class="lineNum">    7228 </span>            :       /* This needs to happen after the linkage is set. */
<span class="lineNum">    7229 </span><span class="lineCov">    8279300 :       determine_visibility (decl);</span>
<span class="lineNum">    7230 </span>            : 
<span class="lineNum">    7231 </span><span class="lineCov">    8279300 :       if (var_definition_p &amp;&amp; TREE_STATIC (decl))</span>
<span class="lineNum">    7232 </span>            :         {
<span class="lineNum">    7233 </span>            :           /* If a TREE_READONLY variable needs initialization
<span class="lineNum">    7234 </span>            :              at runtime, it is no longer readonly and we need to
<span class="lineNum">    7235 </span>            :              avoid MEM_READONLY_P being set on RTL created for it.  */
<span class="lineNum">    7236 </span><span class="lineCov">     737265 :           if (init)</span>
<span class="lineNum">    7237 </span>            :             {
<span class="lineNum">    7238 </span><span class="lineCov">       7880 :               if (TREE_READONLY (decl))</span>
<span class="lineNum">    7239 </span><span class="lineCov">        748 :                 TREE_READONLY (decl) = 0;</span>
<span class="lineNum">    7240 </span>            :               was_readonly = 0;
<span class="lineNum">    7241 </span>            :             }
<span class="lineNum">    7242 </span><span class="lineCov">     729385 :           else if (was_readonly)</span>
<span class="lineNum">    7243 </span><span class="lineCov">        586 :             TREE_READONLY (decl) = 1;</span>
<span class="lineNum">    7244 </span>            : 
<span class="lineNum">    7245 </span>            :           /* Likewise if it needs destruction.  */
<span class="lineNum">    7246 </span><span class="lineCov">     737265 :           if (TYPE_HAS_NONTRIVIAL_DESTRUCTOR (type))</span>
<span class="lineNum">    7247 </span><span class="lineCov">       2440 :             TREE_READONLY (decl) = 0;</span>
<span class="lineNum">    7248 </span>            :         }
<span class="lineNum">    7249 </span>            : 
<span class="lineNum">    7250 </span><span class="lineCov">    8279300 :       make_rtl_for_nonlocal_decl (decl, init, asmspec);</span>
<span class="lineNum">    7251 </span>            : 
<span class="lineNum">    7252 </span>            :       /* Check for abstractness of the type. Notice that there is no
<span class="lineNum">    7253 </span>            :          need to strip array types here since the check for those types
<span class="lineNum">    7254 </span>            :          is already done within create_array_type_for_decl.  */
<span class="lineNum">    7255 </span><span class="lineCov">    8279300 :       abstract_virtuals_error (decl, type);</span>
<span class="lineNum">    7256 </span>            : 
<span class="lineNum">    7257 </span><span class="lineCov">    8279300 :       if (TREE_TYPE (decl) == error_mark_node)</span>
<span class="lineNum">    7258 </span>            :         /* No initialization required.  */
<span class="lineNum">    7259 </span>            :         ;
<span class="lineNum">    7260 </span><span class="lineCov">    8279243 :       else if (TREE_CODE (decl) == FUNCTION_DECL)</span>
<span class="lineNum">    7261 </span>            :         {
<span class="lineNum">    7262 </span><span class="lineCov">    4407775 :           if (init)</span>
<span class="lineNum">    7263 </span>            :             {
<span class="lineNum">    7264 </span><span class="lineCov">        117 :               if (init == ridpointers[(int)RID_DEFAULT])</span>
<span class="lineNum">    7265 </span>            :                 {
<span class="lineNum">    7266 </span>            :                   /* An out-of-class default definition is defined at
<span class="lineNum">    7267 </span>            :                      the point where it is explicitly defaulted.  */
<span class="lineNum">    7268 </span><span class="lineCov">        105 :                   if (DECL_DELETED_FN (decl))</span>
<span class="lineNum">    7269 </span><span class="lineCov">          4 :                     maybe_explain_implicit_delete (decl);</span>
<span class="lineNum">    7270 </span><span class="lineCov">        101 :                   else if (DECL_INITIAL (decl) == error_mark_node)</span>
<span class="lineNum">    7271 </span><span class="lineCov">         95 :                     synthesize_method (decl);</span>
<span class="lineNum">    7272 </span>            :                 }
<span class="lineNum">    7273 </span>            :               else
<span class="lineNum">    7274 </span><span class="lineCov">         12 :                 error (&quot;function %q#D is initialized like a variable&quot;, decl);</span>
<span class="lineNum">    7275 </span>            :             }
<span class="lineNum">    7276 </span>            :           /* else no initialization required.  */
<span class="lineNum">    7277 </span>            :         }
<span class="lineNum">    7278 </span><span class="lineCov">    3871468 :       else if (DECL_EXTERNAL (decl)</span>
<span class="lineNum">    7279 </span><span class="lineCov">    2129670 :                &amp;&amp; ! (DECL_LANG_SPECIFIC (decl)</span>
<span class="lineNum">    7280 </span><span class="lineCov">    5655766 :                      &amp;&amp; DECL_NOT_REALLY_EXTERN (decl)))</span>
<span class="lineNum">    7281 </span>            :         {
<span class="lineNum">    7282 </span><span class="lineCov">     869277 :           if (init)</span>
<span class="lineNum">    7283 </span><span class="lineCov">          4 :             DECL_INITIAL (decl) = init;</span>
<span class="lineNum">    7284 </span>            :         }
<span class="lineNum">    7285 </span>            :       /* A variable definition.  */
<span class="lineNum">    7286 </span><span class="lineCov">    3002191 :       else if (DECL_FUNCTION_SCOPE_P (decl) &amp;&amp; !TREE_STATIC (decl))</span>
<span class="lineNum">    7287 </span>            :         /* Initialize the local variable.  */
<span class="lineNum">    7288 </span><span class="lineCov">    2068274 :         initialize_local_var (decl, init);</span>
<span class="lineNum">    7289 </span>            : 
<span class="lineNum">    7290 </span>            :       /* If a variable is defined, and then a subsequent
<span class="lineNum">    7291 </span>            :          definition with external linkage is encountered, we will
<span class="lineNum">    7292 </span>            :          get here twice for the same variable.  We want to avoid
<span class="lineNum">    7293 </span>            :          calling expand_static_init more than once.  For variables
<span class="lineNum">    7294 </span>            :          that are not static data members, we can call
<span class="lineNum">    7295 </span>            :          expand_static_init only when we actually process the
<span class="lineNum">    7296 </span>            :          initializer.  It is not legal to redeclare a static data
<span class="lineNum">    7297 </span>            :          member, so this issue does not arise in that case.  */
<span class="lineNum">    7298 </span><span class="lineCov">     933917 :       else if (var_definition_p &amp;&amp; TREE_STATIC (decl))</span>
<span class="lineNum">    7299 </span><span class="lineCov">     737234 :         expand_static_init (decl, init);</span>
<span class="lineNum">    7300 </span>            :     }
<span class="lineNum">    7301 </span>            : 
<span class="lineNum">    7302 </span>            :   /* If a CLEANUP_STMT was created to destroy a temporary bound to a
<span class="lineNum">    7303 </span>            :      reference, insert it in the statement-tree now.  */
<span class="lineNum">    7304 </span><span class="lineCov">    9359314 :   if (cleanups)</span>
<span class="lineNum">    7305 </span>            :     {
<span class="lineNum">    7306 </span>            :       unsigned i; tree t;
<span class="lineNum">    7307 </span><span class="lineCov">    3191652 :       FOR_EACH_VEC_ELT (*cleanups, i, t)</span>
<span class="lineNum">    7308 </span><span class="lineCov">        634 :         push_cleanup (decl, t, false);</span>
<span class="lineNum">    7309 </span><span class="lineCov">    3191018 :       release_tree_vector (cleanups);</span>
<span class="lineNum">    7310 </span>            :     }
<span class="lineNum">    7311 </span>            : 
<span class="lineNum">    7312 </span><span class="lineCov">    9359314 :   if (was_readonly)</span>
<span class="lineNum">    7313 </span><span class="lineCov">      60952 :     TREE_READONLY (decl) = 1;</span>
<span class="lineNum">    7314 </span>            : 
<span class="lineNum">    7315 </span><span class="lineCov">    9359314 :   if (flag_openmp</span>
<span class="lineNum">    7316 </span><span class="lineCov">      38734 :       &amp;&amp; VAR_P (decl)</span>
<span class="lineNum">    7317 </span><span class="lineCov">    9371613 :       &amp;&amp; lookup_attribute (&quot;omp declare target implicit&quot;,</span>
<span class="lineNum">    7318 </span><span class="lineCov">      12299 :                            DECL_ATTRIBUTES (decl)))</span>
<span class="lineNum">    7319 </span>            :     {
<span class="lineNum">    7320 </span><span class="lineCov">         72 :       DECL_ATTRIBUTES (decl)</span>
<span class="lineNum">    7321 </span><span class="lineCov">         24 :         = remove_attribute (&quot;omp declare target implicit&quot;,</span>
<span class="lineNum">    7322 </span><span class="lineCov">         24 :                             DECL_ATTRIBUTES (decl));</span>
<span class="lineNum">    7323 </span><span class="lineCov">         24 :       complete_type (TREE_TYPE (decl));</span>
<span class="lineNum">    7324 </span><span class="lineCov">         24 :       if (!cp_omp_mappable_type (TREE_TYPE (decl)))</span>
<span class="lineNum">    7325 </span><span class="lineCov">         12 :         error (&quot;%q+D in declare target directive does not have mappable type&quot;,</span>
<span class="lineNum">    7326 </span>            :                decl);
<span class="lineNum">    7327 </span><span class="lineCov">         24 :       else if (!lookup_attribute (&quot;omp declare target&quot;,</span>
<span class="lineNum">    7328 </span><span class="lineCov">         12 :                                   DECL_ATTRIBUTES (decl))</span>
<span class="lineNum">    7329 </span><span class="lineCov">         24 :                &amp;&amp; !lookup_attribute (&quot;omp declare target link&quot;,</span>
<span class="lineNum">    7330 </span><span class="lineCov">         12 :                                      DECL_ATTRIBUTES (decl)))</span>
<span class="lineNum">    7331 </span><span class="lineCov">         12 :         DECL_ATTRIBUTES (decl)</span>
<span class="lineNum">    7332 </span><span class="lineCov">         12 :           = tree_cons (get_identifier (&quot;omp declare target&quot;),</span>
<span class="lineNum">    7333 </span><span class="lineCov">         12 :                        NULL_TREE, DECL_ATTRIBUTES (decl));</span>
<span class="lineNum">    7334 </span>            :     }
<span class="lineNum">    7335 </span>            : 
<span class="lineNum">    7336 </span><span class="lineCov">    9359436 :   invoke_plugin_callbacks (PLUGIN_FINISH_DECL, decl);</span>
<span class="lineNum">    7337 </span>            : }
<span class="lineNum">    7338 </span>            : 
<span class="lineNum">    7339 </span>            : /* For class TYPE return itself or some its bases that contain
<span class="lineNum">    7340 </span>            :    any direct non-static data members.  Return error_mark_node if an
<span class="lineNum">    7341 </span>            :    error has been diagnosed.  */
<a name="7342"><span class="lineNum">    7342 </span>            : </a>
<span class="lineNum">    7343 </span>            : static tree
<span class="lineNum">    7344 </span><span class="lineCov">        236 : find_decomp_class_base (location_t loc, tree type, tree ret)</span>
<span class="lineNum">    7345 </span>            : {
<span class="lineNum">    7346 </span><span class="lineCov">        236 :   bool member_seen = false;</span>
<span class="lineNum">    7347 </span><span class="lineCov">       3750 :   for (tree field = TYPE_FIELDS (type); field; field = DECL_CHAIN (field))</span>
<span class="lineNum">    7348 </span><span class="lineCov">       3530 :     if (TREE_CODE (field) != FIELD_DECL</span>
<span class="lineNum">    7349 </span><span class="lineCov">        659 :         || DECL_ARTIFICIAL (field)</span>
<span class="lineNum">    7350 </span><span class="lineCov">       5351 :         || DECL_UNNAMED_BIT_FIELD (field))</span>
<span class="lineNum">    7351 </span>            :       continue;
<span class="lineNum">    7352 </span><span class="lineCov">        591 :     else if (ret)</span>
<span class="lineNum">    7353 </span>            :       return type;
<span class="lineNum">    7354 </span><span class="lineCov">        579 :     else if (ANON_AGGR_TYPE_P (TREE_TYPE (field)))</span>
<span class="lineNum">    7355 </span>            :       {
<span class="lineNum">    7356 </span><span class="lineCov">          4 :         if (TREE_CODE (TREE_TYPE (field)) == RECORD_TYPE)</span>
<span class="lineNum">    7357 </span><span class="lineCov">          1 :           error_at (loc, &quot;cannot decompose class type %qT because it has an &quot;</span>
<span class="lineNum">    7358 </span>            :                          &quot;anonymous struct member&quot;, type);
<span class="lineNum">    7359 </span>            :         else
<span class="lineNum">    7360 </span><span class="lineCov">          1 :           error_at (loc, &quot;cannot decompose class type %qT because it has an &quot;</span>
<span class="lineNum">    7361 </span>            :                          &quot;anonymous union member&quot;, type);
<span class="lineNum">    7362 </span><span class="lineCov">          2 :         inform (DECL_SOURCE_LOCATION (field), &quot;declared here&quot;);</span>
<span class="lineNum">    7363 </span><span class="lineCov">          2 :         return error_mark_node;</span>
<span class="lineNum">    7364 </span>            :       }
<span class="lineNum">    7365 </span><span class="lineCov">        577 :     else if (!accessible_p (type, field, true))</span>
<span class="lineNum">    7366 </span>            :       {
<span class="lineNum">    7367 </span><span class="lineCov">          2 :         error_at (loc, &quot;cannot decompose inaccessible member %qD of %qT&quot;,</span>
<span class="lineNum">    7368 </span>            :                   field, type);
<span class="lineNum">    7369 </span><span class="lineCov">          2 :         inform (DECL_SOURCE_LOCATION (field),</span>
<span class="lineNum">    7370 </span>            :                 TREE_PRIVATE (field)
<span class="lineNum">    7371 </span>            :                 ? G_(&quot;declared private here&quot;)
<span class="lineNum">    7372 </span><span class="lineCov">          2 :                 : G_(&quot;declared protected here&quot;));</span>
<span class="lineNum">    7373 </span><span class="lineCov">          2 :         return error_mark_node;</span>
<span class="lineNum">    7374 </span>            :       }
<span class="lineNum">    7375 </span>            :     else
<span class="lineNum">    7376 </span>            :       member_seen = true;
<span class="lineNum">    7377 </span>            : 
<span class="lineNum">    7378 </span><span class="lineCov">        220 :   tree base_binfo, binfo;</span>
<span class="lineNum">    7379 </span><span class="lineCov">        220 :   tree orig_ret = ret;</span>
<span class="lineNum">    7380 </span><span class="lineCov">        220 :   int i;</span>
<span class="lineNum">    7381 </span><span class="lineCov">        220 :   if (member_seen)</span>
<span class="lineNum">    7382 </span><span class="lineCov">        192 :     ret = type;</span>
<span class="lineNum">    7383 </span><span class="lineCov">        254 :   for (binfo = TYPE_BINFO (type), i = 0;</span>
<span class="lineNum">    7384 </span><span class="lineCov">        254 :        BINFO_BASE_ITERATE (binfo, i, base_binfo); i++)</span>
<span class="lineNum">    7385 </span>            :     {
<span class="lineNum">    7386 </span><span class="lineCov">         40 :       tree t = find_decomp_class_base (loc, TREE_TYPE (base_binfo), ret);</span>
<span class="lineNum">    7387 </span><span class="lineCov">         40 :       if (t == error_mark_node)</span>
<span class="lineNum">    7388 </span><span class="lineNoCov">          0 :         return error_mark_node;</span>
<span class="lineNum">    7389 </span><span class="lineCov">         40 :       if (t != NULL_TREE &amp;&amp; t != ret)</span>
<span class="lineNum">    7390 </span>            :         {
<span class="lineNum">    7391 </span><span class="lineCov">         24 :           if (ret == type)</span>
<span class="lineNum">    7392 </span>            :             {
<span class="lineNum">    7393 </span><span class="lineCov">          3 :               error_at (loc, &quot;cannot decompose class type %qT: both it and &quot;</span>
<span class="lineNum">    7394 </span>            :                              &quot;its base class %qT have non-static data members&quot;,
<span class="lineNum">    7395 </span>            :                         type, t);
<span class="lineNum">    7396 </span><span class="lineCov">          3 :               return error_mark_node;</span>
<span class="lineNum">    7397 </span>            :             }
<span class="lineNum">    7398 </span><span class="lineCov">         21 :           else if (orig_ret != NULL_TREE)</span>
<span class="lineNum">    7399 </span><span class="lineNoCov">          0 :             return t;</span>
<span class="lineNum">    7400 </span><span class="lineCov">         21 :           else if (ret != NULL_TREE)</span>
<span class="lineNum">    7401 </span>            :             {
<span class="lineNum">    7402 </span><span class="lineCov">          3 :               error_at (loc, &quot;cannot decompose class type %qT: its base &quot;</span>
<span class="lineNum">    7403 </span>            :                              &quot;classes %qT and %qT have non-static data &quot;
<span class="lineNum">    7404 </span>            :                              &quot;members&quot;, type, ret, t);
<span class="lineNum">    7405 </span><span class="lineCov">          3 :               return error_mark_node;</span>
<span class="lineNum">    7406 </span>            :             }
<span class="lineNum">    7407 </span>            :           else
<span class="lineNum">    7408 </span>            :             ret = t;
<span class="lineNum">    7409 </span>            :         }
<span class="lineNum">    7410 </span>            :     }
<span class="lineNum">    7411 </span>            :   return ret;
<span class="lineNum">    7412 </span>            : }
<span class="lineNum">    7413 </span>            : 
<span class="lineNum">    7414 </span>            : /* Return std::tuple_size&lt;TYPE&gt;::value.  */
<a name="7415"><span class="lineNum">    7415 </span>            : </a>
<span class="lineNum">    7416 </span>            : static tree
<span class="lineNum">    7417 </span><span class="lineCov">        262 : get_tuple_size (tree type)</span>
<span class="lineNum">    7418 </span>            : {
<span class="lineNum">    7419 </span><span class="lineCov">        262 :   tree args = make_tree_vec (1);</span>
<span class="lineNum">    7420 </span><span class="lineCov">        262 :   TREE_VEC_ELT (args, 0) = type;</span>
<span class="lineNum">    7421 </span><span class="lineCov">        262 :   tree inst = lookup_template_class (tuple_size_identifier, args,</span>
<span class="lineNum">    7422 </span>            :                                      /*in_decl*/NULL_TREE,
<span class="lineNum">    7423 </span>            :                                      /*context*/std_node,
<span class="lineNum">    7424 </span><span class="lineCov">        262 :                                      /*entering_scope*/false, tf_none);</span>
<span class="lineNum">    7425 </span><span class="lineCov">        262 :   inst = complete_type (inst);</span>
<span class="lineNum">    7426 </span><span class="lineCov">        262 :   if (inst == error_mark_node || !COMPLETE_TYPE_P (inst))</span>
<span class="lineNum">    7427 </span>            :     return NULL_TREE;
<span class="lineNum">    7428 </span><span class="lineCov">         54 :   tree val = lookup_qualified_name (inst, value_identifier,</span>
<span class="lineNum">    7429 </span><span class="lineCov">         54 :                                     /*type*/false, /*complain*/false);</span>
<span class="lineNum">    7430 </span><span class="lineCov">         54 :   if (TREE_CODE (val) == VAR_DECL || TREE_CODE (val) == CONST_DECL)</span>
<span class="lineNum">    7431 </span><span class="lineCov">         53 :     val = maybe_constant_value (val);</span>
<span class="lineNum">    7432 </span><span class="lineCov">         54 :   if (TREE_CODE (val) == INTEGER_CST)</span>
<span class="lineNum">    7433 </span>            :     return val;
<span class="lineNum">    7434 </span>            :   else
<span class="lineNum">    7435 </span><span class="lineCov">          1 :     return error_mark_node;</span>
<span class="lineNum">    7436 </span>            : }
<span class="lineNum">    7437 </span>            : 
<span class="lineNum">    7438 </span>            : /* Return std::tuple_element&lt;I,TYPE&gt;::type.  */
<a name="7439"><span class="lineNum">    7439 </span>            : </a>
<span class="lineNum">    7440 </span>            : static tree
<span class="lineNum">    7441 </span><span class="lineCov">         70 : get_tuple_element_type (tree type, unsigned i)</span>
<span class="lineNum">    7442 </span>            : {
<span class="lineNum">    7443 </span><span class="lineCov">         70 :   tree args = make_tree_vec (2);</span>
<span class="lineNum">    7444 </span><span class="lineCov">        140 :   TREE_VEC_ELT (args, 0) = build_int_cst (integer_type_node, i);</span>
<span class="lineNum">    7445 </span><span class="lineCov">         70 :   TREE_VEC_ELT (args, 1) = type;</span>
<span class="lineNum">    7446 </span><span class="lineCov">         70 :   tree inst = lookup_template_class (tuple_element_identifier, args,</span>
<span class="lineNum">    7447 </span>            :                                      /*in_decl*/NULL_TREE,
<span class="lineNum">    7448 </span>            :                                      /*context*/std_node,
<span class="lineNum">    7449 </span>            :                                      /*entering_scope*/false,
<span class="lineNum">    7450 </span>            :                                      tf_warning_or_error);
<span class="lineNum">    7451 </span><span class="lineCov">         70 :   return make_typename_type (inst, type_identifier,</span>
<span class="lineNum">    7452 </span><span class="lineCov">         70 :                              none_type, tf_warning_or_error);</span>
<span class="lineNum">    7453 </span>            : }
<span class="lineNum">    7454 </span>            : 
<span class="lineNum">    7455 </span>            : /* Return e.get&lt;i&gt;() or get&lt;i&gt;(e).  */
<a name="7456"><span class="lineNum">    7456 </span>            : </a>
<span class="lineNum">    7457 </span>            : static tree
<span class="lineNum">    7458 </span><span class="lineCov">         73 : get_tuple_decomp_init (tree decl, unsigned i)</span>
<span class="lineNum">    7459 </span>            : {
<span class="lineNum">    7460 </span><span class="lineCov">         73 :   tree targs = make_tree_vec (1);</span>
<span class="lineNum">    7461 </span><span class="lineCov">        146 :   TREE_VEC_ELT (targs, 0) = build_int_cst (integer_type_node, i);</span>
<span class="lineNum">    7462 </span>            : 
<span class="lineNum">    7463 </span><span class="lineCov">         73 :   tree etype = TREE_TYPE (decl);</span>
<span class="lineNum">    7464 </span><span class="lineCov">         73 :   tree e = convert_from_reference (decl);</span>
<span class="lineNum">    7465 </span>            : 
<span class="lineNum">    7466 </span>            :   /* [The id-expression] e is an lvalue if the type of the entity e is an
<span class="lineNum">    7467 </span>            :      lvalue reference and an xvalue otherwise.  */
<span class="lineNum">    7468 </span><span class="lineCov">         73 :   if (!TYPE_REF_P (etype)</span>
<span class="lineNum">    7469 </span><span class="lineCov">         73 :       || TYPE_REF_IS_RVALUE (etype))</span>
<span class="lineNum">    7470 </span><span class="lineCov">         55 :     e = move (e);</span>
<span class="lineNum">    7471 </span>            : 
<span class="lineNum">    7472 </span><span class="lineCov">         73 :   tree fns = lookup_qualified_name (TREE_TYPE (e), get__identifier,</span>
<span class="lineNum">    7473 </span><span class="lineCov">         73 :                                     /*type*/false, /*complain*/false);</span>
<span class="lineNum">    7474 </span><span class="lineCov">         73 :   bool use_member_get = false;</span>
<span class="lineNum">    7475 </span>            : 
<span class="lineNum">    7476 </span>            :   /* To use a member get, member lookup must find at least one
<span class="lineNum">    7477 </span>            :      declaration that is a function template
<span class="lineNum">    7478 </span>            :      whose first template parameter is a non-type parameter.  */
<span class="lineNum">    7479 </span><span class="lineCov">        266 :   for (lkp_iterator iter (MAYBE_BASELINK_FUNCTIONS (fns)); iter; ++iter)</span>
<span class="lineNum">    7480 </span>            :     {
<span class="lineNum">    7481 </span><span class="lineCov">         73 :       tree fn = *iter;</span>
<span class="lineNum">    7482 </span><span class="lineCov">         73 :       if (TREE_CODE (fn) == TEMPLATE_DECL)</span>
<span class="lineNum">    7483 </span>            :         {
<span class="lineNum">    7484 </span><span class="lineCov">         27 :           tree tparms = DECL_TEMPLATE_PARMS (fn);</span>
<span class="lineNum">    7485 </span><span class="lineCov">         27 :           tree parm = TREE_VEC_ELT (INNERMOST_TEMPLATE_PARMS (tparms), 0);</span>
<span class="lineNum">    7486 </span><span class="lineCov">         27 :           if (TREE_CODE (TREE_VALUE (parm)) == PARM_DECL)</span>
<span class="lineNum">    7487 </span>            :             {
<span class="lineNum">    7488 </span>            :               use_member_get = true;
<span class="lineNum">    7489 </span>            :               break;
<span class="lineNum">    7490 </span>            :             }
<span class="lineNum">    7491 </span>            :         }
<span class="lineNum">    7492 </span>            :     }
<span class="lineNum">    7493 </span>            : 
<span class="lineNum">    7494 </span><span class="lineCov">         73 :   if (use_member_get)</span>
<span class="lineNum">    7495 </span>            :     {
<span class="lineNum">    7496 </span><span class="lineCov">         26 :       fns = lookup_template_function (fns, targs);</span>
<span class="lineNum">    7497 </span><span class="lineCov">         26 :       return build_new_method_call (e, fns, /*args*/NULL,</span>
<span class="lineNum">    7498 </span>            :                                     /*path*/NULL_TREE, LOOKUP_NORMAL,
<span class="lineNum">    7499 </span><span class="lineCov">         26 :                                     /*fn_p*/NULL, tf_warning_or_error);</span>
<span class="lineNum">    7500 </span>            :     }
<span class="lineNum">    7501 </span>            :   else
<span class="lineNum">    7502 </span>            :     {
<span class="lineNum">    7503 </span><span class="lineCov">         47 :       vec&lt;tree,va_gc&gt; *args = make_tree_vector_single (e);</span>
<span class="lineNum">    7504 </span><span class="lineCov">         47 :       fns = lookup_template_function (get__identifier, targs);</span>
<span class="lineNum">    7505 </span><span class="lineCov">         47 :       fns = perform_koenig_lookup (fns, args, tf_warning_or_error);</span>
<span class="lineNum">    7506 </span><span class="lineCov">         47 :       return finish_call_expr (fns, &amp;args, /*novirt*/false,</span>
<span class="lineNum">    7507 </span>            :                                /*koenig*/true, tf_warning_or_error);
<span class="lineNum">    7508 </span>            :     }
<span class="lineNum">    7509 </span>            : }
<span class="lineNum">    7510 </span>            : 
<span class="lineNum">    7511 </span>            : /* It's impossible to recover the decltype of a tuple decomposition variable
<span class="lineNum">    7512 </span>            :    based on the actual type of the variable, so store it in a hash table.  */
<span class="lineNum">    7513 </span>            : 
<a name="7514"><span class="lineNum">    7514 </span>            : static GTY((cache)) tree_cache_map *decomp_type_table;</a>
<span class="lineNum">    7515 </span>            : static void
<span class="lineNum">    7516 </span><span class="lineCov">         67 : store_decomp_type (tree v, tree t)</span>
<span class="lineNum">    7517 </span>            : {
<span class="lineNum">    7518 </span><span class="lineCov">         67 :   if (!decomp_type_table)</span>
<span class="lineNum">    7519 </span><span class="lineCov">         18 :     decomp_type_table = tree_cache_map::create_ggc (13);</span>
<span class="lineNum">    7520 </span><span class="lineCov">         67 :   decomp_type_table-&gt;put (v, t);</span>
<span class="lineNum">    7521 </span><span class="lineCov">         67 : }</span>
<a name="7522"><span class="lineNum">    7522 </span>            : </a>
<span class="lineNum">    7523 </span>            : tree
<span class="lineNum">    7524 </span><span class="lineCov">          8 : lookup_decomp_type (tree v)</span>
<span class="lineNum">    7525 </span>            : {
<span class="lineNum">    7526 </span><span class="lineCov">          8 :   return *decomp_type_table-&gt;get (v);</span>
<span class="lineNum">    7527 </span>            : }
<span class="lineNum">    7528 </span>            : 
<span class="lineNum">    7529 </span>            : /* Mangle a decomposition declaration if needed.  Arguments like
<span class="lineNum">    7530 </span>            :    in cp_finish_decomp.  */
<a name="7531"><span class="lineNum">    7531 </span>            : </a>
<span class="lineNum">    7532 </span>            : void
<span class="lineNum">    7533 </span><span class="lineCov">        349 : cp_maybe_mangle_decomp (tree decl, tree first, unsigned int count)</span>
<span class="lineNum">    7534 </span>            : {
<span class="lineNum">    7535 </span><span class="lineCov">        349 :   if (!processing_template_decl</span>
<span class="lineNum">    7536 </span><span class="lineCov">        311 :       &amp;&amp; !error_operand_p (decl)</span>
<span class="lineNum">    7537 </span><span class="lineCov">        660 :       &amp;&amp; DECL_NAMESPACE_SCOPE_P (decl))</span>
<span class="lineNum">    7538 </span>            :     {
<span class="lineNum">    7539 </span><span class="lineCov">        100 :       auto_vec&lt;tree, 16&gt; v;</span>
<span class="lineNum">    7540 </span><span class="lineCov">         50 :       v.safe_grow (count);</span>
<span class="lineNum">    7541 </span><span class="lineCov">         50 :       tree d = first;</span>
<span class="lineNum">    7542 </span><span class="lineCov">        176 :       for (unsigned int i = 0; i &lt; count; i++, d = DECL_CHAIN (d))</span>
<span class="lineNum">    7543 </span><span class="lineCov">        126 :         v[count - i - 1] = d;</span>
<span class="lineNum">    7544 </span><span class="lineCov">         50 :       SET_DECL_ASSEMBLER_NAME (decl, mangle_decomp (decl, v));</span>
<span class="lineNum">    7545 </span><span class="lineCov">         50 :       maybe_apply_pragma_weak (decl);</span>
<span class="lineNum">    7546 </span>            :     }
<span class="lineNum">    7547 </span><span class="lineCov">        349 : }</span>
<span class="lineNum">    7548 </span>            : 
<span class="lineNum">    7549 </span>            : /* Finish a decomposition declaration.  DECL is the underlying declaration
<span class="lineNum">    7550 </span>            :    &quot;e&quot;, FIRST is the head of a chain of decls for the individual identifiers
<span class="lineNum">    7551 </span>            :    chained through DECL_CHAIN in reverse order and COUNT is the number of
<span class="lineNum">    7552 </span>            :    those decls.  */
<a name="7553"><span class="lineNum">    7553 </span>            : </a>
<span class="lineNum">    7554 </span>            : void
<span class="lineNum">    7555 </span><span class="lineCov">        393 : cp_finish_decomp (tree decl, tree first, unsigned int count)</span>
<span class="lineNum">    7556 </span>            : {
<span class="lineNum">    7557 </span><span class="lineCov">        393 :   if (error_operand_p (decl))</span>
<span class="lineNum">    7558 </span>            :     {
<span class="lineNum">    7559 </span><span class="lineCov">        141 :      error_out:</span>
<span class="lineNum">    7560 </span><span class="lineCov">        141 :       while (count--)</span>
<span class="lineNum">    7561 </span>            :         {
<span class="lineNum">    7562 </span><span class="lineCov">         88 :           TREE_TYPE (first) = error_mark_node;</span>
<span class="lineNum">    7563 </span><span class="lineCov">         88 :           if (DECL_HAS_VALUE_EXPR_P (first))</span>
<span class="lineNum">    7564 </span>            :             {
<span class="lineNum">    7565 </span><span class="lineCov">          2 :               SET_DECL_VALUE_EXPR (first, NULL_TREE);</span>
<span class="lineNum">    7566 </span><span class="lineCov">          2 :               DECL_HAS_VALUE_EXPR_P (first) = 0;</span>
<span class="lineNum">    7567 </span>            :             }
<span class="lineNum">    7568 </span><span class="lineCov">         88 :           first = DECL_CHAIN (first);</span>
<span class="lineNum">    7569 </span>            :         }
<span class="lineNum">    7570 </span><span class="lineCov">         53 :       if (DECL_P (decl) &amp;&amp; DECL_NAMESPACE_SCOPE_P (decl))</span>
<span class="lineNum">    7571 </span><span class="lineCov">         17 :         SET_DECL_ASSEMBLER_NAME (decl, get_identifier (&quot;&lt;decomp&gt;&quot;));</span>
<span class="lineNum">    7572 </span><span class="lineCov">        114 :       return;</span>
<span class="lineNum">    7573 </span>            :     }
<span class="lineNum">    7574 </span>            : 
<span class="lineNum">    7575 </span><span class="lineCov">        383 :   location_t loc = DECL_SOURCE_LOCATION (decl);</span>
<span class="lineNum">    7576 </span><span class="lineCov">        383 :   if (type_dependent_expression_p (decl)</span>
<span class="lineNum">    7577 </span>            :       /* This happens for range for when not in templates.
<span class="lineNum">    7578 </span>            :          Still add the DECL_VALUE_EXPRs for later processing.  */
<span class="lineNum">    7579 </span><span class="lineCov">        383 :       || (!processing_template_decl</span>
<span class="lineNum">    7580 </span><span class="lineCov">        325 :           &amp;&amp; type_uses_auto (TREE_TYPE (decl))))</span>
<span class="lineNum">    7581 </span>            :     {
<span class="lineNum">    7582 </span><span class="lineCov">        336 :       for (unsigned int i = 0; i &lt; count; i++)</span>
<span class="lineNum">    7583 </span>            :         {
<span class="lineNum">    7584 </span><span class="lineCov">        275 :           if (!DECL_HAS_VALUE_EXPR_P (first))</span>
<span class="lineNum">    7585 </span>            :             {
<span class="lineNum">    7586 </span><span class="lineCov">        275 :               tree v = build_nt (ARRAY_REF, decl,</span>
<span class="lineNum">    7587 </span><span class="lineCov">        275 :                                  size_int (count - i - 1),</span>
<span class="lineNum">    7588 </span>            :                                  NULL_TREE, NULL_TREE);
<span class="lineNum">    7589 </span><span class="lineCov">        275 :               SET_DECL_VALUE_EXPR (first, v);</span>
<span class="lineNum">    7590 </span><span class="lineCov">        275 :               DECL_HAS_VALUE_EXPR_P (first) = 1;</span>
<span class="lineNum">    7591 </span>            :             }
<span class="lineNum">    7592 </span><span class="lineCov">        275 :           if (processing_template_decl)</span>
<span class="lineNum">    7593 </span><span class="lineCov">         69 :             fit_decomposition_lang_decl (first, decl);</span>
<span class="lineNum">    7594 </span><span class="lineCov">        275 :           first = DECL_CHAIN (first);</span>
<span class="lineNum">    7595 </span>            :         }
<span class="lineNum">    7596 </span>            :       return;
<span class="lineNum">    7597 </span>            :     }
<span class="lineNum">    7598 </span>            : 
<span class="lineNum">    7599 </span><span class="lineCov">        880 :   auto_vec&lt;tree, 16&gt; v;</span>
<span class="lineNum">    7600 </span><span class="lineCov">        322 :   v.safe_grow (count);</span>
<span class="lineNum">    7601 </span><span class="lineCov">        322 :   tree d = first;</span>
<span class="lineNum">    7602 </span><span class="lineCov">       1193 :   for (unsigned int i = 0; i &lt; count; i++, d = DECL_CHAIN (d))</span>
<span class="lineNum">    7603 </span>            :     {
<span class="lineNum">    7604 </span><span class="lineCov">        871 :       v[count - i - 1] = d;</span>
<span class="lineNum">    7605 </span><span class="lineCov">        871 :       fit_decomposition_lang_decl (d, decl);</span>
<span class="lineNum">    7606 </span>            :     }
<span class="lineNum">    7607 </span>            : 
<span class="lineNum">    7608 </span><span class="lineCov">        322 :   tree type = TREE_TYPE (decl);</span>
<span class="lineNum">    7609 </span><span class="lineCov">        322 :   tree dexp = decl;</span>
<span class="lineNum">    7610 </span>            : 
<span class="lineNum">    7611 </span><span class="lineCov">        322 :   if (TYPE_REF_P (type))</span>
<span class="lineNum">    7612 </span>            :     {
<span class="lineNum">    7613 </span><span class="lineCov">         98 :       dexp = convert_from_reference (dexp);</span>
<span class="lineNum">    7614 </span><span class="lineCov">         98 :       type = complete_type (TREE_TYPE (type));</span>
<span class="lineNum">    7615 </span><span class="lineCov">         98 :       if (type == error_mark_node)</span>
<span class="lineNum">    7616 </span><span class="lineCov">         86 :         goto error_out;</span>
<span class="lineNum">    7617 </span><span class="lineCov">         98 :       if (!COMPLETE_TYPE_P (type))</span>
<span class="lineNum">    7618 </span>            :         {
<span class="lineNum">    7619 </span><span class="lineCov">          2 :           error_at (loc, &quot;structured binding refers to incomplete type %qT&quot;,</span>
<span class="lineNum">    7620 </span>            :                     type);
<span class="lineNum">    7621 </span><span class="lineCov">          2 :           goto error_out;</span>
<span class="lineNum">    7622 </span>            :         }
<span class="lineNum">    7623 </span>            :     }
<span class="lineNum">    7624 </span>            : 
<span class="lineNum">    7625 </span><span class="lineCov">        320 :   tree eltype = NULL_TREE;</span>
<span class="lineNum">    7626 </span><span class="lineCov">        320 :   unsigned HOST_WIDE_INT eltscnt = 0;</span>
<span class="lineNum">    7627 </span><span class="lineCov">        320 :   if (TREE_CODE (type) == ARRAY_TYPE)</span>
<span class="lineNum">    7628 </span>            :     {
<span class="lineNum">    7629 </span><span class="lineCov">         46 :       tree nelts;</span>
<span class="lineNum">    7630 </span><span class="lineCov">         46 :       nelts = array_type_nelts_top (type);</span>
<span class="lineNum">    7631 </span><span class="lineCov">         46 :       if (nelts == error_mark_node)</span>
<span class="lineNum">    7632 </span>            :         goto error_out;
<span class="lineNum">    7633 </span><span class="lineCov">         46 :       if (!tree_fits_uhwi_p (nelts))</span>
<span class="lineNum">    7634 </span>            :         {
<span class="lineNum">    7635 </span><span class="lineNoCov">          0 :           error_at (loc, &quot;cannot decompose variable length array %qT&quot;, type);</span>
<span class="lineNum">    7636 </span><span class="lineNoCov">          0 :           goto error_out;</span>
<span class="lineNum">    7637 </span>            :         }
<span class="lineNum">    7638 </span><span class="lineCov">         46 :       eltscnt = tree_to_uhwi (nelts);</span>
<span class="lineNum">    7639 </span><span class="lineCov">         46 :       if (count != eltscnt)</span>
<span class="lineNum">    7640 </span>            :         {
<span class="lineNum">    7641 </span><span class="lineCov">          2 :        cnt_mismatch:</span>
<span class="lineNum">    7642 </span><span class="lineCov">          6 :           if (count &gt; eltscnt)</span>
<span class="lineNum">    7643 </span><span class="lineCov">          3 :             error_n (loc, count,</span>
<span class="lineNum">    7644 </span>            :                      &quot;%u name provided for structured binding&quot;,
<span class="lineNum">    7645 </span>            :                      &quot;%u names provided for structured binding&quot;, count);
<span class="lineNum">    7646 </span>            :           else
<span class="lineNum">    7647 </span><span class="lineCov">          3 :             error_n (loc, count,</span>
<span class="lineNum">    7648 </span>            :                      &quot;only %u name provided for structured binding&quot;,
<span class="lineNum">    7649 </span>            :                      &quot;only %u names provided for structured binding&quot;, count);
<span class="lineNum">    7650 </span><span class="lineCov">          6 :           inform_n (loc, eltscnt,</span>
<span class="lineNum">    7651 </span>            :                     &quot;while %qT decomposes into %wu element&quot;,
<span class="lineNum">    7652 </span>            :                     &quot;while %qT decomposes into %wu elements&quot;,
<span class="lineNum">    7653 </span>            :                     type, eltscnt);
<span class="lineNum">    7654 </span><span class="lineCov">          6 :           goto error_out;</span>
<span class="lineNum">    7655 </span>            :         }
<span class="lineNum">    7656 </span><span class="lineCov">         44 :       eltype = TREE_TYPE (type);</span>
<span class="lineNum">    7657 </span><span class="lineCov">        186 :       for (unsigned int i = 0; i &lt; count; i++)</span>
<span class="lineNum">    7658 </span>            :         {
<span class="lineNum">    7659 </span><span class="lineCov">        142 :           TREE_TYPE (v[i]) = eltype;</span>
<span class="lineNum">    7660 </span><span class="lineCov">        142 :           layout_decl (v[i], 0);</span>
<span class="lineNum">    7661 </span><span class="lineCov">        142 :           if (processing_template_decl)</span>
<span class="lineNum">    7662 </span>            :             continue;
<span class="lineNum">    7663 </span><span class="lineCov">        134 :           tree t = unshare_expr (dexp);</span>
<span class="lineNum">    7664 </span><span class="lineCov">        268 :           t = build4_loc (DECL_SOURCE_LOCATION (v[i]), ARRAY_REF,</span>
<span class="lineNum">    7665 </span>            :                           eltype, t, size_int (i), NULL_TREE,
<span class="lineNum">    7666 </span>            :                           NULL_TREE);
<span class="lineNum">    7667 </span><span class="lineCov">        134 :           SET_DECL_VALUE_EXPR (v[i], t);</span>
<span class="lineNum">    7668 </span><span class="lineCov">        134 :           DECL_HAS_VALUE_EXPR_P (v[i]) = 1;</span>
<span class="lineNum">    7669 </span>            :         }
<span class="lineNum">    7670 </span>            :     }
<span class="lineNum">    7671 </span>            :   /* 2 GNU extensions.  */
<span class="lineNum">    7672 </span><span class="lineCov">        274 :   else if (TREE_CODE (type) == COMPLEX_TYPE)</span>
<span class="lineNum">    7673 </span>            :     {
<span class="lineNum">    7674 </span><span class="lineCov">          8 :       eltscnt = 2;</span>
<span class="lineNum">    7675 </span><span class="lineCov">          8 :       if (count != eltscnt)</span>
<span class="lineNum">    7676 </span>            :         goto cnt_mismatch;
<span class="lineNum">    7677 </span><span class="lineCov">          8 :       eltype = cp_build_qualified_type (TREE_TYPE (type), TYPE_QUALS (type));</span>
<span class="lineNum">    7678 </span><span class="lineCov">         24 :       for (unsigned int i = 0; i &lt; count; i++)</span>
<span class="lineNum">    7679 </span>            :         {
<span class="lineNum">    7680 </span><span class="lineCov">         16 :           TREE_TYPE (v[i]) = eltype;</span>
<span class="lineNum">    7681 </span><span class="lineCov">         16 :           layout_decl (v[i], 0);</span>
<span class="lineNum">    7682 </span><span class="lineCov">         16 :           if (processing_template_decl)</span>
<span class="lineNum">    7683 </span>            :             continue;
<span class="lineNum">    7684 </span><span class="lineCov">         16 :           tree t = unshare_expr (dexp);</span>
<span class="lineNum">    7685 </span><span class="lineCov">         24 :           t = build1_loc (DECL_SOURCE_LOCATION (v[i]),</span>
<span class="lineNum">    7686 </span>            :                           i ? IMAGPART_EXPR : REALPART_EXPR, eltype,
<span class="lineNum">    7687 </span>            :                           t);
<span class="lineNum">    7688 </span><span class="lineCov">         16 :           SET_DECL_VALUE_EXPR (v[i], t);</span>
<span class="lineNum">    7689 </span><span class="lineCov">         16 :           DECL_HAS_VALUE_EXPR_P (v[i]) = 1;</span>
<span class="lineNum">    7690 </span>            :         }
<span class="lineNum">    7691 </span>            :     }
<span class="lineNum">    7692 </span><span class="lineCov">        266 :   else if (TREE_CODE (type) == VECTOR_TYPE)</span>
<span class="lineNum">    7693 </span>            :     {
<span class="lineNum">    7694 </span><span class="lineCov">          4 :       if (!TYPE_VECTOR_SUBPARTS (type).is_constant (&amp;eltscnt))</span>
<span class="lineNum">    7695 </span>            :         {
<span class="lineNum">    7696 </span>            :           error_at (loc, &quot;cannot decompose variable length vector %qT&quot;, type);
<span class="lineNum">    7697 </span>            :           goto error_out;
<span class="lineNum">    7698 </span>            :         }
<span class="lineNum">    7699 </span><span class="lineCov">          4 :       if (count != eltscnt)</span>
<span class="lineNum">    7700 </span>            :         goto cnt_mismatch;
<span class="lineNum">    7701 </span><span class="lineCov">          4 :       eltype = cp_build_qualified_type (TREE_TYPE (type), TYPE_QUALS (type));</span>
<span class="lineNum">    7702 </span><span class="lineCov">         20 :       for (unsigned int i = 0; i &lt; count; i++)</span>
<span class="lineNum">    7703 </span>            :         {
<span class="lineNum">    7704 </span><span class="lineCov">         16 :           TREE_TYPE (v[i]) = eltype;</span>
<span class="lineNum">    7705 </span><span class="lineCov">         16 :           layout_decl (v[i], 0);</span>
<span class="lineNum">    7706 </span><span class="lineCov">         16 :           if (processing_template_decl)</span>
<span class="lineNum">    7707 </span><span class="lineNoCov">          0 :             continue;</span>
<span class="lineNum">    7708 </span><span class="lineCov">         16 :           tree t = unshare_expr (dexp);</span>
<span class="lineNum">    7709 </span><span class="lineCov">         32 :           convert_vector_to_array_for_subscript (DECL_SOURCE_LOCATION (v[i]),</span>
<span class="lineNum">    7710 </span>            :                                                  &amp;t, size_int (i));
<span class="lineNum">    7711 </span><span class="lineCov">         32 :           t = build4_loc (DECL_SOURCE_LOCATION (v[i]), ARRAY_REF,</span>
<span class="lineNum">    7712 </span>            :                           eltype, t, size_int (i), NULL_TREE,
<span class="lineNum">    7713 </span>            :                           NULL_TREE);
<span class="lineNum">    7714 </span><span class="lineCov">         16 :           SET_DECL_VALUE_EXPR (v[i], t);</span>
<span class="lineNum">    7715 </span><span class="lineCov">         16 :           DECL_HAS_VALUE_EXPR_P (v[i]) = 1;</span>
<span class="lineNum">    7716 </span>            :         }
<span class="lineNum">    7717 </span>            :     }
<span class="lineNum">    7718 </span><span class="lineCov">        262 :   else if (tree tsize = get_tuple_size (type))</span>
<span class="lineNum">    7719 </span>            :     {
<span class="lineNum">    7720 </span><span class="lineCov">         54 :       if (tsize == error_mark_node)</span>
<span class="lineNum">    7721 </span>            :         {
<span class="lineNum">    7722 </span><span class="lineCov">          1 :           error_at (loc, &quot;%&lt;std::tuple_size&lt;%T&gt;::value%&gt; is not an integral &quot;</span>
<span class="lineNum">    7723 </span>            :                          &quot;constant expression&quot;, type);
<span class="lineNum">    7724 </span><span class="lineCov">          1 :           goto error_out;</span>
<span class="lineNum">    7725 </span>            :         }
<span class="lineNum">    7726 </span><span class="lineCov">         53 :       if (!tree_fits_uhwi_p (tsize))</span>
<span class="lineNum">    7727 </span>            :         {
<span class="lineNum">    7728 </span><span class="lineCov">          8 :           error_n (loc, count,</span>
<span class="lineNum">    7729 </span>            :                    &quot;%u name provided for structured binding&quot;,
<span class="lineNum">    7730 </span>            :                    &quot;%u names provided for structured binding&quot;, count);
<span class="lineNum">    7731 </span><span class="lineCov">          8 :           inform (loc, &quot;while %qT decomposes into %E elements&quot;,</span>
<span class="lineNum">    7732 </span>            :                   type, tsize);
<span class="lineNum">    7733 </span><span class="lineCov">          8 :           goto error_out;</span>
<span class="lineNum">    7734 </span>            :         }
<span class="lineNum">    7735 </span><span class="lineCov">         45 :       eltscnt = tree_to_uhwi (tsize);</span>
<span class="lineNum">    7736 </span><span class="lineCov">         45 :       if (count != eltscnt)</span>
<span class="lineNum">    7737 </span>            :         goto cnt_mismatch;
<span class="lineNum">    7738 </span><span class="lineCov">         44 :       int save_read = DECL_READ_P (decl);       </span>
<span class="lineNum">    7739 </span><span class="lineCov">        111 :       for (unsigned i = 0; i &lt; count; ++i)</span>
<span class="lineNum">    7740 </span>            :         {
<span class="lineNum">    7741 </span><span class="lineCov">         73 :           location_t sloc = input_location;</span>
<span class="lineNum">    7742 </span><span class="lineCov">         73 :           location_t dloc = DECL_SOURCE_LOCATION (v[i]);</span>
<span class="lineNum">    7743 </span>            : 
<span class="lineNum">    7744 </span><span class="lineCov">         73 :           input_location = dloc;</span>
<span class="lineNum">    7745 </span><span class="lineCov">         73 :           tree init = get_tuple_decomp_init (decl, i);</span>
<span class="lineNum">    7746 </span><span class="lineCov">         73 :           tree eltype = (init == error_mark_node ? error_mark_node</span>
<span class="lineNum">    7747 </span><span class="lineCov">         70 :                          : get_tuple_element_type (type, i));</span>
<span class="lineNum">    7748 </span><span class="lineCov">         73 :           input_location = sloc;</span>
<span class="lineNum">    7749 </span>            : 
<span class="lineNum">    7750 </span><span class="lineCov">         73 :           if (init == error_mark_node || eltype == error_mark_node)</span>
<span class="lineNum">    7751 </span>            :             {
<span class="lineNum">    7752 </span><span class="lineCov">         12 :               inform (dloc, &quot;in initialization of structured binding &quot;</span>
<span class="lineNum">    7753 </span><span class="lineCov">          6 :                       &quot;variable %qD&quot;, v[i]);</span>
<span class="lineNum">    7754 </span><span class="lineCov">          6 :               goto error_out;</span>
<span class="lineNum">    7755 </span>            :             }
<span class="lineNum">    7756 </span>            :           /* Save the decltype away before reference collapse.  */
<span class="lineNum">    7757 </span><span class="lineCov">         67 :           store_decomp_type (v[i], eltype);</span>
<span class="lineNum">    7758 </span><span class="lineCov">         67 :           eltype = cp_build_reference_type (eltype, !lvalue_p (init));</span>
<span class="lineNum">    7759 </span><span class="lineCov">         67 :           TREE_TYPE (v[i]) = eltype;</span>
<span class="lineNum">    7760 </span><span class="lineCov">         67 :           layout_decl (v[i], 0);</span>
<span class="lineNum">    7761 </span><span class="lineCov">         67 :           if (DECL_HAS_VALUE_EXPR_P (v[i]))</span>
<span class="lineNum">    7762 </span>            :             {
<span class="lineNum">    7763 </span>            :               /* In this case the names are variables, not just proxies.  */
<span class="lineNum">    7764 </span><span class="lineNoCov">          0 :               SET_DECL_VALUE_EXPR (v[i], NULL_TREE);</span>
<span class="lineNum">    7765 </span><span class="lineNoCov">          0 :               DECL_HAS_VALUE_EXPR_P (v[i]) = 0;</span>
<span class="lineNum">    7766 </span>            :             }
<span class="lineNum">    7767 </span><span class="lineCov">         67 :           if (!processing_template_decl)</span>
<span class="lineNum">    7768 </span><span class="lineCov">         65 :             cp_finish_decl (v[i], init, /*constexpr*/false,</span>
<span class="lineNum">    7769 </span>            :                             /*asm*/NULL_TREE, LOOKUP_NORMAL);
<span class="lineNum">    7770 </span>            :         }
<span class="lineNum">    7771 </span>            :       /* Ignore reads from the underlying decl performed during initialization
<span class="lineNum">    7772 </span>            :          of the individual variables.  If those will be read, we'll mark
<span class="lineNum">    7773 </span>            :          the underlying decl as read at that point.  */
<span class="lineNum">    7774 </span><span class="lineCov">         38 :       DECL_READ_P (decl) = save_read;</span>
<span class="lineNum">    7775 </span>            :     }
<span class="lineNum">    7776 </span><span class="lineCov">        208 :   else if (TREE_CODE (type) == UNION_TYPE)</span>
<span class="lineNum">    7777 </span>            :     {
<span class="lineNum">    7778 </span><span class="lineNoCov">          0 :       error_at (loc, &quot;cannot decompose union type %qT&quot;, type);</span>
<span class="lineNum">    7779 </span><span class="lineNoCov">          0 :       goto error_out;</span>
<span class="lineNum">    7780 </span>            :     }
<span class="lineNum">    7781 </span><span class="lineCov">        208 :   else if (!CLASS_TYPE_P (type))</span>
<span class="lineNum">    7782 </span>            :     {
<span class="lineNum">    7783 </span><span class="lineCov">          6 :       error_at (loc, &quot;cannot decompose non-array non-class type %qT&quot;, type);</span>
<span class="lineNum">    7784 </span><span class="lineCov">          6 :       goto error_out;</span>
<span class="lineNum">    7785 </span>            :     }
<span class="lineNum">    7786 </span><span class="lineCov">        606 :   else if (LAMBDA_TYPE_P (type))</span>
<span class="lineNum">    7787 </span>            :     {
<span class="lineNum">    7788 </span><span class="lineCov">          4 :       error_at (loc, &quot;cannot decompose lambda closure type %qT&quot;, type);</span>
<span class="lineNum">    7789 </span><span class="lineCov">          4 :       goto error_out;</span>
<span class="lineNum">    7790 </span>            :     }
<span class="lineNum">    7791 </span><span class="lineCov">        198 :   else if (processing_template_decl &amp;&amp; !COMPLETE_TYPE_P (type))</span>
<span class="lineNum">    7792 </span><span class="lineCov">          2 :     pedwarn (loc, 0, &quot;structured binding refers to incomplete class type %qT&quot;,</span>
<span class="lineNum">    7793 </span>            :              type);
<span class="lineNum">    7794 </span>            :   else
<span class="lineNum">    7795 </span>            :     {
<span class="lineNum">    7796 </span><span class="lineCov">        196 :       tree btype = find_decomp_class_base (loc, type, NULL_TREE);</span>
<span class="lineNum">    7797 </span><span class="lineCov">        196 :       if (btype == error_mark_node)</span>
<span class="lineNum">    7798 </span>            :         goto error_out;
<span class="lineNum">    7799 </span><span class="lineCov">        186 :       else if (btype == NULL_TREE)</span>
<span class="lineNum">    7800 </span>            :         {
<span class="lineNum">    7801 </span><span class="lineNoCov">          0 :           error_at (loc, &quot;cannot decompose class type %qT without non-static &quot;</span>
<span class="lineNum">    7802 </span>            :                          &quot;data members&quot;, type);
<span class="lineNum">    7803 </span><span class="lineNoCov">          0 :           goto error_out;</span>
<span class="lineNum">    7804 </span>            :         }
<span class="lineNum">    7805 </span><span class="lineCov">       3011 :       for (tree field = TYPE_FIELDS (btype); field; field = TREE_CHAIN (field))</span>
<span class="lineNum">    7806 </span><span class="lineCov">       2825 :         if (TREE_CODE (field) != FIELD_DECL</span>
<span class="lineNum">    7807 </span><span class="lineCov">        576 :             || DECL_ARTIFICIAL (field)</span>
<span class="lineNum">    7808 </span><span class="lineCov">       4547 :             || DECL_UNNAMED_BIT_FIELD (field))</span>
<span class="lineNum">    7809 </span>            :           continue;
<span class="lineNum">    7810 </span>            :         else
<span class="lineNum">    7811 </span><span class="lineCov">        566 :           eltscnt++;</span>
<span class="lineNum">    7812 </span><span class="lineCov">        186 :       if (count != eltscnt)</span>
<span class="lineNum">    7813 </span>            :         goto cnt_mismatch;
<span class="lineNum">    7814 </span><span class="lineCov">        183 :       tree t = dexp;</span>
<span class="lineNum">    7815 </span><span class="lineCov">        183 :       if (type != btype)</span>
<span class="lineNum">    7816 </span>            :         {
<span class="lineNum">    7817 </span><span class="lineCov">         11 :           t = convert_to_base (t, btype, /*check_access*/true,</span>
<span class="lineNum">    7818 </span>            :                                /*nonnull*/false, tf_warning_or_error);
<span class="lineNum">    7819 </span><span class="lineCov">         11 :           type = btype;</span>
<span class="lineNum">    7820 </span>            :         }
<span class="lineNum">    7821 </span><span class="lineCov">        183 :       unsigned int i = 0;</span>
<span class="lineNum">    7822 </span><span class="lineCov">       2962 :       for (tree field = TYPE_FIELDS (btype); field; field = TREE_CHAIN (field))</span>
<span class="lineNum">    7823 </span><span class="lineCov">       2779 :         if (TREE_CODE (field) != FIELD_DECL</span>
<span class="lineNum">    7824 </span><span class="lineCov">        569 :             || DECL_ARTIFICIAL (field)</span>
<span class="lineNum">    7825 </span><span class="lineCov">       4480 :             || DECL_UNNAMED_BIT_FIELD (field))</span>
<span class="lineNum">    7826 </span>            :           continue;
<span class="lineNum">    7827 </span>            :         else
<span class="lineNum">    7828 </span>            :           {
<span class="lineNum">    7829 </span><span class="lineCov">        559 :             tree tt = finish_non_static_data_member (field, unshare_expr (t),</span>
<span class="lineNum">    7830 </span><span class="lineCov">        559 :                                                      NULL_TREE);</span>
<span class="lineNum">    7831 </span><span class="lineCov">        559 :             if (REFERENCE_REF_P (tt))</span>
<span class="lineNum">    7832 </span><span class="lineCov">         10 :               tt = TREE_OPERAND (tt, 0);</span>
<span class="lineNum">    7833 </span><span class="lineCov">        559 :             TREE_TYPE (v[i]) = TREE_TYPE (tt);</span>
<span class="lineNum">    7834 </span><span class="lineCov">        559 :             layout_decl (v[i], 0);</span>
<span class="lineNum">    7835 </span><span class="lineCov">        559 :             if (!processing_template_decl)</span>
<span class="lineNum">    7836 </span>            :               {
<span class="lineNum">    7837 </span><span class="lineCov">        535 :                 SET_DECL_VALUE_EXPR (v[i], tt);</span>
<span class="lineNum">    7838 </span><span class="lineCov">        535 :                 DECL_HAS_VALUE_EXPR_P (v[i]) = 1;</span>
<span class="lineNum">    7839 </span>            :               }
<span class="lineNum">    7840 </span><span class="lineCov">        559 :             i++;</span>
<span class="lineNum">    7841 </span>            :           }
<span class="lineNum">    7842 </span>            :     }
<span class="lineNum">    7843 </span><span class="lineCov">        279 :   if (processing_template_decl)</span>
<span class="lineNum">    7844 </span>            :     {
<span class="lineNum">    7845 </span><span class="lineCov">         55 :       for (unsigned int i = 0; i &lt; count; i++)</span>
<span class="lineNum">    7846 </span><span class="lineCov">         36 :         if (!DECL_HAS_VALUE_EXPR_P (v[i]))</span>
<span class="lineNum">    7847 </span>            :           {
<span class="lineNum">    7848 </span><span class="lineCov">         72 :             tree a = build_nt (ARRAY_REF, decl, size_int (i),</span>
<span class="lineNum">    7849 </span>            :                                NULL_TREE, NULL_TREE);
<span class="lineNum">    7850 </span><span class="lineCov">         36 :             SET_DECL_VALUE_EXPR (v[i], a);</span>
<span class="lineNum">    7851 </span><span class="lineCov">         36 :             DECL_HAS_VALUE_EXPR_P (v[i]) = 1;</span>
<span class="lineNum">    7852 </span>            :           }
<span class="lineNum">    7853 </span>            :     }
<span class="lineNum">    7854 </span>            : }
<span class="lineNum">    7855 </span>            : 
<span class="lineNum">    7856 </span>            : /* Returns a declaration for a VAR_DECL as if:
<span class="lineNum">    7857 </span>            : 
<span class="lineNum">    7858 </span>            :      extern &quot;C&quot; TYPE NAME;
<span class="lineNum">    7859 </span>            : 
<span class="lineNum">    7860 </span>            :    had been seen.  Used to create compiler-generated global
<span class="lineNum">    7861 </span>            :    variables.  */
<a name="7862"><span class="lineNum">    7862 </span>            : </a>
<span class="lineNum">    7863 </span>            : static tree
<span class="lineNum">    7864 </span><span class="lineCov">       7141 : declare_global_var (tree name, tree type)</span>
<span class="lineNum">    7865 </span>            : {
<span class="lineNum">    7866 </span><span class="lineCov">       7141 :   tree decl;</span>
<span class="lineNum">    7867 </span>            : 
<span class="lineNum">    7868 </span><span class="lineCov">       7141 :   push_to_top_level ();</span>
<span class="lineNum">    7869 </span><span class="lineCov">       7141 :   decl = build_decl (input_location, VAR_DECL, name, type);</span>
<span class="lineNum">    7870 </span><span class="lineCov">       7141 :   TREE_PUBLIC (decl) = 1;</span>
<span class="lineNum">    7871 </span><span class="lineCov">       7141 :   DECL_EXTERNAL (decl) = 1;</span>
<span class="lineNum">    7872 </span><span class="lineCov">       7141 :   DECL_ARTIFICIAL (decl) = 1;</span>
<span class="lineNum">    7873 </span><span class="lineCov">       7141 :   DECL_CONTEXT (decl) = FROB_CONTEXT (global_namespace);</span>
<span class="lineNum">    7874 </span>            :   /* If the user has explicitly declared this variable (perhaps
<span class="lineNum">    7875 </span>            :      because the code we are compiling is part of a low-level runtime
<span class="lineNum">    7876 </span>            :      library), then it is possible that our declaration will be merged
<span class="lineNum">    7877 </span>            :      with theirs by pushdecl.  */
<span class="lineNum">    7878 </span><span class="lineCov">       7141 :   decl = pushdecl (decl);</span>
<span class="lineNum">    7879 </span><span class="lineCov">       7141 :   cp_finish_decl (decl, NULL_TREE, false, NULL_TREE, 0);</span>
<span class="lineNum">    7880 </span><span class="lineCov">       7141 :   pop_from_top_level ();</span>
<span class="lineNum">    7881 </span>            : 
<span class="lineNum">    7882 </span><span class="lineCov">       7141 :   return decl;</span>
<span class="lineNum">    7883 </span>            : }
<span class="lineNum">    7884 </span>            : 
<span class="lineNum">    7885 </span>            : /* Returns the type for the argument to &quot;__cxa_atexit&quot; (or &quot;atexit&quot;,
<span class="lineNum">    7886 </span>            :    if &quot;__cxa_atexit&quot; is not being used) corresponding to the function
<span class="lineNum">    7887 </span>            :    to be called when the program exits.  */
<a name="7888"><span class="lineNum">    7888 </span>            : </a>
<span class="lineNum">    7889 </span>            : static tree
<span class="lineNum">    7890 </span><span class="lineCov">      15562 : get_atexit_fn_ptr_type (void)</span>
<span class="lineNum">    7891 </span>            : {
<span class="lineNum">    7892 </span><span class="lineCov">      15562 :   tree fn_type;</span>
<span class="lineNum">    7893 </span>            : 
<span class="lineNum">    7894 </span><span class="lineCov">      15562 :   if (!atexit_fn_ptr_type_node)</span>
<span class="lineNum">    7895 </span>            :     {
<span class="lineNum">    7896 </span><span class="lineCov">       7141 :       tree arg_type;</span>
<span class="lineNum">    7897 </span><span class="lineCov">       7141 :       if (flag_use_cxa_atexit </span>
<span class="lineNum">    7898 </span><span class="lineCov">       7141 :           &amp;&amp; !targetm.cxx.use_atexit_for_cxa_atexit ())</span>
<span class="lineNum">    7899 </span>            :         /* The parameter to &quot;__cxa_atexit&quot; is &quot;void (*)(void *)&quot;.  */
<span class="lineNum">    7900 </span><span class="lineCov">       7141 :         arg_type = ptr_type_node;</span>
<span class="lineNum">    7901 </span>            :       else
<span class="lineNum">    7902 </span>            :         /* The parameter to &quot;atexit&quot; is &quot;void (*)(void)&quot;.  */
<span class="lineNum">    7903 </span>            :         arg_type = NULL_TREE;
<span class="lineNum">    7904 </span>            :       
<span class="lineNum">    7905 </span><span class="lineCov">       7141 :       fn_type = build_function_type_list (void_type_node,</span>
<span class="lineNum">    7906 </span>            :                                           arg_type, NULL_TREE);
<span class="lineNum">    7907 </span><span class="lineCov">       7141 :       atexit_fn_ptr_type_node = build_pointer_type (fn_type);</span>
<span class="lineNum">    7908 </span>            :     }
<span class="lineNum">    7909 </span>            : 
<span class="lineNum">    7910 </span><span class="lineCov">      15562 :   return atexit_fn_ptr_type_node;</span>
<span class="lineNum">    7911 </span>            : }
<span class="lineNum">    7912 </span>            : 
<span class="lineNum">    7913 </span>            : /* Returns a pointer to the `atexit' function.  Note that if
<span class="lineNum">    7914 </span>            :    FLAG_USE_CXA_ATEXIT is nonzero, then this will actually be the new
<span class="lineNum">    7915 </span>            :    `__cxa_atexit' function specified in the IA64 C++ ABI.  */
<a name="7916"><span class="lineNum">    7916 </span>            : </a>
<span class="lineNum">    7917 </span>            : static tree
<span class="lineNum">    7918 </span><span class="lineCov">       8387 : get_atexit_node (void)</span>
<span class="lineNum">    7919 </span>            : {
<span class="lineNum">    7920 </span><span class="lineCov">       8387 :   tree atexit_fndecl;</span>
<span class="lineNum">    7921 </span><span class="lineCov">       8387 :   tree fn_type;</span>
<span class="lineNum">    7922 </span><span class="lineCov">       8387 :   tree fn_ptr_type;</span>
<span class="lineNum">    7923 </span><span class="lineCov">       8387 :   const char *name;</span>
<span class="lineNum">    7924 </span><span class="lineCov">       8387 :   bool use_aeabi_atexit;</span>
<span class="lineNum">    7925 </span>            : 
<span class="lineNum">    7926 </span><span class="lineCov">       8387 :   if (atexit_node)</span>
<span class="lineNum">    7927 </span>            :     return atexit_node;
<span class="lineNum">    7928 </span>            : 
<span class="lineNum">    7929 </span><span class="lineCov">       7125 :   if (flag_use_cxa_atexit &amp;&amp; !targetm.cxx.use_atexit_for_cxa_atexit ())</span>
<span class="lineNum">    7930 </span>            :     {
<span class="lineNum">    7931 </span>            :       /* The declaration for `__cxa_atexit' is:
<span class="lineNum">    7932 </span>            : 
<span class="lineNum">    7933 </span>            :            int __cxa_atexit (void (*)(void *), void *, void *)
<span class="lineNum">    7934 </span>            : 
<span class="lineNum">    7935 </span>            :          We build up the argument types and then the function type
<span class="lineNum">    7936 </span>            :          itself.  */
<span class="lineNum">    7937 </span><span class="lineCov">       7125 :       tree argtype0, argtype1, argtype2;</span>
<span class="lineNum">    7938 </span>            : 
<span class="lineNum">    7939 </span><span class="lineCov">       7125 :       use_aeabi_atexit = targetm.cxx.use_aeabi_atexit ();</span>
<span class="lineNum">    7940 </span>            :       /* First, build the pointer-to-function type for the first
<span class="lineNum">    7941 </span>            :          argument.  */
<span class="lineNum">    7942 </span><span class="lineCov">       7125 :       fn_ptr_type = get_atexit_fn_ptr_type ();</span>
<span class="lineNum">    7943 </span>            :       /* Then, build the rest of the argument types.  */
<span class="lineNum">    7944 </span><span class="lineCov">       7125 :       argtype2 = ptr_type_node;</span>
<span class="lineNum">    7945 </span><span class="lineCov">       7125 :       if (use_aeabi_atexit)</span>
<span class="lineNum">    7946 </span>            :         {
<span class="lineNum">    7947 </span>            :           argtype1 = fn_ptr_type;
<span class="lineNum">    7948 </span>            :           argtype0 = ptr_type_node;
<span class="lineNum">    7949 </span>            :         }
<span class="lineNum">    7950 </span>            :       else
<span class="lineNum">    7951 </span>            :         {
<span class="lineNum">    7952 </span><span class="lineCov">       7125 :           argtype1 = ptr_type_node;</span>
<span class="lineNum">    7953 </span><span class="lineCov">       7125 :           argtype0 = fn_ptr_type;</span>
<span class="lineNum">    7954 </span>            :         }
<span class="lineNum">    7955 </span>            :       /* And the final __cxa_atexit type.  */
<span class="lineNum">    7956 </span><span class="lineCov">       7125 :       fn_type = build_function_type_list (integer_type_node,</span>
<span class="lineNum">    7957 </span>            :                                           argtype0, argtype1, argtype2,
<span class="lineNum">    7958 </span>            :                                           NULL_TREE);
<span class="lineNum">    7959 </span><span class="lineCov">       7125 :       if (use_aeabi_atexit)</span>
<span class="lineNum">    7960 </span>            :         name = &quot;__aeabi_atexit&quot;;
<span class="lineNum">    7961 </span>            :       else
<span class="lineNum">    7962 </span><span class="lineCov">       7125 :         name = &quot;__cxa_atexit&quot;;</span>
<span class="lineNum">    7963 </span>            :     }
<span class="lineNum">    7964 </span>            :   else
<span class="lineNum">    7965 </span>            :     {
<span class="lineNum">    7966 </span>            :       /* The declaration for `atexit' is:
<span class="lineNum">    7967 </span>            : 
<span class="lineNum">    7968 </span>            :            int atexit (void (*)());
<span class="lineNum">    7969 </span>            : 
<span class="lineNum">    7970 </span>            :          We build up the argument types and then the function type
<span class="lineNum">    7971 </span>            :          itself.  */
<span class="lineNum">    7972 </span><span class="lineNoCov">          0 :       fn_ptr_type = get_atexit_fn_ptr_type ();</span>
<span class="lineNum">    7973 </span>            :       /* Build the final atexit type.  */
<span class="lineNum">    7974 </span><span class="lineNoCov">          0 :       fn_type = build_function_type_list (integer_type_node,</span>
<span class="lineNum">    7975 </span>            :                                           fn_ptr_type, NULL_TREE);
<span class="lineNum">    7976 </span><span class="lineNoCov">          0 :       name = &quot;atexit&quot;;</span>
<span class="lineNum">    7977 </span>            :     }
<span class="lineNum">    7978 </span>            : 
<span class="lineNum">    7979 </span>            :   /* Now, build the function declaration.  */
<span class="lineNum">    7980 </span><span class="lineCov">       7125 :   push_lang_context (lang_name_c);</span>
<span class="lineNum">    7981 </span><span class="lineCov">       7125 :   atexit_fndecl = build_library_fn_ptr (name, fn_type, ECF_LEAF | ECF_NOTHROW);</span>
<span class="lineNum">    7982 </span><span class="lineCov">       7125 :   mark_used (atexit_fndecl);</span>
<span class="lineNum">    7983 </span><span class="lineCov">       7125 :   pop_lang_context ();</span>
<span class="lineNum">    7984 </span><span class="lineCov">       7125 :   atexit_node = decay_conversion (atexit_fndecl, tf_warning_or_error);</span>
<span class="lineNum">    7985 </span>            : 
<span class="lineNum">    7986 </span><span class="lineCov">       7125 :   return atexit_node;</span>
<span class="lineNum">    7987 </span>            : }
<span class="lineNum">    7988 </span>            : 
<span class="lineNum">    7989 </span>            : /* Like get_atexit_node, but for thread-local cleanups.  */
<a name="7990"><span class="lineNum">    7990 </span>            : </a>
<span class="lineNum">    7991 </span>            : static tree
<span class="lineNum">    7992 </span><span class="lineCov">         25 : get_thread_atexit_node (void)</span>
<span class="lineNum">    7993 </span>            : {
<span class="lineNum">    7994 </span>            :   /* The declaration for `__cxa_thread_atexit' is:
<span class="lineNum">    7995 </span>            : 
<span class="lineNum">    7996 </span>            :      int __cxa_thread_atexit (void (*)(void *), void *, void *) */
<span class="lineNum">    7997 </span><span class="lineCov">         25 :   tree fn_type = build_function_type_list (integer_type_node,</span>
<span class="lineNum">    7998 </span>            :                                            get_atexit_fn_ptr_type (),
<span class="lineNum">    7999 </span>            :                                            ptr_type_node, ptr_type_node,
<span class="lineNum">    8000 </span>            :                                            NULL_TREE);
<span class="lineNum">    8001 </span>            : 
<span class="lineNum">    8002 </span>            :   /* Now, build the function declaration.  */
<span class="lineNum">    8003 </span><span class="lineCov">         25 :   tree atexit_fndecl = build_library_fn_ptr (&quot;__cxa_thread_atexit&quot;, fn_type,</span>
<span class="lineNum">    8004 </span>            :                                              ECF_LEAF | ECF_NOTHROW);
<span class="lineNum">    8005 </span><span class="lineCov">         25 :   return decay_conversion (atexit_fndecl, tf_warning_or_error);</span>
<span class="lineNum">    8006 </span>            : }
<span class="lineNum">    8007 </span>            : 
<span class="lineNum">    8008 </span>            : /* Returns the __dso_handle VAR_DECL.  */
<a name="8009"><span class="lineNum">    8009 </span>            : </a>
<span class="lineNum">    8010 </span>            : static tree
<span class="lineNum">    8011 </span><span class="lineCov">       8412 : get_dso_handle_node (void)</span>
<span class="lineNum">    8012 </span>            : {
<span class="lineNum">    8013 </span><span class="lineCov">       8412 :   if (dso_handle_node)</span>
<span class="lineNum">    8014 </span>            :     return dso_handle_node;
<span class="lineNum">    8015 </span>            : 
<span class="lineNum">    8016 </span>            :   /* Declare the variable.  */
<span class="lineNum">    8017 </span><span class="lineCov">       7141 :   dso_handle_node = declare_global_var (get_identifier (&quot;__dso_handle&quot;),</span>
<span class="lineNum">    8018 </span>            :                                         ptr_type_node);
<span class="lineNum">    8019 </span>            : 
<span class="lineNum">    8020 </span>            : #ifdef HAVE_GAS_HIDDEN
<span class="lineNum">    8021 </span><span class="lineCov">       7141 :   if (dso_handle_node != error_mark_node)</span>
<span class="lineNum">    8022 </span>            :     {
<span class="lineNum">    8023 </span><span class="lineCov">       7138 :       DECL_VISIBILITY (dso_handle_node) = VISIBILITY_HIDDEN;</span>
<span class="lineNum">    8024 </span><span class="lineCov">       7138 :       DECL_VISIBILITY_SPECIFIED (dso_handle_node) = 1;</span>
<span class="lineNum">    8025 </span>            :     }
<span class="lineNum">    8026 </span>            : #endif
<span class="lineNum">    8027 </span>            : 
<span class="lineNum">    8028 </span><span class="lineCov">       7141 :   return dso_handle_node;</span>
<span class="lineNum">    8029 </span>            : }
<span class="lineNum">    8030 </span>            : 
<span class="lineNum">    8031 </span>            : /* Begin a new function with internal linkage whose job will be simply
<span class="lineNum">    8032 </span>            :    to destroy some particular variable.  */
<span class="lineNum">    8033 </span>            : 
<span class="lineNum">    8034 </span>            : static GTY(()) int start_cleanup_cnt;
<a name="8035"><span class="lineNum">    8035 </span>            : </a>
<span class="lineNum">    8036 </span>            : static tree
<span class="lineNum">    8037 </span><span class="lineCov">        192 : start_cleanup_fn (void)</span>
<span class="lineNum">    8038 </span>            : {
<span class="lineNum">    8039 </span><span class="lineCov">        192 :   char name[32];</span>
<span class="lineNum">    8040 </span><span class="lineCov">        192 :   tree fntype;</span>
<span class="lineNum">    8041 </span><span class="lineCov">        192 :   tree fndecl;</span>
<span class="lineNum">    8042 </span><span class="lineCov">        192 :   bool use_cxa_atexit = flag_use_cxa_atexit</span>
<span class="lineNum">    8043 </span><span class="lineCov">        192 :                         &amp;&amp; !targetm.cxx.use_atexit_for_cxa_atexit ();</span>
<span class="lineNum">    8044 </span>            : 
<span class="lineNum">    8045 </span><span class="lineCov">        192 :   push_to_top_level ();</span>
<span class="lineNum">    8046 </span>            : 
<span class="lineNum">    8047 </span>            :   /* No need to mangle this.  */
<span class="lineNum">    8048 </span><span class="lineCov">        192 :   push_lang_context (lang_name_c);</span>
<span class="lineNum">    8049 </span>            : 
<span class="lineNum">    8050 </span>            :   /* Build the name of the function.  */
<span class="lineNum">    8051 </span><span class="lineCov">        192 :   sprintf (name, &quot;__tcf_%d&quot;, start_cleanup_cnt++);</span>
<span class="lineNum">    8052 </span>            :   /* Build the function declaration.  */
<span class="lineNum">    8053 </span><span class="lineCov">        192 :   fntype = TREE_TYPE (get_atexit_fn_ptr_type ());</span>
<span class="lineNum">    8054 </span><span class="lineCov">        192 :   fndecl = build_lang_decl (FUNCTION_DECL, get_identifier (name), fntype);</span>
<span class="lineNum">    8055 </span>            :   /* It's a function with internal linkage, generated by the
<span class="lineNum">    8056 </span>            :      compiler.  */
<span class="lineNum">    8057 </span><span class="lineCov">        192 :   TREE_PUBLIC (fndecl) = 0;</span>
<span class="lineNum">    8058 </span><span class="lineCov">        192 :   DECL_ARTIFICIAL (fndecl) = 1;</span>
<span class="lineNum">    8059 </span>            :   /* Make the function `inline' so that it is only emitted if it is
<span class="lineNum">    8060 </span>            :      actually needed.  It is unlikely that it will be inlined, since
<span class="lineNum">    8061 </span>            :      it is only called via a function pointer, but we avoid unnecessary
<span class="lineNum">    8062 </span>            :      emissions this way.  */
<span class="lineNum">    8063 </span><span class="lineCov">        192 :   DECL_DECLARED_INLINE_P (fndecl) = 1;</span>
<span class="lineNum">    8064 </span><span class="lineCov">        192 :   DECL_INTERFACE_KNOWN (fndecl) = 1;</span>
<span class="lineNum">    8065 </span>            :   /* Build the parameter.  */
<span class="lineNum">    8066 </span><span class="lineCov">        192 :   if (use_cxa_atexit)</span>
<span class="lineNum">    8067 </span>            :     {
<span class="lineNum">    8068 </span><span class="lineCov">        192 :       tree parmdecl = cp_build_parm_decl (fndecl, NULL_TREE, ptr_type_node);</span>
<span class="lineNum">    8069 </span><span class="lineCov">        192 :       TREE_USED (parmdecl) = 1;</span>
<span class="lineNum">    8070 </span><span class="lineCov">        192 :       DECL_READ_P (parmdecl) = 1;</span>
<span class="lineNum">    8071 </span><span class="lineCov">        192 :       DECL_ARGUMENTS (fndecl) = parmdecl;</span>
<span class="lineNum">    8072 </span>            :     }
<span class="lineNum">    8073 </span>            : 
<span class="lineNum">    8074 </span><span class="lineCov">        192 :   pushdecl (fndecl);</span>
<span class="lineNum">    8075 </span><span class="lineCov">        192 :   start_preparsed_function (fndecl, NULL_TREE, SF_PRE_PARSED);</span>
<span class="lineNum">    8076 </span>            : 
<span class="lineNum">    8077 </span><span class="lineCov">        192 :   pop_lang_context ();</span>
<span class="lineNum">    8078 </span>            : 
<span class="lineNum">    8079 </span><span class="lineCov">        192 :   return current_function_decl;</span>
<span class="lineNum">    8080 </span>            : }
<span class="lineNum">    8081 </span>            : 
<span class="lineNum">    8082 </span>            : /* Finish the cleanup function begun by start_cleanup_fn.  */
<a name="8083"><span class="lineNum">    8083 </span>            : </a>
<span class="lineNum">    8084 </span>            : static void
<span class="lineNum">    8085 </span><span class="lineCov">        192 : end_cleanup_fn (void)</span>
<span class="lineNum">    8086 </span>            : {
<span class="lineNum">    8087 </span><span class="lineCov">        192 :   expand_or_defer_fn (finish_function (/*inline_p=*/false));</span>
<span class="lineNum">    8088 </span>            : 
<span class="lineNum">    8089 </span><span class="lineCov">        192 :   pop_from_top_level ();</span>
<span class="lineNum">    8090 </span><span class="lineCov">        192 : }</span>
<span class="lineNum">    8091 </span>            : 
<span class="lineNum">    8092 </span>            : /* Generate code to handle the destruction of DECL, an object with
<span class="lineNum">    8093 </span>            :    static storage duration.  */
<a name="8094"><span class="lineNum">    8094 </span>            : </a>
<span class="lineNum">    8095 </span>            : tree
<span class="lineNum">    8096 </span><span class="lineCov">      14015 : register_dtor_fn (tree decl)</span>
<span class="lineNum">    8097 </span>            : {
<span class="lineNum">    8098 </span><span class="lineCov">      14015 :   tree cleanup;</span>
<span class="lineNum">    8099 </span><span class="lineCov">      14015 :   tree addr;</span>
<span class="lineNum">    8100 </span><span class="lineCov">      14015 :   tree compound_stmt;</span>
<span class="lineNum">    8101 </span><span class="lineCov">      14015 :   tree fcall;</span>
<span class="lineNum">    8102 </span><span class="lineCov">      14015 :   tree type;</span>
<span class="lineNum">    8103 </span><span class="lineCov">      14015 :   bool ob_parm, dso_parm, use_dtor;</span>
<span class="lineNum">    8104 </span><span class="lineCov">      14015 :   tree arg0, arg1, arg2;</span>
<span class="lineNum">    8105 </span><span class="lineCov">      14015 :   tree atex_node;</span>
<span class="lineNum">    8106 </span>            : 
<span class="lineNum">    8107 </span><span class="lineCov">      14015 :   type = TREE_TYPE (decl);</span>
<span class="lineNum">    8108 </span><span class="lineCov">      14015 :   if (TYPE_HAS_TRIVIAL_DESTRUCTOR (type))</span>
<span class="lineNum">    8109 </span><span class="lineCov">       5603 :     return void_node;</span>
<span class="lineNum">    8110 </span>            : 
<span class="lineNum">    8111 </span>            :   /* If we're using &quot;__cxa_atexit&quot; (or &quot;__cxa_thread_atexit&quot; or
<span class="lineNum">    8112 </span>            :      &quot;__aeabi_atexit&quot;), and DECL is a class object, we can just pass the
<span class="lineNum">    8113 </span>            :      destructor to &quot;__cxa_atexit&quot;; we don't have to build a temporary
<span class="lineNum">    8114 </span>            :      function to do the cleanup.  */
<span class="lineNum">    8115 </span><span class="lineCov">      16824 :   dso_parm = (flag_use_cxa_atexit</span>
<span class="lineNum">    8116 </span><span class="lineCov">       8412 :               &amp;&amp; !targetm.cxx.use_atexit_for_cxa_atexit ());</span>
<span class="lineNum">    8117 </span><span class="lineCov">       8412 :   ob_parm = (CP_DECL_THREAD_LOCAL_P (decl) || dso_parm);</span>
<span class="lineNum">    8118 </span><span class="lineCov">       8412 :   use_dtor = ob_parm &amp;&amp; CLASS_TYPE_P (type);</span>
<span class="lineNum">    8119 </span><span class="lineCov">       8412 :   if (use_dtor)</span>
<span class="lineNum">    8120 </span>            :     {
<span class="lineNum">    8121 </span><span class="lineCov">       8220 :       cleanup = get_class_binding (type, complete_dtor_identifier);</span>
<span class="lineNum">    8122 </span>            : 
<span class="lineNum">    8123 </span>            :       /* Make sure it is accessible.  */
<span class="lineNum">    8124 </span><span class="lineCov">       8230 :       perform_or_defer_access_check (TYPE_BINFO (type), cleanup, cleanup,</span>
<span class="lineNum">    8125 </span>            :                                      tf_warning_or_error);
<span class="lineNum">    8126 </span>            :     }
<span class="lineNum">    8127 </span>            :   else
<span class="lineNum">    8128 </span>            :     {
<span class="lineNum">    8129 </span>            :       /* Call build_cleanup before we enter the anonymous function so
<span class="lineNum">    8130 </span>            :          that any access checks will be done relative to the current
<span class="lineNum">    8131 </span>            :          scope, rather than the scope of the anonymous function.  */
<span class="lineNum">    8132 </span><span class="lineCov">        192 :       build_cleanup (decl);</span>
<span class="lineNum">    8133 </span>            :   
<span class="lineNum">    8134 </span>            :       /* Now start the function.  */
<span class="lineNum">    8135 </span><span class="lineCov">        192 :       cleanup = start_cleanup_fn ();</span>
<span class="lineNum">    8136 </span>            :       
<span class="lineNum">    8137 </span>            :       /* Now, recompute the cleanup.  It may contain SAVE_EXPRs that refer
<span class="lineNum">    8138 </span>            :          to the original function, rather than the anonymous one.  That
<span class="lineNum">    8139 </span>            :          will make the back end think that nested functions are in use,
<span class="lineNum">    8140 </span>            :          which causes confusion.  */
<span class="lineNum">    8141 </span><span class="lineCov">        192 :       push_deferring_access_checks (dk_no_check);</span>
<span class="lineNum">    8142 </span><span class="lineCov">        192 :       fcall = build_cleanup (decl);</span>
<span class="lineNum">    8143 </span><span class="lineCov">        192 :       pop_deferring_access_checks ();</span>
<span class="lineNum">    8144 </span>            :       
<span class="lineNum">    8145 </span>            :       /* Create the body of the anonymous function.  */
<span class="lineNum">    8146 </span><span class="lineCov">        192 :       compound_stmt = begin_compound_stmt (BCS_FN_BODY);</span>
<span class="lineNum">    8147 </span><span class="lineCov">        192 :       finish_expr_stmt (fcall);</span>
<span class="lineNum">    8148 </span><span class="lineCov">        192 :       finish_compound_stmt (compound_stmt);</span>
<span class="lineNum">    8149 </span><span class="lineCov">        192 :       end_cleanup_fn ();</span>
<span class="lineNum">    8150 </span>            :     }
<span class="lineNum">    8151 </span>            : 
<span class="lineNum">    8152 </span>            :   /* Call atexit with the cleanup function.  */
<span class="lineNum">    8153 </span><span class="lineCov">       8412 :   mark_used (cleanup);</span>
<span class="lineNum">    8154 </span><span class="lineCov">       8412 :   cleanup = build_address (cleanup);</span>
<span class="lineNum">    8155 </span>            : 
<span class="lineNum">    8156 </span><span class="lineCov">       8412 :   if (CP_DECL_THREAD_LOCAL_P (decl))</span>
<span class="lineNum">    8157 </span><span class="lineCov">         25 :     atex_node = get_thread_atexit_node ();</span>
<span class="lineNum">    8158 </span>            :   else
<span class="lineNum">    8159 </span><span class="lineCov">       8387 :     atex_node = get_atexit_node ();</span>
<span class="lineNum">    8160 </span>            : 
<span class="lineNum">    8161 </span><span class="lineCov">       8412 :   if (use_dtor)</span>
<span class="lineNum">    8162 </span>            :     {
<span class="lineNum">    8163 </span>            :       /* We must convert CLEANUP to the type that &quot;__cxa_atexit&quot;
<span class="lineNum">    8164 </span>            :          expects.  */
<span class="lineNum">    8165 </span><span class="lineCov">       8220 :       cleanup = build_nop (get_atexit_fn_ptr_type (), cleanup);</span>
<span class="lineNum">    8166 </span>            :       /* &quot;__cxa_atexit&quot; will pass the address of DECL to the
<span class="lineNum">    8167 </span>            :          cleanup function.  */
<span class="lineNum">    8168 </span><span class="lineCov">       8220 :       mark_used (decl);</span>
<span class="lineNum">    8169 </span><span class="lineCov">       8220 :       addr = build_address (decl);</span>
<span class="lineNum">    8170 </span>            :       /* The declared type of the parameter to &quot;__cxa_atexit&quot; is
<span class="lineNum">    8171 </span>            :          &quot;void *&quot;.  For plain &quot;T*&quot;, we could just let the
<span class="lineNum">    8172 </span>            :          machinery in cp_build_function_call convert it -- but if the
<span class="lineNum">    8173 </span>            :          type is &quot;cv-qualified T *&quot;, then we need to convert it
<span class="lineNum">    8174 </span>            :          before passing it in, to avoid spurious errors.  */
<span class="lineNum">    8175 </span><span class="lineCov">       8220 :       addr = build_nop (ptr_type_node, addr);</span>
<span class="lineNum">    8176 </span>            :     }
<span class="lineNum">    8177 </span>            :   else
<span class="lineNum">    8178 </span>            :     /* Since the cleanup functions we build ignore the address
<span class="lineNum">    8179 </span>            :        they're given, there's no reason to pass the actual address
<span class="lineNum">    8180 </span>            :        in, and, in general, it's cheaper to pass NULL than any
<span class="lineNum">    8181 </span>            :        other value.  */
<span class="lineNum">    8182 </span><span class="lineCov">        192 :     addr = null_pointer_node;</span>
<span class="lineNum">    8183 </span>            : 
<span class="lineNum">    8184 </span><span class="lineCov">       8412 :   if (dso_parm)</span>
<span class="lineNum">    8185 </span><span class="lineCov">       8412 :     arg2 = cp_build_addr_expr (get_dso_handle_node (),</span>
<span class="lineNum">    8186 </span>            :                                tf_warning_or_error);
<span class="lineNum">    8187 </span><span class="lineNoCov">          0 :   else if (ob_parm)</span>
<span class="lineNum">    8188 </span>            :     /* Just pass NULL to the dso handle parm if we don't actually
<span class="lineNum">    8189 </span>            :        have a DSO handle on this target.  */
<span class="lineNum">    8190 </span><span class="lineNoCov">          0 :     arg2 = null_pointer_node;</span>
<span class="lineNum">    8191 </span>            :   else
<span class="lineNum">    8192 </span>            :     arg2 = NULL_TREE;
<span class="lineNum">    8193 </span>            : 
<span class="lineNum">    8194 </span><span class="lineCov">       8412 :   if (ob_parm)</span>
<span class="lineNum">    8195 </span>            :     {
<span class="lineNum">    8196 </span><span class="lineCov">       8412 :       if (!CP_DECL_THREAD_LOCAL_P (decl)</span>
<span class="lineNum">    8197 </span><span class="lineCov">       8412 :           &amp;&amp; targetm.cxx.use_aeabi_atexit ())</span>
<span class="lineNum">    8198 </span>            :         {
<span class="lineNum">    8199 </span>            :           arg1 = cleanup;
<span class="lineNum">    8200 </span>            :           arg0 = addr;
<span class="lineNum">    8201 </span>            :         }
<span class="lineNum">    8202 </span>            :       else
<span class="lineNum">    8203 </span>            :         {
<span class="lineNum">    8204 </span>            :           arg1 = addr;
<span class="lineNum">    8205 </span>            :           arg0 = cleanup;
<span class="lineNum">    8206 </span>            :         }
<span class="lineNum">    8207 </span>            :     }
<span class="lineNum">    8208 </span>            :   else
<span class="lineNum">    8209 </span>            :     {
<span class="lineNum">    8210 </span>            :       arg0 = cleanup;
<span class="lineNum">    8211 </span>            :       arg1 = NULL_TREE;
<span class="lineNum">    8212 </span>            :     }
<span class="lineNum">    8213 </span><span class="lineCov">       8412 :   return cp_build_function_call_nary (atex_node, tf_warning_or_error,</span>
<span class="lineNum">    8214 </span><span class="lineCov">       8412 :                                       arg0, arg1, arg2, NULL_TREE);</span>
<span class="lineNum">    8215 </span>            : }
<span class="lineNum">    8216 </span>            : 
<span class="lineNum">    8217 </span>            : /* DECL is a VAR_DECL with static storage duration.  INIT, if present,
<span class="lineNum">    8218 </span>            :    is its initializer.  Generate code to handle the construction
<span class="lineNum">    8219 </span>            :    and destruction of DECL.  */
<a name="8220"><span class="lineNum">    8220 </span>            : </a>
<span class="lineNum">    8221 </span>            : static void
<span class="lineNum">    8222 </span><span class="lineCov">     737234 : expand_static_init (tree decl, tree init)</span>
<span class="lineNum">    8223 </span>            : {
<span class="lineNum">    8224 </span><span class="lineCov">     737234 :   gcc_assert (VAR_P (decl));</span>
<span class="lineNum">    8225 </span><span class="lineCov">     737234 :   gcc_assert (TREE_STATIC (decl));</span>
<span class="lineNum">    8226 </span>            : 
<span class="lineNum">    8227 </span>            :   /* Some variables require no dynamic initialization.  */
<span class="lineNum">    8228 </span><span class="lineCov">     737234 :   if (TYPE_HAS_TRIVIAL_DESTRUCTOR (TREE_TYPE (decl)))</span>
<span class="lineNum">    8229 </span>            :     {
<span class="lineNum">    8230 </span>            :       /* Make sure the destructor is callable.  */
<span class="lineNum">    8231 </span><span class="lineCov">     734794 :       cxx_maybe_build_cleanup (decl, tf_warning_or_error);</span>
<span class="lineNum">    8232 </span><span class="lineCov">     734794 :       if (!init)</span>
<span class="lineNum">    8233 </span>            :         return;
<span class="lineNum">    8234 </span>            :     }
<span class="lineNum">    8235 </span>            : 
<span class="lineNum">    8236 </span><span class="lineCov">       8025 :   if (CP_DECL_THREAD_LOCAL_P (decl) &amp;&amp; DECL_GNU_TLS_P (decl)</span>
<span class="lineNum">    8237 </span><span class="lineCov">       8034 :       &amp;&amp; !DECL_FUNCTION_SCOPE_P (decl))</span>
<span class="lineNum">    8238 </span>            :     {
<span class="lineNum">    8239 </span><span class="lineCov">          9 :       if (init)</span>
<span class="lineNum">    8240 </span><span class="lineCov">          9 :         error (&quot;non-local variable %qD declared %&lt;__thread%&gt; &quot;</span>
<span class="lineNum">    8241 </span>            :                &quot;needs dynamic initialization&quot;, decl);
<span class="lineNum">    8242 </span>            :       else
<span class="lineNum">    8243 </span><span class="lineNoCov">          0 :         error (&quot;non-local variable %qD declared %&lt;__thread%&gt; &quot;</span>
<span class="lineNum">    8244 </span>            :                &quot;has a non-trivial destructor&quot;, decl);
<span class="lineNum">    8245 </span><span class="lineCov">          9 :       static bool informed;</span>
<span class="lineNum">    8246 </span><span class="lineCov">          9 :       if (!informed)</span>
<span class="lineNum">    8247 </span>            :         {
<span class="lineNum">    8248 </span><span class="lineCov">          3 :           inform (DECL_SOURCE_LOCATION (decl),</span>
<span class="lineNum">    8249 </span>            :                   &quot;C++11 %&lt;thread_local%&gt; allows dynamic initialization &quot;
<span class="lineNum">    8250 </span>            :                   &quot;and destruction&quot;);
<span class="lineNum">    8251 </span><span class="lineCov">          3 :           informed = true;</span>
<span class="lineNum">    8252 </span>            :         }
<span class="lineNum">    8253 </span><span class="lineCov">          9 :       return;</span>
<span class="lineNum">    8254 </span>            :     }
<span class="lineNum">    8255 </span>            : 
<span class="lineNum">    8256 </span><span class="lineCov">       8016 :   if (DECL_FUNCTION_SCOPE_P (decl))</span>
<span class="lineNum">    8257 </span>            :     {
<span class="lineNum">    8258 </span>            :       /* Emit code to perform this initialization but once.  */
<span class="lineNum">    8259 </span><span class="lineCov">       2277 :       tree if_stmt = NULL_TREE, inner_if_stmt = NULL_TREE;</span>
<span class="lineNum">    8260 </span><span class="lineCov">       2277 :       tree then_clause = NULL_TREE, inner_then_clause = NULL_TREE;</span>
<span class="lineNum">    8261 </span><span class="lineCov">       2277 :       tree guard, guard_addr;</span>
<span class="lineNum">    8262 </span><span class="lineCov">       2277 :       tree flag, begin;</span>
<span class="lineNum">    8263 </span>            :       /* We don't need thread-safety code for thread-local vars.  */
<span class="lineNum">    8264 </span><span class="lineCov">       2277 :       bool thread_guard = (flag_threadsafe_statics</span>
<span class="lineNum">    8265 </span><span class="lineCov">       2277 :                            &amp;&amp; !CP_DECL_THREAD_LOCAL_P (decl));</span>
<span class="lineNum">    8266 </span>            : 
<span class="lineNum">    8267 </span>            :       /* Emit code to perform this initialization but once.  This code
<span class="lineNum">    8268 </span>            :          looks like:
<span class="lineNum">    8269 </span>            : 
<span class="lineNum">    8270 </span>            :            static &lt;type&gt; guard;
<span class="lineNum">    8271 </span>            :            if (!__atomic_load (guard.first_byte)) {
<span class="lineNum">    8272 </span>            :              if (__cxa_guard_acquire (&amp;guard)) {
<span class="lineNum">    8273 </span>            :                bool flag = false;
<span class="lineNum">    8274 </span>            :                try {
<span class="lineNum">    8275 </span>            :                  // Do initialization.
<span class="lineNum">    8276 </span>            :                  flag = true; __cxa_guard_release (&amp;guard);
<span class="lineNum">    8277 </span>            :                  // Register variable for destruction at end of program.
<span class="lineNum">    8278 </span>            :                } catch {
<span class="lineNum">    8279 </span>            :                  if (!flag) __cxa_guard_abort (&amp;guard);
<span class="lineNum">    8280 </span>            :                }
<span class="lineNum">    8281 </span>            :              }
<span class="lineNum">    8282 </span>            :            }
<span class="lineNum">    8283 </span>            : 
<span class="lineNum">    8284 </span>            :          Note that the `flag' variable is only set to 1 *after* the
<span class="lineNum">    8285 </span>            :          initialization is complete.  This ensures that an exception,
<span class="lineNum">    8286 </span>            :          thrown during the construction, will cause the variable to
<span class="lineNum">    8287 </span>            :          reinitialized when we pass through this code again, as per:
<span class="lineNum">    8288 </span>            : 
<span class="lineNum">    8289 </span>            :            [stmt.dcl]
<span class="lineNum">    8290 </span>            : 
<span class="lineNum">    8291 </span>            :            If the initialization exits by throwing an exception, the
<span class="lineNum">    8292 </span>            :            initialization is not complete, so it will be tried again
<span class="lineNum">    8293 </span>            :            the next time control enters the declaration.
<span class="lineNum">    8294 </span>            : 
<span class="lineNum">    8295 </span>            :          This process should be thread-safe, too; multiple threads
<span class="lineNum">    8296 </span>            :          should not be able to initialize the variable more than
<span class="lineNum">    8297 </span>            :          once.  */
<span class="lineNum">    8298 </span>            : 
<span class="lineNum">    8299 </span>            :       /* Create the guard variable.  */
<span class="lineNum">    8300 </span><span class="lineCov">       2277 :       guard = get_guard (decl);</span>
<span class="lineNum">    8301 </span>            : 
<span class="lineNum">    8302 </span>            :       /* Begin the conditional initialization.  */
<span class="lineNum">    8303 </span><span class="lineCov">       2277 :       if_stmt = begin_if_stmt ();</span>
<span class="lineNum">    8304 </span>            : 
<span class="lineNum">    8305 </span><span class="lineCov">       2277 :       finish_if_stmt_cond (get_guard_cond (guard, thread_guard), if_stmt);</span>
<span class="lineNum">    8306 </span><span class="lineCov">       2277 :       then_clause = begin_compound_stmt (BCS_NO_SCOPE);</span>
<span class="lineNum">    8307 </span>            : 
<span class="lineNum">    8308 </span><span class="lineCov">       2277 :       if (thread_guard)</span>
<span class="lineNum">    8309 </span>            :         {
<span class="lineNum">    8310 </span><span class="lineCov">       2253 :           tree vfntype = NULL_TREE;</span>
<span class="lineNum">    8311 </span><span class="lineCov">       2253 :           tree acquire_name, release_name, abort_name;</span>
<span class="lineNum">    8312 </span><span class="lineCov">       2253 :           tree acquire_fn, release_fn, abort_fn;</span>
<span class="lineNum">    8313 </span><span class="lineCov">       2253 :           guard_addr = build_address (guard);</span>
<span class="lineNum">    8314 </span>            : 
<span class="lineNum">    8315 </span><span class="lineCov">       2253 :           acquire_name = get_identifier (&quot;__cxa_guard_acquire&quot;);</span>
<span class="lineNum">    8316 </span><span class="lineCov">       2253 :           release_name = get_identifier (&quot;__cxa_guard_release&quot;);</span>
<span class="lineNum">    8317 </span><span class="lineCov">       2253 :           abort_name = get_identifier (&quot;__cxa_guard_abort&quot;);</span>
<span class="lineNum">    8318 </span><span class="lineCov">       2253 :           acquire_fn = get_global_binding (acquire_name);</span>
<span class="lineNum">    8319 </span><span class="lineCov">       2253 :           release_fn = get_global_binding (release_name);</span>
<span class="lineNum">    8320 </span><span class="lineCov">       2253 :           abort_fn = get_global_binding (abort_name);</span>
<span class="lineNum">    8321 </span><span class="lineCov">       2253 :           if (!acquire_fn)</span>
<span class="lineNum">    8322 </span><span class="lineCov">       1086 :             acquire_fn = push_library_fn</span>
<span class="lineNum">    8323 </span><span class="lineCov">       1086 :               (acquire_name, build_function_type_list (integer_type_node,</span>
<span class="lineNum">    8324 </span><span class="lineCov">       1086 :                                                        TREE_TYPE (guard_addr),</span>
<span class="lineNum">    8325 </span>            :                                                        NULL_TREE),
<span class="lineNum">    8326 </span>            :                NULL_TREE, ECF_NOTHROW | ECF_LEAF);
<span class="lineNum">    8327 </span><span class="lineCov">       2253 :           if (!release_fn || !abort_fn)</span>
<span class="lineNum">    8328 </span><span class="lineCov">       2178 :             vfntype = build_function_type_list (void_type_node,</span>
<span class="lineNum">    8329 </span><span class="lineCov">       1089 :                                                 TREE_TYPE (guard_addr),</span>
<span class="lineNum">    8330 </span>            :                                                 NULL_TREE);
<span class="lineNum">    8331 </span><span class="lineCov">       2253 :           if (!release_fn)</span>
<span class="lineNum">    8332 </span><span class="lineCov">       1089 :             release_fn = push_library_fn (release_name, vfntype, NULL_TREE,</span>
<span class="lineNum">    8333 </span>            :                                            ECF_NOTHROW | ECF_LEAF);
<span class="lineNum">    8334 </span><span class="lineCov">       2253 :           if (!abort_fn)</span>
<span class="lineNum">    8335 </span><span class="lineCov">       1089 :             abort_fn = push_library_fn (abort_name, vfntype, NULL_TREE,</span>
<span class="lineNum">    8336 </span>            :                                         ECF_NOTHROW | ECF_LEAF);
<span class="lineNum">    8337 </span>            : 
<span class="lineNum">    8338 </span><span class="lineCov">       2253 :           inner_if_stmt = begin_if_stmt ();</span>
<span class="lineNum">    8339 </span><span class="lineCov">       2253 :           finish_if_stmt_cond (build_call_n (acquire_fn, 1, guard_addr),</span>
<span class="lineNum">    8340 </span>            :                                inner_if_stmt);
<span class="lineNum">    8341 </span>            : 
<span class="lineNum">    8342 </span><span class="lineCov">       2253 :           inner_then_clause = begin_compound_stmt (BCS_NO_SCOPE);</span>
<span class="lineNum">    8343 </span><span class="lineCov">       2253 :           begin = get_target_expr (boolean_false_node);</span>
<span class="lineNum">    8344 </span><span class="lineCov">       2253 :           flag = TARGET_EXPR_SLOT (begin);</span>
<span class="lineNum">    8345 </span>            : 
<span class="lineNum">    8346 </span><span class="lineCov">       4506 :           TARGET_EXPR_CLEANUP (begin)</span>
<span class="lineNum">    8347 </span><span class="lineCov">       2253 :             = build3 (COND_EXPR, void_type_node, flag,</span>
<span class="lineNum">    8348 </span>            :                       void_node,
<span class="lineNum">    8349 </span>            :                       build_call_n (abort_fn, 1, guard_addr));
<span class="lineNum">    8350 </span><span class="lineCov">       2253 :           CLEANUP_EH_ONLY (begin) = 1;</span>
<span class="lineNum">    8351 </span>            : 
<span class="lineNum">    8352 </span>            :           /* Do the initialization itself.  */
<span class="lineNum">    8353 </span><span class="lineCov">       2253 :           init = add_stmt_to_compound (begin, init);</span>
<span class="lineNum">    8354 </span><span class="lineCov">       2253 :           init = add_stmt_to_compound</span>
<span class="lineNum">    8355 </span><span class="lineCov">       2253 :             (init, build2 (MODIFY_EXPR, void_type_node, flag, boolean_true_node));</span>
<span class="lineNum">    8356 </span><span class="lineCov">       2253 :           init = add_stmt_to_compound</span>
<span class="lineNum">    8357 </span><span class="lineCov">       2253 :             (init, build_call_n (release_fn, 1, guard_addr));</span>
<span class="lineNum">    8358 </span>            :         }
<span class="lineNum">    8359 </span>            :       else
<span class="lineNum">    8360 </span><span class="lineCov">         24 :         init = add_stmt_to_compound (init, set_guard (guard));</span>
<span class="lineNum">    8361 </span>            : 
<span class="lineNum">    8362 </span>            :       /* Use atexit to register a function for destroying this static
<span class="lineNum">    8363 </span>            :          variable.  */
<span class="lineNum">    8364 </span><span class="lineCov">       2277 :       init = add_stmt_to_compound (init, register_dtor_fn (decl));</span>
<span class="lineNum">    8365 </span>            : 
<span class="lineNum">    8366 </span><span class="lineCov">       2277 :       finish_expr_stmt (init);</span>
<span class="lineNum">    8367 </span>            : 
<span class="lineNum">    8368 </span><span class="lineCov">       2277 :       if (thread_guard)</span>
<span class="lineNum">    8369 </span>            :         {
<span class="lineNum">    8370 </span><span class="lineCov">       2253 :           finish_compound_stmt (inner_then_clause);</span>
<span class="lineNum">    8371 </span><span class="lineCov">       2253 :           finish_then_clause (inner_if_stmt);</span>
<span class="lineNum">    8372 </span><span class="lineCov">       2253 :           finish_if_stmt (inner_if_stmt);</span>
<span class="lineNum">    8373 </span>            :         }
<span class="lineNum">    8374 </span>            : 
<span class="lineNum">    8375 </span><span class="lineCov">       2277 :       finish_compound_stmt (then_clause);</span>
<span class="lineNum">    8376 </span><span class="lineCov">       2277 :       finish_then_clause (if_stmt);</span>
<span class="lineNum">    8377 </span><span class="lineCov">       2277 :       finish_if_stmt (if_stmt);</span>
<span class="lineNum">    8378 </span>            :     }
<span class="lineNum">    8379 </span><span class="lineCov">      17217 :   else if (CP_DECL_THREAD_LOCAL_P (decl))</span>
<span class="lineNum">    8380 </span><span class="lineCov">         35 :     tls_aggregates = tree_cons (init, decl, tls_aggregates);</span>
<span class="lineNum">    8381 </span>            :   else
<span class="lineNum">    8382 </span><span class="lineCov">       5704 :     static_aggregates = tree_cons (init, decl, static_aggregates);</span>
<span class="lineNum">    8383 </span>            : }
<span class="lineNum">    8384 </span>            : 
<span class="lineNum">    8385 </span>            : 
<span class="lineNum">    8386 </span>            : /* Make TYPE a complete type based on INITIAL_VALUE.
<span class="lineNum">    8387 </span>            :    Return 0 if successful, 1 if INITIAL_VALUE can't be deciphered,
<span class="lineNum">    8388 </span>            :    2 if there was no information (in which case assume 0 if DO_DEFAULT),
<span class="lineNum">    8389 </span>            :    3 if the initializer list is empty (in pedantic mode). */
<a name="8390"><span class="lineNum">    8390 </span>            : </a>
<span class="lineNum">    8391 </span>            : int
<span class="lineNum">    8392 </span><span class="lineCov">     185524 : cp_complete_array_type (tree *ptype, tree initial_value, bool do_default)</span>
<span class="lineNum">    8393 </span>            : {
<span class="lineNum">    8394 </span><span class="lineCov">     185524 :   int failure;</span>
<span class="lineNum">    8395 </span><span class="lineCov">     185524 :   tree type, elt_type;</span>
<span class="lineNum">    8396 </span>            : 
<span class="lineNum">    8397 </span>            :   /* Don't get confused by a CONSTRUCTOR for some other type.  */
<span class="lineNum">    8398 </span><span class="lineCov">     185490 :   if (initial_value &amp;&amp; TREE_CODE (initial_value) == CONSTRUCTOR</span>
<span class="lineNum">    8399 </span><span class="lineCov">       3994 :       &amp;&amp; !BRACE_ENCLOSED_INITIALIZER_P (initial_value)</span>
<span class="lineNum">    8400 </span><span class="lineCov">     185641 :       &amp;&amp; TREE_CODE (TREE_TYPE (initial_value)) != ARRAY_TYPE)</span>
<span class="lineNum">    8401 </span>            :     return 1;
<span class="lineNum">    8402 </span>            : 
<span class="lineNum">    8403 </span><span class="lineCov">     185521 :   if (initial_value)</span>
<span class="lineNum">    8404 </span>            :     {
<span class="lineNum">    8405 </span><span class="lineCov">     185487 :       unsigned HOST_WIDE_INT i;</span>
<span class="lineNum">    8406 </span><span class="lineCov">     185487 :       tree value;</span>
<span class="lineNum">    8407 </span>            : 
<span class="lineNum">    8408 </span>            :       /* An array of character type can be initialized from a
<span class="lineNum">    8409 </span>            :          brace-enclosed string constant.
<span class="lineNum">    8410 </span>            : 
<span class="lineNum">    8411 </span>            :          FIXME: this code is duplicated from reshape_init. Probably
<span class="lineNum">    8412 </span>            :          we should just call reshape_init here?  */
<span class="lineNum">    8413 </span><span class="lineCov">     185487 :       if (char_type_p (TYPE_MAIN_VARIANT (TREE_TYPE (*ptype)))</span>
<span class="lineNum">    8414 </span><span class="lineCov">     181691 :           &amp;&amp; TREE_CODE (initial_value) == CONSTRUCTOR</span>
<span class="lineNum">    8415 </span><span class="lineCov">     185975 :           &amp;&amp; !vec_safe_is_empty (CONSTRUCTOR_ELTS (initial_value)))</span>
<span class="lineNum">    8416 </span>            :         {
<span class="lineNum">    8417 </span><span class="lineCov">        224 :           vec&lt;constructor_elt, va_gc&gt; *v = CONSTRUCTOR_ELTS (initial_value);</span>
<span class="lineNum">    8418 </span><span class="lineCov">        224 :           tree value = (*v)[0].value;</span>
<span class="lineNum">    8419 </span>            : 
<span class="lineNum">    8420 </span><span class="lineCov">        224 :           if (TREE_CODE (value) == STRING_CST</span>
<span class="lineNum">    8421 </span><span class="lineCov">        224 :               &amp;&amp; v-&gt;length () == 1)</span>
<span class="lineNum">    8422 </span>            :             initial_value = value;
<span class="lineNum">    8423 </span>            :         }
<span class="lineNum">    8424 </span>            : 
<span class="lineNum">    8425 </span>            :       /* If any of the elements are parameter packs, we can't actually
<span class="lineNum">    8426 </span>            :          complete this type now because the array size is dependent.  */
<span class="lineNum">    8427 </span><span class="lineCov">     185487 :       if (TREE_CODE (initial_value) == CONSTRUCTOR)</span>
<span class="lineNum">    8428 </span>            :         {
<span class="lineNum">    8429 </span><span class="lineCov">     124642 :           FOR_EACH_CONSTRUCTOR_VALUE (CONSTRUCTOR_ELTS (initial_value), </span>
<span class="lineNum">    8430 </span>            :                                       i, value)
<span class="lineNum">    8431 </span>            :             {
<span class="lineNum">    8432 </span><span class="lineCov">      56596 :               if (PACK_EXPANSION_P (value))</span>
<span class="lineNum">    8433 </span>            :                 return 0;
<span class="lineNum">    8434 </span>            :             }
<span class="lineNum">    8435 </span>            :         }
<span class="lineNum">    8436 </span>            :     }
<span class="lineNum">    8437 </span>            : 
<span class="lineNum">    8438 </span><span class="lineCov">     185315 :   failure = complete_array_type (ptype, initial_value, do_default);</span>
<span class="lineNum">    8439 </span>            : 
<span class="lineNum">    8440 </span>            :   /* We can create the array before the element type is complete, which
<span class="lineNum">    8441 </span>            :      means that we didn't have these two bits set in the original type
<span class="lineNum">    8442 </span>            :      either.  In completing the type, we are expected to propagate these
<span class="lineNum">    8443 </span>            :      bits.  See also complete_type which does the same thing for arrays
<span class="lineNum">    8444 </span>            :      of fixed size.  */
<span class="lineNum">    8445 </span><span class="lineCov">     185315 :   type = *ptype;</span>
<span class="lineNum">    8446 </span><span class="lineCov">     185315 :   if (type != error_mark_node &amp;&amp; TYPE_DOMAIN (type))</span>
<span class="lineNum">    8447 </span>            :     {
<span class="lineNum">    8448 </span><span class="lineCov">     185284 :       elt_type = TREE_TYPE (type);</span>
<span class="lineNum">    8449 </span><span class="lineCov">     185284 :       TYPE_NEEDS_CONSTRUCTING (type) = TYPE_NEEDS_CONSTRUCTING (elt_type);</span>
<span class="lineNum">    8450 </span><span class="lineCov">     555852 :       TYPE_HAS_NONTRIVIAL_DESTRUCTOR (type)</span>
<span class="lineNum">    8451 </span><span class="lineCov">     185284 :         = TYPE_HAS_NONTRIVIAL_DESTRUCTOR (elt_type);</span>
<span class="lineNum">    8452 </span>            :     }
<span class="lineNum">    8453 </span>            : 
<span class="lineNum">    8454 </span>            :   return failure;
<span class="lineNum">    8455 </span>            : }
<span class="lineNum">    8456 </span>            : 
<span class="lineNum">    8457 </span>            : /* As above, but either give an error or reject zero-size arrays, depending
<span class="lineNum">    8458 </span>            :    on COMPLAIN.  */
<a name="8459"><span class="lineNum">    8459 </span>            : </a>
<span class="lineNum">    8460 </span>            : int
<span class="lineNum">    8461 </span><span class="lineCov">         44 : cp_complete_array_type_or_error (tree *ptype, tree initial_value,</span>
<span class="lineNum">    8462 </span>            :                                  bool do_default, tsubst_flags_t complain)
<span class="lineNum">    8463 </span>            : {
<span class="lineNum">    8464 </span><span class="lineCov">         44 :   int failure;</span>
<span class="lineNum">    8465 </span><span class="lineCov">         44 :   bool sfinae = !(complain &amp; tf_error);</span>
<span class="lineNum">    8466 </span>            :   /* In SFINAE context we can't be lenient about zero-size arrays.  */
<span class="lineNum">    8467 </span><span class="lineCov">         44 :   if (sfinae)</span>
<span class="lineNum">    8468 </span><span class="lineCov">          2 :     ++pedantic;</span>
<span class="lineNum">    8469 </span><span class="lineCov">         44 :   failure = cp_complete_array_type (ptype, initial_value, do_default);</span>
<span class="lineNum">    8470 </span><span class="lineCov">         44 :   if (sfinae)</span>
<span class="lineNum">    8471 </span><span class="lineCov">          2 :     --pedantic;</span>
<span class="lineNum">    8472 </span><span class="lineCov">         44 :   if (failure)</span>
<span class="lineNum">    8473 </span>            :     {
<span class="lineNum">    8474 </span><span class="lineCov">          2 :       if (sfinae)</span>
<span class="lineNum">    8475 </span>            :         /* Not an error.  */;
<span class="lineNum">    8476 </span><span class="lineNoCov">          0 :       else if (failure == 1)</span>
<span class="lineNum">    8477 </span><span class="lineNoCov">          0 :         error (&quot;initializer fails to determine size of %qT&quot;, *ptype);</span>
<span class="lineNum">    8478 </span><span class="lineNoCov">          0 :       else if (failure == 2)</span>
<span class="lineNum">    8479 </span>            :         {
<span class="lineNum">    8480 </span><span class="lineNoCov">          0 :           if (do_default)</span>
<span class="lineNum">    8481 </span><span class="lineNoCov">          0 :             error (&quot;array size missing in %qT&quot;, *ptype);</span>
<span class="lineNum">    8482 </span>            :         }
<span class="lineNum">    8483 </span><span class="lineNoCov">          0 :       else if (failure == 3)</span>
<span class="lineNum">    8484 </span><span class="lineNoCov">          0 :         error (&quot;zero-size array %qT&quot;, *ptype);</span>
<span class="lineNum">    8485 </span><span class="lineCov">          2 :       *ptype = error_mark_node;</span>
<span class="lineNum">    8486 </span>            :     }
<span class="lineNum">    8487 </span><span class="lineCov">         44 :   return failure;</span>
<span class="lineNum">    8488 </span>            : }
<span class="lineNum">    8489 </span>            : 
<span class="lineNum">    8490 </span>            : /* Return zero if something is declared to be a member of type
<span class="lineNum">    8491 </span>            :    CTYPE when in the context of CUR_TYPE.  STRING is the error
<span class="lineNum">    8492 </span>            :    message to print in that case.  Otherwise, quietly return 1.  */
<a name="8493"><span class="lineNum">    8493 </span>            : </a>
<span class="lineNum">    8494 </span>            : static int
<span class="lineNum">    8495 </span><span class="lineCov">    1075705 : member_function_or_else (tree ctype, tree cur_type, enum overload_flags flags)</span>
<span class="lineNum">    8496 </span>            : {
<span class="lineNum">    8497 </span><span class="lineCov">    1075705 :   if (ctype &amp;&amp; ctype != cur_type)</span>
<span class="lineNum">    8498 </span>            :     {
<span class="lineNum">    8499 </span><span class="lineNoCov">          0 :       if (flags == DTOR_FLAG)</span>
<span class="lineNum">    8500 </span><span class="lineNoCov">          0 :         error (&quot;destructor for alien class %qT cannot be a member&quot;, ctype);</span>
<span class="lineNum">    8501 </span>            :       else
<span class="lineNum">    8502 </span><span class="lineNoCov">          0 :         error (&quot;constructor for alien class %qT cannot be a member&quot;, ctype);</span>
<span class="lineNum">    8503 </span><span class="lineNoCov">          0 :       return 0;</span>
<span class="lineNum">    8504 </span>            :     }
<span class="lineNum">    8505 </span>            :   return 1;
<span class="lineNum">    8506 </span>            : }
<span class="lineNum">    8507 </span>            : 
<span class="lineNum">    8508 </span>            : /* Subroutine of `grokdeclarator'.  */
<span class="lineNum">    8509 </span>            : 
<span class="lineNum">    8510 </span>            : /* Generate errors possibly applicable for a given set of specifiers.
<span class="lineNum">    8511 </span>            :    This is for ARM $7.1.2.  */
<a name="8512"><span class="lineNum">    8512 </span>            : </a>
<span class="lineNum">    8513 </span>            : static void
<span class="lineNum">    8514 </span><span class="lineCov">   24745993 : bad_specifiers (tree object,</span>
<span class="lineNum">    8515 </span>            :                 enum bad_spec_place type,
<span class="lineNum">    8516 </span>            :                 int virtualp,
<span class="lineNum">    8517 </span>            :                 int quals,
<span class="lineNum">    8518 </span>            :                 int inlinep,
<span class="lineNum">    8519 </span>            :                 int friendp,
<span class="lineNum">    8520 </span>            :                 int raises,
<span class="lineNum">    8521 </span>            :                 const location_t* locations)
<span class="lineNum">    8522 </span>            : {
<span class="lineNum">    8523 </span><span class="lineCov">   24745993 :   switch (type)</span>
<span class="lineNum">    8524 </span>            :     {
<span class="lineNum">    8525 </span><span class="lineCov">    2591460 :       case BSP_VAR:</span>
<span class="lineNum">    8526 </span><span class="lineCov">    2591460 :         if (virtualp)</span>
<span class="lineNum">    8527 </span><span class="lineNoCov">          0 :           error_at (locations[ds_virtual],</span>
<span class="lineNum">    8528 </span>            :                     &quot;%qD declared as a %&lt;virtual%&gt; variable&quot;, object);
<span class="lineNum">    8529 </span><span class="lineCov">    2591460 :         if (quals)</span>
<span class="lineNum">    8530 </span><span class="lineCov">          3 :           error (&quot;%&lt;const%&gt; and %&lt;volatile%&gt; function specifiers on &quot;</span>
<span class="lineNum">    8531 </span>            :                  &quot;%qD invalid in variable declaration&quot;, object);
<span class="lineNum">    8532 </span>            :         break;
<span class="lineNum">    8533 </span><span class="lineCov">   17188090 :       case BSP_PARM:</span>
<span class="lineNum">    8534 </span><span class="lineCov">   17188090 :         if (virtualp)</span>
<span class="lineNum">    8535 </span><span class="lineNoCov">          0 :           error_at (locations[ds_virtual],</span>
<span class="lineNum">    8536 </span>            :                     &quot;%qD declared as a %&lt;virtual%&gt; parameter&quot;, object);
<span class="lineNum">    8537 </span><span class="lineCov">   17188090 :         if (inlinep)</span>
<span class="lineNum">    8538 </span><span class="lineCov">          5 :           error_at (locations[ds_inline],</span>
<span class="lineNum">    8539 </span>            :                     &quot;%qD declared as an %&lt;inline%&gt; parameter&quot;, object);
<span class="lineNum">    8540 </span><span class="lineCov">   17188090 :         if (quals)</span>
<span class="lineNum">    8541 </span><span class="lineCov">          2 :           error (&quot;%&lt;const%&gt; and %&lt;volatile%&gt; function specifiers on &quot;</span>
<span class="lineNum">    8542 </span>            :                  &quot;%qD invalid in parameter declaration&quot;, object);
<span class="lineNum">    8543 </span>            :         break;
<span class="lineNum">    8544 </span><span class="lineCov">    2797988 :       case BSP_TYPE:</span>
<span class="lineNum">    8545 </span><span class="lineCov">    2797988 :         if (virtualp)</span>
<span class="lineNum">    8546 </span><span class="lineNoCov">          0 :           error_at (locations[ds_virtual],</span>
<span class="lineNum">    8547 </span>            :                     &quot;%qD declared as a %&lt;virtual%&gt; type&quot;, object);
<span class="lineNum">    8548 </span><span class="lineCov">    2797988 :         if (inlinep)</span>
<span class="lineNum">    8549 </span><span class="lineCov">          5 :           error_at (locations[ds_inline],</span>
<span class="lineNum">    8550 </span>            :                     &quot;%qD declared as an %&lt;inline%&gt; type&quot;, object);
<span class="lineNum">    8551 </span><span class="lineCov">    2797988 :         if (quals)</span>
<span class="lineNum">    8552 </span><span class="lineNoCov">          0 :           error (&quot;%&lt;const%&gt; and %&lt;volatile%&gt; function specifiers on &quot;</span>
<span class="lineNum">    8553 </span>            :                  &quot;%qD invalid in type declaration&quot;, object);
<span class="lineNum">    8554 </span>            :         break;
<span class="lineNum">    8555 </span><span class="lineCov">    2168455 :       case BSP_FIELD:</span>
<span class="lineNum">    8556 </span><span class="lineCov">    2168455 :         if (virtualp)</span>
<span class="lineNum">    8557 </span><span class="lineCov">          5 :           error_at (locations[ds_virtual],</span>
<span class="lineNum">    8558 </span>            :                     &quot;%qD declared as a %&lt;virtual%&gt; field&quot;, object);
<span class="lineNum">    8559 </span><span class="lineCov">    2168455 :         if (inlinep)</span>
<span class="lineNum">    8560 </span><span class="lineCov">          5 :           error_at (locations[ds_inline],</span>
<span class="lineNum">    8561 </span>            :                     &quot;%qD declared as an %&lt;inline%&gt; field&quot;, object);
<span class="lineNum">    8562 </span><span class="lineCov">    2168455 :         if (quals)</span>
<span class="lineNum">    8563 </span><span class="lineNoCov">          0 :           error (&quot;%&lt;const%&gt; and %&lt;volatile%&gt; function specifiers on &quot;</span>
<span class="lineNum">    8564 </span>            :                  &quot;%qD invalid in field declaration&quot;, object);
<span class="lineNum">    8565 </span>            :         break;
<span class="lineNum">    8566 </span><span class="lineNoCov">          0 :       default:</span>
<span class="lineNum">    8567 </span><span class="lineNoCov">          0 :         gcc_unreachable();</span>
<span class="lineNum">    8568 </span>            :     }
<span class="lineNum">    8569 </span><span class="lineCov">   24745993 :   if (friendp)</span>
<span class="lineNum">    8570 </span><span class="lineNoCov">          0 :     error (&quot;%q+D declared as a friend&quot;, object);</span>
<span class="lineNum">    8571 </span><span class="lineCov">   24745993 :   if (raises</span>
<span class="lineNum">    8572 </span><span class="lineCov">        995 :       &amp;&amp; !flag_noexcept_type</span>
<span class="lineNum">    8573 </span><span class="lineCov">   24746024 :       &amp;&amp; (TREE_CODE (object) == TYPE_DECL</span>
<span class="lineNum">    8574 </span><span class="lineCov">         22 :           || (!TYPE_PTRFN_P (TREE_TYPE (object))</span>
<span class="lineNum">    8575 </span><span class="lineCov">         24 :               &amp;&amp; !TYPE_REFFN_P (TREE_TYPE (object))</span>
<span class="lineNum">    8576 </span><span class="lineCov">         18 :               &amp;&amp; !TYPE_PTRMEMFUNC_P (TREE_TYPE (object)))))</span>
<span class="lineNum">    8577 </span><span class="lineCov">          9 :     error (&quot;%q+D declared with an exception specification&quot;, object);</span>
<span class="lineNum">    8578 </span><span class="lineCov">   24745993 : }</span>
<span class="lineNum">    8579 </span>            : 
<span class="lineNum">    8580 </span>            : /* DECL is a member function or static data member and is presently
<span class="lineNum">    8581 </span>            :    being defined.  Check that the definition is taking place in a
<span class="lineNum">    8582 </span>            :    valid namespace.  */
<a name="8583"><span class="lineNum">    8583 </span>            : </a>
<span class="lineNum">    8584 </span>            : static void
<span class="lineNum">    8585 </span><span class="lineCov">    3451882 : check_class_member_definition_namespace (tree decl)</span>
<span class="lineNum">    8586 </span>            : {
<span class="lineNum">    8587 </span>            :   /* These checks only apply to member functions and static data
<span class="lineNum">    8588 </span>            :      members.  */
<span class="lineNum">    8589 </span><span class="lineCov">    3451882 :   gcc_assert (VAR_OR_FUNCTION_DECL_P (decl));</span>
<span class="lineNum">    8590 </span>            :   /* We check for problems with specializations in pt.c in
<span class="lineNum">    8591 </span>            :      check_specialization_namespace, where we can issue better
<span class="lineNum">    8592 </span>            :      diagnostics.  */
<span class="lineNum">    8593 </span><span class="lineCov">    3451882 :   if (processing_specialization)</span>
<span class="lineNum">    8594 </span>            :     return;
<span class="lineNum">    8595 </span>            :   /* We check this in check_explicit_instantiation_namespace.  */
<span class="lineNum">    8596 </span><span class="lineCov">    3432640 :   if (processing_explicit_instantiation)</span>
<span class="lineNum">    8597 </span>            :     return;
<span class="lineNum">    8598 </span>            :   /* [class.mfct]
<span class="lineNum">    8599 </span>            : 
<span class="lineNum">    8600 </span>            :      A member function definition that appears outside of the
<span class="lineNum">    8601 </span>            :      class definition shall appear in a namespace scope enclosing
<span class="lineNum">    8602 </span>            :      the class definition.
<span class="lineNum">    8603 </span>            : 
<span class="lineNum">    8604 </span>            :      [class.static.data]
<span class="lineNum">    8605 </span>            : 
<span class="lineNum">    8606 </span>            :      The definition for a static data member shall appear in a
<span class="lineNum">    8607 </span>            :      namespace scope enclosing the member's class definition.  */
<span class="lineNum">    8608 </span><span class="lineCov">    3432567 :   if (!is_ancestor (current_namespace, DECL_CONTEXT (decl)))</span>
<span class="lineNum">    8609 </span><span class="lineCov">         36 :     permerror (input_location, &quot;definition of %qD is not in namespace enclosing %qT&quot;,</span>
<span class="lineNum">    8610 </span><span class="lineCov">         18 :                decl, DECL_CONTEXT (decl));</span>
<span class="lineNum">    8611 </span>            : }
<span class="lineNum">    8612 </span>            : 
<span class="lineNum">    8613 </span>            : /* Build a PARM_DECL for the &quot;this&quot; parameter of FN.  TYPE is the
<span class="lineNum">    8614 </span>            :    METHOD_TYPE for a non-static member function; QUALS are the
<span class="lineNum">    8615 </span>            :    cv-qualifiers that apply to the function.  */
<a name="8616"><span class="lineNum">    8616 </span>            : </a>
<span class="lineNum">    8617 </span>            : tree
<span class="lineNum">    8618 </span><span class="lineCov">    6441928 : build_this_parm (tree fn, tree type, cp_cv_quals quals)</span>
<span class="lineNum">    8619 </span>            : {
<span class="lineNum">    8620 </span><span class="lineCov">    6441928 :   tree this_type;</span>
<span class="lineNum">    8621 </span><span class="lineCov">    6441928 :   tree qual_type;</span>
<span class="lineNum">    8622 </span><span class="lineCov">    6441928 :   tree parm;</span>
<span class="lineNum">    8623 </span><span class="lineCov">    6441928 :   cp_cv_quals this_quals;</span>
<span class="lineNum">    8624 </span>            : 
<span class="lineNum">    8625 </span><span class="lineCov">    6441928 :   if (CLASS_TYPE_P (type))</span>
<span class="lineNum">    8626 </span>            :     {
<span class="lineNum">    8627 </span><span class="lineCov">      99608 :       this_type</span>
<span class="lineNum">    8628 </span><span class="lineCov">      99608 :         = cp_build_qualified_type (type, quals &amp; ~TYPE_QUAL_RESTRICT);</span>
<span class="lineNum">    8629 </span><span class="lineCov">      99608 :       this_type = build_pointer_type (this_type);</span>
<span class="lineNum">    8630 </span>            :     }
<span class="lineNum">    8631 </span>            :   else
<span class="lineNum">    8632 </span><span class="lineCov">    6342320 :     this_type = type_of_this_parm (type);</span>
<span class="lineNum">    8633 </span>            :   /* The `this' parameter is implicitly `const'; it cannot be
<span class="lineNum">    8634 </span>            :      assigned to.  */
<span class="lineNum">    8635 </span><span class="lineCov">    6441928 :   this_quals = (quals &amp; TYPE_QUAL_RESTRICT) | TYPE_QUAL_CONST;</span>
<span class="lineNum">    8636 </span><span class="lineCov">    6441928 :   qual_type = cp_build_qualified_type (this_type, this_quals);</span>
<span class="lineNum">    8637 </span><span class="lineCov">    6441928 :   parm = build_artificial_parm (fn, this_identifier, qual_type);</span>
<span class="lineNum">    8638 </span><span class="lineCov">    6441928 :   cp_apply_type_quals_to_decl (this_quals, parm);</span>
<span class="lineNum">    8639 </span><span class="lineCov">    6441928 :   return parm;</span>
<span class="lineNum">    8640 </span>            : }
<span class="lineNum">    8641 </span>            : 
<span class="lineNum">    8642 </span>            : /* DECL is a static member function.  Complain if it was declared
<span class="lineNum">    8643 </span>            :    with function-cv-quals.  */
<a name="8644"><span class="lineNum">    8644 </span>            : </a>
<span class="lineNum">    8645 </span>            : static void
<span class="lineNum">    8646 </span><span class="lineNoCov">          0 : check_static_quals (tree decl, cp_cv_quals quals)</span>
<span class="lineNum">    8647 </span>            : {
<span class="lineNum">    8648 </span><span class="lineNoCov">          0 :   if (quals != TYPE_UNQUALIFIED)</span>
<span class="lineNum">    8649 </span><span class="lineCov">          5 :     error (&quot;static member function %q#D declared with type qualifiers&quot;,</span>
<span class="lineNum">    8650 </span>            :            decl);
<span class="lineNum">    8651 </span><span class="lineNoCov">          0 : }</span>
<span class="lineNum">    8652 </span>            : 
<a name="8653"><span class="lineNum">    8653 </span>            : // Check that FN takes no arguments and returns bool.</a>
<span class="lineNum">    8654 </span>            : static void
<span class="lineNum">    8655 </span><span class="lineCov">        203 : check_concept_fn (tree fn)</span>
<span class="lineNum">    8656 </span>            : {
<span class="lineNum">    8657 </span>            :   // A constraint is nullary.
<span class="lineNum">    8658 </span><span class="lineCov">        203 :   if (DECL_ARGUMENTS (fn))</span>
<span class="lineNum">    8659 </span><span class="lineCov">          1 :     error_at (DECL_SOURCE_LOCATION (fn),</span>
<span class="lineNum">    8660 </span>            :               &quot;concept %q#D declared with function parameters&quot;, fn);
<span class="lineNum">    8661 </span>            : 
<span class="lineNum">    8662 </span>            :   // The declared return type of the concept shall be bool, and
<span class="lineNum">    8663 </span>            :   // it shall not be deduced from it definition.
<span class="lineNum">    8664 </span><span class="lineCov">        203 :   tree type = TREE_TYPE (TREE_TYPE (fn));</span>
<span class="lineNum">    8665 </span><span class="lineCov">        203 :   if (is_auto (type))</span>
<span class="lineNum">    8666 </span><span class="lineCov">          1 :     error_at (DECL_SOURCE_LOCATION (fn),</span>
<span class="lineNum">    8667 </span>            :               &quot;concept %q#D declared with a deduced return type&quot;, fn);
<span class="lineNum">    8668 </span><span class="lineCov">        202 :   else if (type != boolean_type_node)</span>
<span class="lineNum">    8669 </span><span class="lineCov">          2 :     error_at (DECL_SOURCE_LOCATION (fn),</span>
<span class="lineNum">    8670 </span>            :               &quot;concept %q#D with non-%&lt;bool%&gt; return type %qT&quot;, fn, type);
<span class="lineNum">    8671 </span><span class="lineCov">        203 : }</span>
<span class="lineNum">    8672 </span>            : 
<span class="lineNum">    8673 </span>            : /* Helper function.  Replace the temporary this parameter injected
<span class="lineNum">    8674 </span>            :    during cp_finish_omp_declare_simd with the real this parameter.  */
<a name="8675"><span class="lineNum">    8675 </span>            : </a>
<span class="lineNum">    8676 </span>            : static tree
<span class="lineNum">    8677 </span><span class="lineCov">       1311 : declare_simd_adjust_this (tree *tp, int *walk_subtrees, void *data)</span>
<span class="lineNum">    8678 </span>            : {
<span class="lineNum">    8679 </span><span class="lineCov">       1311 :   tree this_parm = (tree) data;</span>
<span class="lineNum">    8680 </span><span class="lineCov">       1311 :   if (TREE_CODE (*tp) == PARM_DECL</span>
<span class="lineNum">    8681 </span><span class="lineCov">        321 :       &amp;&amp; DECL_NAME (*tp) == this_identifier</span>
<span class="lineNum">    8682 </span><span class="lineCov">       1470 :       &amp;&amp; *tp != this_parm)</span>
<span class="lineNum">    8683 </span><span class="lineCov">        159 :     *tp = this_parm;</span>
<span class="lineNum">    8684 </span><span class="lineCov">       1152 :   else if (TYPE_P (*tp))</span>
<span class="lineNum">    8685 </span><span class="lineCov">         15 :     *walk_subtrees = 0;</span>
<span class="lineNum">    8686 </span><span class="lineCov">       1311 :   return NULL_TREE;</span>
<span class="lineNum">    8687 </span>            : }
<span class="lineNum">    8688 </span>            : 
<span class="lineNum">    8689 </span>            : /* CTYPE is class type, or null if non-class.
<span class="lineNum">    8690 </span>            :    TYPE is type this FUNCTION_DECL should have, either FUNCTION_TYPE
<span class="lineNum">    8691 </span>            :    or METHOD_TYPE.
<span class="lineNum">    8692 </span>            :    DECLARATOR is the function's name.
<span class="lineNum">    8693 </span>            :    PARMS is a chain of PARM_DECLs for the function.
<span class="lineNum">    8694 </span>            :    VIRTUALP is truthvalue of whether the function is virtual or not.
<span class="lineNum">    8695 </span>            :    FLAGS are to be passed through to `grokclassfn'.
<span class="lineNum">    8696 </span>            :    QUALS are qualifiers indicating whether the function is `const'
<span class="lineNum">    8697 </span>            :    or `volatile'.
<span class="lineNum">    8698 </span>            :    RAISES is a list of exceptions that this function can raise.
<span class="lineNum">    8699 </span>            :    CHECK is 1 if we must find this method in CTYPE, 0 if we should
<span class="lineNum">    8700 </span>            :    not look, and -1 if we should not call `grokclassfn' at all.
<span class="lineNum">    8701 </span>            : 
<span class="lineNum">    8702 </span>            :    SFK is the kind of special function (if any) for the new function.
<span class="lineNum">    8703 </span>            : 
<span class="lineNum">    8704 </span>            :    Returns `NULL_TREE' if something goes wrong, after issuing
<span class="lineNum">    8705 </span>            :    applicable error messages.  */
<a name="8706"><span class="lineNum">    8706 </span>            : </a>
<span class="lineNum">    8707 </span>            : static tree
<span class="lineNum">    8708 </span><span class="lineCov">   10172310 : grokfndecl (tree ctype,</span>
<span class="lineNum">    8709 </span>            :             tree type,
<span class="lineNum">    8710 </span>            :             tree declarator,
<span class="lineNum">    8711 </span>            :             tree parms,
<span class="lineNum">    8712 </span>            :             tree orig_declarator,
<span class="lineNum">    8713 </span>            :             const cp_decl_specifier_seq *declspecs,
<span class="lineNum">    8714 </span>            :             tree decl_reqs,
<span class="lineNum">    8715 </span>            :             int virtualp,
<span class="lineNum">    8716 </span>            :             enum overload_flags flags,
<span class="lineNum">    8717 </span>            :             cp_cv_quals quals,
<span class="lineNum">    8718 </span>            :             cp_ref_qualifier rqual,
<span class="lineNum">    8719 </span>            :             tree raises,
<span class="lineNum">    8720 </span>            :             int check,
<span class="lineNum">    8721 </span>            :             int friendp,
<span class="lineNum">    8722 </span>            :             int publicp,
<span class="lineNum">    8723 </span>            :             int inlinep,
<span class="lineNum">    8724 </span>            :             bool deletedp,
<span class="lineNum">    8725 </span>            :             special_function_kind sfk,
<span class="lineNum">    8726 </span>            :             bool funcdef_flag,
<span class="lineNum">    8727 </span>            :             bool late_return_type_p,
<span class="lineNum">    8728 </span>            :             int template_count,
<span class="lineNum">    8729 </span>            :             tree in_namespace,
<span class="lineNum">    8730 </span>            :             tree* attrlist,
<span class="lineNum">    8731 </span>            :             location_t location)
<span class="lineNum">    8732 </span>            : {
<span class="lineNum">    8733 </span><span class="lineCov">   10172310 :   tree decl;</span>
<span class="lineNum">    8734 </span><span class="lineCov">   10172310 :   int staticp = ctype &amp;&amp; TREE_CODE (type) == FUNCTION_TYPE;</span>
<span class="lineNum">    8735 </span><span class="lineCov">   10172310 :   tree t;</span>
<span class="lineNum">    8736 </span>            : 
<span class="lineNum">    8737 </span><span class="lineCov">   10172310 :   if (location == UNKNOWN_LOCATION)</span>
<span class="lineNum">    8738 </span><span class="lineCov">       4761 :     location = input_location;</span>
<span class="lineNum">    8739 </span>            : 
<span class="lineNum">    8740 </span>            :   // Was the concept specifier present?
<span class="lineNum">    8741 </span><span class="lineCov">   10172310 :   bool concept_p = inlinep &amp; 4;</span>
<span class="lineNum">    8742 </span>            : 
<span class="lineNum">    8743 </span>            :   // Concept declarations must have a corresponding definition.
<span class="lineNum">    8744 </span><span class="lineCov">   10172310 :   if (concept_p &amp;&amp; !funcdef_flag)</span>
<span class="lineNum">    8745 </span>            :     {
<span class="lineNum">    8746 </span><span class="lineCov">          1 :       error_at (location, &quot;concept %qD has no definition&quot;, declarator);</span>
<span class="lineNum">    8747 </span><span class="lineCov">          1 :       return NULL_TREE;</span>
<span class="lineNum">    8748 </span>            :     }
<span class="lineNum">    8749 </span>            : 
<span class="lineNum">    8750 </span><span class="lineCov">   10172309 :   type = build_cp_fntype_variant (type, rqual, raises, late_return_type_p);</span>
<span class="lineNum">    8751 </span>            : 
<span class="lineNum">    8752 </span><span class="lineCov">   10172309 :   decl = build_lang_decl_loc (location, FUNCTION_DECL, declarator, type);</span>
<span class="lineNum">    8753 </span>            : 
<span class="lineNum">    8754 </span>            :   /* Set the constraints on the declaration. */
<span class="lineNum">    8755 </span><span class="lineCov">   10172309 :   if (flag_concepts)</span>
<span class="lineNum">    8756 </span>            :     {
<span class="lineNum">    8757 </span><span class="lineCov">       7792 :       tree tmpl_reqs = NULL_TREE;</span>
<span class="lineNum">    8758 </span><span class="lineCov">       7792 :       if (processing_template_decl &gt; template_class_depth (ctype))</span>
<span class="lineNum">    8759 </span><span class="lineCov">       2605 :         tmpl_reqs = TEMPLATE_PARMS_CONSTRAINTS (current_template_parms);</span>
<span class="lineNum">    8760 </span>            : 
<span class="lineNum">    8761 </span>            :       /* Adjust the required expression into a constraint. */
<span class="lineNum">    8762 </span><span class="lineCov">       7792 :       if (decl_reqs)</span>
<span class="lineNum">    8763 </span><span class="lineCov">         62 :         decl_reqs = normalize_expression (decl_reqs);</span>
<span class="lineNum">    8764 </span>            : 
<span class="lineNum">    8765 </span><span class="lineCov">       7792 :       tree ci = build_constraints (tmpl_reqs, decl_reqs);</span>
<span class="lineNum">    8766 </span><span class="lineCov">       7792 :       set_constraints (decl, ci);</span>
<span class="lineNum">    8767 </span>            :     }
<span class="lineNum">    8768 </span>            : 
<span class="lineNum">    8769 </span><span class="lineCov">   10172309 :   if (TREE_CODE (type) == METHOD_TYPE)</span>
<span class="lineNum">    8770 </span>            :     {
<span class="lineNum">    8771 </span><span class="lineCov">    3802953 :       tree parm = build_this_parm (decl, type, quals);</span>
<span class="lineNum">    8772 </span><span class="lineCov">    3802953 :       DECL_CHAIN (parm) = parms;</span>
<span class="lineNum">    8773 </span><span class="lineCov">    3802953 :       parms = parm;</span>
<span class="lineNum">    8774 </span>            : 
<span class="lineNum">    8775 </span>            :       /* Allocate space to hold the vptr bit if needed.  */
<span class="lineNum">    8776 </span><span class="lineCov">    7605906 :       SET_DECL_ALIGN (decl, MINIMUM_METHOD_BOUNDARY);</span>
<span class="lineNum">    8777 </span>            :     }
<span class="lineNum">    8778 </span>            : 
<span class="lineNum">    8779 </span><span class="lineCov">   10172309 :   DECL_ARGUMENTS (decl) = parms;</span>
<span class="lineNum">    8780 </span><span class="lineCov">   30210374 :   for (t = parms; t; t = DECL_CHAIN (t))</span>
<span class="lineNum">    8781 </span><span class="lineCov">   20038065 :     DECL_CONTEXT (t) = decl;</span>
<span class="lineNum">    8782 </span>            : 
<span class="lineNum">    8783 </span>            :   /* Propagate volatile out from type to decl.  */
<span class="lineNum">    8784 </span><span class="lineCov">   10172309 :   if (TYPE_VOLATILE (type))</span>
<span class="lineNum">    8785 </span><span class="lineNoCov">          0 :     TREE_THIS_VOLATILE (decl) = 1;</span>
<span class="lineNum">    8786 </span>            : 
<span class="lineNum">    8787 </span>            :   /* Setup decl according to sfk.  */
<span class="lineNum">    8788 </span><span class="lineCov">   10172309 :   switch (sfk)</span>
<span class="lineNum">    8789 </span>            :     {
<span class="lineNum">    8790 </span><span class="lineCov">     944079 :     case sfk_constructor:</span>
<span class="lineNum">    8791 </span><span class="lineCov">     944079 :     case sfk_copy_constructor:</span>
<span class="lineNum">    8792 </span><span class="lineCov">     944079 :     case sfk_move_constructor:</span>
<span class="lineNum">    8793 </span><span class="lineCov">     944079 :       DECL_CXX_CONSTRUCTOR_P (decl) = 1;</span>
<span class="lineNum">    8794 </span><span class="lineCov">     944079 :       DECL_NAME (decl) = ctor_identifier;</span>
<span class="lineNum">    8795 </span><span class="lineCov">     944079 :       break;</span>
<span class="lineNum">    8796 </span><span class="lineCov">     169638 :     case sfk_destructor:</span>
<span class="lineNum">    8797 </span><span class="lineCov">     169638 :       DECL_CXX_DESTRUCTOR_P (decl) = 1;</span>
<span class="lineNum">    8798 </span><span class="lineCov">     169638 :       DECL_NAME (decl) = dtor_identifier;</span>
<span class="lineNum">    8799 </span><span class="lineCov">     169638 :       break;</span>
<span class="lineNum">    8800 </span>            :     default:
<span class="lineNum">    8801 </span>            :       break;
<span class="lineNum">    8802 </span>            :     }
<span class="lineNum">    8803 </span>            : 
<span class="lineNum">    8804 </span><span class="lineCov">   10172309 :   if (friendp &amp;&amp; TREE_CODE (orig_declarator) == TEMPLATE_ID_EXPR)</span>
<span class="lineNum">    8805 </span>            :     {
<span class="lineNum">    8806 </span><span class="lineCov">       1049 :       if (funcdef_flag)</span>
<span class="lineNum">    8807 </span><span class="lineCov">          3 :         error_at (location,</span>
<span class="lineNum">    8808 </span>            :                   &quot;defining explicit specialization %qD in friend declaration&quot;,
<span class="lineNum">    8809 </span>            :                   orig_declarator);
<span class="lineNum">    8810 </span>            :       else
<span class="lineNum">    8811 </span>            :         {
<span class="lineNum">    8812 </span><span class="lineCov">       1046 :           tree fns = TREE_OPERAND (orig_declarator, 0);</span>
<span class="lineNum">    8813 </span><span class="lineCov">       1046 :           tree args = TREE_OPERAND (orig_declarator, 1);</span>
<span class="lineNum">    8814 </span>            : 
<span class="lineNum">    8815 </span><span class="lineCov">       1046 :           if (PROCESSING_REAL_TEMPLATE_DECL_P ())</span>
<span class="lineNum">    8816 </span>            :             {
<span class="lineNum">    8817 </span>            :               /* Something like `template &lt;class T&gt; friend void f&lt;T&gt;()'.  */
<span class="lineNum">    8818 </span><span class="lineCov">          6 :               error_at (location,</span>
<span class="lineNum">    8819 </span>            :                         &quot;invalid use of template-id %qD in declaration &quot;
<span class="lineNum">    8820 </span>            :                         &quot;of primary template&quot;,
<span class="lineNum">    8821 </span>            :                         orig_declarator);
<span class="lineNum">    8822 </span><span class="lineCov">          6 :               return NULL_TREE;</span>
<span class="lineNum">    8823 </span>            :             }
<span class="lineNum">    8824 </span>            : 
<span class="lineNum">    8825 </span>            : 
<span class="lineNum">    8826 </span>            :           /* A friend declaration of the form friend void f&lt;&gt;().  Record
<span class="lineNum">    8827 </span>            :              the information in the TEMPLATE_ID_EXPR.  */
<span class="lineNum">    8828 </span><span class="lineCov">       1040 :           SET_DECL_IMPLICIT_INSTANTIATION (decl);</span>
<span class="lineNum">    8829 </span>            : 
<span class="lineNum">    8830 </span><span class="lineCov">       1040 :           gcc_assert (identifier_p (fns) || TREE_CODE (fns) == OVERLOAD);</span>
<span class="lineNum">    8831 </span><span class="lineCov">       1040 :           DECL_TEMPLATE_INFO (decl) = build_template_info (fns, args);</span>
<span class="lineNum">    8832 </span>            : 
<span class="lineNum">    8833 </span><span class="lineCov">       4909 :           for (t = TYPE_ARG_TYPES (TREE_TYPE (decl)); t; t = TREE_CHAIN (t))</span>
<span class="lineNum">    8834 </span><span class="lineCov">       3860 :             if (TREE_PURPOSE (t)</span>
<span class="lineNum">    8835 </span><span class="lineCov">       3860 :                 &amp;&amp; TREE_CODE (TREE_PURPOSE (t)) == DEFAULT_ARG)</span>
<span class="lineNum">    8836 </span>            :             {
<span class="lineNum">    8837 </span><span class="lineCov">          6 :               error_at (defarg_location (TREE_PURPOSE (t)),</span>
<span class="lineNum">    8838 </span>            :                         &quot;default arguments are not allowed in declaration &quot;
<span class="lineNum">    8839 </span>            :                         &quot;of friend template specialization %qD&quot;,
<span class="lineNum">    8840 </span>            :                         decl);
<span class="lineNum">    8841 </span><span class="lineCov">          3 :               return NULL_TREE;</span>
<span class="lineNum">    8842 </span>            :             }
<span class="lineNum">    8843 </span>            : 
<span class="lineNum">    8844 </span><span class="lineCov">       1037 :           if (inlinep &amp; 1)</span>
<span class="lineNum">    8845 </span>            :             {
<span class="lineNum">    8846 </span><span class="lineCov">          3 :               error_at (declspecs-&gt;locations[ds_inline],</span>
<span class="lineNum">    8847 </span>            :                         &quot;%&lt;inline%&gt; is not allowed in declaration of friend &quot;
<span class="lineNum">    8848 </span>            :                         &quot;template specialization %qD&quot;,
<span class="lineNum">    8849 </span>            :                         decl);
<span class="lineNum">    8850 </span><span class="lineCov">          3 :               return NULL_TREE;</span>
<span class="lineNum">    8851 </span>            :             }
<span class="lineNum">    8852 </span>            :         }
<span class="lineNum">    8853 </span>            :     }
<span class="lineNum">    8854 </span>            : 
<span class="lineNum">    8855 </span>            :   /* C++17 11.3.6/4: &quot;If a friend declaration specifies a default argument
<span class="lineNum">    8856 </span>            :      expression, that declaration shall be a definition...&quot;  */
<span class="lineNum">    8857 </span><span class="lineCov">   10172297 :   if (friendp &amp;&amp; !funcdef_flag)</span>
<span class="lineNum">    8858 </span>            :     {
<span class="lineNum">    8859 </span><span class="lineCov">      39771 :       for (tree t = FUNCTION_FIRST_USER_PARMTYPE (decl);</span>
<span class="lineNum">    8860 </span><span class="lineCov">     111183 :            t &amp;&amp; t != void_list_node; t = TREE_CHAIN (t))</span>
<span class="lineNum">    8861 </span><span class="lineCov">      71604 :         if (TREE_PURPOSE (t))</span>
<span class="lineNum">    8862 </span>            :           {
<span class="lineNum">    8863 </span><span class="lineCov">         21 :             permerror (DECL_SOURCE_LOCATION (decl),</span>
<span class="lineNum">    8864 </span>            :                        &quot;friend declaration of %qD specifies default &quot;
<span class="lineNum">    8865 </span>            :                        &quot;arguments and isn't a definition&quot;, decl);
<span class="lineNum">    8866 </span><span class="lineCov">         21 :             break;</span>
<span class="lineNum">    8867 </span>            :           }
<span class="lineNum">    8868 </span>            :     }
<span class="lineNum">    8869 </span>            : 
<span class="lineNum">    8870 </span>            :   /* If this decl has namespace scope, set that up.  */
<span class="lineNum">    8871 </span><span class="lineCov">   10172297 :   if (in_namespace)</span>
<span class="lineNum">    8872 </span><span class="lineCov">       7239 :     set_decl_namespace (decl, in_namespace, friendp);</span>
<span class="lineNum">    8873 </span><span class="lineCov">   10165058 :   else if (!ctype)</span>
<span class="lineNum">    8874 </span><span class="lineCov">    5569524 :     DECL_CONTEXT (decl) = FROB_CONTEXT (current_decl_namespace ());</span>
<span class="lineNum">    8875 </span>            : 
<span class="lineNum">    8876 </span>            :   /* `main' and builtins have implicit 'C' linkage.  */
<span class="lineNum">    8877 </span><span class="lineCov">   10172297 :   if (ctype == NULL_TREE</span>
<span class="lineNum">    8878 </span><span class="lineCov">    5576763 :       &amp;&amp; DECL_FILE_SCOPE_P (decl)</span>
<span class="lineNum">    8879 </span><span class="lineCov">    3794622 :       &amp;&amp; current_lang_name == lang_name_cplusplus</span>
<span class="lineNum">    8880 </span><span class="lineCov">   11196974 :       &amp;&amp; (MAIN_NAME_P (declarator)</span>
<span class="lineNum">    8881 </span><span class="lineCov">    2005778 :           || (IDENTIFIER_LENGTH (declarator) &gt; 10</span>
<span class="lineNum">    8882 </span><span class="lineCov">    1587820 :               &amp;&amp; IDENTIFIER_POINTER (declarator)[0] == '_'</span>
<span class="lineNum">    8883 </span><span class="lineCov">    1456916 :               &amp;&amp; IDENTIFIER_POINTER (declarator)[1] == '_'</span>
<span class="lineNum">    8884 </span><span class="lineCov">     201922 :               &amp;&amp; strncmp (IDENTIFIER_POINTER (declarator)+2,</span>
<span class="lineNum">    8885 </span>            :                           &quot;builtin_&quot;, 8) == 0)
<span class="lineNum">    8886 </span><span class="lineCov">    1002877 :           || (targetcm.cxx_implicit_extern_c</span>
<span class="lineNum">    8887 </span><span class="lineNoCov">          0 :               &amp;&amp; (targetcm.cxx_implicit_extern_c</span>
<span class="lineNum">    8888 </span><span class="lineNoCov">          0 :                   (IDENTIFIER_POINTER (declarator))))))</span>
<span class="lineNum">    8889 </span><span class="lineCov">      21800 :     SET_DECL_LANGUAGE (decl, lang_c);</span>
<span class="lineNum">    8890 </span>            : 
<span class="lineNum">    8891 </span>            :   /* Should probably propagate const out from type to decl I bet (mrs).  */
<span class="lineNum">    8892 </span><span class="lineCov">   10172297 :   if (staticp)</span>
<span class="lineNum">    8893 </span>            :     {
<span class="lineNum">    8894 </span><span class="lineCov">     792581 :       DECL_STATIC_FUNCTION_P (decl) = 1;</span>
<span class="lineNum">    8895 </span><span class="lineCov">     792581 :       DECL_CONTEXT (decl) = ctype;</span>
<span class="lineNum">    8896 </span>            :     }
<span class="lineNum">    8897 </span>            : 
<span class="lineNum">    8898 </span><span class="lineCov">   10172297 :   if (deletedp)</span>
<span class="lineNum">    8899 </span><span class="lineCov">      12377 :     DECL_DELETED_FN (decl) = 1;</span>
<span class="lineNum">    8900 </span>            : 
<span class="lineNum">    8901 </span><span class="lineCov">   10172297 :   if (ctype)</span>
<span class="lineNum">    8902 </span>            :     {
<span class="lineNum">    8903 </span><span class="lineCov">    4595534 :       DECL_CONTEXT (decl) = ctype;</span>
<span class="lineNum">    8904 </span><span class="lineCov">    4595534 :       if (funcdef_flag)</span>
<span class="lineNum">    8905 </span><span class="lineCov">    3395187 :         check_class_member_definition_namespace (decl);</span>
<span class="lineNum">    8906 </span>            :     }
<span class="lineNum">    8907 </span>            : 
<span class="lineNum">    8908 </span><span class="lineCov">   10172297 :   if (ctype == NULL_TREE &amp;&amp; DECL_MAIN_P (decl))</span>
<span class="lineNum">    8909 </span>            :     {
<span class="lineNum">    8910 </span><span class="lineCov">      21791 :       if (PROCESSING_REAL_TEMPLATE_DECL_P())</span>
<span class="lineNum">    8911 </span><span class="lineCov">          9 :         error_at (location, &quot;cannot declare %&lt;::main%&gt; to be a template&quot;);</span>
<span class="lineNum">    8912 </span><span class="lineCov">      21791 :       if (inlinep &amp; 1)</span>
<span class="lineNum">    8913 </span><span class="lineCov">          3 :         error_at (declspecs-&gt;locations[ds_inline],</span>
<span class="lineNum">    8914 </span>            :                   &quot;cannot declare %&lt;::main%&gt; to be inline&quot;);
<span class="lineNum">    8915 </span><span class="lineCov">      21791 :       if (inlinep &amp; 2)</span>
<span class="lineNum">    8916 </span><span class="lineCov">          4 :         error_at (declspecs-&gt;locations[ds_constexpr],</span>
<span class="lineNum">    8917 </span>            :                   &quot;cannot declare %&lt;::main%&gt; to be %&lt;constexpr%&gt;&quot;);
<span class="lineNum">    8918 </span><span class="lineCov">      21791 :       if (!publicp)</span>
<span class="lineNum">    8919 </span><span class="lineNoCov">          0 :         error_at (location, &quot;cannot declare %&lt;::main%&gt; to be static&quot;);</span>
<span class="lineNum">    8920 </span>            :       inlinep = 0;
<span class="lineNum">    8921 </span>            :       publicp = 1;
<span class="lineNum">    8922 </span>            :     }
<span class="lineNum">    8923 </span>            : 
<span class="lineNum">    8924 </span>            :   /* Members of anonymous types and local classes have no linkage; make
<span class="lineNum">    8925 </span>            :      them internal.  If a typedef is made later, this will be changed.  */
<span class="lineNum">    8926 </span><span class="lineCov">   10172297 :   if (ctype &amp;&amp; (!TREE_PUBLIC (TYPE_MAIN_DECL (ctype))</span>
<span class="lineNum">    8927 </span><span class="lineCov">   18360692 :                 || decl_function_context (TYPE_MAIN_DECL (ctype))))</span>
<span class="lineNum">    8928 </span>            :     publicp = 0;
<span class="lineNum">    8929 </span>            : 
<span class="lineNum">    8930 </span><span class="lineCov">   10152392 :   if (publicp &amp;&amp; cxx_dialect == cxx98)</span>
<span class="lineNum">    8931 </span>            :     {
<span class="lineNum">    8932 </span>            :       /* [basic.link]: A name with no linkage (notably, the name of a class
<span class="lineNum">    8933 </span>            :          or enumeration declared in a local scope) shall not be used to
<span class="lineNum">    8934 </span>            :          declare an entity with linkage.
<span class="lineNum">    8935 </span>            : 
<span class="lineNum">    8936 </span>            :          DR 757 relaxes this restriction for C++0x.  */
<span class="lineNum">    8937 </span><span class="lineCov">     657603 :       no_linkage_error (decl);</span>
<span class="lineNum">    8938 </span>            :     }
<span class="lineNum">    8939 </span>            : 
<span class="lineNum">    8940 </span><span class="lineCov">   10172297 :   TREE_PUBLIC (decl) = publicp;</span>
<span class="lineNum">    8941 </span><span class="lineCov">   10172297 :   if (! publicp)</span>
<span class="lineNum">    8942 </span>            :     {
<span class="lineNum">    8943 </span><span class="lineCov">     153426 :       DECL_INTERFACE_KNOWN (decl) = 1;</span>
<span class="lineNum">    8944 </span><span class="lineCov">     153426 :       DECL_NOT_REALLY_EXTERN (decl) = 1;</span>
<span class="lineNum">    8945 </span>            :     }
<span class="lineNum">    8946 </span>            : 
<span class="lineNum">    8947 </span>            :   /* If the declaration was declared inline, mark it as such.  */
<span class="lineNum">    8948 </span><span class="lineCov">   10172297 :   if (inlinep)</span>
<span class="lineNum">    8949 </span>            :     {
<span class="lineNum">    8950 </span><span class="lineCov">    2785606 :       DECL_DECLARED_INLINE_P (decl) = 1;</span>
<span class="lineNum">    8951 </span><span class="lineCov">    2785606 :       if (publicp)</span>
<span class="lineNum">    8952 </span><span class="lineCov">    2704599 :         DECL_COMDAT (decl) = 1;</span>
<span class="lineNum">    8953 </span>            :     }
<span class="lineNum">    8954 </span><span class="lineCov">   10172297 :   if (inlinep &amp; 2)</span>
<span class="lineNum">    8955 </span><span class="lineCov">    1840840 :     DECL_DECLARED_CONSTEXPR_P (decl) = true;</span>
<span class="lineNum">    8956 </span>            : 
<span class="lineNum">    8957 </span>            :   // If the concept declaration specifier was found, check
<span class="lineNum">    8958 </span>            :   // that the declaration satisfies the necessary requirements.
<span class="lineNum">    8959 </span><span class="lineCov">   10172297 :   if (concept_p)</span>
<span class="lineNum">    8960 </span>            :     {
<span class="lineNum">    8961 </span><span class="lineCov">        203 :       DECL_DECLARED_CONCEPT_P (decl) = true;</span>
<span class="lineNum">    8962 </span><span class="lineCov">        203 :       check_concept_fn (decl);</span>
<span class="lineNum">    8963 </span>            :     }
<span class="lineNum">    8964 </span>            : 
<span class="lineNum">    8965 </span><span class="lineCov">   10172297 :   DECL_EXTERNAL (decl) = 1;</span>
<span class="lineNum">    8966 </span><span class="lineCov">   10172297 :   if (TREE_CODE (type) == FUNCTION_TYPE)</span>
<span class="lineNum">    8967 </span>            :     {
<span class="lineNum">    8968 </span><span class="lineCov">    6369344 :       if (quals || rqual)</span>
<span class="lineNum">    8969 </span><span class="lineCov">         26 :         TREE_TYPE (decl) = apply_memfn_quals (TREE_TYPE (decl),</span>
<span class="lineNum">    8970 </span>            :                                               TYPE_UNQUALIFIED,
<span class="lineNum">    8971 </span>            :                                               REF_QUAL_NONE);
<span class="lineNum">    8972 </span>            : 
<span class="lineNum">    8973 </span><span class="lineCov">    6369344 :       if (quals)</span>
<span class="lineNum">    8974 </span>            :         {
<span class="lineNum">    8975 </span><span class="lineCov">         24 :           error (ctype</span>
<span class="lineNum">    8976 </span>            :                  ? G_(&quot;static member function %qD cannot have cv-qualifier&quot;)
<span class="lineNum">    8977 </span>            :                  : G_(&quot;non-member function %qD cannot have cv-qualifier&quot;),
<span class="lineNum">    8978 </span>            :                  decl);
<span class="lineNum">    8979 </span><span class="lineCov">         24 :           quals = TYPE_UNQUALIFIED;</span>
<span class="lineNum">    8980 </span>            :         }
<span class="lineNum">    8981 </span>            : 
<span class="lineNum">    8982 </span><span class="lineCov">    6369344 :       if (rqual)</span>
<span class="lineNum">    8983 </span>            :         {
<span class="lineNum">    8984 </span><span class="lineCov">          2 :           error (ctype</span>
<span class="lineNum">    8985 </span>            :                  ? G_(&quot;static member function %qD cannot have ref-qualifier&quot;)
<span class="lineNum">    8986 </span>            :                  : G_(&quot;non-member function %qD cannot have ref-qualifier&quot;),
<span class="lineNum">    8987 </span>            :                  decl);
<span class="lineNum">    8988 </span><span class="lineCov">          2 :           rqual = REF_QUAL_NONE;</span>
<span class="lineNum">    8989 </span>            :         }
<span class="lineNum">    8990 </span>            :     }
<span class="lineNum">    8991 </span>            : 
<span class="lineNum">    8992 </span><span class="lineCov">   10172297 :   if (deduction_guide_p (decl))</span>
<span class="lineNum">    8993 </span>            :     {
<span class="lineNum">    8994 </span><span class="lineCov">       6601 :       if (!DECL_NAMESPACE_SCOPE_P (decl))</span>
<span class="lineNum">    8995 </span>            :         {
<span class="lineNum">    8996 </span><span class="lineNoCov">          0 :           error_at (location, &quot;deduction guide %qD must be declared at &quot;</span>
<span class="lineNum">    8997 </span>            :                     &quot;namespace scope&quot;, decl);
<span class="lineNum">    8998 </span><span class="lineNoCov">          0 :           return NULL_TREE;</span>
<span class="lineNum">    8999 </span>            :         }
<span class="lineNum">    9000 </span><span class="lineCov">       6601 :       if (funcdef_flag)</span>
<span class="lineNum">    9001 </span><span class="lineCov">          1 :         error_at (location,</span>
<span class="lineNum">    9002 </span>            :                   &quot;deduction guide %qD must not have a function body&quot;, decl);
<span class="lineNum">    9003 </span>            :     }
<span class="lineNum">    9004 </span><span class="lineCov">   10165696 :   else if (IDENTIFIER_ANY_OP_P (DECL_NAME (decl))</span>
<span class="lineNum">    9005 </span><span class="lineCov">   10165696 :            &amp;&amp; !grok_op_properties (decl, /*complain=*/true))</span>
<span class="lineNum">    9006 </span>            :     return NULL_TREE;
<span class="lineNum">    9007 </span><span class="lineCov">   10165564 :   else if (UDLIT_OPER_P (DECL_NAME (decl)))</span>
<span class="lineNum">    9008 </span>            :     {
<span class="lineNum">    9009 </span><span class="lineCov">      12978 :       bool long_long_unsigned_p;</span>
<span class="lineNum">    9010 </span><span class="lineCov">      12978 :       bool long_double_p;</span>
<span class="lineNum">    9011 </span><span class="lineCov">      12978 :       const char *suffix = NULL;</span>
<span class="lineNum">    9012 </span>            :       /* [over.literal]/6: Literal operators shall not have C linkage. */
<span class="lineNum">    9013 </span><span class="lineCov">      12978 :       if (DECL_LANGUAGE (decl) == lang_c)</span>
<span class="lineNum">    9014 </span>            :         {
<span class="lineNum">    9015 </span><span class="lineCov">          4 :           error_at (location, &quot;literal operator with C linkage&quot;);</span>
<span class="lineNum">    9016 </span><span class="lineCov">          4 :           maybe_show_extern_c_location ();</span>
<span class="lineNum">    9017 </span><span class="lineCov">         35 :           return NULL_TREE;</span>
<span class="lineNum">    9018 </span>            :         }
<span class="lineNum">    9019 </span>            : 
<span class="lineNum">    9020 </span><span class="lineCov">      25948 :       if (DECL_NAMESPACE_SCOPE_P (decl))</span>
<span class="lineNum">    9021 </span>            :         {
<span class="lineNum">    9022 </span><span class="lineCov">      12970 :           if (!check_literal_operator_args (decl, &amp;long_long_unsigned_p,</span>
<span class="lineNum">    9023 </span>            :                                             &amp;long_double_p))
<span class="lineNum">    9024 </span>            :             {
<span class="lineNum">    9025 </span><span class="lineCov">         27 :               error_at (location, &quot;%qD has invalid argument list&quot;, decl);</span>
<span class="lineNum">    9026 </span><span class="lineCov">         27 :               return NULL_TREE;</span>
<span class="lineNum">    9027 </span>            :             }
<span class="lineNum">    9028 </span>            : 
<span class="lineNum">    9029 </span><span class="lineCov">      12943 :           suffix = UDLIT_OP_SUFFIX (DECL_NAME (decl));</span>
<span class="lineNum">    9030 </span><span class="lineCov">      12943 :           if (long_long_unsigned_p)</span>
<span class="lineNum">    9031 </span>            :             {
<span class="lineNum">    9032 </span><span class="lineCov">        251 :               if (cpp_interpret_int_suffix (parse_in, suffix, strlen (suffix)))</span>
<span class="lineNum">    9033 </span><span class="lineCov">         22 :                 warning_at (location, 0, &quot;integer suffix %qs&quot;</span>
<span class="lineNum">    9034 </span>            :                             &quot; shadowed by implementation&quot;, suffix);
<span class="lineNum">    9035 </span>            :             }
<span class="lineNum">    9036 </span><span class="lineCov">      12692 :           else if (long_double_p)</span>
<span class="lineNum">    9037 </span>            :             {
<span class="lineNum">    9038 </span><span class="lineCov">       2892 :               if (cpp_interpret_float_suffix (parse_in, suffix, strlen (suffix)))</span>
<span class="lineNum">    9039 </span><span class="lineCov">         54 :                 warning_at (location, 0, &quot;floating point suffix %qs&quot;</span>
<span class="lineNum">    9040 </span>            :                             &quot; shadowed by implementation&quot;, suffix);
<span class="lineNum">    9041 </span>            :             }
<span class="lineNum">    9042 </span>            :           /* 17.6.3.3.5  */
<span class="lineNum">    9043 </span><span class="lineCov">      12943 :           if (suffix[0] != '_'</span>
<span class="lineNum">    9044 </span><span class="lineCov">      12687 :               &amp;&amp; !in_system_header_at (location)</span>
<span class="lineNum">    9045 </span><span class="lineCov">      13098 :               &amp;&amp; !current_function_decl &amp;&amp; !(friendp &amp;&amp; !funcdef_flag))</span>
<span class="lineNum">    9046 </span><span class="lineCov">        153 :             warning_at (location, OPT_Wliteral_suffix,</span>
<span class="lineNum">    9047 </span>            :                         &quot;literal operator suffixes not preceded by %&lt;_%&gt;&quot;
<span class="lineNum">    9048 </span>            :                         &quot; are reserved for future standardization&quot;);
<span class="lineNum">    9049 </span>            :         }
<span class="lineNum">    9050 </span>            :       else
<span class="lineNum">    9051 </span>            :         {
<span class="lineNum">    9052 </span><span class="lineCov">          4 :           error_at (location, &quot;%qD must be a non-member function&quot;, decl);</span>
<span class="lineNum">    9053 </span><span class="lineCov">          4 :           return NULL_TREE;</span>
<span class="lineNum">    9054 </span>            :         }
<span class="lineNum">    9055 </span>            :     }
<span class="lineNum">    9056 </span>            : 
<span class="lineNum">    9057 </span><span class="lineCov">   10172130 :   if (funcdef_flag)</span>
<span class="lineNum">    9058 </span>            :     /* Make the init_value nonzero so pushdecl knows this is not
<span class="lineNum">    9059 </span>            :        tentative.  error_mark_node is replaced later with the BLOCK.  */
<span class="lineNum">    9060 </span><span class="lineCov">    5685162 :     DECL_INITIAL (decl) = error_mark_node;</span>
<span class="lineNum">    9061 </span>            : 
<span class="lineNum">    9062 </span><span class="lineCov">   13975034 :   if (TYPE_NOTHROW_P (type) || nothrow_libfn_p (decl))</span>
<span class="lineNum">    9063 </span><span class="lineCov">    3807991 :     TREE_NOTHROW (decl) = 1;</span>
<span class="lineNum">    9064 </span>            : 
<span class="lineNum">    9065 </span><span class="lineCov">   10172130 :   if (flag_openmp || flag_openmp_simd)</span>
<span class="lineNum">    9066 </span>            :     {
<span class="lineNum">    9067 </span>            :       /* Adjust &quot;omp declare simd&quot; attributes.  */
<span class="lineNum">    9068 </span><span class="lineCov">      42497 :       tree ods = lookup_attribute (&quot;omp declare simd&quot;, *attrlist);</span>
<span class="lineNum">    9069 </span><span class="lineCov">      42497 :       if (ods)</span>
<span class="lineNum">    9070 </span>            :         {
<span class="lineNum">    9071 </span>            :           tree attr;
<span class="lineNum">    9072 </span><span class="lineCov">       1039 :           for (attr = ods; attr;</span>
<span class="lineNum">    9073 </span><span class="lineCov">        533 :                attr = lookup_attribute (&quot;omp declare simd&quot;, TREE_CHAIN (attr)))</span>
<span class="lineNum">    9074 </span>            :             {
<span class="lineNum">    9075 </span><span class="lineCov">        533 :               if (TREE_CODE (type) == METHOD_TYPE)</span>
<span class="lineNum">    9076 </span><span class="lineCov">        189 :                 walk_tree (&amp;TREE_VALUE (attr), declare_simd_adjust_this,</span>
<span class="lineNum">    9077 </span>            :                            DECL_ARGUMENTS (decl), NULL);
<span class="lineNum">    9078 </span><span class="lineCov">        533 :               if (TREE_VALUE (attr) != NULL_TREE)</span>
<span class="lineNum">    9079 </span>            :                 {
<span class="lineNum">    9080 </span><span class="lineCov">        892 :                   tree cl = TREE_VALUE (TREE_VALUE (attr));</span>
<span class="lineNum">    9081 </span><span class="lineCov">        446 :                   cl = c_omp_declare_simd_clauses_to_numbers</span>
<span class="lineNum">    9082 </span><span class="lineCov">        446 :                                                 (DECL_ARGUMENTS (decl), cl);</span>
<span class="lineNum">    9083 </span><span class="lineCov">        446 :                   if (cl)</span>
<span class="lineNum">    9084 </span><span class="lineCov">        440 :                     TREE_VALUE (TREE_VALUE (attr)) = cl;</span>
<span class="lineNum">    9085 </span>            :                   else
<span class="lineNum">    9086 </span><span class="lineCov">          6 :                     TREE_VALUE (attr) = NULL_TREE;</span>
<span class="lineNum">    9087 </span>            :                 }
<span class="lineNum">    9088 </span>            :             }
<span class="lineNum">    9089 </span>            :         }
<span class="lineNum">    9090 </span>            :     }
<span class="lineNum">    9091 </span>            : 
<span class="lineNum">    9092 </span>            :   /* Caller will do the rest of this.  */
<span class="lineNum">    9093 </span><span class="lineCov">   10172130 :   if (check &lt; 0)</span>
<span class="lineNum">    9094 </span><span class="lineCov">      66694 :     return decl;</span>
<span class="lineNum">    9095 </span>            : 
<span class="lineNum">    9096 </span><span class="lineCov">   10105436 :   if (ctype != NULL_TREE)</span>
<span class="lineNum">    9097 </span><span class="lineCov">    4595293 :     grokclassfn (ctype, decl, flags);</span>
<span class="lineNum">    9098 </span>            : 
<span class="lineNum">    9099 </span>            :   /* 12.4/3  */
<span class="lineNum">    9100 </span><span class="lineCov">   10105436 :   if (cxx_dialect &gt;= cxx11</span>
<span class="lineNum">    9101 </span><span class="lineCov">    9435134 :       &amp;&amp; DECL_DESTRUCTOR_P (decl)</span>
<span class="lineNum">    9102 </span><span class="lineCov">     156405 :       &amp;&amp; !TYPE_BEING_DEFINED (DECL_CONTEXT (decl))</span>
<span class="lineNum">    9103 </span><span class="lineCov">   10113296 :       &amp;&amp; !processing_template_decl)</span>
<span class="lineNum">    9104 </span><span class="lineCov">       3625 :     deduce_noexcept_on_destructor (decl);</span>
<span class="lineNum">    9105 </span>            : 
<span class="lineNum">    9106 </span><span class="lineCov">   30316308 :   decl = check_explicit_specialization (orig_declarator, decl,</span>
<span class="lineNum">    9107 </span>            :                                         template_count,
<span class="lineNum">    9108 </span><span class="lineCov">   20210872 :                                         2 * funcdef_flag +</span>
<span class="lineNum">    9109 </span><span class="lineCov">   10105436 :                                         4 * (friendp != 0) +</span>
<span class="lineNum">    9110 </span><span class="lineCov">   10105436 :                                         8 * concept_p,</span>
<span class="lineNum">    9111 </span>            :                                         *attrlist);
<span class="lineNum">    9112 </span><span class="lineCov">   10105436 :   if (decl == error_mark_node)</span>
<span class="lineNum">    9113 </span>            :     return NULL_TREE;
<span class="lineNum">    9114 </span>            : 
<span class="lineNum">    9115 </span><span class="lineCov">   10105234 :   if (DECL_STATIC_FUNCTION_P (decl))</span>
<span class="lineNum">    9116 </span><span class="lineCov">     793320 :     check_static_quals (decl, quals);</span>
<span class="lineNum">    9117 </span>            : 
<span class="lineNum">    9118 </span><span class="lineCov">   10105234 :   if (attrlist)</span>
<span class="lineNum">    9119 </span>            :     {
<span class="lineNum">    9120 </span><span class="lineCov">   10105234 :       cplus_decl_attributes (&amp;decl, *attrlist, 0);</span>
<span class="lineNum">    9121 </span><span class="lineCov">   10105234 :       *attrlist = NULL_TREE;</span>
<span class="lineNum">    9122 </span>            :     }
<span class="lineNum">    9123 </span>            : 
<span class="lineNum">    9124 </span>            :   /* Check main's type after attributes have been applied.  */
<span class="lineNum">    9125 </span><span class="lineCov">   10105234 :   if (ctype == NULL_TREE &amp;&amp; DECL_MAIN_P (decl))</span>
<span class="lineNum">    9126 </span>            :     {
<span class="lineNum">    9127 </span><span class="lineCov">      21779 :       if (!same_type_p (TREE_TYPE (TREE_TYPE (decl)),</span>
<span class="lineNum">    9128 </span>            :                         integer_type_node))
<span class="lineNum">    9129 </span>            :         {
<span class="lineNum">    9130 </span><span class="lineCov">         18 :           tree oldtypeargs = TYPE_ARG_TYPES (TREE_TYPE (decl));</span>
<span class="lineNum">    9131 </span><span class="lineCov">         18 :           tree newtype;</span>
<span class="lineNum">    9132 </span><span class="lineCov">         18 :           error_at (declspecs-&gt;locations[ds_type_spec],</span>
<span class="lineNum">    9133 </span>            :                     &quot;%&lt;::main%&gt; must return %&lt;int%&gt;&quot;);
<span class="lineNum">    9134 </span><span class="lineCov">         18 :           newtype = build_function_type (integer_type_node, oldtypeargs);</span>
<span class="lineNum">    9135 </span><span class="lineCov">         18 :           TREE_TYPE (decl) = newtype;</span>
<span class="lineNum">    9136 </span>            :         }
<span class="lineNum">    9137 </span><span class="lineCov">      21779 :       if (warn_main)</span>
<span class="lineNum">    9138 </span><span class="lineCov">      21768 :         check_main_parameter_types (decl);</span>
<span class="lineNum">    9139 </span>            :     }
<span class="lineNum">    9140 </span>            : 
<span class="lineNum">    9141 </span><span class="lineCov">   10105234 :   if (ctype != NULL_TREE &amp;&amp; check)</span>
<span class="lineNum">    9142 </span>            :     {
<span class="lineNum">    9143 </span><span class="lineCov">     458942 :       tree old_decl = check_classfn (ctype, decl,</span>
<span class="lineNum">    9144 </span><span class="lineCov">     409907 :                                      (processing_template_decl</span>
<span class="lineNum">    9145 </span><span class="lineCov">     409907 :                                       &gt; template_class_depth (ctype))</span>
<span class="lineNum">    9146 </span><span class="lineCov">      49035 :                                      ? current_template_parms</span>
<span class="lineNum">    9147 </span><span class="lineCov">     409907 :                                      : NULL_TREE);</span>
<span class="lineNum">    9148 </span>            : 
<span class="lineNum">    9149 </span><span class="lineCov">     409907 :       if (old_decl == error_mark_node)</span>
<span class="lineNum">    9150 </span>            :         return NULL_TREE;
<span class="lineNum">    9151 </span>            : 
<span class="lineNum">    9152 </span><span class="lineCov">     409841 :       if (old_decl)</span>
<span class="lineNum">    9153 </span>            :         {
<span class="lineNum">    9154 </span><span class="lineCov">     380624 :           tree ok;</span>
<span class="lineNum">    9155 </span><span class="lineCov">     380624 :           tree pushed_scope;</span>
<span class="lineNum">    9156 </span>            : 
<span class="lineNum">    9157 </span><span class="lineCov">     380624 :           if (TREE_CODE (old_decl) == TEMPLATE_DECL)</span>
<span class="lineNum">    9158 </span>            :             /* Because grokfndecl is always supposed to return a
<span class="lineNum">    9159 </span>            :                FUNCTION_DECL, we pull out the DECL_TEMPLATE_RESULT
<span class="lineNum">    9160 </span>            :                here.  We depend on our callers to figure out that its
<span class="lineNum">    9161 </span>            :                really a template that's being returned.  */
<span class="lineNum">    9162 </span><span class="lineCov">      98040 :             old_decl = DECL_TEMPLATE_RESULT (old_decl);</span>
<span class="lineNum">    9163 </span>            : 
<span class="lineNum">    9164 </span><span class="lineCov">     380624 :           if (DECL_STATIC_FUNCTION_P (old_decl)</span>
<span class="lineNum">    9165 </span><span class="lineCov">     380624 :               &amp;&amp; TREE_CODE (TREE_TYPE (decl)) == METHOD_TYPE)</span>
<span class="lineNum">    9166 </span>            :             {
<span class="lineNum">    9167 </span>            :               /* Remove the `this' parm added by grokclassfn.  */
<span class="lineNum">    9168 </span><span class="lineCov">      19794 :               revert_static_member_fn (decl);</span>
<span class="lineNum">    9169 </span><span class="lineCov">      19794 :               check_static_quals (decl, quals);</span>
<span class="lineNum">    9170 </span>            :             }
<span class="lineNum">    9171 </span><span class="lineCov">     380624 :           if (DECL_ARTIFICIAL (old_decl))</span>
<span class="lineNum">    9172 </span>            :             {
<span class="lineNum">    9173 </span><span class="lineCov">          9 :               error (&quot;definition of implicitly-declared %qD&quot;, old_decl);</span>
<span class="lineNum">    9174 </span><span class="lineCov">          9 :               return NULL_TREE;</span>
<span class="lineNum">    9175 </span>            :             }
<span class="lineNum">    9176 </span><span class="lineCov">     380615 :           else if (DECL_DEFAULTED_FN (old_decl))</span>
<span class="lineNum">    9177 </span>            :             {
<span class="lineNum">    9178 </span><span class="lineCov">          2 :               error (&quot;definition of explicitly-defaulted %q+D&quot;, decl);</span>
<span class="lineNum">    9179 </span><span class="lineCov">          2 :               inform (DECL_SOURCE_LOCATION (old_decl),</span>
<span class="lineNum">    9180 </span>            :                       &quot;%q#D explicitly defaulted here&quot;, old_decl);
<span class="lineNum">    9181 </span><span class="lineCov">          2 :               return NULL_TREE;</span>
<span class="lineNum">    9182 </span>            :             }
<span class="lineNum">    9183 </span>            : 
<span class="lineNum">    9184 </span>            :           /* Since we've smashed OLD_DECL to its
<span class="lineNum">    9185 </span>            :              DECL_TEMPLATE_RESULT, we must do the same to DECL.  */
<span class="lineNum">    9186 </span><span class="lineCov">     380613 :           if (TREE_CODE (decl) == TEMPLATE_DECL)</span>
<span class="lineNum">    9187 </span><span class="lineCov">       1408 :             decl = DECL_TEMPLATE_RESULT (decl);</span>
<span class="lineNum">    9188 </span>            : 
<span class="lineNum">    9189 </span>            :           /* Attempt to merge the declarations.  This can fail, in
<span class="lineNum">    9190 </span>            :              the case of some invalid specialization declarations.  */
<span class="lineNum">    9191 </span><span class="lineCov">     380613 :           pushed_scope = push_scope (ctype);</span>
<span class="lineNum">    9192 </span><span class="lineCov">     380613 :           ok = duplicate_decls (decl, old_decl, friendp);</span>
<span class="lineNum">    9193 </span><span class="lineCov">     380613 :           if (pushed_scope)</span>
<span class="lineNum">    9194 </span><span class="lineCov">     380613 :             pop_scope (pushed_scope);</span>
<span class="lineNum">    9195 </span><span class="lineCov">     380613 :           if (!ok)</span>
<span class="lineNum">    9196 </span>            :             {
<span class="lineNum">    9197 </span><span class="lineNoCov">          0 :               error (&quot;no %q#D member function declared in class %qT&quot;,</span>
<span class="lineNum">    9198 </span>            :                      decl, ctype);
<span class="lineNum">    9199 </span><span class="lineNoCov">          0 :               return NULL_TREE;</span>
<span class="lineNum">    9200 </span>            :             }
<span class="lineNum">    9201 </span><span class="lineCov">     380613 :           if (ok == error_mark_node)</span>
<span class="lineNum">    9202 </span>            :             return NULL_TREE;
<span class="lineNum">    9203 </span><span class="lineCov">     380594 :           return old_decl;</span>
<span class="lineNum">    9204 </span>            :         }
<span class="lineNum">    9205 </span>            :     }
<span class="lineNum">    9206 </span>            : 
<span class="lineNum">    9207 </span><span class="lineCov">    9724544 :   if (DECL_CONSTRUCTOR_P (decl) &amp;&amp; !grok_ctor_properties (ctype, decl))</span>
<span class="lineNum">    9208 </span>            :     return NULL_TREE;
<span class="lineNum">    9209 </span>            : 
<span class="lineNum">    9210 </span><span class="lineCov">    9724541 :   if (ctype == NULL_TREE || check)</span>
<span class="lineNum">    9211 </span><span class="lineCov">    5539205 :     return decl;</span>
<span class="lineNum">    9212 </span>            : 
<span class="lineNum">    9213 </span><span class="lineCov">    4185336 :   if (virtualp)</span>
<span class="lineNum">    9214 </span><span class="lineCov">     265695 :     DECL_VIRTUAL_P (decl) = 1;</span>
<span class="lineNum">    9215 </span>            : 
<span class="lineNum">    9216 </span><span class="lineCov">    4185336 :   return decl;</span>
<span class="lineNum">    9217 </span>            : }
<span class="lineNum">    9218 </span>            : 
<span class="lineNum">    9219 </span>            : /* decl is a FUNCTION_DECL.
<span class="lineNum">    9220 </span>            :    specifiers are the parsed virt-specifiers.
<span class="lineNum">    9221 </span>            : 
<span class="lineNum">    9222 </span>            :    Set flags to reflect the virt-specifiers.
<span class="lineNum">    9223 </span>            : 
<span class="lineNum">    9224 </span>            :    Returns decl.  */
<a name="9225"><span class="lineNum">    9225 </span>            : </a>
<span class="lineNum">    9226 </span>            : static tree
<span class="lineNum">    9227 </span><span class="lineCov">    4252110 : set_virt_specifiers (tree decl, cp_virt_specifiers specifiers)</span>
<span class="lineNum">    9228 </span>            : {
<span class="lineNum">    9229 </span><span class="lineCov">    4252110 :   if (decl == NULL_TREE)</span>
<span class="lineNum">    9230 </span>            :     return decl;
<span class="lineNum">    9231 </span><span class="lineCov">    4252030 :   if (specifiers &amp; VIRT_SPEC_OVERRIDE)</span>
<span class="lineNum">    9232 </span><span class="lineCov">       2730 :     DECL_OVERRIDE_P (decl) = 1;</span>
<span class="lineNum">    9233 </span><span class="lineCov">    4252030 :   if (specifiers &amp; VIRT_SPEC_FINAL)</span>
<span class="lineNum">    9234 </span><span class="lineCov">        171 :     DECL_FINAL_P (decl) = 1;</span>
<span class="lineNum">    9235 </span>            :   return decl;
<span class="lineNum">    9236 </span>            : }
<span class="lineNum">    9237 </span>            : 
<span class="lineNum">    9238 </span>            : /* DECL is a VAR_DECL for a static data member.  Set flags to reflect
<span class="lineNum">    9239 </span>            :    the linkage that DECL will receive in the object file.  */
<a name="9240"><span class="lineNum">    9240 </span>            : </a>
<span class="lineNum">    9241 </span>            : static void
<span class="lineNum">    9242 </span><span class="lineCov">     819003 : set_linkage_for_static_data_member (tree decl)</span>
<span class="lineNum">    9243 </span>            : {
<span class="lineNum">    9244 </span>            :   /* A static data member always has static storage duration and
<span class="lineNum">    9245 </span>            :      external linkage.  Note that static data members are forbidden in
<span class="lineNum">    9246 </span>            :      local classes -- the only situation in which a class has
<span class="lineNum">    9247 </span>            :      non-external linkage.  */
<span class="lineNum">    9248 </span><span class="lineCov">     819003 :   TREE_PUBLIC (decl) = 1;</span>
<span class="lineNum">    9249 </span><span class="lineCov">     819003 :   TREE_STATIC (decl) = 1;</span>
<span class="lineNum">    9250 </span>            :   /* For non-template classes, static data members are always put
<span class="lineNum">    9251 </span>            :      out in exactly those files where they are defined, just as
<span class="lineNum">    9252 </span>            :      with ordinary namespace-scope variables.  */
<span class="lineNum">    9253 </span><span class="lineCov">     819003 :   if (!processing_template_decl)</span>
<span class="lineNum">    9254 </span><span class="lineCov">     639357 :     DECL_INTERFACE_KNOWN (decl) = 1;</span>
<span class="lineNum">    9255 </span><span class="lineCov">     819003 : }</span>
<span class="lineNum">    9256 </span>            : 
<span class="lineNum">    9257 </span>            : /* Create a VAR_DECL named NAME with the indicated TYPE.
<span class="lineNum">    9258 </span>            : 
<span class="lineNum">    9259 </span>            :    If SCOPE is non-NULL, it is the class type or namespace containing
<span class="lineNum">    9260 </span>            :    the variable.  If SCOPE is NULL, the variable should is created in
<span class="lineNum">    9261 </span>            :    the innermost enclosing scope.  */
<a name="9262"><span class="lineNum">    9262 </span>            : </a>
<span class="lineNum">    9263 </span>            : static tree
<span class="lineNum">    9264 </span><span class="lineCov">    2591471 : grokvardecl (tree type,</span>
<span class="lineNum">    9265 </span>            :              tree name,
<span class="lineNum">    9266 </span>            :              tree orig_declarator,
<span class="lineNum">    9267 </span>            :              const cp_decl_specifier_seq *declspecs,
<span class="lineNum">    9268 </span>            :              int initialized,
<span class="lineNum">    9269 </span>            :              int type_quals,
<span class="lineNum">    9270 </span>            :              int inlinep,
<span class="lineNum">    9271 </span>            :              bool conceptp,
<span class="lineNum">    9272 </span>            :              int template_count,
<span class="lineNum">    9273 </span>            :              tree scope)
<span class="lineNum">    9274 </span>            : {
<span class="lineNum">    9275 </span><span class="lineCov">    2591471 :   tree decl;</span>
<span class="lineNum">    9276 </span><span class="lineCov">    2591471 :   tree explicit_scope;</span>
<span class="lineNum">    9277 </span>            : 
<span class="lineNum">    9278 </span><span class="lineCov">    2591471 :   gcc_assert (!name || identifier_p (name));</span>
<span class="lineNum">    9279 </span>            : 
<span class="lineNum">    9280 </span><span class="lineCov">    2591471 :   bool constp = (type_quals &amp; TYPE_QUAL_CONST) != 0;</span>
<span class="lineNum">    9281 </span><span class="lineCov">    2591471 :   bool volatilep = (type_quals &amp; TYPE_QUAL_VOLATILE) != 0;</span>
<span class="lineNum">    9282 </span>            : 
<span class="lineNum">    9283 </span>            :   /* Compute the scope in which to place the variable, but remember
<span class="lineNum">    9284 </span>            :      whether or not that scope was explicitly specified by the user.   */
<span class="lineNum">    9285 </span><span class="lineCov">    2591471 :   explicit_scope = scope;</span>
<span class="lineNum">    9286 </span><span class="lineCov">    2591471 :   if (!scope)</span>
<span class="lineNum">    9287 </span>            :     {
<span class="lineNum">    9288 </span>            :       /* An explicit &quot;extern&quot; specifier indicates a namespace-scope
<span class="lineNum">    9289 </span>            :          variable.  */
<span class="lineNum">    9290 </span><span class="lineCov">    2534721 :       if (declspecs-&gt;storage_class == sc_extern)</span>
<span class="lineNum">    9291 </span><span class="lineCov">     236212 :         scope = current_decl_namespace ();</span>
<span class="lineNum">    9292 </span><span class="lineCov">    2298509 :       else if (!at_function_scope_p ())</span>
<span class="lineNum">    9293 </span><span class="lineCov">     174071 :         scope = current_scope ();</span>
<span class="lineNum">    9294 </span>            :     }
<span class="lineNum">    9295 </span>            : 
<span class="lineNum">    9296 </span><span class="lineCov">    2591471 :   if (scope</span>
<span class="lineNum">    9297 </span><span class="lineCov">     467033 :       &amp;&amp; (/* If the variable is a namespace-scope variable declared in a</span>
<span class="lineNum">    9298 </span>            :              template, we need DECL_LANG_SPECIFIC.  */
<span class="lineNum">    9299 </span><span class="lineCov">     467033 :           (TREE_CODE (scope) == NAMESPACE_DECL &amp;&amp; processing_template_decl)</span>
<span class="lineNum">    9300 </span>            :           /* Similarly for namespace-scope variables with language linkage
<span class="lineNum">    9301 </span>            :              other than C++.  */
<span class="lineNum">    9302 </span><span class="lineCov">     410338 :           || (TREE_CODE (scope) == NAMESPACE_DECL</span>
<span class="lineNum">    9303 </span><span class="lineCov">     348637 :               &amp;&amp; current_lang_name != lang_name_cplusplus)</span>
<span class="lineNum">    9304 </span>            :           /* Similarly for static data members.  */
<span class="lineNum">    9305 </span><span class="lineCov">     335324 :           || TYPE_P (scope)</span>
<span class="lineNum">    9306 </span>            :           /* Similarly for explicit specializations.  */
<span class="lineNum">    9307 </span><span class="lineCov">     278629 :           || (orig_declarator</span>
<span class="lineNum">    9308 </span><span class="lineCov">     278527 :               &amp;&amp; TREE_CODE (orig_declarator) == TEMPLATE_ID_EXPR)))</span>
<span class="lineNum">    9309 </span><span class="lineCov">     188418 :     decl = build_lang_decl (VAR_DECL, name, type);</span>
<span class="lineNum">    9310 </span>            :   else
<span class="lineNum">    9311 </span><span class="lineCov">    2403053 :     decl = build_decl (input_location, VAR_DECL, name, type);</span>
<span class="lineNum">    9312 </span>            : 
<span class="lineNum">    9313 </span><span class="lineCov">    2591471 :   if (explicit_scope &amp;&amp; TREE_CODE (explicit_scope) == NAMESPACE_DECL)</span>
<span class="lineNum">    9314 </span><span class="lineCov">         55 :     set_decl_namespace (decl, explicit_scope, 0);</span>
<span class="lineNum">    9315 </span>            :   else
<span class="lineNum">    9316 </span><span class="lineCov">    2591416 :     DECL_CONTEXT (decl) = FROB_CONTEXT (scope);</span>
<span class="lineNum">    9317 </span>            : 
<span class="lineNum">    9318 </span><span class="lineCov">    2591471 :   if (declspecs-&gt;storage_class == sc_extern)</span>
<span class="lineNum">    9319 </span>            :     {
<span class="lineNum">    9320 </span><span class="lineCov">     236212 :       DECL_THIS_EXTERN (decl) = 1;</span>
<span class="lineNum">    9321 </span><span class="lineCov">     236212 :       DECL_EXTERNAL (decl) = !initialized;</span>
<span class="lineNum">    9322 </span>            :     }
<span class="lineNum">    9323 </span>            : 
<span class="lineNum">    9324 </span><span class="lineCov">    2591471 :   if (DECL_CLASS_SCOPE_P (decl))</span>
<span class="lineNum">    9325 </span>            :     {
<span class="lineNum">    9326 </span><span class="lineCov">      56695 :       set_linkage_for_static_data_member (decl);</span>
<span class="lineNum">    9327 </span>            :       /* This function is only called with out-of-class definitions.  */
<span class="lineNum">    9328 </span><span class="lineCov">      56695 :       DECL_EXTERNAL (decl) = 0;</span>
<span class="lineNum">    9329 </span><span class="lineCov">      56695 :       check_class_member_definition_namespace (decl);</span>
<span class="lineNum">    9330 </span>            :     }
<span class="lineNum">    9331 </span>            :   /* At top level, either `static' or no s.c. makes a definition
<span class="lineNum">    9332 </span>            :      (perhaps tentative), and absence of `static' makes it public.  */
<span class="lineNum">    9333 </span><span class="lineCov">    2534776 :   else if (toplevel_bindings_p ())</span>
<span class="lineNum">    9334 </span>            :     {
<span class="lineNum">    9335 </span><span class="lineCov">     819384 :       TREE_PUBLIC (decl) = (declspecs-&gt;storage_class != sc_static</span>
<span class="lineNum">    9336 </span><span class="lineCov">     409692 :                             &amp;&amp; (DECL_THIS_EXTERN (decl)</span>
<span class="lineNum">    9337 </span><span class="lineCov">     370426 :                                 || ! constp</span>
<span class="lineNum">    9338 </span><span class="lineCov">     134860 :                                 || volatilep</span>
<span class="lineNum">    9339 </span><span class="lineCov">      86700 :                                 || inlinep));</span>
<span class="lineNum">    9340 </span><span class="lineCov">     409692 :       TREE_STATIC (decl) = ! DECL_EXTERNAL (decl);</span>
<span class="lineNum">    9341 </span>            :     }
<span class="lineNum">    9342 </span>            :   /* Not at top level, only `static' makes a static definition.  */
<span class="lineNum">    9343 </span>            :   else
<span class="lineNum">    9344 </span>            :     {
<span class="lineNum">    9345 </span><span class="lineCov">    2125084 :       TREE_STATIC (decl) = declspecs-&gt;storage_class == sc_static;</span>
<span class="lineNum">    9346 </span><span class="lineCov">    2125084 :       TREE_PUBLIC (decl) = DECL_EXTERNAL (decl);</span>
<span class="lineNum">    9347 </span>            :     }
<span class="lineNum">    9348 </span>            : 
<span class="lineNum">    9349 </span><span class="lineCov">    2591471 :   if (decl_spec_seq_has_spec_p (declspecs, ds_thread))</span>
<span class="lineNum">    9350 </span>            :     {
<span class="lineNum">    9351 </span><span class="lineCov">        723 :       if (DECL_EXTERNAL (decl) || TREE_STATIC (decl))</span>
<span class="lineNum">    9352 </span>            :         {
<span class="lineNum">    9353 </span><span class="lineCov">        715 :           CP_DECL_THREAD_LOCAL_P (decl) = true;</span>
<span class="lineNum">    9354 </span><span class="lineCov">        715 :           if (!processing_template_decl)</span>
<span class="lineNum">    9355 </span><span class="lineCov">        700 :             set_decl_tls_model (decl, decl_default_tls_model (decl));</span>
<span class="lineNum">    9356 </span>            :         }
<span class="lineNum">    9357 </span><span class="lineCov">        723 :       if (declspecs-&gt;gnu_thread_keyword_p)</span>
<span class="lineNum">    9358 </span><span class="lineCov">        630 :         SET_DECL_GNU_TLS_P (decl);</span>
<span class="lineNum">    9359 </span>            :     }
<span class="lineNum">    9360 </span>            : 
<span class="lineNum">    9361 </span>            :   /* If the type of the decl has no linkage, make sure that we'll
<span class="lineNum">    9362 </span>            :      notice that in mark_used.  */
<span class="lineNum">    9363 </span><span class="lineCov">    2591471 :   if (cxx_dialect &gt; cxx98</span>
<span class="lineNum">    9364 </span><span class="lineCov">    2418427 :       &amp;&amp; decl_linkage (decl) != lk_none</span>
<span class="lineNum">    9365 </span><span class="lineCov">    2388576 :       &amp;&amp; DECL_LANG_SPECIFIC (decl) == NULL</span>
<span class="lineNum">    9366 </span><span class="lineCov">    4415070 :       &amp;&amp; !DECL_EXTERN_C_P (decl)</span>
<span class="lineNum">    9367 </span><span class="lineCov">    4799006 :       &amp;&amp; no_linkage_check (TREE_TYPE (decl), /*relaxed_p=*/false))</span>
<span class="lineNum">    9368 </span><span class="lineCov">       1257 :     retrofit_lang_decl (decl);</span>
<span class="lineNum">    9369 </span>            : 
<span class="lineNum">    9370 </span><span class="lineCov">    2591471 :   if (TREE_PUBLIC (decl))</span>
<span class="lineNum">    9371 </span>            :     {
<span class="lineNum">    9372 </span>            :       /* [basic.link]: A name with no linkage (notably, the name of a class
<span class="lineNum">    9373 </span>            :          or enumeration declared in a local scope) shall not be used to
<span class="lineNum">    9374 </span>            :          declare an entity with linkage.
<span class="lineNum">    9375 </span>            : 
<span class="lineNum">    9376 </span>            :          DR 757 relaxes this restriction for C++0x.  */
<span class="lineNum">    9377 </span><span class="lineCov">     396649 :       if (cxx_dialect &lt; cxx11)</span>
<span class="lineNum">    9378 </span><span class="lineCov">      15770 :         no_linkage_error (decl);</span>
<span class="lineNum">    9379 </span>            :     }
<span class="lineNum">    9380 </span>            :   else
<span class="lineNum">    9381 </span><span class="lineCov">    2194822 :     DECL_INTERFACE_KNOWN (decl) = 1;</span>
<span class="lineNum">    9382 </span>            : 
<span class="lineNum">    9383 </span><span class="lineCov">    2591471 :   if (DECL_NAME (decl)</span>
<span class="lineNum">    9384 </span><span class="lineCov">    5112348 :       &amp;&amp; MAIN_NAME_P (DECL_NAME (decl))</span>
<span class="lineNum">    9385 </span><span class="lineCov">    2591477 :       &amp;&amp; scope == global_namespace)</span>
<span class="lineNum">    9386 </span><span class="lineCov">          3 :     error (&quot;cannot declare %&lt;::main%&gt; to be a global variable&quot;);</span>
<span class="lineNum">    9387 </span>            : 
<span class="lineNum">    9388 </span>            :   /* Check that the variable can be safely declared as a concept.
<span class="lineNum">    9389 </span>            :      Note that this also forbids explicit specializations.  */
<span class="lineNum">    9390 </span><span class="lineCov">    2591471 :   if (conceptp)</span>
<span class="lineNum">    9391 </span>            :     {
<span class="lineNum">    9392 </span><span class="lineCov">        106 :       if (!processing_template_decl)</span>
<span class="lineNum">    9393 </span>            :         {
<span class="lineNum">    9394 </span><span class="lineCov">          3 :           error_at (declspecs-&gt;locations[ds_concept],</span>
<span class="lineNum">    9395 </span>            :                     &quot;a non-template variable cannot be %&lt;concept%&gt;&quot;);
<span class="lineNum">    9396 </span><span class="lineCov">          3 :           return NULL_TREE;</span>
<span class="lineNum">    9397 </span>            :         }
<span class="lineNum">    9398 </span>            :       else
<span class="lineNum">    9399 </span><span class="lineCov">        103 :         DECL_DECLARED_CONCEPT_P (decl) = true;</span>
<span class="lineNum">    9400 </span><span class="lineCov">        103 :       if (!same_type_ignoring_top_level_qualifiers_p (type, boolean_type_node))</span>
<span class="lineNum">    9401 </span><span class="lineCov">          1 :         error_at (declspecs-&gt;locations[ds_type_spec],</span>
<span class="lineNum">    9402 </span>            :                   &quot;concept must have type %&lt;bool%&gt;&quot;);
<span class="lineNum">    9403 </span>            :     }
<span class="lineNum">    9404 </span><span class="lineCov">    2591365 :   else if (flag_concepts</span>
<span class="lineNum">    9405 </span><span class="lineCov">    2591365 :            &amp;&amp; processing_template_decl &gt; template_class_depth (scope))</span>
<span class="lineNum">    9406 </span>            :     {
<span class="lineNum">    9407 </span><span class="lineCov">       1664 :       tree reqs = TEMPLATE_PARMS_CONSTRAINTS (current_template_parms);</span>
<span class="lineNum">    9408 </span><span class="lineCov">       1664 :       tree ci = build_constraints (reqs, NULL_TREE);</span>
<span class="lineNum">    9409 </span><span class="lineCov">       1664 :       set_constraints (decl, ci);</span>
<span class="lineNum">    9410 </span>            :     }
<span class="lineNum">    9411 </span>            : 
<span class="lineNum">    9412 </span>            :   // Handle explicit specializations and instantiations of variable templates.
<span class="lineNum">    9413 </span><span class="lineCov">    2591468 :   if (orig_declarator)</span>
<span class="lineNum">    9414 </span><span class="lineCov">    2556171 :     decl = check_explicit_specialization (orig_declarator, decl,</span>
<span class="lineNum">    9415 </span>            :                                           template_count, conceptp * 8);
<span class="lineNum">    9416 </span>            : 
<span class="lineNum">    9417 </span><span class="lineCov">    2591468 :   return decl != error_mark_node ? decl : NULL_TREE;</span>
<span class="lineNum">    9418 </span>            : }
<span class="lineNum">    9419 </span>            : 
<span class="lineNum">    9420 </span>            : /* Create and return a canonical pointer to member function type, for
<span class="lineNum">    9421 </span>            :    TYPE, which is a POINTER_TYPE to a METHOD_TYPE.  */
<a name="9422"><span class="lineNum">    9422 </span>            : </a>
<span class="lineNum">    9423 </span>            : tree
<span class="lineNum">    9424 </span><span class="lineCov">     487994 : build_ptrmemfunc_type (tree type)</span>
<span class="lineNum">    9425 </span>            : {
<span class="lineNum">    9426 </span><span class="lineCov">     487994 :   tree field, fields;</span>
<span class="lineNum">    9427 </span><span class="lineCov">     487994 :   tree t;</span>
<span class="lineNum">    9428 </span>            : 
<span class="lineNum">    9429 </span><span class="lineCov">     487994 :   if (type == error_mark_node)</span>
<span class="lineNum">    9430 </span>            :     return type;
<span class="lineNum">    9431 </span>            : 
<span class="lineNum">    9432 </span>            :   /* Make sure that we always have the unqualified pointer-to-member
<span class="lineNum">    9433 </span>            :      type first.  */
<span class="lineNum">    9434 </span><span class="lineCov">     487994 :   if (cp_cv_quals quals = cp_type_quals (type))</span>
<span class="lineNum">    9435 </span>            :     {
<span class="lineNum">    9436 </span><span class="lineCov">        420 :       tree unqual = build_ptrmemfunc_type (TYPE_MAIN_VARIANT (type));</span>
<span class="lineNum">    9437 </span><span class="lineCov">        420 :       return cp_build_qualified_type (unqual, quals);</span>
<span class="lineNum">    9438 </span>            :     }
<span class="lineNum">    9439 </span>            : 
<span class="lineNum">    9440 </span>            :   /* If a canonical type already exists for this type, use it.  We use
<span class="lineNum">    9441 </span>            :      this method instead of type_hash_canon, because it only does a
<span class="lineNum">    9442 </span>            :      simple equality check on the list of field members.  */
<span class="lineNum">    9443 </span>            : 
<span class="lineNum">    9444 </span><span class="lineCov">     487574 :   t = TYPE_PTRMEMFUNC_TYPE (type);</span>
<span class="lineNum">    9445 </span><span class="lineCov">     487574 :   if (t)</span>
<span class="lineNum">    9446 </span>            :     return t;
<span class="lineNum">    9447 </span>            : 
<span class="lineNum">    9448 </span><span class="lineCov">      72212 :   t = make_node (RECORD_TYPE);</span>
<span class="lineNum">    9449 </span>            : 
<span class="lineNum">    9450 </span>            :   /* Let the front end know this is a pointer to member function.  */
<span class="lineNum">    9451 </span><span class="lineCov">      72212 :   TYPE_PTRMEMFUNC_FLAG (t) = 1;</span>
<span class="lineNum">    9452 </span>            : 
<span class="lineNum">    9453 </span><span class="lineCov">      72212 :   field = build_decl (input_location, FIELD_DECL, pfn_identifier, type);</span>
<span class="lineNum">    9454 </span><span class="lineCov">      72212 :   fields = field;</span>
<span class="lineNum">    9455 </span>            : 
<span class="lineNum">    9456 </span><span class="lineCov">      72212 :   field = build_decl (input_location, FIELD_DECL, delta_identifier, </span>
<span class="lineNum">    9457 </span>            :                       delta_type_node);
<span class="lineNum">    9458 </span><span class="lineCov">      72212 :   DECL_CHAIN (field) = fields;</span>
<span class="lineNum">    9459 </span><span class="lineCov">      72212 :   fields = field;</span>
<span class="lineNum">    9460 </span>            : 
<span class="lineNum">    9461 </span><span class="lineCov">      72212 :   finish_builtin_struct (t, &quot;__ptrmemfunc_type&quot;, fields, ptr_type_node);</span>
<span class="lineNum">    9462 </span>            : 
<span class="lineNum">    9463 </span>            :   /* Zap out the name so that the back end will give us the debugging
<span class="lineNum">    9464 </span>            :      information for this anonymous RECORD_TYPE.  */
<span class="lineNum">    9465 </span><span class="lineCov">      72212 :   TYPE_NAME (t) = NULL_TREE;</span>
<span class="lineNum">    9466 </span>            : 
<span class="lineNum">    9467 </span>            :   /* Cache this pointer-to-member type so that we can find it again
<span class="lineNum">    9468 </span>            :      later.  */
<span class="lineNum">    9469 </span><span class="lineCov">      72212 :   TYPE_PTRMEMFUNC_TYPE (type) = t;</span>
<span class="lineNum">    9470 </span>            : 
<span class="lineNum">    9471 </span><span class="lineCov">      72212 :   if (TYPE_STRUCTURAL_EQUALITY_P (type))</span>
<span class="lineNum">    9472 </span><span class="lineCov">      21880 :     SET_TYPE_STRUCTURAL_EQUALITY (t);</span>
<span class="lineNum">    9473 </span><span class="lineCov">     100664 :   else if (TYPE_CANONICAL (type) != type)</span>
<span class="lineNum">    9474 </span><span class="lineCov">      66792 :     TYPE_CANONICAL (t) = build_ptrmemfunc_type (TYPE_CANONICAL (type));</span>
<span class="lineNum">    9475 </span>            : 
<span class="lineNum">    9476 </span>            :   return t;
<span class="lineNum">    9477 </span>            : }
<span class="lineNum">    9478 </span>            : 
<span class="lineNum">    9479 </span>            : /* Create and return a pointer to data member type.  */
<a name="9480"><span class="lineNum">    9480 </span>            : </a>
<span class="lineNum">    9481 </span>            : tree
<span class="lineNum">    9482 </span><span class="lineCov">      69665 : build_ptrmem_type (tree class_type, tree member_type)</span>
<span class="lineNum">    9483 </span>            : {
<span class="lineNum">    9484 </span><span class="lineCov">      69665 :   if (TREE_CODE (member_type) == METHOD_TYPE)</span>
<span class="lineNum">    9485 </span>            :     {
<span class="lineNum">    9486 </span><span class="lineCov">       4280 :       cp_cv_quals quals = type_memfn_quals (member_type);</span>
<span class="lineNum">    9487 </span><span class="lineCov">       4280 :       cp_ref_qualifier rqual = type_memfn_rqual (member_type);</span>
<span class="lineNum">    9488 </span><span class="lineCov">       4280 :       member_type = build_memfn_type (member_type, class_type, quals, rqual);</span>
<span class="lineNum">    9489 </span><span class="lineCov">       4280 :       return build_ptrmemfunc_type (build_pointer_type (member_type));</span>
<span class="lineNum">    9490 </span>            :     }
<span class="lineNum">    9491 </span>            :   else
<span class="lineNum">    9492 </span>            :     {
<span class="lineNum">    9493 </span><span class="lineCov">      65385 :       gcc_assert (TREE_CODE (member_type) != FUNCTION_TYPE);</span>
<span class="lineNum">    9494 </span><span class="lineCov">      65385 :       return build_offset_type (class_type, member_type);</span>
<span class="lineNum">    9495 </span>            :     }
<span class="lineNum">    9496 </span>            : }
<span class="lineNum">    9497 </span>            : 
<span class="lineNum">    9498 </span>            : /* DECL is a VAR_DECL defined in-class, whose TYPE is also given.
<span class="lineNum">    9499 </span>            :    Check to see that the definition is valid.  Issue appropriate error
<span class="lineNum">    9500 </span>            :    messages.  */
<a name="9501"><span class="lineNum">    9501 </span>            : </a>
<span class="lineNum">    9502 </span>            : static void
<span class="lineNum">    9503 </span><span class="lineCov">     993877 : check_static_variable_definition (tree decl, tree type)</span>
<span class="lineNum">    9504 </span>            : {
<span class="lineNum">    9505 </span>            :   /* Avoid redundant diagnostics on out-of-class definitions.  */
<span class="lineNum">    9506 </span><span class="lineCov">     993877 :   if (!current_class_type || !TYPE_BEING_DEFINED (current_class_type))</span>
<span class="lineNum">    9507 </span>            :     ;
<span class="lineNum">    9508 </span>            :   /* Can't check yet if we don't know the type.  */
<span class="lineNum">    9509 </span><span class="lineCov">     899109 :   else if (dependent_type_p (type))</span>
<span class="lineNum">    9510 </span>            :     ;
<span class="lineNum">    9511 </span>            :   /* If DECL is declared constexpr, we'll do the appropriate checks
<span class="lineNum">    9512 </span>            :      in check_initializer.  Similarly for inline static data members.  */
<span class="lineNum">    9513 </span><span class="lineCov">     884715 :   else if (DECL_P (decl)</span>
<span class="lineNum">    9514 </span><span class="lineCov">     884715 :       &amp;&amp; (DECL_DECLARED_CONSTEXPR_P (decl)</span>
<span class="lineNum">    9515 </span><span class="lineCov">     884715 :           || undeduced_auto_decl (decl)</span>
<span class="lineNum">    9516 </span><span class="lineCov">     242508 :           || DECL_VAR_DECLARED_INLINE_P (decl)))</span>
<span class="lineNum">    9517 </span>            :     ;
<span class="lineNum">    9518 </span><span class="lineCov">     242419 :   else if (cxx_dialect &gt;= cxx11 &amp;&amp; !INTEGRAL_OR_ENUMERATION_TYPE_P (type))</span>
<span class="lineNum">    9519 </span>            :     {
<span class="lineNum">    9520 </span><span class="lineCov">         40 :       if (!COMPLETE_TYPE_P (type))</span>
<span class="lineNum">    9521 </span><span class="lineCov">         10 :         error_at (DECL_SOURCE_LOCATION (decl),</span>
<span class="lineNum">    9522 </span>            :                   &quot;in-class initialization of static data member %q#D of &quot;
<span class="lineNum">    9523 </span>            :                   &quot;incomplete type&quot;, decl);
<span class="lineNum">    9524 </span><span class="lineCov">         30 :       else if (literal_type_p (type))</span>
<span class="lineNum">    9525 </span><span class="lineCov">         26 :         permerror (DECL_SOURCE_LOCATION (decl),</span>
<span class="lineNum">    9526 </span>            :                    &quot;%&lt;constexpr%&gt; needed for in-class initialization of &quot;
<span class="lineNum">    9527 </span>            :                    &quot;static data member %q#D of non-integral type&quot;, decl);
<span class="lineNum">    9528 </span>            :       else
<span class="lineNum">    9529 </span><span class="lineCov">          4 :         error_at (DECL_SOURCE_LOCATION (decl),</span>
<span class="lineNum">    9530 </span>            :                   &quot;in-class initialization of static data member %q#D of &quot;
<span class="lineNum">    9531 </span>            :                   &quot;non-literal type&quot;, decl);
<span class="lineNum">    9532 </span>            :     }
<span class="lineNum">    9533 </span>            :   /* Motion 10 at San Diego: If a static const integral data member is
<span class="lineNum">    9534 </span>            :      initialized with an integral constant expression, the initializer
<span class="lineNum">    9535 </span>            :      may appear either in the declaration (within the class), or in
<span class="lineNum">    9536 </span>            :      the definition, but not both.  If it appears in the class, the
<span class="lineNum">    9537 </span>            :      member is a member constant.  The file-scope definition is always
<span class="lineNum">    9538 </span>            :      required.  */
<span class="lineNum">    9539 </span><span class="lineCov">     242379 :   else if (!ARITHMETIC_TYPE_P (type) &amp;&amp; TREE_CODE (type) != ENUMERAL_TYPE)</span>
<span class="lineNum">    9540 </span><span class="lineCov">         11 :     error_at (DECL_SOURCE_LOCATION (decl),</span>
<span class="lineNum">    9541 </span>            :               &quot;invalid in-class initialization of static data member &quot;
<span class="lineNum">    9542 </span>            :               &quot;of non-integral type %qT&quot;,
<span class="lineNum">    9543 </span>            :               type);
<span class="lineNum">    9544 </span><span class="lineCov">     242368 :   else if (!CP_TYPE_CONST_P (type))</span>
<span class="lineNum">    9545 </span><span class="lineCov">          4 :     error_at (DECL_SOURCE_LOCATION (decl),</span>
<span class="lineNum">    9546 </span>            :               &quot;ISO C++ forbids in-class initialization of non-const &quot;
<span class="lineNum">    9547 </span>            :               &quot;static member %qD&quot;,
<span class="lineNum">    9548 </span>            :               decl);
<span class="lineNum">    9549 </span><span class="lineCov">     242364 :   else if (!INTEGRAL_OR_ENUMERATION_TYPE_P (type))</span>
<span class="lineNum">    9550 </span><span class="lineCov">          5 :     pedwarn (DECL_SOURCE_LOCATION (decl), OPT_Wpedantic,</span>
<span class="lineNum">    9551 </span>            :              &quot;ISO C++ forbids initialization of member constant &quot;
<span class="lineNum">    9552 </span>            :              &quot;%qD of non-integral type %qT&quot;, decl, type);
<span class="lineNum">    9553 </span><span class="lineCov">     993877 : }</span>
<span class="lineNum">    9554 </span>            : 
<span class="lineNum">    9555 </span>            : /* *expr_p is part of the TYPE_SIZE of a variably-sized array.  If any
<span class="lineNum">    9556 </span>            :    SAVE_EXPRs in *expr_p wrap expressions with side-effects, break those
<span class="lineNum">    9557 </span>            :    expressions out into temporary variables so that walk_tree doesn't
<span class="lineNum">    9558 </span>            :    step into them (c++/15764).  */
<a name="9559"><span class="lineNum">    9559 </span>            : </a>
<span class="lineNum">    9560 </span>            : static tree
<span class="lineNum">    9561 </span><span class="lineCov">       2622 : stabilize_save_expr_r (tree *expr_p, int *walk_subtrees, void *data)</span>
<span class="lineNum">    9562 </span>            : {
<span class="lineNum">    9563 </span><span class="lineCov">       2622 :   hash_set&lt;tree&gt; *pset = (hash_set&lt;tree&gt; *)data;</span>
<span class="lineNum">    9564 </span><span class="lineCov">       2622 :   tree expr = *expr_p;</span>
<span class="lineNum">    9565 </span><span class="lineCov">       2622 :   if (TREE_CODE (expr) == SAVE_EXPR)</span>
<span class="lineNum">    9566 </span>            :     {
<span class="lineNum">    9567 </span><span class="lineCov">        919 :       tree op = TREE_OPERAND (expr, 0);</span>
<span class="lineNum">    9568 </span><span class="lineCov">        919 :       cp_walk_tree (&amp;op, stabilize_save_expr_r, data, pset);</span>
<span class="lineNum">    9569 </span><span class="lineCov">        919 :       if (TREE_SIDE_EFFECTS (op))</span>
<span class="lineNum">    9570 </span><span class="lineCov">         77 :         TREE_OPERAND (expr, 0) = get_temp_regvar (TREE_TYPE (op), op);</span>
<span class="lineNum">    9571 </span><span class="lineCov">        919 :       *walk_subtrees = 0;</span>
<span class="lineNum">    9572 </span>            :     }
<span class="lineNum">    9573 </span><span class="lineCov">       1703 :   else if (!EXPR_P (expr) || !TREE_SIDE_EFFECTS (expr))</span>
<span class="lineNum">    9574 </span><span class="lineCov">       1286 :     *walk_subtrees = 0;</span>
<span class="lineNum">    9575 </span><span class="lineCov">       2622 :   return NULL;</span>
<span class="lineNum">    9576 </span>            : }
<span class="lineNum">    9577 </span>            : 
<span class="lineNum">    9578 </span>            : /* Entry point for the above.  */
<a name="9579"><span class="lineNum">    9579 </span>            : </a>
<span class="lineNum">    9580 </span>            : static void
<span class="lineNum">    9581 </span><span class="lineCov">        950 : stabilize_vla_size (tree size)</span>
<span class="lineNum">    9582 </span>            : {
<span class="lineNum">    9583 </span><span class="lineCov">        950 :   hash_set&lt;tree&gt; pset;</span>
<span class="lineNum">    9584 </span>            :   /* Break out any function calls into temporary variables.  */
<span class="lineNum">    9585 </span><span class="lineCov">        950 :   cp_walk_tree (&amp;size, stabilize_save_expr_r, &amp;pset, &amp;pset);</span>
<span class="lineNum">    9586 </span><span class="lineCov">        950 : }</span>
<span class="lineNum">    9587 </span>            : 
<span class="lineNum">    9588 </span>            : /* Reduce a SIZEOF_EXPR to its value.  */
<a name="9589"><span class="lineNum">    9589 </span>            : </a>
<span class="lineNum">    9590 </span>            : tree
<span class="lineNum">    9591 </span><span class="lineCov">    1348785 : fold_sizeof_expr (tree t)</span>
<span class="lineNum">    9592 </span>            : {
<span class="lineNum">    9593 </span><span class="lineCov">    1348785 :   tree r;</span>
<span class="lineNum">    9594 </span><span class="lineCov">    1348785 :   if (SIZEOF_EXPR_TYPE_P (t))</span>
<span class="lineNum">    9595 </span><span class="lineCov">    1125114 :     r = cxx_sizeof_or_alignof_type (TREE_TYPE (TREE_OPERAND (t, 0)),</span>
<span class="lineNum">    9596 </span>            :                                     SIZEOF_EXPR, false, false);
<span class="lineNum">    9597 </span><span class="lineCov">     223671 :   else if (TYPE_P (TREE_OPERAND (t, 0)))</span>
<span class="lineNum">    9598 </span><span class="lineNoCov">          0 :     r = cxx_sizeof_or_alignof_type (TREE_OPERAND (t, 0), SIZEOF_EXPR,</span>
<span class="lineNum">    9599 </span>            :                                     false, false);
<span class="lineNum">    9600 </span>            :   else
<span class="lineNum">    9601 </span><span class="lineCov">     223671 :     r = cxx_sizeof_or_alignof_expr (TREE_OPERAND (t, 0), SIZEOF_EXPR,</span>
<span class="lineNum">    9602 </span>            :                                     false);
<span class="lineNum">    9603 </span><span class="lineCov">    1348785 :   if (r == error_mark_node)</span>
<span class="lineNum">    9604 </span><span class="lineCov">         44 :     r = size_one_node;</span>
<span class="lineNum">    9605 </span><span class="lineCov">    1348785 :   return r;</span>
<span class="lineNum">    9606 </span>            : }
<span class="lineNum">    9607 </span>            : 
<span class="lineNum">    9608 </span>            : /* Given the SIZE (i.e., number of elements) in an array, compute
<span class="lineNum">    9609 </span>            :    an appropriate index type for the array.  If non-NULL, NAME is
<span class="lineNum">    9610 </span>            :    the name of the entity being declared.  */
<a name="9611"><span class="lineNum">    9611 </span>            : </a>
<span class="lineNum">    9612 </span>            : tree
<span class="lineNum">    9613 </span><span class="lineCov">     303360 : compute_array_index_type (tree name, tree size, tsubst_flags_t complain)</span>
<span class="lineNum">    9614 </span>            : {
<span class="lineNum">    9615 </span><span class="lineCov">     303360 :   tree itype;</span>
<span class="lineNum">    9616 </span><span class="lineCov">     303360 :   tree osize = size;</span>
<span class="lineNum">    9617 </span>            : 
<span class="lineNum">    9618 </span><span class="lineCov">     303360 :   if (error_operand_p (size))</span>
<span class="lineNum">    9619 </span>            :     return error_mark_node;
<span class="lineNum">    9620 </span>            : 
<span class="lineNum">    9621 </span><span class="lineCov">     303343 :   if (!type_dependent_expression_p (size))</span>
<span class="lineNum">    9622 </span>            :     {
<span class="lineNum">    9623 </span><span class="lineCov">     298697 :       osize = size = mark_rvalue_use (size);</span>
<span class="lineNum">    9624 </span>            : 
<span class="lineNum">    9625 </span><span class="lineCov">      21487 :       if (cxx_dialect &lt; cxx11 &amp;&amp; TREE_CODE (size) == NOP_EXPR</span>
<span class="lineNum">    9626 </span><span class="lineCov">     298868 :           &amp;&amp; TREE_SIDE_EFFECTS (size))</span>
<span class="lineNum">    9627 </span>            :         /* In C++98, we mark a non-constant array bound with a magic
<span class="lineNum">    9628 </span>            :            NOP_EXPR with TREE_SIDE_EFFECTS; don't fold in that case.  */;
<span class="lineNum">    9629 </span>            :       else
<span class="lineNum">    9630 </span>            :         {
<span class="lineNum">    9631 </span><span class="lineCov">     298687 :           size = instantiate_non_dependent_expr_sfinae (size, complain);</span>
<span class="lineNum">    9632 </span><span class="lineCov">     298687 :           size = build_converted_constant_expr (size_type_node, size, complain);</span>
<span class="lineNum">    9633 </span><span class="lineCov">     298687 :           size = maybe_constant_value (size);</span>
<span class="lineNum">    9634 </span>            : 
<span class="lineNum">    9635 </span><span class="lineCov">     298687 :           if (!TREE_CONSTANT (size))</span>
<span class="lineNum">    9636 </span><span class="lineCov">       4909 :             size = osize;</span>
<span class="lineNum">    9637 </span>            :         }
<span class="lineNum">    9638 </span>            : 
<span class="lineNum">    9639 </span><span class="lineCov">     298697 :       if (error_operand_p (size))</span>
<span class="lineNum">    9640 </span>            :         return error_mark_node;
<span class="lineNum">    9641 </span>            : 
<span class="lineNum">    9642 </span>            :       /* The array bound must be an integer type.  */
<span class="lineNum">    9643 </span><span class="lineCov">     298695 :       tree type = TREE_TYPE (size);</span>
<span class="lineNum">    9644 </span><span class="lineCov">     298695 :       if (!INTEGRAL_OR_UNSCOPED_ENUMERATION_TYPE_P (type))</span>
<span class="lineNum">    9645 </span>            :         {
<span class="lineNum">    9646 </span><span class="lineCov">         18 :           if (!(complain &amp; tf_error))</span>
<span class="lineNum">    9647 </span>            :             return error_mark_node;
<span class="lineNum">    9648 </span><span class="lineCov">         18 :           if (name)</span>
<span class="lineNum">    9649 </span><span class="lineCov">         15 :             error (&quot;size of array %qD has non-integral type %qT&quot;, name, type);</span>
<span class="lineNum">    9650 </span>            :           else
<span class="lineNum">    9651 </span><span class="lineCov">          3 :             error (&quot;size of array has non-integral type %qT&quot;, type);</span>
<span class="lineNum">    9652 </span><span class="lineCov">         18 :           size = integer_one_node;</span>
<span class="lineNum">    9653 </span>            :         }
<span class="lineNum">    9654 </span>            :     }
<span class="lineNum">    9655 </span>            : 
<span class="lineNum">    9656 </span>            :   /* A type is dependent if it is...an array type constructed from any
<span class="lineNum">    9657 </span>            :      dependent type or whose size is specified by a constant expression
<span class="lineNum">    9658 </span>            :      that is value-dependent.  */
<span class="lineNum">    9659 </span>            :   /* We can only call value_dependent_expression_p on integral constant
<span class="lineNum">    9660 </span>            :      expressions; treat non-constant expressions as dependent, too.  */
<span class="lineNum">    9661 </span><span class="lineCov">     303341 :   if (processing_template_decl</span>
<span class="lineNum">    9662 </span><span class="lineCov">     303341 :       &amp;&amp; (type_dependent_expression_p (size)</span>
<span class="lineNum">    9663 </span><span class="lineCov">      70247 :           || !TREE_CONSTANT (size) || value_dependent_expression_p (size)))</span>
<span class="lineNum">    9664 </span>            :     {
<span class="lineNum">    9665 </span>            :       /* We cannot do any checking for a SIZE that isn't known to be
<span class="lineNum">    9666 </span>            :          constant. Just build the index type and mark that it requires
<span class="lineNum">    9667 </span>            :          structural equality checks.  */
<span class="lineNum">    9668 </span><span class="lineCov">      57457 :       itype = build_index_type (build_min (MINUS_EXPR, sizetype,</span>
<span class="lineNum">    9669 </span>            :                                            size, size_one_node));
<span class="lineNum">    9670 </span><span class="lineCov">      57457 :       TYPE_DEPENDENT_P (itype) = 1;</span>
<span class="lineNum">    9671 </span><span class="lineCov">      57457 :       TYPE_DEPENDENT_P_VALID (itype) = 1;</span>
<span class="lineNum">    9672 </span><span class="lineCov">      57457 :       SET_TYPE_STRUCTURAL_EQUALITY (itype);</span>
<span class="lineNum">    9673 </span><span class="lineCov">      57457 :       return itype;</span>
<span class="lineNum">    9674 </span>            :     }
<span class="lineNum">    9675 </span>            : 
<span class="lineNum">    9676 </span><span class="lineCov">     245884 :   if (TREE_CODE (size) != INTEGER_CST)</span>
<span class="lineNum">    9677 </span>            :     {
<span class="lineNum">    9678 </span><span class="lineCov">       1082 :       tree folded = cp_fully_fold (size);</span>
<span class="lineNum">    9679 </span><span class="lineCov">       1082 :       if (TREE_CODE (folded) == INTEGER_CST)</span>
<span class="lineNum">    9680 </span><span class="lineCov">         95 :         pedwarn (input_location, OPT_Wpedantic,</span>
<span class="lineNum">    9681 </span>            :                  &quot;size of array is not an integral constant-expression&quot;);
<span class="lineNum">    9682 </span>            :       /* Use the folded result for VLAs, too; it will have resolved
<span class="lineNum">    9683 </span>            :          SIZEOF_EXPR.  */
<span class="lineNum">    9684 </span>            :       size = folded;
<span class="lineNum">    9685 </span>            :     }
<span class="lineNum">    9686 </span>            : 
<span class="lineNum">    9687 </span>            :   /* Normally, the array-bound will be a constant.  */
<span class="lineNum">    9688 </span><span class="lineCov">     245884 :   if (TREE_CODE (size) == INTEGER_CST)</span>
<span class="lineNum">    9689 </span>            :     {
<span class="lineNum">    9690 </span>            :       /* An array must have a positive number of elements.  */
<span class="lineNum">    9691 </span><span class="lineCov">     244897 :       if (!valid_constant_size_p (size))</span>
<span class="lineNum">    9692 </span>            :         {
<span class="lineNum">    9693 </span><span class="lineCov">        347 :           if (!(complain &amp; tf_error))</span>
<span class="lineNum">    9694 </span><span class="lineCov">          8 :             return error_mark_node;</span>
<span class="lineNum">    9695 </span>            : 
<span class="lineNum">    9696 </span><span class="lineCov">        339 :           if (name)</span>
<span class="lineNum">    9697 </span><span class="lineCov">         45 :             error (&quot;size of array %qD is negative&quot;, name);</span>
<span class="lineNum">    9698 </span>            :           else
<span class="lineNum">    9699 </span><span class="lineCov">        294 :             error (&quot;size of array is negative&quot;);</span>
<span class="lineNum">    9700 </span><span class="lineCov">        339 :           size = integer_one_node;</span>
<span class="lineNum">    9701 </span>            :         }
<span class="lineNum">    9702 </span>            :       /* As an extension we allow zero-sized arrays.  */
<span class="lineNum">    9703 </span><span class="lineCov">     244550 :       else if (integer_zerop (size))</span>
<span class="lineNum">    9704 </span>            :         {
<span class="lineNum">    9705 </span><span class="lineCov">       1601 :           if (!(complain &amp; tf_error))</span>
<span class="lineNum">    9706 </span>            :             /* We must fail if performing argument deduction (as
<span class="lineNum">    9707 </span>            :                indicated by the state of complain), so that
<span class="lineNum">    9708 </span>            :                another substitution can be found.  */
<span class="lineNum">    9709 </span><span class="lineCov">          8 :             return error_mark_node;</span>
<span class="lineNum">    9710 </span><span class="lineCov">       1593 :           else if (in_system_header_at (input_location))</span>
<span class="lineNum">    9711 </span>            :             /* Allow them in system headers because glibc uses them.  */;
<span class="lineNum">    9712 </span><span class="lineCov">       1506 :           else if (name)</span>
<span class="lineNum">    9713 </span><span class="lineCov">       1447 :             pedwarn (input_location, OPT_Wpedantic, &quot;ISO C++ forbids zero-size array %qD&quot;, name);</span>
<span class="lineNum">    9714 </span>            :           else
<span class="lineNum">    9715 </span><span class="lineCov">         59 :             pedwarn (input_location, OPT_Wpedantic, &quot;ISO C++ forbids zero-size array&quot;);</span>
<span class="lineNum">    9716 </span>            :         }
<span class="lineNum">    9717 </span>            :     }
<span class="lineNum">    9718 </span><span class="lineCov">        987 :   else if (TREE_CONSTANT (size)</span>
<span class="lineNum">    9719 </span>            :            /* We don't allow VLAs at non-function scopes, or during
<span class="lineNum">    9720 </span>            :               tentative template substitution.  */
<span class="lineNum">    9721 </span><span class="lineCov">        980 :            || !at_function_scope_p ()</span>
<span class="lineNum">    9722 </span><span class="lineCov">       1937 :            || !(complain &amp; tf_error))</span>
<span class="lineNum">    9723 </span>            :     {
<span class="lineNum">    9724 </span><span class="lineCov">         37 :       if (!(complain &amp; tf_error))</span>
<span class="lineNum">    9725 </span><span class="lineCov">         20 :         return error_mark_node;</span>
<span class="lineNum">    9726 </span>            :       /* `(int) &amp;fn' is not a valid array bound.  */
<span class="lineNum">    9727 </span><span class="lineCov">         17 :       if (name)</span>
<span class="lineNum">    9728 </span><span class="lineCov">          9 :         error (&quot;size of array %qD is not an integral constant-expression&quot;,</span>
<span class="lineNum">    9729 </span>            :                name);
<span class="lineNum">    9730 </span>            :       else
<span class="lineNum">    9731 </span><span class="lineCov">          8 :         error (&quot;size of array is not an integral constant-expression&quot;);</span>
<span class="lineNum">    9732 </span><span class="lineCov">         17 :       size = integer_one_node;</span>
<span class="lineNum">    9733 </span>            :     }
<span class="lineNum">    9734 </span><span class="lineCov">        950 :   else if (pedantic &amp;&amp; warn_vla != 0)</span>
<span class="lineNum">    9735 </span>            :     {
<span class="lineNum">    9736 </span><span class="lineCov">         26 :       if (name)</span>
<span class="lineNum">    9737 </span><span class="lineCov">         11 :         pedwarn (input_location, OPT_Wvla, &quot;ISO C++ forbids variable length array %qD&quot;, name);</span>
<span class="lineNum">    9738 </span>            :       else
<span class="lineNum">    9739 </span><span class="lineCov">         15 :         pedwarn (input_location, OPT_Wvla, &quot;ISO C++ forbids variable length array&quot;);</span>
<span class="lineNum">    9740 </span>            :     }
<span class="lineNum">    9741 </span><span class="lineCov">        924 :   else if (warn_vla &gt; 0)</span>
<span class="lineNum">    9742 </span>            :     {
<span class="lineNum">    9743 </span><span class="lineCov">          3 :       if (name)</span>
<span class="lineNum">    9744 </span><span class="lineCov">          3 :         warning (OPT_Wvla, </span>
<span class="lineNum">    9745 </span>            :                  &quot;variable length array %qD is used&quot;, name);
<span class="lineNum">    9746 </span>            :       else
<span class="lineNum">    9747 </span><span class="lineNoCov">          0 :         warning (OPT_Wvla, </span>
<span class="lineNum">    9748 </span>            :                  &quot;variable length array is used&quot;);
<span class="lineNum">    9749 </span>            :     }
<span class="lineNum">    9750 </span>            : 
<span class="lineNum">    9751 </span><span class="lineCov">     245848 :   if (processing_template_decl &amp;&amp; !TREE_CONSTANT (size))</span>
<span class="lineNum">    9752 </span>            :     /* A variable sized array.  */
<span class="lineNum">    9753 </span><span class="lineNoCov">          0 :     itype = build_min (MINUS_EXPR, sizetype, size, integer_one_node);</span>
<span class="lineNum">    9754 </span>            :   else
<span class="lineNum">    9755 </span>            :     {
<span class="lineNum">    9756 </span>            :       /* Compute the index of the largest element in the array.  It is
<span class="lineNum">    9757 </span>            :          one less than the number of elements in the array.  We save
<span class="lineNum">    9758 </span>            :          and restore PROCESSING_TEMPLATE_DECL so that computations in
<span class="lineNum">    9759 </span>            :          cp_build_binary_op will be appropriately folded.  */
<span class="lineNum">    9760 </span><span class="lineCov">     245848 :       {</span>
<span class="lineNum">    9761 </span><span class="lineCov">     245848 :         processing_template_decl_sentinel s;</span>
<span class="lineNum">    9762 </span><span class="lineCov">     245848 :         itype = cp_build_binary_op (input_location,</span>
<span class="lineNum">    9763 </span>            :                                     MINUS_EXPR,
<span class="lineNum">    9764 </span>            :                                     cp_convert (ssizetype, size, complain),
<span class="lineNum">    9765 </span>            :                                     cp_convert (ssizetype, integer_one_node,
<span class="lineNum">    9766 </span>            :                                                 complain),
<span class="lineNum">    9767 </span>            :                                     complain);
<span class="lineNum">    9768 </span><span class="lineCov">     245848 :         itype = maybe_constant_value (itype);</span>
<span class="lineNum">    9769 </span>            :       }
<span class="lineNum">    9770 </span>            : 
<span class="lineNum">    9771 </span><span class="lineCov">     245848 :       if (!TREE_CONSTANT (itype))</span>
<span class="lineNum">    9772 </span>            :         {
<span class="lineNum">    9773 </span>            :           /* A variable sized array.  */
<span class="lineNum">    9774 </span><span class="lineCov">        950 :           itype = variable_size (itype);</span>
<span class="lineNum">    9775 </span>            : 
<span class="lineNum">    9776 </span><span class="lineCov">        950 :           stabilize_vla_size (itype);</span>
<span class="lineNum">    9777 </span>            : 
<span class="lineNum">    9778 </span><span class="lineCov">        950 :           if (sanitize_flags_p (SANITIZE_VLA)</span>
<span class="lineNum">    9779 </span><span class="lineCov">        950 :               &amp;&amp; current_function_decl != NULL_TREE)</span>
<span class="lineNum">    9780 </span>            :             {
<span class="lineNum">    9781 </span>            :               /* We have to add 1 -- in the ubsan routine we generate
<span class="lineNum">    9782 </span>            :                  LE_EXPR rather than LT_EXPR.  */
<span class="lineNum">    9783 </span><span class="lineCov">        151 :               tree t = fold_build2 (PLUS_EXPR, TREE_TYPE (itype), itype,</span>
<span class="lineNum">    9784 </span>            :                                     build_one_cst (TREE_TYPE (itype)));
<span class="lineNum">    9785 </span><span class="lineCov">        151 :               t = ubsan_instrument_vla (input_location, t);</span>
<span class="lineNum">    9786 </span><span class="lineCov">        151 :               finish_expr_stmt (t);</span>
<span class="lineNum">    9787 </span>            :             }
<span class="lineNum">    9788 </span>            :         }
<span class="lineNum">    9789 </span>            :       /* Make sure that there was no overflow when creating to a signed
<span class="lineNum">    9790 </span>            :          index type.  (For example, on a 32-bit machine, an array with
<span class="lineNum">    9791 </span>            :          size 2^32 - 1 is too big.)  */
<span class="lineNum">    9792 </span><span class="lineCov">     244898 :       else if (TREE_CODE (itype) == INTEGER_CST</span>
<span class="lineNum">    9793 </span><span class="lineCov">     244898 :                &amp;&amp; TREE_OVERFLOW (itype))</span>
<span class="lineNum">    9794 </span>            :         {
<span class="lineNum">    9795 </span><span class="lineNoCov">          0 :           if (!(complain &amp; tf_error))</span>
<span class="lineNum">    9796 </span><span class="lineNoCov">          0 :             return error_mark_node;</span>
<span class="lineNum">    9797 </span><span class="lineNoCov">          0 :           error (&quot;overflow in array dimension&quot;);</span>
<span class="lineNum">    9798 </span><span class="lineNoCov">          0 :           TREE_OVERFLOW (itype) = 0;</span>
<span class="lineNum">    9799 </span>            :         }
<span class="lineNum">    9800 </span>            :     }
<span class="lineNum">    9801 </span>            : 
<span class="lineNum">    9802 </span>            :   /* Create and return the appropriate index type.  */
<span class="lineNum">    9803 </span><span class="lineCov">     245848 :   itype = build_index_type (itype);</span>
<span class="lineNum">    9804 </span>            : 
<span class="lineNum">    9805 </span>            :   /* If the index type were dependent, we would have returned early, so
<span class="lineNum">    9806 </span>            :      remember that it isn't.  */
<span class="lineNum">    9807 </span><span class="lineCov">     245848 :   TYPE_DEPENDENT_P (itype) = 0;</span>
<span class="lineNum">    9808 </span><span class="lineCov">     245848 :   TYPE_DEPENDENT_P_VALID (itype) = 1;</span>
<span class="lineNum">    9809 </span><span class="lineCov">     245848 :   return itype;</span>
<span class="lineNum">    9810 </span>            : }
<span class="lineNum">    9811 </span>            : 
<span class="lineNum">    9812 </span>            : /* Returns the scope (if any) in which the entity declared by
<span class="lineNum">    9813 </span>            :    DECLARATOR will be located.  If the entity was declared with an
<span class="lineNum">    9814 </span>            :    unqualified name, NULL_TREE is returned.  */
<a name="9815"><span class="lineNum">    9815 </span>            : </a>
<span class="lineNum">    9816 </span>            : tree
<span class="lineNum">    9817 </span><span class="lineCov">   42438081 : get_scope_of_declarator (const cp_declarator *declarator)</span>
<span class="lineNum">    9818 </span>            : {
<span class="lineNum">    9819 </span><span class="lineCov">   50250333 :   while (declarator &amp;&amp; declarator-&gt;kind != cdk_id)</span>
<span class="lineNum">    9820 </span><span class="lineCov">    7812252 :     declarator = declarator-&gt;declarator;</span>
<span class="lineNum">    9821 </span>            : 
<span class="lineNum">    9822 </span>            :   /* If the declarator-id is a SCOPE_REF, the scope in which the
<span class="lineNum">    9823 </span>            :      declaration occurs is the first operand.  */
<span class="lineNum">    9824 </span><span class="lineCov">   42438081 :   if (declarator</span>
<span class="lineNum">    9825 </span><span class="lineCov">   42394158 :       &amp;&amp; declarator-&gt;u.id.qualifying_scope)</span>
<span class="lineNum">    9826 </span><span class="lineCov">     919309 :     return declarator-&gt;u.id.qualifying_scope;</span>
<span class="lineNum">    9827 </span>            : 
<span class="lineNum">    9828 </span>            :   /* Otherwise, the declarator is not a qualified name; the entity will
<span class="lineNum">    9829 </span>            :      be declared in the current scope.  */
<span class="lineNum">    9830 </span>            :   return NULL_TREE;
<span class="lineNum">    9831 </span>            : }
<span class="lineNum">    9832 </span>            : 
<span class="lineNum">    9833 </span>            : /* Returns an ARRAY_TYPE for an array with SIZE elements of the
<span class="lineNum">    9834 </span>            :    indicated TYPE.  If non-NULL, NAME is the NAME of the declaration
<span class="lineNum">    9835 </span>            :    with this type.  */
<a name="9836"><span class="lineNum">    9836 </span>            : </a>
<span class="lineNum">    9837 </span>            : static tree
<span class="lineNum">    9838 </span><span class="lineCov">     401331 : create_array_type_for_decl (tree name, tree type, tree size)</span>
<span class="lineNum">    9839 </span>            : {
<span class="lineNum">    9840 </span><span class="lineCov">     401331 :   tree itype = NULL_TREE;</span>
<span class="lineNum">    9841 </span>            : 
<span class="lineNum">    9842 </span>            :   /* If things have already gone awry, bail now.  */
<span class="lineNum">    9843 </span><span class="lineCov">     401331 :   if (type == error_mark_node || size == error_mark_node)</span>
<span class="lineNum">    9844 </span>            :     return error_mark_node;
<span class="lineNum">    9845 </span>            : 
<span class="lineNum">    9846 </span>            :   /* 8.3.4/1: If the type of the identifier of D contains the auto
<span class="lineNum">    9847 </span>            :      type-specifier, the program is ill-formed.  */
<span class="lineNum">    9848 </span><span class="lineCov">     401263 :   if (type_uses_auto (type))</span>
<span class="lineNum">    9849 </span>            :     {
<span class="lineNum">    9850 </span><span class="lineCov">         10 :       if (name)</span>
<span class="lineNum">    9851 </span><span class="lineCov">         10 :    error (&quot;%qD declared as array of %qT&quot;, name, type);</span>
<span class="lineNum">    9852 </span>            :       else
<span class="lineNum">    9853 </span><span class="lineNoCov">          0 :    error (&quot;creating array of %qT&quot;, type);</span>
<span class="lineNum">    9854 </span><span class="lineCov">         10 :       return error_mark_node;</span>
<span class="lineNum">    9855 </span>            :     }
<span class="lineNum">    9856 </span>            : 
<span class="lineNum">    9857 </span>            :   /* If there are some types which cannot be array elements,
<span class="lineNum">    9858 </span>            :      issue an error-message and return.  */
<span class="lineNum">    9859 </span><span class="lineCov">     401253 :   switch (TREE_CODE (type))</span>
<span class="lineNum">    9860 </span>            :     {
<span class="lineNum">    9861 </span><span class="lineCov">          3 :     case VOID_TYPE:</span>
<span class="lineNum">    9862 </span><span class="lineCov">          3 :       if (name)</span>
<span class="lineNum">    9863 </span><span class="lineNoCov">          0 :         error (&quot;declaration of %qD as array of void&quot;, name);</span>
<span class="lineNum">    9864 </span>            :       else
<span class="lineNum">    9865 </span><span class="lineCov">          3 :         error (&quot;creating array of void&quot;);</span>
<span class="lineNum">    9866 </span><span class="lineCov">          3 :       return error_mark_node;</span>
<span class="lineNum">    9867 </span>            : 
<span class="lineNum">    9868 </span><span class="lineCov">          2 :     case FUNCTION_TYPE:</span>
<span class="lineNum">    9869 </span><span class="lineCov">          2 :       if (name)</span>
<span class="lineNum">    9870 </span><span class="lineCov">          2 :         error (&quot;declaration of %qD as array of functions&quot;, name);</span>
<span class="lineNum">    9871 </span>            :       else
<span class="lineNum">    9872 </span><span class="lineNoCov">          0 :         error (&quot;creating array of functions&quot;);</span>
<span class="lineNum">    9873 </span><span class="lineCov">          2 :       return error_mark_node;</span>
<span class="lineNum">    9874 </span>            : 
<span class="lineNum">    9875 </span><span class="lineCov">         20 :     case REFERENCE_TYPE:</span>
<span class="lineNum">    9876 </span><span class="lineCov">         20 :       if (name)</span>
<span class="lineNum">    9877 </span><span class="lineCov">         14 :         error (&quot;declaration of %qD as array of references&quot;, name);</span>
<span class="lineNum">    9878 </span>            :       else
<span class="lineNum">    9879 </span><span class="lineCov">          6 :         error (&quot;creating array of references&quot;);</span>
<span class="lineNum">    9880 </span><span class="lineCov">         20 :       return error_mark_node;</span>
<span class="lineNum">    9881 </span>            : 
<span class="lineNum">    9882 </span><span class="lineNoCov">          0 :     case METHOD_TYPE:</span>
<span class="lineNum">    9883 </span><span class="lineNoCov">          0 :       if (name)</span>
<span class="lineNum">    9884 </span><span class="lineNoCov">          0 :         error (&quot;declaration of %qD as array of function members&quot;, name);</span>
<span class="lineNum">    9885 </span>            :       else
<span class="lineNum">    9886 </span><span class="lineNoCov">          0 :         error (&quot;creating array of function members&quot;);</span>
<span class="lineNum">    9887 </span><span class="lineNoCov">          0 :       return error_mark_node;</span>
<span class="lineNum">    9888 </span>            : 
<span class="lineNum">    9889 </span><span class="lineCov">     401228 :     default:</span>
<span class="lineNum">    9890 </span><span class="lineCov">     401228 :       break;</span>
<span class="lineNum">    9891 </span>            :     }
<span class="lineNum">    9892 </span>            : 
<span class="lineNum">    9893 </span>            :   /* [dcl.array]
<span class="lineNum">    9894 </span>            : 
<span class="lineNum">    9895 </span>            :      The constant expressions that specify the bounds of the arrays
<span class="lineNum">    9896 </span>            :      can be omitted only for the first member of the sequence.  */
<span class="lineNum">    9897 </span><span class="lineCov">     401228 :   if (TREE_CODE (type) == ARRAY_TYPE &amp;&amp; !TYPE_DOMAIN (type))</span>
<span class="lineNum">    9898 </span>            :     {
<span class="lineNum">    9899 </span><span class="lineCov">         30 :       if (name)</span>
<span class="lineNum">    9900 </span><span class="lineCov">         24 :         error (&quot;declaration of %qD as multidimensional array must &quot;</span>
<span class="lineNum">    9901 </span>            :                &quot;have bounds for all dimensions except the first&quot;,
<span class="lineNum">    9902 </span>            :                name);
<span class="lineNum">    9903 </span>            :       else
<span class="lineNum">    9904 </span><span class="lineCov">          6 :         error (&quot;multidimensional array must have bounds for all &quot;</span>
<span class="lineNum">    9905 </span>            :                &quot;dimensions except the first&quot;);
<span class="lineNum">    9906 </span>            : 
<span class="lineNum">    9907 </span><span class="lineCov">         30 :       return error_mark_node;</span>
<span class="lineNum">    9908 </span>            :     }
<span class="lineNum">    9909 </span>            : 
<span class="lineNum">    9910 </span>            :   /* Figure out the index type for the array.  */
<span class="lineNum">    9911 </span><span class="lineCov">     401198 :   if (size)</span>
<span class="lineNum">    9912 </span><span class="lineCov">     273442 :     itype = compute_array_index_type (name, size, tf_warning_or_error);</span>
<span class="lineNum">    9913 </span>            : 
<span class="lineNum">    9914 </span>            :   /* [dcl.array]
<span class="lineNum">    9915 </span>            :      T is called the array element type; this type shall not be [...] an
<span class="lineNum">    9916 </span>            :      abstract class type.  */
<span class="lineNum">    9917 </span><span class="lineCov">     401198 :   abstract_virtuals_error (name, type);</span>
<span class="lineNum">    9918 </span>            : 
<span class="lineNum">    9919 </span><span class="lineCov">     401198 :   return build_cplus_array_type (type, itype);</span>
<span class="lineNum">    9920 </span>            : }
<span class="lineNum">    9921 </span>            : 
<span class="lineNum">    9922 </span>            : /* Returns the smallest location that is not UNKNOWN_LOCATION.  */
<a name="9923"><span class="lineNum">    9923 </span>            : </a>
<span class="lineNum">    9924 </span>            : static location_t
<span class="lineNum">    9925 </span><span class="lineCov">     120639 : min_location (location_t loca, location_t locb)</span>
<span class="lineNum">    9926 </span>            : {
<span class="lineNum">    9927 </span><span class="lineCov">     120639 :   if (loca == UNKNOWN_LOCATION</span>
<span class="lineNum">    9928 </span><span class="lineCov">     120639 :       || (locb != UNKNOWN_LOCATION</span>
<span class="lineNum">    9929 </span><span class="lineCov">      51913 :           &amp;&amp; linemap_location_before_p (line_table, locb, loca)))</span>
<span class="lineNum">    9930 </span><span class="lineCov">      69262 :     return locb;</span>
<span class="lineNum">    9931 </span>            :   return loca;
<span class="lineNum">    9932 </span>            : }
<span class="lineNum">    9933 </span>            : 
<span class="lineNum">    9934 </span>            : /* Returns the smallest location != UNKNOWN_LOCATION among the
<span class="lineNum">    9935 </span>            :    three stored in LOCATIONS[ds_const], LOCATIONS[ds_volatile],
<span class="lineNum">    9936 </span>            :    and LOCATIONS[ds_restrict].  */
<a name="9937"><span class="lineNum">    9937 </span>            : </a>
<span class="lineNum">    9938 </span>            : static location_t
<span class="lineNum">    9939 </span><span class="lineCov">   51841211 : smallest_type_quals_location (int type_quals, const location_t* locations)</span>
<span class="lineNum">    9940 </span>            : {
<span class="lineNum">    9941 </span><span class="lineCov">   51841211 :   location_t loc = UNKNOWN_LOCATION;</span>
<span class="lineNum">    9942 </span>            : 
<span class="lineNum">    9943 </span><span class="lineCov">   51841211 :   if (type_quals &amp; TYPE_QUAL_CONST)</span>
<span class="lineNum">    9944 </span><span class="lineCov">    5495351 :     loc = locations[ds_const];</span>
<span class="lineNum">    9945 </span>            : 
<span class="lineNum">    9946 </span><span class="lineCov">   51841211 :   if (type_quals &amp; TYPE_QUAL_VOLATILE)</span>
<span class="lineNum">    9947 </span><span class="lineCov">     120562 :     loc = min_location (loc, locations[ds_volatile]);</span>
<span class="lineNum">    9948 </span>            : 
<span class="lineNum">    9949 </span><span class="lineCov">   51841211 :   if (type_quals &amp; TYPE_QUAL_RESTRICT)</span>
<span class="lineNum">    9950 </span><span class="lineCov">         25 :     loc = min_location (loc, locations[ds_restrict]);</span>
<span class="lineNum">    9951 </span>            : 
<span class="lineNum">    9952 </span><span class="lineCov">   51841211 :   return loc;</span>
<span class="lineNum">    9953 </span>            : }
<span class="lineNum">    9954 </span>            : 
<span class="lineNum">    9955 </span>            : /* Check that it's OK to declare a function with the indicated TYPE
<span class="lineNum">    9956 </span>            :    and TYPE_QUALS.  SFK indicates the kind of special function (if any)
<span class="lineNum">    9957 </span>            :    that this function is.  OPTYPE is the type given in a conversion
<span class="lineNum">    9958 </span>            :    operator declaration, or the class type for a constructor/destructor.
<span class="lineNum">    9959 </span>            :    Returns the actual return type of the function; that may be different
<span class="lineNum">    9960 </span>            :    than TYPE if an error occurs, or for certain special functions.  */
<a name="9961"><span class="lineNum">    9961 </span>            : </a>
<span class="lineNum">    9962 </span>            : static tree
<span class="lineNum">    9963 </span><span class="lineCov">    1146117 : check_special_function_return_type (special_function_kind sfk,</span>
<span class="lineNum">    9964 </span>            :                                     tree type,
<span class="lineNum">    9965 </span>            :                                     tree optype,
<span class="lineNum">    9966 </span>            :                                     int type_quals,
<span class="lineNum">    9967 </span>            :                                     const location_t* locations)
<span class="lineNum">    9968 </span>            : {
<span class="lineNum">    9969 </span><span class="lineCov">    1146117 :   switch (sfk)</span>
<span class="lineNum">    9970 </span>            :     {
<span class="lineNum">    9971 </span><span class="lineCov">     944111 :     case sfk_constructor:</span>
<span class="lineNum">    9972 </span><span class="lineCov">     944111 :       if (type)</span>
<span class="lineNum">    9973 </span><span class="lineCov">         12 :         error (&quot;return type specification for constructor invalid&quot;);</span>
<span class="lineNum">    9974 </span><span class="lineCov">     944099 :       else if (type_quals != TYPE_UNQUALIFIED)</span>
<span class="lineNum">    9975 </span><span class="lineCov">         15 :         error_at (smallest_type_quals_location (type_quals, locations),</span>
<span class="lineNum">    9976 </span>            :                   &quot;qualifiers are not allowed on constructor declaration&quot;);
<span class="lineNum">    9977 </span>            : 
<span class="lineNum">    9978 </span><span class="lineCov">     944111 :       if (targetm.cxx.cdtor_returns_this ())</span>
<span class="lineNum">    9979 </span><span class="lineNoCov">          0 :         type = build_pointer_type (optype);</span>
<span class="lineNum">    9980 </span>            :       else
<span class="lineNum">    9981 </span><span class="lineCov">     944111 :         type = void_type_node;</span>
<span class="lineNum">    9982 </span>            :       break;
<span class="lineNum">    9983 </span>            : 
<span class="lineNum">    9984 </span><span class="lineCov">     169672 :     case sfk_destructor:</span>
<span class="lineNum">    9985 </span><span class="lineCov">     169672 :       if (type)</span>
<span class="lineNum">    9986 </span><span class="lineCov">          9 :         error (&quot;return type specification for destructor invalid&quot;);</span>
<span class="lineNum">    9987 </span><span class="lineCov">     169663 :       else if (type_quals != TYPE_UNQUALIFIED)</span>
<span class="lineNum">    9988 </span><span class="lineNoCov">          0 :         error_at (smallest_type_quals_location (type_quals, locations),</span>
<span class="lineNum">    9989 </span>            :                   &quot;qualifiers are not allowed on destructor declaration&quot;);
<span class="lineNum">    9990 </span>            : 
<span class="lineNum">    9991 </span>            :       /* We can't use the proper return type here because we run into
<span class="lineNum">    9992 </span>            :          problems with ambiguous bases and covariant returns.  */
<span class="lineNum">    9993 </span><span class="lineCov">     169672 :       if (targetm.cxx.cdtor_returns_this ())</span>
<span class="lineNum">    9994 </span><span class="lineNoCov">          0 :         type = build_pointer_type (void_type_node);</span>
<span class="lineNum">    9995 </span>            :       else
<span class="lineNum">    9996 </span><span class="lineCov">     169672 :         type = void_type_node;</span>
<span class="lineNum">    9997 </span>            :       break;
<span class="lineNum">    9998 </span>            : 
<span class="lineNum">    9999 </span><span class="lineCov">      25731 :     case sfk_conversion:</span>
<span class="lineNum">   10000 </span><span class="lineCov">      25731 :       if (type)</span>
<span class="lineNum">   10001 </span><span class="lineCov">         15 :         error (&quot;return type specified for %&lt;operator %T%&gt;&quot;, optype);</span>
<span class="lineNum">   10002 </span><span class="lineCov">      25716 :       else if (type_quals != TYPE_UNQUALIFIED)</span>
<span class="lineNum">   10003 </span><span class="lineCov">          3 :         error_at (smallest_type_quals_location (type_quals, locations),</span>
<span class="lineNum">   10004 </span>            :                   &quot;qualifiers are not allowed on declaration of &quot;
<span class="lineNum">   10005 </span>            :                   &quot;%&lt;operator %T%&gt;&quot;, optype);
<span class="lineNum">   10006 </span>            : 
<span class="lineNum">   10007 </span>            :       type = optype;
<span class="lineNum">   10008 </span>            :       break;
<span class="lineNum">   10009 </span>            : 
<span class="lineNum">   10010 </span><span class="lineCov">       6603 :     case sfk_deduction_guide:</span>
<span class="lineNum">   10011 </span><span class="lineCov">       6603 :       if (type)</span>
<span class="lineNum">   10012 </span><span class="lineNoCov">          0 :         error (&quot;return type specified for deduction guide&quot;);</span>
<span class="lineNum">   10013 </span><span class="lineCov">       6603 :       else if (type_quals != TYPE_UNQUALIFIED)</span>
<span class="lineNum">   10014 </span><span class="lineNoCov">          0 :         error_at (smallest_type_quals_location (type_quals, locations),</span>
<span class="lineNum">   10015 </span>            :                   &quot;qualifiers are not allowed on declaration of &quot;
<span class="lineNum">   10016 </span>            :                   &quot;deduction guide&quot;);
<span class="lineNum">   10017 </span><span class="lineCov">       6603 :       if (TREE_CODE (optype) == TEMPLATE_TEMPLATE_PARM)</span>
<span class="lineNum">   10018 </span>            :         {
<span class="lineNum">   10019 </span><span class="lineCov">          1 :           error (&quot;template template parameter %qT in declaration of &quot;</span>
<span class="lineNum">   10020 </span>            :                  &quot;deduction guide&quot;, optype);
<span class="lineNum">   10021 </span><span class="lineCov">          1 :           type = error_mark_node;</span>
<span class="lineNum">   10022 </span>            :         }
<span class="lineNum">   10023 </span>            :       else
<span class="lineNum">   10024 </span><span class="lineCov">       6602 :         type = make_template_placeholder (CLASSTYPE_TI_TEMPLATE (optype));</span>
<span class="lineNum">   10025 </span><span class="lineCov">     158472 :       for (int i = 0; i &lt; ds_last; ++i)</span>
<span class="lineNum">   10026 </span><span class="lineCov">     151869 :         if (i != ds_explicit &amp;&amp; locations[i])</span>
<span class="lineNum">   10027 </span><span class="lineCov">          1 :           error_at (locations[i],</span>
<span class="lineNum">   10028 </span><span class="lineCov">       6603 :                     &quot;decl-specifier in declaration of deduction guide&quot;);</span>
<span class="lineNum">   10029 </span>            :       break;
<span class="lineNum">   10030 </span>            : 
<span class="lineNum">   10031 </span><span class="lineNoCov">          0 :     default:</span>
<span class="lineNum">   10032 </span><span class="lineNoCov">          0 :       gcc_unreachable ();</span>
<span class="lineNum">   10033 </span>            :     }
<span class="lineNum">   10034 </span>            : 
<span class="lineNum">   10035 </span><span class="lineCov">    1146117 :   return type;</span>
<span class="lineNum">   10036 </span>            : }
<span class="lineNum">   10037 </span>            : 
<span class="lineNum">   10038 </span>            : /* A variable or data member (whose unqualified name is IDENTIFIER)
<span class="lineNum">   10039 </span>            :    has been declared with the indicated TYPE.  If the TYPE is not
<span class="lineNum">   10040 </span>            :    acceptable, issue an error message and return a type to use for
<span class="lineNum">   10041 </span>            :    error-recovery purposes.  */
<a name="10042"><span class="lineNum">   10042 </span>            : </a>
<span class="lineNum">   10043 </span>            : tree
<span class="lineNum">   10044 </span><span class="lineCov">   16716712 : check_var_type (tree identifier, tree type)</span>
<span class="lineNum">   10045 </span>            : {
<span class="lineNum">   10046 </span><span class="lineCov">   16716712 :   if (VOID_TYPE_P (type))</span>
<span class="lineNum">   10047 </span>            :     {
<span class="lineNum">   10048 </span><span class="lineCov">         66 :       if (!identifier)</span>
<span class="lineNum">   10049 </span><span class="lineNoCov">          0 :         error (&quot;unnamed variable or field declared void&quot;);</span>
<span class="lineNum">   10050 </span><span class="lineCov">         66 :       else if (identifier_p (identifier))</span>
<span class="lineNum">   10051 </span>            :         {
<span class="lineNum">   10052 </span><span class="lineCov">        198 :           gcc_assert (!IDENTIFIER_ANY_OP_P (identifier));</span>
<span class="lineNum">   10053 </span><span class="lineCov">         66 :           error (&quot;variable or field %qE declared void&quot;, identifier);</span>
<span class="lineNum">   10054 </span>            :         }
<span class="lineNum">   10055 </span>            :       else
<span class="lineNum">   10056 </span><span class="lineNoCov">          0 :         error (&quot;variable or field declared void&quot;);</span>
<span class="lineNum">   10057 </span><span class="lineCov">         66 :       type = error_mark_node;</span>
<span class="lineNum">   10058 </span>            :     }
<span class="lineNum">   10059 </span>            : 
<span class="lineNum">   10060 </span><span class="lineCov">   16716712 :   return type;</span>
<span class="lineNum">   10061 </span>            : }
<span class="lineNum">   10062 </span>            : 
<span class="lineNum">   10063 </span>            : /* Handle declaring DECL as an inline variable.  */
<a name="10064"><span class="lineNum">   10064 </span>            : </a>
<span class="lineNum">   10065 </span>            : static void
<span class="lineNum">   10066 </span><span class="lineCov">      55773 : mark_inline_variable (tree decl, location_t loc)</span>
<span class="lineNum">   10067 </span>            : {
<span class="lineNum">   10068 </span><span class="lineCov">      55773 :   bool inlinep = true;</span>
<span class="lineNum">   10069 </span><span class="lineCov">      55773 :   if (! toplevel_bindings_p ())</span>
<span class="lineNum">   10070 </span>            :     {
<span class="lineNum">   10071 </span><span class="lineCov">          4 :       error_at (loc, &quot;%&lt;inline%&gt; specifier invalid for variable &quot;</span>
<span class="lineNum">   10072 </span>            :                 &quot;%qD declared at block scope&quot;, decl);
<span class="lineNum">   10073 </span><span class="lineCov">          4 :       inlinep = false;</span>
<span class="lineNum">   10074 </span>            :     }
<span class="lineNum">   10075 </span><span class="lineCov">      55769 :   else if (cxx_dialect &lt; cxx17)</span>
<span class="lineNum">   10076 </span><span class="lineCov">        105 :     pedwarn (loc, 0, &quot;inline variables are only available &quot;</span>
<span class="lineNum">   10077 </span>            :              &quot;with -std=c++17 or -std=gnu++17&quot;);
<span class="lineNum">   10078 </span><span class="lineCov">        109 :   if (inlinep)</span>
<span class="lineNum">   10079 </span>            :     {
<span class="lineNum">   10080 </span><span class="lineCov">      55769 :       retrofit_lang_decl (decl);</span>
<span class="lineNum">   10081 </span><span class="lineCov">      55769 :       SET_DECL_VAR_DECLARED_INLINE_P (decl);</span>
<span class="lineNum">   10082 </span>            :     }
<span class="lineNum">   10083 </span><span class="lineCov">      55773 : }</span>
<span class="lineNum">   10084 </span>            : 
<span class="lineNum">   10085 </span>            : 
<span class="lineNum">   10086 </span>            : /* Assign a typedef-given name to a class or enumeration type declared
<span class="lineNum">   10087 </span>            :    as anonymous at first.  This was split out of grokdeclarator
<span class="lineNum">   10088 </span>            :    because it is also used in libcc1.  */
<a name="10089"><span class="lineNum">   10089 </span>            : </a>
<span class="lineNum">   10090 </span>            : void
<span class="lineNum">   10091 </span><span class="lineCov">      62657 : name_unnamed_type (tree type, tree decl)</span>
<span class="lineNum">   10092 </span>            : {
<span class="lineNum">   10093 </span><span class="lineCov">      62657 :   gcc_assert (TYPE_UNNAMED_P (type));</span>
<span class="lineNum">   10094 </span>            : 
<span class="lineNum">   10095 </span>            :   /* Replace the anonymous name with the real name everywhere.  */
<span class="lineNum">   10096 </span><span class="lineCov">     186844 :   for (tree t = TYPE_MAIN_VARIANT (type); t; t = TYPE_NEXT_VARIANT (t))</span>
<span class="lineNum">   10097 </span>            :     {
<span class="lineNum">   10098 </span><span class="lineCov">     124187 :       if (anon_aggrname_p (TYPE_IDENTIFIER (t)))</span>
<span class="lineNum">   10099 </span>            :         /* We do not rename the debug info representing the
<span class="lineNum">   10100 </span>            :            unnamed tagged type because the standard says in
<span class="lineNum">   10101 </span>            :            [dcl.typedef] that the naming applies only for
<span class="lineNum">   10102 </span>            :            linkage purposes.  */
<span class="lineNum">   10103 </span>            :         /*debug_hooks-&gt;set_name (t, decl);*/
<span class="lineNum">   10104 </span><span class="lineCov">     124187 :         TYPE_NAME (t) = decl;</span>
<span class="lineNum">   10105 </span>            :     }
<span class="lineNum">   10106 </span>            : 
<span class="lineNum">   10107 </span><span class="lineCov">      62657 :   if (TYPE_LANG_SPECIFIC (type))</span>
<span class="lineNum">   10108 </span><span class="lineCov">     123060 :     TYPE_WAS_UNNAMED (type) = 1;</span>
<span class="lineNum">   10109 </span>            : 
<span class="lineNum">   10110 </span>            :   /* If this is a typedef within a template class, the nested
<span class="lineNum">   10111 </span>            :      type is a (non-primary) template.  The name for the
<span class="lineNum">   10112 </span>            :      template needs updating as well.  */
<span class="lineNum">   10113 </span><span class="lineCov">     111549 :   if (TYPE_LANG_SPECIFIC (type) &amp;&amp; CLASSTYPE_TEMPLATE_INFO (type))</span>
<span class="lineNum">   10114 </span><span class="lineCov">         45 :     DECL_NAME (CLASSTYPE_TI_TEMPLATE (type))</span>
<span class="lineNum">   10115 </span><span class="lineCov">        135 :       = TYPE_IDENTIFIER (type);</span>
<span class="lineNum">   10116 </span>            : 
<span class="lineNum">   10117 </span>            :   /* Adjust linkage now that we aren't unnamed anymore.  */
<span class="lineNum">   10118 </span><span class="lineCov">      62657 :   reset_type_linkage (type);</span>
<span class="lineNum">   10119 </span>            : 
<span class="lineNum">   10120 </span>            :   /* FIXME remangle member functions; member functions of a
<span class="lineNum">   10121 </span>            :      type with external linkage have external linkage.  */
<span class="lineNum">   10122 </span>            : 
<span class="lineNum">   10123 </span>            :   /* Check that our job is done, and that it would fail if we
<span class="lineNum">   10124 </span>            :      attempted to do it again.  */
<span class="lineNum">   10125 </span><span class="lineCov">      62657 :   gcc_assert (!TYPE_UNNAMED_P (type));</span>
<span class="lineNum">   10126 </span><span class="lineCov">      62657 : }</span>
<span class="lineNum">   10127 </span>            : 
<span class="lineNum">   10128 </span>            : /* Given declspecs and a declarator (abstract or otherwise), determine
<span class="lineNum">   10129 </span>            :    the name and type of the object declared and construct a DECL node
<span class="lineNum">   10130 </span>            :    for it.
<span class="lineNum">   10131 </span>            : 
<span class="lineNum">   10132 </span>            :    DECLSPECS points to the representation of declaration-specifier
<span class="lineNum">   10133 </span>            :    sequence that precedes declarator.
<span class="lineNum">   10134 </span>            : 
<span class="lineNum">   10135 </span>            :    DECL_CONTEXT says which syntactic context this declaration is in:
<span class="lineNum">   10136 </span>            :      NORMAL for most contexts.  Make a VAR_DECL or FUNCTION_DECL or TYPE_DECL.
<span class="lineNum">   10137 </span>            :      FUNCDEF for a function definition.  Like NORMAL but a few different
<span class="lineNum">   10138 </span>            :       error messages in each case.  Return value may be zero meaning
<span class="lineNum">   10139 </span>            :       this definition is too screwy to try to parse.
<span class="lineNum">   10140 </span>            :      MEMFUNCDEF for a function definition.  Like FUNCDEF but prepares to
<span class="lineNum">   10141 </span>            :       handle member functions (which have FIELD context).
<span class="lineNum">   10142 </span>            :       Return value may be zero meaning this definition is too screwy to
<span class="lineNum">   10143 </span>            :       try to parse.
<span class="lineNum">   10144 </span>            :      PARM for a parameter declaration (either within a function prototype
<span class="lineNum">   10145 </span>            :       or before a function body).  Make a PARM_DECL, or return void_type_node.
<span class="lineNum">   10146 </span>            :      TPARM for a template parameter declaration.
<span class="lineNum">   10147 </span>            :      CATCHPARM for a parameter declaration before a catch clause.
<span class="lineNum">   10148 </span>            :      TYPENAME if for a typename (in a cast or sizeof).
<span class="lineNum">   10149 </span>            :       Don't make a DECL node; just return the ..._TYPE node.
<span class="lineNum">   10150 </span>            :      FIELD for a struct or union field; make a FIELD_DECL.
<span class="lineNum">   10151 </span>            :      BITFIELD for a field with specified width.
<span class="lineNum">   10152 </span>            : 
<span class="lineNum">   10153 </span>            :    INITIALIZED is as for start_decl.
<span class="lineNum">   10154 </span>            : 
<span class="lineNum">   10155 </span>            :    ATTRLIST is a pointer to the list of attributes, which may be NULL
<span class="lineNum">   10156 </span>            :    if there are none; *ATTRLIST may be modified if attributes from inside
<span class="lineNum">   10157 </span>            :    the declarator should be applied to the declaration.
<span class="lineNum">   10158 </span>            : 
<span class="lineNum">   10159 </span>            :    When this function is called, scoping variables (such as
<span class="lineNum">   10160 </span>            :    CURRENT_CLASS_TYPE) should reflect the scope in which the
<span class="lineNum">   10161 </span>            :    declaration occurs, not the scope in which the new declaration will
<span class="lineNum">   10162 </span>            :    be placed.  For example, on:
<span class="lineNum">   10163 </span>            : 
<span class="lineNum">   10164 </span>            :      void S::f() { ... }
<span class="lineNum">   10165 </span>            : 
<span class="lineNum">   10166 </span>            :    when grokdeclarator is called for `S::f', the CURRENT_CLASS_TYPE
<span class="lineNum">   10167 </span>            :    should not be `S'.
<span class="lineNum">   10168 </span>            : 
<span class="lineNum">   10169 </span>            :    Returns a DECL (if a declarator is present), a TYPE (if there is no
<span class="lineNum">   10170 </span>            :    declarator, in cases like &quot;struct S;&quot;), or the ERROR_MARK_NODE if an
<span class="lineNum">   10171 </span>            :    error occurs. */
<a name="10172"><span class="lineNum">   10172 </span>            : </a>
<span class="lineNum">   10173 </span>            : tree
<span class="lineNum">   10174 </span><span class="lineCov">   51841193 : grokdeclarator (const cp_declarator *declarator,</span>
<span class="lineNum">   10175 </span>            :                 cp_decl_specifier_seq *declspecs,
<span class="lineNum">   10176 </span>            :                 enum decl_context decl_context,
<span class="lineNum">   10177 </span>            :                 int initialized,
<span class="lineNum">   10178 </span>            :                 tree* attrlist)
<span class="lineNum">   10179 </span>            : {
<span class="lineNum">   10180 </span><span class="lineCov">   51841193 :   tree type = NULL_TREE;</span>
<span class="lineNum">   10181 </span><span class="lineCov">   51841193 :   int longlong = 0;</span>
<span class="lineNum">   10182 </span><span class="lineCov">   51841193 :   int explicit_intN = 0;</span>
<span class="lineNum">   10183 </span><span class="lineCov">   51841193 :   int virtualp, explicitp, friendp, inlinep, staticp;</span>
<span class="lineNum">   10184 </span><span class="lineCov">   51841193 :   int explicit_int = 0;</span>
<span class="lineNum">   10185 </span><span class="lineCov">   51841193 :   int explicit_char = 0;</span>
<span class="lineNum">   10186 </span><span class="lineCov">   51841193 :   int defaulted_int = 0;</span>
<span class="lineNum">   10187 </span>            : 
<span class="lineNum">   10188 </span><span class="lineCov">   51841193 :   tree typedef_decl = NULL_TREE;</span>
<span class="lineNum">   10189 </span><span class="lineCov">   51841193 :   const char *name = NULL;</span>
<span class="lineNum">   10190 </span><span class="lineCov">   51841193 :   tree typedef_type = NULL_TREE;</span>
<span class="lineNum">   10191 </span>            :   /* True if this declarator is a function definition.  */
<span class="lineNum">   10192 </span><span class="lineCov">   51841193 :   bool funcdef_flag = false;</span>
<span class="lineNum">   10193 </span><span class="lineCov">   51841193 :   cp_declarator_kind innermost_code = cdk_error;</span>
<span class="lineNum">   10194 </span><span class="lineCov">   51841193 :   int bitfield = 0;</span>
<span class="lineNum">   10195 </span>            : #if 0
<span class="lineNum">   10196 </span>            :   /* See the code below that used this.  */
<span class="lineNum">   10197 </span>            :   tree decl_attr = NULL_TREE;
<span class="lineNum">   10198 </span>            : #endif
<span class="lineNum">   10199 </span>            : 
<span class="lineNum">   10200 </span>            :   /* Keep track of what sort of function is being processed
<span class="lineNum">   10201 </span>            :      so that we can warn about default return values, or explicit
<span class="lineNum">   10202 </span>            :      return values which do not match prescribed defaults.  */
<span class="lineNum">   10203 </span><span class="lineCov">   51841193 :   special_function_kind sfk = sfk_none;</span>
<span class="lineNum">   10204 </span>            : 
<span class="lineNum">   10205 </span><span class="lineCov">   51841193 :   tree dname = NULL_TREE;</span>
<span class="lineNum">   10206 </span><span class="lineCov">   51841193 :   tree ctor_return_type = NULL_TREE;</span>
<span class="lineNum">   10207 </span><span class="lineCov">   51841193 :   enum overload_flags flags = NO_SPECIAL;</span>
<span class="lineNum">   10208 </span>            :   /* cv-qualifiers that apply to the declarator, for a declaration of
<span class="lineNum">   10209 </span>            :      a member function.  */
<span class="lineNum">   10210 </span><span class="lineCov">   51841193 :   cp_cv_quals memfn_quals = TYPE_UNQUALIFIED;</span>
<span class="lineNum">   10211 </span>            :   /* virt-specifiers that apply to the declarator, for a declaration of
<span class="lineNum">   10212 </span>            :      a member function.  */
<span class="lineNum">   10213 </span><span class="lineCov">   51841193 :   cp_virt_specifiers virt_specifiers = VIRT_SPEC_UNSPECIFIED;</span>
<span class="lineNum">   10214 </span>            :   /* ref-qualifier that applies to the declarator, for a declaration of
<span class="lineNum">   10215 </span>            :      a member function.  */
<span class="lineNum">   10216 </span><span class="lineCov">   51841193 :   cp_ref_qualifier rqual = REF_QUAL_NONE;</span>
<span class="lineNum">   10217 </span>            :   /* cv-qualifiers that apply to the type specified by the DECLSPECS.  */
<span class="lineNum">   10218 </span><span class="lineCov">   51841193 :   int type_quals = TYPE_UNQUALIFIED;</span>
<span class="lineNum">   10219 </span><span class="lineCov">   51841193 :   tree raises = NULL_TREE;</span>
<span class="lineNum">   10220 </span><span class="lineCov">   51841193 :   int template_count = 0;</span>
<span class="lineNum">   10221 </span><span class="lineCov">   51841193 :   tree returned_attrs = NULL_TREE;</span>
<span class="lineNum">   10222 </span><span class="lineCov">   51841193 :   tree parms = NULL_TREE;</span>
<span class="lineNum">   10223 </span><span class="lineCov">   51841193 :   const cp_declarator *id_declarator;</span>
<span class="lineNum">   10224 </span>            :   /* The unqualified name of the declarator; either an
<span class="lineNum">   10225 </span>            :      IDENTIFIER_NODE, BIT_NOT_EXPR, or TEMPLATE_ID_EXPR.  */
<span class="lineNum">   10226 </span><span class="lineCov">   51841193 :   tree unqualified_id;</span>
<span class="lineNum">   10227 </span>            :   /* The class type, if any, in which this entity is located,
<span class="lineNum">   10228 </span>            :      or NULL_TREE if none.  Note that this value may be different from
<span class="lineNum">   10229 </span>            :      the current class type; for example if an attempt is made to declare
<span class="lineNum">   10230 </span>            :      &quot;A::f&quot; inside &quot;B&quot;, this value will be &quot;A&quot;.  */
<span class="lineNum">   10231 </span><span class="lineCov">   51841193 :   tree ctype = current_class_type;</span>
<span class="lineNum">   10232 </span>            :   /* The NAMESPACE_DECL for the namespace in which this entity is
<span class="lineNum">   10233 </span>            :      located.  If an unqualified name is used to declare the entity,
<span class="lineNum">   10234 </span>            :      this value will be NULL_TREE, even if the entity is located at
<span class="lineNum">   10235 </span>            :      namespace scope.  */
<span class="lineNum">   10236 </span><span class="lineCov">   51841193 :   tree in_namespace = NULL_TREE;</span>
<span class="lineNum">   10237 </span><span class="lineCov">   51841193 :   cp_storage_class storage_class;</span>
<span class="lineNum">   10238 </span><span class="lineCov">   51841193 :   bool unsigned_p, signed_p, short_p, long_p, thread_p;</span>
<span class="lineNum">   10239 </span><span class="lineCov">   51841193 :   bool type_was_error_mark_node = false;</span>
<span class="lineNum">   10240 </span><span class="lineCov">   51841193 :   bool parameter_pack_p = declarator ? declarator-&gt;parameter_pack_p : false;</span>
<span class="lineNum">   10241 </span><span class="lineCov">   51841193 :   bool template_type_arg = false;</span>
<span class="lineNum">   10242 </span><span class="lineCov">   51841193 :   bool template_parm_flag = false;</span>
<span class="lineNum">   10243 </span><span class="lineCov">   51841193 :   bool typedef_p = decl_spec_seq_has_spec_p (declspecs, ds_typedef);</span>
<span class="lineNum">   10244 </span><span class="lineCov">   51841193 :   bool constexpr_p = decl_spec_seq_has_spec_p (declspecs, ds_constexpr);</span>
<span class="lineNum">   10245 </span><span class="lineCov">   51841193 :   bool late_return_type_p = false;</span>
<span class="lineNum">   10246 </span><span class="lineCov">   51841193 :   bool array_parameter_p = false;</span>
<span class="lineNum">   10247 </span><span class="lineCov">   51841193 :   source_location saved_loc = input_location;</span>
<span class="lineNum">   10248 </span><span class="lineCov">   51841193 :   tree reqs = NULL_TREE;</span>
<span class="lineNum">   10249 </span>            : 
<span class="lineNum">   10250 </span><span class="lineCov">   51841193 :   signed_p = decl_spec_seq_has_spec_p (declspecs, ds_signed);</span>
<span class="lineNum">   10251 </span><span class="lineCov">   51841193 :   unsigned_p = decl_spec_seq_has_spec_p (declspecs, ds_unsigned);</span>
<span class="lineNum">   10252 </span><span class="lineCov">   51841193 :   short_p = decl_spec_seq_has_spec_p (declspecs, ds_short);</span>
<span class="lineNum">   10253 </span><span class="lineCov">   51841193 :   long_p = decl_spec_seq_has_spec_p (declspecs, ds_long);</span>
<span class="lineNum">   10254 </span><span class="lineCov">   51841193 :   longlong = decl_spec_seq_has_spec_p (declspecs, ds_long_long);</span>
<span class="lineNum">   10255 </span><span class="lineCov">   51841193 :   explicit_intN = declspecs-&gt;explicit_intN_p;</span>
<span class="lineNum">   10256 </span><span class="lineCov">   51841193 :   thread_p = decl_spec_seq_has_spec_p (declspecs, ds_thread);</span>
<span class="lineNum">   10257 </span>            : 
<span class="lineNum">   10258 </span>            :   // Was concept_p specified? Note that ds_concept
<span class="lineNum">   10259 </span>            :   // implies ds_constexpr!
<span class="lineNum">   10260 </span><span class="lineCov">   51841193 :   bool concept_p = decl_spec_seq_has_spec_p (declspecs, ds_concept);</span>
<span class="lineNum">   10261 </span><span class="lineCov">   51841193 :   if (concept_p)</span>
<span class="lineNum">   10262 </span><span class="lineCov">        328 :     constexpr_p = true;</span>
<span class="lineNum">   10263 </span>            : 
<span class="lineNum">   10264 </span><span class="lineCov">   51841193 :   if (decl_spec_seq_has_spec_p (declspecs, ds_const))</span>
<span class="lineNum">   10265 </span><span class="lineCov">    5495339 :     type_quals |= TYPE_QUAL_CONST;</span>
<span class="lineNum">   10266 </span><span class="lineCov">   51841193 :   if (decl_spec_seq_has_spec_p (declspecs, ds_volatile))</span>
<span class="lineNum">   10267 </span><span class="lineCov">     120553 :     type_quals |= TYPE_QUAL_VOLATILE;</span>
<span class="lineNum">   10268 </span><span class="lineCov">   51841193 :   if (decl_spec_seq_has_spec_p (declspecs, ds_restrict))</span>
<span class="lineNum">   10269 </span><span class="lineCov">         16 :     type_quals |= TYPE_QUAL_RESTRICT;</span>
<span class="lineNum">   10270 </span>            : 
<span class="lineNum">   10271 </span><span class="lineCov">   51841193 :   if (decl_context == FUNCDEF)</span>
<span class="lineNum">   10272 </span>            :     funcdef_flag = true, decl_context = NORMAL;
<span class="lineNum">   10273 </span><span class="lineCov">   49232877 :   else if (decl_context == MEMFUNCDEF)</span>
<span class="lineNum">   10274 </span>            :     funcdef_flag = true, decl_context = FIELD;
<span class="lineNum">   10275 </span><span class="lineCov">   46169809 :   else if (decl_context == BITFIELD)</span>
<span class="lineNum">   10276 </span>            :     bitfield = 1, decl_context = FIELD;
<span class="lineNum">   10277 </span><span class="lineCov">   46133205 :   else if (decl_context == TEMPLATE_TYPE_ARG)</span>
<span class="lineNum">   10278 </span>            :     template_type_arg = true, decl_context = TYPENAME;
<span class="lineNum">   10279 </span><span class="lineCov">   34039937 :   else if (decl_context == TPARM)</span>
<span class="lineNum">   10280 </span><span class="lineCov">     735475 :     template_parm_flag = true, decl_context = PARM;</span>
<span class="lineNum">   10281 </span>            : 
<span class="lineNum">   10282 </span><span class="lineCov">   51841193 :   if (initialized &gt; 1)</span>
<span class="lineNum">   10283 </span><span class="lineCov">      13904 :     funcdef_flag = true;</span>
<span class="lineNum">   10284 </span>            : 
<span class="lineNum">   10285 </span><span class="lineCov">  155523579 :   location_t typespec_loc = smallest_type_quals_location (type_quals,</span>
<span class="lineNum">   10286 </span><span class="lineCov">   51841193 :                                                       declspecs-&gt;locations);</span>
<span class="lineNum">   10287 </span><span class="lineCov">   51841193 :   if (typespec_loc == UNKNOWN_LOCATION)</span>
<span class="lineNum">   10288 </span><span class="lineCov">   46277180 :     typespec_loc = declspecs-&gt;locations[ds_type_spec];</span>
<span class="lineNum">   10289 </span><span class="lineCov">   51841193 :   if (typespec_loc == UNKNOWN_LOCATION)</span>
<span class="lineNum">   10290 </span><span class="lineCov">    2685596 :     typespec_loc = input_location;</span>
<span class="lineNum">   10291 </span>            : 
<span class="lineNum">   10292 </span>            :   /* Look inside a declarator for the name being declared
<span class="lineNum">   10293 </span>            :      and get it as a string, for an error message.  */
<span class="lineNum">   10294 </span><span class="lineCov">   51841193 :   for (id_declarator = declarator;</span>
<span class="lineNum">   10295 </span><span class="lineCov">   73360141 :        id_declarator;</span>
<span class="lineNum">   10296 </span><span class="lineCov">   21518948 :        id_declarator = id_declarator-&gt;declarator)</span>
<span class="lineNum">   10297 </span>            :     {
<span class="lineNum">   10298 </span><span class="lineCov">   54025235 :       if (id_declarator-&gt;kind != cdk_id)</span>
<span class="lineNum">   10299 </span><span class="lineCov">   21519939 :         innermost_code = id_declarator-&gt;kind;</span>
<span class="lineNum">   10300 </span>            : 
<span class="lineNum">   10301 </span><span class="lineCov">   54025235 :       switch (id_declarator-&gt;kind)</span>
<span class="lineNum">   10302 </span>            :         {
<span class="lineNum">   10303 </span><span class="lineCov">   10411145 :         case cdk_function:</span>
<span class="lineNum">   10304 </span><span class="lineCov">   10411145 :           if (id_declarator-&gt;declarator</span>
<span class="lineNum">   10305 </span><span class="lineCov">   10302466 :               &amp;&amp; id_declarator-&gt;declarator-&gt;kind == cdk_id)</span>
<span class="lineNum">   10306 </span>            :             {
<span class="lineNum">   10307 </span><span class="lineCov">   10130973 :               sfk = id_declarator-&gt;declarator-&gt;u.id.sfk;</span>
<span class="lineNum">   10308 </span><span class="lineCov">   10130973 :               if (sfk == sfk_destructor)</span>
<span class="lineNum">   10309 </span><span class="lineCov">     169675 :                 flags = DTOR_FLAG;</span>
<span class="lineNum">   10310 </span>            :             }
<span class="lineNum">   10311 </span>            :           break;
<span class="lineNum">   10312 </span>            : 
<span class="lineNum">   10313 </span><span class="lineCov">   32505296 :         case cdk_id:</span>
<span class="lineNum">   10314 </span><span class="lineCov">   32505296 :           {</span>
<span class="lineNum">   10315 </span><span class="lineCov">   32505296 :             tree qualifying_scope = id_declarator-&gt;u.id.qualifying_scope;</span>
<span class="lineNum">   10316 </span><span class="lineCov">   32505296 :             tree decl = id_declarator-&gt;u.id.unqualified_name;</span>
<span class="lineNum">   10317 </span><span class="lineCov">   32505296 :             if (!decl)</span>
<span class="lineNum">   10318 </span>            :               break;
<span class="lineNum">   10319 </span><span class="lineCov">   32505296 :             if (qualifying_scope)</span>
<span class="lineNum">   10320 </span>            :               {
<span class="lineNum">   10321 </span><span class="lineCov">     474368 :                 if (check_for_bare_parameter_packs (qualifying_scope,</span>
<span class="lineNum">   10322 </span><span class="lineCov">     474368 :                                                     id_declarator-&gt;id_loc))</span>
<span class="lineNum">   10323 </span><span class="lineCov">          4 :                   return error_mark_node;</span>
<span class="lineNum">   10324 </span><span class="lineCov">     474364 :                 if (at_function_scope_p ())</span>
<span class="lineNum">   10325 </span>            :                   {
<span class="lineNum">   10326 </span>            :                     /* [dcl.meaning] 
<span class="lineNum">   10327 </span>            : 
<span class="lineNum">   10328 </span>            :                        A declarator-id shall not be qualified except
<span class="lineNum">   10329 </span>            :                        for ... 
<span class="lineNum">   10330 </span>            : 
<span class="lineNum">   10331 </span>            :                        None of the cases are permitted in block
<span class="lineNum">   10332 </span>            :                        scope.  */
<span class="lineNum">   10333 </span><span class="lineNoCov">          0 :                     if (qualifying_scope == global_namespace)</span>
<span class="lineNum">   10334 </span><span class="lineNoCov">          0 :                       error (&quot;invalid use of qualified-name %&lt;::%D%&gt;&quot;,</span>
<span class="lineNum">   10335 </span>            :                              decl);
<span class="lineNum">   10336 </span><span class="lineNoCov">          0 :                     else if (TYPE_P (qualifying_scope))</span>
<span class="lineNum">   10337 </span><span class="lineNoCov">          0 :                       error (&quot;invalid use of qualified-name %&lt;%T::%D%&gt;&quot;,</span>
<span class="lineNum">   10338 </span>            :                              qualifying_scope, decl);
<span class="lineNum">   10339 </span>            :                     else 
<span class="lineNum">   10340 </span><span class="lineNoCov">          0 :                       error (&quot;invalid use of qualified-name %&lt;%D::%D%&gt;&quot;,</span>
<span class="lineNum">   10341 </span>            :                              qualifying_scope, decl);
<span class="lineNum">   10342 </span><span class="lineNoCov">          0 :                     return error_mark_node;</span>
<span class="lineNum">   10343 </span>            :                   }
<span class="lineNum">   10344 </span><span class="lineCov">     474364 :                 else if (TYPE_P (qualifying_scope))</span>
<span class="lineNum">   10345 </span>            :                   {
<span class="lineNum">   10346 </span><span class="lineCov">     467031 :                     ctype = qualifying_scope;</span>
<span class="lineNum">   10347 </span><span class="lineCov">     467031 :                     if (!MAYBE_CLASS_TYPE_P (ctype))</span>
<span class="lineNum">   10348 </span>            :                       {
<span class="lineNum">   10349 </span><span class="lineCov">          5 :                         error (&quot;%q#T is not a class or a namespace&quot;, ctype);</span>
<span class="lineNum">   10350 </span><span class="lineCov">          5 :                         ctype = NULL_TREE;</span>
<span class="lineNum">   10351 </span>            :                       }
<span class="lineNum">   10352 </span><span class="lineCov">     467026 :                     else if (innermost_code != cdk_function</span>
<span class="lineNum">   10353 </span><span class="lineCov">      56744 :                              &amp;&amp; current_class_type</span>
<span class="lineNum">   10354 </span><span class="lineCov">     467040 :                              &amp;&amp; !uniquely_derived_from_p (ctype,</span>
<span class="lineNum">   10355 </span>            :                                                           current_class_type))
<span class="lineNum">   10356 </span>            :                       {
<span class="lineNum">   10357 </span><span class="lineCov">          8 :                         error (&quot;invalid use of qualified-name %&lt;%T::%D%&gt;&quot;,</span>
<span class="lineNum">   10358 </span>            :                                qualifying_scope, decl);
<span class="lineNum">   10359 </span><span class="lineCov">          8 :                         return error_mark_node;</span>
<span class="lineNum">   10360 </span>            :                       }
<span class="lineNum">   10361 </span>            :                   }
<span class="lineNum">   10362 </span><span class="lineCov">       7333 :                 else if (TREE_CODE (qualifying_scope) == NAMESPACE_DECL)</span>
<span class="lineNum">   10363 </span><span class="lineCov">       7306 :                   in_namespace = qualifying_scope;</span>
<span class="lineNum">   10364 </span>            :               }
<span class="lineNum">   10365 </span><span class="lineCov">   32505284 :             switch (TREE_CODE (decl))</span>
<span class="lineNum">   10366 </span>            :               {
<span class="lineNum">   10367 </span><span class="lineCov">     169690 :               case BIT_NOT_EXPR:</span>
<span class="lineNum">   10368 </span><span class="lineCov">     169690 :                 {</span>
<span class="lineNum">   10369 </span><span class="lineCov">     169690 :                   if (innermost_code != cdk_function)</span>
<span class="lineNum">   10370 </span>            :                     {
<span class="lineNum">   10371 </span><span class="lineCov">          6 :                       error (&quot;declaration of %qD as non-function&quot;, decl);</span>
<span class="lineNum">   10372 </span><span class="lineCov">          6 :                       return error_mark_node;</span>
<span class="lineNum">   10373 </span>            :                     }
<span class="lineNum">   10374 </span><span class="lineCov">     169684 :                   else if (!qualifying_scope</span>
<span class="lineNum">   10375 </span><span class="lineCov">     169684 :                            &amp;&amp; !(current_class_type &amp;&amp; at_class_scope_p ()))</span>
<span class="lineNum">   10376 </span>            :                     {
<span class="lineNum">   10377 </span><span class="lineCov">          9 :                       error (&quot;declaration of %qD as non-member&quot;, decl);</span>
<span class="lineNum">   10378 </span><span class="lineCov">          9 :                       return error_mark_node;</span>
<span class="lineNum">   10379 </span>            :                     }
<span class="lineNum">   10380 </span>            : 
<span class="lineNum">   10381 </span><span class="lineCov">     169675 :                   tree type = TREE_OPERAND (decl, 0);</span>
<span class="lineNum">   10382 </span><span class="lineCov">     169675 :                   if (TYPE_P (type))</span>
<span class="lineNum">   10383 </span><span class="lineCov">     169672 :                     type = constructor_name (type);</span>
<span class="lineNum">   10384 </span><span class="lineCov">     169675 :                   name = identifier_to_locale (IDENTIFIER_POINTER (type));</span>
<span class="lineNum">   10385 </span><span class="lineCov">     169675 :                   dname = decl;</span>
<span class="lineNum">   10386 </span>            :                 }
<span class="lineNum">   10387 </span><span class="lineCov">     169675 :                 break;</span>
<span class="lineNum">   10388 </span>            : 
<span class="lineNum">   10389 </span><span class="lineCov">      32783 :               case TEMPLATE_ID_EXPR:</span>
<span class="lineNum">   10390 </span><span class="lineCov">      32783 :                 {</span>
<span class="lineNum">   10391 </span><span class="lineCov">      32783 :                   tree fns = TREE_OPERAND (decl, 0);</span>
<span class="lineNum">   10392 </span>            : 
<span class="lineNum">   10393 </span><span class="lineCov">      32783 :                   dname = fns;</span>
<span class="lineNum">   10394 </span><span class="lineCov">      32783 :                   if (!identifier_p (dname))</span>
<span class="lineNum">   10395 </span><span class="lineCov">      32774 :                     dname = OVL_NAME (dname);</span>
<span class="lineNum">   10396 </span>            :                 }
<span class="lineNum">   10397 </span>            :                 /* Fall through.  */
<span class="lineNum">   10398 </span>            : 
<span class="lineNum">   10399 </span><span class="lineCov">   32335594 :               case IDENTIFIER_NODE:</span>
<span class="lineNum">   10400 </span><span class="lineCov">   32335594 :                 if (identifier_p (decl))</span>
<span class="lineNum">   10401 </span><span class="lineCov">   32302811 :                   dname = decl;</span>
<span class="lineNum">   10402 </span>            : 
<span class="lineNum">   10403 </span><span class="lineCov">   32335594 :                 if (IDENTIFIER_KEYWORD_P (dname))</span>
<span class="lineNum">   10404 </span>            :                   {
<span class="lineNum">   10405 </span><span class="lineNoCov">          0 :                     error (&quot;declarator-id missing; using reserved word %qD&quot;,</span>
<span class="lineNum">   10406 </span>            :                            dname);
<span class="lineNum">   10407 </span><span class="lineNoCov">          0 :                     name = identifier_to_locale (IDENTIFIER_POINTER (dname));</span>
<span class="lineNum">   10408 </span>            :                   }
<span class="lineNum">   10409 </span><span class="lineCov">  226349158 :                 else if (!IDENTIFIER_CONV_OP_P (dname))</span>
<span class="lineNum">   10410 </span><span class="lineCov">   64619722 :                   name = identifier_to_locale (IDENTIFIER_POINTER (dname));</span>
<span class="lineNum">   10411 </span>            :                 else
<span class="lineNum">   10412 </span>            :                   {
<span class="lineNum">   10413 </span><span class="lineCov">      25733 :                     gcc_assert (flags == NO_SPECIAL);</span>
<span class="lineNum">   10414 </span><span class="lineCov">      25733 :                     flags = TYPENAME_FLAG;</span>
<span class="lineNum">   10415 </span><span class="lineCov">      25733 :                     sfk = sfk_conversion;</span>
<span class="lineNum">   10416 </span><span class="lineCov">      25733 :                     tree glob = get_global_binding (dname);</span>
<span class="lineNum">   10417 </span><span class="lineCov">      25733 :                     if (glob &amp;&amp; TREE_CODE (glob) == TYPE_DECL)</span>
<span class="lineNum">   10418 </span><span class="lineNoCov">          0 :                       name = identifier_to_locale (IDENTIFIER_POINTER (dname));</span>
<span class="lineNum">   10419 </span>            :                     else
<span class="lineNum">   10420 </span>            :                       name = &quot;&lt;invalid operator&gt;&quot;;
<span class="lineNum">   10421 </span>            :                   }
<span class="lineNum">   10422 </span>            :                 break;
<span class="lineNum">   10423 </span>            : 
<span class="lineNum">   10424 </span><span class="lineNoCov">          0 :               default:</span>
<span class="lineNum">   10425 </span><span class="lineNoCov">          0 :                 gcc_unreachable ();</span>
<span class="lineNum">   10426 </span>            :               }
<span class="lineNum">   10427 </span>            :             break;
<span class="lineNum">   10428 </span>            :           }
<span class="lineNum">   10429 </span>            : 
<span class="lineNum">   10430 </span>            :         case cdk_array:
<span class="lineNum">   10431 </span>            :         case cdk_pointer:
<span class="lineNum">   10432 </span>            :         case cdk_reference:
<span class="lineNum">   10433 </span>            :         case cdk_ptrmem:
<span class="lineNum">   10434 </span>            :           break;
<span class="lineNum">   10435 </span>            : 
<span class="lineNum">   10436 </span><span class="lineCov">        315 :         case cdk_decomp:</span>
<span class="lineNum">   10437 </span><span class="lineCov">        315 :           name = &quot;structured binding&quot;;</span>
<span class="lineNum">   10438 </span><span class="lineCov">        315 :           break;</span>
<span class="lineNum">   10439 </span>            : 
<span class="lineNum">   10440 </span><span class="lineCov">        991 :         case cdk_error:</span>
<span class="lineNum">   10441 </span><span class="lineCov">        991 :           return error_mark_node;</span>
<span class="lineNum">   10442 </span>            : 
<span class="lineNum">   10443 </span><span class="lineNoCov">          0 :         default:</span>
<span class="lineNum">   10444 </span><span class="lineNoCov">          0 :           gcc_unreachable ();</span>
<span class="lineNum">   10445 </span>            :         }
<span class="lineNum">   10446 </span><span class="lineCov">   54024217 :       if (id_declarator-&gt;kind == cdk_id)</span>
<span class="lineNum">   10447 </span>            :         break;
<span class="lineNum">   10448 </span>            :     }
<span class="lineNum">   10449 </span>            : 
<span class="lineNum">   10450 </span>            :   /* [dcl.fct.edf]
<span class="lineNum">   10451 </span>            : 
<span class="lineNum">   10452 </span>            :      The declarator in a function-definition shall have the form
<span class="lineNum">   10453 </span>            :      D1 ( parameter-declaration-clause) ...  */
<span class="lineNum">   10454 </span><span class="lineCov">   51840175 :   if (funcdef_flag &amp;&amp; innermost_code != cdk_function)</span>
<span class="lineNum">   10455 </span>            :     {
<span class="lineNum">   10456 </span><span class="lineCov">          3 :       error (&quot;function definition does not declare parameters&quot;);</span>
<span class="lineNum">   10457 </span><span class="lineCov">          3 :       return error_mark_node;</span>
<span class="lineNum">   10458 </span>            :     }
<span class="lineNum">   10459 </span>            : 
<span class="lineNum">   10460 </span><span class="lineCov">  103680344 :   if (flags == TYPENAME_FLAG</span>
<span class="lineNum">   10461 </span><span class="lineCov">   51840172 :       &amp;&amp; innermost_code != cdk_function</span>
<span class="lineNum">   10462 </span><span class="lineCov">          2 :       &amp;&amp; ! (ctype &amp;&amp; !declspecs-&gt;any_specifiers_p))</span>
<span class="lineNum">   10463 </span>            :     {
<span class="lineNum">   10464 </span><span class="lineCov">          2 :       error (&quot;declaration of %qD as non-function&quot;, dname);</span>
<span class="lineNum">   10465 </span><span class="lineCov">          2 :       return error_mark_node;</span>
<span class="lineNum">   10466 </span>            :     }
<span class="lineNum">   10467 </span>            : 
<span class="lineNum">   10468 </span><span class="lineCov">   51840170 :   if (dname &amp;&amp; identifier_p (dname))</span>
<span class="lineNum">   10469 </span>            :     {
<span class="lineNum">   10470 </span><span class="lineCov">   32335589 :       if (UDLIT_OPER_P (dname)</span>
<span class="lineNum">   10471 </span><span class="lineCov">   32335589 :           &amp;&amp; innermost_code != cdk_function)</span>
<span class="lineNum">   10472 </span>            :         {
<span class="lineNum">   10473 </span><span class="lineCov">          4 :           error (&quot;declaration of %qD as non-function&quot;, dname);</span>
<span class="lineNum">   10474 </span><span class="lineCov">          4 :           return error_mark_node;</span>
<span class="lineNum">   10475 </span>            :         }
<span class="lineNum">   10476 </span>            : 
<span class="lineNum">   10477 </span><span class="lineCov">   97006755 :       if (IDENTIFIER_ANY_OP_P (dname))</span>
<span class="lineNum">   10478 </span>            :         {
<span class="lineNum">   10479 </span><span class="lineCov">    1327287 :           if (typedef_p)</span>
<span class="lineNum">   10480 </span>            :             {
<span class="lineNum">   10481 </span><span class="lineCov">          3 :               error (&quot;declaration of %qD as %&lt;typedef%&gt;&quot;, dname);</span>
<span class="lineNum">   10482 </span><span class="lineCov">          3 :               return error_mark_node;</span>
<span class="lineNum">   10483 </span>            :             }
<span class="lineNum">   10484 </span><span class="lineCov">    1327284 :           else if (decl_context == PARM || decl_context == CATCHPARM)</span>
<span class="lineNum">   10485 </span>            :             {
<span class="lineNum">   10486 </span><span class="lineCov">         15 :               error (&quot;declaration of %qD as parameter&quot;, dname);</span>
<span class="lineNum">   10487 </span><span class="lineCov">         15 :               return error_mark_node;</span>
<span class="lineNum">   10488 </span>            :             }
<span class="lineNum">   10489 </span>            :         }
<span class="lineNum">   10490 </span>            :     }
<span class="lineNum">   10491 </span>            : 
<span class="lineNum">   10492 </span>            :   /* Anything declared one level down from the top level
<span class="lineNum">   10493 </span>            :      must be one of the parameters of a function
<span class="lineNum">   10494 </span>            :      (because the body is at least two levels down).  */
<span class="lineNum">   10495 </span>            : 
<span class="lineNum">   10496 </span>            :   /* This heuristic cannot be applied to C++ nodes! Fixed, however,
<span class="lineNum">   10497 </span>            :      by not allowing C++ class definitions to specify their parameters
<span class="lineNum">   10498 </span>            :      with xdecls (must be spec.d in the parmlist).
<span class="lineNum">   10499 </span>            : 
<span class="lineNum">   10500 </span>            :      Since we now wait to push a class scope until we are sure that
<span class="lineNum">   10501 </span>            :      we are in a legitimate method context, we must set oldcname
<span class="lineNum">   10502 </span>            :      explicitly (since current_class_name is not yet alive).
<span class="lineNum">   10503 </span>            : 
<span class="lineNum">   10504 </span>            :      We also want to avoid calling this a PARM if it is in a namespace.  */
<span class="lineNum">   10505 </span>            : 
<span class="lineNum">   10506 </span><span class="lineCov">   51840148 :   if (decl_context == NORMAL &amp;&amp; !toplevel_bindings_p ())</span>
<span class="lineNum">   10507 </span>            :     {
<span class="lineNum">   10508 </span><span class="lineCov">    2431402 :       cp_binding_level *b = current_binding_level;</span>
<span class="lineNum">   10509 </span><span class="lineCov">    2431402 :       current_binding_level = b-&gt;level_chain;</span>
<span class="lineNum">   10510 </span><span class="lineCov">    2431402 :       if (current_binding_level != 0 &amp;&amp; toplevel_bindings_p ())</span>
<span class="lineNum">   10511 </span>            :         decl_context = PARM;
<span class="lineNum">   10512 </span><span class="lineCov">    2431402 :       current_binding_level = b;</span>
<span class="lineNum">   10513 </span>            :     }
<span class="lineNum">   10514 </span>            : 
<span class="lineNum">   10515 </span><span class="lineCov">   51840148 :   if (name == NULL)</span>
<span class="lineNum">   10516 </span><span class="lineCov">   19334591 :     name = decl_context == PARM ? &quot;parameter&quot; : &quot;type name&quot;;</span>
<span class="lineNum">   10517 </span>            : 
<span class="lineNum">   10518 </span><span class="lineCov">   51840148 :   if (concept_p &amp;&amp; typedef_p)</span>
<span class="lineNum">   10519 </span>            :     {
<span class="lineNum">   10520 </span><span class="lineCov">          2 :       error_at (declspecs-&gt;locations[ds_concept],</span>
<span class="lineNum">   10521 </span>            :                 &quot;%&lt;concept%&gt; cannot appear in a typedef declaration&quot;);
<span class="lineNum">   10522 </span><span class="lineCov">          2 :       return error_mark_node;</span>
<span class="lineNum">   10523 </span>            :     }
<span class="lineNum">   10524 </span>            : 
<span class="lineNum">   10525 </span><span class="lineCov">   51840146 :   if (constexpr_p &amp;&amp; typedef_p)</span>
<span class="lineNum">   10526 </span>            :     {
<span class="lineNum">   10527 </span><span class="lineCov">          2 :       error_at (declspecs-&gt;locations[ds_constexpr],</span>
<span class="lineNum">   10528 </span>            :                 &quot;%&lt;constexpr%&gt; cannot appear in a typedef declaration&quot;);
<span class="lineNum">   10529 </span><span class="lineCov">          2 :       return error_mark_node;</span>
<span class="lineNum">   10530 </span>            :     }
<span class="lineNum">   10531 </span>            : 
<span class="lineNum">   10532 </span>            :   /* If there were multiple types specified in the decl-specifier-seq,
<span class="lineNum">   10533 </span>            :      issue an error message.  */
<span class="lineNum">   10534 </span><span class="lineCov">   51840144 :   if (declspecs-&gt;multiple_types_p)</span>
<span class="lineNum">   10535 </span>            :     {
<span class="lineNum">   10536 </span><span class="lineCov">       1450 :       error (&quot;two or more data types in declaration of %qs&quot;, name);</span>
<span class="lineNum">   10537 </span><span class="lineCov">       1450 :       return error_mark_node;</span>
<span class="lineNum">   10538 </span>            :     }
<span class="lineNum">   10539 </span>            : 
<span class="lineNum">   10540 </span><span class="lineCov">   51838694 :   if (declspecs-&gt;conflicting_specifiers_p)</span>
<span class="lineNum">   10541 </span>            :     {
<span class="lineNum">   10542 </span><span class="lineCov">         25 :       error (&quot;conflicting specifiers in declaration of %qs&quot;, name);</span>
<span class="lineNum">   10543 </span><span class="lineCov">         25 :       return error_mark_node;</span>
<span class="lineNum">   10544 </span>            :     }
<span class="lineNum">   10545 </span>            : 
<span class="lineNum">   10546 </span>            :   /* Extract the basic type from the decl-specifier-seq.  */
<span class="lineNum">   10547 </span><span class="lineCov">   51838669 :   type = declspecs-&gt;type;</span>
<span class="lineNum">   10548 </span><span class="lineCov">   51838669 :   if (type == error_mark_node)</span>
<span class="lineNum">   10549 </span>            :     {
<span class="lineNum">   10550 </span><span class="lineCov">        662 :       type = NULL_TREE;</span>
<span class="lineNum">   10551 </span><span class="lineCov">        662 :       type_was_error_mark_node = true;</span>
<span class="lineNum">   10552 </span>            :     }
<span class="lineNum">   10553 </span><span class="lineCov">   51838669 :   cp_warn_deprecated_use (type);</span>
<span class="lineNum">   10554 </span><span class="lineCov">   51838669 :   if (type &amp;&amp; TREE_CODE (type) == TYPE_DECL)</span>
<span class="lineNum">   10555 </span>            :     {
<span class="lineNum">   10556 </span><span class="lineCov">   33307768 :       typedef_decl = type;</span>
<span class="lineNum">   10557 </span><span class="lineCov">   33307768 :       type = TREE_TYPE (typedef_decl);</span>
<span class="lineNum">   10558 </span><span class="lineCov">   33307768 :       if (DECL_ARTIFICIAL (typedef_decl))</span>
<span class="lineNum">   10559 </span><span class="lineCov">   19083028 :         cp_warn_deprecated_use (type);</span>
<span class="lineNum">   10560 </span>            :     }
<span class="lineNum">   10561 </span>            :   /* No type at all: default to `int', and set DEFAULTED_INT
<span class="lineNum">   10562 </span>            :      because it was not a user-defined typedef.  */
<span class="lineNum">   10563 </span><span class="lineCov">   51838669 :   if (type == NULL_TREE)</span>
<span class="lineNum">   10564 </span>            :     {
<span class="lineNum">   10565 </span><span class="lineCov">    2033566 :       if (signed_p || unsigned_p || long_p || short_p)</span>
<span class="lineNum">   10566 </span>            :         {
<span class="lineNum">   10567 </span>            :           /* These imply 'int'.  */
<span class="lineNum">   10568 </span><span class="lineCov">     886481 :           type = integer_type_node;</span>
<span class="lineNum">   10569 </span><span class="lineCov">     886481 :           defaulted_int = 1;</span>
<span class="lineNum">   10570 </span>            :         }
<span class="lineNum">   10571 </span>            :       /* If we just have &quot;complex&quot;, it is equivalent to &quot;complex double&quot;.  */
<span class="lineNum">   10572 </span><span class="lineCov">    1147085 :       else if (!longlong &amp;&amp; !explicit_intN</span>
<span class="lineNum">   10573 </span><span class="lineCov">    1147085 :                &amp;&amp; decl_spec_seq_has_spec_p (declspecs, ds_complex))</span>
<span class="lineNum">   10574 </span>            :         {
<span class="lineNum">   10575 </span><span class="lineCov">         19 :           type = double_type_node;</span>
<span class="lineNum">   10576 </span><span class="lineCov">         19 :           pedwarn (declspecs-&gt;locations[ds_complex], OPT_Wpedantic,</span>
<span class="lineNum">   10577 </span>            :                    &quot;ISO C++ does not support plain %&lt;complex%&gt; meaning &quot;
<span class="lineNum">   10578 </span>            :                    &quot;%&lt;double complex%&gt;&quot;);
<span class="lineNum">   10579 </span>            :         }
<span class="lineNum">   10580 </span>            :     }
<span class="lineNum">   10581 </span>            :   /* Gather flags.  */
<span class="lineNum">   10582 </span><span class="lineCov">   51838669 :   explicit_int = declspecs-&gt;explicit_int_p;</span>
<span class="lineNum">   10583 </span><span class="lineCov">   51838669 :   explicit_char = declspecs-&gt;explicit_char_p;</span>
<span class="lineNum">   10584 </span>            : 
<span class="lineNum">   10585 </span>            : #if 0
<span class="lineNum">   10586 </span>            :   /* See the code below that used this.  */
<span class="lineNum">   10587 </span>            :   if (typedef_decl)
<span class="lineNum">   10588 </span>            :     decl_attr = DECL_ATTRIBUTES (typedef_decl);
<span class="lineNum">   10589 </span>            : #endif
<span class="lineNum">   10590 </span><span class="lineCov">   51838669 :   typedef_type = type;</span>
<span class="lineNum">   10591 </span>            : 
<span class="lineNum">   10592 </span><span class="lineCov">   51838669 :   if (sfk == sfk_conversion || sfk == sfk_deduction_guide)</span>
<span class="lineNum">   10593 </span><span class="lineCov">      32334 :     ctor_return_type = TREE_TYPE (dname);</span>
<span class="lineNum">   10594 </span>            :   else
<span class="lineNum">   10595 </span>            :     ctor_return_type = ctype;
<span class="lineNum">   10596 </span>            : 
<span class="lineNum">   10597 </span><span class="lineCov">   51838669 :   if (sfk != sfk_none)</span>
<span class="lineNum">   10598 </span>            :     {
<span class="lineNum">   10599 </span><span class="lineCov">    1146117 :       type = check_special_function_return_type (sfk, type,</span>
<span class="lineNum">   10600 </span>            :                                                  ctor_return_type,
<span class="lineNum">   10601 </span>            :                                                  type_quals,
<span class="lineNum">   10602 </span>            :                                                  declspecs-&gt;locations);
<span class="lineNum">   10603 </span><span class="lineCov">    1146117 :       type_quals = TYPE_UNQUALIFIED;</span>
<span class="lineNum">   10604 </span>            :     }
<span class="lineNum">   10605 </span><span class="lineCov">   50692552 :   else if (type == NULL_TREE)</span>
<span class="lineNum">   10606 </span>            :     {
<span class="lineNum">   10607 </span><span class="lineCov">        985 :       int is_main;</span>
<span class="lineNum">   10608 </span>            : 
<span class="lineNum">   10609 </span><span class="lineCov">        985 :       explicit_int = -1;</span>
<span class="lineNum">   10610 </span>            : 
<span class="lineNum">   10611 </span>            :       /* We handle `main' specially here, because 'main () { }' is so
<span class="lineNum">   10612 </span>            :          common.  With no options, it is allowed.  With -Wreturn-type,
<span class="lineNum">   10613 </span>            :          it is a warning.  It is only an error with -pedantic-errors.  */
<span class="lineNum">   10614 </span><span class="lineCov">       1970 :       is_main = (funcdef_flag</span>
<span class="lineNum">   10615 </span><span class="lineCov">        200 :                  &amp;&amp; dname &amp;&amp; identifier_p (dname)</span>
<span class="lineNum">   10616 </span><span class="lineCov">        394 :                  &amp;&amp; MAIN_NAME_P (dname)</span>
<span class="lineNum">   10617 </span><span class="lineCov">         65 :                  &amp;&amp; ctype == NULL_TREE</span>
<span class="lineNum">   10618 </span><span class="lineCov">         65 :                  &amp;&amp; in_namespace == NULL_TREE</span>
<span class="lineNum">   10619 </span><span class="lineCov">       1050 :                  &amp;&amp; current_namespace == global_namespace);</span>
<span class="lineNum">   10620 </span>            : 
<span class="lineNum">   10621 </span><span class="lineCov">        985 :       if (type_was_error_mark_node)</span>
<span class="lineNum">   10622 </span>            :         /* We've already issued an error, don't complain more.  */;
<span class="lineNum">   10623 </span><span class="lineCov">        323 :       else if (in_system_header_at (input_location) || flag_ms_extensions)</span>
<span class="lineNum">   10624 </span>            :         /* Allow it, sigh.  */;
<span class="lineNum">   10625 </span><span class="lineCov">        261 :       else if (! is_main)</span>
<span class="lineNum">   10626 </span><span class="lineCov">        202 :         permerror (input_location, &quot;ISO C++ forbids declaration of %qs with no type&quot;, name);</span>
<span class="lineNum">   10627 </span><span class="lineCov">         59 :       else if (pedantic)</span>
<span class="lineNum">   10628 </span><span class="lineCov">          1 :         pedwarn (input_location, OPT_Wpedantic,</span>
<span class="lineNum">   10629 </span>            :                  &quot;ISO C++ forbids declaration of %qs with no type&quot;, name);
<span class="lineNum">   10630 </span>            :       else
<span class="lineNum">   10631 </span><span class="lineCov">         58 :         warning (OPT_Wreturn_type,</span>
<span class="lineNum">   10632 </span>            :                  &quot;ISO C++ forbids declaration of %qs with no type&quot;, name);
<span class="lineNum">   10633 </span>            : 
<span class="lineNum">   10634 </span><span class="lineCov">        985 :       if (type_was_error_mark_node &amp;&amp; template_parm_flag)</span>
<span class="lineNum">   10635 </span>            :         /* FIXME we should be able to propagate the error_mark_node as is
<span class="lineNum">   10636 </span>            :            for other contexts too.  */
<span class="lineNum">   10637 </span><span class="lineCov">         63 :         type = error_mark_node;</span>
<span class="lineNum">   10638 </span>            :       else
<span class="lineNum">   10639 </span><span class="lineCov">        922 :         type = integer_type_node;</span>
<span class="lineNum">   10640 </span>            :     }
<span class="lineNum">   10641 </span>            : 
<span class="lineNum">   10642 </span><span class="lineCov">   51838669 :   ctype = NULL_TREE;</span>
<span class="lineNum">   10643 </span>            : 
<span class="lineNum">   10644 </span><span class="lineCov">   51838669 :   if (explicit_intN)</span>
<span class="lineNum">   10645 </span>            :     {
<span class="lineNum">   10646 </span><span class="lineCov">     108067 :       if (! int_n_enabled_p[declspecs-&gt;int_n_idx])</span>
<span class="lineNum">   10647 </span>            :         {
<span class="lineNum">   10648 </span><span class="lineNoCov">          0 :           error (&quot;%&lt;__int%d%&gt; is not supported by this target&quot;,</span>
<span class="lineNum">   10649 </span><span class="lineNoCov">          0 :                  int_n_data[declspecs-&gt;int_n_idx].bitsize);</span>
<span class="lineNum">   10650 </span><span class="lineNoCov">          0 :           explicit_intN = false;</span>
<span class="lineNum">   10651 </span>            :         }
<span class="lineNum">   10652 </span><span class="lineCov">     108067 :       else if (pedantic &amp;&amp; ! in_system_header_at (input_location))</span>
<span class="lineNum">   10653 </span><span class="lineCov">         12 :         pedwarn (input_location, OPT_Wpedantic,</span>
<span class="lineNum">   10654 </span>            :                  &quot;ISO C++ does not support %&lt;__int%d%&gt; for %qs&quot;,
<span class="lineNum">   10655 </span><span class="lineCov">          6 :                  int_n_data[declspecs-&gt;int_n_idx].bitsize, name);</span>
<span class="lineNum">   10656 </span>            :     }
<span class="lineNum">   10657 </span>            : 
<span class="lineNum">   10658 </span>            :   /* Now process the modifiers that were specified
<span class="lineNum">   10659 </span>            :      and check for invalid combinations.  */
<span class="lineNum">   10660 </span>            : 
<span class="lineNum">   10661 </span>            :   /* Long double is a special combination.  */
<span class="lineNum">   10662 </span><span class="lineCov">   51838669 :   if (long_p &amp;&amp; !longlong &amp;&amp; TYPE_MAIN_VARIANT (type) == double_type_node)</span>
<span class="lineNum">   10663 </span>            :     {
<span class="lineNum">   10664 </span><span class="lineCov">     338812 :       long_p = false;</span>
<span class="lineNum">   10665 </span><span class="lineCov">     338812 :       type = cp_build_qualified_type (long_double_type_node,</span>
<span class="lineNum">   10666 </span>            :                                       cp_type_quals (type));
<span class="lineNum">   10667 </span>            :     }
<span class="lineNum">   10668 </span>            : 
<span class="lineNum">   10669 </span>            :   /* Check all other uses of type modifiers.  */
<span class="lineNum">   10670 </span>            : 
<span class="lineNum">   10671 </span><span class="lineCov">   51838669 :   if (unsigned_p || signed_p || long_p || short_p)</span>
<span class="lineNum">   10672 </span>            :     {
<span class="lineNum">   10673 </span><span class="lineCov">    2159175 :       location_t loc;</span>
<span class="lineNum">   10674 </span><span class="lineCov">    2159175 :       const char *key;</span>
<span class="lineNum">   10675 </span><span class="lineCov">    2159175 :       if (unsigned_p)</span>
<span class="lineNum">   10676 </span>            :         {
<span class="lineNum">   10677 </span><span class="lineCov">    1366055 :           key = &quot;unsigned&quot;;</span>
<span class="lineNum">   10678 </span><span class="lineCov">    1366055 :           loc = declspecs-&gt;locations[ds_unsigned];</span>
<span class="lineNum">   10679 </span>            :         }
<span class="lineNum">   10680 </span><span class="lineCov">     793120 :       else if (signed_p)</span>
<span class="lineNum">   10681 </span>            :         {
<span class="lineNum">   10682 </span><span class="lineCov">     187502 :           key = &quot;signed&quot;;</span>
<span class="lineNum">   10683 </span><span class="lineCov">     187502 :           loc = declspecs-&gt;locations[ds_signed];</span>
<span class="lineNum">   10684 </span>            :         }
<span class="lineNum">   10685 </span><span class="lineCov">     605618 :       else if (longlong)</span>
<span class="lineNum">   10686 </span>            :         {
<span class="lineNum">   10687 </span><span class="lineCov">     171428 :           key = &quot;long long&quot;;</span>
<span class="lineNum">   10688 </span><span class="lineCov">     171428 :           loc = declspecs-&gt;locations[ds_long_long];</span>
<span class="lineNum">   10689 </span>            :         }
<span class="lineNum">   10690 </span><span class="lineCov">     434190 :       else if (long_p)</span>
<span class="lineNum">   10691 </span>            :         {
<span class="lineNum">   10692 </span><span class="lineCov">     358129 :           key = &quot;long&quot;;</span>
<span class="lineNum">   10693 </span><span class="lineCov">     358129 :           loc = declspecs-&gt;locations[ds_long];</span>
<span class="lineNum">   10694 </span>            :         }
<span class="lineNum">   10695 </span>            :       else /* if (short_p) */
<span class="lineNum">   10696 </span>            :         {
<span class="lineNum">   10697 </span><span class="lineCov">      76061 :           key = &quot;short&quot;;</span>
<span class="lineNum">   10698 </span><span class="lineCov">      76061 :           loc = declspecs-&gt;locations[ds_short];</span>
<span class="lineNum">   10699 </span>            :         }
<span class="lineNum">   10700 </span>            : 
<span class="lineNum">   10701 </span><span class="lineCov">    2159175 :       int ok = 0;</span>
<span class="lineNum">   10702 </span>            : 
<span class="lineNum">   10703 </span><span class="lineCov">    2159175 :       if (signed_p &amp;&amp; unsigned_p)</span>
<span class="lineNum">   10704 </span>            :         {
<span class="lineNum">   10705 </span><span class="lineCov">         54 :           gcc_rich_location richloc (declspecs-&gt;locations[ds_signed]);</span>
<span class="lineNum">   10706 </span><span class="lineCov">         54 :           richloc.add_range (declspecs-&gt;locations[ds_unsigned]);</span>
<span class="lineNum">   10707 </span><span class="lineCov">         54 :           error_at (&amp;richloc,</span>
<span class="lineNum">   10708 </span>            :                     &quot;%&lt;signed%&gt; and %&lt;unsigned%&gt; specified together&quot;);
<span class="lineNum">   10709 </span>            :         }
<span class="lineNum">   10710 </span><span class="lineCov">    2159121 :       else if (long_p &amp;&amp; short_p)</span>
<span class="lineNum">   10711 </span>            :         {
<span class="lineNum">   10712 </span><span class="lineCov">          6 :           gcc_rich_location richloc (declspecs-&gt;locations[ds_long]);</span>
<span class="lineNum">   10713 </span><span class="lineCov">          6 :           richloc.add_range (declspecs-&gt;locations[ds_short]);</span>
<span class="lineNum">   10714 </span><span class="lineCov">          6 :           error_at (&amp;richloc, &quot;%&lt;long%&gt; and %&lt;short%&gt; specified together&quot;);</span>
<span class="lineNum">   10715 </span>            :         }
<span class="lineNum">   10716 </span><span class="lineCov">    2159115 :       else if (TREE_CODE (type) != INTEGER_TYPE</span>
<span class="lineNum">   10717 </span><span class="lineCov">    2159102 :                || type == char16_type_node || type == char32_type_node</span>
<span class="lineNum">   10718 </span><span class="lineCov">    2159070 :                || ((long_p || short_p)</span>
<span class="lineNum">   10719 </span><span class="lineCov">    1193741 :                    &amp;&amp; (explicit_char || explicit_intN)))</span>
<span class="lineNum">   10720 </span><span class="lineCov">        378 :         error_at (loc, &quot;%qs specified with %qT&quot;, key, type);</span>
<span class="lineNum">   10721 </span><span class="lineCov">    4317474 :       else if (!explicit_int &amp;&amp; !defaulted_int</span>
<span class="lineNum">   10722 </span><span class="lineCov">    2158737 :                &amp;&amp; !explicit_char &amp;&amp; !explicit_intN)</span>
<span class="lineNum">   10723 </span>            :         {
<span class="lineNum">   10724 </span><span class="lineCov">          6 :           if (typedef_decl)</span>
<span class="lineNum">   10725 </span>            :             {
<span class="lineNum">   10726 </span><span class="lineCov">          3 :               pedwarn (loc, OPT_Wpedantic, &quot;%qs specified with %qT&quot;,</span>
<span class="lineNum">   10727 </span>            :                        key, type);
<span class="lineNum">   10728 </span><span class="lineCov">          3 :               ok = !flag_pedantic_errors;</span>
<span class="lineNum">   10729 </span>            :             }
<span class="lineNum">   10730 </span><span class="lineCov">          3 :           else if (declspecs-&gt;decltype_p)</span>
<span class="lineNum">   10731 </span><span class="lineNoCov">          0 :             error_at (loc, &quot;%qs specified with %&lt;decltype%&gt;&quot;, key);</span>
<span class="lineNum">   10732 </span>            :           else
<span class="lineNum">   10733 </span><span class="lineCov">          3 :             error_at (loc, &quot;%qs specified with %&lt;typeof%&gt;&quot;, key);</span>
<span class="lineNum">   10734 </span>            :         }
<span class="lineNum">   10735 </span>            :       else
<span class="lineNum">   10736 </span>            :         ok = 1;
<span class="lineNum">   10737 </span>            : 
<span class="lineNum">   10738 </span>            :       /* Discard the type modifiers if they are invalid.  */
<span class="lineNum">   10739 </span><span class="lineCov">        444 :       if (! ok)</span>
<span class="lineNum">   10740 </span>            :         {
<span class="lineNum">   10741 </span>            :           unsigned_p = false;
<span class="lineNum">   10742 </span>            :           signed_p = false;
<span class="lineNum">   10743 </span>            :           long_p = false;
<span class="lineNum">   10744 </span>            :           short_p = false;
<span class="lineNum">   10745 </span>            :           longlong = 0;
<span class="lineNum">   10746 </span>            :         }
<span class="lineNum">   10747 </span>            :     }
<span class="lineNum">   10748 </span>            : 
<span class="lineNum">   10749 </span>            :   /* Decide whether an integer type is signed or not.
<span class="lineNum">   10750 </span>            :      Optionally treat bitfields as signed by default.  */
<span class="lineNum">   10751 </span><span class="lineCov">   51838669 :   if (unsigned_p</span>
<span class="lineNum">   10752 </span>            :       /* [class.bit]
<span class="lineNum">   10753 </span>            : 
<span class="lineNum">   10754 </span>            :          It is implementation-defined whether a plain (neither
<span class="lineNum">   10755 </span>            :          explicitly signed or unsigned) char, short, int, or long
<span class="lineNum">   10756 </span>            :          bit-field is signed or unsigned.
<span class="lineNum">   10757 </span>            : 
<span class="lineNum">   10758 </span>            :          Naturally, we extend this to long long as well.  Note that
<span class="lineNum">   10759 </span>            :          this does not include wchar_t.  */
<span class="lineNum">   10760 </span><span class="lineCov">   51838669 :       || (bitfield &amp;&amp; !flag_signed_bitfields</span>
<span class="lineNum">   10761 </span><span class="lineCov">         18 :           &amp;&amp; !signed_p</span>
<span class="lineNum">   10762 </span>            :           /* A typedef for plain `int' without `signed' can be
<span class="lineNum">   10763 </span>            :              controlled just like plain `int', but a typedef for
<span class="lineNum">   10764 </span>            :              `signed int' cannot be so controlled.  */
<span class="lineNum">   10765 </span><span class="lineCov">         18 :           &amp;&amp; !(typedef_decl</span>
<span class="lineNum">   10766 </span><span class="lineCov">         18 :                &amp;&amp; C_TYPEDEF_EXPLICITLY_SIGNED (typedef_decl))</span>
<span class="lineNum">   10767 </span><span class="lineCov">         13 :           &amp;&amp; TREE_CODE (type) == INTEGER_TYPE</span>
<span class="lineNum">   10768 </span><span class="lineCov">         10 :           &amp;&amp; !same_type_p (TYPE_MAIN_VARIANT (type), wchar_type_node)))</span>
<span class="lineNum">   10769 </span>            :     {
<span class="lineNum">   10770 </span><span class="lineCov">    1365855 :       if (explicit_intN)</span>
<span class="lineNum">   10771 </span><span class="lineCov">      51244 :         type = int_n_trees[declspecs-&gt;int_n_idx].unsigned_type;</span>
<span class="lineNum">   10772 </span><span class="lineCov">    1314611 :       else if (longlong)</span>
<span class="lineNum">   10773 </span><span class="lineCov">     137867 :         type = long_long_unsigned_type_node;</span>
<span class="lineNum">   10774 </span><span class="lineCov">    1176744 :       else if (long_p)</span>
<span class="lineNum">   10775 </span><span class="lineCov">     244723 :         type = long_unsigned_type_node;</span>
<span class="lineNum">   10776 </span><span class="lineCov">     932021 :       else if (short_p)</span>
<span class="lineNum">   10777 </span><span class="lineCov">     148093 :         type = short_unsigned_type_node;</span>
<span class="lineNum">   10778 </span><span class="lineCov">     783928 :       else if (type == char_type_node)</span>
<span class="lineNum">   10779 </span><span class="lineCov">     149280 :         type = unsigned_char_type_node;</span>
<span class="lineNum">   10780 </span><span class="lineCov">     634648 :       else if (typedef_decl)</span>
<span class="lineNum">   10781 </span><span class="lineCov">         13 :         type = unsigned_type_for (type);</span>
<span class="lineNum">   10782 </span>            :       else
<span class="lineNum">   10783 </span><span class="lineCov">     634635 :         type = unsigned_type_node;</span>
<span class="lineNum">   10784 </span>            :     }
<span class="lineNum">   10785 </span><span class="lineCov">   50472814 :   else if (signed_p &amp;&amp; type == char_type_node)</span>
<span class="lineNum">   10786 </span><span class="lineCov">      87133 :     type = signed_char_type_node;</span>
<span class="lineNum">   10787 </span><span class="lineCov">   50385681 :   else if (explicit_intN)</span>
<span class="lineNum">   10788 </span><span class="lineCov">      56823 :     type = int_n_trees[declspecs-&gt;int_n_idx].signed_type;</span>
<span class="lineNum">   10789 </span><span class="lineCov">   50328858 :   else if (longlong)</span>
<span class="lineNum">   10790 </span><span class="lineCov">     188949 :     type = long_long_integer_type_node;</span>
<span class="lineNum">   10791 </span><span class="lineCov">   50139909 :   else if (long_p)</span>
<span class="lineNum">   10792 </span><span class="lineCov">     378867 :     type = long_integer_type_node;</span>
<span class="lineNum">   10793 </span><span class="lineCov">   49761042 :   else if (short_p)</span>
<span class="lineNum">   10794 </span><span class="lineCov">      94909 :     type = short_integer_type_node;</span>
<span class="lineNum">   10795 </span>            : 
<span class="lineNum">   10796 </span><span class="lineCov">   51838669 :   if (decl_spec_seq_has_spec_p (declspecs, ds_complex))</span>
<span class="lineNum">   10797 </span>            :     {
<span class="lineNum">   10798 </span><span class="lineCov">      46164 :       if (TREE_CODE (type) != INTEGER_TYPE &amp;&amp; TREE_CODE (type) != REAL_TYPE)</span>
<span class="lineNum">   10799 </span><span class="lineNoCov">          0 :         error (&quot;complex invalid for %qs&quot;, name);</span>
<span class="lineNum">   10800 </span>            :       /* If a modifier is specified, the resulting complex is the complex
<span class="lineNum">   10801 </span>            :          form of TYPE.  E.g, &quot;complex short&quot; is &quot;complex short int&quot;.  */
<span class="lineNum">   10802 </span><span class="lineCov">      46164 :       else if (type == integer_type_node)</span>
<span class="lineNum">   10803 </span><span class="lineCov">        123 :         type = complex_integer_type_node;</span>
<span class="lineNum">   10804 </span><span class="lineCov">      46041 :       else if (type == float_type_node)</span>
<span class="lineNum">   10805 </span><span class="lineCov">      16438 :         type = complex_float_type_node;</span>
<span class="lineNum">   10806 </span><span class="lineCov">      29603 :       else if (type == double_type_node)</span>
<span class="lineNum">   10807 </span><span class="lineCov">      15835 :         type = complex_double_type_node;</span>
<span class="lineNum">   10808 </span><span class="lineCov">      13768 :       else if (type == long_double_type_node)</span>
<span class="lineNum">   10809 </span><span class="lineCov">      13350 :         type = complex_long_double_type_node;</span>
<span class="lineNum">   10810 </span>            :       else
<span class="lineNum">   10811 </span><span class="lineCov">        418 :         type = build_complex_type (type);</span>
<span class="lineNum">   10812 </span>            :     }
<span class="lineNum">   10813 </span>            : 
<span class="lineNum">   10814 </span>            :   /* If we're using the injected-class-name to form a compound type or a
<span class="lineNum">   10815 </span>            :      declaration, replace it with the underlying class so we don't get
<span class="lineNum">   10816 </span>            :      redundant typedefs in the debug output.  But if we are returning the
<span class="lineNum">   10817 </span>            :      type unchanged, leave it alone so that it's available to
<span class="lineNum">   10818 </span>            :      maybe_get_template_decl_from_type_decl.  */
<span class="lineNum">   10819 </span><span class="lineCov">    8117739 :   if (CLASS_TYPE_P (type)</span>
<span class="lineNum">   10820 </span><span class="lineCov">   16226146 :       &amp;&amp; DECL_SELF_REFERENCE_P (TYPE_NAME (type))</span>
<span class="lineNum">   10821 </span><span class="lineCov">    2240490 :       &amp;&amp; type == TREE_TYPE (TYPE_NAME (type))</span>
<span class="lineNum">   10822 </span><span class="lineCov">   52958914 :       &amp;&amp; (declarator || type_quals))</span>
<span class="lineNum">   10823 </span><span class="lineCov">    3284424 :     type = DECL_ORIGINAL_TYPE (TYPE_NAME (type));</span>
<span class="lineNum">   10824 </span>            : 
<span class="lineNum">   10825 </span><span class="lineCov">   51838669 :   type_quals |= cp_type_quals (type);</span>
<span class="lineNum">   10826 </span><span class="lineCov">  103677338 :   type = cp_build_qualified_type_real</span>
<span class="lineNum">   10827 </span><span class="lineCov">   89452598 :     (type, type_quals, ((((typedef_decl &amp;&amp; !DECL_ARTIFICIAL (typedef_decl))</span>
<span class="lineNum">   10828 </span><span class="lineCov">   37613929 :                           || declspecs-&gt;decltype_p)</span>
<span class="lineNum">   10829 </span>            :                          ? tf_ignore_bad_quals : 0) | tf_warning_or_error));
<span class="lineNum">   10830 </span>            :   /* We might have ignored or rejected some of the qualifiers.  */
<span class="lineNum">   10831 </span><span class="lineCov">   51838669 :   type_quals = cp_type_quals (type);</span>
<span class="lineNum">   10832 </span>            : 
<span class="lineNum">   10833 </span><span class="lineCov">   10744918 :   if (cxx_dialect &gt;= cxx17 &amp;&amp; type &amp;&amp; is_auto (type)</span>
<span class="lineNum">   10834 </span>            :       &amp;&amp; innermost_code != cdk_function
<span class="lineNum">   10835 </span><span class="lineCov">   51906252 :       &amp;&amp; id_declarator &amp;&amp; declarator != id_declarator)</span>
<span class="lineNum">   10836 </span><span class="lineCov">       3104 :     if (tree tmpl = CLASS_PLACEHOLDER_TEMPLATE (type))</span>
<span class="lineNum">   10837 </span>            :     {
<span class="lineNum">   10838 </span><span class="lineCov">          1 :       error_at (typespec_loc, &quot;template placeholder type %qT must be followed &quot;</span>
<span class="lineNum">   10839 </span>            :                 &quot;by a simple declarator-id&quot;, type);
<span class="lineNum">   10840 </span><span class="lineCov">          1 :       inform (DECL_SOURCE_LOCATION (tmpl), &quot;%qD declared here&quot;, tmpl);</span>
<span class="lineNum">   10841 </span>            :     }
<span class="lineNum">   10842 </span>            : 
<span class="lineNum">   10843 </span><span class="lineCov">   51838669 :   staticp = 0;</span>
<span class="lineNum">   10844 </span><span class="lineCov">   51838669 :   inlinep = decl_spec_seq_has_spec_p (declspecs, ds_inline);</span>
<span class="lineNum">   10845 </span><span class="lineCov">   51838669 :   virtualp =  decl_spec_seq_has_spec_p (declspecs, ds_virtual);</span>
<span class="lineNum">   10846 </span><span class="lineCov">   51838669 :   explicitp = decl_spec_seq_has_spec_p (declspecs, ds_explicit);</span>
<span class="lineNum">   10847 </span>            : 
<span class="lineNum">   10848 </span><span class="lineCov">   51838669 :   storage_class = declspecs-&gt;storage_class;</span>
<span class="lineNum">   10849 </span><span class="lineCov">   51838669 :   if (storage_class == sc_static)</span>
<span class="lineNum">   10850 </span><span class="lineCov">    1738770 :     staticp = 1 + (decl_context == FIELD);</span>
<span class="lineNum">   10851 </span>            : 
<span class="lineNum">   10852 </span><span class="lineCov">   51838669 :   if (virtualp)</span>
<span class="lineNum">   10853 </span>            :     {
<span class="lineNum">   10854 </span><span class="lineCov">     265738 :       if (staticp == 2)</span>
<span class="lineNum">   10855 </span>            :         {
<span class="lineNum">   10856 </span><span class="lineCov">         40 :           gcc_rich_location richloc (declspecs-&gt;locations[ds_virtual]);</span>
<span class="lineNum">   10857 </span><span class="lineCov">         20 :           richloc.add_range (declspecs-&gt;locations[ds_storage_class]);</span>
<span class="lineNum">   10858 </span><span class="lineCov">         20 :           error_at (&amp;richloc, &quot;member %qD cannot be declared both %&lt;virtual%&gt; &quot;</span>
<span class="lineNum">   10859 </span>            :                     &quot;and %&lt;static%&gt;&quot;, dname);
<span class="lineNum">   10860 </span><span class="lineCov">         20 :           storage_class = sc_none;</span>
<span class="lineNum">   10861 </span><span class="lineCov">         20 :           staticp = 0;</span>
<span class="lineNum">   10862 </span>            :         }
<span class="lineNum">   10863 </span><span class="lineCov">     265738 :       if (constexpr_p &amp;&amp; cxx_dialect &lt; cxx2a)</span>
<span class="lineNum">   10864 </span>            :         {
<span class="lineNum">   10865 </span><span class="lineCov">         12 :           gcc_rich_location richloc (declspecs-&gt;locations[ds_virtual]);</span>
<span class="lineNum">   10866 </span><span class="lineCov">          6 :           richloc.add_range (declspecs-&gt;locations[ds_constexpr]);</span>
<span class="lineNum">   10867 </span><span class="lineCov">          6 :           pedwarn (&amp;richloc, OPT_Wpedantic, &quot;member %qD can be declared both &quot;</span>
<span class="lineNum">   10868 </span>            :                    &quot;%&lt;virtual%&gt; and %&lt;constexpr%&gt; only in -std=c++2a or &quot;
<span class="lineNum">   10869 </span>            :                    &quot;-std=gnu++2a&quot;, dname);
<span class="lineNum">   10870 </span>            :         }
<span class="lineNum">   10871 </span>            :     }
<span class="lineNum">   10872 </span><span class="lineCov">   51838669 :   friendp = decl_spec_seq_has_spec_p (declspecs, ds_friend);</span>
<span class="lineNum">   10873 </span>            : 
<span class="lineNum">   10874 </span>            :   /* Issue errors about use of storage classes for parameters.  */
<span class="lineNum">   10875 </span><span class="lineCov">   51838669 :   if (decl_context == PARM)</span>
<span class="lineNum">   10876 </span>            :     {
<span class="lineNum">   10877 </span><span class="lineCov">   17188180 :       if (typedef_p)</span>
<span class="lineNum">   10878 </span>            :         {
<span class="lineNum">   10879 </span><span class="lineCov">         24 :           error_at (declspecs-&gt;locations[ds_typedef],</span>
<span class="lineNum">   10880 </span>            :                     &quot;typedef declaration invalid in parameter declaration&quot;);
<span class="lineNum">   10881 </span><span class="lineCov">         24 :           return error_mark_node;</span>
<span class="lineNum">   10882 </span>            :         }
<span class="lineNum">   10883 </span><span class="lineCov">   17188156 :       else if (template_parm_flag &amp;&amp; storage_class != sc_none)</span>
<span class="lineNum">   10884 </span>            :         {
<span class="lineNum">   10885 </span><span class="lineCov">         16 :           error_at (min_location (declspecs-&gt;locations[ds_thread],</span>
<span class="lineNum">   10886 </span>            :                                   declspecs-&gt;locations[ds_storage_class]),
<span class="lineNum">   10887 </span>            :                     &quot;storage class specified for template parameter %qs&quot;,
<span class="lineNum">   10888 </span>            :                     name);
<span class="lineNum">   10889 </span><span class="lineCov">         16 :           return error_mark_node;</span>
<span class="lineNum">   10890 </span>            :         }
<span class="lineNum">   10891 </span><span class="lineCov">   34376280 :       else if (storage_class == sc_static</span>
<span class="lineNum">   10892 </span><span class="lineCov">   17188140 :                || storage_class == sc_extern</span>
<span class="lineNum">   10893 </span><span class="lineCov">   17188137 :                || thread_p)</span>
<span class="lineNum">   10894 </span>            :         {
<span class="lineNum">   10895 </span><span class="lineCov">          9 :           error_at (min_location (declspecs-&gt;locations[ds_thread],</span>
<span class="lineNum">   10896 </span>            :                                   declspecs-&gt;locations[ds_storage_class]),
<span class="lineNum">   10897 </span>            :                     &quot;storage class specified for parameter %qs&quot;, name);
<span class="lineNum">   10898 </span><span class="lineCov">          9 :           return error_mark_node;</span>
<span class="lineNum">   10899 </span>            :         }
<span class="lineNum">   10900 </span>            : 
<span class="lineNum">   10901 </span>            :       /* Function parameters cannot be concept. */
<span class="lineNum">   10902 </span><span class="lineCov">   17188131 :       if (concept_p)</span>
<span class="lineNum">   10903 </span><span class="lineCov">          2 :         error_at (declspecs-&gt;locations[ds_concept],</span>
<span class="lineNum">   10904 </span>            :                   &quot;a parameter cannot be declared %&lt;concept%&gt;&quot;);
<span class="lineNum">   10905 </span>            :       /* Function parameters cannot be constexpr.  If we saw one, moan
<span class="lineNum">   10906 </span>            :          and pretend it wasn't there.  */
<span class="lineNum">   10907 </span><span class="lineCov">   17188129 :       else if (constexpr_p)</span>
<span class="lineNum">   10908 </span>            :         {
<span class="lineNum">   10909 </span><span class="lineCov">          6 :           error_at (declspecs-&gt;locations[ds_constexpr],</span>
<span class="lineNum">   10910 </span>            :                     &quot;a parameter cannot be declared %&lt;constexpr%&gt;&quot;);
<span class="lineNum">   10911 </span><span class="lineCov">          6 :           constexpr_p = 0;</span>
<span class="lineNum">   10912 </span>            :         }
<span class="lineNum">   10913 </span>            :     }
<span class="lineNum">   10914 </span>            : 
<span class="lineNum">   10915 </span>            :   /* Give error if `virtual' is used outside of class declaration.  */
<span class="lineNum">   10916 </span><span class="lineCov">   51838620 :   if (virtualp</span>
<span class="lineNum">   10917 </span><span class="lineCov">     265738 :       &amp;&amp; (current_class_name == NULL_TREE || decl_context != FIELD))</span>
<span class="lineNum">   10918 </span>            :     {
<span class="lineNum">   10919 </span><span class="lineCov">         16 :       error_at (declspecs-&gt;locations[ds_virtual],</span>
<span class="lineNum">   10920 </span>            :                 &quot;%&lt;virtual%&gt; outside class declaration&quot;);
<span class="lineNum">   10921 </span><span class="lineCov">         16 :       virtualp = 0;</span>
<span class="lineNum">   10922 </span>            :     }
<span class="lineNum">   10923 </span>            : 
<span class="lineNum">   10924 </span><span class="lineCov">   51838620 :   if (innermost_code == cdk_decomp)</span>
<span class="lineNum">   10925 </span>            :     {
<span class="lineNum">   10926 </span><span class="lineCov">        630 :       location_t loc = (declarator-&gt;kind == cdk_reference</span>
<span class="lineNum">   10927 </span><span class="lineCov">        315 :                         ? declarator-&gt;declarator-&gt;id_loc : declarator-&gt;id_loc);</span>
<span class="lineNum">   10928 </span><span class="lineCov">        315 :       if (inlinep)</span>
<span class="lineNum">   10929 </span><span class="lineCov">          1 :         error_at (declspecs-&gt;locations[ds_inline],</span>
<span class="lineNum">   10930 </span>            :                   &quot;structured binding declaration cannot be %&lt;inline%&gt;&quot;);
<span class="lineNum">   10931 </span><span class="lineCov">        315 :       if (typedef_p)</span>
<span class="lineNum">   10932 </span><span class="lineCov">          1 :         error_at (declspecs-&gt;locations[ds_typedef],</span>
<span class="lineNum">   10933 </span>            :                   &quot;structured binding declaration cannot be %&lt;typedef%&gt;&quot;);
<span class="lineNum">   10934 </span><span class="lineCov">        315 :       if (constexpr_p)</span>
<span class="lineNum">   10935 </span><span class="lineCov">          1 :         error_at (declspecs-&gt;locations[ds_constexpr], &quot;structured &quot;</span>
<span class="lineNum">   10936 </span>            :                   &quot;binding declaration cannot be %&lt;constexpr%&gt;&quot;);
<span class="lineNum">   10937 </span><span class="lineCov">        315 :       if (thread_p)</span>
<span class="lineNum">   10938 </span><span class="lineNoCov">          0 :         error_at (declspecs-&gt;locations[ds_thread],</span>
<span class="lineNum">   10939 </span>            :                   &quot;structured binding declaration cannot be %qs&quot;,
<span class="lineNum">   10940 </span>            :                   declspecs-&gt;gnu_thread_keyword_p
<span class="lineNum">   10941 </span><span class="lineNoCov">          0 :                   ? &quot;__thread&quot; : &quot;thread_local&quot;);</span>
<span class="lineNum">   10942 </span><span class="lineCov">        315 :       if (concept_p)</span>
<span class="lineNum">   10943 </span><span class="lineNoCov">          0 :         error_at (declspecs-&gt;locations[ds_concept],</span>
<span class="lineNum">   10944 </span>            :                   &quot;structured binding declaration cannot be %&lt;concept%&gt;&quot;);
<span class="lineNum">   10945 </span><span class="lineCov">        315 :       switch (storage_class)</span>
<span class="lineNum">   10946 </span>            :         {
<span class="lineNum">   10947 </span>            :         case sc_none:
<span class="lineNum">   10948 </span>            :           break;
<span class="lineNum">   10949 </span><span class="lineNoCov">          0 :         case sc_register:</span>
<span class="lineNum">   10950 </span><span class="lineNoCov">          0 :           error_at (loc, &quot;structured binding declaration cannot be &quot;</span>
<span class="lineNum">   10951 </span>            :                     &quot;%&lt;register%&gt;&quot;);
<span class="lineNum">   10952 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">   10953 </span><span class="lineCov">          1 :         case sc_static:</span>
<span class="lineNum">   10954 </span><span class="lineCov">          1 :           error_at (loc, &quot;structured binding declaration cannot be &quot;</span>
<span class="lineNum">   10955 </span>            :                     &quot;%&lt;static%&gt;&quot;);
<span class="lineNum">   10956 </span><span class="lineCov">          1 :           break;</span>
<span class="lineNum">   10957 </span><span class="lineCov">          1 :         case sc_extern:</span>
<span class="lineNum">   10958 </span><span class="lineCov">          1 :           error_at (loc, &quot;structured binding declaration cannot be &quot;</span>
<span class="lineNum">   10959 </span>            :                     &quot;%&lt;extern%&gt;&quot;);
<span class="lineNum">   10960 </span><span class="lineCov">          1 :           break;</span>
<span class="lineNum">   10961 </span><span class="lineNoCov">          0 :         case sc_mutable:</span>
<span class="lineNum">   10962 </span><span class="lineNoCov">          0 :           error_at (loc, &quot;structured binding declaration cannot be &quot;</span>
<span class="lineNum">   10963 </span>            :                     &quot;%&lt;mutable%&gt;&quot;);
<span class="lineNum">   10964 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">   10965 </span><span class="lineNoCov">          0 :         case sc_auto:</span>
<span class="lineNum">   10966 </span><span class="lineNoCov">          0 :           error_at (loc, &quot;structured binding declaration cannot be &quot;</span>
<span class="lineNum">   10967 </span>            :                     &quot;C++98 %&lt;auto%&gt;&quot;);
<span class="lineNum">   10968 </span><span class="lineNoCov">          0 :           break;</span>
<span class="lineNum">   10969 </span><span class="lineNoCov">          0 :         default:</span>
<span class="lineNum">   10970 </span><span class="lineNoCov">          0 :           gcc_unreachable ();</span>
<span class="lineNum">   10971 </span>            :         }
<span class="lineNum">   10972 </span><span class="lineCov">        315 :       if (TREE_CODE (type) != TEMPLATE_TYPE_PARM</span>
<span class="lineNum">   10973 </span><span class="lineCov">        315 :           || TYPE_IDENTIFIER (type) != auto_identifier)</span>
<span class="lineNum">   10974 </span>            :         {
<span class="lineNum">   10975 </span><span class="lineCov">          3 :           if (type != error_mark_node)</span>
<span class="lineNum">   10976 </span>            :             {
<span class="lineNum">   10977 </span><span class="lineCov">          3 :               error_at (loc, &quot;structured binding declaration cannot have &quot;</span>
<span class="lineNum">   10978 </span>            :                         &quot;type %qT&quot;, type);
<span class="lineNum">   10979 </span><span class="lineCov">          3 :               inform (loc,</span>
<span class="lineNum">   10980 </span>            :                       &quot;type must be cv-qualified %&lt;auto%&gt; or reference to &quot;
<span class="lineNum">   10981 </span>            :                       &quot;cv-qualified %&lt;auto%&gt;&quot;);
<span class="lineNum">   10982 </span>            :             }
<span class="lineNum">   10983 </span><span class="lineCov">          3 :           type = build_qualified_type (make_auto (), type_quals);</span>
<span class="lineNum">   10984 </span><span class="lineCov">          3 :           declspecs-&gt;type = type;</span>
<span class="lineNum">   10985 </span>            :         }
<span class="lineNum">   10986 </span><span class="lineCov">        315 :       inlinep = 0;</span>
<span class="lineNum">   10987 </span><span class="lineCov">        315 :       typedef_p = 0;</span>
<span class="lineNum">   10988 </span><span class="lineCov">        315 :       constexpr_p = 0;</span>
<span class="lineNum">   10989 </span><span class="lineCov">        315 :       thread_p = 0;</span>
<span class="lineNum">   10990 </span><span class="lineCov">        315 :       concept_p = 0;</span>
<span class="lineNum">   10991 </span><span class="lineCov">        315 :       storage_class = sc_none;</span>
<span class="lineNum">   10992 </span><span class="lineCov">        315 :       staticp = 0;</span>
<span class="lineNum">   10993 </span><span class="lineCov">        315 :       declspecs-&gt;storage_class = sc_none;</span>
<span class="lineNum">   10994 </span><span class="lineCov">        315 :       declspecs-&gt;locations[ds_thread] = UNKNOWN_LOCATION;</span>
<span class="lineNum">   10995 </span>            :     }
<span class="lineNum">   10996 </span>            : 
<span class="lineNum">   10997 </span>            :   /* Static anonymous unions are dealt with here.  */
<span class="lineNum">   10998 </span><span class="lineCov">   51838620 :   if (staticp &amp;&amp; decl_context == TYPENAME</span>
<span class="lineNum">   10999 </span><span class="lineNoCov">          0 :       &amp;&amp; declspecs-&gt;type</span>
<span class="lineNum">   11000 </span><span class="lineCov">   51838620 :       &amp;&amp; ANON_AGGR_TYPE_P (declspecs-&gt;type))</span>
<span class="lineNum">   11001 </span>            :     decl_context = FIELD;
<span class="lineNum">   11002 </span>            : 
<span class="lineNum">   11003 </span>            :   /* Warn about storage classes that are invalid for certain
<span class="lineNum">   11004 </span>            :      kinds of declarations (parameters, typenames, etc.).  */
<span class="lineNum">   11005 </span><span class="lineCov">   51838620 :   if (thread_p</span>
<span class="lineNum">   11006 </span><span class="lineCov">        782 :       &amp;&amp; ((storage_class</span>
<span class="lineNum">   11007 </span><span class="lineCov">        782 :            &amp;&amp; storage_class != sc_extern</span>
<span class="lineNum">   11008 </span><span class="lineCov">        123 :            &amp;&amp; storage_class != sc_static)</span>
<span class="lineNum">   11009 </span><span class="lineCov">        771 :           || typedef_p))</span>
<span class="lineNum">   11010 </span>            :     {
<span class="lineNum">   11011 </span><span class="lineCov">         17 :       error (&quot;multiple storage classes in declaration of %qs&quot;, name);</span>
<span class="lineNum">   11012 </span><span class="lineCov">         17 :       thread_p = false;</span>
<span class="lineNum">   11013 </span>            :     }
<span class="lineNum">   11014 </span><span class="lineCov">   51838620 :   if (decl_context != NORMAL</span>
<span class="lineNum">   11015 </span><span class="lineCov">   84229660 :       &amp;&amp; ((storage_class != sc_none</span>
<span class="lineNum">   11016 </span><span class="lineCov">   42114830 :            &amp;&amp; storage_class != sc_mutable)</span>
<span class="lineNum">   11017 </span><span class="lineCov">   40560325 :           || thread_p))</span>
<span class="lineNum">   11018 </span>            :     {
<span class="lineNum">   11019 </span><span class="lineCov">    1554508 :       if ((decl_context == PARM || decl_context == CATCHPARM)</span>
<span class="lineNum">   11020 </span><span class="lineCov">         75 :           &amp;&amp; (storage_class == sc_register</span>
<span class="lineNum">   11021 </span><span class="lineCov">         75 :               || storage_class == sc_auto))</span>
<span class="lineNum">   11022 </span>            :         ;
<span class="lineNum">   11023 </span><span class="lineCov">    1554433 :       else if (typedef_p)</span>
<span class="lineNum">   11024 </span>            :         ;
<span class="lineNum">   11025 </span><span class="lineCov">    3108866 :       else if (decl_context == FIELD</span>
<span class="lineNum">   11026 </span>            :                /* C++ allows static class elements.  */
<span class="lineNum">   11027 </span><span class="lineCov">    1554433 :                &amp;&amp; storage_class == sc_static)</span>
<span class="lineNum">   11028 </span>            :         /* C++ also allows inlines and signed and unsigned elements,
<span class="lineNum">   11029 </span>            :            but in those cases we don't come in here.  */
<span class="lineNum">   11030 </span>            :         ;
<span class="lineNum">   11031 </span>            :       else
<span class="lineNum">   11032 </span>            :         {
<span class="lineNum">   11033 </span><span class="lineCov">         15 :           location_t loc</span>
<span class="lineNum">   11034 </span><span class="lineCov">         15 :             = min_location (declspecs-&gt;locations[ds_thread],</span>
<span class="lineNum">   11035 </span>            :                             declspecs-&gt;locations[ds_storage_class]);
<span class="lineNum">   11036 </span><span class="lineCov">         15 :           if (decl_context == FIELD)</span>
<span class="lineNum">   11037 </span><span class="lineCov">         15 :             error_at (loc, &quot;storage class specified for %qs&quot;, name);</span>
<span class="lineNum">   11038 </span><span class="lineNoCov">          0 :           else if (decl_context == PARM || decl_context == CATCHPARM)</span>
<span class="lineNum">   11039 </span><span class="lineNoCov">          0 :             error_at (loc, &quot;storage class specified for parameter %qs&quot;, name);</span>
<span class="lineNum">   11040 </span>            :           else
<span class="lineNum">   11041 </span><span class="lineNoCov">          0 :             error_at (loc, &quot;storage class specified for typename&quot;);</span>
<span class="lineNum">   11042 </span><span class="lineCov">         30 :           if (storage_class == sc_register</span>
<span class="lineNum">   11043 </span><span class="lineCov">         15 :               || storage_class == sc_auto</span>
<span class="lineNum">   11044 </span><span class="lineCov">         15 :               || storage_class == sc_extern</span>
<span class="lineNum">   11045 </span><span class="lineCov">          3 :               || thread_p)</span>
<span class="lineNum">   11046 </span>            :             storage_class = sc_none;
<span class="lineNum">   11047 </span>            :         }
<span class="lineNum">   11048 </span>            :     }
<span class="lineNum">   11049 </span><span class="lineCov">   50284112 :   else if (storage_class == sc_extern &amp;&amp; funcdef_flag</span>
<span class="lineNum">   11050 </span><span class="lineCov">   50284112 :            &amp;&amp; ! toplevel_bindings_p ())</span>
<span class="lineNum">   11051 </span><span class="lineNoCov">          0 :     error (&quot;nested function %qs declared %&lt;extern%&gt;&quot;, name);</span>
<span class="lineNum">   11052 </span><span class="lineCov">   50284112 :   else if (toplevel_bindings_p ())</span>
<span class="lineNum">   11053 </span>            :     {
<span class="lineNum">   11054 </span><span class="lineCov">   23704526 :       if (storage_class == sc_auto)</span>
<span class="lineNum">   11055 </span><span class="lineCov">          1 :         error (&quot;top-level declaration of %qs specifies %&lt;auto%&gt;&quot;, name);</span>
<span class="lineNum">   11056 </span>            :     }
<span class="lineNum">   11057 </span><span class="lineCov">   53159172 :   else if (thread_p</span>
<span class="lineNum">   11058 </span><span class="lineCov">   26579586 :            &amp;&amp; storage_class != sc_extern</span>
<span class="lineNum">   11059 </span><span class="lineCov">         46 :            &amp;&amp; storage_class != sc_static)</span>
<span class="lineNum">   11060 </span>            :     {
<span class="lineNum">   11061 </span><span class="lineCov">         22 :       if (declspecs-&gt;gnu_thread_keyword_p)</span>
<span class="lineNum">   11062 </span><span class="lineCov">          3 :         pedwarn (declspecs-&gt;locations[ds_thread],</span>
<span class="lineNum">   11063 </span>            :                  0, &quot;function-scope %qs implicitly auto and &quot;
<span class="lineNum">   11064 </span>            :                  &quot;declared %&lt;__thread%&gt;&quot;, name);
<span class="lineNum">   11065 </span>            : 
<span class="lineNum">   11066 </span>            :       /* When thread_local is applied to a variable of block scope the
<span class="lineNum">   11067 </span>            :          storage-class-specifier static is implied if it does not appear
<span class="lineNum">   11068 </span>            :          explicitly.  */
<span class="lineNum">   11069 </span><span class="lineCov">         22 :       storage_class = declspecs-&gt;storage_class = sc_static;</span>
<span class="lineNum">   11070 </span><span class="lineCov">         22 :       staticp = 1;</span>
<span class="lineNum">   11071 </span>            :     }
<span class="lineNum">   11072 </span>            : 
<span class="lineNum">   11073 </span><span class="lineCov">   51838605 :   if (storage_class &amp;&amp; friendp)</span>
<span class="lineNum">   11074 </span>            :     {
<span class="lineNum">   11075 </span><span class="lineCov">         12 :       error_at (min_location (declspecs-&gt;locations[ds_thread],</span>
<span class="lineNum">   11076 </span>            :                               declspecs-&gt;locations[ds_storage_class]),
<span class="lineNum">   11077 </span>            :                 &quot;storage class specifiers invalid in friend function &quot;
<span class="lineNum">   11078 </span>            :                 &quot;declarations&quot;);
<span class="lineNum">   11079 </span><span class="lineCov">         12 :       storage_class = sc_none;</span>
<span class="lineNum">   11080 </span><span class="lineCov">         12 :       staticp = 0;</span>
<span class="lineNum">   11081 </span>            :     }
<span class="lineNum">   11082 </span>            : 
<span class="lineNum">   11083 </span><span class="lineCov">   51838620 :   if (!id_declarator)</span>
<span class="lineNum">   11084 </span>            :     unqualified_id = NULL_TREE;
<span class="lineNum">   11085 </span>            :   else
<span class="lineNum">   11086 </span>            :     {
<span class="lineNum">   11087 </span><span class="lineCov">   32503766 :       unqualified_id = id_declarator-&gt;u.id.unqualified_name;</span>
<span class="lineNum">   11088 </span><span class="lineCov">   32503766 :       switch (TREE_CODE (unqualified_id))</span>
<span class="lineNum">   11089 </span>            :         {
<span class="lineNum">   11090 </span><span class="lineCov">     169675 :         case BIT_NOT_EXPR:</span>
<span class="lineNum">   11091 </span><span class="lineCov">     169675 :           unqualified_id = TREE_OPERAND (unqualified_id, 0);</span>
<span class="lineNum">   11092 </span><span class="lineCov">     169675 :           if (TYPE_P (unqualified_id))</span>
<span class="lineNum">   11093 </span><span class="lineCov">     169672 :             unqualified_id = constructor_name (unqualified_id);</span>
<span class="lineNum">   11094 </span>            :           break;
<span class="lineNum">   11095 </span>            : 
<span class="lineNum">   11096 </span>            :         case IDENTIFIER_NODE:
<span class="lineNum">   11097 </span>            :         case TEMPLATE_ID_EXPR:
<span class="lineNum">   11098 </span>            :           break;
<span class="lineNum">   11099 </span>            : 
<span class="lineNum">   11100 </span><span class="lineNoCov">          0 :         default:</span>
<span class="lineNum">   11101 </span><span class="lineNoCov">          0 :           gcc_unreachable ();</span>
<span class="lineNum">   11102 </span>            :         }
<span class="lineNum">   11103 </span>            :     }
<span class="lineNum">   11104 </span>            : 
<span class="lineNum">   11105 </span><span class="lineCov">   51838620 :   if (declspecs-&gt;std_attributes)</span>
<span class="lineNum">   11106 </span>            :     {
<span class="lineNum">   11107 </span><span class="lineCov">         12 :       location_t attr_loc = declspecs-&gt;locations[ds_std_attribute];</span>
<span class="lineNum">   11108 </span><span class="lineCov">         12 :       if (warning_at (attr_loc, OPT_Wattributes, &quot;attribute ignored&quot;))</span>
<span class="lineNum">   11109 </span><span class="lineCov">         12 :         inform (attr_loc, &quot;an attribute that appertains to a type-specifier &quot;</span>
<span class="lineNum">   11110 </span>            :                 &quot;is ignored&quot;);
<span class="lineNum">   11111 </span>            :     }
<span class="lineNum">   11112 </span>            : 
<span class="lineNum">   11113 </span>            :   /* Determine the type of the entity declared by recurring on the
<span class="lineNum">   11114 </span>            :      declarator.  */
<span class="lineNum">   11115 </span><span class="lineCov">   73355687 :   for (; declarator; declarator = declarator-&gt;declarator)</span>
<span class="lineNum">   11116 </span>            :     {
<span class="lineNum">   11117 </span><span class="lineCov">   54021158 :       const cp_declarator *inner_declarator;</span>
<span class="lineNum">   11118 </span><span class="lineCov">   54021158 :       tree attrs;</span>
<span class="lineNum">   11119 </span>            : 
<span class="lineNum">   11120 </span><span class="lineCov">   54021158 :       if (type == error_mark_node)</span>
<span class="lineNum">   11121 </span><span class="lineCov">        224 :         return error_mark_node;</span>
<span class="lineNum">   11122 </span>            : 
<span class="lineNum">   11123 </span><span class="lineCov">   54020934 :       attrs = declarator-&gt;attributes;</span>
<span class="lineNum">   11124 </span><span class="lineCov">   54020934 :       if (attrs)</span>
<span class="lineNum">   11125 </span>            :         {
<span class="lineNum">   11126 </span><span class="lineCov">       1129 :           int attr_flags;</span>
<span class="lineNum">   11127 </span>            : 
<span class="lineNum">   11128 </span><span class="lineCov">       1129 :           attr_flags = 0;</span>
<span class="lineNum">   11129 </span><span class="lineCov">       1129 :           if (declarator == NULL || declarator-&gt;kind == cdk_id)</span>
<span class="lineNum">   11130 </span><span class="lineCov">        683 :             attr_flags |= (int) ATTR_FLAG_DECL_NEXT;</span>
<span class="lineNum">   11131 </span><span class="lineCov">       1129 :           if (declarator-&gt;kind == cdk_function)</span>
<span class="lineNum">   11132 </span><span class="lineCov">        433 :             attr_flags |= (int) ATTR_FLAG_FUNCTION_NEXT;</span>
<span class="lineNum">   11133 </span><span class="lineCov">       1129 :           if (declarator-&gt;kind == cdk_array)</span>
<span class="lineNum">   11134 </span><span class="lineCov">          2 :             attr_flags |= (int) ATTR_FLAG_ARRAY_NEXT;</span>
<span class="lineNum">   11135 </span><span class="lineCov">       1129 :           returned_attrs = decl_attributes (&amp;type,</span>
<span class="lineNum">   11136 </span>            :                                             chainon (returned_attrs, attrs),
<span class="lineNum">   11137 </span>            :                                             attr_flags);
<span class="lineNum">   11138 </span>            :         }
<span class="lineNum">   11139 </span>            : 
<span class="lineNum">   11140 </span><span class="lineCov">   54020934 :       inner_declarator = declarator-&gt;declarator;</span>
<span class="lineNum">   11141 </span>            : 
<span class="lineNum">   11142 </span>            :       /* We don't want to warn in parameter context because we don't
<span class="lineNum">   11143 </span>            :          yet know if the parse will succeed, and this might turn out
<span class="lineNum">   11144 </span>            :          to be a constructor call.  */
<span class="lineNum">   11145 </span><span class="lineCov">   54020934 :       if (decl_context != PARM</span>
<span class="lineNum">   11146 </span><span class="lineCov">   54020934 :           &amp;&amp; decl_context != TYPENAME</span>
<span class="lineNum">   11147 </span><span class="lineCov">   30287057 :           &amp;&amp; !typedef_p</span>
<span class="lineNum">   11148 </span><span class="lineCov">   27300647 :           &amp;&amp; declarator-&gt;parenthesized != UNKNOWN_LOCATION</span>
<span class="lineNum">   11149 </span>            :           /* If the type is class-like and the inner name used a
<span class="lineNum">   11150 </span>            :              global namespace qualifier, we need the parens.
<span class="lineNum">   11151 </span>            :              Unfortunately all we can tell is whether a qualified name
<span class="lineNum">   11152 </span>            :              was used or not.  */
<span class="lineNum">   11153 </span><span class="lineCov">   54021022 :           &amp;&amp; !(inner_declarator</span>
<span class="lineNum">   11154 </span><span class="lineCov">         57 :                &amp;&amp; inner_declarator-&gt;kind == cdk_id</span>
<span class="lineNum">   11155 </span><span class="lineCov">         48 :                &amp;&amp; inner_declarator-&gt;u.id.qualifying_scope</span>
<span class="lineNum">   11156 </span><span class="lineCov">         12 :                &amp;&amp; (MAYBE_CLASS_TYPE_P (type)</span>
<span class="lineNum">   11157 </span><span class="lineCov">          8 :                    || TREE_CODE (type) == ENUMERAL_TYPE)))</span>
<span class="lineNum">   11158 </span><span class="lineCov">         80 :         warning_at (declarator-&gt;parenthesized, OPT_Wparentheses,</span>
<span class="lineNum">   11159 </span>            :                     &quot;unnecessary parentheses in declaration of %qs&quot;, name);
<span class="lineNum">   11160 </span><span class="lineCov">   54020934 :       if (declarator-&gt;kind == cdk_id || declarator-&gt;kind == cdk_decomp)</span>
<span class="lineNum">   11161 </span>            :         break;
<span class="lineNum">   11162 </span>            : 
<span class="lineNum">   11163 </span><span class="lineCov">   21517133 :       switch (declarator-&gt;kind)</span>
<span class="lineNum">   11164 </span>            :         {
<span class="lineNum">   11165 </span><span class="lineCov">     401331 :         case cdk_array:</span>
<span class="lineNum">   11166 </span><span class="lineCov">    1203993 :           type = create_array_type_for_decl (dname, type,</span>
<span class="lineNum">   11167 </span><span class="lineCov">     401331 :                                              declarator-&gt;u.array.bounds);</span>
<span class="lineNum">   11168 </span><span class="lineCov">     401331 :           if (!valid_array_size_p (input_location, type, dname))</span>
<span class="lineNum">   11169 </span><span class="lineCov">        231 :             type = error_mark_node;</span>
<span class="lineNum">   11170 </span>            : 
<span class="lineNum">   11171 </span><span class="lineCov">     401331 :           if (declarator-&gt;std_attributes)</span>
<span class="lineNum">   11172 </span>            :             /* [dcl.array]/1:
<span class="lineNum">   11173 </span>            : 
<span class="lineNum">   11174 </span>            :                The optional attribute-specifier-seq appertains to the
<span class="lineNum">   11175 </span>            :                array.  */
<span class="lineNum">   11176 </span><span class="lineCov">          7 :             returned_attrs = chainon (returned_attrs,</span>
<span class="lineNum">   11177 </span>            :                                       declarator-&gt;std_attributes);
<span class="lineNum">   11178 </span>            :           break;
<span class="lineNum">   11179 </span>            : 
<span class="lineNum">   11180 </span><span class="lineCov">   10411124 :         case cdk_function:</span>
<span class="lineNum">   11181 </span><span class="lineCov">   10411124 :           {</span>
<span class="lineNum">   11182 </span><span class="lineCov">   10411124 :             tree arg_types;</span>
<span class="lineNum">   11183 </span><span class="lineCov">   10411124 :             int funcdecl_p;</span>
<span class="lineNum">   11184 </span>            : 
<span class="lineNum">   11185 </span>            :             /* Declaring a function type.  */
<span class="lineNum">   11186 </span>            : 
<span class="lineNum">   11187 </span><span class="lineCov">   10411124 :             input_location = declspecs-&gt;locations[ds_type_spec];</span>
<span class="lineNum">   11188 </span><span class="lineCov">   10411124 :             abstract_virtuals_error (ACU_RETURN, type);</span>
<span class="lineNum">   11189 </span><span class="lineCov">   10411124 :             input_location = saved_loc;</span>
<span class="lineNum">   11190 </span>            : 
<span class="lineNum">   11191 </span>            :             /* Pick up type qualifiers which should be applied to `this'.  */
<span class="lineNum">   11192 </span><span class="lineCov">   10411124 :             memfn_quals = declarator-&gt;u.function.qualifiers;</span>
<span class="lineNum">   11193 </span>            :             /* Pick up virt-specifiers.  */
<span class="lineNum">   11194 </span><span class="lineCov">   10411124 :             virt_specifiers = declarator-&gt;u.function.virt_specifiers;</span>
<span class="lineNum">   11195 </span>            :             /* And ref-qualifier, too */
<span class="lineNum">   11196 </span><span class="lineCov">   10411124 :             rqual = declarator-&gt;u.function.ref_qualifier;</span>
<span class="lineNum">   11197 </span>            :             /* And tx-qualifier.  */
<span class="lineNum">   11198 </span><span class="lineCov">   10411124 :             tree tx_qual = declarator-&gt;u.function.tx_qualifier;</span>
<span class="lineNum">   11199 </span>            :             /* Pick up the exception specifications.  */
<span class="lineNum">   11200 </span><span class="lineCov">   10411124 :             raises = declarator-&gt;u.function.exception_specification;</span>
<span class="lineNum">   11201 </span>            :             /* If the exception-specification is ill-formed, let's pretend
<span class="lineNum">   11202 </span>            :                there wasn't one.  */
<span class="lineNum">   11203 </span><span class="lineCov">   10411124 :             if (raises == error_mark_node)</span>
<span class="lineNum">   11204 </span><span class="lineCov">          2 :               raises = NULL_TREE;</span>
<span class="lineNum">   11205 </span>            : 
<span class="lineNum">   11206 </span><span class="lineCov">   10411124 :             if (reqs)</span>
<span class="lineNum">   11207 </span><span class="lineCov">          1 :               error_at (location_of (reqs), &quot;requires-clause on return type&quot;);</span>
<span class="lineNum">   11208 </span><span class="lineCov">   10411124 :             reqs = declarator-&gt;u.function.requires_clause;</span>
<span class="lineNum">   11209 </span>            : 
<span class="lineNum">   11210 </span>            :             /* Say it's a definition only for the CALL_EXPR
<span class="lineNum">   11211 </span>            :                closest to the identifier.  */
<span class="lineNum">   11212 </span><span class="lineCov">   10411124 :             funcdecl_p = inner_declarator &amp;&amp; inner_declarator-&gt;kind == cdk_id;</span>
<span class="lineNum">   11213 </span>            : 
<span class="lineNum">   11214 </span>            :             /* Handle a late-specified return type.  */
<span class="lineNum">   11215 </span><span class="lineCov">   10411124 :             tree late_return_type = declarator-&gt;u.function.late_return_type;</span>
<span class="lineNum">   11216 </span><span class="lineCov">   20822248 :             if (funcdecl_p</span>
<span class="lineNum">   11217 </span>            :                 /* This is the case e.g. for
<span class="lineNum">   11218 </span>            :                    using T = auto () -&gt; int.  */
<span class="lineNum">   11219 </span><span class="lineCov">   10411124 :                 || inner_declarator == NULL)</span>
<span class="lineNum">   11220 </span>            :               {
<span class="lineNum">   11221 </span><span class="lineCov">   10239631 :                 if (tree auto_node = type_uses_auto (type))</span>
<span class="lineNum">   11222 </span>            :                   {
<span class="lineNum">   11223 </span><span class="lineCov">      98747 :                     if (!late_return_type)</span>
<span class="lineNum">   11224 </span>            :                       {
<span class="lineNum">   11225 </span><span class="lineCov">      11718 :                         if (current_class_type</span>
<span class="lineNum">   11226 </span><span class="lineCov">      11718 :                             &amp;&amp; LAMBDA_TYPE_P (current_class_type))</span>
<span class="lineNum">   11227 </span>            :                           /* OK for C++11 lambdas.  */;
<span class="lineNum">   11228 </span><span class="lineCov">       7417 :                         else if (cxx_dialect &lt; cxx14)</span>
<span class="lineNum">   11229 </span>            :                           {
<span class="lineNum">   11230 </span><span class="lineCov">          6 :                             error (&quot;%qs function uses &quot;</span>
<span class="lineNum">   11231 </span>            :                                    &quot;%&lt;auto%&gt; type specifier without trailing &quot;
<span class="lineNum">   11232 </span>            :                                    &quot;return type&quot;, name);
<span class="lineNum">   11233 </span><span class="lineCov">          6 :                             inform (input_location, &quot;deduced return type &quot;</span>
<span class="lineNum">   11234 </span>            :                                     &quot;only available with -std=c++14 or &quot;
<span class="lineNum">   11235 </span>            :                                     &quot;-std=gnu++14&quot;);
<span class="lineNum">   11236 </span>            :                           }
<span class="lineNum">   11237 </span><span class="lineCov">       7411 :                         else if (virtualp)</span>
<span class="lineNum">   11238 </span>            :                           {
<span class="lineNum">   11239 </span><span class="lineCov">          2 :                             error (&quot;virtual function cannot &quot;</span>
<span class="lineNum">   11240 </span>            :                                    &quot;have deduced return type&quot;);
<span class="lineNum">   11241 </span><span class="lineCov">          2 :                             virtualp = false;</span>
<span class="lineNum">   11242 </span>            :                           }
<span class="lineNum">   11243 </span>            :                       }
<span class="lineNum">   11244 </span><span class="lineCov">      87029 :                     else if (!is_auto (type) &amp;&amp; sfk != sfk_conversion)</span>
<span class="lineNum">   11245 </span>            :                       {
<span class="lineNum">   11246 </span><span class="lineCov">          4 :                         error (&quot;%qs function with trailing return type has&quot;</span>
<span class="lineNum">   11247 </span>            :                                &quot; %qT as its type rather than plain %&lt;auto%&gt;&quot;,
<span class="lineNum">   11248 </span>            :                                name, type);
<span class="lineNum">   11249 </span><span class="lineCov">          4 :                         return error_mark_node;</span>
<span class="lineNum">   11250 </span>            :                       }
<span class="lineNum">   11251 </span><span class="lineCov">      87025 :                     else if (is_auto (type) &amp;&amp; AUTO_IS_DECLTYPE (type))</span>
<span class="lineNum">   11252 </span>            :                       {
<span class="lineNum">   11253 </span><span class="lineCov">          2 :                         if (funcdecl_p)</span>
<span class="lineNum">   11254 </span><span class="lineCov">          1 :                           error (&quot;%qs function with trailing return type has &quot;</span>
<span class="lineNum">   11255 </span>            :                                  &quot;%&lt;decltype(auto)%&gt; as its type rather than &quot;
<span class="lineNum">   11256 </span>            :                                  &quot;plain %&lt;auto%&gt;&quot;, name);
<span class="lineNum">   11257 </span>            :                         else
<span class="lineNum">   11258 </span><span class="lineCov">          1 :                           error (&quot;invalid use of %&lt;decltype(auto)%&gt;&quot;);</span>
<span class="lineNum">   11259 </span><span class="lineCov">          2 :                         return error_mark_node;</span>
<span class="lineNum">   11260 </span>            :                       }
<span class="lineNum">   11261 </span><span class="lineCov">      98741 :                     tree tmpl = CLASS_PLACEHOLDER_TEMPLATE (auto_node);</span>
<span class="lineNum">   11262 </span><span class="lineCov">      98741 :                     if (!tmpl)</span>
<span class="lineNum">   11263 </span><span class="lineCov">      92138 :                       if (tree late_auto = type_uses_auto (late_return_type))</span>
<span class="lineNum">   11264 </span><span class="lineCov">          9 :                         tmpl = CLASS_PLACEHOLDER_TEMPLATE (late_auto);</span>
<span class="lineNum">   11265 </span><span class="lineCov">      98741 :                     if (tmpl)</span>
<span class="lineNum">   11266 </span>            :                       {
<span class="lineNum">   11267 </span><span class="lineCov">       6603 :                         if (!dguide_name_p (unqualified_id))</span>
<span class="lineNum">   11268 </span>            :                           {
<span class="lineNum">   11269 </span><span class="lineCov">          2 :                             error_at (declarator-&gt;id_loc, &quot;deduced class &quot;</span>
<span class="lineNum">   11270 </span>            :                                       &quot;type %qD in function return type&quot;,
<span class="lineNum">   11271 </span><span class="lineCov">          1 :                                       DECL_NAME (tmpl));</span>
<span class="lineNum">   11272 </span><span class="lineCov">          1 :                             inform (DECL_SOURCE_LOCATION (tmpl),</span>
<span class="lineNum">   11273 </span>            :                                     &quot;%qD declared here&quot;, tmpl);
<span class="lineNum">   11274 </span><span class="lineCov">          1 :                             return error_mark_node;</span>
<span class="lineNum">   11275 </span>            :                           }
<span class="lineNum">   11276 </span><span class="lineCov">       6602 :                         else if (!late_return_type)</span>
<span class="lineNum">   11277 </span>            :                           {
<span class="lineNum">   11278 </span><span class="lineCov">          2 :                             error_at (declarator-&gt;id_loc, &quot;deduction guide &quot;</span>
<span class="lineNum">   11279 </span>            :                                       &quot;for %qT must have trailing return &quot;
<span class="lineNum">   11280 </span><span class="lineCov">          1 :                                       &quot;type&quot;, TREE_TYPE (tmpl));</span>
<span class="lineNum">   11281 </span><span class="lineCov">          1 :                             inform (DECL_SOURCE_LOCATION (tmpl),</span>
<span class="lineNum">   11282 </span>            :                                     &quot;%qD declared here&quot;, tmpl);
<span class="lineNum">   11283 </span><span class="lineCov">          1 :                             return error_mark_node;</span>
<span class="lineNum">   11284 </span>            :                           }
<span class="lineNum">   11285 </span><span class="lineCov">       6601 :                         else if (CLASS_TYPE_P (late_return_type)</span>
<span class="lineNum">   11286 </span><span class="lineCov">      19803 :                                  &amp;&amp; CLASSTYPE_TEMPLATE_INFO (late_return_type)</span>
<span class="lineNum">   11287 </span><span class="lineCov">      26404 :                                  &amp;&amp; (CLASSTYPE_TI_TEMPLATE (late_return_type)</span>
<span class="lineNum">   11288 </span>            :                                      == tmpl))
<span class="lineNum">   11289 </span>            :                           /* OK */;
<span class="lineNum">   11290 </span>            :                         else
<span class="lineNum">   11291 </span><span class="lineNoCov">          0 :                           error (&quot;trailing return type %qT of deduction guide &quot;</span>
<span class="lineNum">   11292 </span>            :                                  &quot;is not a specialization of %qT&quot;,
<span class="lineNum">   11293 </span><span class="lineNoCov">          0 :                                  late_return_type, TREE_TYPE (tmpl));</span>
<span class="lineNum">   11294 </span>            :                       }
<span class="lineNum">   11295 </span>            :                   }
<span class="lineNum">   11296 </span><span class="lineCov">   10140884 :                 else if (late_return_type</span>
<span class="lineNum">   11297 </span><span class="lineCov">          8 :                          &amp;&amp; sfk != sfk_conversion)</span>
<span class="lineNum">   11298 </span>            :                   {
<span class="lineNum">   11299 </span><span class="lineCov">          8 :                     if (cxx_dialect &lt; cxx11)</span>
<span class="lineNum">   11300 </span>            :                       /* Not using maybe_warn_cpp0x because this should
<span class="lineNum">   11301 </span>            :                          always be an error.  */
<span class="lineNum">   11302 </span><span class="lineCov">          1 :                       error (&quot;trailing return type only available with &quot;</span>
<span class="lineNum">   11303 </span>            :                              &quot;-std=c++11 or -std=gnu++11&quot;);
<span class="lineNum">   11304 </span>            :                     else
<span class="lineNum">   11305 </span><span class="lineCov">          7 :                       error (&quot;%qs function with trailing return type not &quot;</span>
<span class="lineNum">   11306 </span>            :                              &quot;declared with %&lt;auto%&gt; type specifier&quot;, name);
<span class="lineNum">   11307 </span><span class="lineCov">          8 :                     return error_mark_node;</span>
<span class="lineNum">   11308 </span>            :                   }
<span class="lineNum">   11309 </span>            :               }
<span class="lineNum">   11310 </span><span class="lineCov">   10411108 :             type = splice_late_return_type (type, late_return_type);</span>
<span class="lineNum">   11311 </span><span class="lineCov">   10411108 :             if (type == error_mark_node)</span>
<span class="lineNum">   11312 </span><span class="lineCov">         18 :               return error_mark_node;</span>
<span class="lineNum">   11313 </span>            : 
<span class="lineNum">   11314 </span><span class="lineCov">   10411090 :             if (late_return_type)</span>
<span class="lineNum">   11315 </span>            :               {
<span class="lineNum">   11316 </span><span class="lineCov">      87015 :                 late_return_type_p = true;</span>
<span class="lineNum">   11317 </span><span class="lineCov">      87015 :                 type_quals = cp_type_quals (type);</span>
<span class="lineNum">   11318 </span>            :               }
<span class="lineNum">   11319 </span>            : 
<span class="lineNum">   11320 </span><span class="lineCov">   10411090 :             if (type_quals != TYPE_UNQUALIFIED)</span>
<span class="lineNum">   11321 </span>            :               {
<span class="lineNum">   11322 </span><span class="lineCov">       3260 :                 if (SCALAR_TYPE_P (type) || VOID_TYPE_P (type))</span>
<span class="lineNum">   11323 </span><span class="lineCov">        189 :                   warning_at (typespec_loc, OPT_Wignored_qualifiers, &quot;type &quot;</span>
<span class="lineNum">   11324 </span>            :                               &quot;qualifiers ignored on function return type&quot;);
<span class="lineNum">   11325 </span>            :                 /* We now know that the TYPE_QUALS don't apply to the
<span class="lineNum">   11326 </span>            :                    decl, but to its return type.  */
<span class="lineNum">   11327 </span>            :                 type_quals = TYPE_UNQUALIFIED;
<span class="lineNum">   11328 </span>            :               }
<span class="lineNum">   11329 </span>            : 
<span class="lineNum">   11330 </span>            :             /* Error about some types functions can't return.  */
<span class="lineNum">   11331 </span>            : 
<span class="lineNum">   11332 </span><span class="lineCov">   10411090 :             if (TREE_CODE (type) == FUNCTION_TYPE)</span>
<span class="lineNum">   11333 </span>            :               {
<span class="lineNum">   11334 </span><span class="lineCov">         25 :                 error_at (typespec_loc, &quot;%qs declared as function returning &quot;</span>
<span class="lineNum">   11335 </span>            :                           &quot;a function&quot;, name);
<span class="lineNum">   11336 </span><span class="lineCov">         25 :                 return error_mark_node;</span>
<span class="lineNum">   11337 </span>            :               }
<span class="lineNum">   11338 </span><span class="lineCov">   10411065 :             if (TREE_CODE (type) == ARRAY_TYPE)</span>
<span class="lineNum">   11339 </span>            :               {
<span class="lineNum">   11340 </span><span class="lineCov">          4 :                 error_at (typespec_loc, &quot;%qs declared as function returning &quot;</span>
<span class="lineNum">   11341 </span>            :                           &quot;an array&quot;, name);
<span class="lineNum">   11342 </span><span class="lineCov">          4 :                 return error_mark_node;</span>
<span class="lineNum">   11343 </span>            :               }
<span class="lineNum">   11344 </span>            : 
<span class="lineNum">   11345 </span><span class="lineCov">   10411061 :             if (ctype == NULL_TREE</span>
<span class="lineNum">   11346 </span><span class="lineCov">   10411061 :                 &amp;&amp; decl_context == FIELD</span>
<span class="lineNum">   11347 </span><span class="lineCov">   10411061 :                 &amp;&amp; funcdecl_p</span>
<span class="lineNum">   11348 </span><span class="lineCov">    4252521 :                 &amp;&amp; friendp == 0)</span>
<span class="lineNum">   11349 </span><span class="lineCov">    4185747 :               ctype = current_class_type;</span>
<span class="lineNum">   11350 </span>            : 
<span class="lineNum">   11351 </span><span class="lineCov">   10411061 :             if (ctype &amp;&amp; (sfk == sfk_constructor</span>
<span class="lineNum">   11352 </span><span class="lineCov">    4185747 :                           || sfk == sfk_destructor))</span>
<span class="lineNum">   11353 </span>            :               {
<span class="lineNum">   11354 </span>            :                 /* We are within a class's scope. If our declarator name
<span class="lineNum">   11355 </span>            :                    is the same as the class name, and we are defining
<span class="lineNum">   11356 </span>            :                    a function, then it is a constructor/destructor, and
<span class="lineNum">   11357 </span>            :                    therefore returns a void type.  */
<span class="lineNum">   11358 </span>            : 
<span class="lineNum">   11359 </span>            :                 /* ISO C++ 12.4/2.  A destructor may not be declared
<span class="lineNum">   11360 </span>            :                    const or volatile.  A destructor may not be static.
<span class="lineNum">   11361 </span>            :                    A destructor may not be declared with ref-qualifier.
<span class="lineNum">   11362 </span>            : 
<span class="lineNum">   11363 </span>            :                    ISO C++ 12.1.  A constructor may not be declared
<span class="lineNum">   11364 </span>            :                    const or volatile.  A constructor may not be
<span class="lineNum">   11365 </span>            :                    virtual.  A constructor may not be static.
<span class="lineNum">   11366 </span>            :                    A constructor may not be declared with ref-qualifier. */
<span class="lineNum">   11367 </span><span class="lineCov">    1075705 :                 if (staticp == 2)</span>
<span class="lineNum">   11368 </span><span class="lineNoCov">          0 :                   error ((flags == DTOR_FLAG)</span>
<span class="lineNum">   11369 </span>            :                          ? G_(&quot;destructor cannot be static member function&quot;)
<span class="lineNum">   11370 </span>            :                          : G_(&quot;constructor cannot be static member function&quot;));
<span class="lineNum">   11371 </span><span class="lineCov">    1075705 :                 if (memfn_quals)</span>
<span class="lineNum">   11372 </span>            :                   {
<span class="lineNum">   11373 </span><span class="lineCov">          9 :                     error ((flags == DTOR_FLAG)</span>
<span class="lineNum">   11374 </span>            :                            ? G_(&quot;destructors may not be cv-qualified&quot;)
<span class="lineNum">   11375 </span>            :                            : G_(&quot;constructors may not be cv-qualified&quot;));
<span class="lineNum">   11376 </span><span class="lineCov">          9 :                     memfn_quals = TYPE_UNQUALIFIED;</span>
<span class="lineNum">   11377 </span>            :                   }
<span class="lineNum">   11378 </span>            : 
<span class="lineNum">   11379 </span><span class="lineCov">    1075705 :                 if (rqual)</span>
<span class="lineNum">   11380 </span>            :                   {
<span class="lineNum">   11381 </span><span class="lineCov">          4 :                     maybe_warn_cpp0x (CPP0X_REF_QUALIFIER);</span>
<span class="lineNum">   11382 </span><span class="lineCov">          4 :                     error ((flags == DTOR_FLAG)</span>
<span class="lineNum">   11383 </span>            :                            ? G_(&quot;destructors may not be ref-qualified&quot;)
<span class="lineNum">   11384 </span>            :                            : G_(&quot;constructors may not be ref-qualified&quot;));
<span class="lineNum">   11385 </span><span class="lineCov">          4 :                     rqual = REF_QUAL_NONE;</span>
<span class="lineNum">   11386 </span>            :                   }
<span class="lineNum">   11387 </span>            : 
<span class="lineNum">   11388 </span><span class="lineCov">    1075705 :                 if (decl_context == FIELD</span>
<span class="lineNum">   11389 </span><span class="lineCov">    1075705 :                     &amp;&amp; !member_function_or_else (ctype,</span>
<span class="lineNum">   11390 </span>            :                                                  current_class_type,
<span class="lineNum">   11391 </span>            :                                                  flags))
<span class="lineNum">   11392 </span><span class="lineNoCov">          0 :                   return error_mark_node;</span>
<span class="lineNum">   11393 </span>            : 
<span class="lineNum">   11394 </span><span class="lineCov">    1075705 :                 if (flags != DTOR_FLAG)</span>
<span class="lineNum">   11395 </span>            :                   {
<span class="lineNum">   11396 </span>            :                     /* It's a constructor.  */
<span class="lineNum">   11397 </span><span class="lineCov">     915041 :                     if (explicitp == 1)</span>
<span class="lineNum">   11398 </span><span class="lineCov">     247910 :                       explicitp = 2;</span>
<span class="lineNum">   11399 </span><span class="lineCov">     915041 :                     if (virtualp)</span>
<span class="lineNum">   11400 </span>            :                       {
<span class="lineNum">   11401 </span><span class="lineCov">          2 :                         permerror (declspecs-&gt;locations[ds_virtual],</span>
<span class="lineNum">   11402 </span>            :                                    &quot;constructors cannot be declared %&lt;virtual%&gt;&quot;);
<span class="lineNum">   11403 </span><span class="lineCov">          2 :                         virtualp = 0;</span>
<span class="lineNum">   11404 </span>            :                       }
<span class="lineNum">   11405 </span><span class="lineCov">    1830082 :                     if (decl_context == FIELD</span>
<span class="lineNum">   11406 </span><span class="lineCov">     915041 :                         &amp;&amp; sfk != sfk_constructor)</span>
<span class="lineNum">   11407 </span><span class="lineNoCov">          0 :                       return error_mark_node;</span>
<span class="lineNum">   11408 </span>            :                   }
<span class="lineNum">   11409 </span><span class="lineCov">    1075705 :                 if (decl_context == FIELD)</span>
<span class="lineNum">   11410 </span><span class="lineCov">    1075705 :                   staticp = 0;</span>
<span class="lineNum">   11411 </span>            :               }
<span class="lineNum">   11412 </span><span class="lineCov">    9335356 :             else if (friendp)</span>
<span class="lineNum">   11413 </span>            :               {
<span class="lineNum">   11414 </span><span class="lineCov">      66774 :                 if (virtualp)</span>
<span class="lineNum">   11415 </span>            :                   {
<span class="lineNum">   11416 </span>            :                     /* Cannot be both friend and virtual.  */
<span class="lineNum">   11417 </span><span class="lineCov">         20 :                     gcc_rich_location richloc (declspecs-&gt;locations[ds_virtual]);</span>
<span class="lineNum">   11418 </span><span class="lineCov">         10 :                     richloc.add_range (declspecs-&gt;locations[ds_friend]);</span>
<span class="lineNum">   11419 </span><span class="lineCov">         10 :                     error_at (&amp;richloc, &quot;virtual functions cannot be friends&quot;);</span>
<span class="lineNum">   11420 </span><span class="lineCov">         10 :                     friendp = 0;</span>
<span class="lineNum">   11421 </span>            :                   }
<span class="lineNum">   11422 </span><span class="lineCov">      66774 :                 if (decl_context == NORMAL)</span>
<span class="lineNum">   11423 </span><span class="lineNoCov">          0 :                   error (&quot;friend declaration not in class definition&quot;);</span>
<span class="lineNum">   11424 </span><span class="lineCov">      66774 :                 if (current_function_decl &amp;&amp; funcdef_flag)</span>
<span class="lineNum">   11425 </span>            :                   {
<span class="lineNum">   11426 </span><span class="lineCov">          5 :                     error (&quot;can%'t define friend function %qs in a local &quot;</span>
<span class="lineNum">   11427 </span>            :                            &quot;class definition&quot;, name);
<span class="lineNum">   11428 </span><span class="lineCov">          5 :                     friendp = 0;</span>
<span class="lineNum">   11429 </span>            :                   }
<span class="lineNum">   11430 </span>            :               }
<span class="lineNum">   11431 </span><span class="lineCov">    9268582 :             else if (ctype &amp;&amp; sfk == sfk_conversion)</span>
<span class="lineNum">   11432 </span>            :               {
<span class="lineNum">   11433 </span><span class="lineCov">      25487 :                 if (explicitp == 1)</span>
<span class="lineNum">   11434 </span>            :                   {
<span class="lineNum">   11435 </span><span class="lineCov">      10284 :                     maybe_warn_cpp0x (CPP0X_EXPLICIT_CONVERSION);</span>
<span class="lineNum">   11436 </span><span class="lineCov">      10284 :                     explicitp = 2;</span>
<span class="lineNum">   11437 </span>            :                   }
<span class="lineNum">   11438 </span><span class="lineCov">      25487 :                 if (late_return_type_p)</span>
<span class="lineNum">   11439 </span><span class="lineCov">          2 :                   error (&quot;a conversion function cannot have a trailing return type&quot;);</span>
<span class="lineNum">   11440 </span>            :               }
<span class="lineNum">   11441 </span><span class="lineCov">    9243095 :             else if (sfk == sfk_deduction_guide)</span>
<span class="lineNum">   11442 </span>            :               {
<span class="lineNum">   11443 </span><span class="lineCov">       6601 :                 if (explicitp == 1)</span>
<span class="lineNum">   11444 </span><span class="lineCov">          1 :                   explicitp = 2;</span>
<span class="lineNum">   11445 </span>            :               }
<span class="lineNum">   11446 </span>            : 
<span class="lineNum">   11447 </span><span class="lineCov">   10411061 :             tree pushed_scope = NULL_TREE;</span>
<span class="lineNum">   11448 </span><span class="lineCov">   10411061 :             if (funcdecl_p</span>
<span class="lineNum">   11449 </span><span class="lineCov">   10411061 :                 &amp;&amp; decl_context != FIELD</span>
<span class="lineNum">   11450 </span><span class="lineCov">    5878372 :                 &amp;&amp; inner_declarator-&gt;u.id.qualifying_scope</span>
<span class="lineNum">   11451 </span><span class="lineCov">   10822263 :                 &amp;&amp; CLASS_TYPE_P (inner_declarator-&gt;u.id.qualifying_scope))</span>
<span class="lineNum">   11452 </span><span class="lineCov">     409989 :               pushed_scope</span>
<span class="lineNum">   11453 </span><span class="lineCov">     409989 :                 = push_scope (inner_declarator-&gt;u.id.qualifying_scope);</span>
<span class="lineNum">   11454 </span>            : 
<span class="lineNum">   11455 </span><span class="lineCov">   10411061 :             arg_types = grokparms (declarator-&gt;u.function.parameters, &amp;parms);</span>
<span class="lineNum">   11456 </span>            : 
<span class="lineNum">   11457 </span><span class="lineCov">   10411061 :             if (pushed_scope)</span>
<span class="lineNum">   11458 </span><span class="lineCov">     409989 :               pop_scope (pushed_scope);</span>
<span class="lineNum">   11459 </span>            : 
<span class="lineNum">   11460 </span><span class="lineCov">   10411061 :             if (inner_declarator</span>
<span class="lineNum">   11461 </span><span class="lineCov">   10302386 :                 &amp;&amp; inner_declarator-&gt;kind == cdk_id</span>
<span class="lineNum">   11462 </span><span class="lineCov">   10130893 :                 &amp;&amp; inner_declarator-&gt;u.id.sfk == sfk_destructor</span>
<span class="lineNum">   11463 </span><span class="lineCov">     169669 :                 &amp;&amp; arg_types != void_list_node)</span>
<span class="lineNum">   11464 </span>            :               {
<span class="lineNum">   11465 </span><span class="lineCov">         18 :                 error (&quot;destructors may not have parameters&quot;);</span>
<span class="lineNum">   11466 </span><span class="lineCov">         18 :                 arg_types = void_list_node;</span>
<span class="lineNum">   11467 </span><span class="lineCov">         18 :                 parms = NULL_TREE;</span>
<span class="lineNum">   11468 </span>            :               }
<span class="lineNum">   11469 </span>            : 
<span class="lineNum">   11470 </span><span class="lineCov">   10411061 :             type = build_function_type (type, arg_types);</span>
<span class="lineNum">   11471 </span>            : 
<span class="lineNum">   11472 </span><span class="lineCov">   10411061 :             tree attrs = declarator-&gt;std_attributes;</span>
<span class="lineNum">   11473 </span><span class="lineCov">   10411061 :             if (tx_qual)</span>
<span class="lineNum">   11474 </span>            :               {
<span class="lineNum">   11475 </span><span class="lineCov">        133 :                 tree att = build_tree_list (tx_qual, NULL_TREE);</span>
<span class="lineNum">   11476 </span>            :                 /* transaction_safe applies to the type, but
<span class="lineNum">   11477 </span>            :                    transaction_safe_dynamic applies to the function.  */
<span class="lineNum">   11478 </span><span class="lineCov">        133 :                 if (is_attribute_p (&quot;transaction_safe&quot;, tx_qual))</span>
<span class="lineNum">   11479 </span><span class="lineCov">        102 :                   attrs = chainon (attrs, att);</span>
<span class="lineNum">   11480 </span>            :                 else
<span class="lineNum">   11481 </span><span class="lineCov">         31 :                   returned_attrs = chainon (returned_attrs, att);</span>
<span class="lineNum">   11482 </span>            :               }
<span class="lineNum">   11483 </span><span class="lineCov">   10411061 :             if (attrs)</span>
<span class="lineNum">   11484 </span>            :               /* [dcl.fct]/2:
<span class="lineNum">   11485 </span>            : 
<span class="lineNum">   11486 </span>            :                  The optional attribute-specifier-seq appertains to
<span class="lineNum">   11487 </span>            :                  the function type.  */
<span class="lineNum">   11488 </span><span class="lineCov">        106 :               decl_attributes (&amp;type, attrs, 0);</span>
<span class="lineNum">   11489 </span>            : 
<span class="lineNum">   11490 </span><span class="lineCov">   10411061 :             if (raises)</span>
<span class="lineNum">   11491 </span><span class="lineCov">    3917279 :               type = build_exception_variant (type, raises);</span>
<span class="lineNum">   11492 </span>            :           }
<span class="lineNum">   11493 </span>            :           break;
<span class="lineNum">   11494 </span>            : 
<span class="lineNum">   11495 </span><span class="lineCov">   10704678 :         case cdk_pointer:</span>
<span class="lineNum">   11496 </span><span class="lineCov">   10704678 :         case cdk_reference:</span>
<span class="lineNum">   11497 </span><span class="lineCov">   10704678 :         case cdk_ptrmem:</span>
<span class="lineNum">   11498 </span>            :           /* Filter out pointers-to-references and references-to-references.
<span class="lineNum">   11499 </span>            :              We can get these if a TYPE_DECL is used.  */
<span class="lineNum">   11500 </span>            : 
<span class="lineNum">   11501 </span><span class="lineCov">   10704678 :           if (TYPE_REF_P (type))</span>
<span class="lineNum">   11502 </span>            :             {
<span class="lineNum">   11503 </span><span class="lineCov">        158 :               if (declarator-&gt;kind != cdk_reference)</span>
<span class="lineNum">   11504 </span>            :                 {
<span class="lineNum">   11505 </span><span class="lineCov">          3 :                   error (&quot;cannot declare pointer to %q#T&quot;, type);</span>
<span class="lineNum">   11506 </span><span class="lineCov">          3 :                   type = TREE_TYPE (type);</span>
<span class="lineNum">   11507 </span>            :                 }
<span class="lineNum">   11508 </span>            : 
<span class="lineNum">   11509 </span>            :               /* In C++0x, we allow reference to reference declarations
<span class="lineNum">   11510 </span>            :                  that occur indirectly through typedefs [7.1.3/8 dcl.typedef]
<span class="lineNum">   11511 </span>            :                  and template type arguments [14.3.1/4 temp.arg.type]. The
<span class="lineNum">   11512 </span>            :                  check for direct reference to reference declarations, which
<span class="lineNum">   11513 </span>            :                  are still forbidden, occurs below. Reasoning behind the change
<span class="lineNum">   11514 </span>            :                  can be found in DR106, DR540, and the rvalue reference
<span class="lineNum">   11515 </span>            :                  proposals. */
<span class="lineNum">   11516 </span><span class="lineCov">        155 :               else if (cxx_dialect == cxx98)</span>
<span class="lineNum">   11517 </span>            :                 {
<span class="lineNum">   11518 </span><span class="lineNoCov">          0 :                   error (&quot;cannot declare reference to %q#T&quot;, type);</span>
<span class="lineNum">   11519 </span><span class="lineNoCov">          0 :                   type = TREE_TYPE (type);</span>
<span class="lineNum">   11520 </span>            :                 }
<span class="lineNum">   11521 </span>            :             }
<span class="lineNum">   11522 </span><span class="lineCov">   10704520 :           else if (VOID_TYPE_P (type))</span>
<span class="lineNum">   11523 </span>            :             {
<span class="lineNum">   11524 </span><span class="lineCov">     603737 :               if (declarator-&gt;kind == cdk_reference)</span>
<span class="lineNum">   11525 </span><span class="lineCov">          3 :                 error (&quot;cannot declare reference to %q#T&quot;, type);</span>
<span class="lineNum">   11526 </span><span class="lineCov">     603734 :               else if (declarator-&gt;kind == cdk_ptrmem)</span>
<span class="lineNum">   11527 </span><span class="lineCov">          3 :                 error (&quot;cannot declare pointer to %q#T member&quot;, type);</span>
<span class="lineNum">   11528 </span>            :             }
<span class="lineNum">   11529 </span>            : 
<span class="lineNum">   11530 </span>            :           /* We now know that the TYPE_QUALS don't apply to the decl,
<span class="lineNum">   11531 </span>            :              but to the target of the pointer.  */
<span class="lineNum">   11532 </span><span class="lineCov">   10704678 :           type_quals = TYPE_UNQUALIFIED;</span>
<span class="lineNum">   11533 </span>            : 
<span class="lineNum">   11534 </span>            :           /* This code used to handle METHOD_TYPE, but I don't think it's
<span class="lineNum">   11535 </span>            :              possible to get it here anymore.  */
<span class="lineNum">   11536 </span><span class="lineCov">   10704678 :           gcc_assert (TREE_CODE (type) != METHOD_TYPE);</span>
<span class="lineNum">   11537 </span><span class="lineCov">   10704678 :           if (declarator-&gt;kind == cdk_ptrmem</span>
<span class="lineNum">   11538 </span><span class="lineCov">     101719 :               &amp;&amp; TREE_CODE (type) == FUNCTION_TYPE)</span>
<span class="lineNum">   11539 </span>            :             {
<span class="lineNum">   11540 </span><span class="lineCov">      71138 :               memfn_quals |= type_memfn_quals (type);</span>
<span class="lineNum">   11541 </span><span class="lineCov">     213414 :               type = build_memfn_type (type,</span>
<span class="lineNum">   11542 </span><span class="lineCov">      71138 :                                        declarator-&gt;u.pointer.class_type,</span>
<span class="lineNum">   11543 </span>            :                                        memfn_quals,
<span class="lineNum">   11544 </span>            :                                        rqual);
<span class="lineNum">   11545 </span><span class="lineCov">      71138 :               if (type == error_mark_node)</span>
<span class="lineNum">   11546 </span><span class="lineCov">          3 :                 return error_mark_node;</span>
<span class="lineNum">   11547 </span>            : 
<span class="lineNum">   11548 </span>            :               rqual = REF_QUAL_NONE;
<span class="lineNum">   11549 </span>            :               memfn_quals = TYPE_UNQUALIFIED;
<span class="lineNum">   11550 </span>            :             }
<span class="lineNum">   11551 </span>            : 
<span class="lineNum">   11552 </span><span class="lineCov">   10704675 :           if (TREE_CODE (type) == FUNCTION_TYPE</span>
<span class="lineNum">   11553 </span><span class="lineCov">   10704675 :               &amp;&amp; (type_memfn_quals (type) != TYPE_UNQUALIFIED</span>
<span class="lineNum">   11554 </span><span class="lineCov">     109555 :                   || type_memfn_rqual (type) != REF_QUAL_NONE))</span>
<span class="lineNum">   11555 </span><span class="lineCov">         12 :             error (declarator-&gt;kind == cdk_reference</span>
<span class="lineNum">   11556 </span>            :                    ? G_(&quot;cannot declare reference to qualified function type %qT&quot;)
<span class="lineNum">   11557 </span>            :                    : G_(&quot;cannot declare pointer to qualified function type %qT&quot;),
<span class="lineNum">   11558 </span>            :                    type);
<span class="lineNum">   11559 </span>            : 
<span class="lineNum">   11560 </span>            :           /* When the pointed-to type involves components of variable size,
<span class="lineNum">   11561 </span>            :              care must be taken to ensure that the size evaluation code is
<span class="lineNum">   11562 </span>            :              emitted early enough to dominate all the possible later uses
<span class="lineNum">   11563 </span>            :              and late enough for the variables on which it depends to have
<span class="lineNum">   11564 </span>            :              been assigned.
<span class="lineNum">   11565 </span>            : 
<span class="lineNum">   11566 </span>            :              This is expected to happen automatically when the pointed-to
<span class="lineNum">   11567 </span>            :              type has a name/declaration of it's own, but special attention
<span class="lineNum">   11568 </span>            :              is required if the type is anonymous.
<span class="lineNum">   11569 </span>            : 
<span class="lineNum">   11570 </span>            :              We handle the NORMAL and FIELD contexts here by inserting a
<span class="lineNum">   11571 </span>            :              dummy statement that just evaluates the size at a safe point
<span class="lineNum">   11572 </span>            :              and ensures it is not deferred until e.g. within a deeper
<span class="lineNum">   11573 </span>            :              conditional context (c++/43555).
<span class="lineNum">   11574 </span>            : 
<span class="lineNum">   11575 </span>            :              We expect nothing to be needed here for PARM or TYPENAME.
<span class="lineNum">   11576 </span>            :              Evaluating the size at this point for TYPENAME would
<span class="lineNum">   11577 </span>            :              actually be incorrect, as we might be in the middle of an
<span class="lineNum">   11578 </span>            :              expression with side effects on the pointed-to type size
<span class="lineNum">   11579 </span>            :              &quot;arguments&quot; prior to the pointer declaration point and the
<span class="lineNum">   11580 </span>            :              size evaluation could end up prior to the side effects.  */
<span class="lineNum">   11581 </span>            : 
<span class="lineNum">   11582 </span><span class="lineCov">   10704675 :           if (!TYPE_NAME (type)</span>
<span class="lineNum">   11583 </span><span class="lineCov">     480916 :               &amp;&amp; (decl_context == NORMAL || decl_context == FIELD)</span>
<span class="lineNum">   11584 </span><span class="lineCov">      97614 :               &amp;&amp; at_function_scope_p ()</span>
<span class="lineNum">   11585 </span><span class="lineCov">   10716065 :               &amp;&amp; variably_modified_type_p (type, NULL_TREE))</span>
<span class="lineNum">   11586 </span>            :             {
<span class="lineNum">   11587 </span><span class="lineCov">         69 :               TYPE_NAME (type) = build_decl (UNKNOWN_LOCATION, TYPE_DECL,</span>
<span class="lineNum">   11588 </span>            :                                              NULL_TREE, type);
<span class="lineNum">   11589 </span><span class="lineCov">         69 :               add_decl_expr (TYPE_NAME (type));</span>
<span class="lineNum">   11590 </span>            :             }
<span class="lineNum">   11591 </span>            : 
<span class="lineNum">   11592 </span><span class="lineCov">   10704675 :           if (declarator-&gt;kind == cdk_reference)</span>
<span class="lineNum">   11593 </span>            :             {
<span class="lineNum">   11594 </span>            :               /* In C++0x, the type we are creating a reference to might be
<span class="lineNum">   11595 </span>            :                  a typedef which is itself a reference type. In that case,
<span class="lineNum">   11596 </span>            :                  we follow the reference collapsing rules in
<span class="lineNum">   11597 </span>            :                  [7.1.3/8 dcl.typedef] to create the final reference type:
<span class="lineNum">   11598 </span>            : 
<span class="lineNum">   11599 </span>            :                  &quot;If a typedef TD names a type that is a reference to a type
<span class="lineNum">   11600 </span>            :                  T, an attempt to create the type 'lvalue reference to cv TD'
<span class="lineNum">   11601 </span>            :                  creates the type 'lvalue reference to T,' while an attempt
<span class="lineNum">   11602 </span>            :                  to create the type &quot;rvalue reference to cv TD' creates the
<span class="lineNum">   11603 </span>            :                  type TD.&quot;
<span class="lineNum">   11604 </span>            :               */
<span class="lineNum">   11605 </span><span class="lineCov">    4682946 :               if (VOID_TYPE_P (type))</span>
<span class="lineNum">   11606 </span>            :                 /* We already gave an error.  */;
<span class="lineNum">   11607 </span><span class="lineCov">    4682943 :               else if (TYPE_REF_P (type))</span>
<span class="lineNum">   11608 </span>            :                 {
<span class="lineNum">   11609 </span><span class="lineCov">        155 :                   if (declarator-&gt;u.reference.rvalue_ref)</span>
<span class="lineNum">   11610 </span>            :                     /* Leave type alone.  */;
<span class="lineNum">   11611 </span>            :                   else
<span class="lineNum">   11612 </span><span class="lineCov">         77 :                     type = cp_build_reference_type (TREE_TYPE (type), false);</span>
<span class="lineNum">   11613 </span>            :                 }
<span class="lineNum">   11614 </span>            :               else
<span class="lineNum">   11615 </span><span class="lineCov">    4682788 :                 type = cp_build_reference_type</span>
<span class="lineNum">   11616 </span><span class="lineCov">    4682788 :                   (type, declarator-&gt;u.reference.rvalue_ref);</span>
<span class="lineNum">   11617 </span>            : 
<span class="lineNum">   11618 </span>            :               /* In C++0x, we need this check for direct reference to
<span class="lineNum">   11619 </span>            :                  reference declarations, which are forbidden by
<span class="lineNum">   11620 </span>            :                  [8.3.2/5 dcl.ref]. Reference to reference declarations
<span class="lineNum">   11621 </span>            :                  are only allowed indirectly through typedefs and template
<span class="lineNum">   11622 </span>            :                  type arguments. Example:
<span class="lineNum">   11623 </span>            : 
<span class="lineNum">   11624 </span>            :                    void foo(int &amp; &amp;);      // invalid ref-to-ref decl
<span class="lineNum">   11625 </span>            : 
<span class="lineNum">   11626 </span>            :                    typedef int &amp; int_ref;
<span class="lineNum">   11627 </span>            :                    void foo(int_ref &amp;);    // valid ref-to-ref decl
<span class="lineNum">   11628 </span>            :               */
<span class="lineNum">   11629 </span><span class="lineCov">    4682946 :               if (inner_declarator &amp;&amp; inner_declarator-&gt;kind == cdk_reference)</span>
<span class="lineNum">   11630 </span><span class="lineNoCov">          0 :                 error (&quot;cannot declare reference to %q#T, which is not &quot;</span>
<span class="lineNum">   11631 </span>            :                        &quot;a typedef or a template type argument&quot;, type);
<span class="lineNum">   11632 </span>            :             }
<span class="lineNum">   11633 </span><span class="lineCov">    6021729 :           else if (TREE_CODE (type) == METHOD_TYPE)</span>
<span class="lineNum">   11634 </span><span class="lineCov">      71135 :             type = build_ptrmemfunc_type (build_pointer_type (type));</span>
<span class="lineNum">   11635 </span><span class="lineCov">    5950594 :           else if (declarator-&gt;kind == cdk_ptrmem)</span>
<span class="lineNum">   11636 </span>            :             {
<span class="lineNum">   11637 </span><span class="lineCov">      30581 :               gcc_assert (TREE_CODE (declarator-&gt;u.pointer.class_type)</span>
<span class="lineNum">   11638 </span>            :                           != NAMESPACE_DECL);
<span class="lineNum">   11639 </span><span class="lineCov">      30581 :               if (declarator-&gt;u.pointer.class_type == error_mark_node)</span>
<span class="lineNum">   11640 </span>            :                 /* We will already have complained.  */
<span class="lineNum">   11641 </span><span class="lineCov">          3 :                 type = error_mark_node;</span>
<span class="lineNum">   11642 </span>            :               else
<span class="lineNum">   11643 </span><span class="lineCov">      30578 :                 type = build_ptrmem_type (declarator-&gt;u.pointer.class_type,</span>
<span class="lineNum">   11644 </span>            :                                           type);
<span class="lineNum">   11645 </span>            :             }
<span class="lineNum">   11646 </span>            :           else
<span class="lineNum">   11647 </span><span class="lineCov">    5920013 :             type = build_pointer_type (type);</span>
<span class="lineNum">   11648 </span>            : 
<span class="lineNum">   11649 </span>            :           /* Process a list of type modifier keywords (such as
<span class="lineNum">   11650 </span>            :              const or volatile) that were given inside the `*' or `&amp;'.  */
<span class="lineNum">   11651 </span>            : 
<span class="lineNum">   11652 </span><span class="lineCov">   10704675 :           if (declarator-&gt;u.pointer.qualifiers)</span>
<span class="lineNum">   11653 </span>            :             {
<span class="lineNum">   11654 </span><span class="lineCov">    1077497 :               type</span>
<span class="lineNum">   11655 </span><span class="lineCov">    1077497 :                 = cp_build_qualified_type (type,</span>
<span class="lineNum">   11656 </span>            :                                            declarator-&gt;u.pointer.qualifiers);
<span class="lineNum">   11657 </span><span class="lineCov">    1077497 :               type_quals = cp_type_quals (type);</span>
<span class="lineNum">   11658 </span>            :             }
<span class="lineNum">   11659 </span>            : 
<span class="lineNum">   11660 </span>            :           /* Apply C++11 attributes to the pointer, and not to the
<span class="lineNum">   11661 </span>            :              type pointed to.  This is unlike what is done for GNU
<span class="lineNum">   11662 </span>            :              attributes above.  It is to comply with [dcl.ptr]/1:
<span class="lineNum">   11663 </span>            : 
<span class="lineNum">   11664 </span>            :                  [the optional attribute-specifier-seq (7.6.1) appertains
<span class="lineNum">   11665 </span>            :                   to the pointer and not to the object pointed to].  */
<span class="lineNum">   11666 </span><span class="lineCov">   10704675 :           if (declarator-&gt;std_attributes)</span>
<span class="lineNum">   11667 </span><span class="lineCov">          4 :             decl_attributes (&amp;type, declarator-&gt;std_attributes,</span>
<span class="lineNum">   11668 </span>            :                              0);
<span class="lineNum">   11669 </span>            : 
<span class="lineNum">   11670 </span>            :           ctype = NULL_TREE;
<span class="lineNum">   11671 </span>            :           break;
<span class="lineNum">   11672 </span>            : 
<span class="lineNum">   11673 </span>            :         case cdk_error:
<span class="lineNum">   11674 </span>            :           break;
<span class="lineNum">   11675 </span>            : 
<span class="lineNum">   11676 </span><span class="lineNoCov">          0 :         default:</span>
<span class="lineNum">   11677 </span><span class="lineNoCov">          0 :           gcc_unreachable ();</span>
<span class="lineNum">   11678 </span>            :         }
<span class="lineNum">   11679 </span>            :     }
<span class="lineNum">   11680 </span>            : 
<span class="lineNum">   11681 </span>            :   /* A `constexpr' specifier used in an object declaration declares
<span class="lineNum">   11682 </span>            :      the object as `const'.  */
<span class="lineNum">   11683 </span><span class="lineCov">   51838330 :   if (constexpr_p &amp;&amp; innermost_code != cdk_function)</span>
<span class="lineNum">   11684 </span>            :     {
<span class="lineNum">   11685 </span>            :       /* DR1688 says that a `constexpr' specifier in combination with
<span class="lineNum">   11686 </span>            :          `volatile' is valid.  */
<span class="lineNum">   11687 </span>            : 
<span class="lineNum">   11688 </span><span class="lineCov">     655995 :       if (!TYPE_REF_P (type))</span>
<span class="lineNum">   11689 </span>            :         {
<span class="lineNum">   11690 </span><span class="lineCov">     655866 :           type_quals |= TYPE_QUAL_CONST;</span>
<span class="lineNum">   11691 </span><span class="lineCov">     655866 :           type = cp_build_qualified_type (type, type_quals);</span>
<span class="lineNum">   11692 </span>            :         }
<span class="lineNum">   11693 </span>            :     }
<span class="lineNum">   11694 </span>            : 
<span class="lineNum">   11695 </span><span class="lineCov">   32503486 :   if (unqualified_id &amp;&amp; TREE_CODE (unqualified_id) == TEMPLATE_ID_EXPR</span>
<span class="lineNum">   11696 </span><span class="lineCov">      32783 :       &amp;&amp; TREE_CODE (type) != FUNCTION_TYPE</span>
<span class="lineNum">   11697 </span><span class="lineCov">         51 :       &amp;&amp; TREE_CODE (type) != METHOD_TYPE</span>
<span class="lineNum">   11698 </span><span class="lineCov">   51838381 :       &amp;&amp; !variable_template_p (TREE_OPERAND (unqualified_id, 0)))</span>
<span class="lineNum">   11699 </span>            :     {
<span class="lineNum">   11700 </span><span class="lineNoCov">          0 :       error (&quot;template-id %qD used as a declarator&quot;,</span>
<span class="lineNum">   11701 </span>            :              unqualified_id);
<span class="lineNum">   11702 </span><span class="lineNoCov">          0 :       unqualified_id = dname;</span>
<span class="lineNum">   11703 </span>            :     }
<span class="lineNum">   11704 </span>            : 
<span class="lineNum">   11705 </span>            :   /* If TYPE is a FUNCTION_TYPE, but the function name was explicitly
<span class="lineNum">   11706 </span>            :      qualified with a class-name, turn it into a METHOD_TYPE, unless
<span class="lineNum">   11707 </span>            :      we know that the function is static.  We take advantage of this
<span class="lineNum">   11708 </span>            :      opportunity to do other processing that pertains to entities
<span class="lineNum">   11709 </span>            :      explicitly declared to be class members.  Note that if DECLARATOR
<span class="lineNum">   11710 </span>            :      is non-NULL, we know it is a cdk_id declarator; otherwise, we
<span class="lineNum">   11711 </span>            :      would not have exited the loop above.  */
<span class="lineNum">   11712 </span><span class="lineCov">   51838330 :   if (declarator</span>
<span class="lineNum">   11713 </span><span class="lineCov">   32503801 :       &amp;&amp; declarator-&gt;kind == cdk_id</span>
<span class="lineNum">   11714 </span><span class="lineCov">   32503486 :       &amp;&amp; declarator-&gt;u.id.qualifying_scope</span>
<span class="lineNum">   11715 </span><span class="lineCov">   52312686 :       &amp;&amp; MAYBE_CLASS_TYPE_P (declarator-&gt;u.id.qualifying_scope))</span>
<span class="lineNum">   11716 </span>            :     {
<span class="lineNum">   11717 </span><span class="lineCov">     467018 :       ctype = declarator-&gt;u.id.qualifying_scope;</span>
<span class="lineNum">   11718 </span><span class="lineCov">     467018 :       ctype = TYPE_MAIN_VARIANT (ctype);</span>
<span class="lineNum">   11719 </span><span class="lineCov">     467018 :       template_count = num_template_headers_for_class (ctype);</span>
<span class="lineNum">   11720 </span>            : 
<span class="lineNum">   11721 </span><span class="lineCov">     467018 :       if (ctype == current_class_type)</span>
<span class="lineNum">   11722 </span>            :         {
<span class="lineNum">   11723 </span><span class="lineCov">         54 :           if (friendp)</span>
<span class="lineNum">   11724 </span>            :             {
<span class="lineNum">   11725 </span><span class="lineCov">         15 :               permerror (input_location, &quot;member functions are implicitly &quot;</span>
<span class="lineNum">   11726 </span>            :                                          &quot;friends of their class&quot;);
<span class="lineNum">   11727 </span><span class="lineCov">         15 :               friendp = 0;</span>
<span class="lineNum">   11728 </span>            :             }
<span class="lineNum">   11729 </span>            :           else
<span class="lineNum">   11730 </span><span class="lineCov">         39 :             permerror (declarator-&gt;id_loc, </span>
<span class="lineNum">   11731 </span>            :                        &quot;extra qualification %&lt;%T::%&gt; on member %qs&quot;,
<span class="lineNum">   11732 </span>            :                        ctype, name);
<span class="lineNum">   11733 </span>            :         }
<span class="lineNum">   11734 </span><span class="lineCov">     466964 :       else if (/* If the qualifying type is already complete, then we</span>
<span class="lineNum">   11735 </span>            :                   can skip the following checks.  */
<span class="lineNum">   11736 </span><span class="lineCov">     466964 :                !COMPLETE_TYPE_P (ctype)</span>
<span class="lineNum">   11737 </span><span class="lineCov">        130 :                &amp;&amp; (/* If the function is being defined, then</span>
<span class="lineNum">   11738 </span>            :                       qualifying type must certainly be complete.  */
<span class="lineNum">   11739 </span>            :                    funcdef_flag
<span class="lineNum">   11740 </span>            :                    /* A friend declaration of &quot;T::f&quot; is OK, even if
<span class="lineNum">   11741 </span>            :                       &quot;T&quot; is a template parameter.  But, if this
<span class="lineNum">   11742 </span>            :                       function is not a friend, the qualifying type
<span class="lineNum">   11743 </span>            :                       must be a class.  */
<span class="lineNum">   11744 </span><span class="lineCov">         88 :                    || (!friendp &amp;&amp; !CLASS_TYPE_P (ctype))</span>
<span class="lineNum">   11745 </span>            :                    /* For a declaration, the type need not be
<span class="lineNum">   11746 </span>            :                       complete, if either it is dependent (since there
<span class="lineNum">   11747 </span>            :                       is no meaningful definition of complete in that
<span class="lineNum">   11748 </span>            :                       case) or the qualifying class is currently being
<span class="lineNum">   11749 </span>            :                       defined.  */
<span class="lineNum">   11750 </span><span class="lineCov">        101 :                    || !(dependent_type_p (ctype)</span>
<span class="lineNum">   11751 </span><span class="lineCov">         24 :                         || currently_open_class (ctype)))</span>
<span class="lineNum">   11752 </span>            :                /* Check that the qualifying type is complete.  */
<span class="lineNum">   11753 </span><span class="lineCov">     467032 :                &amp;&amp; !complete_type_or_else (ctype, NULL_TREE))</span>
<span class="lineNum">   11754 </span><span class="lineCov">         68 :         return error_mark_node;</span>
<span class="lineNum">   11755 </span><span class="lineCov">     466896 :       else if (TREE_CODE (type) == FUNCTION_TYPE)</span>
<span class="lineNum">   11756 </span>            :         {
<span class="lineNum">   11757 </span><span class="lineCov">     410180 :           if (current_class_type</span>
<span class="lineNum">   11758 </span><span class="lineCov">        218 :               &amp;&amp; (!friendp || funcdef_flag || initialized))</span>
<span class="lineNum">   11759 </span>            :             {
<span class="lineNum">   11760 </span><span class="lineCov">         50 :               error (funcdef_flag || initialized</span>
<span class="lineNum">   11761 </span>            :                      ? G_(&quot;cannot define member function %&lt;%T::%s%&gt; &quot;
<span class="lineNum">   11762 </span>            :                           &quot;within %qT&quot;)
<span class="lineNum">   11763 </span>            :                      : G_(&quot;cannot declare member function %&lt;%T::%s%&gt; &quot;
<span class="lineNum">   11764 </span>            :                           &quot;within %qT&quot;),
<span class="lineNum">   11765 </span>            :                      ctype, name, current_class_type);
<span class="lineNum">   11766 </span><span class="lineCov">         41 :               return error_mark_node;</span>
<span class="lineNum">   11767 </span>            :             }
<span class="lineNum">   11768 </span>            :         }
<span class="lineNum">   11769 </span><span class="lineCov">      56716 :       else if (typedef_p &amp;&amp; current_class_type)</span>
<span class="lineNum">   11770 </span>            :         {
<span class="lineNum">   11771 </span><span class="lineNoCov">          0 :           error (&quot;cannot declare member %&lt;%T::%s%&gt; within %qT&quot;,</span>
<span class="lineNum">   11772 </span>            :                  ctype, name, current_class_type);
<span class="lineNum">   11773 </span><span class="lineNoCov">          0 :           return error_mark_node;</span>
<span class="lineNum">   11774 </span>            :         }
<span class="lineNum">   11775 </span>            :     }
<span class="lineNum">   11776 </span>            : 
<span class="lineNum">   11777 </span><span class="lineCov">   51838221 :   if (ctype == NULL_TREE &amp;&amp; decl_context == FIELD &amp;&amp; friendp == 0)</span>
<span class="lineNum">   11778 </span><span class="lineCov">    3717357 :     ctype = current_class_type;</span>
<span class="lineNum">   11779 </span>            : 
<span class="lineNum">   11780 </span>            :   /* Now TYPE has the actual type.  */
<span class="lineNum">   11781 </span>            : 
<span class="lineNum">   11782 </span><span class="lineCov">   51838221 :   if (returned_attrs)</span>
<span class="lineNum">   11783 </span>            :     {
<span class="lineNum">   11784 </span><span class="lineCov">        980 :       if (attrlist)</span>
<span class="lineNum">   11785 </span><span class="lineCov">        980 :         *attrlist = chainon (returned_attrs, *attrlist);</span>
<span class="lineNum">   11786 </span>            :       else
<span class="lineNum">   11787 </span>            :         attrlist = &amp;returned_attrs;
<span class="lineNum">   11788 </span>            :     }
<span class="lineNum">   11789 </span>            : 
<span class="lineNum">   11790 </span><span class="lineCov">   51838221 :   if (declarator</span>
<span class="lineNum">   11791 </span><span class="lineCov">   32503692 :       &amp;&amp; declarator-&gt;kind == cdk_id</span>
<span class="lineNum">   11792 </span><span class="lineCov">   32503377 :       &amp;&amp; declarator-&gt;std_attributes</span>
<span class="lineNum">   11793 </span><span class="lineCov">       1138 :       &amp;&amp; attrlist != NULL)</span>
<span class="lineNum">   11794 </span>            :     {
<span class="lineNum">   11795 </span>            :       /* [dcl.meaning]/1: The optional attribute-specifier-seq following
<span class="lineNum">   11796 </span>            :          a declarator-id appertains to the entity that is declared.  */
<span class="lineNum">   11797 </span><span class="lineCov">       1136 :       if (declarator-&gt;std_attributes != error_mark_node)</span>
<span class="lineNum">   11798 </span><span class="lineCov">       1128 :         *attrlist = chainon (*attrlist, declarator-&gt;std_attributes);</span>
<span class="lineNum">   11799 </span>            :       else
<span class="lineNum">   11800 </span>            :         /* We should have already diagnosed the issue (c++/78344).  */
<span class="lineNum">   11801 </span><span class="lineCov">          8 :         gcc_assert (seen_error ());</span>
<span class="lineNum">   11802 </span>            :     }
<span class="lineNum">   11803 </span>            : 
<span class="lineNum">   11804 </span>            :   /* Handle parameter packs. */
<span class="lineNum">   11805 </span><span class="lineCov">   51838221 :   if (parameter_pack_p)</span>
<span class="lineNum">   11806 </span>            :     {
<span class="lineNum">   11807 </span><span class="lineCov">      83738 :       if (decl_context == PARM)</span>
<span class="lineNum">   11808 </span>            :         /* Turn the type into a pack expansion.*/
<span class="lineNum">   11809 </span><span class="lineCov">      83738 :         type = make_pack_expansion (type);</span>
<span class="lineNum">   11810 </span>            :       else
<span class="lineNum">   11811 </span><span class="lineNoCov">          0 :         error (&quot;non-parameter %qs cannot be a parameter pack&quot;, name);</span>
<span class="lineNum">   11812 </span>            :     }
<span class="lineNum">   11813 </span>            : 
<span class="lineNum">   11814 </span><span class="lineCov">   51838221 :   if ((decl_context == FIELD || decl_context == PARM)</span>
<span class="lineNum">   11815 </span><span class="lineCov">   25157947 :       &amp;&amp; !processing_template_decl</span>
<span class="lineNum">   11816 </span><span class="lineCov">   64761802 :       &amp;&amp; variably_modified_type_p (type, NULL_TREE))</span>
<span class="lineNum">   11817 </span>            :     {
<span class="lineNum">   11818 </span><span class="lineCov">          3 :       if (decl_context == FIELD)</span>
<span class="lineNum">   11819 </span><span class="lineCov">          3 :         error (&quot;data member may not have variably modified type %qT&quot;, type);</span>
<span class="lineNum">   11820 </span>            :       else
<span class="lineNum">   11821 </span><span class="lineNoCov">          0 :         error (&quot;parameter may not have variably modified type %qT&quot;, type);</span>
<span class="lineNum">   11822 </span><span class="lineCov">          3 :       type = error_mark_node;</span>
<span class="lineNum">   11823 </span>            :     }
<span class="lineNum">   11824 </span>            : 
<span class="lineNum">   11825 </span><span class="lineCov">   51838221 :   if (explicitp == 1 || (explicitp &amp;&amp; friendp))</span>
<span class="lineNum">   11826 </span>            :     {
<span class="lineNum">   11827 </span>            :       /* [dcl.fct.spec] (C++11) The explicit specifier shall be used only
<span class="lineNum">   11828 </span>            :          in the declaration of a constructor or conversion function within
<span class="lineNum">   11829 </span>            :          a class definition.  */
<span class="lineNum">   11830 </span><span class="lineCov">         23 :       if (!current_class_type)</span>
<span class="lineNum">   11831 </span><span class="lineCov">         10 :         error_at (declspecs-&gt;locations[ds_explicit],</span>
<span class="lineNum">   11832 </span>            :                   &quot;%&lt;explicit%&gt; outside class declaration&quot;);
<span class="lineNum">   11833 </span><span class="lineCov">         13 :       else if (friendp)</span>
<span class="lineNum">   11834 </span><span class="lineCov">         11 :         error_at (declspecs-&gt;locations[ds_explicit],</span>
<span class="lineNum">   11835 </span>            :                   &quot;%&lt;explicit%&gt; in friend declaration&quot;);
<span class="lineNum">   11836 </span>            :       else
<span class="lineNum">   11837 </span><span class="lineCov">          2 :         error_at (declspecs-&gt;locations[ds_explicit],</span>
<span class="lineNum">   11838 </span>            :                   &quot;only declarations of constructors and conversion operators &quot;
<span class="lineNum">   11839 </span>            :                   &quot;can be %&lt;explicit%&gt;&quot;);
<span class="lineNum">   11840 </span>            :       explicitp = 0;
<span class="lineNum">   11841 </span>            :     }
<span class="lineNum">   11842 </span>            : 
<span class="lineNum">   11843 </span><span class="lineCov">   51838221 :   if (storage_class == sc_mutable)</span>
<span class="lineNum">   11844 </span>            :     {
<span class="lineNum">   11845 </span><span class="lineCov">      10553 :       if (decl_context != FIELD || friendp)</span>
<span class="lineNum">   11846 </span>            :         {
<span class="lineNum">   11847 </span><span class="lineCov">         12 :           error (&quot;non-member %qs cannot be declared %&lt;mutable%&gt;&quot;, name);</span>
<span class="lineNum">   11848 </span><span class="lineCov">         12 :           storage_class = sc_none;</span>
<span class="lineNum">   11849 </span>            :         }
<span class="lineNum">   11850 </span><span class="lineCov">      10541 :       else if (decl_context == TYPENAME || typedef_p)</span>
<span class="lineNum">   11851 </span>            :         {
<span class="lineNum">   11852 </span><span class="lineNoCov">          0 :           error (&quot;non-object member %qs cannot be declared %&lt;mutable%&gt;&quot;, name);</span>
<span class="lineNum">   11853 </span><span class="lineNoCov">          0 :           storage_class = sc_none;</span>
<span class="lineNum">   11854 </span>            :         }
<span class="lineNum">   11855 </span><span class="lineCov">      21082 :       else if (TREE_CODE (type) == FUNCTION_TYPE</span>
<span class="lineNum">   11856 </span><span class="lineCov">      10541 :                || TREE_CODE (type) == METHOD_TYPE)</span>
<span class="lineNum">   11857 </span>            :         {
<span class="lineNum">   11858 </span><span class="lineCov">          3 :           error (&quot;function %qs cannot be declared %&lt;mutable%&gt;&quot;, name);</span>
<span class="lineNum">   11859 </span><span class="lineCov">          3 :           storage_class = sc_none;</span>
<span class="lineNum">   11860 </span>            :         }
<span class="lineNum">   11861 </span><span class="lineCov">      10538 :       else if (staticp)</span>
<span class="lineNum">   11862 </span>            :         {
<span class="lineNum">   11863 </span><span class="lineNoCov">          0 :           error (&quot;static %qs cannot be declared %&lt;mutable%&gt;&quot;, name);</span>
<span class="lineNum">   11864 </span><span class="lineNoCov">          0 :           storage_class = sc_none;</span>
<span class="lineNum">   11865 </span>            :         }
<span class="lineNum">   11866 </span><span class="lineCov">      10538 :       else if (type_quals &amp; TYPE_QUAL_CONST)</span>
<span class="lineNum">   11867 </span>            :         {
<span class="lineNum">   11868 </span><span class="lineCov">          9 :           error (&quot;const %qs cannot be declared %&lt;mutable%&gt;&quot;, name);</span>
<span class="lineNum">   11869 </span><span class="lineCov">          9 :           storage_class = sc_none;</span>
<span class="lineNum">   11870 </span>            :         }
<span class="lineNum">   11871 </span><span class="lineCov">      10529 :       else if (TYPE_REF_P (type))</span>
<span class="lineNum">   11872 </span>            :         {
<span class="lineNum">   11873 </span><span class="lineCov">          6 :           permerror (input_location, &quot;reference %qs cannot be declared &quot;</span>
<span class="lineNum">   11874 </span>            :                      &quot;%&lt;mutable%&gt;&quot;, name);
<span class="lineNum">   11875 </span><span class="lineCov">          6 :           storage_class = sc_none;</span>
<span class="lineNum">   11876 </span>            :         }
<span class="lineNum">   11877 </span>            :     }
<span class="lineNum">   11878 </span>            : 
<span class="lineNum">   11879 </span>            :   /* If this is declaring a typedef name, return a TYPE_DECL.  */
<span class="lineNum">   11880 </span><span class="lineCov">   51838221 :   if (typedef_p &amp;&amp; decl_context != TYPENAME)</span>
<span class="lineNum">   11881 </span>            :     {
<span class="lineNum">   11882 </span><span class="lineCov">    2797988 :       tree decl;</span>
<span class="lineNum">   11883 </span>            : 
<span class="lineNum">   11884 </span>            :       /* This declaration:
<span class="lineNum">   11885 </span>            : 
<span class="lineNum">   11886 </span>            :            typedef void f(int) const;
<span class="lineNum">   11887 </span>            : 
<span class="lineNum">   11888 </span>            :          declares a function type which is not a member of any
<span class="lineNum">   11889 </span>            :          particular class, but which is cv-qualified; for
<span class="lineNum">   11890 </span>            :          example &quot;f S::*&quot; declares a pointer to a const-qualified
<span class="lineNum">   11891 </span>            :          member function of S.  We record the cv-qualification in the
<span class="lineNum">   11892 </span>            :          function type.  */
<span class="lineNum">   11893 </span><span class="lineCov">    2797988 :       if ((rqual || memfn_quals) &amp;&amp; TREE_CODE (type) == FUNCTION_TYPE)</span>
<span class="lineNum">   11894 </span>            :         {
<span class="lineNum">   11895 </span><span class="lineCov">         52 :           type = apply_memfn_quals (type, memfn_quals, rqual);</span>
<span class="lineNum">   11896 </span>            :           
<span class="lineNum">   11897 </span>            :           /* We have now dealt with these qualifiers.  */
<span class="lineNum">   11898 </span><span class="lineCov">         52 :           memfn_quals = TYPE_UNQUALIFIED;</span>
<span class="lineNum">   11899 </span><span class="lineCov">         52 :           rqual = REF_QUAL_NONE;</span>
<span class="lineNum">   11900 </span>            :         }
<span class="lineNum">   11901 </span>            : 
<span class="lineNum">   11902 </span><span class="lineCov">    2797988 :       if (type_uses_auto (type))</span>
<span class="lineNum">   11903 </span>            :         {
<span class="lineNum">   11904 </span><span class="lineCov">          5 :           error (&quot;typedef declared %&lt;auto%&gt;&quot;);</span>
<span class="lineNum">   11905 </span><span class="lineCov">          5 :           type = error_mark_node;</span>
<span class="lineNum">   11906 </span>            :         }
<span class="lineNum">   11907 </span>            : 
<span class="lineNum">   11908 </span><span class="lineCov">    2797988 :       if (reqs)</span>
<span class="lineNum">   11909 </span><span class="lineCov">          1 :         error_at (location_of (reqs), &quot;requires-clause on typedef&quot;);</span>
<span class="lineNum">   11910 </span>            : 
<span class="lineNum">   11911 </span><span class="lineCov">    2797988 :       if (id_declarator &amp;&amp; declarator-&gt;u.id.qualifying_scope)</span>
<span class="lineNum">   11912 </span>            :         {
<span class="lineNum">   11913 </span><span class="lineCov">         21 :           error (&quot;typedef name may not be a nested-name-specifier&quot;);</span>
<span class="lineNum">   11914 </span><span class="lineCov">         21 :           type = error_mark_node;</span>
<span class="lineNum">   11915 </span>            :         }
<span class="lineNum">   11916 </span>            : 
<span class="lineNum">   11917 </span><span class="lineCov">    2797988 :       if (decl_context == FIELD)</span>
<span class="lineNum">   11918 </span><span class="lineCov">    1549213 :         decl = build_lang_decl (TYPE_DECL, unqualified_id, type);</span>
<span class="lineNum">   11919 </span>            :       else
<span class="lineNum">   11920 </span><span class="lineCov">    1248775 :         decl = build_decl (input_location, TYPE_DECL, unqualified_id, type);</span>
<span class="lineNum">   11921 </span>            : 
<span class="lineNum">   11922 </span><span class="lineCov">    2797988 :       if (decl_context != FIELD)</span>
<span class="lineNum">   11923 </span>            :         {
<span class="lineNum">   11924 </span><span class="lineCov">    1248775 :           if (!current_function_decl)</span>
<span class="lineNum">   11925 </span><span class="lineCov">     905901 :             DECL_CONTEXT (decl) = FROB_CONTEXT (current_namespace);</span>
<span class="lineNum">   11926 </span><span class="lineCov">     342874 :           else if (DECL_MAYBE_IN_CHARGE_CDTOR_P (current_function_decl))</span>
<span class="lineNum">   11927 </span>            :             /* The TYPE_DECL is &quot;abstract&quot; because there will be
<span class="lineNum">   11928 </span>            :                clones of this constructor/destructor, and there will
<span class="lineNum">   11929 </span>            :                be copies of this TYPE_DECL generated in those
<span class="lineNum">   11930 </span>            :                clones.  The decloning optimization (for space) may
<span class="lineNum">   11931 </span>            :                revert this subsequently if it determines that
<span class="lineNum">   11932 </span>            :                the clones should share a common implementation.  */
<span class="lineNum">   11933 </span><span class="lineCov">       4495 :             DECL_ABSTRACT_P (decl) = true;</span>
<span class="lineNum">   11934 </span>            :         }
<span class="lineNum">   11935 </span><span class="lineCov">    1549213 :       else if (current_class_type</span>
<span class="lineNum">   11936 </span><span class="lineCov">    1549213 :                &amp;&amp; constructor_name_p (unqualified_id, current_class_type))</span>
<span class="lineNum">   11937 </span><span class="lineCov">          2 :         permerror (input_location, &quot;ISO C++ forbids nested type %qD with same name &quot;</span>
<span class="lineNum">   11938 </span>            :                    &quot;as enclosing class&quot;,
<span class="lineNum">   11939 </span>            :                    unqualified_id);
<span class="lineNum">   11940 </span>            : 
<span class="lineNum">   11941 </span>            :       /* If the user declares &quot;typedef struct {...} foo&quot; then the
<span class="lineNum">   11942 </span>            :          struct will have an anonymous name.  Fill that name in now.
<span class="lineNum">   11943 </span>            :          Nothing can refer to it, so nothing needs know about the name
<span class="lineNum">   11944 </span>            :          change.  */
<span class="lineNum">   11945 </span><span class="lineCov">    2797988 :       if (type != error_mark_node</span>
<span class="lineNum">   11946 </span><span class="lineCov">    2797962 :           &amp;&amp; unqualified_id</span>
<span class="lineNum">   11947 </span><span class="lineCov">    2797962 :           &amp;&amp; TYPE_NAME (type)</span>
<span class="lineNum">   11948 </span><span class="lineCov">    5140428 :           &amp;&amp; TREE_CODE (TYPE_NAME (type)) == TYPE_DECL</span>
<span class="lineNum">   11949 </span><span class="lineCov">    2570214 :           &amp;&amp; TYPE_UNNAMED_P (type)</span>
<span class="lineNum">   11950 </span><span class="lineCov">      62683 :           &amp;&amp; declspecs-&gt;type_definition_p</span>
<span class="lineNum">   11951 </span><span class="lineCov">      62679 :           &amp;&amp; attributes_naming_typedef_ok (*attrlist)</span>
<span class="lineNum">   11952 </span><span class="lineCov">    2860664 :           &amp;&amp; cp_type_quals (type) == TYPE_UNQUALIFIED)</span>
<span class="lineNum">   11953 </span><span class="lineCov">      62657 :         name_unnamed_type (type, decl);</span>
<span class="lineNum">   11954 </span>            : 
<span class="lineNum">   11955 </span><span class="lineCov">    2797988 :       if (signed_p</span>
<span class="lineNum">   11956 </span><span class="lineCov">    2797988 :           || (typedef_decl &amp;&amp; C_TYPEDEF_EXPLICITLY_SIGNED (typedef_decl)))</span>
<span class="lineNum">   11957 </span><span class="lineCov">      59968 :         C_TYPEDEF_EXPLICITLY_SIGNED (decl) = 1;</span>
<span class="lineNum">   11958 </span>            : 
<span class="lineNum">   11959 </span><span class="lineCov">    2797988 :       bad_specifiers (decl, BSP_TYPE, virtualp,</span>
<span class="lineNum">   11960 </span>            :                       memfn_quals != TYPE_UNQUALIFIED,
<span class="lineNum">   11961 </span>            :                       inlinep, friendp, raises != NULL_TREE,
<span class="lineNum">   11962 </span>            :                       declspecs-&gt;locations);
<span class="lineNum">   11963 </span>            : 
<span class="lineNum">   11964 </span><span class="lineCov">    2797988 :       if (decl_spec_seq_has_spec_p (declspecs, ds_alias))</span>
<span class="lineNum">   11965 </span>            :         /* Acknowledge that this was written:
<span class="lineNum">   11966 </span>            :              `using analias = atype;'.  */
<span class="lineNum">   11967 </span><span class="lineCov">     422493 :         TYPE_DECL_ALIAS_P (decl) = 1;</span>
<span class="lineNum">   11968 </span>            : 
<span class="lineNum">   11969 </span><span class="lineCov">    2797988 :       return decl;</span>
<span class="lineNum">   11970 </span>            :     }
<span class="lineNum">   11971 </span>            : 
<span class="lineNum">   11972 </span>            :   /* Detect the case of an array type of unspecified size
<span class="lineNum">   11973 </span>            :      which came, as such, direct from a typedef name.
<span class="lineNum">   11974 </span>            :      We must copy the type, so that the array's domain can be
<span class="lineNum">   11975 </span>            :      individually set by the object's initializer.  */
<span class="lineNum">   11976 </span>            : 
<span class="lineNum">   11977 </span><span class="lineCov">   49040233 :   if (type &amp;&amp; typedef_type</span>
<span class="lineNum">   11978 </span><span class="lineCov">   47893279 :       &amp;&amp; TREE_CODE (type) == ARRAY_TYPE &amp;&amp; !TYPE_DOMAIN (type)</span>
<span class="lineNum">   11979 </span><span class="lineCov">   49159135 :       &amp;&amp; TYPE_MAIN_VARIANT (type) == TYPE_MAIN_VARIANT (typedef_type))</span>
<span class="lineNum">   11980 </span><span class="lineCov">         71 :     type = build_cplus_array_type (TREE_TYPE (type), NULL_TREE);</span>
<span class="lineNum">   11981 </span>            : 
<span class="lineNum">   11982 </span>            :   /* Detect where we're using a typedef of function type to declare a
<span class="lineNum">   11983 </span>            :      function. PARMS will not be set, so we must create it now.  */
<span class="lineNum">   11984 </span>            : 
<span class="lineNum">   11985 </span><span class="lineCov">   49040233 :   if (type == typedef_type &amp;&amp; TREE_CODE (type) == FUNCTION_TYPE)</span>
<span class="lineNum">   11986 </span>            :     {
<span class="lineNum">   11987 </span><span class="lineCov">      51956 :       tree decls = NULL_TREE;</span>
<span class="lineNum">   11988 </span><span class="lineCov">      51956 :       tree args;</span>
<span class="lineNum">   11989 </span>            : 
<span class="lineNum">   11990 </span><span class="lineCov">     103912 :       for (args = TYPE_ARG_TYPES (type);</span>
<span class="lineNum">   11991 </span><span class="lineCov">     130054 :            args &amp;&amp; args != void_list_node;</span>
<span class="lineNum">   11992 </span><span class="lineCov">      78098 :            args = TREE_CHAIN (args))</span>
<span class="lineNum">   11993 </span>            :         {
<span class="lineNum">   11994 </span><span class="lineCov">     156196 :           tree decl = cp_build_parm_decl (NULL_TREE, NULL_TREE,</span>
<span class="lineNum">   11995 </span><span class="lineCov">      78098 :                                           TREE_VALUE (args));</span>
<span class="lineNum">   11996 </span>            : 
<span class="lineNum">   11997 </span><span class="lineCov">      78098 :           DECL_CHAIN (decl) = decls;</span>
<span class="lineNum">   11998 </span><span class="lineCov">      78098 :           decls = decl;</span>
<span class="lineNum">   11999 </span>            :         }
<span class="lineNum">   12000 </span>            : 
<span class="lineNum">   12001 </span><span class="lineCov">      51956 :       parms = nreverse (decls);</span>
<span class="lineNum">   12002 </span>            : 
<span class="lineNum">   12003 </span><span class="lineCov">      51956 :       if (decl_context != TYPENAME)</span>
<span class="lineNum">   12004 </span>            :         {
<span class="lineNum">   12005 </span>            :           /* The qualifiers on the function type become the qualifiers on
<span class="lineNum">   12006 </span>            :              the non-static member function. */
<span class="lineNum">   12007 </span><span class="lineCov">      51521 :           memfn_quals |= type_memfn_quals (type);</span>
<span class="lineNum">   12008 </span><span class="lineCov">      51521 :           rqual = type_memfn_rqual (type);</span>
<span class="lineNum">   12009 </span><span class="lineCov">      51521 :           type_quals = TYPE_UNQUALIFIED;</span>
<span class="lineNum">   12010 </span>            :         }
<span class="lineNum">   12011 </span>            :     }
<span class="lineNum">   12012 </span>            : 
<span class="lineNum">   12013 </span>            :   /* If this is a type name (such as, in a cast or sizeof),
<span class="lineNum">   12014 </span>            :      compute the type and return it now.  */
<span class="lineNum">   12015 </span>            : 
<span class="lineNum">   12016 </span><span class="lineCov">   49040233 :   if (decl_context == TYPENAME)</span>
<span class="lineNum">   12017 </span>            :     {
<span class="lineNum">   12018 </span>            :       /* Note that here we don't care about type_quals.  */
<span class="lineNum">   12019 </span>            : 
<span class="lineNum">   12020 </span>            :       /* Special case: &quot;friend class foo&quot; looks like a TYPENAME context.  */
<span class="lineNum">   12021 </span><span class="lineCov">   16919768 :       if (friendp)</span>
<span class="lineNum">   12022 </span>            :         {
<span class="lineNum">   12023 </span><span class="lineNoCov">          0 :           if (inlinep)</span>
<span class="lineNum">   12024 </span>            :             {
<span class="lineNum">   12025 </span><span class="lineNoCov">          0 :               error (&quot;%&lt;inline%&gt; specified for friend class declaration&quot;);</span>
<span class="lineNum">   12026 </span><span class="lineNoCov">          0 :               inlinep = 0;</span>
<span class="lineNum">   12027 </span>            :             }
<span class="lineNum">   12028 </span>            : 
<span class="lineNum">   12029 </span><span class="lineNoCov">          0 :           if (!current_aggr)</span>
<span class="lineNum">   12030 </span>            :             {
<span class="lineNum">   12031 </span>            :               /* Don't allow friend declaration without a class-key.  */
<span class="lineNum">   12032 </span><span class="lineNoCov">          0 :               if (TREE_CODE (type) == TEMPLATE_TYPE_PARM)</span>
<span class="lineNum">   12033 </span><span class="lineNoCov">          0 :                 permerror (input_location, &quot;template parameters cannot be friends&quot;);</span>
<span class="lineNum">   12034 </span><span class="lineNoCov">          0 :               else if (TREE_CODE (type) == TYPENAME_TYPE)</span>
<span class="lineNum">   12035 </span><span class="lineNoCov">          0 :                 permerror (input_location, &quot;friend declaration requires class-key, &quot;</span>
<span class="lineNum">   12036 </span>            :                            &quot;i.e. %&lt;friend class %T::%D%&gt;&quot;,
<span class="lineNum">   12037 </span><span class="lineNoCov">          0 :                            TYPE_CONTEXT (type), TYPENAME_TYPE_FULLNAME (type));</span>
<span class="lineNum">   12038 </span>            :               else
<span class="lineNum">   12039 </span><span class="lineNoCov">          0 :                 permerror (input_location, &quot;friend declaration requires class-key, &quot;</span>
<span class="lineNum">   12040 </span>            :                            &quot;i.e. %&lt;friend %#T%&gt;&quot;,
<span class="lineNum">   12041 </span>            :                            type);
<span class="lineNum">   12042 </span>            :             }
<span class="lineNum">   12043 </span>            : 
<span class="lineNum">   12044 </span>            :           /* Only try to do this stuff if we didn't already give up.  */
<span class="lineNum">   12045 </span><span class="lineNoCov">          0 :           if (type != integer_type_node)</span>
<span class="lineNum">   12046 </span>            :             {
<span class="lineNum">   12047 </span>            :               /* A friendly class?  */
<span class="lineNum">   12048 </span><span class="lineNoCov">          0 :               if (current_class_type)</span>
<span class="lineNum">   12049 </span><span class="lineNoCov">          0 :                 make_friend_class (current_class_type, TYPE_MAIN_VARIANT (type),</span>
<span class="lineNum">   12050 </span>            :                                    /*complain=*/true);
<span class="lineNum">   12051 </span>            :               else
<span class="lineNum">   12052 </span><span class="lineNoCov">          0 :                 error (&quot;trying to make class %qT a friend of global scope&quot;,</span>
<span class="lineNum">   12053 </span>            :                        type);
<span class="lineNum">   12054 </span>            : 
<span class="lineNum">   12055 </span><span class="lineNoCov">          0 :               type = void_type_node;</span>
<span class="lineNum">   12056 </span>            :             }
<span class="lineNum">   12057 </span>            :         }
<span class="lineNum">   12058 </span><span class="lineCov">   16919768 :       else if (memfn_quals || rqual)</span>
<span class="lineNum">   12059 </span>            :         {
<span class="lineNum">   12060 </span><span class="lineCov">      60379 :           if (ctype == NULL_TREE</span>
<span class="lineNum">   12061 </span><span class="lineCov">      60379 :               &amp;&amp; TREE_CODE (type) == METHOD_TYPE)</span>
<span class="lineNum">   12062 </span><span class="lineNoCov">          0 :             ctype = TYPE_METHOD_BASETYPE (type);</span>
<span class="lineNum">   12063 </span>            : 
<span class="lineNum">   12064 </span><span class="lineCov">      60379 :           if (ctype)</span>
<span class="lineNum">   12065 </span><span class="lineNoCov">          0 :             type = build_memfn_type (type, ctype, memfn_quals, rqual);</span>
<span class="lineNum">   12066 </span>            :           /* Core issue #547: need to allow this in template type args.
<span class="lineNum">   12067 </span>            :              Allow it in general in C++11 for alias-declarations.  */
<span class="lineNum">   12068 </span><span class="lineCov">      60379 :           else if ((template_type_arg || cxx_dialect &gt;= cxx11)</span>
<span class="lineNum">   12069 </span><span class="lineCov">      60377 :                    &amp;&amp; TREE_CODE (type) == FUNCTION_TYPE)</span>
<span class="lineNum">   12070 </span><span class="lineCov">      60375 :             type = apply_memfn_quals (type, memfn_quals, rqual);</span>
<span class="lineNum">   12071 </span>            :           else
<span class="lineNum">   12072 </span><span class="lineCov">          4 :             error (&quot;invalid qualifiers on non-member function type&quot;);</span>
<span class="lineNum">   12073 </span>            :         }
<span class="lineNum">   12074 </span>            : 
<span class="lineNum">   12075 </span><span class="lineCov">   16919768 :       if (reqs)</span>
<span class="lineNum">   12076 </span><span class="lineCov">          1 :         error_at (location_of (reqs), &quot;requires-clause on type-id&quot;);</span>
<span class="lineNum">   12077 </span>            : 
<span class="lineNum">   12078 </span><span class="lineCov">   16919768 :       return type;</span>
<span class="lineNum">   12079 </span>            :     }
<span class="lineNum">   12080 </span><span class="lineCov">   32120465 :   else if (unqualified_id == NULL_TREE &amp;&amp; decl_context != PARM</span>
<span class="lineNum">   12081 </span><span class="lineCov">    2415076 :            &amp;&amp; decl_context != CATCHPARM</span>
<span class="lineNum">   12082 </span><span class="lineCov">      24212 :            &amp;&amp; TREE_CODE (type) != UNION_TYPE</span>
<span class="lineNum">   12083 </span><span class="lineCov">      23991 :            &amp;&amp; ! bitfield</span>
<span class="lineNum">   12084 </span><span class="lineCov">      23991 :            &amp;&amp; innermost_code != cdk_decomp)</span>
<span class="lineNum">   12085 </span>            :     {
<span class="lineNum">   12086 </span><span class="lineCov">          6 :       error (&quot;abstract declarator %qT used as declaration&quot;, type);</span>
<span class="lineNum">   12087 </span><span class="lineCov">          6 :       return error_mark_node;</span>
<span class="lineNum">   12088 </span>            :     }
<span class="lineNum">   12089 </span>            : 
<span class="lineNum">   12090 </span><span class="lineCov">   32120459 :   if (!FUNC_OR_METHOD_TYPE_P (type))</span>
<span class="lineNum">   12091 </span>            :     {
<span class="lineNum">   12092 </span>            :       /* Only functions may be declared using an operator-function-id.  */
<span class="lineNum">   12093 </span><span class="lineCov">   21947368 :       if (dname &amp;&amp; IDENTIFIER_ANY_OP_P (dname))</span>
<span class="lineNum">   12094 </span>            :         {
<span class="lineNum">   12095 </span><span class="lineCov">         12 :           error (&quot;declaration of %qD as non-function&quot;, dname);</span>
<span class="lineNum">   12096 </span><span class="lineCov">         12 :           return error_mark_node;</span>
<span class="lineNum">   12097 </span>            :         }
<span class="lineNum">   12098 </span>            : 
<span class="lineNum">   12099 </span><span class="lineCov">   21947356 :       if (reqs)</span>
<span class="lineNum">   12100 </span><span class="lineCov">          5 :         error_at (location_of (reqs),</span>
<span class="lineNum">   12101 </span>            :                   &quot;requires-clause on declaration of non-function type %qT&quot;,
<span class="lineNum">   12102 </span>            :                   type);
<span class="lineNum">   12103 </span>            :     }
<span class="lineNum">   12104 </span>            : 
<span class="lineNum">   12105 </span>            :   /* We don't check parameter types here because we can emit a better
<span class="lineNum">   12106 </span>            :      error message later.  */
<span class="lineNum">   12107 </span><span class="lineCov">   32120447 :   if (decl_context != PARM)</span>
<span class="lineNum">   12108 </span>            :     {
<span class="lineNum">   12109 </span><span class="lineCov">   14932357 :       type = check_var_type (unqualified_id, type);</span>
<span class="lineNum">   12110 </span><span class="lineCov">   14932357 :       if (type == error_mark_node)</span>
<span class="lineNum">   12111 </span>            :         return error_mark_node;
<span class="lineNum">   12112 </span>            :     }
<span class="lineNum">   12113 </span>            : 
<span class="lineNum">   12114 </span>            :   /* Now create the decl, which may be a VAR_DECL, a PARM_DECL
<span class="lineNum">   12115 </span>            :      or a FUNCTION_DECL, depending on DECL_CONTEXT and TYPE.  */
<span class="lineNum">   12116 </span>            : 
<span class="lineNum">   12117 </span><span class="lineCov">   32120384 :   if (decl_context == PARM || decl_context == CATCHPARM)</span>
<span class="lineNum">   12118 </span>            :     {
<span class="lineNum">   12119 </span><span class="lineCov">   17225041 :       if (ctype || in_namespace)</span>
<span class="lineNum">   12120 </span><span class="lineNoCov">          0 :         error (&quot;cannot use %&lt;::%&gt; in parameter declaration&quot;);</span>
<span class="lineNum">   12121 </span>            : 
<span class="lineNum">   12122 </span><span class="lineCov">   17225041 :       if (type_uses_auto (type)</span>
<span class="lineNum">   12123 </span><span class="lineCov">   17225041 :           &amp;&amp; !(cxx_dialect &gt;= cxx17 &amp;&amp; template_parm_flag))</span>
<span class="lineNum">   12124 </span>            :         {
<span class="lineNum">   12125 </span><span class="lineCov">         27 :           if (cxx_dialect &gt;= cxx14)</span>
<span class="lineNum">   12126 </span><span class="lineCov">         20 :             error (&quot;%&lt;auto%&gt; parameter not permitted in this context&quot;);</span>
<span class="lineNum">   12127 </span>            :           else
<span class="lineNum">   12128 </span><span class="lineCov">          7 :             error (&quot;parameter declared %&lt;auto%&gt;&quot;);</span>
<span class="lineNum">   12129 </span><span class="lineCov">         27 :           type = error_mark_node;</span>
<span class="lineNum">   12130 </span>            :         }
<span class="lineNum">   12131 </span>            : 
<span class="lineNum">   12132 </span>            :       /* A parameter declared as an array of T is really a pointer to T.
<span class="lineNum">   12133 </span>            :          One declared as a function is really a pointer to a function.
<span class="lineNum">   12134 </span>            :          One declared as a member is really a pointer to member.  */
<span class="lineNum">   12135 </span>            : 
<span class="lineNum">   12136 </span><span class="lineCov">   17225041 :       if (TREE_CODE (type) == ARRAY_TYPE)</span>
<span class="lineNum">   12137 </span>            :         {
<span class="lineNum">   12138 </span>            :           /* Transfer const-ness of array into that of type pointed to.  */
<span class="lineNum">   12139 </span><span class="lineCov">     134643 :           type = build_pointer_type (TREE_TYPE (type));</span>
<span class="lineNum">   12140 </span><span class="lineCov">     134643 :           type_quals = TYPE_UNQUALIFIED;</span>
<span class="lineNum">   12141 </span><span class="lineCov">     134643 :           array_parameter_p = true;</span>
<span class="lineNum">   12142 </span>            :         }
<span class="lineNum">   12143 </span><span class="lineCov">   17090398 :       else if (TREE_CODE (type) == FUNCTION_TYPE)</span>
<span class="lineNum">   12144 </span><span class="lineCov">        746 :         type = build_pointer_type (type);</span>
<span class="lineNum">   12145 </span>            :     }
<span class="lineNum">   12146 </span>            : 
<span class="lineNum">   12147 </span><span class="lineCov">    6820713 :   if (ctype &amp;&amp; TREE_CODE (type) == FUNCTION_TYPE &amp;&amp; staticp &lt; 2</span>
<span class="lineNum">   12148 </span><span class="lineCov">   35923837 :       &amp;&amp; !(identifier_p (unqualified_id)</span>
<span class="lineNum">   12149 </span><span class="lineCov">   19016235 :            &amp;&amp; IDENTIFIER_NEWDEL_OP_P (unqualified_id)))</span>
<span class="lineNum">   12150 </span>            :     {
<span class="lineNum">   12151 </span><span class="lineCov">    3802973 :       cp_cv_quals real_quals = memfn_quals;</span>
<span class="lineNum">   12152 </span><span class="lineCov">    3802973 :       if (cxx_dialect &lt; cxx14 &amp;&amp; constexpr_p</span>
<span class="lineNum">   12153 </span><span class="lineCov">     894030 :           &amp;&amp; sfk != sfk_constructor &amp;&amp; sfk != sfk_destructor)</span>
<span class="lineNum">   12154 </span><span class="lineCov">       3205 :         real_quals |= TYPE_QUAL_CONST;</span>
<span class="lineNum">   12155 </span><span class="lineCov">    3802973 :       type = build_memfn_type (type, ctype, real_quals, rqual);</span>
<span class="lineNum">   12156 </span>            :     }
<span class="lineNum">   12157 </span>            : 
<span class="lineNum">   12158 </span><span class="lineCov">   32120384 :   {</span>
<span class="lineNum">   12159 </span><span class="lineCov">   32120384 :     tree decl = NULL_TREE;</span>
<span class="lineNum">   12160 </span>            : 
<span class="lineNum">   12161 </span><span class="lineCov">   32120384 :     if (decl_context == PARM)</span>
<span class="lineNum">   12162 </span>            :       {
<span class="lineNum">   12163 </span><span class="lineCov">   17188090 :         decl = cp_build_parm_decl (NULL_TREE, unqualified_id, type);</span>
<span class="lineNum">   12164 </span><span class="lineCov">   17188090 :         DECL_ARRAY_PARAMETER_P (decl) = array_parameter_p;</span>
<span class="lineNum">   12165 </span>            : 
<span class="lineNum">   12166 </span><span class="lineCov">   17188090 :         bad_specifiers (decl, BSP_PARM, virtualp,</span>
<span class="lineNum">   12167 </span>            :                         memfn_quals != TYPE_UNQUALIFIED,
<span class="lineNum">   12168 </span>            :                         inlinep, friendp, raises != NULL_TREE,
<span class="lineNum">   12169 </span>            :                         declspecs-&gt;locations);
<span class="lineNum">   12170 </span>            :       }
<span class="lineNum">   12171 </span><span class="lineCov">   14932294 :     else if (decl_context == FIELD)</span>
<span class="lineNum">   12172 </span>            :       {
<span class="lineNum">   12173 </span><span class="lineCov">    6420623 :         if (!staticp &amp;&amp; !friendp &amp;&amp; TREE_CODE (type) != METHOD_TYPE)</span>
<span class="lineNum">   12174 </span><span class="lineCov">    1406580 :           if (tree auto_node = type_uses_auto (type))</span>
<span class="lineNum">   12175 </span>            :             {
<span class="lineNum">   12176 </span><span class="lineCov">         10 :               location_t loc = declspecs-&gt;locations[ds_type_spec];</span>
<span class="lineNum">   12177 </span><span class="lineCov">         10 :               if (CLASS_PLACEHOLDER_TEMPLATE (auto_node))</span>
<span class="lineNum">   12178 </span><span class="lineNoCov">          0 :                 error_at (loc, &quot;invalid use of template-name %qE without an &quot;</span>
<span class="lineNum">   12179 </span>            :                           &quot;argument list&quot;,
<span class="lineNum">   12180 </span><span class="lineNoCov">          0 :                           CLASS_PLACEHOLDER_TEMPLATE (auto_node));</span>
<span class="lineNum">   12181 </span>            :               else
<span class="lineNum">   12182 </span><span class="lineCov">         10 :                 error_at (loc, &quot;non-static data member declared with &quot;</span>
<span class="lineNum">   12183 </span>            :                           &quot;placeholder %qT&quot;, auto_node);
<span class="lineNum">   12184 </span><span class="lineCov">         10 :               type = error_mark_node;</span>
<span class="lineNum">   12185 </span>            :             }
<span class="lineNum">   12186 </span>            : 
<span class="lineNum">   12187 </span>            :         /* The C99 flexible array extension.  */
<span class="lineNum">   12188 </span><span class="lineCov">    4866214 :         if (!staticp &amp;&amp; TREE_CODE (type) == ARRAY_TYPE</span>
<span class="lineNum">   12189 </span><span class="lineCov">    6698051 :             &amp;&amp; TYPE_DOMAIN (type) == NULL_TREE)</span>
<span class="lineNum">   12190 </span>            :           {
<span class="lineNum">   12191 </span><span class="lineCov">        826 :             if (ctype</span>
<span class="lineNum">   12192 </span><span class="lineCov">       1652 :                 &amp;&amp; (TREE_CODE (ctype) == UNION_TYPE</span>
<span class="lineNum">   12193 </span><span class="lineCov">        826 :                     || TREE_CODE (ctype) == QUAL_UNION_TYPE))</span>
<span class="lineNum">   12194 </span>            :               {
<span class="lineNum">   12195 </span><span class="lineCov">         18 :                 error (&quot;flexible array member in union&quot;);</span>
<span class="lineNum">   12196 </span><span class="lineCov">         18 :                 type = error_mark_node;</span>
<span class="lineNum">   12197 </span>            :               }
<span class="lineNum">   12198 </span>            :             else
<span class="lineNum">   12199 </span>            :               {
<span class="lineNum">   12200 </span>            :                 /* Array is a flexible member.  */
<span class="lineNum">   12201 </span><span class="lineCov">        808 :                 if (in_system_header_at (input_location))</span>
<span class="lineNum">   12202 </span>            :                   /* Do not warn on flexible array members in system
<span class="lineNum">   12203 </span>            :                      headers because glibc uses them.  */;
<span class="lineNum">   12204 </span><span class="lineCov">        802 :                 else if (name)</span>
<span class="lineNum">   12205 </span><span class="lineCov">        802 :                   pedwarn (input_location, OPT_Wpedantic,</span>
<span class="lineNum">   12206 </span>            :                            &quot;ISO C++ forbids flexible array member %qs&quot;, name);
<span class="lineNum">   12207 </span>            :                 else
<span class="lineNum">   12208 </span><span class="lineNoCov">          0 :                   pedwarn (input_location, OPT_Wpedantic,</span>
<span class="lineNum">   12209 </span>            :                            &quot;ISO C++ forbids flexible array members&quot;);
<span class="lineNum">   12210 </span>            : 
<span class="lineNum">   12211 </span>            :                 /* Flexible array member has a null domain.  */
<span class="lineNum">   12212 </span><span class="lineCov">        808 :                 type = build_cplus_array_type (TREE_TYPE (type), NULL_TREE);</span>
<span class="lineNum">   12213 </span>            :               }
<span class="lineNum">   12214 </span>            :           }
<span class="lineNum">   12215 </span>            : 
<span class="lineNum">   12216 </span><span class="lineCov">    6420623 :         if (type == error_mark_node)</span>
<span class="lineNum">   12217 </span>            :           {
<span class="lineNum">   12218 </span>            :             /* Happens when declaring arrays of sizes which
<span class="lineNum">   12219 </span>            :                are error_mark_node, for example.  */
<span class="lineNum">   12220 </span>            :             decl = NULL_TREE;
<span class="lineNum">   12221 </span>            :           }
<span class="lineNum">   12222 </span><span class="lineCov">    6420595 :         else if (in_namespace &amp;&amp; !friendp)</span>
<span class="lineNum">   12223 </span>            :           {
<span class="lineNum">   12224 </span>            :             /* Something like struct S { int N::j; };  */
<span class="lineNum">   12225 </span><span class="lineCov">          6 :             error (&quot;invalid use of %&lt;::%&gt;&quot;);</span>
<span class="lineNum">   12226 </span><span class="lineCov">          6 :             return error_mark_node;</span>
<span class="lineNum">   12227 </span>            :           }
<span class="lineNum">   12228 </span><span class="lineCov">   12841178 :         else if (TREE_CODE (type) == FUNCTION_TYPE</span>
<span class="lineNum">   12229 </span><span class="lineCov">    6420589 :                  || TREE_CODE (type) == METHOD_TYPE)</span>
<span class="lineNum">   12230 </span>            :           {
<span class="lineNum">   12231 </span><span class="lineCov">    4252142 :             int publicp = 0;</span>
<span class="lineNum">   12232 </span><span class="lineCov">    4252142 :             tree function_context;</span>
<span class="lineNum">   12233 </span>            : 
<span class="lineNum">   12234 </span><span class="lineCov">    4252142 :             if (friendp == 0)</span>
<span class="lineNum">   12235 </span>            :               {
<span class="lineNum">   12236 </span>            :                 /* This should never happen in pure C++ (the check
<span class="lineNum">   12237 </span>            :                    could be an assert).  It could happen in
<span class="lineNum">   12238 </span>            :                    Objective-C++ if someone writes invalid code that
<span class="lineNum">   12239 </span>            :                    uses a function declaration for an instance
<span class="lineNum">   12240 </span>            :                    variable or property (instance variables and
<span class="lineNum">   12241 </span>            :                    properties are parsed as FIELD_DECLs, but they are
<span class="lineNum">   12242 </span>            :                    part of an Objective-C class, not a C++ class).
<span class="lineNum">   12243 </span>            :                    That code is invalid and is caught by this
<span class="lineNum">   12244 </span>            :                    check.  */
<span class="lineNum">   12245 </span><span class="lineCov">    4185418 :                 if (!ctype)</span>
<span class="lineNum">   12246 </span>            :                   {
<span class="lineNum">   12247 </span><span class="lineNoCov">          0 :                     error (&quot;declaration of function %qD in invalid context&quot;,</span>
<span class="lineNum">   12248 </span>            :                            unqualified_id);
<span class="lineNum">   12249 </span><span class="lineNoCov">          0 :                     return error_mark_node;</span>
<span class="lineNum">   12250 </span>            :                   }
<span class="lineNum">   12251 </span>            : 
<span class="lineNum">   12252 </span>            :                 /* ``A union may [ ... ] not [ have ] virtual functions.''
<span class="lineNum">   12253 </span>            :                    ARM 9.5 */
<span class="lineNum">   12254 </span><span class="lineCov">    4185418 :                 if (virtualp &amp;&amp; TREE_CODE (ctype) == UNION_TYPE)</span>
<span class="lineNum">   12255 </span>            :                   {
<span class="lineNum">   12256 </span><span class="lineCov">          2 :                     error_at (declspecs-&gt;locations[ds_virtual],</span>
<span class="lineNum">   12257 </span>            :                               &quot;function %qD declared %&lt;virtual%&gt; inside a union&quot;,
<span class="lineNum">   12258 </span>            :                               unqualified_id);
<span class="lineNum">   12259 </span><span class="lineCov">          2 :                     return error_mark_node;</span>
<span class="lineNum">   12260 </span>            :                   }
<span class="lineNum">   12261 </span>            : 
<span class="lineNum">   12262 </span><span class="lineCov">    4185416 :                 if (virtualp</span>
<span class="lineNum">   12263 </span><span class="lineCov">     265703 :                     &amp;&amp; identifier_p (unqualified_id)</span>
<span class="lineNum">   12264 </span><span class="lineCov">    5513931 :                     &amp;&amp; IDENTIFIER_NEWDEL_OP_P (unqualified_id))</span>
<span class="lineNum">   12265 </span>            :                   {
<span class="lineNum">   12266 </span><span class="lineCov">          8 :                     error_at (declspecs-&gt;locations[ds_virtual],</span>
<span class="lineNum">   12267 </span>            :                               &quot;%qD cannot be declared %&lt;virtual%&gt;, since it &quot;
<span class="lineNum">   12268 </span>            :                               &quot;is always static&quot;, unqualified_id);
<span class="lineNum">   12269 </span><span class="lineCov">          8 :                     virtualp = 0;</span>
<span class="lineNum">   12270 </span>            :                   }
<span class="lineNum">   12271 </span>            :               }
<span class="lineNum">   12272 </span>            : 
<span class="lineNum">   12273 </span>            :             /* Check that the name used for a destructor makes sense.  */
<span class="lineNum">   12274 </span><span class="lineCov">    4252140 :             if (sfk == sfk_destructor)</span>
<span class="lineNum">   12275 </span>            :               {
<span class="lineNum">   12276 </span><span class="lineCov">     160697 :                 tree uqname = id_declarator-&gt;u.id.unqualified_name;</span>
<span class="lineNum">   12277 </span>            : 
<span class="lineNum">   12278 </span><span class="lineCov">     160697 :                 if (!ctype)</span>
<span class="lineNum">   12279 </span>            :                   {
<span class="lineNum">   12280 </span><span class="lineCov">         12 :                     gcc_assert (friendp);</span>
<span class="lineNum">   12281 </span><span class="lineCov">         12 :                     error (&quot;expected qualified name in friend declaration &quot;</span>
<span class="lineNum">   12282 </span>            :                            &quot;for destructor %qD&quot;, uqname);
<span class="lineNum">   12283 </span><span class="lineCov">         12 :                     return error_mark_node;</span>
<span class="lineNum">   12284 </span>            :                   }
<span class="lineNum">   12285 </span>            : 
<span class="lineNum">   12286 </span><span class="lineCov">     160685 :                 if (!check_dtor_name (ctype, TREE_OPERAND (uqname, 0)))</span>
<span class="lineNum">   12287 </span>            :                   {
<span class="lineNum">   12288 </span><span class="lineCov">          9 :                     error (&quot;declaration of %qD as member of %qT&quot;,</span>
<span class="lineNum">   12289 </span>            :                            uqname, ctype);
<span class="lineNum">   12290 </span><span class="lineCov">          9 :                     return error_mark_node;</span>
<span class="lineNum">   12291 </span>            :                   }
<span class="lineNum">   12292 </span><span class="lineCov">     160676 :                 if (concept_p)</span>
<span class="lineNum">   12293 </span>            :                   {
<span class="lineNum">   12294 </span><span class="lineCov">          2 :                     error_at (declspecs-&gt;locations[ds_concept],</span>
<span class="lineNum">   12295 </span>            :                               &quot;a destructor cannot be %&lt;concept%&gt;&quot;);
<span class="lineNum">   12296 </span><span class="lineCov">          2 :                     return error_mark_node;</span>
<span class="lineNum">   12297 </span>            :                   }
<span class="lineNum">   12298 </span><span class="lineCov">     160674 :                 if (constexpr_p)</span>
<span class="lineNum">   12299 </span>            :                   {
<span class="lineNum">   12300 </span><span class="lineCov">          2 :                     error_at (declspecs-&gt;locations[ds_constexpr],</span>
<span class="lineNum">   12301 </span>            :                               &quot;a destructor cannot be %&lt;constexpr%&gt;&quot;);
<span class="lineNum">   12302 </span><span class="lineCov">          2 :                     return error_mark_node;</span>
<span class="lineNum">   12303 </span>            :                   }
<span class="lineNum">   12304 </span>            :               }
<span class="lineNum">   12305 </span><span class="lineCov">    4091443 :             else if (sfk == sfk_constructor &amp;&amp; friendp &amp;&amp; !ctype)</span>
<span class="lineNum">   12306 </span>            :               {
<span class="lineNum">   12307 </span><span class="lineNoCov">          0 :                 error (&quot;expected qualified name in friend declaration &quot;</span>
<span class="lineNum">   12308 </span>            :                        &quot;for constructor %qD&quot;,
<span class="lineNum">   12309 </span><span class="lineNoCov">          0 :                        id_declarator-&gt;u.id.unqualified_name);</span>
<span class="lineNum">   12310 </span><span class="lineNoCov">          0 :                 return error_mark_node;</span>
<span class="lineNum">   12311 </span>            :               }
<span class="lineNum">   12312 </span><span class="lineCov">    4252115 :             if (sfk == sfk_constructor)</span>
<span class="lineNum">   12313 </span><span class="lineCov">     915061 :               if (concept_p)</span>
<span class="lineNum">   12314 </span>            :                 {
<span class="lineNum">   12315 </span><span class="lineCov">          2 :                   error_at (declspecs-&gt;locations[ds_concept],</span>
<span class="lineNum">   12316 </span>            :                             &quot;a constructor cannot be %&lt;concept%&gt;&quot;);
<span class="lineNum">   12317 </span><span class="lineCov">          2 :                   return error_mark_node;</span>
<span class="lineNum">   12318 </span>            :                 }
<span class="lineNum">   12319 </span><span class="lineCov">    4252113 :             if (concept_p)</span>
<span class="lineNum">   12320 </span>            :               {
<span class="lineNum">   12321 </span><span class="lineCov">          6 :                 error_at (declspecs-&gt;locations[ds_concept],</span>
<span class="lineNum">   12322 </span>            :                           &quot;a concept cannot be a member function&quot;);
<span class="lineNum">   12323 </span><span class="lineCov">          6 :                 concept_p = false;</span>
<span class="lineNum">   12324 </span>            :               }
<span class="lineNum">   12325 </span>            : 
<span class="lineNum">   12326 </span><span class="lineCov">    4252113 :             if (TREE_CODE (unqualified_id) == TEMPLATE_ID_EXPR)</span>
<span class="lineNum">   12327 </span>            :               {
<span class="lineNum">   12328 </span><span class="lineCov">       1070 :                 tree tmpl = TREE_OPERAND (unqualified_id, 0);</span>
<span class="lineNum">   12329 </span><span class="lineCov">       1070 :                 if (variable_template_p (tmpl))</span>
<span class="lineNum">   12330 </span>            :                   {
<span class="lineNum">   12331 </span><span class="lineCov">          3 :                     error (&quot;specialization of variable template %qD &quot;</span>
<span class="lineNum">   12332 </span>            :                            &quot;declared as function&quot;, tmpl);
<span class="lineNum">   12333 </span><span class="lineCov">          3 :                     inform (DECL_SOURCE_LOCATION (tmpl),</span>
<span class="lineNum">   12334 </span>            :                             &quot;variable template declared here&quot;);
<span class="lineNum">   12335 </span><span class="lineCov">          3 :                     return error_mark_node;</span>
<span class="lineNum">   12336 </span>            :                   }
<span class="lineNum">   12337 </span>            :               }
<span class="lineNum">   12338 </span>            : 
<span class="lineNum">   12339 </span>            :             /* Tell grokfndecl if it needs to set TREE_PUBLIC on the node.  */
<span class="lineNum">   12340 </span><span class="lineCov">    4252110 :             function_context = (ctype != NULL_TREE) ?</span>
<span class="lineNum">   12341 </span><span class="lineCov">    4185578 :               decl_function_context (TYPE_MAIN_DECL (ctype)) : NULL_TREE;</span>
<span class="lineNum">   12342 </span><span class="lineCov">      66709 :             publicp = (! friendp || ! staticp)</span>
<span class="lineNum">   12343 </span><span class="lineCov">    4318819 :               &amp;&amp; function_context == NULL_TREE;</span>
<span class="lineNum">   12344 </span>            : 
<span class="lineNum">   12345 </span><span class="lineCov">    4252110 :             decl = grokfndecl (ctype, type,</span>
<span class="lineNum">   12346 </span><span class="lineCov">    4252110 :                                TREE_CODE (unqualified_id) != TEMPLATE_ID_EXPR</span>
<span class="lineNum">   12347 </span>            :                                ? unqualified_id : dname,
<span class="lineNum">   12348 </span>            :                                parms,
<span class="lineNum">   12349 </span>            :                                unqualified_id,
<span class="lineNum">   12350 </span>            :                                declspecs,
<span class="lineNum">   12351 </span>            :                                reqs,
<span class="lineNum">   12352 </span>            :                                virtualp, flags, memfn_quals, rqual, raises,
<span class="lineNum">   12353 </span>            :                                friendp ? -1 : 0, friendp, publicp,
<span class="lineNum">   12354 </span><span class="lineCov">    4252110 :                                inlinep | (2 * constexpr_p) | (4 * concept_p),</span>
<span class="lineNum">   12355 </span>            :                                initialized == SD_DELETED, sfk,
<span class="lineNum">   12356 </span>            :                                funcdef_flag, late_return_type_p,
<span class="lineNum">   12357 </span>            :                                template_count, in_namespace,
<span class="lineNum">   12358 </span><span class="lineCov">    4252110 :                                attrlist, declarator-&gt;id_loc);</span>
<span class="lineNum">   12359 </span><span class="lineCov">    4252110 :             decl = set_virt_specifiers (decl, virt_specifiers);</span>
<span class="lineNum">   12360 </span><span class="lineCov">    4252110 :             if (decl == NULL_TREE)</span>
<span class="lineNum">   12361 </span><span class="lineCov">         80 :               return error_mark_node;</span>
<span class="lineNum">   12362 </span>            : #if 0
<span class="lineNum">   12363 </span>            :             /* This clobbers the attrs stored in `decl' from `attrlist'.  */
<span class="lineNum">   12364 </span>            :             /* The decl and setting of decl_attr is also turned off.  */
<span class="lineNum">   12365 </span>            :             decl = build_decl_attribute_variant (decl, decl_attr);
<span class="lineNum">   12366 </span>            : #endif
<span class="lineNum">   12367 </span>            : 
<span class="lineNum">   12368 </span>            :             /* [class.conv.ctor]
<span class="lineNum">   12369 </span>            : 
<span class="lineNum">   12370 </span>            :                A constructor declared without the function-specifier
<span class="lineNum">   12371 </span>            :                explicit that can be called with a single parameter
<span class="lineNum">   12372 </span>            :                specifies a conversion from the type of its first
<span class="lineNum">   12373 </span>            :                parameter to the type of its class.  Such a constructor
<span class="lineNum">   12374 </span>            :                is called a converting constructor.  */
<span class="lineNum">   12375 </span><span class="lineCov">    4252030 :             if (explicitp == 2)</span>
<span class="lineNum">   12376 </span><span class="lineCov">     258194 :               DECL_NONCONVERTING_P (decl) = 1;</span>
<span class="lineNum">   12377 </span>            :           }
<span class="lineNum">   12378 </span><span class="lineCov">    1406139 :         else if (!staticp &amp;&amp; !dependent_type_p (type)</span>
<span class="lineNum">   12379 </span><span class="lineCov">    1143937 :                  &amp;&amp; !COMPLETE_TYPE_P (complete_type (type))</span>
<span class="lineNum">   12380 </span><span class="lineCov">    2169345 :                  &amp;&amp; (!complete_or_array_type_p (type)</span>
<span class="lineNum">   12381 </span><span class="lineCov">        788 :                      || initialized == 0))</span>
<span class="lineNum">   12382 </span>            :           {
<span class="lineNum">   12383 </span><span class="lineCov">        881 :             if (TREE_CODE (type) != ARRAY_TYPE</span>
<span class="lineNum">   12384 </span><span class="lineCov">        881 :                 || !COMPLETE_TYPE_P (TREE_TYPE (type)))</span>
<span class="lineNum">   12385 </span>            :               {
<span class="lineNum">   12386 </span><span class="lineCov">        110 :                 if (unqualified_id)</span>
<span class="lineNum">   12387 </span>            :                   {
<span class="lineNum">   12388 </span><span class="lineCov">         74 :                     error (&quot;field %qD has incomplete type %qT&quot;,</span>
<span class="lineNum">   12389 </span>            :                            unqualified_id, type);
<span class="lineNum">   12390 </span><span class="lineCov">         74 :                     cxx_incomplete_type_inform (strip_array_types (type));</span>
<span class="lineNum">   12391 </span>            :                   }
<span class="lineNum">   12392 </span>            :                 else
<span class="lineNum">   12393 </span><span class="lineCov">         36 :                   error (&quot;name %qT has incomplete type&quot;, type);</span>
<span class="lineNum">   12394 </span>            : 
<span class="lineNum">   12395 </span><span class="lineCov">        110 :                 type = error_mark_node;</span>
<span class="lineNum">   12396 </span><span class="lineCov">        110 :                 decl = NULL_TREE;</span>
<span class="lineNum">   12397 </span>            :               }
<span class="lineNum">   12398 </span>            :           }
<span class="lineNum">   12399 </span>            :         else
<span class="lineNum">   12400 </span>            :           {
<span class="lineNum">   12401 </span><span class="lineCov">    2167560 :             if (friendp)</span>
<span class="lineNum">   12402 </span>            :               {
<span class="lineNum">   12403 </span><span class="lineCov">         11 :                 error (&quot;%qE is neither function nor member function; &quot;</span>
<span class="lineNum">   12404 </span>            :                        &quot;cannot be declared friend&quot;, unqualified_id);
<span class="lineNum">   12405 </span><span class="lineCov">         11 :                 return error_mark_node;</span>
<span class="lineNum">   12406 </span>            :               }
<span class="lineNum">   12407 </span>            :             decl = NULL_TREE;
<span class="lineNum">   12408 </span>            :           }
<span class="lineNum">   12409 </span>            : 
<span class="lineNum">   12410 </span><span class="lineCov">    6420488 :         if (friendp)</span>
<span class="lineNum">   12411 </span>            :           {
<span class="lineNum">   12412 </span>            :             /* Friends are treated specially.  */
<span class="lineNum">   12413 </span><span class="lineCov">      66697 :             if (ctype == current_class_type)</span>
<span class="lineNum">   12414 </span>            :               ;  /* We already issued a permerror.  */
<span class="lineNum">   12415 </span><span class="lineCov">      66697 :             else if (decl &amp;&amp; DECL_NAME (decl))</span>
<span class="lineNum">   12416 </span>            :               {
<span class="lineNum">   12417 </span><span class="lineCov">      66694 :                 if (template_class_depth (current_class_type) == 0)</span>
<span class="lineNum">   12418 </span>            :                   {
<span class="lineNum">   12419 </span><span class="lineCov">      32776 :                     decl = check_explicit_specialization</span>
<span class="lineNum">   12420 </span><span class="lineCov">      16388 :                       (unqualified_id, decl, template_count,</span>
<span class="lineNum">   12421 </span><span class="lineCov">      16388 :                        2 * funcdef_flag + 4);</span>
<span class="lineNum">   12422 </span><span class="lineCov">      16388 :                     if (decl == error_mark_node)</span>
<span class="lineNum">   12423 </span>            :                       return error_mark_node;
<span class="lineNum">   12424 </span>            :                   }
<span class="lineNum">   12425 </span>            : 
<span class="lineNum">   12426 </span><span class="lineCov">      66694 :                 decl = do_friend (ctype, unqualified_id, decl,</span>
<span class="lineNum">   12427 </span>            :                                   *attrlist, flags,
<span class="lineNum">   12428 </span>            :                                   funcdef_flag);
<span class="lineNum">   12429 </span><span class="lineCov">      66694 :                 return decl;</span>
<span class="lineNum">   12430 </span>            :               }
<span class="lineNum">   12431 </span>            :             else
<span class="lineNum">   12432 </span><span class="lineCov">          3 :               return error_mark_node;</span>
<span class="lineNum">   12433 </span>            :           }
<span class="lineNum">   12434 </span>            : 
<span class="lineNum">   12435 </span>            :         /* Structure field.  It may not be a function, except for C++.  */
<span class="lineNum">   12436 </span>            : 
<span class="lineNum">   12437 </span><span class="lineCov">    6353791 :         if (decl == NULL_TREE)</span>
<span class="lineNum">   12438 </span>            :           {
<span class="lineNum">   12439 </span><span class="lineCov">    2168455 :             if (staticp)</span>
<span class="lineNum">   12440 </span>            :               {
<span class="lineNum">   12441 </span>            :                 /* C++ allows static class members.  All other work
<span class="lineNum">   12442 </span>            :                    for this is done by grokfield.  */
<span class="lineNum">   12443 </span><span class="lineCov">     762308 :                 decl = build_lang_decl_loc (declarator</span>
<span class="lineNum">   12444 </span>            :                                             ? declarator-&gt;id_loc
<span class="lineNum">   12445 </span>            :                                             : input_location,
<span class="lineNum">   12446 </span>            :                                             VAR_DECL, unqualified_id, type);
<span class="lineNum">   12447 </span><span class="lineCov">     762308 :                 set_linkage_for_static_data_member (decl);</span>
<span class="lineNum">   12448 </span><span class="lineCov">     762308 :                 if (concept_p)</span>
<span class="lineNum">   12449 </span><span class="lineCov">          2 :                   error_at (declspecs-&gt;locations[ds_concept],</span>
<span class="lineNum">   12450 </span>            :                             &quot;static data member %qE declared %&lt;concept%&gt;&quot;,
<span class="lineNum">   12451 </span>            :                             unqualified_id);
<span class="lineNum">   12452 </span><span class="lineCov">     762306 :                 else if (constexpr_p &amp;&amp; !initialized)</span>
<span class="lineNum">   12453 </span>            :                   {
<span class="lineNum">   12454 </span><span class="lineCov">          2 :                     error (&quot;%&lt;constexpr%&gt; static data member %qD must have an &quot;</span>
<span class="lineNum">   12455 </span>            :                            &quot;initializer&quot;, decl);
<span class="lineNum">   12456 </span><span class="lineCov">          2 :                     constexpr_p = false;</span>
<span class="lineNum">   12457 </span>            :                   }
<span class="lineNum">   12458 </span>            : 
<span class="lineNum">   12459 </span><span class="lineCov">     762308 :                 if (inlinep)</span>
<span class="lineNum">   12460 </span><span class="lineCov">        102 :                   mark_inline_variable (decl, declspecs-&gt;locations[ds_inline]);</span>
<span class="lineNum">   12461 </span>            : 
<span class="lineNum">   12462 </span><span class="lineCov">    2286924 :                 if (!DECL_VAR_DECLARED_INLINE_P (decl)</span>
<span class="lineNum">   12463 </span><span class="lineCov">    1524514 :                     &amp;&amp; !(cxx_dialect &gt;= cxx17 &amp;&amp; constexpr_p))</span>
<span class="lineNum">   12464 </span>            :                   /* Even if there is an in-class initialization, DECL
<span class="lineNum">   12465 </span>            :                      is considered undefined until an out-of-class
<span class="lineNum">   12466 </span>            :                      definition is provided, unless this is an inline
<span class="lineNum">   12467 </span>            :                      variable.  */
<span class="lineNum">   12468 </span><span class="lineCov">    1018358 :                   DECL_EXTERNAL (decl) = 1;</span>
<span class="lineNum">   12469 </span>            : 
<span class="lineNum">   12470 </span><span class="lineCov">     762308 :                 if (thread_p)</span>
<span class="lineNum">   12471 </span>            :                   {
<span class="lineNum">   12472 </span><span class="lineCov">         35 :                     CP_DECL_THREAD_LOCAL_P (decl) = true;</span>
<span class="lineNum">   12473 </span><span class="lineCov">         35 :                     if (!processing_template_decl)</span>
<span class="lineNum">   12474 </span><span class="lineCov">         15 :                       set_decl_tls_model (decl, decl_default_tls_model (decl));</span>
<span class="lineNum">   12475 </span><span class="lineCov">         35 :                     if (declspecs-&gt;gnu_thread_keyword_p)</span>
<span class="lineNum">   12476 </span><span class="lineCov">         31 :                       SET_DECL_GNU_TLS_P (decl);</span>
<span class="lineNum">   12477 </span>            :                   }
<span class="lineNum">   12478 </span>            :               }
<span class="lineNum">   12479 </span>            :             else
<span class="lineNum">   12480 </span>            :               {
<span class="lineNum">   12481 </span><span class="lineCov">    1406147 :                 if (concept_p)</span>
<span class="lineNum">   12482 </span><span class="lineCov">          2 :                   error_at (declspecs-&gt;locations[ds_concept],</span>
<span class="lineNum">   12483 </span>            :                             &quot;non-static data member %qE declared %&lt;concept%&gt;&quot;,
<span class="lineNum">   12484 </span>            :                             unqualified_id);
<span class="lineNum">   12485 </span><span class="lineCov">    1406145 :                 else if (constexpr_p)</span>
<span class="lineNum">   12486 </span>            :                   {
<span class="lineNum">   12487 </span><span class="lineCov">          4 :                     error_at (declspecs-&gt;locations[ds_constexpr],</span>
<span class="lineNum">   12488 </span>            :                               &quot;non-static data member %qE declared %&lt;constexpr%&gt;&quot;,
<span class="lineNum">   12489 </span>            :                               unqualified_id);
<span class="lineNum">   12490 </span><span class="lineCov">          4 :                     constexpr_p = false;</span>
<span class="lineNum">   12491 </span>            :                   }
<span class="lineNum">   12492 </span><span class="lineCov">    1406147 :                 decl = build_decl (input_location,</span>
<span class="lineNum">   12493 </span>            :                                    FIELD_DECL, unqualified_id, type);
<span class="lineNum">   12494 </span><span class="lineCov">    1406147 :                 DECL_NONADDRESSABLE_P (decl) = bitfield;</span>
<span class="lineNum">   12495 </span><span class="lineCov">    1406147 :                 if (bitfield &amp;&amp; !unqualified_id)</span>
<span class="lineNum">   12496 </span>            :                   {
<span class="lineNum">   12497 </span><span class="lineCov">      23664 :                     TREE_NO_WARNING (decl) = 1;</span>
<span class="lineNum">   12498 </span><span class="lineCov">      47328 :                     DECL_PADDING_P (decl) = 1;</span>
<span class="lineNum">   12499 </span>            :                   }
<span class="lineNum">   12500 </span>            : 
<span class="lineNum">   12501 </span><span class="lineCov">    1406147 :                 if (storage_class == sc_mutable)</span>
<span class="lineNum">   12502 </span>            :                   {
<span class="lineNum">   12503 </span><span class="lineCov">      10523 :                     DECL_MUTABLE_P (decl) = 1;</span>
<span class="lineNum">   12504 </span><span class="lineCov">      10523 :                     storage_class = sc_none;</span>
<span class="lineNum">   12505 </span>            :                   }
<span class="lineNum">   12506 </span>            : 
<span class="lineNum">   12507 </span><span class="lineCov">    1406147 :                 if (initialized)</span>
<span class="lineNum">   12508 </span>            :                   {
<span class="lineNum">   12509 </span>            :                     /* An attempt is being made to initialize a non-static
<span class="lineNum">   12510 </span>            :                        member.  This is new in C++11.  */
<span class="lineNum">   12511 </span><span class="lineCov">       8294 :                     maybe_warn_cpp0x (CPP0X_NSDMI);</span>
<span class="lineNum">   12512 </span>            : 
<span class="lineNum">   12513 </span>            :                     /* If this has been parsed with static storage class, but
<span class="lineNum">   12514 </span>            :                        errors forced staticp to be cleared, ensure NSDMI is
<span class="lineNum">   12515 </span>            :                        not present.  */
<span class="lineNum">   12516 </span><span class="lineCov">       8294 :                     if (declspecs-&gt;storage_class == sc_static)</span>
<span class="lineNum">   12517 </span><span class="lineCov">          2 :                       DECL_INITIAL (decl) = error_mark_node;</span>
<span class="lineNum">   12518 </span>            :                   }
<span class="lineNum">   12519 </span>            :               }
<span class="lineNum">   12520 </span>            : 
<span class="lineNum">   12521 </span><span class="lineCov">    3574602 :             bad_specifiers (decl, BSP_FIELD, virtualp,</span>
<span class="lineNum">   12522 </span>            :                             memfn_quals != TYPE_UNQUALIFIED,
<span class="lineNum">   12523 </span>            :                             staticp ? false : inlinep, friendp,
<span class="lineNum">   12524 </span>            :                             raises != NULL_TREE,
<span class="lineNum">   12525 </span>            :                             declspecs-&gt;locations);
<span class="lineNum">   12526 </span>            :           }
<span class="lineNum">   12527 </span>            :       }
<span class="lineNum">   12528 </span><span class="lineCov">   17023342 :     else if (TREE_CODE (type) == FUNCTION_TYPE</span>
<span class="lineNum">   12529 </span><span class="lineCov">    8511671 :              || TREE_CODE (type) == METHOD_TYPE)</span>
<span class="lineNum">   12530 </span>            :       {
<span class="lineNum">   12531 </span><span class="lineCov">    5920200 :         tree original_name;</span>
<span class="lineNum">   12532 </span><span class="lineCov">    5920200 :         int publicp = 0;</span>
<span class="lineNum">   12533 </span>            : 
<span class="lineNum">   12534 </span><span class="lineCov">    5920200 :         if (!unqualified_id)</span>
<span class="lineNum">   12535 </span><span class="lineNoCov">          0 :           return error_mark_node;</span>
<span class="lineNum">   12536 </span>            : 
<span class="lineNum">   12537 </span><span class="lineCov">    5920200 :         if (TREE_CODE (unqualified_id) == TEMPLATE_ID_EXPR)</span>
<span class="lineNum">   12538 </span>            :           original_name = dname;
<span class="lineNum">   12539 </span>            :         else
<span class="lineNum">   12540 </span><span class="lineCov">    5888542 :           original_name = unqualified_id;</span>
<span class="lineNum">   12541 </span>            :         // FIXME:gcc_assert (original_name == dname);
<span class="lineNum">   12542 </span>            : 
<span class="lineNum">   12543 </span><span class="lineCov">    5920200 :         if (storage_class == sc_auto)</span>
<span class="lineNum">   12544 </span><span class="lineNoCov">          0 :           error (&quot;storage class %&lt;auto%&gt; invalid for function %qs&quot;, name);</span>
<span class="lineNum">   12545 </span><span class="lineCov">    5920200 :         else if (storage_class == sc_register)</span>
<span class="lineNum">   12546 </span><span class="lineCov">          9 :           error (&quot;storage class %&lt;register%&gt; invalid for function %qs&quot;, name);</span>
<span class="lineNum">   12547 </span><span class="lineCov">    5920191 :         else if (thread_p)</span>
<span class="lineNum">   12548 </span>            :           {
<span class="lineNum">   12549 </span><span class="lineCov">         12 :             if (declspecs-&gt;gnu_thread_keyword_p)</span>
<span class="lineNum">   12550 </span><span class="lineCov">         12 :               error_at (declspecs-&gt;locations[ds_thread],</span>
<span class="lineNum">   12551 </span>            :                         &quot;storage class %&lt;__thread%&gt; invalid for function %qs&quot;,
<span class="lineNum">   12552 </span>            :                         name);
<span class="lineNum">   12553 </span>            :             else
<span class="lineNum">   12554 </span><span class="lineNoCov">          0 :               error_at (declspecs-&gt;locations[ds_thread],</span>
<span class="lineNum">   12555 </span>            :                         &quot;storage class %&lt;thread_local%&gt; invalid for &quot;
<span class="lineNum">   12556 </span>            :                         &quot;function %qs&quot;, name);
<span class="lineNum">   12557 </span>            :           }
<span class="lineNum">   12558 </span>            : 
<span class="lineNum">   12559 </span><span class="lineCov">    5920200 :         if (virt_specifiers)</span>
<span class="lineNum">   12560 </span><span class="lineCov">          4 :           error (&quot;virt-specifiers in %qs not allowed outside a class &quot;</span>
<span class="lineNum">   12561 </span>            :                  &quot;definition&quot;, name);
<span class="lineNum">   12562 </span>            :         /* Function declaration not at top level.
<span class="lineNum">   12563 </span>            :            Storage classes other than `extern' are not allowed
<span class="lineNum">   12564 </span>            :            and `extern' makes no difference.  */
<span class="lineNum">   12565 </span><span class="lineCov">    5920200 :         if (! toplevel_bindings_p ()</span>
<span class="lineNum">   12566 </span><span class="lineCov">        330 :             &amp;&amp; (storage_class == sc_static</span>
<span class="lineNum">   12567 </span><span class="lineCov">        322 :                 || decl_spec_seq_has_spec_p (declspecs, ds_inline))</span>
<span class="lineNum">   12568 </span><span class="lineCov">    5920210 :             &amp;&amp; pedantic)</span>
<span class="lineNum">   12569 </span>            :           {
<span class="lineNum">   12570 </span><span class="lineCov">          7 :             if (storage_class == sc_static)</span>
<span class="lineNum">   12571 </span><span class="lineCov">          5 :               pedwarn (declspecs-&gt;locations[ds_storage_class], OPT_Wpedantic, </span>
<span class="lineNum">   12572 </span>            :                        &quot;%&lt;static%&gt; specifier invalid for function %qs &quot;
<span class="lineNum">   12573 </span>            :                        &quot;declared out of global scope&quot;, name);
<span class="lineNum">   12574 </span>            :             else
<span class="lineNum">   12575 </span><span class="lineCov">          2 :               pedwarn (declspecs-&gt;locations[ds_inline], OPT_Wpedantic, </span>
<span class="lineNum">   12576 </span>            :                        &quot;%&lt;inline%&gt; specifier invalid for function %qs &quot;
<span class="lineNum">   12577 </span>            :                        &quot;declared out of global scope&quot;, name);
<span class="lineNum">   12578 </span>            :           }
<span class="lineNum">   12579 </span>            : 
<span class="lineNum">   12580 </span><span class="lineCov">    5920200 :         if (ctype == NULL_TREE)</span>
<span class="lineNum">   12581 </span>            :           {
<span class="lineNum">   12582 </span><span class="lineCov">    5510244 :             if (virtualp)</span>
<span class="lineNum">   12583 </span>            :               {
<span class="lineNum">   12584 </span><span class="lineNoCov">          0 :                 error (&quot;virtual non-class function %qs&quot;, name);</span>
<span class="lineNum">   12585 </span><span class="lineNoCov">          0 :                 virtualp = 0;</span>
<span class="lineNum">   12586 </span>            :               }
<span class="lineNum">   12587 </span><span class="lineCov">   11020488 :             else if (sfk == sfk_constructor</span>
<span class="lineNum">   12588 </span><span class="lineCov">    5510244 :                      || sfk == sfk_destructor)</span>
<span class="lineNum">   12589 </span>            :               {
<span class="lineNum">   12590 </span><span class="lineCov">          3 :                 error (funcdef_flag</span>
<span class="lineNum">   12591 </span>            :                        ? G_(&quot;%qs defined in a non-class scope&quot;)
<span class="lineNum">   12592 </span>            :                        : G_(&quot;%qs declared in a non-class scope&quot;), name);
<span class="lineNum">   12593 </span><span class="lineCov">          3 :                 sfk = sfk_none;</span>
<span class="lineNum">   12594 </span>            :               }
<span class="lineNum">   12595 </span>            :           }
<span class="lineNum">   12596 </span>            : 
<span class="lineNum">   12597 </span>            :         /* Record whether the function is public.  */
<span class="lineNum">   12598 </span><span class="lineCov">   11840400 :         publicp = (ctype != NULL_TREE</span>
<span class="lineNum">   12599 </span><span class="lineCov">    5920200 :                    || storage_class != sc_static);</span>
<span class="lineNum">   12600 </span>            : 
<span class="lineNum">   12601 </span><span class="lineCov">   23680800 :         decl = grokfndecl (ctype, type, original_name, parms, unqualified_id,</span>
<span class="lineNum">   12602 </span>            :                            declspecs,
<span class="lineNum">   12603 </span>            :                            reqs, virtualp, flags, memfn_quals, rqual, raises,
<span class="lineNum">   12604 </span>            :                            1, friendp,
<span class="lineNum">   12605 </span>            :                            publicp,
<span class="lineNum">   12606 </span><span class="lineCov">    5920200 :                            inlinep | (2 * constexpr_p) | (4 * concept_p),</span>
<span class="lineNum">   12607 </span>            :                            initialized == SD_DELETED,
<span class="lineNum">   12608 </span>            :                            sfk,
<span class="lineNum">   12609 </span>            :                            funcdef_flag,
<span class="lineNum">   12610 </span>            :                            late_return_type_p,
<span class="lineNum">   12611 </span>            :                            template_count, in_namespace, attrlist,
<span class="lineNum">   12612 </span><span class="lineCov">    5920200 :                            declarator-&gt;id_loc);</span>
<span class="lineNum">   12613 </span><span class="lineCov">    5920200 :         if (decl == NULL_TREE)</span>
<span class="lineNum">   12614 </span><span class="lineCov">        401 :           return error_mark_node;</span>
<span class="lineNum">   12615 </span>            : 
<span class="lineNum">   12616 </span><span class="lineCov">    5919799 :         if (explicitp == 2)</span>
<span class="lineNum">   12617 </span><span class="lineCov">          1 :           DECL_NONCONVERTING_P (decl) = 1;</span>
<span class="lineNum">   12618 </span><span class="lineCov">    5919799 :         if (staticp == 1)</span>
<span class="lineNum">   12619 </span>            :           {
<span class="lineNum">   12620 </span><span class="lineCov">     133512 :             int invalid_static = 0;</span>
<span class="lineNum">   12621 </span>            : 
<span class="lineNum">   12622 </span>            :             /* Don't allow a static member function in a class, and forbid
<span class="lineNum">   12623 </span>            :                declaring main to be static.  */
<span class="lineNum">   12624 </span><span class="lineCov">     133512 :             if (TREE_CODE (type) == METHOD_TYPE)</span>
<span class="lineNum">   12625 </span>            :               {
<span class="lineNum">   12626 </span><span class="lineNoCov">          0 :                 permerror (input_location, &quot;cannot declare member function %qD to have &quot;</span>
<span class="lineNum">   12627 </span>            :                            &quot;static linkage&quot;, decl);
<span class="lineNum">   12628 </span><span class="lineNoCov">          0 :                 invalid_static = 1;</span>
<span class="lineNum">   12629 </span>            :               }
<span class="lineNum">   12630 </span><span class="lineCov">     133512 :             else if (current_function_decl)</span>
<span class="lineNum">   12631 </span>            :               {
<span class="lineNum">   12632 </span>            :                 /* 7.1.1: There can be no static function declarations within a
<span class="lineNum">   12633 </span>            :                    block.  */
<span class="lineNum">   12634 </span><span class="lineCov">          8 :                 error_at (declspecs-&gt;locations[ds_storage_class],</span>
<span class="lineNum">   12635 </span>            :                           &quot;cannot declare static function inside another function&quot;);
<span class="lineNum">   12636 </span><span class="lineCov">          8 :                 invalid_static = 1;</span>
<span class="lineNum">   12637 </span>            :               }
<span class="lineNum">   12638 </span>            : 
<span class="lineNum">   12639 </span><span class="lineCov">          8 :             if (invalid_static)</span>
<span class="lineNum">   12640 </span>            :               {
<span class="lineNum">   12641 </span>            :                 staticp = 0;
<span class="lineNum">   12642 </span>            :                 storage_class = sc_none;
<span class="lineNum">   12643 </span>            :               }
<span class="lineNum">   12644 </span>            :           }
<span class="lineNum">   12645 </span>            :       }
<span class="lineNum">   12646 </span>            :     else
<span class="lineNum">   12647 </span>            :       {
<span class="lineNum">   12648 </span>            :         /* It's a variable.  */
<span class="lineNum">   12649 </span>            : 
<span class="lineNum">   12650 </span>            :         /* An uninitialized decl with `extern' is a reference.  */
<span class="lineNum">   12651 </span><span class="lineCov">    5126247 :         decl = grokvardecl (type, dname, unqualified_id,</span>
<span class="lineNum">   12652 </span>            :                             declspecs,
<span class="lineNum">   12653 </span>            :                             initialized,
<span class="lineNum">   12654 </span>            :                             type_quals,
<span class="lineNum">   12655 </span>            :                             inlinep,
<span class="lineNum">   12656 </span>            :                             concept_p,
<span class="lineNum">   12657 </span>            :                             template_count,
<span class="lineNum">   12658 </span>            :                             ctype ? ctype : in_namespace);
<span class="lineNum">   12659 </span><span class="lineCov">    2591471 :         if (decl == NULL_TREE)</span>
<span class="lineNum">   12660 </span><span class="lineCov">         11 :           return error_mark_node;</span>
<span class="lineNum">   12661 </span>            : 
<span class="lineNum">   12662 </span><span class="lineCov">    2591460 :         bad_specifiers (decl, BSP_VAR, virtualp,</span>
<span class="lineNum">   12663 </span>            :                         memfn_quals != TYPE_UNQUALIFIED,
<span class="lineNum">   12664 </span>            :                         inlinep, friendp, raises != NULL_TREE,
<span class="lineNum">   12665 </span>            :                         declspecs-&gt;locations);
<span class="lineNum">   12666 </span>            : 
<span class="lineNum">   12667 </span><span class="lineCov">    2591460 :         if (ctype)</span>
<span class="lineNum">   12668 </span>            :           {
<span class="lineNum">   12669 </span><span class="lineCov">      56695 :             DECL_CONTEXT (decl) = ctype;</span>
<span class="lineNum">   12670 </span><span class="lineCov">      56695 :             if (staticp == 1)</span>
<span class="lineNum">   12671 </span>            :               {
<span class="lineNum">   12672 </span><span class="lineNoCov">          0 :                 permerror (input_location, &quot;%&lt;static%&gt; may not be used when defining &quot;</span>
<span class="lineNum">   12673 </span>            :                            &quot;(as opposed to declaring) a static data member&quot;);
<span class="lineNum">   12674 </span><span class="lineNoCov">          0 :                 staticp = 0;</span>
<span class="lineNum">   12675 </span><span class="lineNoCov">          0 :                 storage_class = sc_none;</span>
<span class="lineNum">   12676 </span>            :               }
<span class="lineNum">   12677 </span><span class="lineCov">      56695 :             if (storage_class == sc_register &amp;&amp; TREE_STATIC (decl))</span>
<span class="lineNum">   12678 </span>            :               {
<span class="lineNum">   12679 </span><span class="lineNoCov">          0 :                 error (&quot;static member %qD declared %&lt;register%&gt;&quot;, decl);</span>
<span class="lineNum">   12680 </span><span class="lineNoCov">          0 :                 storage_class = sc_none;</span>
<span class="lineNum">   12681 </span>            :               }
<span class="lineNum">   12682 </span><span class="lineCov">      56695 :             if (storage_class == sc_extern &amp;&amp; pedantic)</span>
<span class="lineNum">   12683 </span>            :               {
<span class="lineNum">   12684 </span><span class="lineNoCov">          0 :                 pedwarn (input_location, OPT_Wpedantic, </span>
<span class="lineNum">   12685 </span>            :                          &quot;cannot explicitly declare member %q#D to have &quot;
<span class="lineNum">   12686 </span>            :                          &quot;extern linkage&quot;, decl);
<span class="lineNum">   12687 </span><span class="lineNoCov">          0 :                 storage_class = sc_none;</span>
<span class="lineNum">   12688 </span>            :               }
<span class="lineNum">   12689 </span>            :           }
<span class="lineNum">   12690 </span><span class="lineCov">    2534765 :         else if (constexpr_p &amp;&amp; DECL_EXTERNAL (decl))</span>
<span class="lineNum">   12691 </span>            :           {
<span class="lineNum">   12692 </span><span class="lineCov">          6 :             error (&quot;declaration of %&lt;constexpr%&gt; variable %qD &quot;</span>
<span class="lineNum">   12693 </span>            :                    &quot;is not a definition&quot;, decl);
<span class="lineNum">   12694 </span><span class="lineCov">          6 :             constexpr_p = false;</span>
<span class="lineNum">   12695 </span>            :           }
<span class="lineNum">   12696 </span>            : 
<span class="lineNum">   12697 </span><span class="lineCov">    2591460 :         if (inlinep)</span>
<span class="lineNum">   12698 </span><span class="lineCov">      55671 :           mark_inline_variable (decl, declspecs-&gt;locations[ds_inline]);</span>
<span class="lineNum">   12699 </span><span class="lineCov">    2591460 :         if (innermost_code == cdk_decomp)</span>
<span class="lineNum">   12700 </span>            :           {
<span class="lineNum">   12701 </span><span class="lineCov">        315 :             gcc_assert (declarator &amp;&amp; declarator-&gt;kind == cdk_decomp);</span>
<span class="lineNum">   12702 </span><span class="lineCov">        315 :             DECL_SOURCE_LOCATION (decl) = declarator-&gt;id_loc;</span>
<span class="lineNum">   12703 </span><span class="lineCov">        315 :             DECL_ARTIFICIAL (decl) = 1;</span>
<span class="lineNum">   12704 </span><span class="lineCov">        315 :             fit_decomposition_lang_decl (decl, NULL_TREE);</span>
<span class="lineNum">   12705 </span>            :           }
<span class="lineNum">   12706 </span>            :       }
<span class="lineNum">   12707 </span>            : 
<span class="lineNum">   12708 </span><span class="lineCov">   32053140 :     if (VAR_P (decl) &amp;&amp; !initialized)</span>
<span class="lineNum">   12709 </span><span class="lineCov">     715307 :       if (tree auto_node = type_uses_auto (type))</span>
<span class="lineNum">   12710 </span><span class="lineCov">         16 :         if (!CLASS_PLACEHOLDER_TEMPLATE (auto_node))</span>
<span class="lineNum">   12711 </span>            :           {
<span class="lineNum">   12712 </span><span class="lineCov">         12 :             location_t loc = declspecs-&gt;locations[ds_type_spec];</span>
<span class="lineNum">   12713 </span><span class="lineCov">         12 :             error_at (loc, &quot;declaration of %q#D has no initializer&quot;, decl);</span>
<span class="lineNum">   12714 </span><span class="lineCov">         12 :             TREE_TYPE (decl) = error_mark_node;</span>
<span class="lineNum">   12715 </span>            :           }
<span class="lineNum">   12716 </span>            : 
<span class="lineNum">   12717 </span><span class="lineCov">   32053140 :     if (storage_class == sc_extern &amp;&amp; initialized &amp;&amp; !funcdef_flag)</span>
<span class="lineNum">   12718 </span>            :       {
<span class="lineNum">   12719 </span><span class="lineCov">        154 :         if (toplevel_bindings_p ())</span>
<span class="lineNum">   12720 </span>            :           {
<span class="lineNum">   12721 </span>            :             /* It's common practice (and completely valid) to have a const
<span class="lineNum">   12722 </span>            :                be initialized and declared extern.  */
<span class="lineNum">   12723 </span><span class="lineCov">        151 :             if (!(type_quals &amp; TYPE_QUAL_CONST))</span>
<span class="lineNum">   12724 </span><span class="lineCov">          3 :               warning (0, &quot;%qs initialized and declared %&lt;extern%&gt;&quot;, name);</span>
<span class="lineNum">   12725 </span>            :           }
<span class="lineNum">   12726 </span>            :         else
<span class="lineNum">   12727 </span>            :           {
<span class="lineNum">   12728 </span><span class="lineCov">          3 :             error (&quot;%qs has both %&lt;extern%&gt; and initializer&quot;, name);</span>
<span class="lineNum">   12729 </span><span class="lineCov">          3 :             return error_mark_node;</span>
<span class="lineNum">   12730 </span>            :           }
<span class="lineNum">   12731 </span>            :       }
<span class="lineNum">   12732 </span>            : 
<span class="lineNum">   12733 </span>            :     /* Record `register' declaration for warnings on &amp;
<span class="lineNum">   12734 </span>            :        and in case doing stupid register allocation.  */
<span class="lineNum">   12735 </span>            : 
<span class="lineNum">   12736 </span><span class="lineCov">   32053137 :     if (storage_class == sc_register)</span>
<span class="lineNum">   12737 </span>            :       {
<span class="lineNum">   12738 </span><span class="lineCov">       2243 :         DECL_REGISTER (decl) = 1;</span>
<span class="lineNum">   12739 </span>            :         /* Warn about register storage specifiers on PARM_DECLs.  */
<span class="lineNum">   12740 </span><span class="lineCov">       2243 :         if (TREE_CODE (decl) == PARM_DECL)</span>
<span class="lineNum">   12741 </span>            :           {
<span class="lineNum">   12742 </span><span class="lineCov">         71 :             if (cxx_dialect &gt;= cxx17)</span>
<span class="lineNum">   12743 </span><span class="lineNoCov">          0 :               pedwarn (DECL_SOURCE_LOCATION (decl), OPT_Wregister,</span>
<span class="lineNum">   12744 </span>            :                        &quot;ISO C++17 does not allow %&lt;register%&gt; storage &quot;
<span class="lineNum">   12745 </span>            :                        &quot;class specifier&quot;);
<span class="lineNum">   12746 </span>            :             else
<span class="lineNum">   12747 </span><span class="lineCov">         71 :               warning_at (DECL_SOURCE_LOCATION (decl), OPT_Wregister,</span>
<span class="lineNum">   12748 </span>            :                           &quot;%&lt;register%&gt; storage class specifier used&quot;);
<span class="lineNum">   12749 </span>            :           }
<span class="lineNum">   12750 </span>            :       }
<span class="lineNum">   12751 </span><span class="lineCov">   32050894 :     else if (storage_class == sc_extern)</span>
<span class="lineNum">   12752 </span><span class="lineCov">    7143623 :       DECL_THIS_EXTERN (decl) = 1;</span>
<span class="lineNum">   12753 </span><span class="lineCov">   28360978 :     else if (storage_class == sc_static)</span>
<span class="lineNum">   12754 </span><span class="lineCov">    2664305 :       DECL_THIS_STATIC (decl) = 1;</span>
<span class="lineNum">   12755 </span>            : 
<span class="lineNum">   12756 </span>            :     /* Set constexpr flag on vars (functions got it in grokfndecl).  */
<span class="lineNum">   12757 </span><span class="lineCov">   32053137 :     if (constexpr_p &amp;&amp; VAR_P (decl))</span>
<span class="lineNum">   12758 </span><span class="lineCov">     655975 :       DECL_DECLARED_CONSTEXPR_P (decl) = true;</span>
<span class="lineNum">   12759 </span>            : 
<span class="lineNum">   12760 </span>            :     /* Record constancy and volatility on the DECL itself .  There's
<span class="lineNum">   12761 </span>            :        no need to do this when processing a template; we'll do this
<span class="lineNum">   12762 </span>            :        for the instantiated declaration based on the type of DECL.  */
<span class="lineNum">   12763 </span><span class="lineCov">   32053137 :     if (!processing_template_decl)</span>
<span class="lineNum">   12764 </span><span class="lineCov">   17982377 :       cp_apply_type_quals_to_decl (type_quals, decl);</span>
<span class="lineNum">   12765 </span>            : 
<span class="lineNum">   12766 </span>            :     return decl;
<span class="lineNum">   12767 </span>            :   }
<span class="lineNum">   12768 </span>            : }
<span class="lineNum">   12769 </span>            : 
<span class="lineNum">   12770 </span>            : /* Subroutine of start_function.  Ensure that each of the parameter
<span class="lineNum">   12771 </span>            :    types (as listed in PARMS) is complete, as is required for a
<span class="lineNum">   12772 </span>            :    function definition.  */
<a name="12773"><span class="lineNum">   12773 </span>            : </a>
<span class="lineNum">   12774 </span>            : static void
<span class="lineNum">   12775 </span><span class="lineCov">   15923054 : require_complete_types_for_parms (tree parms)</span>
<span class="lineNum">   12776 </span>            : {
<span class="lineNum">   12777 </span><span class="lineCov">   45000333 :   for (; parms; parms = DECL_CHAIN (parms))</span>
<span class="lineNum">   12778 </span>            :     {
<span class="lineNum">   12779 </span><span class="lineCov">   29077279 :       if (dependent_type_p (TREE_TYPE (parms)))</span>
<span class="lineNum">   12780 </span>            :         continue;
<span class="lineNum">   12781 </span><span class="lineCov">   22324221 :       if (!VOID_TYPE_P (TREE_TYPE (parms))</span>
<span class="lineNum">   12782 </span><span class="lineCov">   22324221 :           &amp;&amp; complete_type_or_else (TREE_TYPE (parms), parms))</span>
<span class="lineNum">   12783 </span>            :         {
<span class="lineNum">   12784 </span><span class="lineCov">   22324160 :           relayout_decl (parms);</span>
<span class="lineNum">   12785 </span><span class="lineCov">   22324160 :           DECL_ARG_TYPE (parms) = type_passed_as (TREE_TYPE (parms));</span>
<span class="lineNum">   12786 </span>            : 
<span class="lineNum">   12787 </span><span class="lineCov">   22324160 :           maybe_warn_parm_abi (TREE_TYPE (parms),</span>
<span class="lineNum">   12788 </span><span class="lineCov">   22324160 :                                DECL_SOURCE_LOCATION (parms));</span>
<span class="lineNum">   12789 </span>            :         }
<span class="lineNum">   12790 </span>            :       else
<span class="lineNum">   12791 </span>            :         /* grokparms or complete_type_or_else will have already issued
<span class="lineNum">   12792 </span>            :            an error.  */
<span class="lineNum">   12793 </span><span class="lineCov">         61 :         TREE_TYPE (parms) = error_mark_node;</span>
<span class="lineNum">   12794 </span>            :     }
<span class="lineNum">   12795 </span><span class="lineCov">   15923054 : }</span>
<span class="lineNum">   12796 </span>            : 
<span class="lineNum">   12797 </span>            : /* Returns nonzero if T is a local variable.  */
<a name="12798"><span class="lineNum">   12798 </span>            : </a>
<span class="lineNum">   12799 </span>            : int
<span class="lineNum">   12800 </span><span class="lineCov">    5742373 : local_variable_p (const_tree t)</span>
<span class="lineNum">   12801 </span>            : {
<span class="lineNum">   12802 </span><span class="lineCov">    5742373 :   if ((VAR_P (t)</span>
<span class="lineNum">   12803 </span>            :        /* A VAR_DECL with a context that is a _TYPE is a static data
<span class="lineNum">   12804 </span>            :           member.  */
<span class="lineNum">   12805 </span><span class="lineCov">    3786666 :        &amp;&amp; !TYPE_P (CP_DECL_CONTEXT (t))</span>
<span class="lineNum">   12806 </span>            :        /* Any other non-local variable must be at namespace scope.  */
<span class="lineNum">   12807 </span><span class="lineCov">    3658635 :        &amp;&amp; !DECL_NAMESPACE_SCOPE_P (t))</span>
<span class="lineNum">   12808 </span><span class="lineCov">    5973094 :       || (TREE_CODE (t) == PARM_DECL))</span>
<span class="lineNum">   12809 </span><span class="lineCov">    3555954 :     return 1;</span>
<span class="lineNum">   12810 </span>            : 
<span class="lineNum">   12811 </span>            :   return 0;
<span class="lineNum">   12812 </span>            : }
<span class="lineNum">   12813 </span>            : 
<span class="lineNum">   12814 </span>            : /* Like local_variable_p, but suitable for use as a tree-walking
<span class="lineNum">   12815 </span>            :    function.  */
<a name="12816"><span class="lineNum">   12816 </span>            : </a>
<span class="lineNum">   12817 </span>            : static tree
<span class="lineNum">   12818 </span><span class="lineCov">     527819 : local_variable_p_walkfn (tree *tp, int *walk_subtrees,</span>
<span class="lineNum">   12819 </span>            :                          void * /*data*/)
<span class="lineNum">   12820 </span>            : {
<span class="lineNum">   12821 </span><span class="lineCov">     527819 :   if (local_variable_p (*tp)</span>
<span class="lineNum">   12822 </span><span class="lineCov">     527819 :       &amp;&amp; (!DECL_ARTIFICIAL (*tp) || DECL_NAME (*tp) == this_identifier))</span>
<span class="lineNum">   12823 </span>            :     return *tp;
<span class="lineNum">   12824 </span><span class="lineCov">     527819 :   else if (TYPE_P (*tp))</span>
<span class="lineNum">   12825 </span><span class="lineCov">          9 :     *walk_subtrees = 0;</span>
<span class="lineNum">   12826 </span>            : 
<span class="lineNum">   12827 </span>            :   return NULL_TREE;
<span class="lineNum">   12828 </span>            : }
<span class="lineNum">   12829 </span>            : 
<span class="lineNum">   12830 </span>            : /* Check that ARG, which is a default-argument expression for a
<span class="lineNum">   12831 </span>            :    parameter DECL, is valid.  Returns ARG, or ERROR_MARK_NODE, if
<span class="lineNum">   12832 </span>            :    something goes wrong.  DECL may also be a _TYPE node, rather than a
<span class="lineNum">   12833 </span>            :    DECL, if there is no DECL available.  */
<a name="12834"><span class="lineNum">   12834 </span>            : </a>
<span class="lineNum">   12835 </span>            : tree
<span class="lineNum">   12836 </span><span class="lineCov">     231950 : check_default_argument (tree decl, tree arg, tsubst_flags_t complain)</span>
<span class="lineNum">   12837 </span>            : {
<span class="lineNum">   12838 </span><span class="lineCov">     231950 :   tree var;</span>
<span class="lineNum">   12839 </span><span class="lineCov">     231950 :   tree decl_type;</span>
<span class="lineNum">   12840 </span>            : 
<span class="lineNum">   12841 </span><span class="lineCov">     231950 :   if (TREE_CODE (arg) == DEFAULT_ARG)</span>
<span class="lineNum">   12842 </span>            :     /* We get a DEFAULT_ARG when looking at an in-class declaration
<span class="lineNum">   12843 </span>            :        with a default argument.  Ignore the argument for now; we'll
<span class="lineNum">   12844 </span>            :        deal with it after the class is complete.  */
<span class="lineNum">   12845 </span>            :     return arg;
<span class="lineNum">   12846 </span>            : 
<span class="lineNum">   12847 </span><span class="lineCov">     188251 :   if (TYPE_P (decl))</span>
<span class="lineNum">   12848 </span>            :     {
<span class="lineNum">   12849 </span>            :       decl_type = decl;
<span class="lineNum">   12850 </span>            :       decl = NULL_TREE;
<span class="lineNum">   12851 </span>            :     }
<span class="lineNum">   12852 </span>            :   else
<span class="lineNum">   12853 </span><span class="lineCov">      54220 :     decl_type = TREE_TYPE (decl);</span>
<span class="lineNum">   12854 </span>            : 
<span class="lineNum">   12855 </span><span class="lineCov">     188251 :   if (arg == error_mark_node</span>
<span class="lineNum">   12856 </span><span class="lineCov">     188157 :       || decl == error_mark_node</span>
<span class="lineNum">   12857 </span><span class="lineCov">     188148 :       || TREE_TYPE (arg) == error_mark_node</span>
<span class="lineNum">   12858 </span><span class="lineCov">     376399 :       || decl_type == error_mark_node)</span>
<span class="lineNum">   12859 </span>            :     /* Something already went wrong.  There's no need to check
<span class="lineNum">   12860 </span>            :        further.  */
<span class="lineNum">   12861 </span>            :     return error_mark_node;
<span class="lineNum">   12862 </span>            : 
<span class="lineNum">   12863 </span>            :   /* [dcl.fct.default]
<span class="lineNum">   12864 </span>            : 
<span class="lineNum">   12865 </span>            :      A default argument expression is implicitly converted to the
<span class="lineNum">   12866 </span>            :      parameter type.  */
<span class="lineNum">   12867 </span><span class="lineCov">     188148 :   ++cp_unevaluated_operand;</span>
<span class="lineNum">   12868 </span>            :   /* Avoid digest_init clobbering the initializer.  */
<span class="lineNum">   12869 </span><span class="lineCov">     188148 :   tree carg = BRACE_ENCLOSED_INITIALIZER_P (arg) ? unshare_expr (arg): arg;</span>
<span class="lineNum">   12870 </span><span class="lineCov">     188148 :   perform_implicit_conversion_flags (decl_type, carg, complain,</span>
<span class="lineNum">   12871 </span>            :                                      LOOKUP_IMPLICIT);
<span class="lineNum">   12872 </span><span class="lineCov">     188148 :   --cp_unevaluated_operand;</span>
<span class="lineNum">   12873 </span>            : 
<span class="lineNum">   12874 </span>            :   /* Avoid redundant -Wzero-as-null-pointer-constant warnings at
<span class="lineNum">   12875 </span>            :      the call sites.  */
<span class="lineNum">   12876 </span><span class="lineCov">     112787 :   if (TYPE_PTR_OR_PTRMEM_P (decl_type)</span>
<span class="lineNum">   12877 </span><span class="lineCov">     188154 :       &amp;&amp; null_ptr_cst_p (arg))</span>
<span class="lineNum">   12878 </span><span class="lineCov">      37016 :     return nullptr_node;</span>
<span class="lineNum">   12879 </span>            : 
<span class="lineNum">   12880 </span>            :   /* [dcl.fct.default]
<span class="lineNum">   12881 </span>            : 
<span class="lineNum">   12882 </span>            :      Local variables shall not be used in default argument
<span class="lineNum">   12883 </span>            :      expressions.
<span class="lineNum">   12884 </span>            : 
<span class="lineNum">   12885 </span>            :      The keyword `this' shall not be used in a default argument of a
<span class="lineNum">   12886 </span>            :      member function.  */
<span class="lineNum">   12887 </span><span class="lineCov">     151132 :   var = cp_walk_tree_without_duplicates (&amp;arg, local_variable_p_walkfn, NULL);</span>
<span class="lineNum">   12888 </span><span class="lineCov">     151132 :   if (var)</span>
<span class="lineNum">   12889 </span>            :     {
<span class="lineNum">   12890 </span><span class="lineNoCov">          0 :       if (complain &amp; tf_warning_or_error)</span>
<span class="lineNum">   12891 </span>            :         {
<span class="lineNum">   12892 </span><span class="lineNoCov">          0 :           if (DECL_NAME (var) == this_identifier)</span>
<span class="lineNum">   12893 </span><span class="lineNoCov">          0 :             permerror (input_location, &quot;default argument %qE uses %qD&quot;,</span>
<span class="lineNum">   12894 </span>            :                        arg, var);
<span class="lineNum">   12895 </span>            :           else
<span class="lineNum">   12896 </span><span class="lineNoCov">          0 :             error (&quot;default argument %qE uses local variable %qD&quot;, arg, var);</span>
<span class="lineNum">   12897 </span>            :         }
<span class="lineNum">   12898 </span><span class="lineNoCov">          0 :       return error_mark_node;</span>
<span class="lineNum">   12899 </span>            :     }
<span class="lineNum">   12900 </span>            : 
<span class="lineNum">   12901 </span>            :   /* All is well.  */
<span class="lineNum">   12902 </span><span class="lineCov">     151132 :   return arg;</span>
<span class="lineNum">   12903 </span>            : }
<span class="lineNum">   12904 </span>            : 
<span class="lineNum">   12905 </span>            : /* Returns a deprecated type used within TYPE, or NULL_TREE if none.  */
<a name="12906"><span class="lineNum">   12906 </span>            : </a>
<span class="lineNum">   12907 </span>            : static tree
<span class="lineNum">   12908 </span><span class="lineCov">   16373649 : type_is_deprecated (tree type)</span>
<span class="lineNum">   12909 </span>            : {
<span class="lineNum">   12910 </span><span class="lineCov">   24168873 :   enum tree_code code;</span>
<span class="lineNum">   12911 </span><span class="lineCov">   24168873 :   if (TREE_DEPRECATED (type))</span>
<span class="lineNum">   12912 </span>            :     return type;
<span class="lineNum">   12913 </span><span class="lineCov">   24168816 :   if (TYPE_NAME (type))</span>
<span class="lineNum">   12914 </span>            :     {
<span class="lineNum">   12915 </span><span class="lineCov">   32342874 :       if (TREE_DEPRECATED (TYPE_NAME (type)))</span>
<span class="lineNum">   12916 </span>            :         return type;
<span class="lineNum">   12917 </span>            :       else
<span class="lineNum">   12918 </span><span class="lineCov">   16171425 :         return NULL_TREE;</span>
<span class="lineNum">   12919 </span>            :     }
<span class="lineNum">   12920 </span>            : 
<span class="lineNum">   12921 </span>            :   /* Do warn about using typedefs to a deprecated class.  */
<span class="lineNum">   12922 </span><span class="lineCov">    7997379 :   if (OVERLOAD_TYPE_P (type) &amp;&amp; type != TYPE_MAIN_VARIANT (type))</span>
<span class="lineNum">   12923 </span>            :     return type_is_deprecated (TYPE_MAIN_VARIANT (type));
<span class="lineNum">   12924 </span>            : 
<span class="lineNum">   12925 </span><span class="lineCov">    7997379 :   code = TREE_CODE (type);</span>
<span class="lineNum">   12926 </span>            : 
<span class="lineNum">   12927 </span><span class="lineCov">   15994758 :   if (code == POINTER_TYPE || code == REFERENCE_TYPE</span>
<span class="lineNum">   12928 </span><span class="lineCov">    7997379 :       || code == OFFSET_TYPE || code == FUNCTION_TYPE</span>
<span class="lineNum">   12929 </span><span class="lineCov">     300278 :       || code == METHOD_TYPE || code == ARRAY_TYPE)</span>
<span class="lineNum">   12930 </span><span class="lineCov">    7767272 :     return type_is_deprecated (TREE_TYPE (type));</span>
<span class="lineNum">   12931 </span>            : 
<span class="lineNum">   12932 </span><span class="lineCov">     230107 :   if (TYPE_PTRMEMFUNC_P (type))</span>
<span class="lineNum">   12933 </span><span class="lineCov">      27952 :     return type_is_deprecated</span>
<span class="lineNum">   12934 </span><span class="lineCov">      27952 :       (TREE_TYPE (TREE_TYPE (TYPE_PTRMEMFUNC_FN_TYPE (type))));</span>
<span class="lineNum">   12935 </span>            : 
<span class="lineNum">   12936 </span>            :   return NULL_TREE;
<span class="lineNum">   12937 </span>            : }
<span class="lineNum">   12938 </span>            : 
<span class="lineNum">   12939 </span>            : /* Decode the list of parameter types for a function type.
<span class="lineNum">   12940 </span>            :    Given the list of things declared inside the parens,
<span class="lineNum">   12941 </span>            :    return a list of types.
<span class="lineNum">   12942 </span>            : 
<span class="lineNum">   12943 </span>            :    If this parameter does not end with an ellipsis, we append
<span class="lineNum">   12944 </span>            :    void_list_node.
<span class="lineNum">   12945 </span>            : 
<span class="lineNum">   12946 </span>            :    *PARMS is set to the chain of PARM_DECLs created.  */
<a name="12947"><span class="lineNum">   12947 </span>            : </a>
<span class="lineNum">   12948 </span>            : tree
<span class="lineNum">   12949 </span><span class="lineCov">   10411133 : grokparms (tree parmlist, tree *parms)</span>
<span class="lineNum">   12950 </span>            : {
<span class="lineNum">   12951 </span><span class="lineCov">   10411133 :   tree result = NULL_TREE;</span>
<span class="lineNum">   12952 </span><span class="lineCov">   10411133 :   tree decls = NULL_TREE;</span>
<span class="lineNum">   12953 </span><span class="lineCov">   10411133 :   tree parm;</span>
<span class="lineNum">   12954 </span><span class="lineCov">   10411133 :   int any_error = 0;</span>
<span class="lineNum">   12955 </span>            : 
<span class="lineNum">   12956 </span><span class="lineCov">   26863634 :   for (parm = parmlist; parm != NULL_TREE; parm = TREE_CHAIN (parm))</span>
<span class="lineNum">   12957 </span>            :     {
<span class="lineNum">   12958 </span><span class="lineCov">   26696552 :       tree type = NULL_TREE;</span>
<span class="lineNum">   12959 </span><span class="lineCov">   26696552 :       tree init = TREE_PURPOSE (parm);</span>
<span class="lineNum">   12960 </span><span class="lineCov">   26696552 :       tree decl = TREE_VALUE (parm);</span>
<span class="lineNum">   12961 </span>            : 
<span class="lineNum">   12962 </span><span class="lineCov">   26696552 :       if (parm == void_list_node)</span>
<span class="lineNum">   12963 </span>            :         break;
<span class="lineNum">   12964 </span>            : 
<span class="lineNum">   12965 </span><span class="lineCov">   16452513 :       if (! decl || TREE_TYPE (decl) == error_mark_node)</span>
<span class="lineNum">   12966 </span>            :         continue;
<span class="lineNum">   12967 </span>            : 
<span class="lineNum">   12968 </span><span class="lineCov">   16452440 :       type = TREE_TYPE (decl);</span>
<span class="lineNum">   12969 </span><span class="lineCov">   16452440 :       if (VOID_TYPE_P (type))</span>
<span class="lineNum">   12970 </span>            :         {
<span class="lineNum">   12971 </span><span class="lineCov">         76 :           if (same_type_p (type, void_type_node)</span>
<span class="lineNum">   12972 </span><span class="lineCov">         68 :               &amp;&amp; !init</span>
<span class="lineNum">   12973 </span><span class="lineCov">         56 :               &amp;&amp; !DECL_NAME (decl) &amp;&amp; !result</span>
<span class="lineNum">   12974 </span><span class="lineCov">        100 :               &amp;&amp; TREE_CHAIN (parm) == void_list_node)</span>
<span class="lineNum">   12975 </span>            :             /* DR 577: A parameter list consisting of a single
<span class="lineNum">   12976 </span>            :                unnamed parameter of non-dependent type 'void'.  */
<span class="lineNum">   12977 </span>            :             break;
<span class="lineNum">   12978 </span><span class="lineCov">         64 :           else if (cv_qualified_p (type))</span>
<span class="lineNum">   12979 </span><span class="lineCov">          8 :             error_at (DECL_SOURCE_LOCATION (decl),</span>
<span class="lineNum">   12980 </span>            :                       &quot;invalid use of cv-qualified type %qT in &quot;
<span class="lineNum">   12981 </span>            :                       &quot;parameter declaration&quot;, type);
<span class="lineNum">   12982 </span>            :           else
<span class="lineNum">   12983 </span><span class="lineCov">         56 :             error_at (DECL_SOURCE_LOCATION (decl),</span>
<span class="lineNum">   12984 </span>            :                       &quot;invalid use of type %&lt;void%&gt; in parameter &quot;
<span class="lineNum">   12985 </span>            :                       &quot;declaration&quot;);
<span class="lineNum">   12986 </span>            :           /* It's not a good idea to actually create parameters of
<span class="lineNum">   12987 </span>            :              type `void'; other parts of the compiler assume that a
<span class="lineNum">   12988 </span>            :              void type terminates the parameter list.  */
<span class="lineNum">   12989 </span><span class="lineCov">         64 :           type = error_mark_node;</span>
<span class="lineNum">   12990 </span><span class="lineCov">         64 :           TREE_TYPE (decl) = error_mark_node;</span>
<span class="lineNum">   12991 </span>            :         }
<span class="lineNum">   12992 </span>            : 
<span class="lineNum">   12993 </span><span class="lineCov">   16452428 :       if (type != error_mark_node)</span>
<span class="lineNum">   12994 </span>            :         {
<span class="lineNum">   12995 </span><span class="lineCov">   16452364 :           if (deprecated_state != DEPRECATED_SUPPRESS)</span>
<span class="lineNum">   12996 </span>            :             {
<span class="lineNum">   12997 </span><span class="lineCov">   16373649 :               tree deptype = type_is_deprecated (type);</span>
<span class="lineNum">   12998 </span><span class="lineCov">   16373649 :               if (deptype)</span>
<span class="lineNum">   12999 </span><span class="lineCov">         69 :                 cp_warn_deprecated_use (deptype);</span>
<span class="lineNum">   13000 </span>            :             }
<span class="lineNum">   13001 </span>            : 
<span class="lineNum">   13002 </span>            :           /* Top-level qualifiers on the parameters are
<span class="lineNum">   13003 </span>            :              ignored for function types.  */
<span class="lineNum">   13004 </span><span class="lineCov">   16452364 :           type = cp_build_qualified_type (type, 0);</span>
<span class="lineNum">   13005 </span><span class="lineCov">   16452364 :           if (TREE_CODE (type) == METHOD_TYPE)</span>
<span class="lineNum">   13006 </span>            :             {
<span class="lineNum">   13007 </span><span class="lineNoCov">          0 :               error (&quot;parameter %qD invalidly declared method type&quot;, decl);</span>
<span class="lineNum">   13008 </span><span class="lineNoCov">          0 :               type = build_pointer_type (type);</span>
<span class="lineNum">   13009 </span><span class="lineNoCov">          0 :               TREE_TYPE (decl) = type;</span>
<span class="lineNum">   13010 </span>            :             }
<span class="lineNum">   13011 </span><span class="lineCov">   16452364 :           else if (abstract_virtuals_error (decl, type))</span>
<span class="lineNum">   13012 </span>            :             any_error = 1;  /* Seems like a good idea.  */
<span class="lineNum">   13013 </span><span class="lineCov">   16452358 :           else if (cxx_dialect &lt; cxx17 &amp;&amp; INDIRECT_TYPE_P (type))</span>
<span class="lineNum">   13014 </span>            :             {
<span class="lineNum">   13015 </span>            :               /* Before C++17 DR 393:
<span class="lineNum">   13016 </span>            :                  [dcl.fct]/6, parameter types cannot contain pointers
<span class="lineNum">   13017 </span>            :                  (references) to arrays of unknown bound.  */
<span class="lineNum">   13018 </span><span class="lineCov">    6032236 :               tree t = TREE_TYPE (type);</span>
<span class="lineNum">   13019 </span><span class="lineCov">    6032236 :               int ptr = TYPE_PTR_P (type);</span>
<span class="lineNum">   13020 </span>            : 
<span class="lineNum">   13021 </span><span class="lineCov">    6276963 :               while (1)</span>
<span class="lineNum">   13022 </span>            :                 {
<span class="lineNum">   13023 </span><span class="lineCov">    6276963 :                   if (TYPE_PTR_P (t))</span>
<span class="lineNum">   13024 </span>            :                     ptr = 1;
<span class="lineNum">   13025 </span><span class="lineCov">    6045955 :                   else if (TREE_CODE (t) != ARRAY_TYPE)</span>
<span class="lineNum">   13026 </span>            :                     break;
<span class="lineNum">   13027 </span><span class="lineCov">      27456 :                   else if (!TYPE_DOMAIN (t))</span>
<span class="lineNum">   13028 </span>            :                     break;
<span class="lineNum">   13029 </span><span class="lineCov">     244727 :                   t = TREE_TYPE (t);</span>
<span class="lineNum">   13030 </span>            :                 }
<span class="lineNum">   13031 </span><span class="lineCov">    6032236 :               if (TREE_CODE (t) == ARRAY_TYPE)</span>
<span class="lineNum">   13032 </span><span class="lineCov">         15 :                 pedwarn (DECL_SOURCE_LOCATION (decl), OPT_Wpedantic,</span>
<span class="lineNum">   13033 </span>            :                          ptr
<span class="lineNum">   13034 </span>            :                          ? G_(&quot;parameter %qD includes pointer to array of &quot;
<span class="lineNum">   13035 </span>            :                               &quot;unknown bound %qT&quot;)
<span class="lineNum">   13036 </span>            :                          : G_(&quot;parameter %qD includes reference to array of &quot;
<span class="lineNum">   13037 </span>            :                               &quot;unknown bound %qT&quot;),
<span class="lineNum">   13038 </span>            :                          decl, t);
<span class="lineNum">   13039 </span>            :             }
<span class="lineNum">   13040 </span>            : 
<span class="lineNum">   13041 </span><span class="lineCov">   16452358 :           if (any_error)</span>
<span class="lineNum">   13042 </span>            :             init = NULL_TREE;
<span class="lineNum">   13043 </span><span class="lineCov">   16452358 :           else if (init &amp;&amp; !processing_template_decl)</span>
<span class="lineNum">   13044 </span><span class="lineCov">      97910 :             init = check_default_argument (decl, init, tf_warning_or_error);</span>
<span class="lineNum">   13045 </span>            :         }
<span class="lineNum">   13046 </span>            : 
<span class="lineNum">   13047 </span><span class="lineCov">   16452428 :       DECL_CHAIN (decl) = decls;</span>
<span class="lineNum">   13048 </span><span class="lineCov">   16452428 :       decls = decl;</span>
<span class="lineNum">   13049 </span><span class="lineCov">   16452428 :       result = tree_cons (init, type, result);</span>
<span class="lineNum">   13050 </span>            :     }
<span class="lineNum">   13051 </span><span class="lineCov">   10411133 :   decls = nreverse (decls);</span>
<span class="lineNum">   13052 </span><span class="lineCov">   10411133 :   result = nreverse (result);</span>
<span class="lineNum">   13053 </span><span class="lineCov">   10411133 :   if (parm)</span>
<span class="lineNum">   13054 </span><span class="lineCov">   10244051 :     result = chainon (result, void_list_node);</span>
<span class="lineNum">   13055 </span><span class="lineCov">   10411133 :   *parms = decls;</span>
<span class="lineNum">   13056 </span>            : 
<span class="lineNum">   13057 </span><span class="lineCov">   10411133 :   return result;</span>
<span class="lineNum">   13058 </span>            : }
<span class="lineNum">   13059 </span>            : 
<span class="lineNum">   13060 </span>            : 
<span class="lineNum">   13061 </span>            : /* D is a constructor or overloaded `operator='.
<span class="lineNum">   13062 </span>            : 
<span class="lineNum">   13063 </span>            :    Let T be the class in which D is declared. Then, this function
<span class="lineNum">   13064 </span>            :    returns:
<span class="lineNum">   13065 </span>            : 
<span class="lineNum">   13066 </span>            :    -1 if D's is an ill-formed constructor or copy assignment operator
<span class="lineNum">   13067 </span>            :       whose first parameter is of type `T'.
<span class="lineNum">   13068 </span>            :    0  if D is not a copy constructor or copy assignment
<span class="lineNum">   13069 </span>            :       operator.
<span class="lineNum">   13070 </span>            :    1  if D is a copy constructor or copy assignment operator whose
<span class="lineNum">   13071 </span>            :       first parameter is a reference to non-const qualified T.
<span class="lineNum">   13072 </span>            :    2  if D is a copy constructor or copy assignment operator whose
<span class="lineNum">   13073 </span>            :       first parameter is a reference to const qualified T.
<span class="lineNum">   13074 </span>            : 
<span class="lineNum">   13075 </span>            :    This function can be used as a predicate. Positive values indicate
<span class="lineNum">   13076 </span>            :    a copy constructor and nonzero values indicate a copy assignment
<span class="lineNum">   13077 </span>            :    operator.  */
<a name="13078"><span class="lineNum">   13078 </span>            : </a>
<span class="lineNum">   13079 </span>            : int
<span class="lineNum">   13080 </span><span class="lineCov">   21889598 : copy_fn_p (const_tree d)</span>
<span class="lineNum">   13081 </span>            : {
<span class="lineNum">   13082 </span><span class="lineCov">   21889598 :   tree args;</span>
<span class="lineNum">   13083 </span><span class="lineCov">   21889598 :   tree arg_type;</span>
<span class="lineNum">   13084 </span><span class="lineCov">   21889598 :   int result = 1;</span>
<span class="lineNum">   13085 </span>            : 
<span class="lineNum">   13086 </span><span class="lineCov">   21889598 :   gcc_assert (DECL_FUNCTION_MEMBER_P (d));</span>
<span class="lineNum">   13087 </span>            : 
<span class="lineNum">   13088 </span><span class="lineCov">   21889598 :   if (TREE_CODE (d) == TEMPLATE_DECL</span>
<span class="lineNum">   13089 </span><span class="lineCov">   21889598 :       || (DECL_TEMPLATE_INFO (d)</span>
<span class="lineNum">   13090 </span><span class="lineCov">    8090867 :           &amp;&amp; DECL_MEMBER_TEMPLATE_P (DECL_TI_TEMPLATE (d))))</span>
<span class="lineNum">   13091 </span>            :     /* Instantiations of template member functions are never copy
<span class="lineNum">   13092 </span>            :        functions.  Note that member functions of templated classes are
<span class="lineNum">   13093 </span>            :        represented as template functions internally, and we must
<span class="lineNum">   13094 </span>            :        accept those as copy functions.  */
<span class="lineNum">   13095 </span>            :     return 0;
<span class="lineNum">   13096 </span>            : 
<span class="lineNum">   13097 </span><span class="lineCov">   56549127 :   args = FUNCTION_FIRST_USER_PARMTYPE (d);</span>
<span class="lineNum">   13098 </span><span class="lineCov">   18849709 :   if (!args)</span>
<span class="lineNum">   13099 </span>            :     return 0;
<span class="lineNum">   13100 </span>            : 
<span class="lineNum">   13101 </span><span class="lineCov">   18844184 :   arg_type = TREE_VALUE (args);</span>
<span class="lineNum">   13102 </span><span class="lineCov">   18844184 :   if (arg_type == error_mark_node)</span>
<span class="lineNum">   13103 </span>            :     return 0;
<span class="lineNum">   13104 </span>            : 
<span class="lineNum">   13105 </span><span class="lineCov">   18844156 :   if (TYPE_MAIN_VARIANT (arg_type) == DECL_CONTEXT (d))</span>
<span class="lineNum">   13106 </span>            :     {
<span class="lineNum">   13107 </span>            :       /* Pass by value copy assignment operator.  */
<span class="lineNum">   13108 </span>            :       result = -1;
<span class="lineNum">   13109 </span>            :     }
<span class="lineNum">   13110 </span><span class="lineCov">   18843975 :   else if (TYPE_REF_P (arg_type)</span>
<span class="lineNum">   13111 </span><span class="lineCov">   26095394 :            &amp;&amp; !TYPE_REF_IS_RVALUE (arg_type)</span>
<span class="lineNum">   13112 </span><span class="lineCov">   26136135 :            &amp;&amp; TYPE_MAIN_VARIANT (TREE_TYPE (arg_type)) == DECL_CONTEXT (d))</span>
<span class="lineNum">   13113 </span>            :     {
<span class="lineNum">   13114 </span><span class="lineCov">   12515550 :       if (CP_TYPE_CONST_P (TREE_TYPE (arg_type)))</span>
<span class="lineNum">   13115 </span><span class="lineCov">    6250616 :         result = 2;</span>
<span class="lineNum">   13116 </span>            :     }
<span class="lineNum">   13117 </span>            :   else
<span class="lineNum">   13118 </span>            :     return 0;
<span class="lineNum">   13119 </span>            : 
<span class="lineNum">   13120 </span><span class="lineCov">    6257956 :   args = TREE_CHAIN (args);</span>
<span class="lineNum">   13121 </span>            : 
<span class="lineNum">   13122 </span><span class="lineCov">    6257956 :   if (args &amp;&amp; args != void_list_node &amp;&amp; !TREE_PURPOSE (args))</span>
<span class="lineNum">   13123 </span>            :     /* There are more non-optional args.  */
<span class="lineNum">   13124 </span><span class="lineCov">     163594 :     return 0;</span>
<span class="lineNum">   13125 </span>            : 
<span class="lineNum">   13126 </span>            :   return result;
<span class="lineNum">   13127 </span>            : }
<span class="lineNum">   13128 </span>            : 
<span class="lineNum">   13129 </span>            : /* D is a constructor or overloaded `operator='.
<span class="lineNum">   13130 </span>            : 
<span class="lineNum">   13131 </span>            :    Let T be the class in which D is declared. Then, this function
<span class="lineNum">   13132 </span>            :    returns true when D is a move constructor or move assignment
<span class="lineNum">   13133 </span>            :    operator, false otherwise.  */
<a name="13134"><span class="lineNum">   13134 </span>            : </a>
<span class="lineNum">   13135 </span>            : bool
<span class="lineNum">   13136 </span><span class="lineCov">   13817888 : move_fn_p (const_tree d)</span>
<span class="lineNum">   13137 </span>            : {
<span class="lineNum">   13138 </span><span class="lineCov">   13817888 :   gcc_assert (DECL_FUNCTION_MEMBER_P (d));</span>
<span class="lineNum">   13139 </span>            : 
<span class="lineNum">   13140 </span><span class="lineCov">   13817888 :   if (cxx_dialect == cxx98)</span>
<span class="lineNum">   13141 </span>            :     /* There are no move constructors if we are in C++98 mode.  */
<span class="lineNum">   13142 </span>            :     return false;
<span class="lineNum">   13143 </span>            : 
<span class="lineNum">   13144 </span><span class="lineCov">   13727083 :   if (TREE_CODE (d) == TEMPLATE_DECL</span>
<span class="lineNum">   13145 </span><span class="lineCov">   13727083 :       || (DECL_TEMPLATE_INFO (d)</span>
<span class="lineNum">   13146 </span><span class="lineCov">    3798091 :          &amp;&amp; DECL_MEMBER_TEMPLATE_P (DECL_TI_TEMPLATE (d))))</span>
<span class="lineNum">   13147 </span>            :     /* Instantiations of template member functions are never move
<span class="lineNum">   13148 </span>            :        functions.  Note that member functions of templated classes are
<span class="lineNum">   13149 </span>            :        represented as template functions internally, and we must
<span class="lineNum">   13150 </span>            :        accept those as move functions.  */
<span class="lineNum">   13151 </span>            :     return 0;
<span class="lineNum">   13152 </span>            : 
<span class="lineNum">   13153 </span><span class="lineCov">   11265042 :   return move_signature_fn_p (d);</span>
<span class="lineNum">   13154 </span>            : }
<span class="lineNum">   13155 </span>            : 
<span class="lineNum">   13156 </span>            : /* D is a constructor or overloaded `operator='.
<span class="lineNum">   13157 </span>            : 
<span class="lineNum">   13158 </span>            :    Then, this function returns true when D has the same signature as a move
<span class="lineNum">   13159 </span>            :    constructor or move assignment operator (because either it is such a
<span class="lineNum">   13160 </span>            :    ctor/op= or it is a template specialization with the same signature),
<span class="lineNum">   13161 </span>            :    false otherwise.  */
<a name="13162"><span class="lineNum">   13162 </span>            : </a>
<span class="lineNum">   13163 </span>            : bool
<span class="lineNum">   13164 </span><span class="lineCov">   11265042 : move_signature_fn_p (const_tree d)</span>
<span class="lineNum">   13165 </span>            : {
<span class="lineNum">   13166 </span><span class="lineCov">   11265042 :   tree args;</span>
<span class="lineNum">   13167 </span><span class="lineCov">   11265042 :   tree arg_type;</span>
<span class="lineNum">   13168 </span><span class="lineCov">   11265042 :   bool result = false;</span>
<span class="lineNum">   13169 </span>            : 
<span class="lineNum">   13170 </span><span class="lineCov">   22530084 :   args = FUNCTION_FIRST_USER_PARMTYPE (d);</span>
<span class="lineNum">   13171 </span><span class="lineCov">   11265042 :   if (!args)</span>
<span class="lineNum">   13172 </span>            :     return 0;
<span class="lineNum">   13173 </span>            : 
<span class="lineNum">   13174 </span><span class="lineCov">   11263647 :   arg_type = TREE_VALUE (args);</span>
<span class="lineNum">   13175 </span><span class="lineCov">   11263647 :   if (arg_type == error_mark_node)</span>
<span class="lineNum">   13176 </span>            :     return 0;
<span class="lineNum">   13177 </span>            : 
<span class="lineNum">   13178 </span><span class="lineCov">   11263629 :   if (TYPE_REF_P (arg_type)</span>
<span class="lineNum">   13179 </span><span class="lineCov">   15881156 :       &amp;&amp; TYPE_REF_IS_RVALUE (arg_type)</span>
<span class="lineNum">   13180 </span><span class="lineCov">   18240177 :       &amp;&amp; same_type_p (TYPE_MAIN_VARIANT (TREE_TYPE (arg_type)),</span>
<span class="lineNum">   13181 </span>            :                       DECL_CONTEXT (d)))
<span class="lineNum">   13182 </span>            :     result = true;
<span class="lineNum">   13183 </span>            : 
<span class="lineNum">   13184 </span><span class="lineCov">   11263629 :   args = TREE_CHAIN (args);</span>
<span class="lineNum">   13185 </span>            : 
<span class="lineNum">   13186 </span><span class="lineCov">   11263629 :   if (args &amp;&amp; args != void_list_node &amp;&amp; !TREE_PURPOSE (args))</span>
<span class="lineNum">   13187 </span>            :     /* There are more non-optional args.  */
<span class="lineNum">   13188 </span><span class="lineCov">     662574 :     return false;</span>
<span class="lineNum">   13189 </span>            : 
<span class="lineNum">   13190 </span>            :   return result;
<span class="lineNum">   13191 </span>            : }
<span class="lineNum">   13192 </span>            : 
<span class="lineNum">   13193 </span>            : /* Remember any special properties of member function DECL.  */
<a name="13194"><span class="lineNum">   13194 </span>            : </a>
<span class="lineNum">   13195 </span>            : void
<span class="lineNum">   13196 </span><span class="lineCov">   22516954 : grok_special_member_properties (tree decl)</span>
<span class="lineNum">   13197 </span>            : {
<span class="lineNum">   13198 </span><span class="lineCov">   22516954 :   tree class_type;</span>
<span class="lineNum">   13199 </span>            : 
<span class="lineNum">   13200 </span><span class="lineCov">   22516954 :   if (!DECL_NONSTATIC_MEMBER_FUNCTION_P (decl))</span>
<span class="lineNum">   13201 </span>            :     return;
<span class="lineNum">   13202 </span>            : 
<span class="lineNum">   13203 </span><span class="lineCov">   20139343 :   class_type = DECL_CONTEXT (decl);</span>
<span class="lineNum">   13204 </span><span class="lineCov">   40278686 :   if (IDENTIFIER_CTOR_P (DECL_NAME (decl)))</span>
<span class="lineNum">   13205 </span>            :     {
<span class="lineNum">   13206 </span><span class="lineCov">   10577915 :       int ctor = copy_fn_p (decl);</span>
<span class="lineNum">   13207 </span>            : 
<span class="lineNum">   13208 </span><span class="lineCov">   10577915 :       if (!DECL_ARTIFICIAL (decl))</span>
<span class="lineNum">   13209 </span><span class="lineCov">    5865123 :         TYPE_HAS_USER_CONSTRUCTOR (class_type) = 1;</span>
<span class="lineNum">   13210 </span>            : 
<span class="lineNum">   13211 </span><span class="lineCov">   10577915 :       if (ctor &gt; 0)</span>
<span class="lineNum">   13212 </span>            :         {
<span class="lineNum">   13213 </span>            :           /* [class.copy]
<span class="lineNum">   13214 </span>            : 
<span class="lineNum">   13215 </span>            :              A non-template constructor for class X is a copy
<span class="lineNum">   13216 </span>            :              constructor if its first parameter is of type X&amp;, const
<span class="lineNum">   13217 </span>            :              X&amp;, volatile X&amp; or const volatile X&amp;, and either there
<span class="lineNum">   13218 </span>            :              are no other parameters or else all other parameters have
<span class="lineNum">   13219 </span>            :              default arguments.  */
<span class="lineNum">   13220 </span><span class="lineCov">    2874330 :           TYPE_HAS_COPY_CTOR (class_type) = 1;</span>
<span class="lineNum">   13221 </span><span class="lineCov">    2874330 :           if (user_provided_p (decl))</span>
<span class="lineNum">   13222 </span><span class="lineCov">     436487 :             TYPE_HAS_COMPLEX_COPY_CTOR (class_type) = 1;</span>
<span class="lineNum">   13223 </span><span class="lineCov">    2874330 :           if (ctor &gt; 1)</span>
<span class="lineNum">   13224 </span><span class="lineCov">    2870975 :             TYPE_HAS_CONST_COPY_CTOR (class_type) = 1;</span>
<span class="lineNum">   13225 </span>            :         }
<span class="lineNum">   13226 </span><span class="lineCov">   15407170 :       else if (sufficient_parms_p (FUNCTION_FIRST_USER_PARMTYPE (decl)))</span>
<span class="lineNum">   13227 </span><span class="lineCov">    2594691 :         TYPE_HAS_DEFAULT_CONSTRUCTOR (class_type) = 1;</span>
<span class="lineNum">   13228 </span><span class="lineCov">    5108894 :       else if (move_fn_p (decl) &amp;&amp; user_provided_p (decl))</span>
<span class="lineNum">   13229 </span><span class="lineCov">     197861 :         TYPE_HAS_COMPLEX_MOVE_CTOR (class_type) = 1;</span>
<span class="lineNum">   13230 </span><span class="lineCov">    4911033 :       else if (is_list_ctor (decl))</span>
<span class="lineNum">   13231 </span><span class="lineCov">      61129 :         TYPE_HAS_LIST_CTOR (class_type) = 1;</span>
<span class="lineNum">   13232 </span>            : 
<span class="lineNum">   13233 </span><span class="lineCov">   21155830 :       if (DECL_DECLARED_CONSTEXPR_P (decl)</span>
<span class="lineNum">   13234 </span><span class="lineCov">   10577915 :           &amp;&amp; !ctor &amp;&amp; !move_fn_p (decl))</span>
<span class="lineNum">   13235 </span><span class="lineCov">    1613944 :         TYPE_HAS_CONSTEXPR_CTOR (class_type) = 1;</span>
<span class="lineNum">   13236 </span>            :     }
<span class="lineNum">   13237 </span><span class="lineCov">   19122856 :   else if (DECL_NAME (decl) == assign_op_identifier)</span>
<span class="lineNum">   13238 </span>            :     {
<span class="lineNum">   13239 </span>            :       /* [class.copy]
<span class="lineNum">   13240 </span>            : 
<span class="lineNum">   13241 </span>            :          A non-template assignment operator for class X is a copy
<span class="lineNum">   13242 </span>            :          assignment operator if its parameter is of type X, X&amp;, const
<span class="lineNum">   13243 </span>            :          X&amp;, volatile X&amp; or const volatile X&amp;.  */
<span class="lineNum">   13244 </span>            : 
<span class="lineNum">   13245 </span><span class="lineCov">     698457 :       int assop = copy_fn_p (decl);</span>
<span class="lineNum">   13246 </span>            : 
<span class="lineNum">   13247 </span><span class="lineCov">     698457 :       if (assop)</span>
<span class="lineNum">   13248 </span>            :         {
<span class="lineNum">   13249 </span><span class="lineCov">     358422 :           TYPE_HAS_COPY_ASSIGN (class_type) = 1;</span>
<span class="lineNum">   13250 </span><span class="lineCov">     358422 :           if (user_provided_p (decl))</span>
<span class="lineNum">   13251 </span><span class="lineCov">      71281 :             TYPE_HAS_COMPLEX_COPY_ASSIGN (class_type) = 1;</span>
<span class="lineNum">   13252 </span><span class="lineCov">     358422 :           if (assop != 1)</span>
<span class="lineNum">   13253 </span><span class="lineCov">     357491 :             TYPE_HAS_CONST_COPY_ASSIGN (class_type) = 1;</span>
<span class="lineNum">   13254 </span>            :         }
<span class="lineNum">   13255 </span><span class="lineCov">     340035 :       else if (move_fn_p (decl) &amp;&amp; user_provided_p (decl))</span>
<span class="lineNum">   13256 </span><span class="lineCov">      57771 :         TYPE_HAS_COMPLEX_MOVE_ASSIGN (class_type) = 1;</span>
<span class="lineNum">   13257 </span>            :     }
<span class="lineNum">   13258 </span><span class="lineCov">   88629710 :   else if (IDENTIFIER_CONV_OP_P (DECL_NAME (decl)))</span>
<span class="lineNum">   13259 </span><span class="lineCov">      83850 :     TYPE_HAS_CONVERSION (class_type) = true;</span>
<span class="lineNum">   13260 </span>            :   
<span class="lineNum">   13261 </span>            :   /* Destructors are handled in check_methods.  */
<span class="lineNum">   13262 </span>            : }
<span class="lineNum">   13263 </span>            : 
<span class="lineNum">   13264 </span>            : /* Check a constructor DECL has the correct form.  Complains
<span class="lineNum">   13265 </span>            :    if the class has a constructor of the form X(X).  */
<a name="13266"><span class="lineNum">   13266 </span>            : </a>
<span class="lineNum">   13267 </span>            : bool
<span class="lineNum">   13268 </span><span class="lineCov">    2803241 : grok_ctor_properties (const_tree ctype, const_tree decl)</span>
<span class="lineNum">   13269 </span>            : {
<span class="lineNum">   13270 </span><span class="lineCov">    2803241 :   int ctor_parm = copy_fn_p (decl);</span>
<span class="lineNum">   13271 </span>            : 
<span class="lineNum">   13272 </span><span class="lineCov">    2803241 :   if (ctor_parm &lt; 0)</span>
<span class="lineNum">   13273 </span>            :     {
<span class="lineNum">   13274 </span>            :       /* [class.copy]
<span class="lineNum">   13275 </span>            : 
<span class="lineNum">   13276 </span>            :          A declaration of a constructor for a class X is ill-formed if
<span class="lineNum">   13277 </span>            :          its first parameter is of type (optionally cv-qualified) X
<span class="lineNum">   13278 </span>            :          and either there are no other parameters or else all other
<span class="lineNum">   13279 </span>            :          parameters have default arguments.
<span class="lineNum">   13280 </span>            : 
<span class="lineNum">   13281 </span>            :          We *don't* complain about member template instantiations that
<span class="lineNum">   13282 </span>            :          have this form, though; they can occur as we try to decide
<span class="lineNum">   13283 </span>            :          what constructor to use during overload resolution.  Since
<span class="lineNum">   13284 </span>            :          overload resolution will never prefer such a constructor to
<span class="lineNum">   13285 </span>            :          the non-template copy constructor (which is either explicitly
<span class="lineNum">   13286 </span>            :          or implicitly defined), there's no need to worry about their
<span class="lineNum">   13287 </span>            :          existence.  Theoretically, they should never even be
<span class="lineNum">   13288 </span>            :          instantiated, but that's hard to forestall.  */
<span class="lineNum">   13289 </span><span class="lineCov">          9 :       error (&quot;invalid constructor; you probably meant %&lt;%T (const %T&amp;)%&gt;&quot;,</span>
<span class="lineNum">   13290 </span>            :                 ctype, ctype);
<span class="lineNum">   13291 </span><span class="lineCov">          9 :       return false;</span>
<span class="lineNum">   13292 </span>            :     }
<span class="lineNum">   13293 </span>            : 
<span class="lineNum">   13294 </span>            :   return true;
<span class="lineNum">   13295 </span>            : }
<span class="lineNum">   13296 </span>            : 
<span class="lineNum">   13297 </span>            : /* DECL is a declaration for an overloaded or conversion operator.  If
<span class="lineNum">   13298 </span>            :    COMPLAIN is true, errors are issued for invalid declarations.  */
<a name="13299"><span class="lineNum">   13299 </span>            : </a>
<span class="lineNum">   13300 </span>            : bool
<span class="lineNum">   13301 </span><span class="lineCov">    2689095 : grok_op_properties (tree decl, bool complain)</span>
<span class="lineNum">   13302 </span>            : {
<span class="lineNum">   13303 </span><span class="lineCov">    2689095 :   tree argtypes = TYPE_ARG_TYPES (TREE_TYPE (decl));</span>
<span class="lineNum">   13304 </span><span class="lineCov">    2689095 :   bool methodp = TREE_CODE (TREE_TYPE (decl)) == METHOD_TYPE;</span>
<span class="lineNum">   13305 </span><span class="lineCov">    2689095 :   tree name = DECL_NAME (decl);</span>
<span class="lineNum">   13306 </span><span class="lineCov">    2689095 :   location_t loc = DECL_SOURCE_LOCATION (decl);</span>
<span class="lineNum">   13307 </span>            : 
<span class="lineNum">   13308 </span><span class="lineCov">    2689095 :   tree class_type = DECL_CONTEXT (decl);</span>
<span class="lineNum">   13309 </span><span class="lineCov">    2689095 :   if (class_type &amp;&amp; !CLASS_TYPE_P (class_type))</span>
<span class="lineNum">   13310 </span>            :     class_type = NULL_TREE;
<span class="lineNum">   13311 </span>            : 
<span class="lineNum">   13312 </span><span class="lineCov">    2689095 :   tree_code operator_code;</span>
<span class="lineNum">   13313 </span><span class="lineCov">    2689095 :   unsigned op_flags;</span>
<span class="lineNum">   13314 </span><span class="lineCov">    2689095 :   if (IDENTIFIER_CONV_OP_P (name))</span>
<span class="lineNum">   13315 </span>            :     {
<span class="lineNum">   13316 </span>            :       /* Conversion operators are TYPE_EXPR for the purposes of this
<span class="lineNum">   13317 </span>            :          function.  */
<span class="lineNum">   13318 </span>            :       operator_code = TYPE_EXPR;
<span class="lineNum">   13319 </span>            :       op_flags = OVL_OP_FLAG_UNARY;
<span class="lineNum">   13320 </span>            :     }
<span class="lineNum">   13321 </span>            :   else
<span class="lineNum">   13322 </span>            :     {
<span class="lineNum">   13323 </span><span class="lineCov">    7873371 :       const ovl_op_info_t *ovl_op = IDENTIFIER_OVL_OP_INFO (name);</span>
<span class="lineNum">   13324 </span>            : 
<span class="lineNum">   13325 </span><span class="lineCov">    2624457 :       operator_code = ovl_op-&gt;tree_code;</span>
<span class="lineNum">   13326 </span><span class="lineCov">    2624457 :       op_flags = ovl_op-&gt;flags;</span>
<span class="lineNum">   13327 </span><span class="lineCov">    2624457 :       gcc_checking_assert (operator_code != ERROR_MARK);</span>
<span class="lineNum">   13328 </span><span class="lineCov">    2624457 :       DECL_OVERLOADED_OPERATOR_CODE_RAW (decl) = ovl_op-&gt;ovl_op_code;</span>
<span class="lineNum">   13329 </span>            :     }
<span class="lineNum">   13330 </span>            : 
<span class="lineNum">   13331 </span><span class="lineCov">    2689095 :   if (op_flags &amp; OVL_OP_FLAG_ALLOC)</span>
<span class="lineNum">   13332 </span>            :     {
<span class="lineNum">   13333 </span>            :       /* operator new and operator delete are quite special.  */
<span class="lineNum">   13334 </span><span class="lineCov">      37996 :       if (class_type)</span>
<span class="lineNum">   13335 </span><span class="lineCov">       1195 :         switch (op_flags)</span>
<span class="lineNum">   13336 </span>            :           {
<span class="lineNum">   13337 </span><span class="lineCov">        683 :           case OVL_OP_FLAG_ALLOC:</span>
<span class="lineNum">   13338 </span><span class="lineCov">        683 :             TYPE_HAS_NEW_OPERATOR (class_type) = 1;</span>
<span class="lineNum">   13339 </span><span class="lineCov">        683 :             break;</span>
<span class="lineNum">   13340 </span>            : 
<span class="lineNum">   13341 </span><span class="lineCov">        433 :           case OVL_OP_FLAG_ALLOC | OVL_OP_FLAG_DELETE:</span>
<span class="lineNum">   13342 </span><span class="lineCov">        433 :             TYPE_GETS_DELETE (class_type) |= 1;</span>
<span class="lineNum">   13343 </span><span class="lineCov">        433 :             break;</span>
<span class="lineNum">   13344 </span>            : 
<span class="lineNum">   13345 </span><span class="lineCov">         47 :           case OVL_OP_FLAG_ALLOC | OVL_OP_FLAG_VEC:</span>
<span class="lineNum">   13346 </span><span class="lineCov">         47 :             TYPE_HAS_ARRAY_NEW_OPERATOR (class_type) = 1;</span>
<span class="lineNum">   13347 </span><span class="lineCov">         47 :             break;</span>
<span class="lineNum">   13348 </span>            : 
<span class="lineNum">   13349 </span><span class="lineCov">         32 :           case OVL_OP_FLAG_ALLOC | OVL_OP_FLAG_DELETE | OVL_OP_FLAG_VEC:</span>
<span class="lineNum">   13350 </span><span class="lineCov">         32 :             TYPE_GETS_DELETE (class_type) |= 2;</span>
<span class="lineNum">   13351 </span><span class="lineCov">         32 :             break;</span>
<span class="lineNum">   13352 </span>            : 
<span class="lineNum">   13353 </span><span class="lineNoCov">          0 :           default:</span>
<span class="lineNum">   13354 </span><span class="lineNoCov">          0 :             gcc_unreachable ();</span>
<span class="lineNum">   13355 </span>            :           }
<span class="lineNum">   13356 </span>            : 
<span class="lineNum">   13357 </span>            :       /* [basic.std.dynamic.allocation]/1:
<span class="lineNum">   13358 </span>            : 
<span class="lineNum">   13359 </span>            :          A program is ill-formed if an allocation function is declared
<span class="lineNum">   13360 </span>            :          in a namespace scope other than global scope or declared
<span class="lineNum">   13361 </span>            :          static in global scope.
<span class="lineNum">   13362 </span>            : 
<span class="lineNum">   13363 </span>            :          The same also holds true for deallocation functions.  */
<span class="lineNum">   13364 </span><span class="lineCov">      37996 :       if (DECL_NAMESPACE_SCOPE_P (decl))</span>
<span class="lineNum">   13365 </span>            :         {
<span class="lineNum">   13366 </span><span class="lineCov">      73602 :           if (CP_DECL_CONTEXT (decl) != global_namespace)</span>
<span class="lineNum">   13367 </span>            :             {
<span class="lineNum">   13368 </span><span class="lineCov">          6 :               error_at (loc, &quot;%qD may not be declared within a namespace&quot;,</span>
<span class="lineNum">   13369 </span>            :                         decl);
<span class="lineNum">   13370 </span><span class="lineCov">          6 :               return false;</span>
<span class="lineNum">   13371 </span>            :             }
<span class="lineNum">   13372 </span>            : 
<span class="lineNum">   13373 </span><span class="lineCov">      36795 :           if (!TREE_PUBLIC (decl))</span>
<span class="lineNum">   13374 </span>            :             {
<span class="lineNum">   13375 </span><span class="lineCov">          6 :               error_at (loc, &quot;%qD may not be declared as static&quot;, decl);</span>
<span class="lineNum">   13376 </span><span class="lineCov">          6 :               return false;</span>
<span class="lineNum">   13377 </span>            :             }
<span class="lineNum">   13378 </span>            :         }
<span class="lineNum">   13379 </span>            : 
<span class="lineNum">   13380 </span><span class="lineCov">      37984 :       if (op_flags &amp; OVL_OP_FLAG_DELETE)</span>
<span class="lineNum">   13381 </span><span class="lineCov">      20378 :         TREE_TYPE (decl) = coerce_delete_type (TREE_TYPE (decl), loc);</span>
<span class="lineNum">   13382 </span>            :       else
<span class="lineNum">   13383 </span>            :         {
<span class="lineNum">   13384 </span><span class="lineCov">      17606 :           DECL_IS_OPERATOR_NEW (decl) = 1;</span>
<span class="lineNum">   13385 </span><span class="lineCov">      17606 :           TREE_TYPE (decl) = coerce_new_type (TREE_TYPE (decl), loc);</span>
<span class="lineNum">   13386 </span>            :         }
<span class="lineNum">   13387 </span>            : 
<span class="lineNum">   13388 </span><span class="lineCov">      37984 :       return true;</span>
<span class="lineNum">   13389 </span>            :     }
<span class="lineNum">   13390 </span>            : 
<span class="lineNum">   13391 </span>            :   /* An operator function must either be a non-static member function
<span class="lineNum">   13392 </span>            :      or have at least one parameter of a class, a reference to a class,
<span class="lineNum">   13393 </span>            :      an enumeration, or a reference to an enumeration.  13.4.0.6 */
<span class="lineNum">   13394 </span><span class="lineCov">    2651099 :   if (! methodp || DECL_STATIC_FUNCTION_P (decl))</span>
<span class="lineNum">   13395 </span>            :     {
<span class="lineNum">   13396 </span><span class="lineCov">    1147992 :       if (operator_code == TYPE_EXPR</span>
<span class="lineNum">   13397 </span><span class="lineCov">     573996 :           || operator_code == CALL_EXPR</span>
<span class="lineNum">   13398 </span><span class="lineCov">     573966 :           || operator_code == COMPONENT_REF</span>
<span class="lineNum">   13399 </span><span class="lineCov">     573966 :           || operator_code == ARRAY_REF</span>
<span class="lineNum">   13400 </span><span class="lineCov">     573957 :           || operator_code == NOP_EXPR)</span>
<span class="lineNum">   13401 </span>            :         {
<span class="lineNum">   13402 </span><span class="lineCov">         48 :           error_at (loc, &quot;%qD must be a nonstatic member function&quot;, decl);</span>
<span class="lineNum">   13403 </span><span class="lineCov">         48 :           return false;</span>
<span class="lineNum">   13404 </span>            :         }
<span class="lineNum">   13405 </span>            : 
<span class="lineNum">   13406 </span><span class="lineCov">     573948 :       if (DECL_STATIC_FUNCTION_P (decl))</span>
<span class="lineNum">   13407 </span>            :         {
<span class="lineNum">   13408 </span><span class="lineCov">          6 :           error_at (loc, &quot;%qD must be either a non-static member &quot;</span>
<span class="lineNum">   13409 </span>            :                     &quot;function or a non-member function&quot;, decl);
<span class="lineNum">   13410 </span><span class="lineCov">          6 :           return false;</span>
<span class="lineNum">   13411 </span>            :         }
<span class="lineNum">   13412 </span>            : 
<span class="lineNum">   13413 </span><span class="lineCov">      43951 :       for (tree arg = argtypes; ; arg = TREE_CHAIN (arg))</span>
<span class="lineNum">   13414 </span>            :         {
<span class="lineNum">   13415 </span><span class="lineCov">     617893 :           if (!arg || arg == void_list_node)</span>
<span class="lineNum">   13416 </span>            :             {
<span class="lineNum">   13417 </span><span class="lineCov">         18 :               if (complain)</span>
<span class="lineNum">   13418 </span><span class="lineCov">         15 :                 error_at(loc, &quot;%qD must have an argument of class or &quot;</span>
<span class="lineNum">   13419 </span>            :                          &quot;enumerated type&quot;, decl);
<span class="lineNum">   13420 </span><span class="lineCov">         18 :               return false;</span>
<span class="lineNum">   13421 </span>            :             }
<span class="lineNum">   13422 </span>            :       
<span class="lineNum">   13423 </span><span class="lineCov">     617875 :           tree type = non_reference (TREE_VALUE (arg));</span>
<span class="lineNum">   13424 </span><span class="lineCov">     617875 :           if (type == error_mark_node)</span>
<span class="lineNum">   13425 </span>            :             return false;
<span class="lineNum">   13426 </span>            :           
<span class="lineNum">   13427 </span>            :           /* MAYBE_CLASS_TYPE_P, rather than CLASS_TYPE_P, is used
<span class="lineNum">   13428 </span>            :              because these checks are performed even on template
<span class="lineNum">   13429 </span>            :              functions.  */
<span class="lineNum">   13430 </span><span class="lineCov">     588717 :           if (MAYBE_CLASS_TYPE_P (type)</span>
<span class="lineNum">   13431 </span><span class="lineCov">     688197 :               || TREE_CODE (type) == ENUMERAL_TYPE)</span>
<span class="lineNum">   13432 </span>            :             break;
<span class="lineNum">   13433 </span><span class="lineCov">      43951 :         }</span>
<span class="lineNum">   13434 </span>            :     }
<span class="lineNum">   13435 </span>            : 
<span class="lineNum">   13436 </span><span class="lineCov">    2651024 :   if (operator_code == CALL_EXPR)</span>
<span class="lineNum">   13437 </span>            :     /* There are no further restrictions on the arguments to an overloaded
<span class="lineNum">   13438 </span>            :        &quot;operator ()&quot;.  */
<span class="lineNum">   13439 </span>            :     return true;
<span class="lineNum">   13440 </span>            : 
<span class="lineNum">   13441 </span><span class="lineCov">    2304702 :   if (operator_code == COND_EXPR)</span>
<span class="lineNum">   13442 </span>            :     {
<span class="lineNum">   13443 </span>            :       /* 13.4.0.3 */
<span class="lineNum">   13444 </span><span class="lineNoCov">          0 :       error_at (loc, &quot;ISO C++ prohibits overloading operator ?:&quot;);</span>
<span class="lineNum">   13445 </span><span class="lineNoCov">          0 :       return false;</span>
<span class="lineNum">   13446 </span>            :     }
<span class="lineNum">   13447 </span>            : 
<span class="lineNum">   13448 </span>            :   /* Count the number of arguments and check for ellipsis.  */
<span class="lineNum">   13449 </span>            :   int arity = 0;
<span class="lineNum">   13450 </span><span class="lineCov">    6505884 :   for (tree arg = argtypes; arg != void_list_node; arg = TREE_CHAIN (arg))</span>
<span class="lineNum">   13451 </span>            :     {
<span class="lineNum">   13452 </span><span class="lineCov">    4201197 :       if (!arg)</span>
<span class="lineNum">   13453 </span>            :         {
<span class="lineNum">   13454 </span>            :           /* Variadic.  */
<span class="lineNum">   13455 </span><span class="lineCov">         15 :           error_at (loc, &quot;%qD must not have variable number of arguments&quot;,</span>
<span class="lineNum">   13456 </span>            :                     decl);
<span class="lineNum">   13457 </span><span class="lineCov">         15 :           return false;</span>
<span class="lineNum">   13458 </span>            :         }
<span class="lineNum">   13459 </span><span class="lineCov">    4201182 :       ++arity;</span>
<span class="lineNum">   13460 </span>            :     }
<span class="lineNum">   13461 </span>            : 
<span class="lineNum">   13462 </span>            :   /* Verify correct number of arguments.  */
<span class="lineNum">   13463 </span><span class="lineCov">    2304687 :   switch (op_flags)</span>
<span class="lineNum">   13464 </span>            :     {
<span class="lineNum">   13465 </span><span class="lineCov">     633285 :     case OVL_OP_FLAG_AMBIARY:</span>
<span class="lineNum">   13466 </span><span class="lineCov">     633285 :       if (arity == 1)</span>
<span class="lineNum">   13467 </span>            :         {
<span class="lineNum">   13468 </span>            :           /* We have a unary instance of an ambi-ary op.  Remap to the
<span class="lineNum">   13469 </span>            :              unary one.  */
<span class="lineNum">   13470 </span><span class="lineCov">     262955 :           unsigned alt = ovl_op_alternate[ovl_op_mapping [operator_code]];</span>
<span class="lineNum">   13471 </span><span class="lineCov">     262955 :           const ovl_op_info_t *ovl_op = &amp;ovl_op_info[false][alt];</span>
<span class="lineNum">   13472 </span><span class="lineCov">     262955 :           gcc_checking_assert (ovl_op-&gt;flags == OVL_OP_FLAG_UNARY);</span>
<span class="lineNum">   13473 </span><span class="lineCov">     262955 :           operator_code = ovl_op-&gt;tree_code;</span>
<span class="lineNum">   13474 </span><span class="lineCov">     262955 :           DECL_OVERLOADED_OPERATOR_CODE_RAW (decl) = ovl_op-&gt;ovl_op_code;</span>
<span class="lineNum">   13475 </span>            :         }
<span class="lineNum">   13476 </span><span class="lineCov">     370330 :       else if (arity != 2)</span>
<span class="lineNum">   13477 </span>            :         {
<span class="lineNum">   13478 </span>            :           /* This was an ambiguous operator but is invalid. */
<span class="lineNum">   13479 </span><span class="lineCov">          3 :           error_at (loc,</span>
<span class="lineNum">   13480 </span>            :                     methodp
<span class="lineNum">   13481 </span>            :                     ? G_(&quot;%qD must have either zero or one argument&quot;)
<span class="lineNum">   13482 </span>            :                     : G_(&quot;%qD must have either one or two arguments&quot;), decl);
<span class="lineNum">   13483 </span><span class="lineCov">          3 :           return false;</span>
<span class="lineNum">   13484 </span>            :         }
<span class="lineNum">   13485 </span><span class="lineCov">     370327 :       else if ((operator_code == POSTINCREMENT_EXPR</span>
<span class="lineNum">   13486 </span><span class="lineCov">     370327 :                 || operator_code == POSTDECREMENT_EXPR)</span>
<span class="lineNum">   13487 </span><span class="lineCov">     164276 :                &amp;&amp; ! processing_template_decl</span>
<span class="lineNum">   13488 </span>            :                /* x++ and x--'s second argument must be an int.  */
<span class="lineNum">   13489 </span><span class="lineCov">     499868 :                &amp;&amp; ! same_type_p (TREE_VALUE (TREE_CHAIN (argtypes)),</span>
<span class="lineNum">   13490 </span>            :                                  integer_type_node))
<span class="lineNum">   13491 </span>            :         {
<span class="lineNum">   13492 </span><span class="lineCov">         15 :           error_at (loc,</span>
<span class="lineNum">   13493 </span>            :                     methodp
<span class="lineNum">   13494 </span>            :                     ? G_(&quot;postfix %qD must have %&lt;int%&gt; as its argument&quot;)
<span class="lineNum">   13495 </span>            :                     : G_(&quot;postfix %qD must have %&lt;int%&gt; as its second argument&quot;),
<span class="lineNum">   13496 </span>            :                     decl);
<span class="lineNum">   13497 </span><span class="lineCov">         15 :           return false;</span>
<span class="lineNum">   13498 </span>            :         }
<span class="lineNum">   13499 </span>            :       break;
<span class="lineNum">   13500 </span>            : 
<span class="lineNum">   13501 </span><span class="lineCov">     145264 :     case OVL_OP_FLAG_UNARY:</span>
<span class="lineNum">   13502 </span><span class="lineCov">     145264 :       if (arity != 1)</span>
<span class="lineNum">   13503 </span>            :         {
<span class="lineNum">   13504 </span><span class="lineCov">          3 :           error_at (loc,</span>
<span class="lineNum">   13505 </span>            :                     methodp
<span class="lineNum">   13506 </span>            :                     ? G_(&quot;%qD must have no arguments&quot;)
<span class="lineNum">   13507 </span>            :                     : G_(&quot;%qD must have exactly one argument&quot;), decl);
<span class="lineNum">   13508 </span><span class="lineCov">          3 :           return false;</span>
<span class="lineNum">   13509 </span>            :         }
<span class="lineNum">   13510 </span>            :       break;
<span class="lineNum">   13511 </span>            : 
<span class="lineNum">   13512 </span><span class="lineCov">    1526138 :     case OVL_OP_FLAG_BINARY:</span>
<span class="lineNum">   13513 </span><span class="lineCov">    1526138 :       if (arity != 2)</span>
<span class="lineNum">   13514 </span>            :         {
<span class="lineNum">   13515 </span><span class="lineNoCov">          0 :           error_at (loc,</span>
<span class="lineNum">   13516 </span>            :                     methodp
<span class="lineNum">   13517 </span>            :                     ? G_(&quot;%qD must have exactly one argument&quot;)
<span class="lineNum">   13518 </span>            :                     : G_(&quot;%qD must have exactly two arguments&quot;), decl);
<span class="lineNum">   13519 </span><span class="lineNoCov">          0 :           return false;</span>
<span class="lineNum">   13520 </span>            :         }
<span class="lineNum">   13521 </span>            :       break;
<span class="lineNum">   13522 </span>            : 
<span class="lineNum">   13523 </span><span class="lineNoCov">          0 :     default:</span>
<span class="lineNum">   13524 </span><span class="lineNoCov">          0 :       gcc_unreachable ();</span>
<span class="lineNum">   13525 </span>            :     }
<span class="lineNum">   13526 </span>            : 
<span class="lineNum">   13527 </span>            :   /* There can be no default arguments.  */
<span class="lineNum">   13528 </span><span class="lineCov">    6505767 :   for (tree arg = argtypes; arg != void_list_node; arg = TREE_CHAIN (arg))</span>
<span class="lineNum">   13529 </span><span class="lineCov">    4201116 :     if (TREE_PURPOSE (arg))</span>
<span class="lineNum">   13530 </span>            :       {
<span class="lineNum">   13531 </span><span class="lineCov">         15 :         TREE_PURPOSE (arg) = NULL_TREE;</span>
<span class="lineNum">   13532 </span><span class="lineCov">         15 :         error_at (loc, &quot;%qD cannot have default arguments&quot;, decl);</span>
<span class="lineNum">   13533 </span><span class="lineCov">         15 :         return false;</span>
<span class="lineNum">   13534 </span>            :       }
<span class="lineNum">   13535 </span>            : 
<span class="lineNum">   13536 </span>            :   /* At this point the declaration is well-formed.  It may not be
<span class="lineNum">   13537 </span>            :      sensible though.  */
<span class="lineNum">   13538 </span>            : 
<span class="lineNum">   13539 </span>            :   /* Check member function warnings only on the in-class declaration.
<span class="lineNum">   13540 </span>            :      There's no point warning on an out-of-class definition.  */
<span class="lineNum">   13541 </span><span class="lineCov">    2304651 :   if (class_type &amp;&amp; class_type != current_class_type)</span>
<span class="lineNum">   13542 </span>            :     return true;
<span class="lineNum">   13543 </span>            : 
<span class="lineNum">   13544 </span>            :   /* Warn about conversion operators that will never be used.  */
<span class="lineNum">   13545 </span><span class="lineCov">    2281971 :   if (IDENTIFIER_CONV_OP_P (name)</span>
<span class="lineNum">   13546 </span><span class="lineCov">      64385 :       &amp;&amp; ! DECL_TEMPLATE_INFO (decl)</span>
<span class="lineNum">   13547 </span><span class="lineCov">    2307449 :       &amp;&amp; warn_class_conversion)</span>
<span class="lineNum">   13548 </span>            :     {
<span class="lineNum">   13549 </span><span class="lineCov">      25445 :       tree t = TREE_TYPE (name);</span>
<span class="lineNum">   13550 </span><span class="lineCov">      25445 :       int ref = TYPE_REF_P (t);</span>
<span class="lineNum">   13551 </span>            : 
<span class="lineNum">   13552 </span><span class="lineCov">      25445 :       if (ref)</span>
<span class="lineNum">   13553 </span><span class="lineCov">       1321 :         t = TYPE_MAIN_VARIANT (TREE_TYPE (t));</span>
<span class="lineNum">   13554 </span>            : 
<span class="lineNum">   13555 </span><span class="lineCov">      25445 :       if (VOID_TYPE_P (t))</span>
<span class="lineNum">   13556 </span><span class="lineCov">          9 :         warning_at (loc, OPT_Wclass_conversion, &quot;converting %qT to %&lt;void%&gt; &quot;</span>
<span class="lineNum">   13557 </span>            :                     &quot;will never use a type conversion operator&quot;, class_type);
<span class="lineNum">   13558 </span><span class="lineCov">      25436 :       else if (class_type)</span>
<span class="lineNum">   13559 </span>            :         {
<span class="lineNum">   13560 </span><span class="lineCov">      25436 :           if (same_type_ignoring_top_level_qualifiers_p (t, class_type))</span>
<span class="lineNum">   13561 </span><span class="lineCov">         24 :             warning_at (loc, OPT_Wclass_conversion,</span>
<span class="lineNum">   13562 </span>            :                         ref
<span class="lineNum">   13563 </span>            :                         ? G_(&quot;converting %qT to a reference to the same type &quot;
<span class="lineNum">   13564 </span>            :                              &quot;will never use a type conversion operator&quot;)
<span class="lineNum">   13565 </span>            :                         : G_(&quot;converting %qT to the same type &quot;
<span class="lineNum">   13566 </span>            :                              &quot;will never use a type conversion operator&quot;),
<span class="lineNum">   13567 </span>            :                         class_type);
<span class="lineNum">   13568 </span>            :           /* Don't force t to be complete here.  */
<span class="lineNum">   13569 </span><span class="lineCov">      19014 :           else if (MAYBE_CLASS_TYPE_P (t)</span>
<span class="lineNum">   13570 </span><span class="lineCov">       9751 :                    &amp;&amp; COMPLETE_TYPE_P (t)</span>
<span class="lineNum">   13571 </span><span class="lineCov">      27324 :                    &amp;&amp; DERIVED_FROM_P (t, class_type))</span>
<span class="lineNum">   13572 </span><span class="lineCov">         30 :             warning_at (loc, OPT_Wclass_conversion,</span>
<span class="lineNum">   13573 </span>            :                         ref
<span class="lineNum">   13574 </span>            :                         ? G_(&quot;converting %qT to a reference to a base class &quot;
<span class="lineNum">   13575 </span>            :                              &quot;%qT will never use a type conversion operator&quot;)
<span class="lineNum">   13576 </span>            :                         : G_(&quot;converting %qT to a base class %qT &quot;
<span class="lineNum">   13577 </span>            :                              &quot;will never use a type conversion operator&quot;),
<span class="lineNum">   13578 </span>            :                         class_type, t);
<span class="lineNum">   13579 </span>            :         }
<span class="lineNum">   13580 </span>            :     }
<span class="lineNum">   13581 </span>            : 
<span class="lineNum">   13582 </span><span class="lineCov">    2281971 :   if (!warn_ecpp)</span>
<span class="lineNum">   13583 </span>            :     return true;
<span class="lineNum">   13584 </span>            : 
<span class="lineNum">   13585 </span>            :   /* Effective C++ rules below.  */
<span class="lineNum">   13586 </span>            : 
<span class="lineNum">   13587 </span>            :   /* More Effective C++ rule 7.  */
<span class="lineNum">   13588 </span><span class="lineCov">         84 :   if (operator_code == TRUTH_ANDIF_EXPR</span>
<span class="lineNum">   13589 </span><span class="lineCov">         42 :       || operator_code == TRUTH_ORIF_EXPR</span>
<span class="lineNum">   13590 </span><span class="lineCov">         42 :       || operator_code == COMPOUND_EXPR)</span>
<span class="lineNum">   13591 </span><span class="lineNoCov">          0 :     warning_at (loc, OPT_Weffc__,</span>
<span class="lineNum">   13592 </span>            :                 &quot;user-defined %qD always evaluates both arguments&quot;, decl);
<span class="lineNum">   13593 </span>            :   
<span class="lineNum">   13594 </span>            :   /* More Effective C++ rule 6.  */
<span class="lineNum">   13595 </span><span class="lineCov">         84 :   if (operator_code == POSTINCREMENT_EXPR</span>
<span class="lineNum">   13596 </span>            :       || operator_code == POSTDECREMENT_EXPR
<span class="lineNum">   13597 </span>            :       || operator_code == PREINCREMENT_EXPR
<span class="lineNum">   13598 </span><span class="lineCov">         42 :       || operator_code == PREDECREMENT_EXPR)</span>
<span class="lineNum">   13599 </span>            :     {
<span class="lineNum">   13600 </span><span class="lineNoCov">          0 :       tree arg = TREE_VALUE (argtypes);</span>
<span class="lineNum">   13601 </span><span class="lineNoCov">          0 :       tree ret = TREE_TYPE (TREE_TYPE (decl));</span>
<span class="lineNum">   13602 </span><span class="lineNoCov">          0 :       if (methodp || TYPE_REF_P (arg))</span>
<span class="lineNum">   13603 </span><span class="lineNoCov">          0 :         arg = TREE_TYPE (arg);</span>
<span class="lineNum">   13604 </span><span class="lineNoCov">          0 :       arg = TYPE_MAIN_VARIANT (arg);</span>
<span class="lineNum">   13605 </span>            : 
<span class="lineNum">   13606 </span><span class="lineNoCov">          0 :       if (operator_code == PREINCREMENT_EXPR</span>
<span class="lineNum">   13607 </span>            :           || operator_code == PREDECREMENT_EXPR)
<span class="lineNum">   13608 </span>            :         {
<span class="lineNum">   13609 </span><span class="lineNoCov">          0 :           if (!TYPE_REF_P (ret)</span>
<span class="lineNum">   13610 </span><span class="lineNoCov">          0 :               || !same_type_p (TYPE_MAIN_VARIANT (TREE_TYPE (ret)), arg))</span>
<span class="lineNum">   13611 </span><span class="lineNoCov">          0 :             warning_at (loc, OPT_Weffc__, &quot;prefix %qD should return %qT&quot;, decl,</span>
<span class="lineNum">   13612 </span>            :                         build_reference_type (arg));
<span class="lineNum">   13613 </span>            :         }
<span class="lineNum">   13614 </span>            :       else
<span class="lineNum">   13615 </span>            :         {
<span class="lineNum">   13616 </span><span class="lineNoCov">          0 :           if (!same_type_p (TYPE_MAIN_VARIANT (ret), arg))</span>
<span class="lineNum">   13617 </span><span class="lineNoCov">          0 :             warning_at (loc, OPT_Weffc__,</span>
<span class="lineNum">   13618 </span>            :                         &quot;postfix %qD should return %qT&quot;, decl, arg);
<span class="lineNum">   13619 </span>            :         }
<span class="lineNum">   13620 </span>            :     }
<span class="lineNum">   13621 </span>            : 
<span class="lineNum">   13622 </span>            :   /* Effective C++ rule 23.  */
<span class="lineNum">   13623 </span><span class="lineCov">         42 :   if (!DECL_ASSIGNMENT_OPERATOR_P (decl)</span>
<span class="lineNum">   13624 </span><span class="lineCov">          9 :       &amp;&amp; (operator_code == PLUS_EXPR</span>
<span class="lineNum">   13625 </span><span class="lineCov">          9 :           || operator_code == MINUS_EXPR</span>
<span class="lineNum">   13626 </span><span class="lineCov">          9 :           || operator_code == TRUNC_DIV_EXPR</span>
<span class="lineNum">   13627 </span><span class="lineCov">          3 :           || operator_code == MULT_EXPR</span>
<span class="lineNum">   13628 </span><span class="lineCov">          3 :           || operator_code == TRUNC_MOD_EXPR)</span>
<span class="lineNum">   13629 </span><span class="lineCov">         48 :       &amp;&amp; TYPE_REF_P (TREE_TYPE (TREE_TYPE (decl))))</span>
<span class="lineNum">   13630 </span><span class="lineCov">          3 :     warning_at (loc, OPT_Weffc__, &quot;%qD should return by value&quot;, decl);</span>
<span class="lineNum">   13631 </span>            : 
<span class="lineNum">   13632 </span>            :   return true;
<span class="lineNum">   13633 </span>            : }
<span class="lineNum">   13634 </span>            : 
<span class="lineNum">   13635 </span>            : /* Return a string giving the keyword associate with CODE.  */
<a name="13636"><span class="lineNum">   13636 </span>            : </a>
<span class="lineNum">   13637 </span>            : static const char *
<span class="lineNum">   13638 </span><span class="lineCov">        103 : tag_name (enum tag_types code)</span>
<span class="lineNum">   13639 </span>            : {
<span class="lineNum">   13640 </span><span class="lineCov">        103 :   switch (code)</span>
<span class="lineNum">   13641 </span>            :     {
<span class="lineNum">   13642 </span>            :     case record_type:
<span class="lineNum">   13643 </span>            :       return &quot;struct&quot;;
<span class="lineNum">   13644 </span><span class="lineCov">         55 :     case class_type:</span>
<span class="lineNum">   13645 </span><span class="lineCov">         55 :       return &quot;class&quot;;</span>
<span class="lineNum">   13646 </span><span class="lineNoCov">          0 :     case union_type:</span>
<span class="lineNum">   13647 </span><span class="lineNoCov">          0 :       return &quot;union&quot;;</span>
<span class="lineNum">   13648 </span><span class="lineCov">          3 :     case enum_type:</span>
<span class="lineNum">   13649 </span><span class="lineCov">          3 :       return &quot;enum&quot;;</span>
<span class="lineNum">   13650 </span><span class="lineNoCov">          0 :     case typename_type:</span>
<span class="lineNum">   13651 </span><span class="lineNoCov">          0 :       return &quot;typename&quot;;</span>
<span class="lineNum">   13652 </span><span class="lineNoCov">          0 :     default:</span>
<span class="lineNum">   13653 </span><span class="lineNoCov">          0 :       gcc_unreachable ();</span>
<span class="lineNum">   13654 </span>            :     }
<span class="lineNum">   13655 </span>            : }
<span class="lineNum">   13656 </span>            : 
<span class="lineNum">   13657 </span>            : /* Name lookup in an elaborated-type-specifier (after the keyword
<span class="lineNum">   13658 </span>            :    indicated by TAG_CODE) has found the TYPE_DECL DECL.  If the
<span class="lineNum">   13659 </span>            :    elaborated-type-specifier is invalid, issue a diagnostic and return
<span class="lineNum">   13660 </span>            :    error_mark_node; otherwise, return the *_TYPE to which it referred.
<span class="lineNum">   13661 </span>            :    If ALLOW_TEMPLATE_P is true, TYPE may be a class template.  */
<a name="13662"><span class="lineNum">   13662 </span>            : </a>
<span class="lineNum">   13663 </span>            : tree
<span class="lineNum">   13664 </span><span class="lineCov">     711462 : check_elaborated_type_specifier (enum tag_types tag_code,</span>
<span class="lineNum">   13665 </span>            :                                  tree decl,
<span class="lineNum">   13666 </span>            :                                  bool allow_template_p)
<span class="lineNum">   13667 </span>            : {
<span class="lineNum">   13668 </span><span class="lineCov">     711462 :   tree type;</span>
<span class="lineNum">   13669 </span>            : 
<span class="lineNum">   13670 </span>            :   /* In the case of:
<span class="lineNum">   13671 </span>            : 
<span class="lineNum">   13672 </span>            :        struct S { struct S *p; };
<span class="lineNum">   13673 </span>            : 
<span class="lineNum">   13674 </span>            :      name lookup will find the TYPE_DECL for the implicit &quot;S::S&quot;
<span class="lineNum">   13675 </span>            :      typedef.  Adjust for that here.  */
<span class="lineNum">   13676 </span><span class="lineCov">     711462 :   if (DECL_SELF_REFERENCE_P (decl))</span>
<span class="lineNum">   13677 </span><span class="lineCov">      20203 :     decl = TYPE_NAME (TREE_TYPE (decl));</span>
<span class="lineNum">   13678 </span>            : 
<span class="lineNum">   13679 </span><span class="lineCov">     711462 :   type = TREE_TYPE (decl);</span>
<span class="lineNum">   13680 </span>            : 
<span class="lineNum">   13681 </span>            :   /* Check TEMPLATE_TYPE_PARM first because DECL_IMPLICIT_TYPEDEF_P
<span class="lineNum">   13682 </span>            :      is false for this case as well.  */
<span class="lineNum">   13683 </span><span class="lineCov">     711462 :   if (TREE_CODE (type) == TEMPLATE_TYPE_PARM)</span>
<span class="lineNum">   13684 </span>            :     {
<span class="lineNum">   13685 </span><span class="lineCov">          9 :       error (&quot;using template type parameter %qT after %qs&quot;,</span>
<span class="lineNum">   13686 </span>            :              type, tag_name (tag_code));
<span class="lineNum">   13687 </span><span class="lineCov">          9 :       return error_mark_node;</span>
<span class="lineNum">   13688 </span>            :     }
<span class="lineNum">   13689 </span>            :   /* Accept template template parameters.  */
<span class="lineNum">   13690 </span><span class="lineCov">     711453 :   else if (allow_template_p</span>
<span class="lineNum">   13691 </span><span class="lineCov">     230880 :            &amp;&amp; (TREE_CODE (type) == BOUND_TEMPLATE_TEMPLATE_PARM</span>
<span class="lineNum">   13692 </span><span class="lineCov">     230871 :                || TREE_CODE (type) == TEMPLATE_TEMPLATE_PARM))</span>
<span class="lineNum">   13693 </span>            :     ;
<span class="lineNum">   13694 </span>            :   /*   [dcl.type.elab]
<span class="lineNum">   13695 </span>            : 
<span class="lineNum">   13696 </span>            :        If the identifier resolves to a typedef-name or the
<span class="lineNum">   13697 </span>            :        simple-template-id resolves to an alias template
<span class="lineNum">   13698 </span>            :        specialization, the elaborated-type-specifier is ill-formed.
<span class="lineNum">   13699 </span>            : 
<span class="lineNum">   13700 </span>            :      In other words, the only legitimate declaration to use in the
<span class="lineNum">   13701 </span>            :      elaborated type specifier is the implicit typedef created when
<span class="lineNum">   13702 </span>            :      the type is declared.  */
<span class="lineNum">   13703 </span><span class="lineCov">     711442 :   else if (!DECL_IMPLICIT_TYPEDEF_P (decl)</span>
<span class="lineNum">   13704 </span><span class="lineCov">      20393 :            &amp;&amp; !DECL_SELF_REFERENCE_P (decl)</span>
<span class="lineNum">   13705 </span><span class="lineCov">     711632 :            &amp;&amp; tag_code != typename_type)</span>
<span class="lineNum">   13706 </span>            :     {
<span class="lineNum">   13707 </span><span class="lineCov">         67 :       if (alias_template_specialization_p (type))</span>
<span class="lineNum">   13708 </span><span class="lineCov">         14 :         error (&quot;using alias template specialization %qT after %qs&quot;,</span>
<span class="lineNum">   13709 </span>            :                type, tag_name (tag_code));
<span class="lineNum">   13710 </span>            :       else
<span class="lineNum">   13711 </span><span class="lineCov">         53 :         error (&quot;using typedef-name %qD after %qs&quot;, decl, tag_name (tag_code));</span>
<span class="lineNum">   13712 </span><span class="lineCov">         67 :       inform (DECL_SOURCE_LOCATION (decl),</span>
<span class="lineNum">   13713 </span>            :               &quot;%qD has a previous declaration here&quot;, decl);
<span class="lineNum">   13714 </span><span class="lineCov">         67 :       return error_mark_node;</span>
<span class="lineNum">   13715 </span>            :     }
<span class="lineNum">   13716 </span><span class="lineCov">    1422750 :   else if (TREE_CODE (type) != RECORD_TYPE</span>
<span class="lineNum">   13717 </span><span class="lineCov">     711375 :            &amp;&amp; TREE_CODE (type) != UNION_TYPE</span>
<span class="lineNum">   13718 </span>            :            &amp;&amp; tag_code != enum_type
<span class="lineNum">   13719 </span><span class="lineCov">      14976 :            &amp;&amp; tag_code != typename_type)</span>
<span class="lineNum">   13720 </span>            :     {
<span class="lineNum">   13721 </span><span class="lineCov">          6 :       error (&quot;%qT referred to as %qs&quot;, type, tag_name (tag_code));</span>
<span class="lineNum">   13722 </span><span class="lineCov">          6 :       inform (location_of (type), &quot;%qT has a previous declaration here&quot;, type);</span>
<span class="lineNum">   13723 </span><span class="lineCov">          6 :       return error_mark_node;</span>
<span class="lineNum">   13724 </span>            :     }
<span class="lineNum">   13725 </span><span class="lineCov">     711369 :   else if (TREE_CODE (type) != ENUMERAL_TYPE</span>
<span class="lineNum">   13726 </span><span class="lineCov">     696522 :            &amp;&amp; tag_code == enum_type)</span>
<span class="lineNum">   13727 </span>            :     {
<span class="lineNum">   13728 </span><span class="lineCov">          3 :       error (&quot;%qT referred to as enum&quot;, type);</span>
<span class="lineNum">   13729 </span><span class="lineCov">          3 :       inform (location_of (type), &quot;%qT has a previous declaration here&quot;, type);</span>
<span class="lineNum">   13730 </span><span class="lineCov">          3 :       return error_mark_node;</span>
<span class="lineNum">   13731 </span>            :     }
<span class="lineNum">   13732 </span><span class="lineCov">     711366 :   else if (!allow_template_p</span>
<span class="lineNum">   13733 </span><span class="lineCov">     480517 :            &amp;&amp; TREE_CODE (type) == RECORD_TYPE</span>
<span class="lineNum">   13734 </span><span class="lineCov">    1619674 :            &amp;&amp; CLASSTYPE_IS_TEMPLATE (type))</span>
<span class="lineNum">   13735 </span>            :     {
<span class="lineNum">   13736 </span>            :       /* If a class template appears as elaborated type specifier
<span class="lineNum">   13737 </span>            :          without a template header such as:
<span class="lineNum">   13738 </span>            : 
<span class="lineNum">   13739 </span>            :            template &lt;class T&gt; class C {};
<span class="lineNum">   13740 </span>            :            void f(class C);             // No template header here
<span class="lineNum">   13741 </span>            : 
<span class="lineNum">   13742 </span>            :          then the required template argument is missing.  */
<span class="lineNum">   13743 </span><span class="lineCov">         21 :       error (&quot;template argument required for %&lt;%s %T%&gt;&quot;,</span>
<span class="lineNum">   13744 </span>            :              tag_name (tag_code),
<span class="lineNum">   13745 </span><span class="lineCov">        105 :              DECL_NAME (CLASSTYPE_TI_TEMPLATE (type)));</span>
<span class="lineNum">   13746 </span><span class="lineCov">         21 :       return error_mark_node;</span>
<span class="lineNum">   13747 </span>            :     }
<span class="lineNum">   13748 </span>            : 
<span class="lineNum">   13749 </span>            :   return type;
<span class="lineNum">   13750 </span>            : }
<span class="lineNum">   13751 </span>            : 
<span class="lineNum">   13752 </span>            : /* Lookup NAME in elaborate type specifier in scope according to
<span class="lineNum">   13753 </span>            :    SCOPE and issue diagnostics if necessary.
<span class="lineNum">   13754 </span>            :    Return *_TYPE node upon success, NULL_TREE when the NAME is not
<span class="lineNum">   13755 </span>            :    found, and ERROR_MARK_NODE for type error.  */
<a name="13756"><span class="lineNum">   13756 </span>            : </a>
<span class="lineNum">   13757 </span>            : static tree
<span class="lineNum">   13758 </span><span class="lineCov">    2463815 : lookup_and_check_tag (enum tag_types tag_code, tree name,</span>
<span class="lineNum">   13759 </span>            :                       tag_scope scope, bool template_header_p)
<span class="lineNum">   13760 </span>            : {
<span class="lineNum">   13761 </span><span class="lineCov">    2463815 :   tree t;</span>
<span class="lineNum">   13762 </span><span class="lineCov">    2463815 :   tree decl;</span>
<span class="lineNum">   13763 </span><span class="lineCov">    2463815 :   if (scope == ts_global)</span>
<span class="lineNum">   13764 </span>            :     {
<span class="lineNum">   13765 </span>            :       /* First try ordinary name lookup, ignoring hidden class name
<span class="lineNum">   13766 </span>            :          injected via friend declaration.  */
<span class="lineNum">   13767 </span><span class="lineCov">     445735 :       decl = lookup_name_prefer_type (name, 2);</span>
<span class="lineNum">   13768 </span><span class="lineCov">     445735 :       decl = strip_using_decl (decl);</span>
<span class="lineNum">   13769 </span>            :       /* If that fails, the name will be placed in the smallest
<span class="lineNum">   13770 </span>            :          non-class, non-function-prototype scope according to 3.3.1/5.
<span class="lineNum">   13771 </span>            :          We may already have a hidden name declared as friend in this
<span class="lineNum">   13772 </span>            :          scope.  So lookup again but not ignoring hidden names.
<span class="lineNum">   13773 </span>            :          If we find one, that name will be made visible rather than
<span class="lineNum">   13774 </span>            :          creating a new tag.  */
<span class="lineNum">   13775 </span><span class="lineCov">     445735 :       if (!decl)</span>
<span class="lineNum">   13776 </span><span class="lineCov">       4239 :         decl = lookup_type_scope (name, ts_within_enclosing_non_class);</span>
<span class="lineNum">   13777 </span>            :     }
<span class="lineNum">   13778 </span>            :   else
<span class="lineNum">   13779 </span><span class="lineCov">    2018080 :     decl = lookup_type_scope (name, scope);</span>
<span class="lineNum">   13780 </span>            : 
<span class="lineNum">   13781 </span><span class="lineCov">    2463815 :   if (decl</span>
<span class="lineNum">   13782 </span><span class="lineCov">    2463815 :       &amp;&amp; (DECL_CLASS_TEMPLATE_P (decl)</span>
<span class="lineNum">   13783 </span>            :           /* If scope is ts_current we're defining a class, so ignore a
<span class="lineNum">   13784 </span>            :              template template parameter.  */
<span class="lineNum">   13785 </span><span class="lineCov">     496004 :           || (scope != ts_current</span>
<span class="lineNum">   13786 </span><span class="lineCov">     454725 :               &amp;&amp; DECL_TEMPLATE_TEMPLATE_PARM_P (decl))))</span>
<span class="lineNum">   13787 </span><span class="lineCov">     115383 :     decl = DECL_TEMPLATE_RESULT (decl);</span>
<span class="lineNum">   13788 </span>            : 
<span class="lineNum">   13789 </span><span class="lineCov">    2463815 :   if (decl &amp;&amp; TREE_CODE (decl) == TYPE_DECL)</span>
<span class="lineNum">   13790 </span>            :     {
<span class="lineNum">   13791 </span>            :       /* Look for invalid nested type:
<span class="lineNum">   13792 </span>            :            class C {
<span class="lineNum">   13793 </span>            :              class C {};
<span class="lineNum">   13794 </span>            :            };  */
<span class="lineNum">   13795 </span><span class="lineCov">     611366 :       if (scope == ts_current &amp;&amp; DECL_SELF_REFERENCE_P (decl))</span>
<span class="lineNum">   13796 </span>            :         {
<span class="lineNum">   13797 </span><span class="lineCov">          6 :           error (&quot;%qD has the same name as the class in which it is &quot;</span>
<span class="lineNum">   13798 </span>            :                  &quot;declared&quot;,
<span class="lineNum">   13799 </span>            :                  decl);
<span class="lineNum">   13800 </span><span class="lineCov">          6 :           return error_mark_node;</span>
<span class="lineNum">   13801 </span>            :         }
<span class="lineNum">   13802 </span>            : 
<span class="lineNum">   13803 </span>            :       /* Two cases we need to consider when deciding if a class
<span class="lineNum">   13804 </span>            :          template is allowed as an elaborated type specifier:
<span class="lineNum">   13805 </span>            :          1. It is a self reference to its own class.
<span class="lineNum">   13806 </span>            :          2. It comes with a template header.
<span class="lineNum">   13807 </span>            : 
<span class="lineNum">   13808 </span>            :          For example:
<span class="lineNum">   13809 </span>            : 
<span class="lineNum">   13810 </span>            :            template &lt;class T&gt; class C {
<span class="lineNum">   13811 </span>            :              class C *c1;               // DECL_SELF_REFERENCE_P is true
<span class="lineNum">   13812 </span>            :              class D;
<span class="lineNum">   13813 </span>            :            };
<span class="lineNum">   13814 </span>            :            template &lt;class U&gt; class C; // template_header_p is true
<span class="lineNum">   13815 </span>            :            template &lt;class T&gt; class C&lt;T&gt;::D {
<span class="lineNum">   13816 </span>            :              class C *c2;               // DECL_SELF_REFERENCE_P is true
<span class="lineNum">   13817 </span>            :            };  */
<span class="lineNum">   13818 </span>            : 
<span class="lineNum">   13819 </span><span class="lineCov">    1834080 :       t = check_elaborated_type_specifier (tag_code,</span>
<span class="lineNum">   13820 </span>            :                                            decl,
<span class="lineNum">   13821 </span>            :                                            template_header_p
<span class="lineNum">   13822 </span><span class="lineCov">    1202532 :                                            | DECL_SELF_REFERENCE_P (decl));</span>
<span class="lineNum">   13823 </span><span class="lineCov">     118228 :       if (template_header_p &amp;&amp; t &amp;&amp; CLASS_TYPE_P (t)</span>
<span class="lineNum">   13824 </span><span class="lineCov">     966011 :           &amp;&amp; (!CLASSTYPE_TEMPLATE_INFO (t)</span>
<span class="lineNum">   13825 </span><span class="lineCov">     354597 :               || (!PRIMARY_TEMPLATE_P (CLASSTYPE_TI_TEMPLATE (t)))))</span>
<span class="lineNum">   13826 </span>            :         {
<span class="lineNum">   13827 </span><span class="lineCov">         21 :           error (&quot;%qT is not a template&quot;, t);</span>
<span class="lineNum">   13828 </span><span class="lineCov">         21 :           inform (location_of (t), &quot;previous declaration here&quot;);</span>
<span class="lineNum">   13829 </span><span class="lineCov">         63 :           if (TYPE_CLASS_SCOPE_P (t)</span>
<span class="lineNum">   13830 </span><span class="lineCov">         27 :               &amp;&amp; CLASSTYPE_TEMPLATE_INFO (TYPE_CONTEXT (t)))</span>
<span class="lineNum">   13831 </span><span class="lineCov">          6 :             inform (input_location,</span>
<span class="lineNum">   13832 </span>            :                     &quot;perhaps you want to explicitly add %&lt;%T::%&gt;&quot;,
<span class="lineNum">   13833 </span><span class="lineCov">          6 :                     TYPE_CONTEXT (t));</span>
<span class="lineNum">   13834 </span><span class="lineCov">         21 :           t = error_mark_node;</span>
<span class="lineNum">   13835 </span>            :         }
<span class="lineNum">   13836 </span>            : 
<span class="lineNum">   13837 </span><span class="lineCov">     611360 :       return t;</span>
<span class="lineNum">   13838 </span>            :     }
<span class="lineNum">   13839 </span><span class="lineCov">    1852449 :   else if (decl &amp;&amp; TREE_CODE (decl) == TREE_LIST)</span>
<span class="lineNum">   13840 </span>            :     {
<span class="lineNum">   13841 </span><span class="lineCov">          3 :       error (&quot;reference to %qD is ambiguous&quot;, name);</span>
<span class="lineNum">   13842 </span><span class="lineCov">          3 :       print_candidates (decl);</span>
<span class="lineNum">   13843 </span><span class="lineCov">          3 :       return error_mark_node;</span>
<span class="lineNum">   13844 </span>            :     }
<span class="lineNum">   13845 </span>            :   else
<span class="lineNum">   13846 </span>            :     return NULL_TREE;
<span class="lineNum">   13847 </span>            : }
<span class="lineNum">   13848 </span>            : 
<span class="lineNum">   13849 </span>            : /* Get the struct, enum or union (TAG_CODE says which) with tag NAME.
<span class="lineNum">   13850 </span>            :    Define the tag as a forward-reference if it is not defined.
<span class="lineNum">   13851 </span>            : 
<span class="lineNum">   13852 </span>            :    If a declaration is given, process it here, and report an error if
<span class="lineNum">   13853 </span>            :    multiple declarations are not identical.
<span class="lineNum">   13854 </span>            : 
<span class="lineNum">   13855 </span>            :    SCOPE is TS_CURRENT when this is also a definition.  Only look in
<span class="lineNum">   13856 </span>            :    the current frame for the name (since C++ allows new names in any
<span class="lineNum">   13857 </span>            :    scope.)  It is TS_WITHIN_ENCLOSING_NON_CLASS if this is a friend
<span class="lineNum">   13858 </span>            :    declaration.  Only look beginning from the current scope outward up
<span class="lineNum">   13859 </span>            :    till the nearest non-class scope.  Otherwise it is TS_GLOBAL.
<span class="lineNum">   13860 </span>            : 
<span class="lineNum">   13861 </span>            :    TEMPLATE_HEADER_P is true when this declaration is preceded by
<span class="lineNum">   13862 </span>            :    a set of template parameters.  */
<a name="13863"><span class="lineNum">   13863 </span>            : </a>
<span class="lineNum">   13864 </span>            : static tree
<span class="lineNum">   13865 </span><span class="lineCov">    2334066 : xref_tag_1 (enum tag_types tag_code, tree name,</span>
<span class="lineNum">   13866 </span>            :             tag_scope scope, bool template_header_p)
<span class="lineNum">   13867 </span>            : {
<span class="lineNum">   13868 </span><span class="lineCov">    2334066 :   enum tree_code code;</span>
<span class="lineNum">   13869 </span><span class="lineCov">    2334066 :   tree context = NULL_TREE;</span>
<span class="lineNum">   13870 </span>            : 
<span class="lineNum">   13871 </span><span class="lineCov">    2334066 :   gcc_assert (identifier_p (name));</span>
<span class="lineNum">   13872 </span>            : 
<span class="lineNum">   13873 </span><span class="lineCov">    2334066 :   switch (tag_code)</span>
<span class="lineNum">   13874 </span>            :     {
<span class="lineNum">   13875 </span>            :     case record_type:
<span class="lineNum">   13876 </span>            :     case class_type:
<span class="lineNum">   13877 </span>            :       code = RECORD_TYPE;
<span class="lineNum">   13878 </span>            :       break;
<span class="lineNum">   13879 </span>            :     case union_type:
<span class="lineNum">   13880 </span>            :       code = UNION_TYPE;
<span class="lineNum">   13881 </span>            :       break;
<span class="lineNum">   13882 </span>            :     case enum_type:
<span class="lineNum">   13883 </span>            :       code = ENUMERAL_TYPE;
<span class="lineNum">   13884 </span>            :       break;
<span class="lineNum">   13885 </span><span class="lineNoCov">          0 :     default:</span>
<span class="lineNum">   13886 </span><span class="lineNoCov">          0 :       gcc_unreachable ();</span>
<span class="lineNum">   13887 </span>            :     }
<span class="lineNum">   13888 </span>            : 
<span class="lineNum">   13889 </span>            :   /* In case of anonymous name, xref_tag is only called to
<span class="lineNum">   13890 </span>            :      make type node and push name.  Name lookup is not required.  */
<span class="lineNum">   13891 </span><span class="lineCov">    2334066 :   tree t = NULL_TREE;</span>
<span class="lineNum">   13892 </span><span class="lineCov">    2334066 :   if (scope != ts_lambda &amp;&amp; !anon_aggrname_p (name))</span>
<span class="lineNum">   13893 </span><span class="lineCov">    2203031 :     t = lookup_and_check_tag  (tag_code, name, scope, template_header_p);</span>
<span class="lineNum">   13894 </span>            :   
<span class="lineNum">   13895 </span><span class="lineCov">    2334066 :   if (t == error_mark_node)</span>
<span class="lineNum">   13896 </span>            :     return error_mark_node;
<span class="lineNum">   13897 </span>            : 
<span class="lineNum">   13898 </span><span class="lineCov">     500756 :   if (scope != ts_current &amp;&amp; t &amp;&amp; current_class_type</span>
<span class="lineNum">   13899 </span><span class="lineCov">      87083 :       &amp;&amp; template_class_depth (current_class_type)</span>
<span class="lineNum">   13900 </span><span class="lineCov">    2344233 :       &amp;&amp; template_header_p)</span>
<span class="lineNum">   13901 </span>            :     {
<span class="lineNum">   13902 </span><span class="lineCov">       6980 :       if (TREE_CODE (t) == TEMPLATE_TEMPLATE_PARM)</span>
<span class="lineNum">   13903 </span>            :         return t;
<span class="lineNum">   13904 </span>            : 
<span class="lineNum">   13905 </span>            :       /* Since SCOPE is not TS_CURRENT, we are not looking at a
<span class="lineNum">   13906 </span>            :          definition of this tag.  Since, in addition, we are currently
<span class="lineNum">   13907 </span>            :          processing a (member) template declaration of a template
<span class="lineNum">   13908 </span>            :          class, we must be very careful; consider:
<span class="lineNum">   13909 </span>            : 
<span class="lineNum">   13910 </span>            :            template &lt;class X&gt; struct S1
<span class="lineNum">   13911 </span>            : 
<span class="lineNum">   13912 </span>            :            template &lt;class U&gt; struct S2
<span class="lineNum">   13913 </span>            :            {
<span class="lineNum">   13914 </span>            :              template &lt;class V&gt; friend struct S1;
<span class="lineNum">   13915 </span>            :            };
<span class="lineNum">   13916 </span>            : 
<span class="lineNum">   13917 </span>            :          Here, the S2::S1 declaration should not be confused with the
<span class="lineNum">   13918 </span>            :          outer declaration.  In particular, the inner version should
<span class="lineNum">   13919 </span>            :          have a template parameter of level 2, not level 1.
<span class="lineNum">   13920 </span>            : 
<span class="lineNum">   13921 </span>            :          On the other hand, when presented with:
<span class="lineNum">   13922 </span>            : 
<span class="lineNum">   13923 </span>            :            template &lt;class T&gt; struct S1
<span class="lineNum">   13924 </span>            :            {
<span class="lineNum">   13925 </span>            :              template &lt;class U&gt; struct S2 {};
<span class="lineNum">   13926 </span>            :              template &lt;class U&gt; friend struct S2;
<span class="lineNum">   13927 </span>            :            };
<span class="lineNum">   13928 </span>            : 
<span class="lineNum">   13929 </span>            :          the friend must find S1::S2 eventually.  We accomplish this
<span class="lineNum">   13930 </span>            :          by making sure that the new type we create to represent this
<span class="lineNum">   13931 </span>            :          declaration has the right TYPE_CONTEXT.  */
<span class="lineNum">   13932 </span><span class="lineCov">       6978 :       context = TYPE_CONTEXT (t);</span>
<span class="lineNum">   13933 </span><span class="lineCov">       6978 :       t = NULL_TREE;</span>
<span class="lineNum">   13934 </span>            :     }
<span class="lineNum">   13935 </span>            : 
<span class="lineNum">   13936 </span><span class="lineCov">    2333965 :   if (! t)</span>
<span class="lineNum">   13937 </span>            :     {
<span class="lineNum">   13938 </span>            :       /* If no such tag is yet defined, create a forward-reference node
<span class="lineNum">   13939 </span>            :          and record it as the &quot;definition&quot;.
<span class="lineNum">   13940 </span>            :          When a real declaration of this type is found,
<span class="lineNum">   13941 </span>            :          the forward-reference will be altered into a real type.  */
<span class="lineNum">   13942 </span><span class="lineCov">    1730403 :       if (code == ENUMERAL_TYPE)</span>
<span class="lineNum">   13943 </span>            :         {
<span class="lineNum">   13944 </span><span class="lineCov">         11 :           error (&quot;use of enum %q#D without previous declaration&quot;, name);</span>
<span class="lineNum">   13945 </span><span class="lineCov">         11 :           return error_mark_node;</span>
<span class="lineNum">   13946 </span>            :         }
<span class="lineNum">   13947 </span>            :       else
<span class="lineNum">   13948 </span>            :         {
<span class="lineNum">   13949 </span><span class="lineCov">    1730392 :           t = make_class_type (code);</span>
<span class="lineNum">   13950 </span><span class="lineCov">    1730392 :           TYPE_CONTEXT (t) = context;</span>
<span class="lineNum">   13951 </span><span class="lineCov">    1730392 :           if (scope == ts_lambda)</span>
<span class="lineNum">   13952 </span>            :             {
<span class="lineNum">   13953 </span>            :               /* Mark it as a lambda type.  */
<span class="lineNum">   13954 </span><span class="lineCov">      31600 :               CLASSTYPE_LAMBDA_EXPR (t) = error_mark_node;</span>
<span class="lineNum">   13955 </span>            :               /* And push it into current scope.  */
<span class="lineNum">   13956 </span><span class="lineCov">      31600 :               scope = ts_current;</span>
<span class="lineNum">   13957 </span>            :             }
<span class="lineNum">   13958 </span><span class="lineCov">    1730392 :           t = pushtag (name, t, scope);</span>
<span class="lineNum">   13959 </span>            :         }
<span class="lineNum">   13960 </span>            :     }
<span class="lineNum">   13961 </span>            :   else
<span class="lineNum">   13962 </span>            :     {
<span class="lineNum">   13963 </span><span class="lineCov">     603562 :       if (template_header_p &amp;&amp; MAYBE_CLASS_TYPE_P (t))</span>
<span class="lineNum">   13964 </span>            :         {
<span class="lineNum">   13965 </span>            :           /* Check that we aren't trying to overload a class with different
<span class="lineNum">   13966 </span>            :              constraints.  */
<span class="lineNum">   13967 </span><span class="lineCov">     111218 :           tree constr = NULL_TREE;</span>
<span class="lineNum">   13968 </span><span class="lineCov">     111218 :           if (current_template_parms)</span>
<span class="lineNum">   13969 </span>            :             {
<span class="lineNum">   13970 </span><span class="lineCov">     111215 :               tree reqs = TEMPLATE_PARMS_CONSTRAINTS (current_template_parms);</span>
<span class="lineNum">   13971 </span><span class="lineCov">     111215 :               constr = build_constraints (reqs, NULL_TREE);</span>
<span class="lineNum">   13972 </span>            :             }
<span class="lineNum">   13973 </span><span class="lineCov">     111218 :           if (!redeclare_class_template (t, current_template_parms, constr))</span>
<span class="lineNum">   13974 </span><span class="lineCov">         40 :             return error_mark_node;</span>
<span class="lineNum">   13975 </span>            :         }
<span class="lineNum">   13976 </span><span class="lineCov">     492344 :       else if (!processing_template_decl</span>
<span class="lineNum">   13977 </span><span class="lineCov">     488116 :                &amp;&amp; CLASS_TYPE_P (t)</span>
<span class="lineNum">   13978 </span><span class="lineCov">    1914665 :                &amp;&amp; CLASSTYPE_IS_TEMPLATE (t))</span>
<span class="lineNum">   13979 </span>            :         {
<span class="lineNum">   13980 </span><span class="lineCov">          3 :           error (&quot;redeclaration of %qT as a non-template&quot;, t);</span>
<span class="lineNum">   13981 </span><span class="lineCov">          3 :           inform (location_of (t), &quot;previous declaration %qD&quot;, t);</span>
<span class="lineNum">   13982 </span><span class="lineCov">          3 :           return error_mark_node;</span>
<span class="lineNum">   13983 </span>            :         }
<span class="lineNum">   13984 </span>            : 
<span class="lineNum">   13985 </span><span class="lineCov">     603519 :       if (scope != ts_within_enclosing_non_class &amp;&amp; TYPE_HIDDEN_P (t))</span>
<span class="lineNum">   13986 </span>            :         {
<span class="lineNum">   13987 </span>            :           /* This is no longer an invisible friend.  Make it
<span class="lineNum">   13988 </span>            :              visible.  */
<span class="lineNum">   13989 </span><span class="lineCov">       3957 :           tree decl = TYPE_NAME (t);</span>
<span class="lineNum">   13990 </span>            : 
<span class="lineNum">   13991 </span><span class="lineCov">       3957 :           DECL_ANTICIPATED (decl) = false;</span>
<span class="lineNum">   13992 </span><span class="lineCov">       3957 :           DECL_FRIEND_P (decl) = false;</span>
<span class="lineNum">   13993 </span>            : 
<span class="lineNum">   13994 </span><span class="lineCov">       3957 :           if (TYPE_TEMPLATE_INFO (t))</span>
<span class="lineNum">   13995 </span>            :             {
<span class="lineNum">   13996 </span><span class="lineCov">       2826 :               tree tmpl = TYPE_TI_TEMPLATE (t);</span>
<span class="lineNum">   13997 </span><span class="lineCov">       5652 :               DECL_ANTICIPATED (tmpl) = false;</span>
<span class="lineNum">   13998 </span><span class="lineCov">       5652 :               DECL_FRIEND_P (tmpl) = false;</span>
<span class="lineNum">   13999 </span>            :             }
<span class="lineNum">   14000 </span>            :         }
<span class="lineNum">   14001 </span>            :     }
<span class="lineNum">   14002 </span>            : 
<span class="lineNum">   14003 </span>            :   return t;
<span class="lineNum">   14004 </span>            : }
<span class="lineNum">   14005 </span>            : 
<span class="lineNum">   14006 </span>            : /* Wrapper for xref_tag_1.  */
<a name="14007"><span class="lineNum">   14007 </span>            : </a>
<span class="lineNum">   14008 </span>            : tree
<span class="lineNum">   14009 </span><span class="lineCov">    2334066 : xref_tag (enum tag_types tag_code, tree name,</span>
<span class="lineNum">   14010 </span>            :           tag_scope scope, bool template_header_p)
<span class="lineNum">   14011 </span>            : {
<span class="lineNum">   14012 </span><span class="lineCov">    2334066 :   tree ret;</span>
<span class="lineNum">   14013 </span><span class="lineCov">    2334066 :   bool subtime;</span>
<span class="lineNum">   14014 </span><span class="lineCov">    2334066 :   subtime = timevar_cond_start (TV_NAME_LOOKUP);</span>
<span class="lineNum">   14015 </span><span class="lineCov">    2334066 :   ret = xref_tag_1 (tag_code, name, scope, template_header_p);</span>
<span class="lineNum">   14016 </span><span class="lineCov">    2334066 :   timevar_cond_stop (TV_NAME_LOOKUP, subtime);</span>
<span class="lineNum">   14017 </span><span class="lineCov">    2334066 :   return ret;</span>
<span class="lineNum">   14018 </span>            : }
<span class="lineNum">   14019 </span>            : 
<a name="14020"><span class="lineNum">   14020 </span>            : </a>
<span class="lineNum">   14021 </span>            : tree
<span class="lineNum">   14022 </span><span class="lineCov">        461 : xref_tag_from_type (tree old, tree id, tag_scope scope)</span>
<span class="lineNum">   14023 </span>            : {
<span class="lineNum">   14024 </span><span class="lineCov">        461 :   enum tag_types tag_kind;</span>
<span class="lineNum">   14025 </span>            : 
<span class="lineNum">   14026 </span><span class="lineCov">        461 :   if (TREE_CODE (old) == RECORD_TYPE)</span>
<span class="lineNum">   14027 </span><span class="lineCov">        461 :     tag_kind = (CLASSTYPE_DECLARED_CLASS (old) ? class_type : record_type);</span>
<span class="lineNum">   14028 </span>            :   else
<span class="lineNum">   14029 </span>            :     tag_kind  = union_type;
<span class="lineNum">   14030 </span>            : 
<span class="lineNum">   14031 </span><span class="lineCov">        461 :   if (id == NULL_TREE)</span>
<span class="lineNum">   14032 </span><span class="lineCov">        451 :     id = TYPE_IDENTIFIER (old);</span>
<span class="lineNum">   14033 </span>            : 
<span class="lineNum">   14034 </span><span class="lineCov">        461 :   return xref_tag (tag_kind, id, scope, false);</span>
<span class="lineNum">   14035 </span>            : }
<span class="lineNum">   14036 </span>            : 
<span class="lineNum">   14037 </span>            : /* Create the binfo hierarchy for REF with (possibly NULL) base list
<span class="lineNum">   14038 </span>            :    BASE_LIST.  For each element on BASE_LIST the TREE_PURPOSE is an
<span class="lineNum">   14039 </span>            :    access_* node, and the TREE_VALUE is the type of the base-class.
<span class="lineNum">   14040 </span>            :    Non-NULL TREE_TYPE indicates virtual inheritance.  */
<a name="14041"><span class="lineNum">   14041 </span>            : </a>
<span class="lineNum">   14042 </span>            : void
<span class="lineNum">   14043 </span><span class="lineCov">   10366205 : xref_basetypes (tree ref, tree base_list)</span>
<span class="lineNum">   14044 </span>            : {
<span class="lineNum">   14045 </span><span class="lineCov">   10366205 :   tree *basep;</span>
<span class="lineNum">   14046 </span><span class="lineCov">   10366205 :   tree binfo, base_binfo;</span>
<span class="lineNum">   14047 </span><span class="lineCov">   10366205 :   unsigned max_vbases = 0; /* Maximum direct &amp; indirect virtual bases.  */</span>
<span class="lineNum">   14048 </span><span class="lineCov">   10366205 :   unsigned max_bases = 0;  /* Maximum direct bases.  */</span>
<span class="lineNum">   14049 </span><span class="lineCov">   10366205 :   unsigned max_dvbases = 0; /* Maximum direct virtual bases.  */</span>
<span class="lineNum">   14050 </span><span class="lineCov">   10366205 :   int i;</span>
<span class="lineNum">   14051 </span><span class="lineCov">   10366205 :   tree default_access;</span>
<span class="lineNum">   14052 </span><span class="lineCov">   10366205 :   tree igo_prev; /* Track Inheritance Graph Order.  */</span>
<span class="lineNum">   14053 </span>            : 
<span class="lineNum">   14054 </span><span class="lineCov">   10366205 :   if (ref == error_mark_node)</span>
<span class="lineNum">   14055 </span><span class="lineCov">         12 :     return;</span>
<span class="lineNum">   14056 </span>            : 
<span class="lineNum">   14057 </span>            :   /* The base of a derived class is private by default, all others are
<span class="lineNum">   14058 </span>            :      public.  */
<span class="lineNum">   14059 </span><span class="lineCov">   20732410 :   default_access = (TREE_CODE (ref) == RECORD_TYPE</span>
<span class="lineNum">   14060 </span><span class="lineCov">   10286147 :                     &amp;&amp; CLASSTYPE_DECLARED_CLASS (ref)</span>
<span class="lineNum">   14061 </span><span class="lineCov">   20652352 :                     ? access_private_node : access_public_node);</span>
<span class="lineNum">   14062 </span>            : 
<span class="lineNum">   14063 </span>            :   /* First, make sure that any templates in base-classes are
<span class="lineNum">   14064 </span>            :      instantiated.  This ensures that if we call ourselves recursively
<span class="lineNum">   14065 </span>            :      we do not get confused about which classes are marked and which
<span class="lineNum">   14066 </span>            :      are not.  */
<span class="lineNum">   14067 </span><span class="lineCov">   10366205 :   basep = &amp;base_list;</span>
<span class="lineNum">   14068 </span><span class="lineCov">   15857811 :   while (*basep)</span>
<span class="lineNum">   14069 </span>            :     {
<span class="lineNum">   14070 </span><span class="lineCov">    5491606 :       tree basetype = TREE_VALUE (*basep);</span>
<span class="lineNum">   14071 </span>            : 
<span class="lineNum">   14072 </span>            :       /* The dependent_type_p call below should really be dependent_scope_p
<span class="lineNum">   14073 </span>            :          so that we give a hard error about using an incomplete type as a
<span class="lineNum">   14074 </span>            :          base, but we allow it with a pedwarn for backward
<span class="lineNum">   14075 </span>            :          compatibility.  */
<span class="lineNum">   14076 </span><span class="lineCov">    5491606 :       if (processing_template_decl</span>
<span class="lineNum">   14077 </span><span class="lineCov">    5491606 :           &amp;&amp; CLASS_TYPE_P (basetype) &amp;&amp; TYPE_BEING_DEFINED (basetype))</span>
<span class="lineNum">   14078 </span><span class="lineCov">          3 :         cxx_incomplete_type_diagnostic (NULL_TREE, basetype, DK_PEDWARN);</span>
<span class="lineNum">   14079 </span><span class="lineCov">    5491606 :       if (!dependent_type_p (basetype)</span>
<span class="lineNum">   14080 </span><span class="lineCov">    5491606 :           &amp;&amp; !complete_type_or_else (basetype, NULL))</span>
<span class="lineNum">   14081 </span>            :         /* An incomplete type.  Remove it from the list.  */
<span class="lineNum">   14082 </span><span class="lineCov">          8 :         *basep = TREE_CHAIN (*basep);</span>
<span class="lineNum">   14083 </span>            :       else
<span class="lineNum">   14084 </span>            :         {
<span class="lineNum">   14085 </span><span class="lineCov">    5491598 :           max_bases++;</span>
<span class="lineNum">   14086 </span><span class="lineCov">    5491598 :           if (TREE_TYPE (*basep))</span>
<span class="lineNum">   14087 </span><span class="lineCov">       9404 :             max_dvbases++;</span>
<span class="lineNum">   14088 </span><span class="lineCov">    5491598 :           if (CLASS_TYPE_P (basetype))</span>
<span class="lineNum">   14089 </span><span class="lineCov">   10712838 :             max_vbases += vec_safe_length (CLASSTYPE_VBASECLASSES (basetype));</span>
<span class="lineNum">   14090 </span><span class="lineCov">    5491598 :           basep = &amp;TREE_CHAIN (*basep);</span>
<span class="lineNum">   14091 </span>            :         }
<span class="lineNum">   14092 </span>            :     }
<span class="lineNum">   14093 </span><span class="lineCov">   10366205 :   max_vbases += max_dvbases;</span>
<span class="lineNum">   14094 </span>            : 
<span class="lineNum">   14095 </span><span class="lineCov">   10366205 :   TYPE_MARKED_P (ref) = 1;</span>
<span class="lineNum">   14096 </span>            : 
<span class="lineNum">   14097 </span>            :   /* The binfo slot should be empty, unless this is an (ill-formed)
<span class="lineNum">   14098 </span>            :      redefinition.  */
<span class="lineNum">   14099 </span><span class="lineCov">   10446263 :   gcc_assert (!TYPE_BINFO (ref) || TYPE_SIZE (ref));</span>
<span class="lineNum">   14100 </span>            : 
<span class="lineNum">   14101 </span><span class="lineCov">   10366205 :   gcc_assert (TYPE_MAIN_VARIANT (ref) == ref);</span>
<span class="lineNum">   14102 </span>            : 
<span class="lineNum">   14103 </span><span class="lineCov">   10366205 :   binfo = make_tree_binfo (max_bases);</span>
<span class="lineNum">   14104 </span>            : 
<span class="lineNum">   14105 </span><span class="lineCov">   10366205 :   TYPE_BINFO (ref) = binfo;</span>
<span class="lineNum">   14106 </span><span class="lineCov">   10366205 :   BINFO_OFFSET (binfo) = size_zero_node;</span>
<span class="lineNum">   14107 </span><span class="lineCov">   20732410 :   BINFO_TYPE (binfo) = ref;</span>
<span class="lineNum">   14108 </span>            : 
<span class="lineNum">   14109 </span>            :   /* Apply base-class info set up to the variants of this type.  */
<span class="lineNum">   14110 </span><span class="lineCov">   10366205 :   fixup_type_variants (ref);</span>
<span class="lineNum">   14111 </span>            : 
<span class="lineNum">   14112 </span><span class="lineCov">   10366205 :   if (max_bases)</span>
<span class="lineNum">   14113 </span>            :     {
<span class="lineNum">   14114 </span><span class="lineCov">    5448321 :       vec_alloc (BINFO_BASE_ACCESSES (binfo), max_bases);</span>
<span class="lineNum">   14115 </span>            :       /* A C++98 POD cannot have base classes.  */
<span class="lineNum">   14116 </span><span class="lineCov">    5448321 :       CLASSTYPE_NON_LAYOUT_POD_P (ref) = true;</span>
<span class="lineNum">   14117 </span>            : 
<span class="lineNum">   14118 </span><span class="lineCov">    5448321 :       if (TREE_CODE (ref) == UNION_TYPE)</span>
<span class="lineNum">   14119 </span>            :         {
<span class="lineNum">   14120 </span><span class="lineCov">         12 :           error (&quot;derived union %qT invalid&quot;, ref);</span>
<span class="lineNum">   14121 </span><span class="lineCov">         12 :           return;</span>
<span class="lineNum">   14122 </span>            :         }
<span class="lineNum">   14123 </span>            :     }
<span class="lineNum">   14124 </span>            : 
<span class="lineNum">   14125 </span><span class="lineCov">   10366193 :   if (max_bases &gt; 1)</span>
<span class="lineNum">   14126 </span><span class="lineCov">      34307 :     warning (OPT_Wmultiple_inheritance,</span>
<span class="lineNum">   14127 </span>            :              &quot;%qT defined with multiple direct bases&quot;, ref);
<span class="lineNum">   14128 </span>            : 
<span class="lineNum">   14129 </span><span class="lineCov">   10366193 :   if (max_vbases)</span>
<span class="lineNum">   14130 </span>            :     {
<span class="lineNum">   14131 </span>            :       /* An aggregate can't have virtual base classes.  */
<span class="lineNum">   14132 </span><span class="lineCov">      14883 :       CLASSTYPE_NON_AGGREGATE (ref) = true;</span>
<span class="lineNum">   14133 </span>            : 
<span class="lineNum">   14134 </span><span class="lineCov">      14883 :       vec_alloc (CLASSTYPE_VBASECLASSES (ref), max_vbases);</span>
<span class="lineNum">   14135 </span>            : 
<span class="lineNum">   14136 </span><span class="lineCov">      14883 :       if (max_dvbases)</span>
<span class="lineNum">   14137 </span><span class="lineCov">       8454 :         warning (OPT_Wvirtual_inheritance,</span>
<span class="lineNum">   14138 </span>            :                  &quot;%qT defined with direct virtual base&quot;, ref);
<span class="lineNum">   14139 </span>            :     }
<span class="lineNum">   14140 </span>            : 
<span class="lineNum">   14141 </span><span class="lineCov">   15857779 :   for (igo_prev = binfo; base_list; base_list = TREE_CHAIN (base_list))</span>
<span class="lineNum">   14142 </span>            :     {
<span class="lineNum">   14143 </span><span class="lineCov">    5491586 :       tree access = TREE_PURPOSE (base_list);</span>
<span class="lineNum">   14144 </span><span class="lineCov">    5491586 :       int via_virtual = TREE_TYPE (base_list) != NULL_TREE;</span>
<span class="lineNum">   14145 </span><span class="lineCov">    5491586 :       tree basetype = TREE_VALUE (base_list);</span>
<span class="lineNum">   14146 </span>            : 
<span class="lineNum">   14147 </span><span class="lineCov">    5491586 :       if (access == access_default_node)</span>
<span class="lineNum">   14148 </span><span class="lineCov">     205595 :         access = default_access;</span>
<span class="lineNum">   14149 </span>            : 
<span class="lineNum">   14150 </span>            :       /* Before C++17, an aggregate cannot have base classes.  In C++17, an
<span class="lineNum">   14151 </span>            :          aggregate can't have virtual, private, or protected base classes.  */
<span class="lineNum">   14152 </span><span class="lineCov">    5491586 :       if (cxx_dialect &lt; cxx17</span>
<span class="lineNum">   14153 </span><span class="lineCov">     625434 :           || access != access_public_node</span>
<span class="lineNum">   14154 </span><span class="lineCov">     608235 :           || via_virtual)</span>
<span class="lineNum">   14155 </span><span class="lineCov">    4884267 :         CLASSTYPE_NON_AGGREGATE (ref) = true;</span>
<span class="lineNum">   14156 </span>            : 
<span class="lineNum">   14157 </span><span class="lineCov">    5491586 :       if (PACK_EXPANSION_P (basetype))</span>
<span class="lineNum">   14158 </span><span class="lineCov">         41 :         basetype = PACK_EXPANSION_PATTERN (basetype);</span>
<span class="lineNum">   14159 </span><span class="lineCov">    5491586 :       if (TREE_CODE (basetype) == TYPE_DECL)</span>
<span class="lineNum">   14160 </span><span class="lineNoCov">          0 :         basetype = TREE_TYPE (basetype);</span>
<span class="lineNum">   14161 </span><span class="lineCov">    5491586 :       if (!MAYBE_CLASS_TYPE_P (basetype) || TREE_CODE (basetype) == UNION_TYPE)</span>
<span class="lineNum">   14162 </span>            :         {
<span class="lineNum">   14163 </span><span class="lineCov">         22 :           error (&quot;base type %qT fails to be a struct or class type&quot;,</span>
<span class="lineNum">   14164 </span>            :                  basetype);
<span class="lineNum">   14165 </span><span class="lineCov">         22 :           goto dropped_base;</span>
<span class="lineNum">   14166 </span>            :         }
<span class="lineNum">   14167 </span>            : 
<span class="lineNum">   14168 </span><span class="lineCov">    5491564 :       base_binfo = NULL_TREE;</span>
<span class="lineNum">   14169 </span><span class="lineCov">    5491564 :       if (CLASS_TYPE_P (basetype) &amp;&amp; !dependent_scope_p (basetype))</span>
<span class="lineNum">   14170 </span>            :         {
<span class="lineNum">   14171 </span><span class="lineCov">    4880672 :           base_binfo = TYPE_BINFO (basetype);</span>
<span class="lineNum">   14172 </span>            :           /* The original basetype could have been a typedef'd type.  */
<span class="lineNum">   14173 </span><span class="lineCov">    4880672 :           basetype = BINFO_TYPE (base_binfo);</span>
<span class="lineNum">   14174 </span>            : 
<span class="lineNum">   14175 </span>            :           /* Inherit flags from the base.  */
<span class="lineNum">   14176 </span><span class="lineCov">   14642016 :           TYPE_HAS_NEW_OPERATOR (ref)</span>
<span class="lineNum">   14177 </span><span class="lineCov">    4880672 :             |= TYPE_HAS_NEW_OPERATOR (basetype);</span>
<span class="lineNum">   14178 </span><span class="lineCov">   14642016 :           TYPE_HAS_ARRAY_NEW_OPERATOR (ref)</span>
<span class="lineNum">   14179 </span><span class="lineCov">    4880672 :             |= TYPE_HAS_ARRAY_NEW_OPERATOR (basetype);</span>
<span class="lineNum">   14180 </span><span class="lineCov">    4880672 :           TYPE_GETS_DELETE (ref) |= TYPE_GETS_DELETE (basetype);</span>
<span class="lineNum">   14181 </span><span class="lineCov">    4880672 :           TYPE_HAS_CONVERSION (ref) |= TYPE_HAS_CONVERSION (basetype);</span>
<span class="lineNum">   14182 </span><span class="lineCov">   14642016 :           CLASSTYPE_DIAMOND_SHAPED_P (ref)</span>
<span class="lineNum">   14183 </span><span class="lineCov">    4880672 :             |= CLASSTYPE_DIAMOND_SHAPED_P (basetype);</span>
<span class="lineNum">   14184 </span><span class="lineCov">   14642016 :           CLASSTYPE_REPEATED_BASE_P (ref)</span>
<span class="lineNum">   14185 </span><span class="lineCov">    4880672 :             |= CLASSTYPE_REPEATED_BASE_P (basetype);</span>
<span class="lineNum">   14186 </span>            :         }
<span class="lineNum">   14187 </span>            : 
<span class="lineNum">   14188 </span>            :       /* We must do this test after we've seen through a typedef
<span class="lineNum">   14189 </span>            :          type.  */
<span class="lineNum">   14190 </span><span class="lineCov">   10983128 :       if (TYPE_MARKED_P (basetype))</span>
<span class="lineNum">   14191 </span>            :         {
<span class="lineNum">   14192 </span><span class="lineCov">         18 :           if (basetype == ref)</span>
<span class="lineNum">   14193 </span><span class="lineNoCov">          0 :             error (&quot;recursive type %qT undefined&quot;, basetype);</span>
<span class="lineNum">   14194 </span>            :           else
<span class="lineNum">   14195 </span><span class="lineCov">         18 :             error (&quot;duplicate base type %qT invalid&quot;, basetype);</span>
<span class="lineNum">   14196 </span><span class="lineCov">         18 :           goto dropped_base;</span>
<span class="lineNum">   14197 </span>            :         }
<span class="lineNum">   14198 </span>            : 
<span class="lineNum">   14199 </span><span class="lineCov">    5491546 :       if (PACK_EXPANSION_P (TREE_VALUE (base_list)))</span>
<span class="lineNum">   14200 </span>            :         /* Regenerate the pack expansion for the bases. */
<span class="lineNum">   14201 </span><span class="lineCov">         41 :         basetype = make_pack_expansion (basetype);</span>
<span class="lineNum">   14202 </span>            : 
<span class="lineNum">   14203 </span><span class="lineCov">    5491546 :       TYPE_MARKED_P (basetype) = 1;</span>
<span class="lineNum">   14204 </span>            : 
<span class="lineNum">   14205 </span><span class="lineCov">    5491546 :       base_binfo = copy_binfo (base_binfo, basetype, ref,</span>
<span class="lineNum">   14206 </span>            :                                &amp;igo_prev, via_virtual);
<span class="lineNum">   14207 </span><span class="lineCov">    5491546 :       if (!BINFO_INHERITANCE_CHAIN (base_binfo))</span>
<span class="lineNum">   14208 </span><span class="lineCov">   10964312 :         BINFO_INHERITANCE_CHAIN (base_binfo) = binfo;</span>
<span class="lineNum">   14209 </span>            : 
<span class="lineNum">   14210 </span><span class="lineCov">    5491546 :       BINFO_BASE_APPEND (binfo, base_binfo);</span>
<span class="lineNum">   14211 </span><span class="lineCov">   10983092 :       BINFO_BASE_ACCESS_APPEND (binfo, access);</span>
<span class="lineNum">   14212 </span><span class="lineCov">    5491546 :       continue;</span>
<span class="lineNum">   14213 </span>            : 
<span class="lineNum">   14214 </span><span class="lineCov">         40 :     dropped_base:</span>
<span class="lineNum">   14215 </span>            :       /* Update max_vbases to reflect the reality that we are dropping
<span class="lineNum">   14216 </span>            :          this base:  if it reaches zero we want to undo the vec_alloc
<span class="lineNum">   14217 </span>            :          above to avoid inconsistencies during error-recovery: eg, in
<span class="lineNum">   14218 </span>            :          build_special_member_call, CLASSTYPE_VBASECLASSES non null
<span class="lineNum">   14219 </span>            :          and vtt null (c++/27952).  */
<span class="lineNum">   14220 </span><span class="lineCov">         40 :       if (via_virtual)</span>
<span class="lineNum">   14221 </span><span class="lineCov">         11 :         max_vbases--;</span>
<span class="lineNum">   14222 </span><span class="lineCov">         40 :       if (CLASS_TYPE_P (basetype))</span>
<span class="lineNum">   14223 </span><span class="lineCov">         30 :         max_vbases</span>
<span class="lineNum">   14224 </span><span class="lineCov">         63 :           -= vec_safe_length (CLASSTYPE_VBASECLASSES (basetype));</span>
<span class="lineNum">   14225 </span>            :     }
<span class="lineNum">   14226 </span>            : 
<span class="lineNum">   14227 </span><span class="lineCov">   10366193 :   if (CLASSTYPE_VBASECLASSES (ref)</span>
<span class="lineNum">   14228 </span><span class="lineCov">   10366193 :       &amp;&amp; max_vbases == 0)</span>
<span class="lineNum">   14229 </span><span class="lineCov">         22 :     vec_free (CLASSTYPE_VBASECLASSES (ref));</span>
<span class="lineNum">   14230 </span>            : 
<span class="lineNum">   14231 </span><span class="lineCov">   10381065 :   if (vec_safe_length (CLASSTYPE_VBASECLASSES (ref)) &lt; max_vbases)</span>
<span class="lineNum">   14232 </span>            :     /* If we didn't get max_vbases vbases, we must have shared at
<span class="lineNum">   14233 </span>            :        least one of them, and are therefore diamond shaped.  */
<span class="lineNum">   14234 </span><span class="lineCov">       5248 :     CLASSTYPE_DIAMOND_SHAPED_P (ref) = 1;</span>
<span class="lineNum">   14235 </span>            : 
<span class="lineNum">   14236 </span>            :   /* Unmark all the types.  */
<span class="lineNum">   14237 </span><span class="lineCov">   15857739 :   for (i = 0; BINFO_BASE_ITERATE (binfo, i, base_binfo); i++)</span>
<span class="lineNum">   14238 </span><span class="lineCov">   10983092 :     TYPE_MARKED_P (BINFO_TYPE (base_binfo)) = 0;</span>
<span class="lineNum">   14239 </span><span class="lineCov">   10366193 :   TYPE_MARKED_P (ref) = 0;</span>
<span class="lineNum">   14240 </span>            : 
<span class="lineNum">   14241 </span>            :   /* Now see if we have a repeated base type.  */
<span class="lineNum">   14242 </span><span class="lineCov">   10366193 :   if (!CLASSTYPE_REPEATED_BASE_P (ref))</span>
<span class="lineNum">   14243 </span>            :     {
<span class="lineNum">   14244 </span><span class="lineCov">   29742199 :       for (base_binfo = binfo; base_binfo;</span>
<span class="lineNum">   14245 </span><span class="lineCov">   19376396 :            base_binfo = TREE_CHAIN (base_binfo))</span>
<span class="lineNum">   14246 </span>            :         {
<span class="lineNum">   14247 </span><span class="lineCov">   38753984 :           if (TYPE_MARKED_P (BINFO_TYPE (base_binfo)))</span>
<span class="lineNum">   14248 </span>            :             {
<span class="lineNum">   14249 </span><span class="lineCov">        596 :               CLASSTYPE_REPEATED_BASE_P (ref) = 1;</span>
<span class="lineNum">   14250 </span><span class="lineCov">        596 :               break;</span>
<span class="lineNum">   14251 </span>            :             }
<span class="lineNum">   14252 </span><span class="lineCov">   96881980 :           TYPE_MARKED_P (BINFO_TYPE (base_binfo)) = 1;</span>
<span class="lineNum">   14253 </span>            :         }
<span class="lineNum">   14254 </span><span class="lineCov">   29742199 :       for (base_binfo = binfo; base_binfo;</span>
<span class="lineNum">   14255 </span><span class="lineCov">   19376396 :            base_binfo = TREE_CHAIN (base_binfo))</span>
<span class="lineNum">   14256 </span><span class="lineCov">   38753984 :         if (TYPE_MARKED_P (BINFO_TYPE (base_binfo)))</span>
<span class="lineNum">   14257 </span><span class="lineCov">   96881980 :           TYPE_MARKED_P (BINFO_TYPE (base_binfo)) = 0;</span>
<span class="lineNum">   14258 </span>            :         else
<span class="lineNum">   14259 </span>            :           break;
<span class="lineNum">   14260 </span>            :     }
<span class="lineNum">   14261 </span>            : }
<span class="lineNum">   14262 </span>            : 
<span class="lineNum">   14263 </span>            : 
<span class="lineNum">   14264 </span>            : /* Copies the enum-related properties from type SRC to type DST.
<a name="14265"><span class="lineNum">   14265 </span>            :    Used with the underlying type of an enum and the enum itself.  */</a>
<span class="lineNum">   14266 </span>            : static void
<span class="lineNum">   14267 </span><span class="lineCov">     227315 : copy_type_enum (tree dst, tree src)</span>
<span class="lineNum">   14268 </span>            : {
<span class="lineNum">   14269 </span><span class="lineCov">     227315 :   tree t;</span>
<span class="lineNum">   14270 </span><span class="lineCov">     454633 :   for (t = dst; t; t = TYPE_NEXT_VARIANT (t))</span>
<span class="lineNum">   14271 </span>            :     {
<span class="lineNum">   14272 </span><span class="lineCov">     227318 :       TYPE_MIN_VALUE (t) = TYPE_MIN_VALUE (src);</span>
<span class="lineNum">   14273 </span><span class="lineCov">     227318 :       TYPE_MAX_VALUE (t) = TYPE_MAX_VALUE (src);</span>
<span class="lineNum">   14274 </span><span class="lineCov">     227318 :       TYPE_SIZE (t) = TYPE_SIZE (src);</span>
<span class="lineNum">   14275 </span><span class="lineCov">     227318 :       TYPE_SIZE_UNIT (t) = TYPE_SIZE_UNIT (src);</span>
<span class="lineNum">   14276 </span><span class="lineCov">     227318 :       SET_TYPE_MODE (dst, TYPE_MODE (src));</span>
<span class="lineNum">   14277 </span><span class="lineCov">     227318 :       TYPE_PRECISION (t) = TYPE_PRECISION (src);</span>
<span class="lineNum">   14278 </span><span class="lineCov">     227318 :       unsigned valign = TYPE_ALIGN (src);</span>
<span class="lineNum">   14279 </span><span class="lineCov">     227318 :       if (TYPE_USER_ALIGN (t))</span>
<span class="lineNum">   14280 </span><span class="lineCov">          4 :         valign = MAX (valign, TYPE_ALIGN (t));</span>
<span class="lineNum">   14281 </span>            :       else
<span class="lineNum">   14282 </span><span class="lineCov">     681948 :         TYPE_USER_ALIGN (t) = TYPE_USER_ALIGN (src);</span>
<span class="lineNum">   14283 </span><span class="lineCov">     454636 :       SET_TYPE_ALIGN (t, valign);</span>
<span class="lineNum">   14284 </span><span class="lineCov">     227318 :       TYPE_UNSIGNED (t) = TYPE_UNSIGNED (src);</span>
<span class="lineNum">   14285 </span>            :     }
<span class="lineNum">   14286 </span><span class="lineCov">     227315 : }</span>
<span class="lineNum">   14287 </span>            : 
<span class="lineNum">   14288 </span>            : /* Begin compiling the definition of an enumeration type.
<span class="lineNum">   14289 </span>            :    NAME is its name, 
<span class="lineNum">   14290 </span>            : 
<span class="lineNum">   14291 </span>            :    if ENUMTYPE is not NULL_TREE then the type has alredy been found.
<span class="lineNum">   14292 </span>            : 
<span class="lineNum">   14293 </span>            :    UNDERLYING_TYPE is the type that will be used as the storage for
<span class="lineNum">   14294 </span>            :    the enumeration type. This should be NULL_TREE if no storage type
<span class="lineNum">   14295 </span>            :    was specified.
<span class="lineNum">   14296 </span>            : 
<span class="lineNum">   14297 </span>            :    ATTRIBUTES are any attributes specified after the enum-key.
<span class="lineNum">   14298 </span>            : 
<span class="lineNum">   14299 </span>            :    SCOPED_ENUM_P is true if this is a scoped enumeration type.
<span class="lineNum">   14300 </span>            : 
<span class="lineNum">   14301 </span>            :    if IS_NEW is not NULL, gets TRUE iff a new type is created.
<span class="lineNum">   14302 </span>            : 
<span class="lineNum">   14303 </span>            :    Returns the type object, as yet incomplete.
<span class="lineNum">   14304 </span>            :    Also records info about it so that build_enumerator
<span class="lineNum">   14305 </span>            :    may be used to declare the individual values as they are read.  */
<a name="14306"><span class="lineNum">   14306 </span>            : </a>
<span class="lineNum">   14307 </span>            : tree
<span class="lineNum">   14308 </span><span class="lineCov">     260892 : start_enum (tree name, tree enumtype, tree underlying_type,</span>
<span class="lineNum">   14309 </span>            :             tree attributes, bool scoped_enum_p, bool *is_new)
<span class="lineNum">   14310 </span>            : {
<span class="lineNum">   14311 </span><span class="lineCov">     260892 :   tree prevtype = NULL_TREE;</span>
<span class="lineNum">   14312 </span><span class="lineCov">     260892 :   gcc_assert (identifier_p (name));</span>
<span class="lineNum">   14313 </span>            : 
<span class="lineNum">   14314 </span><span class="lineCov">     260892 :   if (is_new)</span>
<span class="lineNum">   14315 </span><span class="lineCov">     169958 :     *is_new = false;</span>
<span class="lineNum">   14316 </span>            :   /* [C++0x dcl.enum]p5:
<span class="lineNum">   14317 </span>            : 
<span class="lineNum">   14318 </span>            :     If not explicitly specified, the underlying type of a scoped
<span class="lineNum">   14319 </span>            :     enumeration type is int.  */
<span class="lineNum">   14320 </span><span class="lineCov">     260892 :   if (!underlying_type &amp;&amp; scoped_enum_p)</span>
<span class="lineNum">   14321 </span><span class="lineCov">       4150 :     underlying_type = integer_type_node;</span>
<span class="lineNum">   14322 </span>            : 
<span class="lineNum">   14323 </span><span class="lineCov">     260892 :   if (underlying_type)</span>
<span class="lineNum">   14324 </span><span class="lineCov">       9987 :     underlying_type = cv_unqualified (underlying_type);</span>
<span class="lineNum">   14325 </span>            : 
<span class="lineNum">   14326 </span>            :   /* If this is the real definition for a previous forward reference,
<span class="lineNum">   14327 </span>            :      fill in the contents in the same object that used to be the
<span class="lineNum">   14328 </span>            :      forward reference.  */
<span class="lineNum">   14329 </span><span class="lineCov">     260892 :   if (!enumtype)</span>
<span class="lineNum">   14330 </span><span class="lineCov">     260784 :     enumtype = lookup_and_check_tag (enum_type, name,</span>
<span class="lineNum">   14331 </span>            :                                      /*tag_scope=*/ts_current,
<span class="lineNum">   14332 </span>            :                                      /*template_header_p=*/false);
<span class="lineNum">   14333 </span>            : 
<span class="lineNum">   14334 </span>            :   /* In case of a template_decl, the only check that should be deferred
<span class="lineNum">   14335 </span>            :      to instantiation time is the comparison of underlying types.  */
<span class="lineNum">   14336 </span><span class="lineCov">     260892 :   if (enumtype &amp;&amp; TREE_CODE (enumtype) == ENUMERAL_TYPE)</span>
<span class="lineNum">   14337 </span>            :     {
<span class="lineNum">   14338 </span><span class="lineCov">       1802 :       if (scoped_enum_p != SCOPED_ENUM_P (enumtype))</span>
<span class="lineNum">   14339 </span>            :         {
<span class="lineNum">   14340 </span><span class="lineCov">          4 :           error_at (input_location, &quot;scoped/unscoped mismatch &quot;</span>
<span class="lineNum">   14341 </span>            :                     &quot;in enum %q#T&quot;, enumtype);
<span class="lineNum">   14342 </span><span class="lineCov">          4 :           inform (DECL_SOURCE_LOCATION (TYPE_MAIN_DECL (enumtype)),</span>
<span class="lineNum">   14343 </span>            :                   &quot;previous definition here&quot;);
<span class="lineNum">   14344 </span><span class="lineCov">          4 :           enumtype = error_mark_node;</span>
<span class="lineNum">   14345 </span>            :         }
<span class="lineNum">   14346 </span><span class="lineCov">        829 :       else if (ENUM_FIXED_UNDERLYING_TYPE_P (enumtype) != !! underlying_type)</span>
<span class="lineNum">   14347 </span>            :         {
<span class="lineNum">   14348 </span><span class="lineNoCov">          0 :           error_at (input_location, &quot;underlying type mismatch &quot;</span>
<span class="lineNum">   14349 </span>            :                     &quot;in enum %q#T&quot;, enumtype);
<span class="lineNum">   14350 </span><span class="lineNoCov">          0 :           inform (DECL_SOURCE_LOCATION (TYPE_MAIN_DECL (enumtype)),</span>
<span class="lineNum">   14351 </span>            :                   &quot;previous definition here&quot;);
<span class="lineNum">   14352 </span><span class="lineNoCov">          0 :           enumtype = error_mark_node;</span>
<span class="lineNum">   14353 </span>            :         }
<span class="lineNum">   14354 </span><span class="lineCov">       1652 :       else if (underlying_type &amp;&amp; ENUM_UNDERLYING_TYPE (enumtype)</span>
<span class="lineNum">   14355 </span><span class="lineCov">       3307 :                &amp;&amp; !same_type_p (underlying_type,</span>
<span class="lineNum">   14356 </span>            :                                 ENUM_UNDERLYING_TYPE (enumtype)))
<span class="lineNum">   14357 </span>            :         {
<span class="lineNum">   14358 </span><span class="lineCov">         16 :           error_at (input_location, &quot;different underlying type &quot;</span>
<span class="lineNum">   14359 </span>            :                     &quot;in enum %q#T&quot;, enumtype);
<span class="lineNum">   14360 </span><span class="lineCov">         16 :           inform (DECL_SOURCE_LOCATION (TYPE_MAIN_DECL (enumtype)),</span>
<span class="lineNum">   14361 </span>            :                   &quot;previous definition here&quot;);
<span class="lineNum">   14362 </span><span class="lineCov">         16 :           underlying_type = NULL_TREE;</span>
<span class="lineNum">   14363 </span>            :         }
<span class="lineNum">   14364 </span>            :     }
<span class="lineNum">   14365 </span>            : 
<span class="lineNum">   14366 </span><span class="lineCov">     260892 :   if (!enumtype || TREE_CODE (enumtype) != ENUMERAL_TYPE</span>
<span class="lineNum">   14367 </span><span class="lineCov">        829 :       || processing_template_decl)</span>
<span class="lineNum">   14368 </span>            :     {
<span class="lineNum">   14369 </span>            :       /* In case of error, make a dummy enum to allow parsing to
<span class="lineNum">   14370 </span>            :          continue.  */
<span class="lineNum">   14371 </span><span class="lineCov">     260115 :       if (enumtype == error_mark_node)</span>
<span class="lineNum">   14372 </span>            :         {
<span class="lineNum">   14373 </span><span class="lineCov">          4 :           name = make_anon_name ();</span>
<span class="lineNum">   14374 </span><span class="lineCov">          4 :           enumtype = NULL_TREE;</span>
<span class="lineNum">   14375 </span>            :         }
<span class="lineNum">   14376 </span>            : 
<span class="lineNum">   14377 </span>            :       /* enumtype may be an ENUMERAL_TYPE if this is a redefinition
<span class="lineNum">   14378 </span>            :          of an opaque enum, or an opaque enum of an already defined
<span class="lineNum">   14379 </span>            :          enumeration (C++11).
<span class="lineNum">   14380 </span>            :          In any other case, it'll be NULL_TREE. */
<span class="lineNum">   14381 </span><span class="lineCov">     260115 :       if (!enumtype)</span>
<span class="lineNum">   14382 </span>            :         {
<span class="lineNum">   14383 </span><span class="lineCov">     260060 :           if (is_new)</span>
<span class="lineNum">   14384 </span><span class="lineCov">     169126 :             *is_new = true;</span>
<span class="lineNum">   14385 </span>            :         }
<span class="lineNum">   14386 </span><span class="lineCov">     260115 :       prevtype = enumtype;</span>
<span class="lineNum">   14387 </span>            : 
<span class="lineNum">   14388 </span>            :       /* Do not push the decl more than once.  */
<span class="lineNum">   14389 </span><span class="lineCov">     260115 :       if (!enumtype</span>
<span class="lineNum">   14390 </span><span class="lineCov">         55 :           || TREE_CODE (enumtype) != ENUMERAL_TYPE)</span>
<span class="lineNum">   14391 </span>            :         {
<span class="lineNum">   14392 </span><span class="lineCov">     260063 :           enumtype = cxx_make_type (ENUMERAL_TYPE);</span>
<span class="lineNum">   14393 </span><span class="lineCov">     260063 :           enumtype = pushtag (name, enumtype, /*tag_scope=*/ts_current);</span>
<span class="lineNum">   14394 </span>            : 
<span class="lineNum">   14395 </span>            :           /* std::byte aliases anything.  */
<span class="lineNum">   14396 </span><span class="lineCov">     260063 :           if (enumtype != error_mark_node</span>
<span class="lineNum">   14397 </span><span class="lineCov">     260046 :               &amp;&amp; TYPE_CONTEXT (enumtype) == std_node</span>
<span class="lineNum">   14398 </span><span class="lineCov">     283895 :               &amp;&amp; !strcmp (&quot;byte&quot;, TYPE_NAME_STRING (enumtype)))</span>
<span class="lineNum">   14399 </span><span class="lineCov">       1036 :             TYPE_ALIAS_SET (enumtype) = 0;</span>
<span class="lineNum">   14400 </span>            :         }
<span class="lineNum">   14401 </span>            :       else
<span class="lineNum">   14402 </span><span class="lineCov">         52 :           enumtype = xref_tag (enum_type, name, /*tag_scope=*/ts_current,</span>
<span class="lineNum">   14403 </span>            :                                false);
<span class="lineNum">   14404 </span>            : 
<span class="lineNum">   14405 </span><span class="lineCov">     260115 :       if (enumtype == error_mark_node)</span>
<span class="lineNum">   14406 </span>            :         return error_mark_node;
<span class="lineNum">   14407 </span>            : 
<span class="lineNum">   14408 </span>            :       /* The enum is considered opaque until the opening '{' of the
<span class="lineNum">   14409 </span>            :          enumerator list.  */
<span class="lineNum">   14410 </span><span class="lineCov">     260098 :       SET_OPAQUE_ENUM_P (enumtype, true);</span>
<span class="lineNum">   14411 </span><span class="lineCov">     260098 :       ENUM_FIXED_UNDERLYING_TYPE_P (enumtype) = !! underlying_type;</span>
<span class="lineNum">   14412 </span>            :     }
<span class="lineNum">   14413 </span>            : 
<span class="lineNum">   14414 </span><span class="lineCov">     260875 :   SET_SCOPED_ENUM_P (enumtype, scoped_enum_p);</span>
<span class="lineNum">   14415 </span>            : 
<span class="lineNum">   14416 </span><span class="lineCov">     260875 :   cplus_decl_attributes (&amp;enumtype, attributes, (int)ATTR_FLAG_TYPE_IN_PLACE);</span>
<span class="lineNum">   14417 </span>            : 
<span class="lineNum">   14418 </span><span class="lineCov">     260875 :   if (underlying_type)</span>
<span class="lineNum">   14419 </span>            :     {
<span class="lineNum">   14420 </span><span class="lineCov">       9969 :       if (ENUM_UNDERLYING_TYPE (enumtype))</span>
<span class="lineNum">   14421 </span>            :         /* We already checked that it matches, don't change it to a different
<span class="lineNum">   14422 </span>            :            typedef variant.  */;
<span class="lineNum">   14423 </span><span class="lineCov">       9159 :       else if (CP_INTEGRAL_TYPE_P (underlying_type))</span>
<span class="lineNum">   14424 </span>            :         {
<span class="lineNum">   14425 </span><span class="lineCov">       9125 :           copy_type_enum (enumtype, underlying_type);</span>
<span class="lineNum">   14426 </span><span class="lineCov">       9125 :           ENUM_UNDERLYING_TYPE (enumtype) = underlying_type;</span>
<span class="lineNum">   14427 </span>            :         }
<span class="lineNum">   14428 </span><span class="lineCov">         34 :       else if (dependent_type_p (underlying_type))</span>
<span class="lineNum">   14429 </span><span class="lineCov">         30 :         ENUM_UNDERLYING_TYPE (enumtype) = underlying_type;</span>
<span class="lineNum">   14430 </span>            :       else
<span class="lineNum">   14431 </span><span class="lineCov">          4 :         error (&quot;underlying type %qT of %qT must be an integral type&quot;, </span>
<span class="lineNum">   14432 </span>            :                underlying_type, enumtype);
<span class="lineNum">   14433 </span>            :     }
<span class="lineNum">   14434 </span>            : 
<span class="lineNum">   14435 </span>            :   /* If into a template class, the returned enum is always the first
<span class="lineNum">   14436 </span>            :      declaration (opaque or not) seen. This way all the references to
<span class="lineNum">   14437 </span>            :      this type will be to the same declaration. The following ones are used
<span class="lineNum">   14438 </span>            :      only to check for definition errors.  */
<span class="lineNum">   14439 </span><span class="lineCov">     260875 :   if (prevtype &amp;&amp; processing_template_decl)</span>
<span class="lineNum">   14440 </span>            :     return prevtype;
<span class="lineNum">   14441 </span>            :   else
<span class="lineNum">   14442 </span><span class="lineCov">     260823 :     return enumtype;</span>
<span class="lineNum">   14443 </span>            : }
<span class="lineNum">   14444 </span>            : 
<span class="lineNum">   14445 </span>            : /* After processing and defining all the values of an enumeration type,
<span class="lineNum">   14446 </span>            :    install their decls in the enumeration type.
<span class="lineNum">   14447 </span>            :    ENUMTYPE is the type object.  */
<a name="14448"><span class="lineNum">   14448 </span>            : </a>
<span class="lineNum">   14449 </span>            : void
<span class="lineNum">   14450 </span><span class="lineCov">     257632 : finish_enum_value_list (tree enumtype)</span>
<span class="lineNum">   14451 </span>            : {
<span class="lineNum">   14452 </span><span class="lineCov">     257632 :   tree values;</span>
<span class="lineNum">   14453 </span><span class="lineCov">     257632 :   tree underlying_type;</span>
<span class="lineNum">   14454 </span><span class="lineCov">     257632 :   tree decl;</span>
<span class="lineNum">   14455 </span><span class="lineCov">     257632 :   tree value;</span>
<span class="lineNum">   14456 </span><span class="lineCov">     257632 :   tree minnode, maxnode;</span>
<span class="lineNum">   14457 </span><span class="lineCov">     257632 :   tree t;</span>
<span class="lineNum">   14458 </span>            : 
<span class="lineNum">   14459 </span><span class="lineCov">     257632 :   bool fixed_underlying_type_p </span>
<span class="lineNum">   14460 </span><span class="lineCov">     257632 :     = ENUM_UNDERLYING_TYPE (enumtype) != NULL_TREE;</span>
<span class="lineNum">   14461 </span>            : 
<span class="lineNum">   14462 </span>            :   /* We built up the VALUES in reverse order.  */
<span class="lineNum">   14463 </span><span class="lineCov">     772896 :   TYPE_VALUES (enumtype) = nreverse (TYPE_VALUES (enumtype));</span>
<span class="lineNum">   14464 </span>            : 
<span class="lineNum">   14465 </span>            :   /* For an enum defined in a template, just set the type of the values;
<span class="lineNum">   14466 </span>            :      all further processing is postponed until the template is
<span class="lineNum">   14467 </span>            :      instantiated.  We need to set the type so that tsubst of a CONST_DECL
<span class="lineNum">   14468 </span>            :      works.  */
<span class="lineNum">   14469 </span><span class="lineCov">     257632 :   if (processing_template_decl)</span>
<span class="lineNum">   14470 </span>            :     {
<span class="lineNum">   14471 </span><span class="lineCov">      32739 :       for (values = TYPE_VALUES (enumtype);</span>
<span class="lineNum">   14472 </span><span class="lineCov">      66879 :            values;</span>
<span class="lineNum">   14473 </span><span class="lineCov">      34140 :            values = TREE_CHAIN (values))</span>
<span class="lineNum">   14474 </span><span class="lineCov">      34140 :         TREE_TYPE (TREE_VALUE (values)) = enumtype;</span>
<span class="lineNum">   14475 </span>            :       return;
<span class="lineNum">   14476 </span>            :     }
<span class="lineNum">   14477 </span>            : 
<span class="lineNum">   14478 </span>            :   /* Determine the minimum and maximum values of the enumerators.  */
<span class="lineNum">   14479 </span><span class="lineCov">     224893 :   if (TYPE_VALUES (enumtype))</span>
<span class="lineNum">   14480 </span>            :     {
<span class="lineNum">   14481 </span>            :       minnode = maxnode = NULL_TREE;
<span class="lineNum">   14482 </span>            : 
<span class="lineNum">   14483 </span><span class="lineCov">    2025348 :       for (values = TYPE_VALUES (enumtype);</span>
<span class="lineNum">   14484 </span><span class="lineCov">    2249164 :            values;</span>
<span class="lineNum">   14485 </span><span class="lineCov">    2025348 :            values = TREE_CHAIN (values))</span>
<span class="lineNum">   14486 </span>            :         {
<span class="lineNum">   14487 </span><span class="lineCov">    2025348 :           decl = TREE_VALUE (values);</span>
<span class="lineNum">   14488 </span>            : 
<span class="lineNum">   14489 </span>            :           /* [dcl.enum]: Following the closing brace of an enum-specifier,
<span class="lineNum">   14490 </span>            :              each enumerator has the type of its enumeration.  Prior to the
<span class="lineNum">   14491 </span>            :              closing brace, the type of each enumerator is the type of its
<span class="lineNum">   14492 </span>            :              initializing value.  */
<span class="lineNum">   14493 </span><span class="lineCov">    2025348 :           TREE_TYPE (decl) = enumtype;</span>
<span class="lineNum">   14494 </span>            : 
<span class="lineNum">   14495 </span>            :           /* Update the minimum and maximum values, if appropriate.  */
<span class="lineNum">   14496 </span><span class="lineCov">    2025348 :           value = DECL_INITIAL (decl);</span>
<span class="lineNum">   14497 </span><span class="lineCov">    2025348 :           if (value == error_mark_node)</span>
<span class="lineNum">   14498 </span><span class="lineNoCov">          0 :             value = integer_zero_node;</span>
<span class="lineNum">   14499 </span>            :           /* Figure out what the minimum and maximum values of the
<span class="lineNum">   14500 </span>            :              enumerators are.  */
<span class="lineNum">   14501 </span><span class="lineCov">    2025348 :           if (!minnode)</span>
<span class="lineNum">   14502 </span>            :             minnode = maxnode = value;
<span class="lineNum">   14503 </span><span class="lineCov">    1801532 :           else if (tree_int_cst_lt (maxnode, value))</span>
<span class="lineNum">   14504 </span>            :             maxnode = value;
<span class="lineNum">   14505 </span><span class="lineCov">     117361 :           else if (tree_int_cst_lt (value, minnode))</span>
<span class="lineNum">   14506 </span><span class="lineCov">      11696 :             minnode = value;</span>
<span class="lineNum">   14507 </span>            :         }
<span class="lineNum">   14508 </span>            :     }
<span class="lineNum">   14509 </span>            :   else
<span class="lineNum">   14510 </span>            :     /* [dcl.enum]
<span class="lineNum">   14511 </span>            : 
<span class="lineNum">   14512 </span>            :        If the enumerator-list is empty, the underlying type is as if
<span class="lineNum">   14513 </span>            :        the enumeration had a single enumerator with value 0.  */
<span class="lineNum">   14514 </span><span class="lineCov">       1077 :     minnode = maxnode = integer_zero_node;</span>
<span class="lineNum">   14515 </span>            : 
<span class="lineNum">   14516 </span><span class="lineCov">     224893 :   if (!fixed_underlying_type_p)</span>
<span class="lineNum">   14517 </span>            :     {
<span class="lineNum">   14518 </span>            :       /* Compute the number of bits require to represent all values of the
<span class="lineNum">   14519 </span>            :          enumeration.  We must do this before the type of MINNODE and
<span class="lineNum">   14520 </span>            :          MAXNODE are transformed, since tree_int_cst_min_precision relies
<span class="lineNum">   14521 </span>            :          on the TREE_TYPE of the value it is passed.  */
<span class="lineNum">   14522 </span><span class="lineCov">     218190 :       signop sgn = tree_int_cst_sgn (minnode) &gt;= 0 ? UNSIGNED : SIGNED;</span>
<span class="lineNum">   14523 </span><span class="lineCov">     218190 :       int lowprec = tree_int_cst_min_precision (minnode, sgn);</span>
<span class="lineNum">   14524 </span><span class="lineCov">     218190 :       int highprec = tree_int_cst_min_precision (maxnode, sgn);</span>
<span class="lineNum">   14525 </span><span class="lineCov">     218190 :       int precision = MAX (lowprec, highprec);</span>
<span class="lineNum">   14526 </span><span class="lineCov">     218190 :       unsigned int itk;</span>
<span class="lineNum">   14527 </span><span class="lineCov">     218190 :       bool use_short_enum;</span>
<span class="lineNum">   14528 </span>            : 
<span class="lineNum">   14529 </span>            :       /* Determine the underlying type of the enumeration.
<span class="lineNum">   14530 </span>            : 
<span class="lineNum">   14531 </span>            :          [dcl.enum]
<span class="lineNum">   14532 </span>            : 
<span class="lineNum">   14533 </span>            :          The underlying type of an enumeration is an integral type that
<span class="lineNum">   14534 </span>            :          can represent all the enumerator values defined in the
<span class="lineNum">   14535 </span>            :          enumeration.  It is implementation-defined which integral type is
<span class="lineNum">   14536 </span>            :          used as the underlying type for an enumeration except that the
<span class="lineNum">   14537 </span>            :          underlying type shall not be larger than int unless the value of
<span class="lineNum">   14538 </span>            :          an enumerator cannot fit in an int or unsigned int.
<span class="lineNum">   14539 </span>            : 
<span class="lineNum">   14540 </span>            :          We use &quot;int&quot; or an &quot;unsigned int&quot; as the underlying type, even if
<span class="lineNum">   14541 </span>            :          a smaller integral type would work, unless the user has
<span class="lineNum">   14542 </span>            :          explicitly requested that we use the smallest possible type.  The
<span class="lineNum">   14543 </span>            :          user can request that for all enumerations with a command line
<span class="lineNum">   14544 </span>            :          flag, or for just one enumeration with an attribute.  */
<span class="lineNum">   14545 </span>            : 
<span class="lineNum">   14546 </span><span class="lineCov">     436380 :       use_short_enum = flag_short_enums</span>
<span class="lineNum">   14547 </span><span class="lineCov">     218190 :         || lookup_attribute (&quot;packed&quot;, TYPE_ATTRIBUTES (enumtype));</span>
<span class="lineNum">   14548 </span>            : 
<span class="lineNum">   14549 </span>            :       /* If the precision of the type was specified with an attribute and it
<span class="lineNum">   14550 </span>            :          was too small, give an error.  Otherwise, use it.  */
<span class="lineNum">   14551 </span><span class="lineCov">     218190 :       if (TYPE_PRECISION (enumtype))</span>
<span class="lineNum">   14552 </span>            :         {
<span class="lineNum">   14553 </span><span class="lineCov">         10 :           if (precision &gt; TYPE_PRECISION (enumtype))</span>
<span class="lineNum">   14554 </span><span class="lineNoCov">          0 :             error (&quot;specified mode too small for enumeral values&quot;);</span>
<span class="lineNum">   14555 </span>            :           else
<span class="lineNum">   14556 </span>            :             {
<span class="lineNum">   14557 </span>            :               use_short_enum = true;
<span class="lineNum">   14558 </span>            :               precision = TYPE_PRECISION (enumtype);
<span class="lineNum">   14559 </span>            :             }
<span class="lineNum">   14560 </span>            :         }
<span class="lineNum">   14561 </span>            : 
<span class="lineNum">   14562 </span><span class="lineCov">     649007 :       for (itk = (use_short_enum ? itk_char : itk_int);</span>
<span class="lineNum">   14563 </span><span class="lineCov">     430887 :            itk != itk_none;</span>
<span class="lineNum">   14564 </span>            :            itk++)
<span class="lineNum">   14565 </span>            :         {
<span class="lineNum">   14566 </span><span class="lineCov">     430884 :           underlying_type = integer_types[itk];</span>
<span class="lineNum">   14567 </span><span class="lineCov">     430884 :           if (underlying_type != NULL_TREE</span>
<span class="lineNum">   14568 </span><span class="lineCov">     430866 :               &amp;&amp; TYPE_PRECISION (underlying_type) &gt;= precision</span>
<span class="lineNum">   14569 </span><span class="lineCov">    1290250 :               &amp;&amp; TYPE_SIGN (underlying_type) == sgn)</span>
<span class="lineNum">   14570 </span>            :             break;
<span class="lineNum">   14571 </span>            :         }
<span class="lineNum">   14572 </span><span class="lineCov">     218190 :       if (itk == itk_none)</span>
<span class="lineNum">   14573 </span>            :         {
<span class="lineNum">   14574 </span>            :           /* DR 377
<span class="lineNum">   14575 </span>            : 
<span class="lineNum">   14576 </span>            :              IF no integral type can represent all the enumerator values, the
<span class="lineNum">   14577 </span>            :              enumeration is ill-formed.  */
<span class="lineNum">   14578 </span><span class="lineCov">          3 :           error (&quot;no integral type can represent all of the enumerator values &quot;</span>
<span class="lineNum">   14579 </span>            :                  &quot;for %qT&quot;, enumtype);
<span class="lineNum">   14580 </span><span class="lineCov">          3 :           precision = TYPE_PRECISION (long_long_integer_type_node);</span>
<span class="lineNum">   14581 </span><span class="lineCov">          3 :           underlying_type = integer_types[itk_unsigned_long_long];</span>
<span class="lineNum">   14582 </span>            :         }
<span class="lineNum">   14583 </span>            : 
<span class="lineNum">   14584 </span>            :       /* [dcl.enum]
<span class="lineNum">   14585 </span>            : 
<span class="lineNum">   14586 </span>            :          The value of sizeof() applied to an enumeration type, an object
<span class="lineNum">   14587 </span>            :          of an enumeration type, or an enumerator, is the value of sizeof()
<span class="lineNum">   14588 </span>            :          applied to the underlying type.  */
<span class="lineNum">   14589 </span><span class="lineCov">     218190 :       copy_type_enum (enumtype, underlying_type);</span>
<span class="lineNum">   14590 </span>            : 
<span class="lineNum">   14591 </span>            :       /* Compute the minimum and maximum values for the type.
<span class="lineNum">   14592 </span>            : 
<span class="lineNum">   14593 </span>            :          [dcl.enum]
<span class="lineNum">   14594 </span>            : 
<span class="lineNum">   14595 </span>            :          For an enumeration where emin is the smallest enumerator and emax
<span class="lineNum">   14596 </span>            :          is the largest, the values of the enumeration are the values of the
<span class="lineNum">   14597 </span>            :          underlying type in the range bmin to bmax, where bmin and bmax are,
<span class="lineNum">   14598 </span>            :          respectively, the smallest and largest values of the smallest bit-
<span class="lineNum">   14599 </span>            :          field that can store emin and emax.  */
<span class="lineNum">   14600 </span>            : 
<span class="lineNum">   14601 </span>            :       /* The middle-end currently assumes that types with TYPE_PRECISION
<span class="lineNum">   14602 </span>            :          narrower than their underlying type are suitably zero or sign
<span class="lineNum">   14603 </span>            :          extended to fill their mode.  Similarly, it assumes that the front
<span class="lineNum">   14604 </span>            :          end assures that a value of a particular type must be within
<span class="lineNum">   14605 </span>            :          TYPE_MIN_VALUE and TYPE_MAX_VALUE.
<span class="lineNum">   14606 </span>            : 
<span class="lineNum">   14607 </span>            :          We used to set these fields based on bmin and bmax, but that led
<span class="lineNum">   14608 </span>            :          to invalid assumptions like optimizing away bounds checking.  So
<span class="lineNum">   14609 </span>            :          now we just set the TYPE_PRECISION, TYPE_MIN_VALUE, and
<span class="lineNum">   14610 </span>            :          TYPE_MAX_VALUE to the values for the mode above and only restrict
<span class="lineNum">   14611 </span>            :          the ENUM_UNDERLYING_TYPE for the benefit of diagnostics.  */
<span class="lineNum">   14612 </span><span class="lineCov">     218190 :       ENUM_UNDERLYING_TYPE (enumtype)</span>
<span class="lineNum">   14613 </span><span class="lineCov">     218190 :         = build_distinct_type_copy (underlying_type);</span>
<span class="lineNum">   14614 </span><span class="lineCov">     218190 :       TYPE_PRECISION (ENUM_UNDERLYING_TYPE (enumtype)) = precision;</span>
<span class="lineNum">   14615 </span><span class="lineCov">     218190 :       set_min_and_max_values_for_integral_type</span>
<span class="lineNum">   14616 </span><span class="lineCov">     218190 :         (ENUM_UNDERLYING_TYPE (enumtype), precision, sgn);</span>
<span class="lineNum">   14617 </span>            : 
<span class="lineNum">   14618 </span>            :       /* If -fstrict-enums, still constrain TYPE_MIN/MAX_VALUE.  */
<span class="lineNum">   14619 </span><span class="lineCov">     218190 :       if (flag_strict_enums)</span>
<span class="lineNum">   14620 </span><span class="lineCov">         16 :         set_min_and_max_values_for_integral_type (enumtype, precision, sgn);</span>
<span class="lineNum">   14621 </span>            :     }
<span class="lineNum">   14622 </span>            :   else
<span class="lineNum">   14623 </span><span class="lineCov">       6703 :     underlying_type = ENUM_UNDERLYING_TYPE (enumtype);</span>
<span class="lineNum">   14624 </span>            : 
<span class="lineNum">   14625 </span>            :   /* Convert each of the enumerators to the type of the underlying
<span class="lineNum">   14626 </span>            :      type of the enumeration.  */
<span class="lineNum">   14627 </span><span class="lineCov">    2250241 :   for (values = TYPE_VALUES (enumtype); values; values = TREE_CHAIN (values))</span>
<span class="lineNum">   14628 </span>            :     {
<span class="lineNum">   14629 </span><span class="lineCov">    2025348 :       location_t saved_location;</span>
<span class="lineNum">   14630 </span>            : 
<span class="lineNum">   14631 </span><span class="lineCov">    2025348 :       decl = TREE_VALUE (values);</span>
<span class="lineNum">   14632 </span><span class="lineCov">    2025348 :       saved_location = input_location;</span>
<span class="lineNum">   14633 </span><span class="lineCov">    2025348 :       input_location = DECL_SOURCE_LOCATION (decl);</span>
<span class="lineNum">   14634 </span><span class="lineCov">    2025348 :       if (fixed_underlying_type_p)</span>
<span class="lineNum">   14635 </span>            :         /* If the enumeration type has a fixed underlying type, we
<span class="lineNum">   14636 </span>            :            already checked all of the enumerator values.  */
<span class="lineNum">   14637 </span><span class="lineCov">      91917 :         value = DECL_INITIAL (decl);</span>
<span class="lineNum">   14638 </span>            :       else
<span class="lineNum">   14639 </span><span class="lineCov">    3866862 :         value = perform_implicit_conversion (underlying_type,</span>
<span class="lineNum">   14640 </span><span class="lineCov">    1933431 :                                              DECL_INITIAL (decl),</span>
<span class="lineNum">   14641 </span>            :                                              tf_warning_or_error);
<span class="lineNum">   14642 </span><span class="lineCov">    2025348 :       input_location = saved_location;</span>
<span class="lineNum">   14643 </span>            : 
<span class="lineNum">   14644 </span>            :       /* Do not clobber shared ints.  */
<span class="lineNum">   14645 </span><span class="lineCov">    2025348 :       if (value != error_mark_node)</span>
<span class="lineNum">   14646 </span>            :         {
<span class="lineNum">   14647 </span><span class="lineCov">    2025348 :           value = copy_node (value);</span>
<span class="lineNum">   14648 </span>            : 
<span class="lineNum">   14649 </span><span class="lineCov">    2025348 :           TREE_TYPE (value) = enumtype;</span>
<span class="lineNum">   14650 </span>            :         }
<span class="lineNum">   14651 </span><span class="lineCov">    2025348 :       DECL_INITIAL (decl) = value;</span>
<span class="lineNum">   14652 </span>            :     }
<span class="lineNum">   14653 </span>            : 
<span class="lineNum">   14654 </span>            :   /* Fix up all variant types of this enum type.  */
<span class="lineNum">   14655 </span><span class="lineCov">     449789 :   for (t = TYPE_MAIN_VARIANT (enumtype); t; t = TYPE_NEXT_VARIANT (t))</span>
<span class="lineNum">   14656 </span><span class="lineCov">     224896 :     TYPE_VALUES (t) = TYPE_VALUES (enumtype);</span>
<span class="lineNum">   14657 </span>            : 
<span class="lineNum">   14658 </span><span class="lineCov">     224893 :   if (at_class_scope_p ()</span>
<span class="lineNum">   14659 </span><span class="lineCov">     158254 :       &amp;&amp; COMPLETE_TYPE_P (current_class_type)</span>
<span class="lineNum">   14660 </span><span class="lineCov">     224954 :       &amp;&amp; UNSCOPED_ENUM_P (enumtype))</span>
<span class="lineNum">   14661 </span>            :     {
<span class="lineNum">   14662 </span><span class="lineCov">         49 :       insert_late_enum_def_bindings (current_class_type, enumtype);</span>
<span class="lineNum">   14663 </span>            :       /* TYPE_FIELDS needs fixup.  */
<span class="lineNum">   14664 </span><span class="lineCov">         49 :       fixup_type_variants (current_class_type);</span>
<span class="lineNum">   14665 </span>            :     }
<span class="lineNum">   14666 </span>            : 
<span class="lineNum">   14667 </span>            :   /* Finish debugging output for this type.  */
<span class="lineNum">   14668 </span><span class="lineCov">     224893 :   rest_of_type_compilation (enumtype, namespace_bindings_p ());</span>
<span class="lineNum">   14669 </span>            : 
<span class="lineNum">   14670 </span>            :   /* Each enumerator now has the type of its enumeration.  Clear the cache
<span class="lineNum">   14671 </span>            :      so that this change in types doesn't confuse us later on.  */
<span class="lineNum">   14672 </span><span class="lineCov">     224893 :   clear_cv_and_fold_caches ();</span>
<span class="lineNum">   14673 </span>            : }
<span class="lineNum">   14674 </span>            : 
<span class="lineNum">   14675 </span>            : /* Finishes the enum type. This is called only the first time an
<span class="lineNum">   14676 </span>            :    enumeration is seen, be it opaque or odinary.
<span class="lineNum">   14677 </span>            :    ENUMTYPE is the type object.  */
<a name="14678"><span class="lineNum">   14678 </span>            : </a>
<span class="lineNum">   14679 </span>            : void
<span class="lineNum">   14680 </span><span class="lineCov">     258968 : finish_enum (tree enumtype)</span>
<span class="lineNum">   14681 </span>            : {
<span class="lineNum">   14682 </span><span class="lineCov">     258968 :   if (processing_template_decl)</span>
<span class="lineNum">   14683 </span>            :     {
<span class="lineNum">   14684 </span><span class="lineCov">      32759 :       if (at_function_scope_p ())</span>
<span class="lineNum">   14685 </span><span class="lineCov">        195 :         add_stmt (build_min (TAG_DEFN, enumtype));</span>
<span class="lineNum">   14686 </span><span class="lineCov">      32759 :       return;</span>
<span class="lineNum">   14687 </span>            :     }
<span class="lineNum">   14688 </span>            : 
<span class="lineNum">   14689 </span>            :   /* If this is a forward declaration, there should not be any variants,
<span class="lineNum">   14690 </span>            :      though we can get a variant in the middle of an enum-specifier with
<span class="lineNum">   14691 </span>            :      wacky code like 'enum E { e = sizeof(const E*) };'  */
<span class="lineNum">   14692 </span><span class="lineCov">     226209 :   gcc_assert (enumtype == TYPE_MAIN_VARIANT (enumtype)</span>
<span class="lineNum">   14693 </span>            :               &amp;&amp; (TYPE_VALUES (enumtype)
<span class="lineNum">   14694 </span>            :                   || !TYPE_NEXT_VARIANT (enumtype)));
<span class="lineNum">   14695 </span>            : }
<span class="lineNum">   14696 </span>            : 
<span class="lineNum">   14697 </span>            : /* Build and install a CONST_DECL for an enumeration constant of the
<span class="lineNum">   14698 </span>            :    enumeration type ENUMTYPE whose NAME and VALUE (if any) are provided.
<span class="lineNum">   14699 </span>            :    Apply ATTRIBUTES if available.  LOC is the location of NAME.
<span class="lineNum">   14700 </span>            :    Assignment of sequential values by default is handled here.  */
<a name="14701"><span class="lineNum">   14701 </span>            : </a>
<span class="lineNum">   14702 </span>            : void
<span class="lineNum">   14703 </span><span class="lineCov">    2059480 : build_enumerator (tree name, tree value, tree enumtype, tree attributes,</span>
<span class="lineNum">   14704 </span>            :                   location_t loc)
<span class="lineNum">   14705 </span>            : {
<span class="lineNum">   14706 </span><span class="lineCov">    2059480 :   tree decl;</span>
<span class="lineNum">   14707 </span><span class="lineCov">    2059480 :   tree context;</span>
<span class="lineNum">   14708 </span><span class="lineCov">    2059480 :   tree type;</span>
<span class="lineNum">   14709 </span>            : 
<span class="lineNum">   14710 </span>            :   /* scalar_constant_value will pull out this expression, so make sure
<span class="lineNum">   14711 </span>            :      it's folded as appropriate.  */
<span class="lineNum">   14712 </span><span class="lineCov">    2059480 :   if (processing_template_decl)</span>
<span class="lineNum">   14713 </span><span class="lineCov">      34140 :     value = fold_non_dependent_expr (value);</span>
<span class="lineNum">   14714 </span>            : 
<span class="lineNum">   14715 </span>            :   /* If the VALUE was erroneous, pretend it wasn't there; that will
<span class="lineNum">   14716 </span>            :      result in the enum being assigned the next value in sequence.  */
<span class="lineNum">   14717 </span><span class="lineCov">    2059480 :   if (value == error_mark_node)</span>
<span class="lineNum">   14718 </span>            :     value = NULL_TREE;
<span class="lineNum">   14719 </span>            : 
<span class="lineNum">   14720 </span>            :   /* Remove no-op casts from the value.  */
<span class="lineNum">   14721 </span><span class="lineCov">    2059451 :   if (value)</span>
<span class="lineNum">   14722 </span><span class="lineCov">     470874 :     STRIP_TYPE_NOPS (value);</span>
<span class="lineNum">   14723 </span>            : 
<span class="lineNum">   14724 </span><span class="lineCov">    2059480 :   if (! processing_template_decl)</span>
<span class="lineNum">   14725 </span>            :     {
<span class="lineNum">   14726 </span>            :       /* Validate and default VALUE.  */
<span class="lineNum">   14727 </span><span class="lineCov">    2025340 :       if (value != NULL_TREE)</span>
<span class="lineNum">   14728 </span>            :         {
<span class="lineNum">   14729 </span><span class="lineCov">     437664 :           if (!ENUM_UNDERLYING_TYPE (enumtype))</span>
<span class="lineNum">   14730 </span>            :             {
<span class="lineNum">   14731 </span><span class="lineCov">     354117 :               tree tmp_value = build_expr_type_conversion (WANT_INT | WANT_ENUM,</span>
<span class="lineNum">   14732 </span>            :                                                            value, true);
<span class="lineNum">   14733 </span><span class="lineCov">     354117 :               if (tmp_value)</span>
<span class="lineNum">   14734 </span><span class="lineCov">     354106 :                 value = tmp_value;</span>
<span class="lineNum">   14735 </span>            :             }
<span class="lineNum">   14736 </span><span class="lineCov">      83547 :           else if (! INTEGRAL_OR_UNSCOPED_ENUMERATION_TYPE_P</span>
<span class="lineNum">   14737 </span>            :                    (TREE_TYPE (value)))
<span class="lineNum">   14738 </span><span class="lineCov">         52 :             value = perform_implicit_conversion_flags</span>
<span class="lineNum">   14739 </span><span class="lineCov">         78 :               (ENUM_UNDERLYING_TYPE (enumtype), value, tf_warning_or_error,</span>
<span class="lineNum">   14740 </span>            :                LOOKUP_IMPLICIT | LOOKUP_NO_NARROWING);
<span class="lineNum">   14741 </span>            : 
<span class="lineNum">   14742 </span><span class="lineCov">     437664 :           if (value == error_mark_node)</span>
<span class="lineNum">   14743 </span>            :             value = NULL_TREE;
<span class="lineNum">   14744 </span>            : 
<span class="lineNum">   14745 </span><span class="lineCov">     437650 :           if (value != NULL_TREE)</span>
<span class="lineNum">   14746 </span>            :             {
<span class="lineNum">   14747 </span><span class="lineCov">     437650 :               if (! INTEGRAL_OR_UNSCOPED_ENUMERATION_TYPE_P</span>
<span class="lineNum">   14748 </span>            :                   (TREE_TYPE (value)))
<span class="lineNum">   14749 </span>            :                 {
<span class="lineNum">   14750 </span><span class="lineCov">         13 :                   error (&quot;enumerator value for %qD must have integral or &quot;</span>
<span class="lineNum">   14751 </span>            :                          &quot;unscoped enumeration type&quot;, name);
<span class="lineNum">   14752 </span><span class="lineCov">         13 :                   value = NULL_TREE;</span>
<span class="lineNum">   14753 </span>            :                 }
<span class="lineNum">   14754 </span>            :               else
<span class="lineNum">   14755 </span>            :                 {
<span class="lineNum">   14756 </span><span class="lineCov">     437637 :                   value = cxx_constant_value (value);</span>
<span class="lineNum">   14757 </span>            : 
<span class="lineNum">   14758 </span><span class="lineCov">     437637 :                   if (TREE_CODE (value) != INTEGER_CST)</span>
<span class="lineNum">   14759 </span>            :                     {
<span class="lineNum">   14760 </span><span class="lineCov">         35 :                       error (&quot;enumerator value for %qD is not an integer &quot;</span>
<span class="lineNum">   14761 </span>            :                              &quot;constant&quot;, name);
<span class="lineNum">   14762 </span><span class="lineCov">         35 :                       value = NULL_TREE;</span>
<span class="lineNum">   14763 </span>            :                     }
<span class="lineNum">   14764 </span>            :                 }
<span class="lineNum">   14765 </span>            :             }
<span class="lineNum">   14766 </span>            :         }
<span class="lineNum">   14767 </span>            : 
<span class="lineNum">   14768 </span>            :       /* Default based on previous value.  */
<span class="lineNum">   14769 </span><span class="lineCov">    2025340 :       if (value == NULL_TREE)</span>
<span class="lineNum">   14770 </span>            :         {
<span class="lineNum">   14771 </span><span class="lineCov">    1587738 :           if (TYPE_VALUES (enumtype))</span>
<span class="lineNum">   14772 </span>            :             {
<span class="lineNum">   14773 </span><span class="lineCov">    1536122 :               tree prev_value;</span>
<span class="lineNum">   14774 </span>            : 
<span class="lineNum">   14775 </span>            :               /* C++03 7.2/4: If no initializer is specified for the first
<span class="lineNum">   14776 </span>            :                  enumerator, the type is an unspecified integral
<span class="lineNum">   14777 </span>            :                  type. Otherwise the type is the same as the type of the
<span class="lineNum">   14778 </span>            :                  initializing value of the preceding enumerator unless the
<span class="lineNum">   14779 </span>            :                  incremented value is not representable in that type, in
<span class="lineNum">   14780 </span>            :                  which case the type is an unspecified integral type
<span class="lineNum">   14781 </span>            :                  sufficient to contain the incremented value.  */
<span class="lineNum">   14782 </span><span class="lineCov">    3072244 :               prev_value = DECL_INITIAL (TREE_VALUE (TYPE_VALUES (enumtype)));</span>
<span class="lineNum">   14783 </span><span class="lineCov">    1536122 :               if (error_operand_p (prev_value))</span>
<span class="lineNum">   14784 </span>            :                 value = error_mark_node;
<span class="lineNum">   14785 </span>            :               else
<span class="lineNum">   14786 </span>            :                 {
<span class="lineNum">   14787 </span><span class="lineCov">    1536122 :                   wi::overflow_type overflowed;</span>
<span class="lineNum">   14788 </span><span class="lineCov">    1536122 :                   tree type = TREE_TYPE (prev_value);</span>
<span class="lineNum">   14789 </span><span class="lineCov">    1536122 :                   signop sgn = TYPE_SIGN (type);</span>
<span class="lineNum">   14790 </span><span class="lineCov">    1536122 :                   widest_int wi = wi::add (wi::to_widest (prev_value), 1, sgn,</span>
<span class="lineNum">   14791 </span><span class="lineCov">    1536122 :                                            &amp;overflowed);</span>
<span class="lineNum">   14792 </span><span class="lineCov">    1536122 :                   if (!overflowed)</span>
<span class="lineNum">   14793 </span>            :                     {
<span class="lineNum">   14794 </span><span class="lineCov">    1536122 :                       bool pos = !wi::neg_p (wi, sgn);</span>
<span class="lineNum">   14795 </span><span class="lineCov">    1536122 :                       if (!wi::fits_to_tree_p (wi, type))</span>
<span class="lineNum">   14796 </span>            :                         {
<span class="lineNum">   14797 </span>            :                           unsigned int itk;
<span class="lineNum">   14798 </span><span class="lineCov">         50 :                           for (itk = itk_int; itk != itk_none; itk++)</span>
<span class="lineNum">   14799 </span>            :                             {
<span class="lineNum">   14800 </span><span class="lineCov">         50 :                               type = integer_types[itk];</span>
<span class="lineNum">   14801 </span><span class="lineCov">         50 :                               if (type != NULL_TREE</span>
<span class="lineNum">   14802 </span><span class="lineCov">         50 :                                   &amp;&amp; (pos || !TYPE_UNSIGNED (type))</span>
<span class="lineNum">   14803 </span><span class="lineCov">        100 :                                   &amp;&amp; wi::fits_to_tree_p (wi, type))</span>
<span class="lineNum">   14804 </span>            :                                 break;
<span class="lineNum">   14805 </span>            :                             }
<span class="lineNum">   14806 </span><span class="lineCov">         16 :                           if (type &amp;&amp; cxx_dialect &lt; cxx11</span>
<span class="lineNum">   14807 </span><span class="lineCov">          6 :                               &amp;&amp; itk &gt; itk_unsigned_long)</span>
<span class="lineNum">   14808 </span><span class="lineCov">          3 :                             pedwarn (input_location, OPT_Wlong_long,</span>
<span class="lineNum">   14809 </span>            :                                      pos ? G_(&quot;\
<span class="lineNum">   14810 </span>            : incremented enumerator value is too large for %&lt;unsigned long%&gt;&quot;) : G_(&quot;\
<span class="lineNum">   14811 </span>            : incremented enumerator value is too large for %&lt;long%&gt;&quot;));
<span class="lineNum">   14812 </span>            :                         }
<span class="lineNum">   14813 </span><span class="lineCov">    1536122 :                       if (type == NULL_TREE)</span>
<span class="lineNum">   14814 </span><span class="lineNoCov">          0 :                         overflowed = wi::OVF_UNKNOWN;</span>
<span class="lineNum">   14815 </span>            :                       else
<span class="lineNum">   14816 </span><span class="lineCov">    3072244 :                         value = wide_int_to_tree (type, wi);</span>
<span class="lineNum">   14817 </span>            :                     }
<span class="lineNum">   14818 </span>            : 
<span class="lineNum">   14819 </span><span class="lineCov">    1536122 :                   if (overflowed)</span>
<span class="lineNum">   14820 </span>            :                     {
<span class="lineNum">   14821 </span><span class="lineNoCov">          0 :                       error (&quot;overflow in enumeration values at %qD&quot;, name);</span>
<span class="lineNum">   14822 </span><span class="lineNoCov">          0 :                       value = error_mark_node;</span>
<span class="lineNum">   14823 </span>            :                     }
<span class="lineNum">   14824 </span>            :                 }
<span class="lineNum">   14825 </span>            :             }
<span class="lineNum">   14826 </span>            :           else
<span class="lineNum">   14827 </span><span class="lineCov">      51616 :             value = integer_zero_node;</span>
<span class="lineNum">   14828 </span>            :         }
<span class="lineNum">   14829 </span>            : 
<span class="lineNum">   14830 </span>            :       /* Remove no-op casts from the value.  */
<span class="lineNum">   14831 </span><span class="lineCov">    2025340 :       STRIP_TYPE_NOPS (value);</span>
<span class="lineNum">   14832 </span>            : 
<span class="lineNum">   14833 </span>            :       /* If the underlying type of the enum is fixed, check whether
<span class="lineNum">   14834 </span>            :          the enumerator values fits in the underlying type.  If it
<span class="lineNum">   14835 </span>            :          does not fit, the program is ill-formed [C++0x dcl.enum].  */
<span class="lineNum">   14836 </span><span class="lineCov">    2025340 :       if (ENUM_UNDERLYING_TYPE (enumtype)</span>
<span class="lineNum">   14837 </span>            :           &amp;&amp; value
<span class="lineNum">   14838 </span><span class="lineCov">    2025340 :           &amp;&amp; TREE_CODE (value) == INTEGER_CST)</span>
<span class="lineNum">   14839 </span>            :         {
<span class="lineNum">   14840 </span><span class="lineCov">     275727 :           if (!int_fits_type_p (value, ENUM_UNDERLYING_TYPE (enumtype)))</span>
<span class="lineNum">   14841 </span><span class="lineCov">         12 :             error (&quot;enumerator value %qE is outside the range of underlying &quot;</span>
<span class="lineNum">   14842 </span><span class="lineCov">          6 :                    &quot;type %qT&quot;, value, ENUM_UNDERLYING_TYPE (enumtype));</span>
<span class="lineNum">   14843 </span>            : 
<span class="lineNum">   14844 </span>            :           /* Convert the value to the appropriate type.  */
<span class="lineNum">   14845 </span><span class="lineCov">      91909 :           value = fold_convert (ENUM_UNDERLYING_TYPE (enumtype), value);</span>
<span class="lineNum">   14846 </span>            :         }
<span class="lineNum">   14847 </span>            :     }
<span class="lineNum">   14848 </span>            : 
<span class="lineNum">   14849 </span>            :   /* C++ associates enums with global, function, or class declarations.  */
<span class="lineNum">   14850 </span><span class="lineCov">    2059480 :   context = current_scope ();</span>
<span class="lineNum">   14851 </span>            : 
<span class="lineNum">   14852 </span>            :   /* Build the actual enumeration constant.  Note that the enumeration
<span class="lineNum">   14853 </span>            :      constants have the underlying type of the enum (if it is fixed)
<span class="lineNum">   14854 </span>            :      or the type of their initializer (if the underlying type of the
<span class="lineNum">   14855 </span>            :      enum is not fixed):
<span class="lineNum">   14856 </span>            : 
<span class="lineNum">   14857 </span>            :       [ C++0x dcl.enum ]
<span class="lineNum">   14858 </span>            : 
<span class="lineNum">   14859 </span>            :         If the underlying type is fixed, the type of each enumerator
<span class="lineNum">   14860 </span>            :         prior to the closing brace is the underlying type; if the
<span class="lineNum">   14861 </span>            :         initializing value of an enumerator cannot be represented by
<span class="lineNum">   14862 </span>            :         the underlying type, the program is ill-formed. If the
<span class="lineNum">   14863 </span>            :         underlying type is not fixed, the type of each enumerator is
<span class="lineNum">   14864 </span>            :         the type of its initializing value.
<span class="lineNum">   14865 </span>            : 
<span class="lineNum">   14866 </span>            :     If the underlying type is not fixed, it will be computed by
<span class="lineNum">   14867 </span>            :     finish_enum and we will reset the type of this enumerator.  Of
<span class="lineNum">   14868 </span>            :     course, if we're processing a template, there may be no value.  */
<span class="lineNum">   14869 </span><span class="lineCov">    2059480 :   type = value ? TREE_TYPE (value) : NULL_TREE;</span>
<span class="lineNum">   14870 </span>            : 
<span class="lineNum">   14871 </span><span class="lineCov">    2059480 :   decl = build_decl (loc, CONST_DECL, name, type);</span>
<span class="lineNum">   14872 </span>            :   
<span class="lineNum">   14873 </span><span class="lineCov">    2059480 :   DECL_CONTEXT (decl) = enumtype;</span>
<span class="lineNum">   14874 </span><span class="lineCov">    2059480 :   TREE_CONSTANT (decl) = 1;</span>
<span class="lineNum">   14875 </span><span class="lineCov">    2059480 :   TREE_READONLY (decl) = 1;</span>
<span class="lineNum">   14876 </span><span class="lineCov">    2059480 :   DECL_INITIAL (decl) = value;</span>
<span class="lineNum">   14877 </span>            : 
<span class="lineNum">   14878 </span><span class="lineCov">    2059480 :   if (attributes)</span>
<span class="lineNum">   14879 </span><span class="lineCov">         47 :     cplus_decl_attributes (&amp;decl, attributes, 0);</span>
<span class="lineNum">   14880 </span>            : 
<span class="lineNum">   14881 </span><span class="lineCov">    2059480 :   if (context &amp;&amp; context == current_class_type &amp;&amp; !SCOPED_ENUM_P (enumtype))</span>
<span class="lineNum">   14882 </span>            :     {
<span class="lineNum">   14883 </span>            :       /* In something like `struct S { enum E { i = 7 }; };' we put `i'
<span class="lineNum">   14884 </span>            :          on the TYPE_FIELDS list for `S'.  (That's so that you can say
<span class="lineNum">   14885 </span>            :          things like `S::i' later.)  */
<span class="lineNum">   14886 </span>            : 
<span class="lineNum">   14887 </span>            :       /* The enumerator may be getting declared outside of its enclosing
<span class="lineNum">   14888 </span>            :          class, like so:
<span class="lineNum">   14889 </span>            : 
<span class="lineNum">   14890 </span>            :            class S { public: enum E : int; }; enum S::E : int { i = 7; };
<span class="lineNum">   14891 </span>            : 
<span class="lineNum">   14892 </span>            :          For which case we need to make sure that the access of `S::i'
<span class="lineNum">   14893 </span>            :          matches the access of `S::E'.  */
<span class="lineNum">   14894 </span><span class="lineCov">     226042 :       tree saved_cas = current_access_specifier;</span>
<span class="lineNum">   14895 </span><span class="lineCov">     226042 :       if (TREE_PRIVATE (TYPE_NAME (enumtype)))</span>
<span class="lineNum">   14896 </span><span class="lineCov">      14096 :         current_access_specifier = access_private_node;</span>
<span class="lineNum">   14897 </span><span class="lineCov">     423892 :       else if (TREE_PROTECTED (TYPE_NAME (enumtype)))</span>
<span class="lineNum">   14898 </span><span class="lineCov">       4420 :         current_access_specifier = access_protected_node;</span>
<span class="lineNum">   14899 </span>            :       else
<span class="lineNum">   14900 </span><span class="lineCov">     207526 :         current_access_specifier = access_public_node;</span>
<span class="lineNum">   14901 </span>            : 
<span class="lineNum">   14902 </span><span class="lineCov">     226042 :       finish_member_declaration (decl);</span>
<span class="lineNum">   14903 </span>            : 
<span class="lineNum">   14904 </span><span class="lineCov">     226042 :       current_access_specifier = saved_cas;</span>
<span class="lineNum">   14905 </span>            :     }
<span class="lineNum">   14906 </span>            :   else
<span class="lineNum">   14907 </span><span class="lineCov">    1833438 :     pushdecl (decl);</span>
<span class="lineNum">   14908 </span>            : 
<span class="lineNum">   14909 </span>            :   /* Add this enumeration constant to the list for this type.  */
<span class="lineNum">   14910 </span><span class="lineCov">    2059480 :   TYPE_VALUES (enumtype) = tree_cons (name, decl, TYPE_VALUES (enumtype));</span>
<span class="lineNum">   14911 </span><span class="lineCov">    2059480 : }</span>
<span class="lineNum">   14912 </span>            : 
<span class="lineNum">   14913 </span>            : /* Look for an enumerator with the given NAME within the enumeration
<span class="lineNum">   14914 </span>            :    type ENUMTYPE.  This routine is used primarily for qualified name
<span class="lineNum">   14915 </span>            :    lookup into an enumerator in C++0x, e.g.,
<span class="lineNum">   14916 </span>            : 
<span class="lineNum">   14917 </span>            :      enum class Color { Red, Green, Blue };
<span class="lineNum">   14918 </span>            : 
<span class="lineNum">   14919 </span>            :      Color color = Color::Red;
<span class="lineNum">   14920 </span>            : 
<span class="lineNum">   14921 </span>            :    Returns the value corresponding to the enumerator, or
<a name="14922"><span class="lineNum">   14922 </span>            :    NULL_TREE if no such enumerator was found.  */</a>
<span class="lineNum">   14923 </span>            : tree
<span class="lineNum">   14924 </span><span class="lineCov">      79577 : lookup_enumerator (tree enumtype, tree name)</span>
<span class="lineNum">   14925 </span>            : {
<span class="lineNum">   14926 </span><span class="lineCov">      79577 :   tree e;</span>
<span class="lineNum">   14927 </span><span class="lineCov">      79577 :   gcc_assert (enumtype &amp;&amp; TREE_CODE (enumtype) == ENUMERAL_TYPE);</span>
<span class="lineNum">   14928 </span>            : 
<span class="lineNum">   14929 </span><span class="lineCov">     159154 :   e = purpose_member (name, TYPE_VALUES (enumtype));</span>
<span class="lineNum">   14930 </span><span class="lineCov">      79577 :   return e? TREE_VALUE (e) : NULL_TREE;</span>
<span class="lineNum">   14931 </span>            : }
<span class="lineNum">   14932 </span>            : 
<span class="lineNum">   14933 </span>            : 
<span class="lineNum">   14934 </span>            : /* We're defining DECL.  Make sure that its type is OK.  */
<a name="14935"><span class="lineNum">   14935 </span>            : </a>
<span class="lineNum">   14936 </span>            : static void
<span class="lineNum">   14937 </span><span class="lineCov">   15923054 : check_function_type (tree decl, tree current_function_parms)</span>
<span class="lineNum">   14938 </span>            : {
<span class="lineNum">   14939 </span><span class="lineCov">   15923054 :   tree fntype = TREE_TYPE (decl);</span>
<span class="lineNum">   14940 </span><span class="lineCov">   15923054 :   tree return_type = complete_type (TREE_TYPE (fntype));</span>
<span class="lineNum">   14941 </span>            : 
<span class="lineNum">   14942 </span>            :   /* In a function definition, arg types must be complete.  */
<span class="lineNum">   14943 </span><span class="lineCov">   15923054 :   require_complete_types_for_parms (current_function_parms);</span>
<span class="lineNum">   14944 </span>            : 
<span class="lineNum">   14945 </span><span class="lineCov">   15923054 :   if (dependent_type_p (return_type)</span>
<span class="lineNum">   14946 </span><span class="lineCov">   15923054 :       || type_uses_auto (return_type))</span>
<span class="lineNum">   14947 </span><span class="lineCov">    1773630 :     return;</span>
<span class="lineNum">   14948 </span><span class="lineCov">   14149424 :   if (!COMPLETE_OR_VOID_TYPE_P (return_type))</span>
<span class="lineNum">   14949 </span>            :     {
<span class="lineNum">   14950 </span><span class="lineCov">         11 :       tree args = TYPE_ARG_TYPES (fntype);</span>
<span class="lineNum">   14951 </span>            : 
<span class="lineNum">   14952 </span><span class="lineCov">         11 :       error (&quot;return type %q#T is incomplete&quot;, return_type);</span>
<span class="lineNum">   14953 </span>            : 
<span class="lineNum">   14954 </span>            :       /* Make it return void instead.  */
<span class="lineNum">   14955 </span><span class="lineCov">         11 :       if (TREE_CODE (fntype) == METHOD_TYPE)</span>
<span class="lineNum">   14956 </span><span class="lineCov">          3 :         fntype = build_method_type_directly (TREE_TYPE (TREE_VALUE (args)),</span>
<span class="lineNum">   14957 </span>            :                                              void_type_node,
<span class="lineNum">   14958 </span><span class="lineCov">          3 :                                              TREE_CHAIN (args));</span>
<span class="lineNum">   14959 </span>            :       else
<span class="lineNum">   14960 </span><span class="lineCov">          8 :         fntype = build_function_type (void_type_node, args);</span>
<span class="lineNum">   14961 </span><span class="lineCov">         22 :       fntype = (cp_build_type_attribute_variant</span>
<span class="lineNum">   14962 </span><span class="lineCov">         11 :                 (fntype, TYPE_ATTRIBUTES (TREE_TYPE (decl))));</span>
<span class="lineNum">   14963 </span><span class="lineCov">         11 :       fntype = cxx_copy_lang_qualifiers (fntype, TREE_TYPE (decl));</span>
<span class="lineNum">   14964 </span><span class="lineCov">         11 :       TREE_TYPE (decl) = fntype;</span>
<span class="lineNum">   14965 </span>            :     }
<span class="lineNum">   14966 </span>            :   else
<span class="lineNum">   14967 </span>            :     {
<span class="lineNum">   14968 </span><span class="lineCov">   14149413 :       abstract_virtuals_error (decl, TREE_TYPE (fntype));</span>
<span class="lineNum">   14969 </span><span class="lineCov">   14149413 :       maybe_warn_parm_abi (TREE_TYPE (fntype),</span>
<span class="lineNum">   14970 </span><span class="lineCov">   14149413 :                            DECL_SOURCE_LOCATION (decl));</span>
<span class="lineNum">   14971 </span>            :     }
<span class="lineNum">   14972 </span>            : }
<span class="lineNum">   14973 </span>            : 
<span class="lineNum">   14974 </span>            : /* True iff FN is an implicitly-defined default constructor.  */
<a name="14975"><span class="lineNum">   14975 </span>            : </a>
<span class="lineNum">   14976 </span>            : static bool
<span class="lineNum">   14977 </span><span class="lineCov">    1083937 : implicit_default_ctor_p (tree fn)</span>
<span class="lineNum">   14978 </span>            : {
<span class="lineNum">   14979 </span><span class="lineCov">    1083937 :   return (DECL_CONSTRUCTOR_P (fn)</span>
<span class="lineNum">   14980 </span><span class="lineCov">    1083937 :           &amp;&amp; !user_provided_p (fn)</span>
<span class="lineNum">   14981 </span><span class="lineCov">    1255971 :           &amp;&amp; sufficient_parms_p (FUNCTION_FIRST_USER_PARMTYPE (fn)));</span>
<span class="lineNum">   14982 </span>            : }
<span class="lineNum">   14983 </span>            : 
<span class="lineNum">   14984 </span>            : /* Clobber the contents of *this to let the back end know that the object
<span class="lineNum">   14985 </span>            :    storage is dead when we enter the constructor or leave the destructor.  */
<a name="14986"><span class="lineNum">   14986 </span>            : </a>
<span class="lineNum">   14987 </span>            : static tree
<span class="lineNum">   14988 </span><span class="lineCov">    1460472 : build_clobber_this ()</span>
<span class="lineNum">   14989 </span>            : {
<span class="lineNum">   14990 </span>            :   /* Clobbering an empty base is pointless, and harmful if its one byte
<span class="lineNum">   14991 </span>            :      TYPE_SIZE overlays real data.  */
<span class="lineNum">   14992 </span><span class="lineCov">    1460472 :   if (is_empty_class (current_class_type))</span>
<span class="lineNum">   14993 </span><span class="lineNoCov">          0 :     return void_node;</span>
<span class="lineNum">   14994 </span>            : 
<span class="lineNum">   14995 </span>            :   /* If we have virtual bases, clobber the whole object, but only if we're in
<span class="lineNum">   14996 </span>            :      charge.  If we don't have virtual bases, clobber the as-base type so we
<span class="lineNum">   14997 </span>            :      don't mess with tail padding.  */
<span class="lineNum">   14998 </span><span class="lineCov">    1460472 :   bool vbases = CLASSTYPE_VBASECLASSES (current_class_type);</span>
<span class="lineNum">   14999 </span>            : 
<span class="lineNum">   15000 </span><span class="lineCov">    1460472 :   tree ctype = current_class_type;</span>
<span class="lineNum">   15001 </span><span class="lineCov">    1460472 :   if (!vbases)</span>
<span class="lineNum">   15002 </span><span class="lineCov">    2903226 :     ctype = CLASSTYPE_AS_BASE (ctype);</span>
<span class="lineNum">   15003 </span>            : 
<span class="lineNum">   15004 </span><span class="lineCov">    1460472 :   tree clobber = build_clobber (ctype);</span>
<span class="lineNum">   15005 </span>            : 
<span class="lineNum">   15006 </span><span class="lineCov">    1460472 :   tree thisref = current_class_ref;</span>
<span class="lineNum">   15007 </span><span class="lineCov">    1460472 :   if (ctype != current_class_type)</span>
<span class="lineNum">   15008 </span>            :     {
<span class="lineNum">   15009 </span><span class="lineCov">    1451609 :       thisref = build_nop (build_reference_type (ctype), current_class_ptr);</span>
<span class="lineNum">   15010 </span><span class="lineCov">    1451609 :       thisref = convert_from_reference (thisref);</span>
<span class="lineNum">   15011 </span>            :     }
<span class="lineNum">   15012 </span>            : 
<span class="lineNum">   15013 </span><span class="lineCov">    1460472 :   tree exprstmt = build2 (MODIFY_EXPR, void_type_node, thisref, clobber);</span>
<span class="lineNum">   15014 </span><span class="lineCov">    1460472 :   if (vbases)</span>
<span class="lineNum">   15015 </span><span class="lineCov">       8859 :     exprstmt = build_if_in_charge (exprstmt);</span>
<span class="lineNum">   15016 </span>            : 
<span class="lineNum">   15017 </span>            :   return exprstmt;
<span class="lineNum">   15018 </span>            : }
<span class="lineNum">   15019 </span>            : 
<span class="lineNum">   15020 </span>            : /* Create the FUNCTION_DECL for a function definition.
<span class="lineNum">   15021 </span>            :    DECLSPECS and DECLARATOR are the parts of the declaration;
<span class="lineNum">   15022 </span>            :    they describe the function's name and the type it returns,
<span class="lineNum">   15023 </span>            :    but twisted together in a fashion that parallels the syntax of C.
<span class="lineNum">   15024 </span>            : 
<span class="lineNum">   15025 </span>            :    FLAGS is a bitwise or of SF_PRE_PARSED (indicating that the
<span class="lineNum">   15026 </span>            :    DECLARATOR is really the DECL for the function we are about to
<span class="lineNum">   15027 </span>            :    process and that DECLSPECS should be ignored), SF_INCLASS_INLINE
<span class="lineNum">   15028 </span>            :    indicating that the function is an inline defined in-class.
<span class="lineNum">   15029 </span>            : 
<span class="lineNum">   15030 </span>            :    This function creates a binding context for the function body
<span class="lineNum">   15031 </span>            :    as well as setting up the FUNCTION_DECL in current_function_decl.
<span class="lineNum">   15032 </span>            : 
<span class="lineNum">   15033 </span>            :    For C++, we must first check whether that datum makes any sense.
<span class="lineNum">   15034 </span>            :    For example, &quot;class A local_a(1,2);&quot; means that variable local_a
<span class="lineNum">   15035 </span>            :    is an aggregate of type A, which should have a constructor
<span class="lineNum">   15036 </span>            :    applied to it with the argument list [1, 2].
<span class="lineNum">   15037 </span>            : 
<span class="lineNum">   15038 </span>            :    On entry, DECL_INITIAL (decl1) should be NULL_TREE or error_mark_node,
<span class="lineNum">   15039 </span>            :    or may be a BLOCK if the function has been defined previously
<span class="lineNum">   15040 </span>            :    in this translation unit.  On exit, DECL_INITIAL (decl1) will be
<span class="lineNum">   15041 </span>            :    error_mark_node if the function has never been defined, or
<span class="lineNum">   15042 </span>            :    a BLOCK if the function has been defined somewhere.  */
<a name="15043"><span class="lineNum">   15043 </span>            : </a>
<span class="lineNum">   15044 </span>            : bool
<span class="lineNum">   15045 </span><span class="lineCov">   15923074 : start_preparsed_function (tree decl1, tree attrs, int flags)</span>
<span class="lineNum">   15046 </span>            : {
<span class="lineNum">   15047 </span><span class="lineCov">   15923074 :   tree ctype = NULL_TREE;</span>
<span class="lineNum">   15048 </span><span class="lineCov">   15923074 :   tree fntype;</span>
<span class="lineNum">   15049 </span><span class="lineCov">   15923074 :   tree restype;</span>
<span class="lineNum">   15050 </span><span class="lineCov">   15923074 :   int doing_friend = 0;</span>
<span class="lineNum">   15051 </span><span class="lineCov">   15923074 :   cp_binding_level *bl;</span>
<span class="lineNum">   15052 </span><span class="lineCov">   15923074 :   tree current_function_parms;</span>
<span class="lineNum">   15053 </span><span class="lineCov">   15923074 :   struct c_fileinfo *finfo</span>
<span class="lineNum">   15054 </span><span class="lineCov">   15923074 :     = get_fileinfo (LOCATION_FILE (DECL_SOURCE_LOCATION (decl1)));</span>
<span class="lineNum">   15055 </span><span class="lineCov">   15923074 :   bool honor_interface;</span>
<span class="lineNum">   15056 </span>            : 
<span class="lineNum">   15057 </span>            :   /* Sanity check.  */
<span class="lineNum">   15058 </span><span class="lineCov">   15923074 :   gcc_assert (VOID_TYPE_P (TREE_VALUE (void_list_node)));</span>
<span class="lineNum">   15059 </span><span class="lineCov">   15923074 :   gcc_assert (TREE_CHAIN (void_list_node) == NULL_TREE);</span>
<span class="lineNum">   15060 </span>            : 
<span class="lineNum">   15061 </span><span class="lineCov">   15923074 :   fntype = TREE_TYPE (decl1);</span>
<span class="lineNum">   15062 </span><span class="lineCov">   15923074 :   if (TREE_CODE (fntype) == METHOD_TYPE)</span>
<span class="lineNum">   15063 </span><span class="lineCov">   10566990 :     ctype = TYPE_METHOD_BASETYPE (fntype);</span>
<span class="lineNum">   15064 </span>            : 
<span class="lineNum">   15065 </span>            :   /* ISO C++ 11.4/5.  A friend function defined in a class is in
<span class="lineNum">   15066 </span>            :      the (lexical) scope of the class in which it is defined.  */
<span class="lineNum">   15067 </span><span class="lineCov">   21279158 :   if (!ctype &amp;&amp; DECL_FRIEND_P (decl1))</span>
<span class="lineNum">   15068 </span>            :     {
<span class="lineNum">   15069 </span><span class="lineCov">     188988 :       ctype = DECL_FRIEND_CONTEXT (decl1);</span>
<span class="lineNum">   15070 </span>            : 
<span class="lineNum">   15071 </span>            :       /* CTYPE could be null here if we're dealing with a template;
<span class="lineNum">   15072 </span>            :          for example, `inline friend float foo()' inside a template
<span class="lineNum">   15073 </span>            :          will have no CTYPE set.  */
<span class="lineNum">   15074 </span><span class="lineCov">      47244 :       if (ctype &amp;&amp; TREE_CODE (ctype) != RECORD_TYPE)</span>
<span class="lineNum">   15075 </span>            :         ctype = NULL_TREE;
<span class="lineNum">   15076 </span>            :       else
<span class="lineNum">   15077 </span>            :         doing_friend = 1;
<span class="lineNum">   15078 </span>            :     }
<span class="lineNum">   15079 </span>            : 
<span class="lineNum">   15080 </span><span class="lineCov">   15923074 :   if (DECL_DECLARED_INLINE_P (decl1)</span>
<span class="lineNum">   15081 </span><span class="lineCov">   15923074 :       &amp;&amp; lookup_attribute (&quot;noinline&quot;, attrs))</span>
<span class="lineNum">   15082 </span><span class="lineNoCov">          0 :     warning_at (DECL_SOURCE_LOCATION (decl1), 0,</span>
<span class="lineNum">   15083 </span>            :                 &quot;inline function %qD given attribute noinline&quot;, decl1);
<span class="lineNum">   15084 </span>            : 
<span class="lineNum">   15085 </span>            :   /* Handle gnu_inline attribute.  */
<span class="lineNum">   15086 </span><span class="lineCov">   15923074 :   if (GNU_INLINE_P (decl1))</span>
<span class="lineNum">   15087 </span>            :     {
<span class="lineNum">   15088 </span><span class="lineCov">     758384 :       DECL_EXTERNAL (decl1) = 1;</span>
<span class="lineNum">   15089 </span><span class="lineCov">     758384 :       DECL_NOT_REALLY_EXTERN (decl1) = 0;</span>
<span class="lineNum">   15090 </span><span class="lineCov">     758384 :       DECL_INTERFACE_KNOWN (decl1) = 1;</span>
<span class="lineNum">   15091 </span><span class="lineCov">     758384 :       DECL_DISREGARD_INLINE_LIMITS (decl1) = 1;</span>
<span class="lineNum">   15092 </span>            :     }
<span class="lineNum">   15093 </span>            : 
<span class="lineNum">   15094 </span><span class="lineCov">   15923074 :   if (DECL_MAYBE_IN_CHARGE_CONSTRUCTOR_P (decl1))</span>
<span class="lineNum">   15095 </span>            :     /* This is a constructor, we must ensure that any default args
<span class="lineNum">   15096 </span>            :        introduced by this definition are propagated to the clones
<span class="lineNum">   15097 </span>            :        now. The clones are used directly in overload resolution.  */
<span class="lineNum">   15098 </span><span class="lineCov">    1942850 :     adjust_clone_args (decl1);</span>
<span class="lineNum">   15099 </span>            : 
<span class="lineNum">   15100 </span>            :   /* Sometimes we don't notice that a function is a static member, and
<span class="lineNum">   15101 </span>            :      build a METHOD_TYPE for it.  Fix that up now.  */
<span class="lineNum">   15102 </span><span class="lineCov">   15923074 :   gcc_assert (!(ctype != NULL_TREE &amp;&amp; DECL_STATIC_FUNCTION_P (decl1)</span>
<span class="lineNum">   15103 </span>            :                 &amp;&amp; TREE_CODE (TREE_TYPE (decl1)) == METHOD_TYPE));
<span class="lineNum">   15104 </span>            : 
<span class="lineNum">   15105 </span>            :   /* Set up current_class_type, and enter the scope of the class, if
<span class="lineNum">   15106 </span>            :      appropriate.  */
<span class="lineNum">   15107 </span><span class="lineCov">   15923074 :   if (ctype)</span>
<span class="lineNum">   15108 </span><span class="lineCov">   10595008 :     push_nested_class (ctype);</span>
<span class="lineNum">   15109 </span><span class="lineCov">    5328066 :   else if (DECL_STATIC_FUNCTION_P (decl1))</span>
<span class="lineNum">   15110 </span><span class="lineCov">    1821705 :     push_nested_class (DECL_CONTEXT (decl1));</span>
<span class="lineNum">   15111 </span>            : 
<span class="lineNum">   15112 </span>            :   /* Now that we have entered the scope of the class, we must restore
<span class="lineNum">   15113 </span>            :      the bindings for any template parameters surrounding DECL1, if it
<span class="lineNum">   15114 </span>            :      is an inline member template.  (Order is important; consider the
<span class="lineNum">   15115 </span>            :      case where a template parameter has the same name as a field of
<span class="lineNum">   15116 </span>            :      the class.)  It is not until after this point that
<span class="lineNum">   15117 </span>            :      PROCESSING_TEMPLATE_DECL is guaranteed to be set up correctly.  */
<span class="lineNum">   15118 </span><span class="lineCov">   15923074 :   if (flags &amp; SF_INCLASS_INLINE)</span>
<span class="lineNum">   15119 </span><span class="lineCov">    3115954 :     maybe_begin_member_template_processing (decl1);</span>
<span class="lineNum">   15120 </span>            : 
<span class="lineNum">   15121 </span>            :   /* Effective C++ rule 15.  */
<span class="lineNum">   15122 </span><span class="lineCov">   15923074 :   if (warn_ecpp</span>
<span class="lineNum">   15123 </span><span class="lineCov">        111 :       &amp;&amp; DECL_ASSIGNMENT_OPERATOR_P (decl1)</span>
<span class="lineNum">   15124 </span><span class="lineCov">         21 :       &amp;&amp; DECL_OVERLOADED_OPERATOR_IS (decl1, NOP_EXPR)</span>
<span class="lineNum">   15125 </span><span class="lineCov">   15923095 :       &amp;&amp; VOID_TYPE_P (TREE_TYPE (fntype)))</span>
<span class="lineNum">   15126 </span><span class="lineNoCov">          0 :     warning (OPT_Weffc__,</span>
<span class="lineNum">   15127 </span>            :              &quot;%&lt;operator=%&gt; should return a reference to %&lt;*this%&gt;&quot;);
<span class="lineNum">   15128 </span>            : 
<span class="lineNum">   15129 </span>            :   /* Make the init_value nonzero so pushdecl knows this is not tentative.
<span class="lineNum">   15130 </span>            :      error_mark_node is replaced below (in poplevel) with the BLOCK.  */
<span class="lineNum">   15131 </span><span class="lineCov">   15923074 :   if (!DECL_INITIAL (decl1))</span>
<span class="lineNum">   15132 </span><span class="lineCov">   19931650 :     DECL_INITIAL (decl1) = error_mark_node;</span>
<span class="lineNum">   15133 </span>            : 
<span class="lineNum">   15134 </span>            :   /* This function exists in static storage.
<span class="lineNum">   15135 </span>            :      (This does not mean `static' in the C sense!)  */
<span class="lineNum">   15136 </span><span class="lineCov">   15923074 :   TREE_STATIC (decl1) = 1;</span>
<span class="lineNum">   15137 </span>            : 
<span class="lineNum">   15138 </span>            :   /* We must call push_template_decl after current_class_type is set
<span class="lineNum">   15139 </span>            :      up.  (If we are processing inline definitions after exiting a
<span class="lineNum">   15140 </span>            :      class scope, current_class_type will be NULL_TREE until set above
<span class="lineNum">   15141 </span>            :      by push_nested_class.)  */
<span class="lineNum">   15142 </span><span class="lineCov">   15923074 :   if (processing_template_decl)</span>
<span class="lineNum">   15143 </span>            :     {
<span class="lineNum">   15144 </span><span class="lineCov">    3561853 :       tree newdecl1 = push_template_decl (decl1);</span>
<span class="lineNum">   15145 </span><span class="lineCov">    3561853 :       if (newdecl1 == error_mark_node)</span>
<span class="lineNum">   15146 </span>            :         {
<span class="lineNum">   15147 </span><span class="lineCov">         20 :           if (ctype || DECL_STATIC_FUNCTION_P (decl1))</span>
<span class="lineNum">   15148 </span><span class="lineCov">          6 :             pop_nested_class ();</span>
<span class="lineNum">   15149 </span><span class="lineCov">         20 :           return false;</span>
<span class="lineNum">   15150 </span>            :         }
<span class="lineNum">   15151 </span>            :       decl1 = newdecl1;
<span class="lineNum">   15152 </span>            :     }
<span class="lineNum">   15153 </span>            : 
<span class="lineNum">   15154 </span>            :   /* Make sure the parameter and return types are reasonable.  When
<span class="lineNum">   15155 </span>            :      you declare a function, these types can be incomplete, but they
<span class="lineNum">   15156 </span>            :      must be complete when you define the function.  */
<span class="lineNum">   15157 </span><span class="lineCov">   15923054 :   check_function_type (decl1, DECL_ARGUMENTS (decl1));</span>
<span class="lineNum">   15158 </span>            : 
<span class="lineNum">   15159 </span>            :   /* Build the return declaration for the function.  */
<span class="lineNum">   15160 </span><span class="lineCov">   15923054 :   restype = TREE_TYPE (fntype);</span>
<span class="lineNum">   15161 </span>            : 
<span class="lineNum">   15162 </span><span class="lineCov">   15923054 :   if (DECL_RESULT (decl1) == NULL_TREE)</span>
<span class="lineNum">   15163 </span>            :     {
<span class="lineNum">   15164 </span><span class="lineCov">   15923042 :       tree resdecl;</span>
<span class="lineNum">   15165 </span>            : 
<span class="lineNum">   15166 </span><span class="lineCov">   15923042 :       resdecl = build_decl (input_location, RESULT_DECL, 0, restype);</span>
<span class="lineNum">   15167 </span><span class="lineCov">   15923042 :       DECL_ARTIFICIAL (resdecl) = 1;</span>
<span class="lineNum">   15168 </span><span class="lineCov">   15923042 :       DECL_IGNORED_P (resdecl) = 1;</span>
<span class="lineNum">   15169 </span><span class="lineCov">   15923042 :       DECL_RESULT (decl1) = resdecl;</span>
<span class="lineNum">   15170 </span>            : 
<span class="lineNum">   15171 </span><span class="lineCov">   15923042 :       cp_apply_type_quals_to_decl (cp_type_quals (restype), resdecl);</span>
<span class="lineNum">   15172 </span>            :     }
<span class="lineNum">   15173 </span>            : 
<span class="lineNum">   15174 </span>            :   /* Record the decl so that the function name is defined.
<span class="lineNum">   15175 </span>            :      If we already have a decl for this name, and it is a FUNCTION_DECL,
<span class="lineNum">   15176 </span>            :      use the old decl.  */
<span class="lineNum">   15177 </span><span class="lineCov">   15923054 :   if (!processing_template_decl &amp;&amp; !(flags &amp; SF_PRE_PARSED))</span>
<span class="lineNum">   15178 </span>            :     {
<span class="lineNum">   15179 </span>            :       /* A specialization is not used to guide overload resolution.  */
<span class="lineNum">   15180 </span><span class="lineCov">    2649693 :       if (!DECL_FUNCTION_MEMBER_P (decl1)</span>
<span class="lineNum">   15181 </span><span class="lineCov">    2648840 :           &amp;&amp; !(DECL_USE_TEMPLATE (decl1) &amp;&amp;</span>
<span class="lineNum">   15182 </span><span class="lineCov">    1300717 :                PRIMARY_TEMPLATE_P (DECL_TI_TEMPLATE (decl1))))</span>
<span class="lineNum">   15183 </span>            :         {
<span class="lineNum">   15184 </span><span class="lineCov">    1300285 :           tree olddecl = pushdecl (decl1);</span>
<span class="lineNum">   15185 </span>            : 
<span class="lineNum">   15186 </span><span class="lineCov">    1300285 :           if (olddecl == error_mark_node)</span>
<span class="lineNum">   15187 </span>            :             /* If something went wrong when registering the declaration,
<span class="lineNum">   15188 </span>            :                use DECL1; we have to have a FUNCTION_DECL to use when
<span class="lineNum">   15189 </span>            :                parsing the body of the function.  */
<span class="lineNum">   15190 </span>            :             ;
<span class="lineNum">   15191 </span>            :           else
<span class="lineNum">   15192 </span>            :             {
<span class="lineNum">   15193 </span>            :               /* Otherwise, OLDDECL is either a previous declaration
<span class="lineNum">   15194 </span>            :                  of the same function or DECL1 itself.  */
<span class="lineNum">   15195 </span>            : 
<span class="lineNum">   15196 </span><span class="lineCov">    1300089 :               if (warn_missing_declarations</span>
<span class="lineNum">   15197 </span><span class="lineCov">         21 :                   &amp;&amp; olddecl == decl1</span>
<span class="lineNum">   15198 </span><span class="lineCov">         15 :                   &amp;&amp; !DECL_MAIN_P (decl1)</span>
<span class="lineNum">   15199 </span><span class="lineCov">         15 :                   &amp;&amp; TREE_PUBLIC (decl1)</span>
<span class="lineNum">   15200 </span><span class="lineCov">    1300101 :                   &amp;&amp; !DECL_DECLARED_INLINE_P (decl1))</span>
<span class="lineNum">   15201 </span>            :                 {
<span class="lineNum">   15202 </span><span class="lineCov">          9 :                   tree context;</span>
<span class="lineNum">   15203 </span>            : 
<span class="lineNum">   15204 </span>            :                   /* Check whether DECL1 is in an anonymous
<span class="lineNum">   15205 </span>            :                      namespace.  */
<span class="lineNum">   15206 </span><span class="lineCov">          9 :                   for (context = DECL_CONTEXT (decl1);</span>
<span class="lineNum">   15207 </span><span class="lineCov">         18 :                        context;</span>
<span class="lineNum">   15208 </span><span class="lineCov">          9 :                        context = DECL_CONTEXT (context))</span>
<span class="lineNum">   15209 </span>            :                     {
<span class="lineNum">   15210 </span><span class="lineCov">         12 :                       if (TREE_CODE (context) == NAMESPACE_DECL</span>
<span class="lineNum">   15211 </span><span class="lineCov">         12 :                           &amp;&amp; DECL_NAME (context) == NULL_TREE)</span>
<span class="lineNum">   15212 </span>            :                         break;
<span class="lineNum">   15213 </span>            :                     }
<span class="lineNum">   15214 </span>            : 
<span class="lineNum">   15215 </span><span class="lineCov">          9 :                   if (context == NULL)</span>
<span class="lineNum">   15216 </span><span class="lineCov">         12 :                     warning_at (DECL_SOURCE_LOCATION (decl1),</span>
<span class="lineNum">   15217 </span>            :                                 OPT_Wmissing_declarations,
<span class="lineNum">   15218 </span>            :                                 &quot;no previous declaration for %qD&quot;, decl1);
<span class="lineNum">   15219 </span>            :                 }
<span class="lineNum">   15220 </span>            : 
<span class="lineNum">   15221 </span>            :               decl1 = olddecl;
<span class="lineNum">   15222 </span>            :             }
<span class="lineNum">   15223 </span>            :         }
<span class="lineNum">   15224 </span>            :       else
<span class="lineNum">   15225 </span>            :         {
<span class="lineNum">   15226 </span>            :           /* We need to set the DECL_CONTEXT.  */
<span class="lineNum">   15227 </span><span class="lineCov">      47838 :           if (!DECL_CONTEXT (decl1) &amp;&amp; DECL_TEMPLATE_INFO (decl1))</span>
<span class="lineNum">   15228 </span><span class="lineNoCov">          0 :             DECL_CONTEXT (decl1) = DECL_CONTEXT (DECL_TI_TEMPLATE (decl1));</span>
<span class="lineNum">   15229 </span>            :         }
<span class="lineNum">   15230 </span><span class="lineCov">    1348123 :       fntype = TREE_TYPE (decl1);</span>
<span class="lineNum">   15231 </span><span class="lineCov">    1348123 :       restype = TREE_TYPE (fntype);</span>
<span class="lineNum">   15232 </span>            : 
<span class="lineNum">   15233 </span>            :       /* If #pragma weak applies, mark the decl appropriately now.
<span class="lineNum">   15234 </span>            :          The pragma only applies to global functions.  Because
<span class="lineNum">   15235 </span>            :          determining whether or not the #pragma applies involves
<span class="lineNum">   15236 </span>            :          computing the mangled name for the declaration, we cannot
<span class="lineNum">   15237 </span>            :          apply the pragma until after we have merged this declaration
<span class="lineNum">   15238 </span>            :          with any previous declarations; if the original declaration
<span class="lineNum">   15239 </span>            :          has a linkage specification, that specification applies to
<span class="lineNum">   15240 </span>            :          the definition as well, and may affect the mangled name.  */
<span class="lineNum">   15241 </span><span class="lineCov">    1348123 :       if (DECL_FILE_SCOPE_P (decl1))</span>
<span class="lineNum">   15242 </span><span class="lineCov">     972809 :         maybe_apply_pragma_weak (decl1);</span>
<span class="lineNum">   15243 </span>            :     }
<span class="lineNum">   15244 </span>            : 
<span class="lineNum">   15245 </span>            :   /* We are now in the scope of the function being defined.  */
<span class="lineNum">   15246 </span><span class="lineCov">   15923054 :   current_function_decl = decl1;</span>
<span class="lineNum">   15247 </span>            : 
<span class="lineNum">   15248 </span>            :   /* Save the parm names or decls from this function's declarator
<span class="lineNum">   15249 </span>            :      where store_parm_decls will find them.  */
<span class="lineNum">   15250 </span><span class="lineCov">   15923054 :   current_function_parms = DECL_ARGUMENTS (decl1);</span>
<span class="lineNum">   15251 </span>            : 
<span class="lineNum">   15252 </span>            :   /* Let the user know we're compiling this function.  */
<span class="lineNum">   15253 </span><span class="lineCov">   15923054 :   announce_function (decl1);</span>
<span class="lineNum">   15254 </span>            : 
<span class="lineNum">   15255 </span><span class="lineCov">   15923054 :   gcc_assert (DECL_INITIAL (decl1));</span>
<span class="lineNum">   15256 </span>            : 
<span class="lineNum">   15257 </span>            :   /* This function may already have been parsed, in which case just
<span class="lineNum">   15258 </span>            :      return; our caller will skip over the body without parsing.  */
<span class="lineNum">   15259 </span><span class="lineCov">   31846108 :   if (DECL_INITIAL (decl1) != error_mark_node)</span>
<span class="lineNum">   15260 </span>            :     return true;
<span class="lineNum">   15261 </span>            : 
<span class="lineNum">   15262 </span>            :   /* Initialize RTL machinery.  We cannot do this until
<span class="lineNum">   15263 </span>            :      CURRENT_FUNCTION_DECL and DECL_RESULT are set up.  We do this
<span class="lineNum">   15264 </span>            :      even when processing a template; this is how we get
<span class="lineNum">   15265 </span>            :      CFUN set up, and our per-function variables initialized.
<span class="lineNum">   15266 </span>            :      FIXME factor out the non-RTL stuff.  */
<span class="lineNum">   15267 </span><span class="lineCov">   15923054 :   bl = current_binding_level;</span>
<span class="lineNum">   15268 </span><span class="lineCov">   15923054 :   allocate_struct_function (decl1, processing_template_decl);</span>
<span class="lineNum">   15269 </span>            : 
<span class="lineNum">   15270 </span>            :   /* Initialize the language data structures.  Whenever we start
<span class="lineNum">   15271 </span>            :      a new function, we destroy temporaries in the usual way.  */
<span class="lineNum">   15272 </span><span class="lineCov">   15923054 :   cfun-&gt;language = ggc_cleared_alloc&lt;language_function&gt; ();</span>
<span class="lineNum">   15273 </span><span class="lineCov">   15923054 :   current_stmt_tree ()-&gt;stmts_are_full_exprs_p = 1;</span>
<span class="lineNum">   15274 </span><span class="lineCov">   15923054 :   current_binding_level = bl;</span>
<span class="lineNum">   15275 </span>            : 
<span class="lineNum">   15276 </span><span class="lineCov">   15923054 :   if (!processing_template_decl &amp;&amp; type_uses_auto (restype))</span>
<span class="lineNum">   15277 </span>            :     {
<span class="lineNum">   15278 </span><span class="lineCov">      28683 :       FNDECL_USED_AUTO (decl1) = true;</span>
<span class="lineNum">   15279 </span><span class="lineCov">      28683 :       current_function_auto_return_pattern = restype;</span>
<span class="lineNum">   15280 </span>            :     }
<span class="lineNum">   15281 </span>            : 
<span class="lineNum">   15282 </span>            :   /* Start the statement-tree, start the tree now.  */
<span class="lineNum">   15283 </span><span class="lineCov">   15923054 :   DECL_SAVED_TREE (decl1) = push_stmt_list ();</span>
<span class="lineNum">   15284 </span>            : 
<span class="lineNum">   15285 </span>            :   /* If we are (erroneously) defining a function that we have already
<span class="lineNum">   15286 </span>            :      defined before, wipe out what we knew before.  */
<span class="lineNum">   15287 </span><span class="lineCov">   15923054 :   if (!DECL_PENDING_INLINE_P (decl1))</span>
<span class="lineNum">   15288 </span><span class="lineCov">   15923054 :     DECL_SAVED_FUNCTION_DATA (decl1) = NULL;</span>
<span class="lineNum">   15289 </span>            : 
<span class="lineNum">   15290 </span><span class="lineCov">   15923054 :   if (ctype &amp;&amp; !doing_friend &amp;&amp; !DECL_STATIC_FUNCTION_P (decl1))</span>
<span class="lineNum">   15291 </span>            :     {
<span class="lineNum">   15292 </span>            :       /* We know that this was set up by `grokclassfn'.  We do not
<span class="lineNum">   15293 </span>            :          wait until `store_parm_decls', since evil parse errors may
<span class="lineNum">   15294 </span>            :          never get us to that point.  Here we keep the consistency
<span class="lineNum">   15295 </span>            :          between `current_class_type' and `current_class_ptr'.  */
<span class="lineNum">   15296 </span><span class="lineCov">   10566984 :       tree t = DECL_ARGUMENTS (decl1);</span>
<span class="lineNum">   15297 </span>            : 
<span class="lineNum">   15298 </span><span class="lineCov">   10566984 :       gcc_assert (t != NULL_TREE &amp;&amp; TREE_CODE (t) == PARM_DECL);</span>
<span class="lineNum">   15299 </span><span class="lineCov">   10566984 :       gcc_assert (TYPE_PTR_P (TREE_TYPE (t)));</span>
<span class="lineNum">   15300 </span>            : 
<span class="lineNum">   15301 </span><span class="lineCov">   10566984 :       cp_function_chain-&gt;x_current_class_ref</span>
<span class="lineNum">   15302 </span><span class="lineCov">   10566984 :         = cp_build_fold_indirect_ref (t);</span>
<span class="lineNum">   15303 </span>            :       /* Set this second to avoid shortcut in cp_build_indirect_ref.  */
<span class="lineNum">   15304 </span><span class="lineCov">   10566984 :       cp_function_chain-&gt;x_current_class_ptr = t;</span>
<span class="lineNum">   15305 </span>            : 
<span class="lineNum">   15306 </span>            :       /* Constructors and destructors need to know whether they're &quot;in
<span class="lineNum">   15307 </span>            :          charge&quot; of initializing virtual base classes.  */
<span class="lineNum">   15308 </span><span class="lineCov">   10566984 :       t = DECL_CHAIN (t);</span>
<span class="lineNum">   15309 </span><span class="lineCov">   10566984 :       if (DECL_HAS_IN_CHARGE_PARM_P (decl1))</span>
<span class="lineNum">   15310 </span>            :         {
<span class="lineNum">   15311 </span><span class="lineCov">     595659 :           current_in_charge_parm = t;</span>
<span class="lineNum">   15312 </span><span class="lineCov">     595659 :           t = DECL_CHAIN (t);</span>
<span class="lineNum">   15313 </span>            :         }
<span class="lineNum">   15314 </span><span class="lineCov">   10566984 :       if (DECL_HAS_VTT_PARM_P (decl1))</span>
<span class="lineNum">   15315 </span>            :         {
<span class="lineNum">   15316 </span><span class="lineCov">      21581 :           gcc_assert (DECL_NAME (t) == vtt_parm_identifier);</span>
<span class="lineNum">   15317 </span><span class="lineCov">      21581 :           current_vtt_parm = t;</span>
<span class="lineNum">   15318 </span>            :         }
<span class="lineNum">   15319 </span>            :     }
<span class="lineNum">   15320 </span>            : 
<span class="lineNum">   15321 </span><span class="lineCov">   15923054 :   honor_interface = (!DECL_TEMPLATE_INSTANTIATION (decl1)</span>
<span class="lineNum">   15322 </span>            :                      /* Implicitly-defined methods (like the
<span class="lineNum">   15323 </span>            :                         destructor for a class in which no destructor
<span class="lineNum">   15324 </span>            :                         is explicitly declared) must not be defined
<span class="lineNum">   15325 </span>            :                         until their definition is needed.  So, we
<span class="lineNum">   15326 </span>            :                         ignore interface specifications for
<span class="lineNum">   15327 </span>            :                         compiler-generated functions.  */
<span class="lineNum">   15328 </span><span class="lineCov">   15923054 :                      &amp;&amp; !DECL_ARTIFICIAL (decl1));</span>
<span class="lineNum">   15329 </span>            : 
<span class="lineNum">   15330 </span><span class="lineCov">   15923054 :   if (processing_template_decl)</span>
<span class="lineNum">   15331 </span>            :     /* Don't mess with interface flags.  */;
<span class="lineNum">   15332 </span><span class="lineCov">   24722442 :   else if (DECL_INTERFACE_KNOWN (decl1))</span>
<span class="lineNum">   15333 </span>            :     {
<span class="lineNum">   15334 </span><span class="lineCov">    5967766 :       tree ctx = decl_function_context (decl1);</span>
<span class="lineNum">   15335 </span>            : 
<span class="lineNum">   15336 </span><span class="lineCov">    5967766 :       if (DECL_NOT_REALLY_EXTERN (decl1))</span>
<span class="lineNum">   15337 </span><span class="lineCov">    8602814 :         DECL_EXTERNAL (decl1) = 0;</span>
<span class="lineNum">   15338 </span>            : 
<span class="lineNum">   15339 </span><span class="lineCov">    5967766 :       if (ctx != NULL_TREE &amp;&amp; vague_linkage_p (ctx))</span>
<span class="lineNum">   15340 </span>            :         /* This is a function in a local class in an extern inline
<span class="lineNum">   15341 </span>            :            or template function.  */
<span class="lineNum">   15342 </span><span class="lineCov">    1003823 :         comdat_linkage (decl1);</span>
<span class="lineNum">   15343 </span>            :     }
<span class="lineNum">   15344 </span>            :   /* If this function belongs to an interface, it is public.
<span class="lineNum">   15345 </span>            :      If it belongs to someone else's interface, it is also external.
<span class="lineNum">   15346 </span>            :      This only affects inlines and template instantiations.  */
<span class="lineNum">   15347 </span><span class="lineCov">    6393455 :   else if (!finfo-&gt;interface_unknown &amp;&amp; honor_interface)</span>
<span class="lineNum">   15348 </span>            :     {
<span class="lineNum">   15349 </span><span class="lineCov">        106 :       if (DECL_DECLARED_INLINE_P (decl1)</span>
<span class="lineNum">   15350 </span><span class="lineCov">        106 :           || DECL_TEMPLATE_INSTANTIATION (decl1))</span>
<span class="lineNum">   15351 </span>            :         {
<span class="lineNum">   15352 </span><span class="lineCov">         85 :           DECL_EXTERNAL (decl1)</span>
<span class="lineNum">   15353 </span><span class="lineCov">        170 :             = (finfo-&gt;interface_only</span>
<span class="lineNum">   15354 </span><span class="lineCov">         85 :                || (DECL_DECLARED_INLINE_P (decl1)</span>
<span class="lineNum">   15355 </span><span class="lineCov">         39 :                    &amp;&amp; ! flag_implement_inlines</span>
<span class="lineNum">   15356 </span><span class="lineNoCov">          0 :                    &amp;&amp; !DECL_VINDEX (decl1)));</span>
<span class="lineNum">   15357 </span>            : 
<span class="lineNum">   15358 </span>            :           /* For WIN32 we also want to put these in linkonce sections.  */
<span class="lineNum">   15359 </span><span class="lineCov">         85 :           maybe_make_one_only (decl1);</span>
<span class="lineNum">   15360 </span>            :         }
<span class="lineNum">   15361 </span>            :       else
<span class="lineNum">   15362 </span><span class="lineCov">         42 :         DECL_EXTERNAL (decl1) = 0;</span>
<span class="lineNum">   15363 </span><span class="lineCov">        106 :       DECL_INTERFACE_KNOWN (decl1) = 1;</span>
<span class="lineNum">   15364 </span>            :       /* If this function is in an interface implemented in this file,
<span class="lineNum">   15365 </span>            :          make sure that the back end knows to emit this function
<span class="lineNum">   15366 </span>            :          here.  */
<span class="lineNum">   15367 </span><span class="lineCov">        106 :       if (!DECL_EXTERNAL (decl1))</span>
<span class="lineNum">   15368 </span><span class="lineCov">         60 :         mark_needed (decl1);</span>
<span class="lineNum">   15369 </span>            :     }
<span class="lineNum">   15370 </span><span class="lineCov">    6393349 :   else if (finfo-&gt;interface_unknown &amp;&amp; finfo-&gt;interface_only</span>
<span class="lineNum">   15371 </span><span class="lineNoCov">          0 :            &amp;&amp; honor_interface)</span>
<span class="lineNum">   15372 </span>            :     {
<span class="lineNum">   15373 </span>            :       /* If MULTIPLE_SYMBOL_SPACES is defined and we saw a #pragma
<span class="lineNum">   15374 </span>            :          interface, we will have both finfo-&gt;interface_unknown and
<span class="lineNum">   15375 </span>            :          finfo-&gt;interface_only set.  In that case, we don't want to
<span class="lineNum">   15376 </span>            :          use the normal heuristics because someone will supply a
<span class="lineNum">   15377 </span>            :          #pragma implementation elsewhere, and deducing it here would
<span class="lineNum">   15378 </span>            :          produce a conflict.  */
<span class="lineNum">   15379 </span><span class="lineNoCov">          0 :       comdat_linkage (decl1);</span>
<span class="lineNum">   15380 </span><span class="lineNoCov">          0 :       DECL_EXTERNAL (decl1) = 0;</span>
<span class="lineNum">   15381 </span><span class="lineNoCov">          0 :       DECL_INTERFACE_KNOWN (decl1) = 1;</span>
<span class="lineNum">   15382 </span><span class="lineNoCov">          0 :       DECL_DEFER_OUTPUT (decl1) = 1;</span>
<span class="lineNum">   15383 </span>            :     }
<span class="lineNum">   15384 </span>            :   else
<span class="lineNum">   15385 </span>            :     {
<span class="lineNum">   15386 </span>            :       /* This is a definition, not a reference.
<span class="lineNum">   15387 </span>            :          So clear DECL_EXTERNAL, unless this is a GNU extern inline.  */
<span class="lineNum">   15388 </span><span class="lineCov">    6393349 :       if (!GNU_INLINE_P (decl1))</span>
<span class="lineNum">   15389 </span><span class="lineCov">    6393349 :         DECL_EXTERNAL (decl1) = 0;</span>
<span class="lineNum">   15390 </span>            : 
<span class="lineNum">   15391 </span><span class="lineCov">    6393349 :       if ((DECL_DECLARED_INLINE_P (decl1)</span>
<span class="lineNum">   15392 </span><span class="lineCov">     518984 :            || DECL_TEMPLATE_INSTANTIATION (decl1))</span>
<span class="lineNum">   15393 </span><span class="lineCov">    6748523 :           &amp;&amp; ! DECL_INTERFACE_KNOWN (decl1))</span>
<span class="lineNum">   15394 </span><span class="lineCov">    6229539 :         DECL_DEFER_OUTPUT (decl1) = 1;</span>
<span class="lineNum">   15395 </span>            :       else
<span class="lineNum">   15396 </span><span class="lineCov">     163810 :         DECL_INTERFACE_KNOWN (decl1) = 1;</span>
<span class="lineNum">   15397 </span>            :     }
<span class="lineNum">   15398 </span>            : 
<span class="lineNum">   15399 </span>            :   /* Determine the ELF visibility attribute for the function.  We must not
<span class="lineNum">   15400 </span>            :      do this before calling &quot;pushdecl&quot;, as we must allow &quot;duplicate_decls&quot;
<span class="lineNum">   15401 </span>            :      to merge any attributes appropriately.  We also need to wait until
<span class="lineNum">   15402 </span>            :      linkage is set.  */
<span class="lineNum">   15403 </span><span class="lineCov">   15923054 :   if (!DECL_CLONED_FUNCTION_P (decl1))</span>
<span class="lineNum">   15404 </span><span class="lineCov">   11832223 :     determine_visibility (decl1);</span>
<span class="lineNum">   15405 </span>            : 
<span class="lineNum">   15406 </span><span class="lineCov">   15923054 :   if (!processing_template_decl)</span>
<span class="lineNum">   15407 </span><span class="lineCov">   12361221 :     maybe_instantiate_noexcept (decl1);</span>
<span class="lineNum">   15408 </span>            : 
<span class="lineNum">   15409 </span><span class="lineCov">   15923054 :   begin_scope (sk_function_parms, decl1);</span>
<span class="lineNum">   15410 </span>            : 
<span class="lineNum">   15411 </span><span class="lineCov">   15923054 :   ++function_depth;</span>
<span class="lineNum">   15412 </span>            : 
<span class="lineNum">   15413 </span><span class="lineCov">   15923054 :   if (DECL_DESTRUCTOR_P (decl1)</span>
<span class="lineNum">   15414 </span><span class="lineCov">   14012631 :       || (DECL_CONSTRUCTOR_P (decl1)</span>
<span class="lineNum">   15415 </span><span class="lineCov">   15923054 :           &amp;&amp; targetm.cxx.cdtor_returns_this ()))</span>
<span class="lineNum">   15416 </span>            :     {
<span class="lineNum">   15417 </span><span class="lineCov">    1910423 :       cdtor_label = create_artificial_label (input_location);</span>
<span class="lineNum">   15418 </span><span class="lineCov">    1910423 :       LABEL_DECL_CDTOR (cdtor_label) = true;</span>
<span class="lineNum">   15419 </span>            :     }
<span class="lineNum">   15420 </span>            : 
<span class="lineNum">   15421 </span><span class="lineCov">   15923054 :   start_fname_decls ();</span>
<span class="lineNum">   15422 </span>            : 
<span class="lineNum">   15423 </span><span class="lineCov">   15923054 :   store_parm_decls (current_function_parms);</span>
<span class="lineNum">   15424 </span>            : 
<span class="lineNum">   15425 </span><span class="lineCov">   15923054 :   if (!processing_template_decl</span>
<span class="lineNum">   15426 </span><span class="lineCov">   12361221 :       &amp;&amp; (flag_lifetime_dse &gt; 1)</span>
<span class="lineNum">   15427 </span><span class="lineCov">   12361173 :       &amp;&amp; DECL_CONSTRUCTOR_P (decl1)</span>
<span class="lineNum">   15428 </span><span class="lineCov">    4227439 :       &amp;&amp; !DECL_CLONED_FUNCTION_P (decl1)</span>
<span class="lineNum">   15429 </span>            :       /* Clobbering an empty base is harmful if it overlays real data.  */
<span class="lineNum">   15430 </span><span class="lineCov">    1409151 :       &amp;&amp; !is_empty_class (current_class_type)</span>
<span class="lineNum">   15431 </span>            :       /* We can't clobber safely for an implicitly-defined default constructor
<span class="lineNum">   15432 </span>            :          because part of the initialization might happen before we enter the
<span class="lineNum">   15433 </span>            :          constructor, via AGGR_INIT_ZERO_FIRST (c++/68006).  */
<span class="lineNum">   15434 </span><span class="lineCov">   17006494 :       &amp;&amp; !implicit_default_ctor_p (decl1))</span>
<span class="lineNum">   15435 </span><span class="lineCov">    1046609 :     finish_expr_stmt (build_clobber_this ());</span>
<span class="lineNum">   15436 </span>            : 
<span class="lineNum">   15437 </span><span class="lineCov">   15923054 :   if (!processing_template_decl</span>
<span class="lineNum">   15438 </span><span class="lineCov">   12361221 :       &amp;&amp; DECL_CONSTRUCTOR_P (decl1)</span>
<span class="lineNum">   15439 </span><span class="lineCov">    4227457 :       &amp;&amp; sanitize_flags_p (SANITIZE_VPTR)</span>
<span class="lineNum">   15440 </span><span class="lineCov">       1491 :       &amp;&amp; !DECL_CLONED_FUNCTION_P (decl1)</span>
<span class="lineNum">   15441 </span><span class="lineCov">   15923551 :       &amp;&amp; !implicit_default_ctor_p (decl1))</span>
<span class="lineNum">   15442 </span><span class="lineCov">        327 :     cp_ubsan_maybe_initialize_vtbl_ptrs (current_class_ptr);</span>
<span class="lineNum">   15443 </span>            : 
<span class="lineNum">   15444 </span><span class="lineCov">   15923054 :   start_lambda_scope (decl1);</span>
<span class="lineNum">   15445 </span>            : 
<span class="lineNum">   15446 </span><span class="lineCov">   15923054 :   return true;</span>
<span class="lineNum">   15447 </span>            : }
<span class="lineNum">   15448 </span>            : 
<span class="lineNum">   15449 </span>            : 
<span class="lineNum">   15450 </span>            : /* Like start_preparsed_function, except that instead of a
<span class="lineNum">   15451 </span>            :    FUNCTION_DECL, this function takes DECLSPECS and DECLARATOR.
<span class="lineNum">   15452 </span>            : 
<span class="lineNum">   15453 </span>            :    Returns true on success.  If the DECLARATOR is not suitable
<span class="lineNum">   15454 </span>            :    for a function, we return false, which tells the parser to
<span class="lineNum">   15455 </span>            :    skip the entire function.  */
<a name="15456"><span class="lineNum">   15456 </span>            : </a>
<span class="lineNum">   15457 </span>            : bool
<span class="lineNum">   15458 </span><span class="lineCov">    2608316 : start_function (cp_decl_specifier_seq *declspecs,</span>
<span class="lineNum">   15459 </span>            :                 const cp_declarator *declarator,
<span class="lineNum">   15460 </span>            :                 tree attrs)
<span class="lineNum">   15461 </span>            : {
<span class="lineNum">   15462 </span><span class="lineCov">    2608316 :   tree decl1;</span>
<span class="lineNum">   15463 </span>            : 
<span class="lineNum">   15464 </span><span class="lineCov">    2608316 :   decl1 = grokdeclarator (declarator, declspecs, FUNCDEF, 1, &amp;attrs);</span>
<span class="lineNum">   15465 </span><span class="lineCov">    2608316 :   invoke_plugin_callbacks (PLUGIN_START_PARSE_FUNCTION, decl1);</span>
<span class="lineNum">   15466 </span><span class="lineCov">    2608316 :   if (decl1 == error_mark_node)</span>
<span class="lineNum">   15467 </span>            :     return false;
<span class="lineNum">   15468 </span>            :   /* If the declarator is not suitable for a function definition,
<span class="lineNum">   15469 </span>            :      cause a syntax error.  */
<span class="lineNum">   15470 </span><span class="lineCov">    2608132 :   if (decl1 == NULL_TREE || TREE_CODE (decl1) != FUNCTION_DECL)</span>
<span class="lineNum">   15471 </span>            :     {
<span class="lineNum">   15472 </span><span class="lineCov">          3 :       error (&quot;invalid function declaration&quot;);</span>
<span class="lineNum">   15473 </span><span class="lineCov">          3 :       return false;</span>
<span class="lineNum">   15474 </span>            :     }
<span class="lineNum">   15475 </span>            : 
<span class="lineNum">   15476 </span><span class="lineCov">    2608129 :   if (DECL_MAIN_P (decl1))</span>
<span class="lineNum">   15477 </span>            :     /* main must return int.  grokfndecl should have corrected it
<span class="lineNum">   15478 </span>            :        (and issued a diagnostic) if the user got it wrong.  */
<span class="lineNum">   15479 </span><span class="lineCov">      21757 :     gcc_assert (same_type_p (TREE_TYPE (TREE_TYPE (decl1)),</span>
<span class="lineNum">   15480 </span>            :                              integer_type_node));
<span class="lineNum">   15481 </span>            : 
<span class="lineNum">   15482 </span><span class="lineCov">    2608129 :   return start_preparsed_function (decl1, attrs, /*flags=*/SF_DEFAULT);</span>
<span class="lineNum">   15483 </span>            : }
<span class="lineNum">   15484 </span>            : 
<span class="lineNum">   15485 </span>            : /* Returns true iff an EH_SPEC_BLOCK should be created in the body of
<span class="lineNum">   15486 </span>            :    FN.  */
<a name="15487"><span class="lineNum">   15487 </span>            : </a>
<span class="lineNum">   15488 </span>            : static bool
<span class="lineNum">   15489 </span><span class="lineCov">   27755243 : use_eh_spec_block (tree fn)</span>
<span class="lineNum">   15490 </span>            : {
<span class="lineNum">   15491 </span><span class="lineCov">   26309216 :   return (flag_exceptions &amp;&amp; flag_enforce_eh_specs</span>
<span class="lineNum">   15492 </span><span class="lineCov">   26309216 :           &amp;&amp; !processing_template_decl</span>
<span class="lineNum">   15493 </span><span class="lineCov">   19457006 :           &amp;&amp; !type_throw_all_p (TREE_TYPE (fn))</span>
<span class="lineNum">   15494 </span>            :           /* We insert the EH_SPEC_BLOCK only in the original
<span class="lineNum">   15495 </span>            :              function; then, it is copied automatically to the
<span class="lineNum">   15496 </span>            :              clones.  */
<span class="lineNum">   15497 </span><span class="lineCov">    9302549 :           &amp;&amp; !DECL_CLONED_FUNCTION_P (fn)</span>
<span class="lineNum">   15498 </span>            :           /* Implicitly-generated constructors and destructors have
<span class="lineNum">   15499 </span>            :              exception specifications.  However, those specifications
<span class="lineNum">   15500 </span>            :              are the union of the possible exceptions specified by the
<span class="lineNum">   15501 </span>            :              constructors/destructors for bases and members, so no
<span class="lineNum">   15502 </span>            :              unallowed exception will ever reach this function.  By
<span class="lineNum">   15503 </span>            :              not creating the EH_SPEC_BLOCK we save a little memory,
<span class="lineNum">   15504 </span>            :              and we avoid spurious warnings about unreachable
<span class="lineNum">   15505 </span>            :              code.  */
<span class="lineNum">   15506 </span><span class="lineCov">   34480661 :           &amp;&amp; !DECL_DEFAULTED_FN (fn));</span>
<span class="lineNum">   15507 </span>            : }
<span class="lineNum">   15508 </span>            : 
<span class="lineNum">   15509 </span>            : /* Store the parameter declarations into the current function declaration.
<span class="lineNum">   15510 </span>            :    This is called after parsing the parameter declarations, before
<span class="lineNum">   15511 </span>            :    digesting the body of the function.
<span class="lineNum">   15512 </span>            : 
<span class="lineNum">   15513 </span>            :    Also install to binding contour return value identifier, if any.  */
<a name="15514"><span class="lineNum">   15514 </span>            : </a>
<span class="lineNum">   15515 </span>            : static void
<span class="lineNum">   15516 </span><span class="lineCov">   15923054 : store_parm_decls (tree current_function_parms)</span>
<span class="lineNum">   15517 </span>            : {
<span class="lineNum">   15518 </span><span class="lineCov">   15923054 :   tree fndecl = current_function_decl;</span>
<span class="lineNum">   15519 </span><span class="lineCov">   15923054 :   tree parm;</span>
<span class="lineNum">   15520 </span>            : 
<span class="lineNum">   15521 </span>            :   /* This is a chain of any other decls that came in among the parm
<span class="lineNum">   15522 </span>            :      declarations.  If a parm is declared with  enum {foo, bar} x;
<span class="lineNum">   15523 </span>            :      then CONST_DECLs for foo and bar are put here.  */
<span class="lineNum">   15524 </span><span class="lineCov">   15923054 :   tree nonparms = NULL_TREE;</span>
<span class="lineNum">   15525 </span>            : 
<span class="lineNum">   15526 </span><span class="lineCov">   15923054 :   if (current_function_parms)</span>
<span class="lineNum">   15527 </span>            :     {
<span class="lineNum">   15528 </span>            :       /* This case is when the function was defined with an ANSI prototype.
<span class="lineNum">   15529 </span>            :          The parms already have decls, so we need not do anything here
<span class="lineNum">   15530 </span>            :          except record them as in effect
<span class="lineNum">   15531 </span>            :          and complain if any redundant old-style parm decls were written.  */
<span class="lineNum">   15532 </span>            : 
<span class="lineNum">   15533 </span><span class="lineCov">   15207937 :       tree specparms = current_function_parms;</span>
<span class="lineNum">   15534 </span><span class="lineCov">   15207937 :       tree next;</span>
<span class="lineNum">   15535 </span>            : 
<span class="lineNum">   15536 </span>            :       /* Must clear this because it might contain TYPE_DECLs declared
<span class="lineNum">   15537 </span>            :              at class level.  */
<span class="lineNum">   15538 </span><span class="lineCov">   15207937 :       current_binding_level-&gt;names = NULL;</span>
<span class="lineNum">   15539 </span>            : 
<span class="lineNum">   15540 </span>            :       /* If we're doing semantic analysis, then we'll call pushdecl
<span class="lineNum">   15541 </span>            :              for each of these.  We must do them in reverse order so that
<span class="lineNum">   15542 </span>            :              they end in the correct forward order.  */
<span class="lineNum">   15543 </span><span class="lineCov">   15207937 :       specparms = nreverse (specparms);</span>
<span class="lineNum">   15544 </span>            : 
<span class="lineNum">   15545 </span><span class="lineCov">   44285216 :       for (parm = specparms; parm; parm = next)</span>
<span class="lineNum">   15546 </span>            :         {
<span class="lineNum">   15547 </span><span class="lineCov">   29077279 :           next = DECL_CHAIN (parm);</span>
<span class="lineNum">   15548 </span><span class="lineCov">   29077279 :           if (TREE_CODE (parm) == PARM_DECL)</span>
<span class="lineNum">   15549 </span><span class="lineCov">   29077279 :             pushdecl (parm);</span>
<span class="lineNum">   15550 </span>            :           else
<span class="lineNum">   15551 </span>            :             {
<span class="lineNum">   15552 </span>            :               /* If we find an enum constant or a type tag,
<span class="lineNum">   15553 </span>            :                  put it aside for the moment.  */
<span class="lineNum">   15554 </span><span class="lineNoCov">          0 :               TREE_CHAIN (parm) = NULL_TREE;</span>
<span class="lineNum">   15555 </span><span class="lineNoCov">          0 :               nonparms = chainon (nonparms, parm);</span>
<span class="lineNum">   15556 </span>            :             }
<span class="lineNum">   15557 </span>            :         }
<span class="lineNum">   15558 </span>            : 
<span class="lineNum">   15559 </span>            :       /* Get the decls in their original chain order and record in the
<span class="lineNum">   15560 </span>            :          function.  This is all and only the PARM_DECLs that were
<span class="lineNum">   15561 </span>            :          pushed into scope by the loop above.  */
<span class="lineNum">   15562 </span><span class="lineCov">   15207937 :       DECL_ARGUMENTS (fndecl) = get_local_decls ();</span>
<span class="lineNum">   15563 </span>            :     }
<span class="lineNum">   15564 </span>            :   else
<span class="lineNum">   15565 </span><span class="lineCov">     715117 :     DECL_ARGUMENTS (fndecl) = NULL_TREE;</span>
<span class="lineNum">   15566 </span>            : 
<span class="lineNum">   15567 </span>            :   /* Now store the final chain of decls for the arguments
<span class="lineNum">   15568 </span>            :      as the decl-chain of the current lexical scope.
<span class="lineNum">   15569 </span>            :      Put the enumerators in as well, at the front so that
<span class="lineNum">   15570 </span>            :      DECL_ARGUMENTS is not modified.  */
<span class="lineNum">   15571 </span><span class="lineCov">   15923054 :   current_binding_level-&gt;names = chainon (nonparms, DECL_ARGUMENTS (fndecl));</span>
<span class="lineNum">   15572 </span>            : 
<span class="lineNum">   15573 </span><span class="lineCov">   15923054 :   if (use_eh_spec_block (current_function_decl))</span>
<span class="lineNum">   15574 </span><span class="lineCov">    3154956 :     current_eh_spec_block = begin_eh_spec_block ();</span>
<span class="lineNum">   15575 </span><span class="lineCov">   15923054 : }</span>
<span class="lineNum">   15576 </span>            : 
<span class="lineNum">   15577 </span>            : 
<span class="lineNum">   15578 </span>            : /* We have finished doing semantic analysis on DECL, but have not yet
<span class="lineNum">   15579 </span>            :    generated RTL for its body.  Save away our current state, so that
<span class="lineNum">   15580 </span>            :    when we want to generate RTL later we know what to do.  */
<a name="15581"><span class="lineNum">   15581 </span>            : </a>
<span class="lineNum">   15582 </span>            : static void
<span class="lineNum">   15583 </span><span class="lineCov">   12361187 : save_function_data (tree decl)</span>
<span class="lineNum">   15584 </span>            : {
<span class="lineNum">   15585 </span><span class="lineCov">   12361187 :   struct language_function *f;</span>
<span class="lineNum">   15586 </span>            : 
<span class="lineNum">   15587 </span>            :   /* Save the language-specific per-function data so that we can
<span class="lineNum">   15588 </span>            :      get it back when we really expand this function.  */
<span class="lineNum">   15589 </span><span class="lineCov">   12361187 :   gcc_assert (!DECL_PENDING_INLINE_P (decl));</span>
<span class="lineNum">   15590 </span>            : 
<span class="lineNum">   15591 </span>            :   /* Make a copy.  */
<span class="lineNum">   15592 </span><span class="lineCov">   12361187 :   f = ggc_alloc&lt;language_function&gt; ();</span>
<span class="lineNum">   15593 </span><span class="lineCov">   12361187 :   memcpy (f, cp_function_chain, sizeof (struct language_function));</span>
<span class="lineNum">   15594 </span><span class="lineCov">   12361187 :   DECL_SAVED_FUNCTION_DATA (decl) = f;</span>
<span class="lineNum">   15595 </span>            : 
<span class="lineNum">   15596 </span>            :   /* Clear out the bits we don't need.  */
<span class="lineNum">   15597 </span><span class="lineCov">   12361187 :   f-&gt;base.x_stmt_tree.x_cur_stmt_list = NULL;</span>
<span class="lineNum">   15598 </span><span class="lineCov">   12361187 :   f-&gt;bindings = NULL;</span>
<span class="lineNum">   15599 </span><span class="lineCov">   12361187 :   f-&gt;x_local_names = NULL;</span>
<span class="lineNum">   15600 </span><span class="lineCov">   12361187 :   f-&gt;base.local_typedefs = NULL;</span>
<span class="lineNum">   15601 </span><span class="lineCov">   12361187 : }</span>
<span class="lineNum">   15602 </span>            : 
<span class="lineNum">   15603 </span>            : 
<span class="lineNum">   15604 </span>            : /* Set the return value of the constructor (if present).  */
<a name="15605"><span class="lineNum">   15605 </span>            : </a>
<span class="lineNum">   15606 </span>            : static void
<span class="lineNum">   15607 </span><span class="lineCov">    1409157 : finish_constructor_body (void)</span>
<span class="lineNum">   15608 </span>            : {
<span class="lineNum">   15609 </span><span class="lineCov">    1409157 :   tree val;</span>
<span class="lineNum">   15610 </span><span class="lineCov">    1409157 :   tree exprstmt;</span>
<span class="lineNum">   15611 </span>            : 
<span class="lineNum">   15612 </span><span class="lineCov">    1409157 :   if (targetm.cxx.cdtor_returns_this ())</span>
<span class="lineNum">   15613 </span>            :     {
<span class="lineNum">   15614 </span>            :       /* Any return from a constructor will end up here.  */
<span class="lineNum">   15615 </span><span class="lineNoCov">          0 :       add_stmt (build_stmt (input_location, LABEL_EXPR, cdtor_label));</span>
<span class="lineNum">   15616 </span>            : 
<span class="lineNum">   15617 </span><span class="lineNoCov">          0 :       val = DECL_ARGUMENTS (current_function_decl);</span>
<span class="lineNum">   15618 </span><span class="lineNoCov">          0 :       val = build2 (MODIFY_EXPR, TREE_TYPE (val),</span>
<span class="lineNum">   15619 </span><span class="lineNoCov">          0 :                     DECL_RESULT (current_function_decl), val);</span>
<span class="lineNum">   15620 </span>            :       /* Return the address of the object.  */
<span class="lineNum">   15621 </span><span class="lineNoCov">          0 :       exprstmt = build_stmt (input_location, RETURN_EXPR, val);</span>
<span class="lineNum">   15622 </span><span class="lineNoCov">          0 :       add_stmt (exprstmt);</span>
<span class="lineNum">   15623 </span>            :     }
<span class="lineNum">   15624 </span><span class="lineCov">    1409157 : }</span>
<span class="lineNum">   15625 </span>            : 
<span class="lineNum">   15626 </span>            : /* Do all the processing for the beginning of a destructor; set up the
<span class="lineNum">   15627 </span>            :    vtable pointers and cleanups for bases and members.  */
<a name="15628"><span class="lineNum">   15628 </span>            : </a>
<span class="lineNum">   15629 </span>            : static void
<span class="lineNum">   15630 </span><span class="lineCov">     589308 : begin_destructor_body (void)</span>
<span class="lineNum">   15631 </span>            : {
<span class="lineNum">   15632 </span><span class="lineCov">     589308 :   tree compound_stmt;</span>
<span class="lineNum">   15633 </span>            : 
<span class="lineNum">   15634 </span>            :   /* If the CURRENT_CLASS_TYPE is incomplete, we will have already
<span class="lineNum">   15635 </span>            :      issued an error message.  We still want to try to process the
<span class="lineNum">   15636 </span>            :      body of the function, but initialize_vtbl_ptrs will crash if
<span class="lineNum">   15637 </span>            :      TYPE_BINFO is NULL.  */
<span class="lineNum">   15638 </span><span class="lineCov">     589308 :   if (COMPLETE_TYPE_P (current_class_type))</span>
<span class="lineNum">   15639 </span>            :     {
<span class="lineNum">   15640 </span><span class="lineCov">     589308 :       compound_stmt = begin_compound_stmt (0);</span>
<span class="lineNum">   15641 </span>            :       /* Make all virtual function table pointers in non-virtual base
<span class="lineNum">   15642 </span>            :          classes point to CURRENT_CLASS_TYPE's virtual function
<span class="lineNum">   15643 </span>            :          tables.  */
<span class="lineNum">   15644 </span><span class="lineCov">     589308 :       initialize_vtbl_ptrs (current_class_ptr);</span>
<span class="lineNum">   15645 </span><span class="lineCov">     589308 :       finish_compound_stmt (compound_stmt);</span>
<span class="lineNum">   15646 </span>            : 
<span class="lineNum">   15647 </span><span class="lineCov">     589308 :       if (flag_lifetime_dse</span>
<span class="lineNum">   15648 </span>            :           /* Clobbering an empty base is harmful if it overlays real data.  */
<span class="lineNum">   15649 </span><span class="lineCov">     589308 :           &amp;&amp; !is_empty_class (current_class_type))</span>
<span class="lineNum">   15650 </span>            :       {
<span class="lineNum">   15651 </span><span class="lineCov">     413975 :         if (sanitize_flags_p (SANITIZE_VPTR)</span>
<span class="lineNum">   15652 </span><span class="lineCov">        208 :             &amp;&amp; (flag_sanitize_recover &amp; SANITIZE_VPTR) == 0</span>
<span class="lineNum">   15653 </span><span class="lineCov">     414199 :             &amp;&amp; TYPE_CONTAINS_VPTR_P (current_class_type))</span>
<span class="lineNum">   15654 </span>            :           {
<span class="lineNum">   15655 </span><span class="lineCov">        112 :             tree binfo = TYPE_BINFO (current_class_type);</span>
<span class="lineNum">   15656 </span><span class="lineCov">        112 :             tree ref</span>
<span class="lineNum">   15657 </span><span class="lineCov">        112 :               = cp_build_fold_indirect_ref (current_class_ptr);</span>
<span class="lineNum">   15658 </span>            : 
<span class="lineNum">   15659 </span><span class="lineCov">        112 :             tree vtbl_ptr = build_vfield_ref (ref, TREE_TYPE (binfo));</span>
<span class="lineNum">   15660 </span><span class="lineCov">        112 :             tree vtbl = build_zero_cst (TREE_TYPE (vtbl_ptr));</span>
<span class="lineNum">   15661 </span><span class="lineCov">        112 :             tree stmt = cp_build_modify_expr (input_location, vtbl_ptr,</span>
<span class="lineNum">   15662 </span>            :                                               NOP_EXPR, vtbl,
<span class="lineNum">   15663 </span>            :                                               tf_warning_or_error);
<span class="lineNum">   15664 </span>            :             /* If the vptr is shared with some virtual nearly empty base,
<span class="lineNum">   15665 </span>            :                don't clear it if not in charge, the dtor of the virtual
<span class="lineNum">   15666 </span>            :                nearly empty base will do that later.  */
<span class="lineNum">   15667 </span><span class="lineCov">        112 :             if (CLASSTYPE_VBASECLASSES (current_class_type)</span>
<span class="lineNum">   15668 </span><span class="lineCov">        140 :                 &amp;&amp; CLASSTYPE_PRIMARY_BINFO (current_class_type)</span>
<span class="lineNum">   15669 </span><span class="lineCov">        252 :                 &amp;&amp; BINFO_VIRTUAL_P</span>
<span class="lineNum">   15670 </span>            :                           (CLASSTYPE_PRIMARY_BINFO (current_class_type)))
<span class="lineNum">   15671 </span>            :               {
<span class="lineNum">   15672 </span><span class="lineCov">         35 :                 stmt = convert_to_void (stmt, ICV_STATEMENT,</span>
<span class="lineNum">   15673 </span>            :                                         tf_warning_or_error);
<span class="lineNum">   15674 </span><span class="lineCov">         35 :                 stmt = build_if_in_charge (stmt);</span>
<span class="lineNum">   15675 </span>            :               }
<span class="lineNum">   15676 </span><span class="lineCov">        112 :             finish_decl_cleanup (NULL_TREE, stmt);</span>
<span class="lineNum">   15677 </span>            :           }
<span class="lineNum">   15678 </span>            :         else
<span class="lineNum">   15679 </span><span class="lineCov">     413863 :           finish_decl_cleanup (NULL_TREE, build_clobber_this ());</span>
<span class="lineNum">   15680 </span>            :       }
<span class="lineNum">   15681 </span>            : 
<span class="lineNum">   15682 </span>            :       /* And insert cleanups for our bases and members so that they
<span class="lineNum">   15683 </span>            :          will be properly destroyed if we throw.  */
<span class="lineNum">   15684 </span><span class="lineCov">     589308 :       push_base_cleanups ();</span>
<span class="lineNum">   15685 </span>            :     }
<span class="lineNum">   15686 </span><span class="lineCov">     589308 : }</span>
<span class="lineNum">   15687 </span>            : 
<span class="lineNum">   15688 </span>            : /* At the end of every destructor we generate code to delete the object if
<span class="lineNum">   15689 </span>            :    necessary.  Do that now.  */
<a name="15690"><span class="lineNum">   15690 </span>            : </a>
<span class="lineNum">   15691 </span>            : static void
<span class="lineNum">   15692 </span><span class="lineCov">     589308 : finish_destructor_body (void)</span>
<span class="lineNum">   15693 </span>            : {
<span class="lineNum">   15694 </span><span class="lineCov">     589308 :   tree exprstmt;</span>
<span class="lineNum">   15695 </span>            : 
<span class="lineNum">   15696 </span>            :   /* Any return from a destructor will end up here; that way all base
<span class="lineNum">   15697 </span>            :      and member cleanups will be run when the function returns.  */
<span class="lineNum">   15698 </span><span class="lineCov">     589308 :   add_stmt (build_stmt (input_location, LABEL_EXPR, cdtor_label));</span>
<span class="lineNum">   15699 </span>            : 
<span class="lineNum">   15700 </span><span class="lineCov">     589308 :   if (targetm.cxx.cdtor_returns_this ())</span>
<span class="lineNum">   15701 </span>            :     {
<span class="lineNum">   15702 </span><span class="lineNoCov">          0 :       tree val;</span>
<span class="lineNum">   15703 </span>            : 
<span class="lineNum">   15704 </span><span class="lineNoCov">          0 :       val = DECL_ARGUMENTS (current_function_decl);</span>
<span class="lineNum">   15705 </span><span class="lineNoCov">          0 :       val = build2 (MODIFY_EXPR, TREE_TYPE (val),</span>
<span class="lineNum">   15706 </span><span class="lineNoCov">          0 :                     DECL_RESULT (current_function_decl), val);</span>
<span class="lineNum">   15707 </span>            :       /* Return the address of the object.  */
<span class="lineNum">   15708 </span><span class="lineNoCov">          0 :       exprstmt = build_stmt (input_location, RETURN_EXPR, val);</span>
<span class="lineNum">   15709 </span><span class="lineNoCov">          0 :       add_stmt (exprstmt);</span>
<span class="lineNum">   15710 </span>            :     }
<span class="lineNum">   15711 </span><span class="lineCov">     589308 : }</span>
<span class="lineNum">   15712 </span>            : 
<span class="lineNum">   15713 </span>            : /* Do the necessary processing for the beginning of a function body, which
<span class="lineNum">   15714 </span>            :    in this case includes member-initializers, but not the catch clauses of
<span class="lineNum">   15715 </span>            :    a function-try-block.  Currently, this means opening a binding level
<span class="lineNum">   15716 </span>            :    for the member-initializers (in a ctor), member cleanups (in a dtor),
<span class="lineNum">   15717 </span>            :    and capture proxies (in a lambda operator()).  */
<a name="15718"><span class="lineNum">   15718 </span>            : </a>
<span class="lineNum">   15719 </span>            : tree
<span class="lineNum">   15720 </span><span class="lineCov">    7617033 : begin_function_body (void)</span>
<span class="lineNum">   15721 </span>            : {
<span class="lineNum">   15722 </span><span class="lineCov">    7617033 :   tree stmt;</span>
<span class="lineNum">   15723 </span>            : 
<span class="lineNum">   15724 </span><span class="lineCov">    7617033 :   if (! FUNCTION_NEEDS_BODY_BLOCK (current_function_decl))</span>
<span class="lineNum">   15725 </span>            :     return NULL_TREE;
<span class="lineNum">   15726 </span>            : 
<span class="lineNum">   15727 </span><span class="lineCov">    2639581 :   if (processing_template_decl)</span>
<span class="lineNum">   15728 </span>            :     /* Do nothing now.  */;
<span class="lineNum">   15729 </span>            :   else
<span class="lineNum">   15730 </span>            :     /* Always keep the BLOCK node associated with the outermost pair of
<span class="lineNum">   15731 </span>            :        curly braces of a function.  These are needed for correct
<span class="lineNum">   15732 </span>            :        operation of dwarfout.c.  */
<span class="lineNum">   15733 </span><span class="lineCov">    2053384 :     keep_next_level (true);</span>
<span class="lineNum">   15734 </span>            : 
<span class="lineNum">   15735 </span><span class="lineCov">    2639581 :   stmt = begin_compound_stmt (BCS_FN_BODY);</span>
<span class="lineNum">   15736 </span>            : 
<span class="lineNum">   15737 </span><span class="lineCov">    2639581 :   if (processing_template_decl)</span>
<span class="lineNum">   15738 </span>            :     /* Do nothing now.  */;
<span class="lineNum">   15739 </span><span class="lineCov">    2053384 :   else if (DECL_DESTRUCTOR_P (current_function_decl))</span>
<span class="lineNum">   15740 </span><span class="lineCov">     589308 :     begin_destructor_body ();</span>
<span class="lineNum">   15741 </span>            : 
<span class="lineNum">   15742 </span>            :   return stmt;
<span class="lineNum">   15743 </span>            : }
<span class="lineNum">   15744 </span>            : 
<span class="lineNum">   15745 </span>            : /* Do the processing for the end of a function body.  Currently, this means
<span class="lineNum">   15746 </span>            :    closing out the cleanups for fully-constructed bases and members, and in
<span class="lineNum">   15747 </span>            :    the case of the destructor, deleting the object if desired.  Again, this
<span class="lineNum">   15748 </span>            :    is only meaningful for [cd]tors, since they are the only functions where
<span class="lineNum">   15749 </span>            :    there is a significant distinction between the main body and any
<span class="lineNum">   15750 </span>            :    function catch clauses.  Handling, say, main() return semantics here
<span class="lineNum">   15751 </span>            :    would be wrong, as flowing off the end of a function catch clause for
<span class="lineNum">   15752 </span>            :    main() would also need to return 0.  */
<a name="15753"><span class="lineNum">   15753 </span>            : </a>
<span class="lineNum">   15754 </span>            : void
<span class="lineNum">   15755 </span><span class="lineCov">    7617014 : finish_function_body (tree compstmt)</span>
<span class="lineNum">   15756 </span>            : {
<span class="lineNum">   15757 </span><span class="lineCov">    7617014 :   if (compstmt == NULL_TREE)</span>
<span class="lineNum">   15758 </span>            :     return;
<span class="lineNum">   15759 </span>            : 
<span class="lineNum">   15760 </span>            :   /* Close the block.  */
<span class="lineNum">   15761 </span><span class="lineCov">    2639581 :   finish_compound_stmt (compstmt);</span>
<span class="lineNum">   15762 </span>            : 
<span class="lineNum">   15763 </span><span class="lineCov">    2639581 :   if (processing_template_decl)</span>
<span class="lineNum">   15764 </span>            :     /* Do nothing now.  */;
<span class="lineNum">   15765 </span><span class="lineCov">    2053384 :   else if (DECL_CONSTRUCTOR_P (current_function_decl))</span>
<span class="lineNum">   15766 </span><span class="lineCov">    1409157 :     finish_constructor_body ();</span>
<span class="lineNum">   15767 </span><span class="lineCov">    1288454 :   else if (DECL_DESTRUCTOR_P (current_function_decl))</span>
<span class="lineNum">   15768 </span><span class="lineCov">     589308 :     finish_destructor_body ();</span>
<span class="lineNum">   15769 </span>            : }
<span class="lineNum">   15770 </span>            : 
<span class="lineNum">   15771 </span>            : /* Given a function, returns the BLOCK corresponding to the outermost level
<span class="lineNum">   15772 </span>            :    of curly braces, skipping the artificial block created for constructor
<span class="lineNum">   15773 </span>            :    initializers.  */
<a name="15774"><span class="lineNum">   15774 </span>            : </a>
<span class="lineNum">   15775 </span>            : tree
<span class="lineNum">   15776 </span><span class="lineCov">      22423 : outer_curly_brace_block (tree fndecl)</span>
<span class="lineNum">   15777 </span>            : {
<span class="lineNum">   15778 </span><span class="lineCov">      22423 :   tree block = DECL_INITIAL (fndecl);</span>
<span class="lineNum">   15779 </span><span class="lineCov">      22423 :   if (BLOCK_OUTER_CURLY_BRACE_P (block))</span>
<span class="lineNum">   15780 </span>            :     return block;
<span class="lineNum">   15781 </span><span class="lineNoCov">          0 :   block = BLOCK_SUBBLOCKS (block);</span>
<span class="lineNum">   15782 </span><span class="lineNoCov">          0 :   if (BLOCK_OUTER_CURLY_BRACE_P (block))</span>
<span class="lineNum">   15783 </span>            :     return block;
<span class="lineNum">   15784 </span><span class="lineNoCov">          0 :   block = BLOCK_SUBBLOCKS (block);</span>
<span class="lineNum">   15785 </span><span class="lineNoCov">          0 :   gcc_assert (BLOCK_OUTER_CURLY_BRACE_P (block));</span>
<span class="lineNum">   15786 </span>            :   return block;
<span class="lineNum">   15787 </span>            : }
<span class="lineNum">   15788 </span>            : 
<span class="lineNum">   15789 </span>            : /* If FNDECL is a class's key method, add the class to the list of
<span class="lineNum">   15790 </span>            :    keyed classes that should be emitted.  */
<a name="15791"><span class="lineNum">   15791 </span>            : </a>
<span class="lineNum">   15792 </span>            : static void
<span class="lineNum">   15793 </span><span class="lineCov">   15973379 : record_key_method_defined (tree fndecl)</span>
<span class="lineNum">   15794 </span>            : {
<span class="lineNum">   15795 </span><span class="lineCov">   15973379 :   if (DECL_NONSTATIC_MEMBER_FUNCTION_P (fndecl)</span>
<span class="lineNum">   15796 </span><span class="lineCov">   10567008 :       &amp;&amp; DECL_VIRTUAL_P (fndecl)</span>
<span class="lineNum">   15797 </span><span class="lineCov">   16412628 :       &amp;&amp; !processing_template_decl)</span>
<span class="lineNum">   15798 </span>            :     {
<span class="lineNum">   15799 </span><span class="lineCov">     364793 :       tree fnclass = DECL_CONTEXT (fndecl);</span>
<span class="lineNum">   15800 </span><span class="lineCov">     364793 :       if (fndecl == CLASSTYPE_KEY_METHOD (fnclass))</span>
<span class="lineNum">   15801 </span><span class="lineCov">       1445 :         vec_safe_push (keyed_classes, fnclass);</span>
<span class="lineNum">   15802 </span>            :     }
<span class="lineNum">   15803 </span><span class="lineCov">   15973379 : }</span>
<span class="lineNum">   15804 </span>            : 
<span class="lineNum">   15805 </span>            : /* Subroutine of finish_function.
<span class="lineNum">   15806 </span>            :    Save the body of constexpr functions for possible
<span class="lineNum">   15807 </span>            :    future compile time evaluation.  */
<a name="15808"><span class="lineNum">   15808 </span>            : </a>
<span class="lineNum">   15809 </span>            : static void
<span class="lineNum">   15810 </span><span class="lineCov">   15923020 : maybe_save_function_definition (tree fun)</span>
<span class="lineNum">   15811 </span>            : {
<span class="lineNum">   15812 </span><span class="lineCov">   15923020 :   if (!processing_template_decl</span>
<span class="lineNum">   15813 </span><span class="lineCov">   24722374 :       &amp;&amp; DECL_DECLARED_CONSTEXPR_P (fun)</span>
<span class="lineNum">   15814 </span><span class="lineCov">    2313861 :       &amp;&amp; !cp_function_chain-&gt;invalid_constexpr</span>
<span class="lineNum">   15815 </span><span class="lineCov">   18236863 :       &amp;&amp; !DECL_CLONED_FUNCTION_P (fun))</span>
<span class="lineNum">   15816 </span><span class="lineCov">    1653569 :     register_constexpr_fundef (fun, DECL_SAVED_TREE (fun));</span>
<span class="lineNum">   15817 </span><span class="lineCov">   15923020 : }</span>
<span class="lineNum">   15818 </span>            : 
<span class="lineNum">   15819 </span>            : /* Attempt to add a fix-it hint to RICHLOC suggesting the insertion
<span class="lineNum">   15820 </span>            :    of &quot;return *this;&quot; immediately before its location, using FNDECL's
<span class="lineNum">   15821 </span>            :    first statement (if any) to give the indentation, if appropriate.  */
<a name="15822"><span class="lineNum">   15822 </span>            : </a>
<span class="lineNum">   15823 </span>            : static void
<span class="lineNum">   15824 </span><span class="lineCov">         18 : add_return_star_this_fixit (gcc_rich_location *richloc, tree fndecl)</span>
<span class="lineNum">   15825 </span>            : {
<span class="lineNum">   15826 </span><span class="lineCov">         18 :   location_t indent = UNKNOWN_LOCATION;</span>
<span class="lineNum">   15827 </span><span class="lineCov">         18 :   tree stmts = expr_first (DECL_SAVED_TREE (fndecl));</span>
<span class="lineNum">   15828 </span><span class="lineCov">         18 :   if (stmts)</span>
<span class="lineNum">   15829 </span><span class="lineCov">          9 :     indent = EXPR_LOCATION (stmts);</span>
<span class="lineNum">   15830 </span><span class="lineCov">         18 :   richloc-&gt;add_fixit_insert_formatted (&quot;return *this;&quot;,</span>
<span class="lineNum">   15831 </span>            :                                        richloc-&gt;get_loc (),
<span class="lineNum">   15832 </span>            :                                        indent);
<span class="lineNum">   15833 </span><span class="lineCov">         18 : }</span>
<span class="lineNum">   15834 </span>            : 
<span class="lineNum">   15835 </span>            : /* Finish up a function declaration and compile that function
<span class="lineNum">   15836 </span>            :    all the way to assembler language output.  The free the storage
<span class="lineNum">   15837 </span>            :    for the function definition. INLINE_P is TRUE if we just
<span class="lineNum">   15838 </span>            :    finished processing the body of an in-class inline function
<span class="lineNum">   15839 </span>            :    definition.  (This processing will have taken place after the
<span class="lineNum">   15840 </span>            :    class definition is complete.)  */
<a name="15841"><span class="lineNum">   15841 </span>            : </a>
<span class="lineNum">   15842 </span>            : tree
<span class="lineNum">   15843 </span><span class="lineCov">   15923020 : finish_function (bool inline_p)</span>
<span class="lineNum">   15844 </span>            : {
<span class="lineNum">   15845 </span><span class="lineCov">   15923020 :   tree fndecl = current_function_decl;</span>
<span class="lineNum">   15846 </span><span class="lineCov">   15923020 :   tree fntype, ctype = NULL_TREE;</span>
<span class="lineNum">   15847 </span>            : 
<span class="lineNum">   15848 </span>            :   /* When we get some parse errors, we can end up without a
<span class="lineNum">   15849 </span>            :      current_function_decl, so cope.  */
<span class="lineNum">   15850 </span><span class="lineCov">   15923020 :   if (fndecl == NULL_TREE)</span>
<span class="lineNum">   15851 </span><span class="lineNoCov">          0 :     return error_mark_node;</span>
<span class="lineNum">   15852 </span>            : 
<span class="lineNum">   15853 </span><span class="lineCov">   15923020 :   finish_lambda_scope ();</span>
<span class="lineNum">   15854 </span>            : 
<span class="lineNum">   15855 </span><span class="lineCov">   15923020 :   if (c_dialect_objc ())</span>
<span class="lineNum">   15856 </span><span class="lineNoCov">          0 :     objc_finish_function ();</span>
<span class="lineNum">   15857 </span>            : 
<span class="lineNum">   15858 </span><span class="lineCov">   15923020 :   record_key_method_defined (fndecl);</span>
<span class="lineNum">   15859 </span>            : 
<span class="lineNum">   15860 </span><span class="lineCov">   15923020 :   fntype = TREE_TYPE (fndecl);</span>
<span class="lineNum">   15861 </span>            : 
<span class="lineNum">   15862 </span>            :   /*  TREE_READONLY (fndecl) = 1;
<span class="lineNum">   15863 </span>            :       This caused &amp;foo to be of type ptr-to-const-function
<span class="lineNum">   15864 </span>            :       which then got a warning when stored in a ptr-to-function variable.  */
<span class="lineNum">   15865 </span>            : 
<span class="lineNum">   15866 </span><span class="lineCov">   15923020 :   gcc_assert (building_stmt_list_p ());</span>
<span class="lineNum">   15867 </span>            :   /* The current function is being defined, so its DECL_INITIAL should
<span class="lineNum">   15868 </span>            :      be set, and unless there's a multiple definition, it should be
<span class="lineNum">   15869 </span>            :      error_mark_node.  */
<span class="lineNum">   15870 </span><span class="lineCov">   15923020 :   gcc_assert (DECL_INITIAL (fndecl) == error_mark_node);</span>
<span class="lineNum">   15871 </span>            : 
<span class="lineNum">   15872 </span>            :   /* For a cloned function, we've already got all the code we need;
<span class="lineNum">   15873 </span>            :      there's no need to add any extra bits.  */
<span class="lineNum">   15874 </span><span class="lineCov">   15923020 :   if (!DECL_CLONED_FUNCTION_P (fndecl))</span>
<span class="lineNum">   15875 </span>            :     {
<span class="lineNum">   15876 </span>            :       /* Make it so that `main' always returns 0 by default.  */
<span class="lineNum">   15877 </span><span class="lineCov">   11832189 :       if (DECL_MAIN_P (current_function_decl))</span>
<span class="lineNum">   15878 </span><span class="lineCov">      21743 :         finish_return_stmt (integer_zero_node);</span>
<span class="lineNum">   15879 </span>            : 
<span class="lineNum">   15880 </span><span class="lineCov">   11832189 :       if (use_eh_spec_block (current_function_decl))</span>
<span class="lineNum">   15881 </span><span class="lineCov">    5089895 :         finish_eh_spec_block (TYPE_RAISES_EXCEPTIONS</span>
<span class="lineNum">   15882 </span>            :                               (TREE_TYPE (current_function_decl)),
<span class="lineNum">   15883 </span><span class="lineCov">    3154956 :                               current_eh_spec_block);</span>
<span class="lineNum">   15884 </span>            :     }
<span class="lineNum">   15885 </span>            : 
<span class="lineNum">   15886 </span>            :   /* If we're saving up tree structure, tie off the function now.  */
<span class="lineNum">   15887 </span><span class="lineCov">   15923020 :   DECL_SAVED_TREE (fndecl) = pop_stmt_list (DECL_SAVED_TREE (fndecl));</span>
<span class="lineNum">   15888 </span>            : 
<span class="lineNum">   15889 </span><span class="lineCov">   15923020 :   finish_fname_decls ();</span>
<span class="lineNum">   15890 </span>            : 
<span class="lineNum">   15891 </span>            :   /* If this function can't throw any exceptions, remember that.  */
<span class="lineNum">   15892 </span><span class="lineCov">   15923020 :   if (!processing_template_decl</span>
<span class="lineNum">   15893 </span><span class="lineCov">   12361187 :       &amp;&amp; !cp_function_chain-&gt;can_throw</span>
<span class="lineNum">   15894 </span><span class="lineCov">    8487411 :       &amp;&amp; !flag_non_call_exceptions</span>
<span class="lineNum">   15895 </span><span class="lineCov">   24407274 :       &amp;&amp; !decl_replaceable_p (fndecl))</span>
<span class="lineNum">   15896 </span><span class="lineCov">    8044411 :     TREE_NOTHROW (fndecl) = 1;</span>
<span class="lineNum">   15897 </span>            : 
<span class="lineNum">   15898 </span>            :   /* This must come after expand_function_end because cleanups might
<span class="lineNum">   15899 </span>            :      have declarations (from inline functions) that need to go into
<span class="lineNum">   15900 </span>            :      this function's blocks.  */
<span class="lineNum">   15901 </span>            : 
<span class="lineNum">   15902 </span>            :   /* If the current binding level isn't the outermost binding level
<span class="lineNum">   15903 </span>            :      for this function, either there is a bug, or we have experienced
<span class="lineNum">   15904 </span>            :      syntax errors and the statement tree is malformed.  */
<span class="lineNum">   15905 </span><span class="lineCov">   15923020 :   if (current_binding_level-&gt;kind != sk_function_parms)</span>
<span class="lineNum">   15906 </span>            :     {
<span class="lineNum">   15907 </span>            :       /* Make sure we have already experienced errors.  */
<span class="lineNum">   15908 </span><span class="lineCov">          3 :       gcc_assert (errorcount);</span>
<span class="lineNum">   15909 </span>            : 
<span class="lineNum">   15910 </span>            :       /* Throw away the broken statement tree and extra binding
<span class="lineNum">   15911 </span>            :          levels.  */
<span class="lineNum">   15912 </span><span class="lineCov">          3 :       DECL_SAVED_TREE (fndecl) = alloc_stmt_list ();</span>
<span class="lineNum">   15913 </span>            : 
<span class="lineNum">   15914 </span><span class="lineCov">          6 :       while (current_binding_level-&gt;kind != sk_function_parms)</span>
<span class="lineNum">   15915 </span>            :         {
<span class="lineNum">   15916 </span><span class="lineCov">          3 :           if (current_binding_level-&gt;kind == sk_class)</span>
<span class="lineNum">   15917 </span><span class="lineNoCov">          0 :             pop_nested_class ();</span>
<span class="lineNum">   15918 </span>            :           else
<span class="lineNum">   15919 </span><span class="lineCov">          3 :             poplevel (0, 0, 0);</span>
<span class="lineNum">   15920 </span>            :         }
<span class="lineNum">   15921 </span>            :     }
<span class="lineNum">   15922 </span><span class="lineCov">   15923020 :   poplevel (1, 0, 1);</span>
<span class="lineNum">   15923 </span>            : 
<span class="lineNum">   15924 </span>            :   /* Statements should always be full-expressions at the outermost set
<span class="lineNum">   15925 </span>            :      of curly braces for a function.  */
<span class="lineNum">   15926 </span><span class="lineCov">   15923020 :   gcc_assert (stmts_are_full_exprs_p ());</span>
<span class="lineNum">   15927 </span>            : 
<span class="lineNum">   15928 </span>            :   /* If there are no return statements in a function with auto return type,
<span class="lineNum">   15929 </span>            :      the return type is void.  But if the declared type is something like
<span class="lineNum">   15930 </span>            :      auto*, this is an error.  */
<span class="lineNum">   15931 </span><span class="lineCov">   12361187 :   if (!processing_template_decl &amp;&amp; FNDECL_USED_AUTO (fndecl)</span>
<span class="lineNum">   15932 </span><span class="lineCov">   15951703 :       &amp;&amp; TREE_TYPE (fntype) == current_function_auto_return_pattern)</span>
<span class="lineNum">   15933 </span>            :     {
<span class="lineNum">   15934 </span><span class="lineCov">      26344 :       if (is_auto (current_function_auto_return_pattern))</span>
<span class="lineNum">   15935 </span>            :         {
<span class="lineNum">   15936 </span><span class="lineCov">      26339 :           apply_deduced_return_type (fndecl, void_type_node);</span>
<span class="lineNum">   15937 </span><span class="lineCov">      26339 :           fntype = TREE_TYPE (fndecl);</span>
<span class="lineNum">   15938 </span>            :         }
<span class="lineNum">   15939 </span><span class="lineCov">         10 :       else if (!current_function_returns_value</span>
<span class="lineNum">   15940 </span><span class="lineCov">          5 :                &amp;&amp; !current_function_returns_null)</span>
<span class="lineNum">   15941 </span>            :         {
<span class="lineNum">   15942 </span><span class="lineCov">          2 :           error (&quot;no return statements in function returning %qT&quot;,</span>
<span class="lineNum">   15943 </span>            :                  current_function_auto_return_pattern);
<span class="lineNum">   15944 </span><span class="lineCov">          2 :           inform (input_location, &quot;only plain %&lt;auto%&gt; return type can be &quot;</span>
<span class="lineNum">   15945 </span>            :                   &quot;deduced to %&lt;void%&gt;&quot;);
<span class="lineNum">   15946 </span>            :         }
<span class="lineNum">   15947 </span>            :     }
<span class="lineNum">   15948 </span>            : 
<span class="lineNum">   15949 </span>            :   // If this is a concept, check that the definition is reasonable.
<span class="lineNum">   15950 </span><span class="lineCov">   15923020 :   if (DECL_DECLARED_CONCEPT_P (fndecl))</span>
<span class="lineNum">   15951 </span><span class="lineCov">        203 :     check_function_concept (fndecl);</span>
<span class="lineNum">   15952 </span>            : 
<span class="lineNum">   15953 </span>            :   /* Lambda closure members are implicitly constexpr if possible.  */
<span class="lineNum">   15954 </span><span class="lineCov">   15923020 :   if (cxx_dialect &gt;= cxx17</span>
<span class="lineNum">   15955 </span><span class="lineCov">   15923020 :       &amp;&amp; LAMBDA_TYPE_P (CP_DECL_CONTEXT (fndecl)))</span>
<span class="lineNum">   15956 </span><span class="lineCov">       2984 :     DECL_DECLARED_CONSTEXPR_P (fndecl)</span>
<span class="lineNum">   15957 </span><span class="lineCov">       1492 :       = ((processing_template_decl</span>
<span class="lineNum">   15958 </span><span class="lineCov">        459 :           || is_valid_constexpr_fn (fndecl, /*complain*/false))</span>
<span class="lineNum">   15959 </span><span class="lineCov">       1912 :          &amp;&amp; potential_constant_expression (DECL_SAVED_TREE (fndecl)));</span>
<span class="lineNum">   15960 </span>            : 
<span class="lineNum">   15961 </span>            :   /* Save constexpr function body before it gets munged by
<span class="lineNum">   15962 </span>            :      the NRV transformation.   */
<span class="lineNum">   15963 </span><span class="lineCov">   15923020 :   maybe_save_function_definition (fndecl);</span>
<span class="lineNum">   15964 </span>            : 
<span class="lineNum">   15965 </span>            :   /* Invoke the pre-genericize plugin before we start munging things.  */
<span class="lineNum">   15966 </span><span class="lineCov">   15923020 :   if (!processing_template_decl)</span>
<span class="lineNum">   15967 </span><span class="lineCov">   12361187 :     invoke_plugin_callbacks (PLUGIN_PRE_GENERICIZE, fndecl);</span>
<span class="lineNum">   15968 </span>            : 
<span class="lineNum">   15969 </span>            :   /* Perform delayed folding before NRV transformation.  */
<span class="lineNum">   15970 </span><span class="lineCov">   15923020 :   if (!processing_template_decl)</span>
<span class="lineNum">   15971 </span><span class="lineCov">   12361187 :     cp_fold_function (fndecl);</span>
<span class="lineNum">   15972 </span>            : 
<span class="lineNum">   15973 </span>            :   /* Set up the named return value optimization, if we can.  Candidate
<span class="lineNum">   15974 </span>            :      variables are selected in check_return_expr.  */
<span class="lineNum">   15975 </span><span class="lineCov">   15923020 :   if (current_function_return_value)</span>
<span class="lineNum">   15976 </span>            :     {
<span class="lineNum">   15977 </span><span class="lineCov">    5109134 :       tree r = current_function_return_value;</span>
<span class="lineNum">   15978 </span><span class="lineCov">    5109134 :       tree outer;</span>
<span class="lineNum">   15979 </span>            : 
<span class="lineNum">   15980 </span><span class="lineCov">    5109134 :       if (r != error_mark_node</span>
<span class="lineNum">   15981 </span>            :           /* This is only worth doing for fns that return in memory--and
<span class="lineNum">   15982 </span>            :              simpler, since we don't have to worry about promoted modes.  */
<span class="lineNum">   15983 </span><span class="lineCov">     226916 :           &amp;&amp; aggregate_value_p (TREE_TYPE (TREE_TYPE (fndecl)), fndecl)</span>
<span class="lineNum">   15984 </span>            :           /* Only allow this for variables declared in the outer scope of
<span class="lineNum">   15985 </span>            :              the function so we know that their lifetime always ends with a
<span class="lineNum">   15986 </span>            :              return; see g++.dg/opt/nrv6.C.  We could be more flexible if
<span class="lineNum">   15987 </span>            :              we were to do this optimization in tree-ssa.  */
<span class="lineNum">   15988 </span><span class="lineCov">      12770 :           &amp;&amp; (outer = outer_curly_brace_block (fndecl))</span>
<span class="lineNum">   15989 </span><span class="lineCov">    5121904 :           &amp;&amp; chain_member (r, BLOCK_VARS (outer)))</span>
<span class="lineNum">   15990 </span><span class="lineCov">      12764 :         finalize_nrv (&amp;DECL_SAVED_TREE (fndecl), r, DECL_RESULT (fndecl));</span>
<span class="lineNum">   15991 </span>            : 
<span class="lineNum">   15992 </span><span class="lineCov">    5109134 :       current_function_return_value = NULL_TREE;</span>
<span class="lineNum">   15993 </span>            :     }
<span class="lineNum">   15994 </span>            : 
<span class="lineNum">   15995 </span>            :   /* Remember that we were in class scope.  */
<span class="lineNum">   15996 </span><span class="lineCov">   15923020 :   if (current_class_name)</span>
<span class="lineNum">   15997 </span><span class="lineCov">   12416704 :     ctype = current_class_type;</span>
<span class="lineNum">   15998 </span>            : 
<span class="lineNum">   15999 </span>            :   /* Must mark the RESULT_DECL as being in this function.  */
<span class="lineNum">   16000 </span><span class="lineCov">   15923020 :   DECL_CONTEXT (DECL_RESULT (fndecl)) = fndecl;</span>
<span class="lineNum">   16001 </span>            : 
<span class="lineNum">   16002 </span>            :   /* Set the BLOCK_SUPERCONTEXT of the outermost function scope to point
<span class="lineNum">   16003 </span>            :      to the FUNCTION_DECL node itself.  */
<span class="lineNum">   16004 </span><span class="lineCov">   15923020 :   BLOCK_SUPERCONTEXT (DECL_INITIAL (fndecl)) = fndecl;</span>
<span class="lineNum">   16005 </span>            : 
<span class="lineNum">   16006 </span>            :   /* Save away current state, if appropriate.  */
<span class="lineNum">   16007 </span><span class="lineCov">   15923020 :   if (!processing_template_decl)</span>
<span class="lineNum">   16008 </span><span class="lineCov">   12361187 :     save_function_data (fndecl);</span>
<span class="lineNum">   16009 </span>            : 
<span class="lineNum">   16010 </span>            :   /* Complain if there's just no return statement.  */
<span class="lineNum">   16011 </span><span class="lineCov">   15923020 :   if (warn_return_type</span>
<span class="lineNum">   16012 </span><span class="lineCov">   15888849 :       &amp;&amp; !VOID_TYPE_P (TREE_TYPE (fntype))</span>
<span class="lineNum">   16013 </span><span class="lineCov">   14689218 :       &amp;&amp; !dependent_type_p (TREE_TYPE (fntype))</span>
<span class="lineNum">   16014 </span><span class="lineCov">    5606192 :       &amp;&amp; !current_function_returns_value &amp;&amp; !current_function_returns_null</span>
<span class="lineNum">   16015 </span>            :       /* Don't complain if we abort or throw.  */
<span class="lineNum">   16016 </span>            :       &amp;&amp; !current_function_returns_abnormally
<span class="lineNum">   16017 </span>            :       /* Don't complain if there's an infinite loop.  */
<span class="lineNum">   16018 </span><span class="lineCov">    5606192 :       &amp;&amp; !current_function_infinite_loop</span>
<span class="lineNum">   16019 </span>            :       /* Don't complain if we are declared noreturn.  */
<span class="lineNum">   16020 </span><span class="lineCov">        560 :       &amp;&amp; !TREE_THIS_VOLATILE (fndecl)</span>
<span class="lineNum">   16021 </span><span class="lineCov">        557 :       &amp;&amp; !DECL_NAME (DECL_RESULT (fndecl))</span>
<span class="lineNum">   16022 </span><span class="lineCov">        557 :       &amp;&amp; !TREE_NO_WARNING (fndecl)</span>
<span class="lineNum">   16023 </span>            :       /* Structor return values (if any) are set by the compiler.  */
<span class="lineNum">   16024 </span><span class="lineCov">        491 :       &amp;&amp; !DECL_CONSTRUCTOR_P (fndecl)</span>
<span class="lineNum">   16025 </span><span class="lineCov">        982 :       &amp;&amp; !DECL_DESTRUCTOR_P (fndecl)</span>
<span class="lineNum">   16026 </span><span class="lineCov">   15923511 :       &amp;&amp; targetm.warn_func_return (fndecl))</span>
<span class="lineNum">   16027 </span>            :     {
<span class="lineNum">   16028 </span><span class="lineCov">        976 :       gcc_rich_location richloc (input_location);</span>
<span class="lineNum">   16029 </span>            :       /* Potentially add a &quot;return *this;&quot; fix-it hint for
<span class="lineNum">   16030 </span>            :          assignment operators.  */
<span class="lineNum">   16031 </span><span class="lineCov">        488 :       if (IDENTIFIER_ASSIGN_OP_P (DECL_NAME (fndecl)))</span>
<span class="lineNum">   16032 </span>            :         {
<span class="lineNum">   16033 </span><span class="lineCov">         35 :           tree valtype = TREE_TYPE (DECL_RESULT (fndecl));</span>
<span class="lineNum">   16034 </span><span class="lineCov">         35 :           if (TREE_CODE (valtype) == REFERENCE_TYPE</span>
<span class="lineNum">   16035 </span><span class="lineCov">         61 :               &amp;&amp; same_type_ignoring_top_level_qualifiers_p</span>
<span class="lineNum">   16036 </span><span class="lineCov">         26 :                   (TREE_TYPE (valtype), TREE_TYPE (current_class_ref)))</span>
<span class="lineNum">   16037 </span><span class="lineCov">         18 :             if (global_dc-&gt;option_enabled (OPT_Wreturn_type,</span>
<span class="lineNum">   16038 </span>            :                                            global_dc-&gt;option_state))
<span class="lineNum">   16039 </span><span class="lineCov">         18 :               add_return_star_this_fixit (&amp;richloc, fndecl);</span>
<span class="lineNum">   16040 </span>            :         }
<span class="lineNum">   16041 </span><span class="lineCov">        488 :       warning_at (&amp;richloc, OPT_Wreturn_type,</span>
<span class="lineNum">   16042 </span>            :                   &quot;no return statement in function returning non-void&quot;);
<span class="lineNum">   16043 </span><span class="lineCov">        488 :       TREE_NO_WARNING (fndecl) = 1;</span>
<span class="lineNum">   16044 </span>            :     }
<span class="lineNum">   16045 </span>            : 
<span class="lineNum">   16046 </span>            :   /* Store the end of the function, so that we get good line number
<span class="lineNum">   16047 </span>            :      info for the epilogue.  */
<span class="lineNum">   16048 </span><span class="lineCov">   15923020 :   cfun-&gt;function_end_locus = input_location;</span>
<span class="lineNum">   16049 </span>            : 
<span class="lineNum">   16050 </span>            :   /* Complain about parameters that are only set, but never otherwise used.  */
<span class="lineNum">   16051 </span><span class="lineCov">   15923020 :   if (warn_unused_but_set_parameter</span>
<span class="lineNum">   16052 </span><span class="lineCov">     669210 :       &amp;&amp; !processing_template_decl</span>
<span class="lineNum">   16053 </span><span class="lineCov">     321290 :       &amp;&amp; errorcount == unused_but_set_errorcount</span>
<span class="lineNum">   16054 </span><span class="lineCov">   16244310 :       &amp;&amp; !DECL_CLONED_FUNCTION_P (fndecl))</span>
<span class="lineNum">   16055 </span>            :     {
<span class="lineNum">   16056 </span><span class="lineCov">     243790 :       tree decl;</span>
<span class="lineNum">   16057 </span>            : 
<span class="lineNum">   16058 </span><span class="lineCov">     243790 :       for (decl = DECL_ARGUMENTS (fndecl);</span>
<span class="lineNum">   16059 </span><span class="lineCov">     652739 :            decl;</span>
<span class="lineNum">   16060 </span><span class="lineCov">     408949 :            decl = DECL_CHAIN (decl))</span>
<span class="lineNum">   16061 </span><span class="lineCov">     408949 :         if (TREE_USED (decl)</span>
<span class="lineNum">   16062 </span><span class="lineCov">     408949 :             &amp;&amp; TREE_CODE (decl) == PARM_DECL</span>
<span class="lineNum">   16063 </span><span class="lineCov">     636290 :             &amp;&amp; !DECL_READ_P (decl)</span>
<span class="lineNum">   16064 </span><span class="lineCov">          6 :             &amp;&amp; DECL_NAME (decl)</span>
<span class="lineNum">   16065 </span><span class="lineCov">          6 :             &amp;&amp; !DECL_ARTIFICIAL (decl)</span>
<span class="lineNum">   16066 </span><span class="lineCov">          6 :             &amp;&amp; !TREE_NO_WARNING (decl)</span>
<span class="lineNum">   16067 </span><span class="lineCov">         12 :             &amp;&amp; !DECL_IN_SYSTEM_HEADER (decl)</span>
<span class="lineNum">   16068 </span><span class="lineCov">          6 :             &amp;&amp; TREE_TYPE (decl) != error_mark_node</span>
<span class="lineNum">   16069 </span><span class="lineCov">         12 :             &amp;&amp; !TYPE_REF_P (TREE_TYPE (decl))</span>
<span class="lineNum">   16070 </span><span class="lineCov">     408961 :             &amp;&amp; (!CLASS_TYPE_P (TREE_TYPE (decl))</span>
<span class="lineNum">   16071 </span><span class="lineNoCov">          0 :                 || !TYPE_HAS_NONTRIVIAL_DESTRUCTOR (TREE_TYPE (decl))))</span>
<span class="lineNum">   16072 </span><span class="lineCov">          6 :           warning_at (DECL_SOURCE_LOCATION (decl),</span>
<span class="lineNum">   16073 </span>            :                       OPT_Wunused_but_set_parameter,
<span class="lineNum">   16074 </span>            :                       &quot;parameter %qD set but not used&quot;, decl);
<span class="lineNum">   16075 </span><span class="lineCov">     243790 :       unused_but_set_errorcount = errorcount;</span>
<span class="lineNum">   16076 </span>            :     }
<span class="lineNum">   16077 </span>            : 
<span class="lineNum">   16078 </span>            :   /* Complain about locally defined typedefs that are not used in this
<span class="lineNum">   16079 </span>            :      function.  */
<span class="lineNum">   16080 </span><span class="lineCov">   15923020 :   maybe_warn_unused_local_typedefs ();</span>
<span class="lineNum">   16081 </span>            : 
<span class="lineNum">   16082 </span>            :   /* Possibly warn about unused parameters.  */
<span class="lineNum">   16083 </span><span class="lineCov">   15923020 :   if (warn_unused_parameter</span>
<span class="lineNum">   16084 </span><span class="lineCov">     505338 :       &amp;&amp; !processing_template_decl </span>
<span class="lineNum">   16085 </span><span class="lineCov">   16144890 :       &amp;&amp; !DECL_CLONED_FUNCTION_P (fndecl))</span>
<span class="lineNum">   16086 </span><span class="lineCov">     164388 :     do_warn_unused_parameter (fndecl);</span>
<span class="lineNum">   16087 </span>            : 
<span class="lineNum">   16088 </span>            :   /* Genericize before inlining.  */
<span class="lineNum">   16089 </span><span class="lineCov">   15923020 :   if (!processing_template_decl)</span>
<span class="lineNum">   16090 </span>            :     {
<span class="lineNum">   16091 </span><span class="lineCov">   12361187 :       struct language_function *f = DECL_SAVED_FUNCTION_DATA (fndecl);</span>
<span class="lineNum">   16092 </span><span class="lineCov">   12361187 :       cp_genericize (fndecl);</span>
<span class="lineNum">   16093 </span>            :       /* Clear out the bits we don't need.  */
<span class="lineNum">   16094 </span><span class="lineCov">   12361187 :       f-&gt;x_current_class_ptr = NULL;</span>
<span class="lineNum">   16095 </span><span class="lineCov">   12361187 :       f-&gt;x_current_class_ref = NULL;</span>
<span class="lineNum">   16096 </span><span class="lineCov">   12361187 :       f-&gt;x_eh_spec_block = NULL;</span>
<span class="lineNum">   16097 </span><span class="lineCov">   12361187 :       f-&gt;x_in_charge_parm = NULL;</span>
<span class="lineNum">   16098 </span><span class="lineCov">   12361187 :       f-&gt;x_vtt_parm = NULL;</span>
<span class="lineNum">   16099 </span><span class="lineCov">   12361187 :       f-&gt;x_return_value = NULL;</span>
<span class="lineNum">   16100 </span><span class="lineCov">   12361187 :       f-&gt;bindings = NULL;</span>
<span class="lineNum">   16101 </span><span class="lineCov">   12361187 :       f-&gt;extern_decl_map = NULL;</span>
<span class="lineNum">   16102 </span><span class="lineCov">   12361187 :       f-&gt;infinite_loops = NULL;</span>
<span class="lineNum">   16103 </span>            :     }
<span class="lineNum">   16104 </span>            :   /* Clear out the bits we don't need.  */
<span class="lineNum">   16105 </span><span class="lineCov">   15923020 :   local_names = NULL;</span>
<span class="lineNum">   16106 </span>            : 
<span class="lineNum">   16107 </span>            :   /* We're leaving the context of this function, so zap cfun.  It's still in
<span class="lineNum">   16108 </span>            :      DECL_STRUCT_FUNCTION, and we'll restore it in tree_rest_of_compilation.  */
<span class="lineNum">   16109 </span><span class="lineCov">   15923020 :   set_cfun (NULL);</span>
<span class="lineNum">   16110 </span><span class="lineCov">   15923020 :   current_function_decl = NULL;</span>
<span class="lineNum">   16111 </span>            : 
<span class="lineNum">   16112 </span>            :   /* If this is an in-class inline definition, we may have to pop the
<span class="lineNum">   16113 </span>            :      bindings for the template parameters that we added in
<span class="lineNum">   16114 </span>            :      maybe_begin_member_template_processing when start_function was
<span class="lineNum">   16115 </span>            :      called.  */
<span class="lineNum">   16116 </span><span class="lineCov">   15923020 :   if (inline_p)</span>
<span class="lineNum">   16117 </span><span class="lineCov">    3115954 :     maybe_end_member_template_processing ();</span>
<span class="lineNum">   16118 </span>            : 
<span class="lineNum">   16119 </span>            :   /* Leave the scope of the class.  */
<span class="lineNum">   16120 </span><span class="lineCov">   15923020 :   if (ctype)</span>
<span class="lineNum">   16121 </span><span class="lineCov">   12416704 :     pop_nested_class ();</span>
<span class="lineNum">   16122 </span>            : 
<span class="lineNum">   16123 </span><span class="lineCov">   15923020 :   --function_depth;</span>
<span class="lineNum">   16124 </span>            : 
<span class="lineNum">   16125 </span>            :   /* Clean up.  */
<span class="lineNum">   16126 </span><span class="lineCov">   15923020 :   current_function_decl = NULL_TREE;</span>
<span class="lineNum">   16127 </span>            : 
<span class="lineNum">   16128 </span><span class="lineCov">   15923020 :   invoke_plugin_callbacks (PLUGIN_FINISH_PARSE_FUNCTION, fndecl);</span>
<span class="lineNum">   16129 </span>            :   return fndecl;
<span class="lineNum">   16130 </span>            : }
<span class="lineNum">   16131 </span>            : 
<span class="lineNum">   16132 </span>            : /* Create the FUNCTION_DECL for a function definition.
<span class="lineNum">   16133 </span>            :    DECLSPECS and DECLARATOR are the parts of the declaration;
<span class="lineNum">   16134 </span>            :    they describe the return type and the name of the function,
<span class="lineNum">   16135 </span>            :    but twisted together in a fashion that parallels the syntax of C.
<span class="lineNum">   16136 </span>            : 
<span class="lineNum">   16137 </span>            :    This function creates a binding context for the function body
<span class="lineNum">   16138 </span>            :    as well as setting up the FUNCTION_DECL in current_function_decl.
<span class="lineNum">   16139 </span>            : 
<span class="lineNum">   16140 </span>            :    Returns a FUNCTION_DECL on success.
<span class="lineNum">   16141 </span>            : 
<span class="lineNum">   16142 </span>            :    If the DECLARATOR is not suitable for a function (it defines a datum
<span class="lineNum">   16143 </span>            :    instead), we return 0, which tells yyparse to report a parse error.
<span class="lineNum">   16144 </span>            : 
<span class="lineNum">   16145 </span>            :    May return void_type_node indicating that this method is actually
<span class="lineNum">   16146 </span>            :    a friend.  See grokfield for more details.
<span class="lineNum">   16147 </span>            : 
<span class="lineNum">   16148 </span>            :    Came here with a `.pushlevel' .
<span class="lineNum">   16149 </span>            : 
<span class="lineNum">   16150 </span>            :    DO NOT MAKE ANY CHANGES TO THIS CODE WITHOUT MAKING CORRESPONDING
<span class="lineNum">   16151 </span>            :    CHANGES TO CODE IN `grokfield'.  */
<a name="16152"><span class="lineNum">   16152 </span>            : </a>
<span class="lineNum">   16153 </span>            : tree
<span class="lineNum">   16154 </span><span class="lineCov">    3063068 : grokmethod (cp_decl_specifier_seq *declspecs,</span>
<span class="lineNum">   16155 </span>            :             const cp_declarator *declarator, tree attrlist)
<span class="lineNum">   16156 </span>            : {
<span class="lineNum">   16157 </span><span class="lineCov">    3063068 :   tree fndecl = grokdeclarator (declarator, declspecs, MEMFUNCDEF, 0,</span>
<span class="lineNum">   16158 </span><span class="lineCov">    3063068 :                                 &amp;attrlist);</span>
<span class="lineNum">   16159 </span>            : 
<span class="lineNum">   16160 </span><span class="lineCov">    3063068 :   if (fndecl == error_mark_node)</span>
<span class="lineNum">   16161 </span>            :     return error_mark_node;
<span class="lineNum">   16162 </span>            : 
<span class="lineNum">   16163 </span><span class="lineCov">    3063023 :   if (fndecl == NULL || TREE_CODE (fndecl) != FUNCTION_DECL)</span>
<span class="lineNum">   16164 </span>            :     {
<span class="lineNum">   16165 </span><span class="lineCov">          3 :       error (&quot;invalid member function declaration&quot;);</span>
<span class="lineNum">   16166 </span><span class="lineCov">          3 :       return error_mark_node;</span>
<span class="lineNum">   16167 </span>            :     }
<span class="lineNum">   16168 </span>            : 
<span class="lineNum">   16169 </span><span class="lineCov">    3063020 :   if (attrlist)</span>
<span class="lineNum">   16170 </span><span class="lineCov">          3 :     cplus_decl_attributes (&amp;fndecl, attrlist, 0);</span>
<span class="lineNum">   16171 </span>            : 
<span class="lineNum">   16172 </span>            :   /* Pass friends other than inline friend functions back.  */
<span class="lineNum">   16173 </span><span class="lineCov">    3063020 :   if (fndecl == void_type_node)</span>
<span class="lineNum">   16174 </span>            :     return fndecl;
<span class="lineNum">   16175 </span>            : 
<span class="lineNum">   16176 </span><span class="lineCov">    3063020 :   if (DECL_IN_AGGR_P (fndecl))</span>
<span class="lineNum">   16177 </span>            :     {
<span class="lineNum">   16178 </span><span class="lineNoCov">          0 :       if (DECL_CLASS_SCOPE_P (fndecl))</span>
<span class="lineNum">   16179 </span><span class="lineNoCov">          0 :         error (&quot;%qD is already defined in class %qT&quot;, fndecl,</span>
<span class="lineNum">   16180 </span><span class="lineNoCov">          0 :                DECL_CONTEXT (fndecl));</span>
<span class="lineNum">   16181 </span><span class="lineNoCov">          0 :       return error_mark_node;</span>
<span class="lineNum">   16182 </span>            :     }
<span class="lineNum">   16183 </span>            : 
<span class="lineNum">   16184 </span><span class="lineCov">    3063020 :   check_template_shadow (fndecl);</span>
<span class="lineNum">   16185 </span>            : 
<span class="lineNum">   16186 </span><span class="lineCov">    3063020 :   if (TREE_PUBLIC (fndecl))</span>
<span class="lineNum">   16187 </span><span class="lineCov">    3043672 :     DECL_COMDAT (fndecl) = 1;</span>
<span class="lineNum">   16188 </span><span class="lineCov">    3063020 :   DECL_DECLARED_INLINE_P (fndecl) = 1;</span>
<span class="lineNum">   16189 </span><span class="lineCov">    3063020 :   DECL_NO_INLINE_WARNING_P (fndecl) = 1;</span>
<span class="lineNum">   16190 </span>            : 
<span class="lineNum">   16191 </span>            :   /* We process method specializations in finish_struct_1.  */
<span class="lineNum">   16192 </span><span class="lineCov">    3063020 :   if (processing_template_decl &amp;&amp; !DECL_TEMPLATE_SPECIALIZATION (fndecl))</span>
<span class="lineNum">   16193 </span>            :     {
<span class="lineNum">   16194 </span><span class="lineCov">    2301310 :       fndecl = push_template_decl (fndecl);</span>
<span class="lineNum">   16195 </span><span class="lineCov">    2301310 :       if (fndecl == error_mark_node)</span>
<span class="lineNum">   16196 </span>            :         return fndecl;
<span class="lineNum">   16197 </span>            :     }
<span class="lineNum">   16198 </span>            : 
<span class="lineNum">   16199 </span><span class="lineCov">    6126028 :   if (! DECL_FRIEND_P (fndecl))</span>
<span class="lineNum">   16200 </span>            :     {
<span class="lineNum">   16201 </span><span class="lineCov">    3035920 :       if (DECL_CHAIN (fndecl))</span>
<span class="lineNum">   16202 </span>            :         {
<span class="lineNum">   16203 </span><span class="lineNoCov">          0 :           fndecl = copy_node (fndecl);</span>
<span class="lineNum">   16204 </span><span class="lineNoCov">          0 :           TREE_CHAIN (fndecl) = NULL_TREE;</span>
<span class="lineNum">   16205 </span>            :         }
<span class="lineNum">   16206 </span>            :     }
<span class="lineNum">   16207 </span>            : 
<span class="lineNum">   16208 </span><span class="lineCov">    3063014 :   cp_finish_decl (fndecl, NULL_TREE, false, NULL_TREE, 0);</span>
<span class="lineNum">   16209 </span>            : 
<span class="lineNum">   16210 </span><span class="lineCov">    3063014 :   DECL_IN_AGGR_P (fndecl) = 1;</span>
<span class="lineNum">   16211 </span><span class="lineCov">    3063014 :   return fndecl;</span>
<span class="lineNum">   16212 </span>            : }
<span class="lineNum">   16213 </span>            : 
<span class="lineNum">   16214 </span>            : 
<span class="lineNum">   16215 </span>            : /* VAR is a VAR_DECL.  If its type is incomplete, remember VAR so that
<span class="lineNum">   16216 </span>            :    we can lay it out later, when and if its type becomes complete.
<span class="lineNum">   16217 </span>            : 
<span class="lineNum">   16218 </span>            :    Also handle constexpr variables where the initializer involves
<span class="lineNum">   16219 </span>            :    an unlowered PTRMEM_CST because the class isn't complete yet.  */
<a name="16220"><span class="lineNum">   16220 </span>            : </a>
<span class="lineNum">   16221 </span>            : void
<span class="lineNum">   16222 </span><span class="lineCov">    5250817 : maybe_register_incomplete_var (tree var)</span>
<span class="lineNum">   16223 </span>            : {
<span class="lineNum">   16224 </span><span class="lineCov">    5250817 :   gcc_assert (VAR_P (var));</span>
<span class="lineNum">   16225 </span>            : 
<span class="lineNum">   16226 </span>            :   /* Keep track of variables with incomplete types.  */
<span class="lineNum">   16227 </span><span class="lineCov">    3616691 :   if (!processing_template_decl &amp;&amp; TREE_TYPE (var) != error_mark_node</span>
<span class="lineNum">   16228 </span><span class="lineCov">    8866501 :       &amp;&amp; DECL_EXTERNAL (var))</span>
<span class="lineNum">   16229 </span>            :     {
<span class="lineNum">   16230 </span>            :       tree inner_type = TREE_TYPE (var);
<span class="lineNum">   16231 </span>            : 
<span class="lineNum">   16232 </span><span class="lineCov">    1003050 :       while (TREE_CODE (inner_type) == ARRAY_TYPE)</span>
<span class="lineNum">   16233 </span><span class="lineCov">      23108 :         inner_type = TREE_TYPE (inner_type);</span>
<span class="lineNum">   16234 </span><span class="lineCov">     979942 :       inner_type = TYPE_MAIN_VARIANT (inner_type);</span>
<span class="lineNum">   16235 </span>            : 
<span class="lineNum">   16236 </span><span class="lineCov">     990853 :       if ((!COMPLETE_TYPE_P (inner_type) &amp;&amp; CLASS_TYPE_P (inner_type))</span>
<span class="lineNum">   16237 </span>            :           /* RTTI TD entries are created while defining the type_info.  */
<span class="lineNum">   16238 </span><span class="lineCov">     979988 :           || (TYPE_LANG_SPECIFIC (inner_type)</span>
<span class="lineNum">   16239 </span><span class="lineCov">     399376 :               &amp;&amp; TYPE_BEING_DEFINED (inner_type)))</span>
<span class="lineNum">   16240 </span>            :         {
<span class="lineNum">   16241 </span><span class="lineCov">      10888 :           incomplete_var iv = {var, inner_type};</span>
<span class="lineNum">   16242 </span><span class="lineCov">      10888 :           vec_safe_push (incomplete_vars, iv);</span>
<span class="lineNum">   16243 </span>            :         }
<span class="lineNum">   16244 </span><span class="lineCov">     969054 :       else if (!(DECL_LANG_SPECIFIC (var) &amp;&amp; DECL_TEMPLATE_INFO (var))</span>
<span class="lineNum">   16245 </span><span class="lineCov">     796429 :                &amp;&amp; decl_constant_var_p (var)</span>
<span class="lineNum">   16246 </span><span class="lineCov">    1306601 :                &amp;&amp; (TYPE_PTRMEM_P (inner_type) || CLASS_TYPE_P (inner_type)))</span>
<span class="lineNum">   16247 </span>            :         {
<span class="lineNum">   16248 </span>            :           /* When the outermost open class is complete we can resolve any
<span class="lineNum">   16249 </span>            :              pointers-to-members.  */
<span class="lineNum">   16250 </span><span class="lineCov">         22 :           tree context = outermost_open_class ();</span>
<span class="lineNum">   16251 </span><span class="lineCov">         22 :           incomplete_var iv = {var, context};</span>
<span class="lineNum">   16252 </span><span class="lineCov">         22 :           vec_safe_push (incomplete_vars, iv);</span>
<span class="lineNum">   16253 </span>            :         }
<span class="lineNum">   16254 </span>            :     }
<span class="lineNum">   16255 </span><span class="lineCov">    5250817 : }</span>
<span class="lineNum">   16256 </span>            : 
<span class="lineNum">   16257 </span>            : /* Called when a class type (given by TYPE) is defined.  If there are
<span class="lineNum">   16258 </span>            :    any existing VAR_DECLs whose type has been completed by this
<span class="lineNum">   16259 </span>            :    declaration, update them now.  */
<a name="16260"><span class="lineNum">   16260 </span>            : </a>
<span class="lineNum">   16261 </span>            : void
<span class="lineNum">   16262 </span><span class="lineCov">   10363440 : complete_vars (tree type)</span>
<span class="lineNum">   16263 </span>            : {
<span class="lineNum">   16264 </span><span class="lineCov">   10363440 :   unsigned ix;</span>
<span class="lineNum">   16265 </span><span class="lineCov">   10363440 :   incomplete_var *iv;</span>
<span class="lineNum">   16266 </span>            : 
<span class="lineNum">   16267 </span><span class="lineCov">  235266553 :   for (ix = 0; vec_safe_iterate (incomplete_vars, ix, &amp;iv); )</span>
<span class="lineNum">   16268 </span>            :     {
<span class="lineNum">   16269 </span><span class="lineCov">  224903113 :       if (same_type_p (type, iv-&gt;incomplete_type))</span>
<span class="lineNum">   16270 </span>            :         {
<span class="lineNum">   16271 </span><span class="lineCov">        466 :           tree var = iv-&gt;decl;</span>
<span class="lineNum">   16272 </span><span class="lineCov">        466 :           tree type = TREE_TYPE (var);</span>
<span class="lineNum">   16273 </span>            : 
<span class="lineNum">   16274 </span><span class="lineCov">        466 :           if (type != error_mark_node</span>
<span class="lineNum">   16275 </span><span class="lineCov">        466 :               &amp;&amp; (TYPE_MAIN_VARIANT (strip_array_types (type))</span>
<span class="lineNum">   16276 </span><span class="lineCov">        463 :                   == iv-&gt;incomplete_type))</span>
<span class="lineNum">   16277 </span>            :             {
<span class="lineNum">   16278 </span>            :               /* Complete the type of the variable.  The VAR_DECL itself
<span class="lineNum">   16279 </span>            :                  will be laid out in expand_expr.  */
<span class="lineNum">   16280 </span><span class="lineCov">        441 :               complete_type (type);</span>
<span class="lineNum">   16281 </span><span class="lineCov">        441 :               cp_apply_type_quals_to_decl (cp_type_quals (type), var);</span>
<span class="lineNum">   16282 </span>            :             }
<span class="lineNum">   16283 </span>            : 
<span class="lineNum">   16284 </span>            :           /* Remove this entry from the list.  */
<span class="lineNum">   16285 </span><span class="lineCov">        466 :           incomplete_vars-&gt;unordered_remove (ix);</span>
<span class="lineNum">   16286 </span>            :         }
<span class="lineNum">   16287 </span>            :       else
<span class="lineNum">   16288 </span><span class="lineCov">  224902647 :         ix++;</span>
<span class="lineNum">   16289 </span>            :     }
<span class="lineNum">   16290 </span>            : 
<span class="lineNum">   16291 </span>            :   /* Check for pending declarations which may have abstract type.  */
<span class="lineNum">   16292 </span><span class="lineCov">   10363440 :   complete_type_check_abstract (type);</span>
<span class="lineNum">   16293 </span><span class="lineCov">   10363440 : }</span>
<span class="lineNum">   16294 </span>            : 
<span class="lineNum">   16295 </span>            : /* If DECL is of a type which needs a cleanup, build and return an
<span class="lineNum">   16296 </span>            :    expression to perform that cleanup here.  Return NULL_TREE if no
<span class="lineNum">   16297 </span>            :    cleanup need be done.  DECL can also be a _REF when called from
<span class="lineNum">   16298 </span>            :    split_nonconstant_init_1.  */
<a name="16299"><span class="lineNum">   16299 </span>            : </a>
<span class="lineNum">   16300 </span>            : tree
<span class="lineNum">   16301 </span><span class="lineCov">    5002656 : cxx_maybe_build_cleanup (tree decl, tsubst_flags_t complain)</span>
<span class="lineNum">   16302 </span>            : {
<span class="lineNum">   16303 </span><span class="lineCov">    5002656 :   tree type;</span>
<span class="lineNum">   16304 </span><span class="lineCov">    5002656 :   tree attr;</span>
<span class="lineNum">   16305 </span><span class="lineCov">    5002656 :   tree cleanup;</span>
<span class="lineNum">   16306 </span>            : 
<span class="lineNum">   16307 </span>            :   /* Assume no cleanup is required.  */
<span class="lineNum">   16308 </span><span class="lineCov">    5002656 :   cleanup = NULL_TREE;</span>
<span class="lineNum">   16309 </span>            : 
<span class="lineNum">   16310 </span><span class="lineCov">    5002656 :   if (error_operand_p (decl))</span>
<span class="lineNum">   16311 </span>            :     return cleanup;
<span class="lineNum">   16312 </span>            : 
<span class="lineNum">   16313 </span>            :   /* Handle &quot;__attribute__((cleanup))&quot;.  We run the cleanup function
<span class="lineNum">   16314 </span>            :      before the destructor since the destructor is what actually
<span class="lineNum">   16315 </span>            :      terminates the lifetime of the object.  */
<span class="lineNum">   16316 </span><span class="lineCov">    5002656 :   if (DECL_P (decl))</span>
<span class="lineNum">   16317 </span><span class="lineCov">    4958388 :     attr = lookup_attribute (&quot;cleanup&quot;, DECL_ATTRIBUTES (decl));</span>
<span class="lineNum">   16318 </span>            :   else
<span class="lineNum">   16319 </span>            :     attr = NULL_TREE;
<span class="lineNum">   16320 </span><span class="lineCov">    4958388 :   if (attr)</span>
<span class="lineNum">   16321 </span>            :     {
<span class="lineNum">   16322 </span><span class="lineCov">         81 :       tree id;</span>
<span class="lineNum">   16323 </span><span class="lineCov">         81 :       tree fn;</span>
<span class="lineNum">   16324 </span><span class="lineCov">         81 :       tree arg;</span>
<span class="lineNum">   16325 </span>            : 
<span class="lineNum">   16326 </span>            :       /* Get the name specified by the user for the cleanup function.  */
<span class="lineNum">   16327 </span><span class="lineCov">         81 :       id = TREE_VALUE (TREE_VALUE (attr));</span>
<span class="lineNum">   16328 </span>            :       /* Look up the name to find the cleanup function to call.  It is
<span class="lineNum">   16329 </span>            :          important to use lookup_name here because that is what is
<span class="lineNum">   16330 </span>            :          used in c-common.c:handle_cleanup_attribute when performing
<span class="lineNum">   16331 </span>            :          initial checks on the attribute.  Note that those checks
<span class="lineNum">   16332 </span>            :          include ensuring that the function found is not an overloaded
<span class="lineNum">   16333 </span>            :          function, or an object with an overloaded call operator,
<span class="lineNum">   16334 </span>            :          etc.; we can rely on the fact that the function found is an
<span class="lineNum">   16335 </span>            :          ordinary FUNCTION_DECL.  */
<span class="lineNum">   16336 </span><span class="lineCov">         81 :       fn = lookup_name (id);</span>
<span class="lineNum">   16337 </span><span class="lineCov">         81 :       arg = build_address (decl);</span>
<span class="lineNum">   16338 </span><span class="lineCov">         81 :       if (!mark_used (decl, complain) &amp;&amp; !(complain &amp; tf_error))</span>
<span class="lineNum">   16339 </span><span class="lineNoCov">          0 :         return error_mark_node;</span>
<span class="lineNum">   16340 </span><span class="lineCov">         81 :       cleanup = cp_build_function_call_nary (fn, complain, arg, NULL_TREE);</span>
<span class="lineNum">   16341 </span><span class="lineCov">         81 :       if (cleanup == error_mark_node)</span>
<span class="lineNum">   16342 </span>            :         return error_mark_node;
<span class="lineNum">   16343 </span>            :     }
<span class="lineNum">   16344 </span>            :   /* Handle ordinary C++ destructors.  */
<span class="lineNum">   16345 </span><span class="lineCov">    5002650 :   type = TREE_TYPE (decl);</span>
<span class="lineNum">   16346 </span><span class="lineCov">    5002650 :   if (type_build_dtor_call (type))</span>
<span class="lineNum">   16347 </span>            :     {
<span class="lineNum">   16348 </span><span class="lineCov">     759439 :       int flags = LOOKUP_NORMAL|LOOKUP_NONVIRTUAL|LOOKUP_DESTRUCTOR;</span>
<span class="lineNum">   16349 </span><span class="lineCov">     759439 :       tree addr;</span>
<span class="lineNum">   16350 </span><span class="lineCov">     759439 :       tree call;</span>
<span class="lineNum">   16351 </span>            : 
<span class="lineNum">   16352 </span><span class="lineCov">     759439 :       if (TREE_CODE (type) == ARRAY_TYPE)</span>
<span class="lineNum">   16353 </span>            :         addr = decl;
<span class="lineNum">   16354 </span>            :       else
<span class="lineNum">   16355 </span><span class="lineCov">     758591 :         addr = build_address (decl);</span>
<span class="lineNum">   16356 </span>            : 
<span class="lineNum">   16357 </span><span class="lineCov">     759439 :       call = build_delete (TREE_TYPE (addr), addr,</span>
<span class="lineNum">   16358 </span>            :                            sfk_complete_destructor, flags, 0, complain);
<span class="lineNum">   16359 </span><span class="lineCov">     759439 :       if (call == error_mark_node)</span>
<span class="lineNum">   16360 </span>            :         cleanup = error_mark_node;
<span class="lineNum">   16361 </span><span class="lineCov">     759423 :       else if (TYPE_HAS_TRIVIAL_DESTRUCTOR (type))</span>
<span class="lineNum">   16362 </span>            :         /* Discard the call.  */;
<span class="lineNum">   16363 </span><span class="lineCov">     688590 :       else if (cleanup)</span>
<span class="lineNum">   16364 </span><span class="lineCov">          3 :         cleanup = cp_build_compound_expr (cleanup, call, complain);</span>
<span class="lineNum">   16365 </span>            :       else
<span class="lineNum">   16366 </span>            :         cleanup = call;
<span class="lineNum">   16367 </span>            :     }
<span class="lineNum">   16368 </span>            : 
<span class="lineNum">   16369 </span>            :   /* build_delete sets the location of the destructor call to the
<span class="lineNum">   16370 </span>            :      current location, even though the destructor is going to be
<span class="lineNum">   16371 </span>            :      called later, at the end of the current scope.  This can lead to
<span class="lineNum">   16372 </span>            :      a &quot;jumpy&quot; behavior for users of debuggers when they step around
<span class="lineNum">   16373 </span>            :      the end of the block.  So let's unset the location of the
<span class="lineNum">   16374 </span>            :      destructor call instead.  */
<span class="lineNum">   16375 </span><span class="lineCov">    5002650 :   protected_set_expr_location (cleanup, UNKNOWN_LOCATION);</span>
<span class="lineNum">   16376 </span>            : 
<span class="lineNum">   16377 </span><span class="lineCov">    5002650 :   if (cleanup</span>
<span class="lineNum">   16378 </span><span class="lineCov">     688678 :       &amp;&amp; DECL_P (decl)</span>
<span class="lineNum">   16379 </span><span class="lineCov">     688624 :       &amp;&amp; !lookup_attribute (&quot;warn_unused&quot;, TYPE_ATTRIBUTES (TREE_TYPE (decl)))</span>
<span class="lineNum">   16380 </span>            :       /* Treat objects with destructors as used; the destructor may do
<span class="lineNum">   16381 </span>            :          something substantive.  */
<span class="lineNum">   16382 </span><span class="lineCov">    5691268 :       &amp;&amp; !mark_used (decl, complain) &amp;&amp; !(complain &amp; tf_error))</span>
<span class="lineNum">   16383 </span><span class="lineNoCov">          0 :     return error_mark_node;</span>
<span class="lineNum">   16384 </span>            : 
<span class="lineNum">   16385 </span>            :   return cleanup;
<span class="lineNum">   16386 </span>            : }
<span class="lineNum">   16387 </span>            : 
<span class="lineNum">   16388 </span>            : 
<span class="lineNum">   16389 </span>            : /* Return the FUNCTION_TYPE that corresponds to MEMFNTYPE, which can be a
<span class="lineNum">   16390 </span>            :    FUNCTION_DECL, METHOD_TYPE, FUNCTION_TYPE, pointer or reference to
<span class="lineNum">   16391 </span>            :    METHOD_TYPE or FUNCTION_TYPE, or pointer to member function.  */
<a name="16392"><span class="lineNum">   16392 </span>            : </a>
<span class="lineNum">   16393 </span>            : tree
<span class="lineNum">   16394 </span><span class="lineCov">     556703 : static_fn_type (tree memfntype)</span>
<span class="lineNum">   16395 </span>            : {
<span class="lineNum">   16396 </span><span class="lineCov">     556703 :   tree fntype;</span>
<span class="lineNum">   16397 </span><span class="lineCov">     556703 :   tree args;</span>
<span class="lineNum">   16398 </span>            : 
<span class="lineNum">   16399 </span><span class="lineCov">     556703 :   if (TYPE_PTRMEMFUNC_P (memfntype))</span>
<span class="lineNum">   16400 </span><span class="lineCov">      38521 :     memfntype = TYPE_PTRMEMFUNC_FN_TYPE (memfntype);</span>
<span class="lineNum">   16401 </span><span class="lineCov">     556703 :   if (INDIRECT_TYPE_P (memfntype)</span>
<span class="lineNum">   16402 </span><span class="lineCov">     382220 :       || TREE_CODE (memfntype) == FUNCTION_DECL)</span>
<span class="lineNum">   16403 </span><span class="lineCov">     551183 :     memfntype = TREE_TYPE (memfntype);</span>
<span class="lineNum">   16404 </span><span class="lineCov">     556703 :   if (TREE_CODE (memfntype) == FUNCTION_TYPE)</span>
<span class="lineNum">   16405 </span>            :     return memfntype;
<span class="lineNum">   16406 </span><span class="lineCov">      93522 :   gcc_assert (TREE_CODE (memfntype) == METHOD_TYPE);</span>
<span class="lineNum">   16407 </span><span class="lineCov">      93522 :   args = TYPE_ARG_TYPES (memfntype);</span>
<span class="lineNum">   16408 </span><span class="lineCov">      93522 :   fntype = build_function_type (TREE_TYPE (memfntype), TREE_CHAIN (args));</span>
<span class="lineNum">   16409 </span><span class="lineCov">      93522 :   fntype = apply_memfn_quals (fntype, type_memfn_quals (memfntype));</span>
<span class="lineNum">   16410 </span><span class="lineCov">      93522 :   fntype = (cp_build_type_attribute_variant</span>
<span class="lineNum">   16411 </span><span class="lineCov">      93522 :             (fntype, TYPE_ATTRIBUTES (memfntype)));</span>
<span class="lineNum">   16412 </span><span class="lineCov">      93522 :   fntype = cxx_copy_lang_qualifiers (fntype, memfntype);</span>
<span class="lineNum">   16413 </span><span class="lineCov">      93522 :   return fntype;</span>
<span class="lineNum">   16414 </span>            : }
<span class="lineNum">   16415 </span>            : 
<span class="lineNum">   16416 </span>            : /* DECL was originally constructed as a non-static member function,
<span class="lineNum">   16417 </span>            :    but turned out to be static.  Update it accordingly.  */
<a name="16418"><span class="lineNum">   16418 </span>            : </a>
<span class="lineNum">   16419 </span>            : void
<span class="lineNum">   16420 </span><span class="lineCov">      20514 : revert_static_member_fn (tree decl)</span>
<span class="lineNum">   16421 </span>            : {
<span class="lineNum">   16422 </span><span class="lineCov">      20514 :   tree stype = static_fn_type (decl);</span>
<span class="lineNum">   16423 </span><span class="lineCov">      20514 :   cp_cv_quals quals = type_memfn_quals (stype);</span>
<span class="lineNum">   16424 </span><span class="lineCov">      20514 :   cp_ref_qualifier rqual = type_memfn_rqual (stype);</span>
<span class="lineNum">   16425 </span>            : 
<span class="lineNum">   16426 </span><span class="lineCov">      20514 :   if (quals != TYPE_UNQUALIFIED || rqual != REF_QUAL_NONE)</span>
<span class="lineNum">   16427 </span><span class="lineCov">          7 :     stype = apply_memfn_quals (stype, TYPE_UNQUALIFIED, REF_QUAL_NONE);</span>
<span class="lineNum">   16428 </span>            : 
<span class="lineNum">   16429 </span><span class="lineCov">      20514 :   TREE_TYPE (decl) = stype;</span>
<span class="lineNum">   16430 </span>            : 
<span class="lineNum">   16431 </span><span class="lineCov">      20514 :   if (DECL_ARGUMENTS (decl))</span>
<span class="lineNum">   16432 </span><span class="lineCov">      41028 :     DECL_ARGUMENTS (decl) = DECL_CHAIN (DECL_ARGUMENTS (decl));</span>
<span class="lineNum">   16433 </span><span class="lineCov">      20514 :   DECL_STATIC_FUNCTION_P (decl) = 1;</span>
<span class="lineNum">   16434 </span><span class="lineCov">      20514 : }</span>
<span class="lineNum">   16435 </span>            : 
<span class="lineNum">   16436 </span>            : /* Return which tree structure is used by T, or TS_CP_GENERIC if T is
<span class="lineNum">   16437 </span>            :    one of the language-independent trees.  */
<a name="16438"><span class="lineNum">   16438 </span>            : </a>
<span class="lineNum">   16439 </span>            : enum cp_tree_node_structure_enum
<span class="lineNum">   16440 </span><span class="lineCov"> 3106541420 : cp_tree_node_structure (union lang_tree_node * t)</span>
<span class="lineNum">   16441 </span>            : {
<span class="lineNum">   16442 </span><span class="lineCov"> 3106541420 :   switch (TREE_CODE (&amp;t-&gt;generic))</span>
<span class="lineNum">   16443 </span>            :     {
<span class="lineNum">   16444 </span>            :     case DEFAULT_ARG:           return TS_CP_DEFAULT_ARG;
<span class="lineNum">   16445 </span><span class="lineCov">     448608 :     case DEFERRED_NOEXCEPT:     return TS_CP_DEFERRED_NOEXCEPT;</span>
<span class="lineNum">   16446 </span><span class="lineCov">  197940795 :     case IDENTIFIER_NODE:       return TS_CP_IDENTIFIER;</span>
<span class="lineNum">   16447 </span><span class="lineCov">   67727909 :     case OVERLOAD:              return TS_CP_OVERLOAD;</span>
<span class="lineNum">   16448 </span><span class="lineCov">   51392020 :     case TEMPLATE_PARM_INDEX:   return TS_CP_TPI;</span>
<span class="lineNum">   16449 </span><span class="lineCov">          8 :     case PTRMEM_CST:            return TS_CP_PTRMEM;</span>
<span class="lineNum">   16450 </span><span class="lineCov">   13423873 :     case BASELINK:              return TS_CP_BASELINK;</span>
<span class="lineNum">   16451 </span><span class="lineCov">   61999728 :     case TEMPLATE_DECL:         return TS_CP_TEMPLATE_DECL;</span>
<span class="lineNum">   16452 </span><span class="lineCov">     457824 :     case STATIC_ASSERT:         return TS_CP_STATIC_ASSERT;</span>
<span class="lineNum">   16453 </span><span class="lineNoCov">          0 :     case ARGUMENT_PACK_SELECT:  return TS_CP_ARGUMENT_PACK_SELECT;</span>
<span class="lineNum">   16454 </span><span class="lineCov">     525989 :     case TRAIT_EXPR:            return TS_CP_TRAIT_EXPR;</span>
<span class="lineNum">   16455 </span><span class="lineCov">      57745 :     case LAMBDA_EXPR:           return TS_CP_LAMBDA_EXPR;</span>
<span class="lineNum">   16456 </span><span class="lineCov">  153889700 :     case TEMPLATE_INFO:         return TS_CP_TEMPLATE_INFO;</span>
<span class="lineNum">   16457 </span><span class="lineNoCov">          0 :     case CONSTRAINT_INFO:       return TS_CP_CONSTRAINT_INFO;</span>
<span class="lineNum">   16458 </span><span class="lineCov">      95369 :     case USERDEF_LITERAL:       return TS_CP_USERDEF_LITERAL;</span>
<span class="lineNum">   16459 </span><span class="lineCov"> 2558540649 :     default:                    return TS_CP_GENERIC;</span>
<span class="lineNum">   16460 </span>            :     }
<span class="lineNum">   16461 </span>            : }
<span class="lineNum">   16462 </span>            : 
<a name="16463"><span class="lineNum">   16463 </span>            : /* Build the void_list_node (void_type_node having been created).  */</a>
<span class="lineNum">   16464 </span>            : tree
<span class="lineNum">   16465 </span><span class="lineCov">      57757 : build_void_list_node (void)</span>
<span class="lineNum">   16466 </span>            : {
<span class="lineNum">   16467 </span><span class="lineCov">      57757 :   tree t = build_tree_list (NULL_TREE, void_type_node);</span>
<span class="lineNum">   16468 </span><span class="lineCov">      57757 :   return t;</span>
<span class="lineNum">   16469 </span>            : }
<a name="16470"><span class="lineNum">   16470 </span>            : </a>
<span class="lineNum">   16471 </span>            : bool
<span class="lineNum">   16472 </span><span class="lineCov">       5622 : cp_missing_noreturn_ok_p (tree decl)</span>
<span class="lineNum">   16473 </span>            : {
<span class="lineNum">   16474 </span>            :   /* A missing noreturn is ok for the `main' function.  */
<span class="lineNum">   16475 </span><span class="lineCov">       5622 :   return DECL_MAIN_P (decl);</span>
<span class="lineNum">   16476 </span>            : }
<span class="lineNum">   16477 </span>            : 
<span class="lineNum">   16478 </span>            : /* Return the decl used to identify the COMDAT group into which DECL should
<span class="lineNum">   16479 </span>            :    be placed.  */
<a name="16480"><span class="lineNum">   16480 </span>            : </a>
<span class="lineNum">   16481 </span>            : tree
<span class="lineNum">   16482 </span><span class="lineCov">   13131158 : cxx_comdat_group (tree decl)</span>
<span class="lineNum">   16483 </span>            : {
<span class="lineNum">   16484 </span>            :   /* Virtual tables, construction virtual tables, and virtual table
<span class="lineNum">   16485 </span>            :      tables all go in a single COMDAT group, named after the primary
<span class="lineNum">   16486 </span>            :      virtual table.  */
<span class="lineNum">   16487 </span><span class="lineCov">   13131158 :   if (VAR_P (decl) &amp;&amp; DECL_VTABLE_OR_VTT_P (decl))</span>
<span class="lineNum">   16488 </span><span class="lineCov">     196519 :     decl = CLASSTYPE_VTABLES (DECL_CONTEXT (decl));</span>
<span class="lineNum">   16489 </span>            :   /* For all other DECLs, the COMDAT group is the mangled name of the
<span class="lineNum">   16490 </span>            :      declaration itself.  */
<span class="lineNum">   16491 </span>            :   else
<span class="lineNum">   16492 </span>            :     {
<span class="lineNum">   16493 </span><span class="lineCov">   12934639 :       while (DECL_THUNK_P (decl))</span>
<span class="lineNum">   16494 </span>            :         {
<span class="lineNum">   16495 </span>            :           /* If TARGET_USE_LOCAL_THUNK_ALIAS_P, use_thunk puts the thunk
<span class="lineNum">   16496 </span>            :              into the same section as the target function.  In that case
<span class="lineNum">   16497 </span>            :              we must return target's name.  */
<span class="lineNum">   16498 </span><span class="lineNoCov">          0 :           tree target = THUNK_TARGET (decl);</span>
<span class="lineNum">   16499 </span><span class="lineNoCov">          0 :           if (TARGET_USE_LOCAL_THUNK_ALIAS_P (target)</span>
<span class="lineNum">   16500 </span><span class="lineNoCov">          0 :               &amp;&amp; DECL_SECTION_NAME (target) != NULL</span>
<span class="lineNum">   16501 </span><span class="lineNoCov">          0 :               &amp;&amp; DECL_ONE_ONLY (target))</span>
<span class="lineNum">   16502 </span>            :             decl = target;
<span class="lineNum">   16503 </span>            :           else
<span class="lineNum">   16504 </span>            :             break;
<span class="lineNum">   16505 </span>            :         }
<span class="lineNum">   16506 </span>            :     }
<span class="lineNum">   16507 </span>            : 
<span class="lineNum">   16508 </span><span class="lineCov">   13131158 :   return decl;</span>
<span class="lineNum">   16509 </span>            : }
<span class="lineNum">   16510 </span>            : 
<span class="lineNum">   16511 </span>            : /* Returns the return type for FN as written by the user, which may include
<span class="lineNum">   16512 </span>            :    a placeholder for a deduced return type.  */
<a name="16513"><span class="lineNum">   16513 </span>            : </a>
<span class="lineNum">   16514 </span>            : tree
<span class="lineNum">   16515 </span><span class="lineCov">    8238170 : fndecl_declared_return_type (tree fn)</span>
<span class="lineNum">   16516 </span>            : {
<span class="lineNum">   16517 </span><span class="lineCov">    8238170 :   fn = STRIP_TEMPLATE (fn);</span>
<span class="lineNum">   16518 </span><span class="lineCov">    8238170 :   if (FNDECL_USED_AUTO (fn))</span>
<span class="lineNum">   16519 </span>            :     {
<span class="lineNum">   16520 </span><span class="lineCov">         33 :       struct language_function *f = NULL;</span>
<span class="lineNum">   16521 </span><span class="lineCov">         66 :       if (DECL_STRUCT_FUNCTION (fn))</span>
<span class="lineNum">   16522 </span><span class="lineCov">         33 :         f = DECL_STRUCT_FUNCTION (fn)-&gt;language;</span>
<span class="lineNum">   16523 </span><span class="lineCov">         33 :       if (f == NULL)</span>
<span class="lineNum">   16524 </span><span class="lineNoCov">          0 :         f = DECL_SAVED_FUNCTION_DATA (fn);</span>
<span class="lineNum">   16525 </span><span class="lineCov">         33 :       return f-&gt;x_auto_return_pattern;</span>
<span class="lineNum">   16526 </span>            :     }
<span class="lineNum">   16527 </span><span class="lineCov">    8238137 :   return TREE_TYPE (TREE_TYPE (fn));</span>
<span class="lineNum">   16528 </span>            : }
<span class="lineNum">   16529 </span>            : 
<span class="lineNum">   16530 </span>            : /* Returns true iff DECL is a variable or function declared with an auto type
<span class="lineNum">   16531 </span>            :    that has not yet been deduced to a real type.  */
<a name="16532"><span class="lineNum">   16532 </span>            : </a>
<span class="lineNum">   16533 </span>            : bool
<span class="lineNum">   16534 </span><span class="lineCov">   73398823 : undeduced_auto_decl (tree decl)</span>
<span class="lineNum">   16535 </span>            : {
<span class="lineNum">   16536 </span><span class="lineCov">   73398823 :   if (cxx_dialect &lt; cxx11)</span>
<span class="lineNum">   16537 </span>            :     return false;
<span class="lineNum">   16538 </span><span class="lineCov">   72061683 :   return ((VAR_OR_FUNCTION_DECL_P (decl)</span>
<span class="lineNum">   16539 </span><span class="lineCov">   39861390 :            || TREE_CODE (decl) == TEMPLATE_DECL)</span>
<span class="lineNum">   16540 </span><span class="lineCov">   72129223 :           &amp;&amp; type_uses_auto (TREE_TYPE (decl)));</span>
<span class="lineNum">   16541 </span>            : }
<span class="lineNum">   16542 </span>            : 
<span class="lineNum">   16543 </span>            : /* Complain if DECL has an undeduced return type.  */
<a name="16544"><span class="lineNum">   16544 </span>            : </a>
<span class="lineNum">   16545 </span>            : bool
<span class="lineNum">   16546 </span><span class="lineCov">   43910276 : require_deduced_type (tree decl, tsubst_flags_t complain)</span>
<span class="lineNum">   16547 </span>            : {
<span class="lineNum">   16548 </span><span class="lineCov">   43910276 :   if (undeduced_auto_decl (decl))</span>
<span class="lineNum">   16549 </span>            :     {
<span class="lineNum">   16550 </span><span class="lineCov">         26 :       if (complain &amp; tf_error)</span>
<span class="lineNum">   16551 </span><span class="lineCov">         24 :         error (&quot;use of %qD before deduction of %&lt;auto%&gt;&quot;, decl);</span>
<span class="lineNum">   16552 </span><span class="lineCov">         26 :       return false;</span>
<span class="lineNum">   16553 </span>            :     }
<span class="lineNum">   16554 </span>            :   return true;
<span class="lineNum">   16555 </span>            : }
<span class="lineNum">   16556 </span>            : 
<span class="lineNum">   16557 </span>            : #include &quot;gt-cp-decl.h&quot;
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.0</a></td></tr>
  </table>
  <br>
<h3>LCOV profile is generated on x86_64 machine using following configure options: configure --disable-bootstrap --enable-coverage=opt --enable-languages=c,c++,fortran,go,jit,lto --enable-host-shared. GCC test suite is run with the built compiler.</h3></body></html>
